<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Raku 学习手册 :: 山川异域, 风月同天</title>

<meta name="author" content="ohmyraku">
<meta name="application-name" content="山川异域, 风月同天">
<meta name="description" content="1. 介绍 本章是该语言的全貌图; 如果你还不了解正在发生的一切，请不要担心。担心如果你到了本书的最后，你仍然没有了解全部！有讲很多东西，所以将围绕一些话题，重新审视其他话题，并通过一些练习看看它们是如何融合在一起的 - 这真的都是关于实践的。
 1.1. 为什么是 Raku? 对于初学者，你要学习 Raku。你也可能通过使用这种语言来使得物有所值！
 但是什么使这种语言变得有吸引力？ Perl 家族一直喜欢 DWIM-Do What I Mean。你经常做的事情应该很容易做，而最困难的事情应该是可能的。任何编程语言的用处都可以通过它解决问题的程度来衡量。
 Raku 是一种出色的文本处理语言 - 甚至可能比 Perl 5 更好。正则表达式（第15章）有许多令人兴奋的新功能，可以更容易地匹配和提取文本。内置 grammar（第17章）功能允许你轻松编写复杂的规则来处理和响应文本。
 渐进类型（第3章）允许你注释变量，并限制你可以存储的内容。例如，你可以指定数字必须是整数，正数或两个其他数字之间的数。你不必必须使用它（这是渐进的部分）。你将能够注释子例程接受什么以及它应该返回什么。这可以快速揭示数据边界的错误。
 内置并发（第18章）功能允许你将问题分解为单独运行并可能同时运行的部分。该语言为你处理大部分内容。
 惰性列表和无限列表允许你处理序列而无需过多复制或甚至一次拥有整个列表（第6章）。你可以轻松创建自己的无限惰性列表。
 我可以继续前进，但是当你按照本书的方式工作时，你会遇到更多令人惊叹的功能。
 有时你不想使用 Raku。没有语言能适用所有的工作。如果你更喜欢其他更好的东西，或者可以使用不同的工具更快地完成任务，那么对你来说更强大！但是，我希望本书可以帮助你在 Raku 中快速有效地完成你需要做的事情。
  1.2. First Steps with the REPL REPL 是一个 Read-Evaluate-Print-Loop 的工具，提供交互式提示。 REPL 计算你键入的代码，显示结果，然后再次提示你。这是尝试代码片段的快速方法。当你运行不带参数的 raku 时，它会启动它的 REPL：
 % raku To exit type &#39;exit&#39; or &#39;^D&#39; &gt;   &gt; 是等待你输入内容的提示。当你键入 Return 时，REPL 开始工作。通过使两个数字相加来尝试 REPL：">
<meta name="robots" content="noodp"/>
<meta name="generator" content="Hugo 0.79.0" />
<meta name="referrer" content="no-referrer" />
<meta name="format-detection" content="telephone=no">

<link rel="canonical" href="https://ohmyraku.github.io/learning-raku/" />


<link rel="icon" href="https://ohmyraku.github.io/logo.png" />

<link rel="stylesheet" href="https://ohmyraku.github.io/scss/main.min.84f71d25d375c522a861bb4719728ce6839cf3635b15ca0c7a1b4d799c2dc3399a1d6cb46058a9d8fdbebe9156a8857279cfdeb70aa3862e629de234b5a41fa1.css" integrity="sha512-hPcdJdN1xSKoYbtHGXKM5oOc82NbFcoMehtNeZwtwzmaHWy0YFip2P2&#43;vpFWqIVyec/etwqjhi5ineI0taQfoQ==">
<script>

const theme = window.localStorage.getItem('theme'); 
if (theme && theme !== "1") {
    document.documentElement.classList.add('theme-' + theme);
}
</script>


</head>
<body>
  <main class="site__content">
    <div class="site__page">
  <nav class="site__breadcrumbs">
    <a class="site__breadcrumb" href="https://ohmyraku.github.io/">山川异域, 风月同天</a><a class="site__breadcrumb--active" href="https://ohmyraku.github.io/learning-raku/">Raku 学习手册</a>
</nav>

<h1 class="page__title">Raku 学习手册</h1>
  <div class="page__meta">
    <p>
    
    <span class="page__date">
    on <time datetime="2020-02-05T15:26:52&#43;08:00">2020-02-05</time>
    
    </span>
    </p>

    

    
    </div>
</div>


<div class="page__toc">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#_介绍">1. 介绍</a>
      <ul>
        <li><a href="#_为什么是_raku">1.1. 为什么是 Raku?</a></li>
        <li><a href="#_first_steps_with_the_repl">1.2. First Steps with the REPL</a></li>
        <li><a href="#_阅读文档">1.3. 阅读文档</a></li>
        <li><a href="#_基础语法">1.4. 基础语法</a></li>
        <li><a href="#_variables">1.5. Variables</a></li>
        <li><a href="#_making_and_running_a_program">1.6. Making and Running a Program</a></li>
        <li><a href="#_总结">1.7. 总结</a></li>
        <li><a href="#_绑定和赋值">1.8. 绑定和赋值</a></li>
        <li><a href="#_a_main_program">1.9. A MAIN Program</a></li>
        <li><a href="#_literal_numbers">1.10. Literal Numbers</a></li>
        <li><a href="#_numeric_operations">1.11. Numeric Operations</a></li>
        <li><a href="#_conditional_execution">1.12. Conditional Execution</a></li>
        <li><a href="#_putting_it_all_together">1.13. Putting It All Together</a></li>
        <li><a href="#_summary">1.14. Summary</a></li>
        <li><a href="#_number_types">1.15. Number Types</a></li>
        <li><a href="#_integers">1.16. Integers</a></li>
        <li><a href="#_有理数">1.17. 有理数</a></li>
        <li><a href="#_imaginary_and_complex_numbers">1.18. Imaginary and Complex Numbers</a></li>
        <li><a href="#_numbers_small_and_large">1.19. Numbers Small and Large</a></li>
        <li><a href="#_the_numeric_hierarchy">1.20. The Numeric Hierarchy</a></li>
        <li><a href="#_总结_2">1.21. 总结</a></li>
      </ul>
    </li>
    <li><a href="#_字符串">2. 字符串</a>
      <ul>
        <li><a href="#_literal_quoting">2.1. Literal Quoting</a></li>
        <li><a href="#_escaped_strings">2.2. Escaped Strings</a></li>
        <li><a href="#_interpolated_strings">2.3. Interpolated Strings</a></li>
        <li><a href="#_here_docs">2.4. Here Docs</a></li>
        <li><a href="#_shell_strings">2.5. Shell Strings</a></li>
        <li><a href="#_fancier_quoting">2.6. Fancier Quoting</a></li>
        <li><a href="#_summary_2">2.7. Summary</a></li>
        <li><a href="#_存储_blocks">2.8. 存储 Blocks</a></li>
        <li><a href="#_简单子例程">2.9. 简单子例程</a></li>
        <li><a href="#_whatever_code">2.10. Whatever Code</a></li>
        <li><a href="#_总结_3">2.11. 总结</a></li>
      </ul>
    </li>
    <li><a href="#_positionals">3. Positionals</a>
      <ul>
        <li><a href="#_constructing_a_list">3.1. Constructing a List</a></li>
        <li><a href="#_ranges">3.2. Ranges</a></li>
        <li><a href="#_sequences">3.3. Sequences</a></li>
        <li><a href="#_single_element_access">3.4. Single-Element Access</a></li>
        <li><a href="#_arrays">3.5. Arrays</a></li>
        <li><a href="#_combining_lists">3.6. Combining Lists</a></li>
        <li><a href="#_filtering_lists">3.7. Filtering Lists</a></li>
        <li><a href="#_transforming_a_list">3.8. Transforming a List</a></li>
        <li><a href="#_sorting_lists">3.9. Sorting Lists</a></li>
        <li><a href="#_sorting_on_multiple_comparisons">3.10. Sorting on Multiple Comparisons</a></li>
        <li><a href="#_summary_3">3.11. Summary</a></li>
      </ul>
    </li>
    <li><a href="#_当出错的时候">4. 当出错的时候</a>
      <ul>
        <li><a href="#_异常">4.1. 异常</a></li>
        <li><a href="#_failures">4.2. Failures</a></li>
        <li><a href="#_warnings">4.3. Warnings</a></li>
        <li><a href="#_the_wisdom_of_exceptions">4.4. The Wisdom of Exceptions</a></li>
        <li><a href="#_summary_4">4.5. Summary</a></li>
        <li><a href="#_文件路径">4.6. 文件路径</a></li>
        <li><a href="#_操作目录">4.7. 操作目录</a></li>
        <li><a href="#_格式化输出">4.8. 格式化输出</a></li>
        <li><a href="#_标准文件句柄">4.9. 标准文件句柄</a></li>
        <li><a href="#_读取输入">4.10. 读取输入</a></li>
        <li><a href="#_写出">4.11. 写出</a></li>
        <li><a href="#_二进制文件">4.12. 二进制文件</a></li>
        <li><a href="#_总结_4">4.13. 总结</a></li>
        <li><a href="#_pairs">4.14. Pairs</a></li>
        <li><a href="#_maps">4.15. Maps</a></li>
        <li><a href="#_hashes">4.16. Hashes</a></li>
        <li><a href="#_multilevel_hashes">4.17. Multilevel Hashes</a></li>
        <li><a href="#_总结_5">4.18. 总结</a></li>
        <li><a href="#_installing_modules">4.19. Installing Modules</a></li>
        <li><a href="#_加载模块">4.20. 加载模块</a></li>
        <li><a href="#_从_web_抓取数据">4.21. 从 Web 抓取数据</a></li>
        <li><a href="#_在_raku_中运行_perl_5">4.22. 在 Raku 中运行 Perl 5</a></li>
        <li><a href="#_总结_6">4.23. 总结</a></li>
        <li><a href="#_a_basic_subroutine">4.24. A Basic Subroutine</a></li>
        <li><a href="#_递归">4.25. 递归</a></li>
        <li><a href="#_在库中存储子程序">4.26. 在库中存储子程序</a></li>
        <li><a href="#_位置参数">4.27. 位置参数</a></li>
        <li><a href="#_same_name_different_signature">4.28. Same Name, Different Signature</a></li>
        <li><a href="#_named_parameters">4.29. Named Parameters</a></li>
        <li><a href="#_return_types">4.30. Return Types</a></li>
        <li><a href="#_summary_5">4.31. Summary</a></li>
        <li><a href="#_your_first_class">4.32. Your First Class</a></li>
        <li><a href="#_定义方法">4.33. 定义方法</a></li>
        <li><a href="#_对象">4.34. 对象</a></li>
        <li><a href="#_multi_methods">4.35. multi Methods</a></li>
        <li><a href="#_inheriting_types">4.36. Inheriting Types</a></li>
        <li><a href="#_controlling_object_creation">4.37. Controlling Object Creation</a></li>
        <li><a href="#_private_classes">4.38. Private Classes</a></li>
        <li><a href="#_summary_6">4.39. Summary</a></li>
        <li><a href="#_给类添加行为">4.40. 给类添加行为</a></li>
        <li><a href="#_methods_in_roles">4.41. Methods in Roles</a></li>
        <li><a href="#_de_conflicting_roles">4.42. De-Conflicting Roles</a></li>
        <li><a href="#_anonymous_roles">4.43. Anonymous Roles</a></li>
        <li><a href="#_summary_7">4.44. Summary</a></li>
        <li><a href="#_junctions">4.45. Junctions</a></li>
        <li><a href="#_sets">4.46. Sets</a></li>
        <li><a href="#_summary_8">4.47. Summary</a></li>
        <li><a href="#_the_match_operator">4.48. The Match Operator</a></li>
        <li><a href="#_matching_nonliteral_characters">4.49. Matching Nonliteral Characters</a></li>
        <li><a href="#_matching_adverbs">4.50. Matching Adverbs</a></li>
        <li><a href="#_things_that_use_patterns">4.51. Things That Use Patterns</a></li>
        <li><a href="#_summary_9">4.52. Summary</a></li>
      </ul>
    </li>
    <li><a href="#_更漂亮的正则表达式">5. 更漂亮的正则表达式</a>
      <ul>
        <li><a href="#_量词">5.1. 量词</a></li>
        <li><a href="#_controlling_quantifiers">5.2. Controlling Quantifiers</a></li>
        <li><a href="#_captures">5.3. Captures</a></li>
        <li><a href="#_surrounders_and_separators">5.4. Surrounders and Separators</a></li>
        <li><a href="#_断言">5.5. 断言</a></li>
        <li><a href="#_alternations">5.6. Alternations</a></li>
        <li><a href="#_summary_10">5.7. Summary</a></li>
        <li><a href="#_a_simple_grammar">5.8. A Simple Grammar</a></li>
        <li><a href="#_multiple_rules">5.9. Multiple Rules</a></li>
        <li><a href="#_debugging_grammars">5.10. Debugging Grammars</a></li>
        <li><a href="#_a_simple_action_class">5.11. A Simple Action Class</a></li>
        <li><a href="#_ratcheting">5.12. Ratcheting</a></li>
        <li><a href="#_parsing_json">5.13. Parsing JSON</a></li>
        <li><a href="#_parsing_csv">5.14. Parsing CSV</a></li>
        <li><a href="#_summary_11">5.15. Summary</a></li>
        <li><a href="#_supplier">5.16. Supplier</a></li>
        <li><a href="#_channel">5.17. Channel</a></li>
        <li><a href="#_promise">5.18. Promise</a></li>
        <li><a href="#_响应式编程">5.19. 响应式编程</a></li>
        <li><a href="#_总结_7">5.20. 总结</a></li>
        <li><a href="#_快速和容易">5.21. 快速和容易</a></li>
        <li><a href="#_procs">5.22. Procs</a></li>
        <li><a href="#_异步控制">5.23. 异步控制</a></li>
        <li><a href="#_总结_8">5.24. 总结</a></li>
        <li><a href="#_单行">5.25. 单行</a></li>
        <li><a href="#_declarator_block_comments">5.26. Declarator Block Comments</a></li>
        <li><a href="#_feed_operators">5.27. Feed Operators</a></li>
        <li><a href="#_destructuring_signatures">5.28. Destructuring Signatures</a></li>
        <li><a href="#_defining_your_own_operators">5.29. Defining Your Own Operators</a></li>
        <li><a href="#_perl_5_patterns">5.30. Perl 5 Patterns</a></li>
        <li><a href="#_shaped_arrays">5.31. Shaped Arrays</a></li>
        <li><a href="#_typed_containers">5.32. Typed Containers</a></li>
        <li><a href="#_nativecall">5.33. NativeCall</a></li>
        <li><a href="#_the_with_topicalizer">5.34. The with Topicalizer</a></li>
      </ul>
    </li>
    <li><a href="#_结论">6. 结论</a></li>
  </ul>
</nav>
</div>

</div>

<article class="page__content" >
<div class="sect1">
<h2 id="_介绍">1. 介绍</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章是该语言的全貌图; 如果你还不了解正在发生的一切，请不要担心。担心如果你到了本书的最后，你仍然没有了解全部！有讲很多东西，所以将围绕一些话题，重新审视其他话题，并通过一些练习看看它们是如何融合在一起的 - 这真的都是关于实践的。</p>
</div>
<div class="sect2">
<h3 id="_为什么是_raku">1.1. 为什么是 Raku?</h3>
<div class="paragraph">
<p>对于初学者，你要学习 Raku。你也可能通过使用这种语言来使得物有所值！</p>
</div>
<div class="paragraph">
<p>但是什么使这种语言变得有吸引力？ Perl 家族一直喜欢 DWIM-Do What I Mean。你经常做的事情应该很容易做，而最困难的事情应该是可能的。任何编程语言的用处都可以通过它解决问题的程度来衡量。</p>
</div>
<div class="paragraph">
<p>Raku 是一种出色的文本处理语言 - 甚至可能比 Perl 5 更好。正则表达式（第15章）有许多令人兴奋的新功能，可以更容易地匹配和提取文本。内置 grammar（第17章）功能允许你轻松编写复杂的规则来处理和响应文本。</p>
</div>
<div class="paragraph">
<p>渐进类型（第3章）允许你注释变量，并限制你可以存储的内容。例如，你可以指定数字必须是整数，正数或两个其他数字之间的数。你不必必须使用它（这是渐进的部分）。你将能够注释子例程接受什么以及它应该返回什么。这可以快速揭示数据边界的错误。</p>
</div>
<div class="paragraph">
<p>内置并发（第18章）功能允许你将问题分解为单独运行并可能同时运行的部分。该语言为你处理大部分内容。</p>
</div>
<div class="paragraph">
<p>惰性列表和无限列表允许你处理序列而无需过多复制或甚至一次拥有整个列表（第6章）。你可以轻松创建自己的无限惰性列表。</p>
</div>
<div class="paragraph">
<p>我可以继续前进，但是当你按照本书的方式工作时，你会遇到更多令人惊叹的功能。</p>
</div>
<div class="paragraph">
<p>有时你不想使用 Raku。没有语言能适用所有的工作。如果你更喜欢其他更好的东西，或者可以使用不同的工具更快地完成任务，那么对你来说更强大！但是，我希望本书可以帮助你在 Raku 中快速有效地完成你需要做的事情。</p>
</div>
</div>
<div class="sect2">
<h3 id="_first_steps_with_the_repl">1.2. First Steps with the REPL</h3>
<div class="paragraph">
<p>REPL 是一个 Read-Evaluate-Print-Loop 的工具，提供交互式提示。 REPL 计算你键入的代码，显示结果，然后再次提示你。这是尝试代码片段的快速方法。当你运行不带参数的 raku 时，它会启动它的 REPL：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
To exit type &#39;exit&#39; or &#39;^D&#39;
&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&gt;</code> 是等待你输入内容的提示。当你键入 Return 时，REPL 开始工作。通过使两个数字相加来尝试 REPL：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 2 + 2
4</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果出现错误，它会让你知道并再次提示你：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 2 + Hamadryas
===SORRY!=== Error while compiling:
Undeclared name:
    Hamadryas used at line 1
&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还不知道为什么这失败，因为你刚开始读本书。这真的不重要，只要你知道 REPL 捕获错误并为你提供新提示就好了。如果你需要纠正错误，你应该能够使用向上箭头返回到上一行（或更远）来编辑和重新运行某些内容。</p>
</div>
<div class="paragraph">
<p>在继续之前，你应该了解一些其他技巧，这些技巧可以帮助你了解该语言的轮廓。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当我在本书中编写方法时，我通常会在方法调用点号前面加上它，因此你知道它们是方法，就像在 <code>.is-prime</code> 中一样。点号不是名称的一部分。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>方法是用于对象的预定义行为的标签。每个对象都有一个类型，而 <code>.^name</code> 方法告诉你它的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 3.^name
Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于整数，字面量 <code>3</code> 是 [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>) 类型的对象。一旦你知道类型是什么东西，你可以阅读其文档，以找出你可以用它做什么。</p>
</div>
<div class="paragraph">
<p>行为定义在类中（第12章），这些类可以通过继承基于更通用的类。你可以使用 <code>.^mro</code> 方法查看继承链（尽管文档也告诉你了）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 3.^mro
((Int) (Cool) (Any) (Mu))</code></pre>
</div>
</div>
<div class="paragraph">
<p>对象可以执行从其继承的所有类的所有行为。这表明 <code>3</code> 是一个 [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html)，然后它是一个" class="bare">https://docs.raku.org/type/Int.html)，然后它是一个</a> [<code>Cool</code>](<a href="https://docs.raku.org/type/Cool.html)（方便的面向对象循环），然后它是一个" class="bare">https://docs.raku.org/type/Cool.html)（方便的面向对象循环），然后它是一个</a> [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html)（几乎所有东西的基类），最后是一个" class="bare">https://docs.raku.org/type/Any.html)（几乎所有东西的基类），最后是一个</a> [<code>Mu</code>](<a href="https://docs.raku.org/type/Mu.html)（一个不是东西的东西" class="bare">https://docs.raku.org/type/Mu.html)（一个不是东西的东西</a> - 好好想一想！）。</p>
</div>
<div class="paragraph">
<p>使用 <code>.^methods</code> 查看对象的方法列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 3.^methods
(Int Num Rat FatRat abs Bridge chr sqrt base
polymod expmod is-prime floor ceiling round
...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>该类型也是一个对象（一个类型对象）。这是没有具体值的东西的抽象表达。它也有方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; Int.^methods
(Int Num Rat FatRat abs Bridge chr sqrt base
polymod expmod is-prime floor ceiling round
...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，你无法在类型对象上调用许多这样的方法。你会收到错误，因为还没有值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; Int.sqrt
Invocant of method &#39;sqrt&#39; must be an object instance of
type &#39;Int&#39;, not a type object of type &#39;Int&#39;.</code></pre>
</div>
</div>
<div class="paragraph">
<p>方法 <code>.^name</code>, <code>.^mro</code> 和 <code>.^methods</code>  来自语言的元编程基础。考虑到文章的篇幅，这对于本书有点高级，所以你不会在这里阅读更多相关内容。</p>
</div>
</div>
<div class="sect2">
<h3 id="_阅读文档">1.3. 阅读文档</h3>
<div class="paragraph">
<p>现在你已了解 REPL 以及如何查找对象的类型，你可能希望阅读文档中的那些内容。 <strong>p6doc</strong> 程序可以做到：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% p6doc Int
... lots of text</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想了解某种方法，可以将其添加到该类型中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% p6doc Int.polymod
      method polymod

Defined as:
    method polymod(Int:D: +@mods)

Usage:
    INTEGER.polymod(LIST)
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>有时你找不到你期望的文档。当发生这种情况时，尝试继承的类之一：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% p6doc Int.sqrt
No documentation found for method &#39;sqrt&#39;

% p6doc Cool.sqrt
  routine sqrt

Defined as:
    sub sqrt(Numeric(Cool) $x)
    method sqrt()

...</code></pre>
</div>
</div>
<div class="paragraph">
<p>我发现自己主要在 <a href="https://docs.raku.org" class="bare">https://docs.raku.org</a> 阅读在线文档。比这更糟糕的是谷歌像 “raku Int” 这样的东西，并跟踪第一个结果。该网站还有一个方便的搜索功能以帮助你查找，而无需使用全文搜索。你可以在本地运行同一站点。在每个页面的底部查找这些详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="_基础语法">1.4. 基础语法</h3>
<div class="paragraph">
<p>你经常需要从内到外地阅读代码，就像阅读一个数学公式一样，所以我在这里就是这样做的：从极小的地方开始，然后从那里建立起来。这是对你需要知道的事情的调查，在接下来的章节中你会读到这些内容。如果你在这一点上有点不知所措，不要担心。随着你的练习，你会习惯这些东西的。</p>
</div>
<div class="sect3">
<h4 id="_项">1.4.1. 项</h4>
<div class="paragraph">
<p>程序中最低级别的是项。这些是构成其他一切的基本构成要素。将这些视为语言的名词。下面是一些项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">2
e
π
&#39;Hello&#39;
$x
now</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些包括字面值数据，例如 <code>2</code> 和 <code>&#39;Hello&#39;</code>;变量，例如 <code>$x</code> ;和定义的符号，例如 <strong>π</strong>。<code>now</code> 是一个项，表示当前时间为 <a href="https://docs.raku.org/type/Instant.html"><code>Instant</code></a> 对象。</p>
</div>
<div class="paragraph">
<p>变量通常以 sigil 开头 - 一个表示该变量的特殊字符。变量 <code>$x</code> 有 <code>$</code> sigil。先不要担心这些，尽管你会在本章后面看到更多。</p>
</div>
</div>
<div class="sect3">
<h4 id="_运算符和表达式">1.4.2. 运算符和表达式</h4>
<div class="paragraph">
<p>表达式是项和操作符的组合，产生一个新的值。如果项是名词，那么运算符就是指定动作的动词。它们将一个或多个项转化为一个新的值。操作数是操作符使用的值。一元运算符对单个操作数进行操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">- 137           # negate 137 to make -137
+ &#39;137&#39;         # convert the string &#39;137&#39; to a number
$x++            # add 1 to the current value in $x</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#34;#&#34; 和后面的文本是注释（一会儿你会看到更多）。它是一些被程序忽略的文本，是你对你的代码留下注释的一种方便方式。我经常使用注释来加强观点或显示表达式的输出。</p>
</div>
<div class="paragraph">
<p>二元运算符对两个操作数起作用。通常这些操作符显示在操作数之间（下标）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">2 + 2            # add two numbers
$object.method() # the . method call operator
$x = 137         # assign a value to a variable</code></pre>
</div>
</div>
<div class="paragraph">
<p>A ternary operator, such as the conditional operator, <code>?? !!</code>, has three operands:</p>
</div>
<div class="paragraph">
<p>三元运算符，例如条件运算符，?? !!，有三个操作数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$some_value ?? &#39;Yes&#39; !! &#39;No&#39;    # choose one of two values</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the first thingy evaluates to <code>True</code>, it selects the second thingy. Otherwise it selects the third thingy. You’ll see more of these in [Chapter 3](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch03.html#camelia-numbers" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch03.html#camelia-numbers</a>).</p>
</div>
<div class="paragraph">
<p>如果第一个东西评估为True，它会选择第二个东西。否则它选择第三个东西。你将在第3章中看到更多这些内容。</p>
</div>
<div class="sect4">
<h5 id="_before_after_and_around">BEFORE, AFTER, AND AROUND</h5>
<div class="paragraph">
<p>Operators come in several varieties, with names that describe their position and the number of operands they expect. You’ll see these terms throughout the book. A prefix operator comes before its operand and usually takes only one operand. The increment operator is an example. It adds one to the number in <code>$x</code>:</p>
</div>
<div class="paragraph">
<p>运营商有多种类型，其名称描述了他们的位置和他们期望的操作数。你会在整本书中看到这些术语。前缀运算符位于其操作数之前，通常只需要一个操作数。增量运算符就是一个例子。它在$ x中添加一个数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">++$x</code></pre>
</div>
</div>
<div class="paragraph">
<p>A postfix operator comes after its operand. There are increment forms of this type as well:</p>
</div>
<div class="paragraph">
<p>后缀运算符位于其操作数之后。还有这种类型的增量形式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$x++</code></pre>
</div>
</div>
<div class="paragraph">
<p>A circumfix operator surrounds its operand. Examples include the parentheses and the double quote marks:</p>
</div>
<div class="paragraph">
<p>外围操作符包围其操作数。示例包括括号和双引号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">( 1, 2, 3 )
&#34;Hello&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A postcircumfix operator surrounds its operand but comes after something else. A single-element access to an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) or a [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) surrounds the index and comes after the variable name. The <code>[]</code> and <code>&lt;&gt;</code> are the operators that come after the name but surround the key:</p>
</div>
<div class="paragraph">
<p>postcircumfix运算符包围其操作数，但是在其他内容之后。对数组或哈希的单元素访问包围索引并位于变量名称之后。 []和&lt;&gt;是名称后面但围绕键的运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@array[0]
%hash&lt;key&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Those terms are in the documentation. There are other ways you can arrange operators that don’t have standard terms, so I’ve fashioned my own that I don’t expect to use that much.</p>
</div>
<div class="paragraph">
<p>A precircumfix operator surrounds an operand and comes before other operands. The reduction operator ([Chapter 6](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch06.html#camelia-lists)" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch06.html#camelia-lists)</a>) surrounds an operator that it places between each of the items that follow it. This adds all the numbers without having to specify a <code>+</code> between every pair:</p>
</div>
<div class="paragraph">
<p>这些术语在文档中。还有其他方法可以安排没有标准术语的操作员，所以我自己设计了我不希望使用那么多的操作员。</p>
</div>
<div class="paragraph">
<p>precircumfix运算符包围操作数，并且位于其他操作数之前。缩减操作符（第6章）围绕操作员，操作员将其放置在跟随它的每个项目之间。这会添加所有数字而不必在每对之间指定+：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[+] 1, 2, 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>A circumfix infix operator surrounds an <strong>infix operator</strong>. The hyperoperators <code>&lt;&lt;&gt;&gt;</code> surround an operator and distribute that infix operator along the two lists ([Chapter 6](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch06.html#camelia-lists)" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch06.html#camelia-lists)</a>):</p>
</div>
<div class="paragraph">
<p>外接中缀运算符围绕中缀运算符。超级运算符&lt;&lt; &gt;&gt;围绕一个运算符并在两个列表中分配该中缀运算符（第6章）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1, 2, 3) &lt;&lt;+&gt;&gt; (4, 5, 6)</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are other arrangements you might encounter in this book, but you can generally tell how they work by picking apart the name.</p>
</div>
<div class="paragraph">
<p>Operators are actually methods. Their names look a bit complicated because they start with the sort of operator they are and have the symbol in angle brackets:</p>
</div>
<div class="paragraph">
<p>你可能会在本书中遇到其他安排，但你通常可以通过挑选名称来了解它们的工作原理。</p>
</div>
<div class="paragraph">
<p>运算符实际上是方法。它们的名字看起来有点复杂，因为它们以它们的运算符开头，并在尖括号中有符号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">infix:&lt;+&gt;(1, 2)     # 3

my @array = 1, 2, 3
postcircumfix:&lt;[ ]&gt;( @array, 1 )</code></pre>
</div>
</div>
<div class="paragraph">
<p>You won’t need these forms, but you should know that the operators figure out what to do based on the arguments.</p>
</div>
<div class="paragraph">
<p>你不需要这些表单，但你应该知道运算符根据参数确定要执行的操作。</p>
</div>
</div>
<div class="sect4">
<h5 id="_优先级">优先级</h5>
<div class="paragraph">
<p>You can chain operations one after the other. Try this in the REPL:</p>
</div>
<div class="paragraph">
<p>你可以一个接一个地链接操作。在REPL中尝试这个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1 + 2 + 3 + 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression is evaluated in order of operator precedence and associativity. Precedence decides which operators go first and associativity figures out the order among operators of the same precedence (or even two of the same operator).</p>
</div>
<div class="paragraph">
<p>An operator’s precedence is relatively looser or tighter than other operators. With a chain of terms the tighter operator goes first. Multiplication (<code>*</code>) happens before addition (<code>+</code>), just like in high school algebra:</p>
</div>
<div class="paragraph">
<p>表达式按运算符优先级和关联性的顺序进行计算。优先级决定哪些运算符优先，关联性在相同优先级的运算符（或者甚至是同一运算符中的两个）之间确定顺序。</p>
</div>
<div class="paragraph">
<p>运营商的优先级比其他运营商相对宽松或紧凑。通过一系列术语，更严格的运营商成为第一。乘法（*）在加法（+）之前发生，就像在高中代数中一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">2 + 3 * 4       # 14</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don’t like the order you can change it with parentheses. Things inside parentheses are computed before things outside. Another way to say that is that parentheses have the highest precedence. Now the addition happens first:</p>
</div>
<div class="paragraph">
<p>如果你不喜欢订单，可以使用括号更改订单。括号内的东西是在外面的东西之前计算出来的。另一种说法是括号具有最高优先级。现在首先添加：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(2 + 3) * 4     # 20</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you have two operators of the same precedence then associativity decides the order of evaluation. Operators can be either left associative or right associative. The exponentiation operator is right associative, so the operation on the right happens first:</p>
</div>
<div class="paragraph">
<p>如果你有两个具有相同优先级的运算符，则关联性决定评估的顺序。运算符可以是左关联的，也可以是右关联的。取幂运算符是右关联的，因此右边的操作首先发生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">2 ** 3 ** 4     # 2.4178516392293e+24</code></pre>
</div>
</div>
<div class="paragraph">
<p>It’s the same order as if you put explicit parentheses around the right two numbers:</p>
</div>
<div class="paragraph">
<p>它与在右边两个数字周围放置明确括号的顺序相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">2 ** (3 ** 4)     # 2.4178516392293e+24</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use parentheses to make the left operation happen first:</p>
</div>
<div class="paragraph">
<p>使用括号使左操作首先发生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(2 ** 3) ** 4     # 4096</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some operators can’t be combined and don’t have associativity. The range operator is one of the operators you can’t combine:</p>
</div>
<div class="paragraph">
<p>有些运营商无法合并，也没有相关性。范围运算符是你无法组合的运算符之一：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">0 .. 5       # Range operator, nonassociative
0 .. 3 .. 5  # Illegal</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_语句">1.4.3. 语句</h4>
<div class="paragraph">
<p>A <strong>statement</strong> is a complete, standalone part of a program. An expression can be a statement but it can also be part of a statement. Here’s a statement using <code>put</code> to output a message. It adds a newline for you:</p>
</div>
<div class="paragraph">
<p>声明是程序的完整独立部分。表达式可以是语句，但也可以是语句的一部分。这是一个使用put来输出消息的语句。它为你添加了换行符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Hello Raku!&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You separate statements with a semicolon. Here are two statements; they are on separate lines but you still need a semicolon between them:</p>
</div>
<div class="paragraph">
<p>用分号分隔语句。这是两个陈述;它们在不同的行上但你仍然需要在它们之间加一个分号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Hello Raku!&#39;;
put &#39;The time is &#39;, now;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You don’t need the <code>;</code> unless another statement follows, but I tend to put a semicolon at the end of every statement because I know I’ll forget to add it when I add more code:</p>
</div>
<div class="paragraph">
<p>你不需要;除非有其他声明，但我倾向于在每个语句的末尾加上分号，因为我知道在添加更多代码时我会忘记添加它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Hello Raku!&#39;;
put &#39;The time is &#39;, now;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most whitespace is insignificant, which means you can use it how you like to format your program. These statements have a differently organized manner:</p>
</div>
<div class="paragraph">
<p>大多数空白都是无关紧要的，这意味着你可以按照自己喜欢的方式使用它来格式化程序。这些陈述的组织方式不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put
    &#39;Hello Raku!&#39;

; put &#39;The time is &#39;,
now               ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are a few situations where whitespace matters, but you’ll read about that when you need to know about it.</p>
</div>
<div class="paragraph">
<p>在某些情况下，空白很重要，但是当你需要了解它时，你会读到这些内容。</p>
</div>
</div>
<div class="sect3">
<h4 id="_块儿">1.4.4. 块儿</h4>
<div class="paragraph">
<p>A block ([Chapter 5](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch05.html#camelia-blocks)" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch05.html#camelia-blocks)</a>) combines one or more statements into a single unit by surrounding them with a set of braces. Sometimes the block has a control keyword, such as <code>loop</code>, attached to it. This block continually evaluates its statements until you stop the program with Control-C. This is an <strong>infinite loop</strong>:</p>
</div>
<div class="paragraph">
<p>一个块（第5章）通过用一组括号围绕它们将一个或多个语句组合成一个单元。有时块会附加一个控制关键字，例如循环。在使用Control-C停止程序之前，此块会持续评估其语句。这是一个无限循环：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop {
    state $count = 0;
    sleep 1;
    print $count, &#34;\r&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each statement is separated by a semicolon and the last statement has a semicolon for good measure.</p>
</div>
<div class="paragraph">
<p>You don’t see a <code>;</code> after the closing brace for that <code>loop</code>, but it’s implicitly there. A <code>}</code> followed by nothing more than whitespace until the end of the line implies a <code>;</code>. If you have more stuff on the same line, though, you need a <code>;</code> after the <code>}</code>:</p>
</div>
<div class="paragraph">
<p>每个语句用分号分隔，最后一个语句用分号表示。</p>
</div>
<div class="paragraph">
<p>你没有看到;在该循环的右括号之后，但它隐含在那里。 A}后面只有空格，直到行尾意味着;。但是，如果你在同一条线上有更多的东西，你需要一个;之后 }：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop { ... }; put &#34;Done&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>…​</code> (yada yada) operator is the way you signal that there’s something there but you don’t care to say what it is at the moment. Use it when you intend to fill in the details later. I’ll use those to hide code to save space in examples. It compiles but gives you an error when you run it. You’ll see this used throughout the book to shorten examples to fit on the page.</p>
</div>
<div class="paragraph">
<p>A block creates a lexical scope. You can see what this scope is based on the position of the braces (hence, lexical). Things you define inside a scope only matter inside that scope and the deeper scopes it defines. This limits the effects of many things to exactly where you need them. The effects of variables and modules are limited to their lexical scope.</p>
</div>
<div class="paragraph">
<p>…​…​（yada yada）操作员是你发出信号的方式，但是你不想在此刻说出它是什么。如果你打算稍后填写详细信息，请使用它。我将使用这些来隐藏代码以节省示例中的空间。它会编译，但在运行时会出错。你将在本书中看到这一点，以缩短示例以适应页面。</p>
</div>
<div class="paragraph">
<p>块创建词法范围。你可以看到这个范围基于大括号的位置（因此，词汇）。你在范围内定义的内容仅在该范围内以及它定义的更深范围内。这将许多事物的影响限制在你需要它们的确切位置。变量和模块的影响仅限于它们的词法范围。</p>
</div>
</div>
<div class="sect3">
<h4 id="_注释">1.4.5. 注释</h4>
<div class="paragraph">
<p>Comments are a way to leave ourselves notes that the program doesn’t care about. The compiler mostly ignores these things. You can make a comment with a # when the compiler is expecting a new token. The compiler skips everything from that # to the end of the line. Here’s a mostly useless comment:</p>
</div>
<div class="paragraph">
<p>评论是一种让自己留下该程序不关心的注释的方法。编译器大多忽略了这些东西。当编译器期望新的令牌时，你可以使用＃进行注释。编译器会跳过从＃到行尾的所有内容。这是一个无用的评论：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Hello Raku!&#39;; # output a message</code></pre>
</div>
</div>
<div class="paragraph">
<p>A better comment expounds on the purpose, not the effect, of the code. This type of little program is often used as a first exercise to check that everything is working. The comment can say that:</p>
</div>
<div class="paragraph">
<p>更好的评论阐述了代码的目的，而不是效果。这种类型的小程序通常用作检查一切正常的第一个练习。评论可以说：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Hello Raku!&#39;; # show that the program ran</code></pre>
</div>
</div>
<div class="paragraph">
<p>An alternative is an embedded comment. Put your message inside the parentheses in <code>#</code>( )` somewhere in your statement (or even between statements):</p>
</div>
<div class="paragraph">
<p>另一种选择是嵌入式评论。将你的消息放在语句中某处（甚至语句之间）的＃（）`中的括号内：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put #`(Marketing asked for this) &#39;Hello Raku!&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a nice way to have multiline comments:</p>
</div>
<div class="paragraph">
<p>这是获得多行注释的好方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#`(
* show that the program ran
* need to add blockchain email AI feature
)
put  &#39;Hello Raku!&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since a closing parenthesis ends the comment, you can’t have one in your comment.</p>
</div>
<div class="paragraph">
<p>Both of those are fine for short comments. Sometimes you want to comment out several lines to prevent them from running. If you put the <code>#</code> at the beginning of a line you effectively remove that line from the program:</p>
</div>
<div class="paragraph">
<p>由于右括号结束了注释，因此你的注释中不能有注释。</p>
</div>
<div class="paragraph">
<p>这两个都适合简短的评论。有时你想要注释掉几行以防止它们运行。如果你把＃放在一行的开头，你就可以从程序中删除该行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop {
    state $count = 0;
#   sleep 1;
    print $count, &#34;\r&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You might add another comment to remind yourself why that line is still in the code. Often programmers do this as they are debugging so they remember what was there before they started:</p>
</div>
<div class="paragraph">
<p>你可以添加另一条注释来提醒自己为什么该行仍在代码中。程序员通常会在调试时执行此操作，以便他们记住启动之前的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop {
    state $count = 0;
# Testing this for ticket 1234 (bug://1234)
# I think that the sleep slows the program down too much
#   sleep 1;
    print $count, &#34;\r&#34;;
    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_unspace">1.4.6. Unspace</h4>
<div class="paragraph">
<p>In most places Raku doesn’t care about whitespace, but there are some parts of the Raku syntax that don’t allow spaces. Space between the name of a subroutine and its opening parenthesis for an argument list changes the meaning:</p>
</div>
<div class="paragraph">
<p>在大多数地方，Raku并不关心空格，但Raku语法的某些部分不允许使用空格。子例程名称与参数列表的左括号之间的空格改变了含义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my-sub 1, 2, 3;            # three arguments
my-sub( 1, 2, 3 );         # three arguments
my-sub ( 1, 2, 3 );        # one argument (a List)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In that last line there’s a space between <code>my-sub</code> and the <code>(</code>. That compiles and runs, but instead of three arguments the subroutine gets a single [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) argument ([Chapter 6](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch06.html#camelia-lists)" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch06.html#camelia-lists)</a>). You can unspace that space with a backslash. Any whitespace following the <code>\</code> is basically invisible to the compiler:</p>
</div>
<div class="paragraph">
<p>在最后一行中，my-sub和（。）之间有一个空格编译并运行，但是子程序不是三个参数，而是获取单个List参数（第6章）。你可以用反斜杠取消空格。任何空格跟随\对编译器基本上是不可见的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my-sub\ (1, 2, 3 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>You might want to do this to format code into columns to make it easier to read:</p>
</div>
<div class="paragraph">
<p>你可能希望这样做以将代码格式化为列以使其更易于阅读：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my-sub\            ( 2, 4, 8 );
my-much-longer-name( 1, 3, 7 );</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_对象和类">1.4.7. 对象和类</h4>
<div class="paragraph">
<p>Raku is a class-based object system. I’ll skip most of the theory of object-oriented programming (that could be a whole other book), but you should know that in these systems a <strong>class</strong> ([Chapter 12](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch12.html#camelia-classes)" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch12.html#camelia-classes)</a>) defines the abstract structure and behavior of an object. The <strong>object</strong> is a particular concrete version of that class.</p>
</div>
<div class="paragraph">
<p>Most of the data in Raku are objects, and each object knows what class defines it. Classes define methods, which are the behaviors of the object. Classes can inherit from another class to include its behavior, but they can also include roles that add behavior without inheritance. When you see class names in the digital version of this book the name should link to the online documentation for that class (for example, the [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>) class).</p>
</div>
<div class="paragraph">
<p>You create objects by calling a constructor method, often called <code>.new</code> ([Chapter 12](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch12.html#camelia-classes)" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch12.html#camelia-classes)</a>). You pass <strong>arguments</strong> to the method in parentheses after the method name:</p>
</div>
<div class="paragraph">
<p>Raku是一个基于类的对象系统。我将跳过面向对象编程的大部分理论（可能是另一本书），但你应该知道在这些系统中，一个类（第12章）定义了一个对象的抽象结构和行为。该对象是该类的特定具体版本。</p>
</div>
<div class="paragraph">
<p>Raku中的大多数数据都是对象，每个对象都知道哪个类定义了它。类定义方法，这是对象的行为。类可以从另一个类继承以包含其行为，但它们也可以包含添加行为而不继承的角色。当你在本书的数字版本中看到类名时，该名称应该链接到该类的在线文档（例如，Int类）。</p>
</div>
<div class="paragraph">
<p>你可以通过调用构造函数方法来创建对象，通常称为.new（第12章）。在方法名称后面的括号中将参数传递给方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fraction = Rat.new( 5, 4 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s also a colon syntax for method arguments which relieves you from the burden of typing the closing parenthesis as long as there’s nothing more in the statement:</p>
</div>
<div class="paragraph">
<p>方法参数还有一个冒号语法，只要语句中没有其他内容，就可以减轻输入右括号的负担：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fraction = Rat.new: 5, 4;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Type objects</strong> represent the abstract idea of a class but aren’t objects. Sometimes they are useful as placeholders when you know what sort of object you want but you don’t know its value yet:</p>
</div>
<div class="paragraph">
<p>*类型对象*表示类的抽象概念，但不是对象。当你知道你想要什么样的对象但你还不知道它的价值时，有时候它们可以用作占位符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fraction = Rat;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With gradual typing you can restrict variables to fit into a type. These are runtime checks, so you don’t know that it didn’t work until you try it:</p>
</div>
<div class="paragraph">
<p>通过逐步输入，你可以限制变量以适合类型。这些是运行时检查，所以在尝试之前你不知道它不起作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int $n;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since you haven’t assigned a value to <code>$n</code> yet, it’s an [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>) type object. When you want to assign a value it must match that type:</p>
</div>
<div class="paragraph">
<p>由于尚未为$ n分配值，因此它是Int类型对象。如果要分配值，则必须与该类型匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$n = 137;          # works because it&#39;s an integer
$n = &#39;Hamadryas&#39;;  # fails</code></pre>
</div>
</div>
<div class="paragraph">
<p>Look through a class’s documentation to see what sorts of things its objects can do. In many of the exercises I’ll ask you to use a method that I haven’t shown you. This trains you to go to the docs, but also lets you learn things about seeing what’s out there. This saves some space in the book. Let’s try some of those now.</p>
</div>
<div class="paragraph">
<p>EXERCISE 1.1What type of object is <code>137</code>? Compute its square root. Is it a prime number? You should be able to do each of these with a simple method.</p>
</div>
<div class="paragraph">
<p>查看类的文档，了解其对象可以执行的操作。在许多练习中，我会要求你使用我没有给你看的方法。这会训练你去看文档，但也可以让你学习看看那里有什么。这节省了书中的一些空间。我们现在试试吧。</p>
</div>
<div class="paragraph">
<p>练习1.1什么类型的对象是137？计算其平方根。它是素数吗？你应该能够使用一种简单的方法完成其中的每一项。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_variables">1.5. Variables</h3>
<div class="paragraph">
<p>Raku has <strong>named values</strong>. They can be immutable, which means you can’t change the values once you set them. They can also be mutable, which means you can change the values. The mutable ones are commonly called <strong>variables</strong>, but they are also known as containers. A container holds a value and you can replace that value with another. You’ll read more about that in the next chapter. Despite the possibility that you can’t change the value, I’ll still call all of these “variables.”</p>
</div>
<div class="paragraph">
<p>A named value has an identifier—a fancy word for “name.” Names can include letters, digits, the underscore, the hyphen, and the apostrophe (<code>&#39;</code>). You must start your name with a letter or digit. These are valid identifiers:</p>
</div>
<div class="paragraph">
<p>Raku具有命名值。它们可以是不可变的，这意味着一旦设置它们就无法更改它们。它们也可以是可变的，这意味着你可以更改值。可变的通常称为变量，但它们也称为容器。容器包含值，你可以将该值替换为另一个值。你将在下一章中阅读更多相关内容。尽管你无法更改该值，但我仍然会调用所有这些“变量”。</p>
</div>
<div class="paragraph">
<p>命名值具有标识符 - “名称”的奇特单词。名称可以包括字母，数字，下划线，连字符和撇号（&#39;）。你必须以字母或数字开头。这些是有效的标识符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">butterfly_name
butterfly-name
butterfly&#39;name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The underscore, hyphen, or apostrophe can separate words to make them easier to read. Sometimes the underscore pattern is called snake case since the word separators crawl along the ground. The hyphen pattern is called kebab case (or sometimes lisp case).</p>
</div>
<div class="paragraph">
<p>Some people might feel more at home capitalizing the first letter of each word instead. This is known as camel case since it imitates the humps on a camel’s back. In this example there’s one hump, which is the best number of humps for a camel:</p>
</div>
<div class="paragraph">
<p>下划线，连字符或撇号可以分隔单词以使其更易于阅读。有时下划线模式称为蛇形，因为单词分隔符沿着地面爬行。连字符模式称为kebab案例（或有时称为lisp案例）。</p>
</div>
<div class="paragraph">
<p>有些人可能会觉得在家里更多地将每个单词的第一个字母大写。这被称为骆驼案，因为它模仿骆驼背上的驼峰。在这个例子中有一个驼峰，这是驼峰的最佳驼峰数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">butterflyName</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are some rules with <code>-</code> and <code>&#39;</code>. You can’t have two <code>-</code> or <code>&#39;</code> characters in a row, and the character after either must be a letter (not a number). Also, you cannot start an identifier with these characters. None of these are valid:</p>
</div>
<div class="paragraph">
<p>有一些规则 - 和&#39;。你不能连续两个 - 或’字符，并且后面的字符必须是字母（不是数字）。此外，你无法使用这些字符启动标识符。这些都不是有效的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">butterfly--name
butterfly&#39;&#39;name
&#39;butterfly
butterfly-1</code></pre>
</div>
</div>
<div class="paragraph">
<p>A variable name combines a sigil with an identifier. The sigil is a character that gives some context to the identifier. A scalar is a single thingy. A scalar variable holds a single value and has a <code>$</code> sigil. The <code>$</code> looks similar to <code>S</code>, for scalar:</p>
</div>
<div class="paragraph">
<p>变量名称将sigil与标识符组合在一起。 sigil是一个为标识符提供一些上下文的字符。标量是一个单一的东西。标量变量包含单个值并具有$ sigil。对于标量，$看起来类似于S：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$butterfly_name</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you encounter the different types you’ll encounter the other sigils. The <code>@</code> is for positionals (<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch06.html#camelia-lists">Chapter 6</a>), the <code>%</code> is for associatives (<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch09.html#camelia-hashes">Chapter 9</a>), and the <code>&amp;</code> is for callables (<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch11.html#camelia-subroutines">Chapter 11</a>).</p>
</div>
<div class="paragraph">
<p>The first time you use a variable you must declare it. You do this so the compiler knows you definitely want to use that name and to avoid problems with misspelling variables. The <code>my</code> keyword declares the variable to be private to the current scope:</p>
</div>
<div class="paragraph">
<p>当你遇到不同的类型时，你会遇到其他的印记。 @代表位置（第6章），％代表关联（第9章），＆是适用于callables（第11章）。</p>
</div>
<div class="paragraph">
<p>第一次使用变量时，必须声明它。你这样做是因为编译器知道你肯定想要使用该名称并避免拼写错误变量的问题。 my关键字将变量声明为当前范围的私有变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $number;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next time you use <code>$number</code> in that same scope you don’t need to declare it. You probably want to assign it a value. The <code>=</code> is the assignment operator:</p>
</div>
<div class="paragraph">
<p>下次在同一范围内使用$ number时，你不需要声明它。你可能想要为其分配值。 =是赋值运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$number = 137;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You initialize a variable first time you assign a value to it. You can do this at the same time that you declare it:</p>
</div>
<div class="paragraph">
<p>首次为其赋值时初始化变量。你可以在声明它的同时执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $number = 137;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since Raku already knows which variables you intend to use it knows when you misspell one:</p>
</div>
<div class="paragraph">
<p>由于Raku已经知道你打算使用哪些变量，因此它知道你拼错了一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$numbear = 137;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You get an error that’s often aware enough to guess what you meant:</p>
</div>
<div class="paragraph">
<p>你会得到一个经常意识到足以猜出你的意思的错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Variable &#39;$numbear&#39; is not declared. Did you mean &#39;$number&#39;?</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_简单输出">1.5.1. 简单输出</h4>
<div class="paragraph">
<p>To see what’s in a variable you can use (or “call”) the <code>put</code> routine. This outputs the value to standard output and adds a newline to the end:</p>
</div>
<div class="paragraph">
<p>要查看变量中的内容，你可以使用（或“调用”）put例程。这会将值输出到标准输出并在结尾添加换行符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put $number;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you use <code>say</code> it calls the <code>.gist</code> method for you. This often results in the same output, but some complicated objects may summarize or elide data to give you something easier to read. These two do the same thing:</p>
</div>
<div class="paragraph">
<p>如果你使用say它会为你调用.gist方法。这通常会产生相同的输出，但是一些复杂的对象可能会总结或删除数据，以便你更容易阅读。这两个做同样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $number;
put $number.gist;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don’t want to add a newline you can use <code>print</code>:</p>
</div>
<div class="paragraph">
<p>如果你不想添加换行符，可以使用print：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">print $number;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are also method forms of each of these:</p>
</div>
<div class="paragraph">
<p>还有以下各种方法形式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$number.put;
$number.say;
$number.print;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_词法作用域">1.5.2. 词法作用域</h4>
<div class="paragraph">
<p>A variable is only visible in its lexical scope. If you define a variable inside braces you can’t use it outside the braces:</p>
</div>
<div class="paragraph">
<p>变量仅在其词法范围内可见。如果在大括号内定义变量，则不能在大括号外使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
my $number = 137;
}

$number = 5; # a compilation error</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is caught when you try to compile the program:</p>
</div>
<div class="paragraph">
<p>当你尝试编译程序时会捕获此信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Variable &#39;$number&#39; is not declared</code></pre>
</div>
</div>
<div class="paragraph">
<p>A variable of the same name can exist in the outer scope and isn’t disturbed when the same name is reused in a deeper scope:</p>
</div>
<div class="paragraph">
<p>外部作用域中可以存在同名变量，并且在更深的作用域中重用相同名称时不会受到干扰：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $number = 5;
put $number;

{
my $number = 137;
put $number;
}

put $number;</code></pre>
</div>
</div>
<div class="paragraph">
<p>These are two different variables that happen to use the same name. The compiler can tell them apart based on where you declared them. The inner scope declaration “hides” the outer scope one, so the result is:</p>
</div>
<div class="paragraph">
<p>这是两个碰巧使用相同名称的不同变量。编译器可以根据你声明它们的位置区分它们。内部范围声明“隐藏”外部范围一，因此结果是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">5
137
5</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes a named value doesn’t have a sigil. These sigilless variables don’t create containers, which means that you can’t change their values. This makes them handy for values you don’t want anyone to accidentally change. Prefix the identifier with a <code>\</code>:</p>
</div>
<div class="paragraph">
<p>有时命名值没有印记。这些无形变量不会创建容器，这意味着你无法更改其值。这使得它们非常便于你不希望任何人意外更改的值。使用\前缀标识符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my \magic-number = 42;
magic-number.put;</code></pre>
</div>
</div>
<div class="paragraph">
<p>These statements actually create terms, but since you declare them like variables it’s slightly easier to be a little wrong than pedantically correct.</p>
</div>
<div class="paragraph">
<p>这些语句实际上创建了术语，但是因为你将它们声明为变量，所以稍微容易出错而不是迂腐正确。</p>
</div>
</div>
<div class="sect3">
<h4 id="_预定义变量">1.5.3. 预定义变量</h4>
<div class="paragraph">
<p>Raku defines several variables for you. These are prefixed with a sigil and then an additional character called a twigil. The combination of characters tells you something about the variable. Don’t worry about all the sorts of twigils that exist. Know that they do exist and that you can read about them at <a href="https://docs.raku.org/language/variabless。" class="bare">https://docs.raku.org/language/variabless。</a></p>
</div>
<div class="paragraph">
<p>Raku为你定义了几个变量。这些是以印记为前缀，然后是一个名为twigil的附加角色。字符组合会告诉你有关变量的信息。不要担心存在的所有种类的树枝。知道它们确实存在，你可以在https://docs.raku.org/language/variables或p6doc上阅读它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% p6doc language/variables</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>?</code> twigil marks values that the compiler sets as it does its work. These are compile-time variables. If you want to know the file the compiler is working on you can look in <code>$?FILE</code>. The <code>$</code> is the sigil and the <code>?</code> is the twigil:</p>
</div>
<div class="paragraph">
<p>的？ twigil标记编译器在工作时设置的值。这些是编译时变量。如果你想知道编译器正在处理的文件，你可以查看$？FILE。 $是sigil和？是twigil：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put $?FILE;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>*</code> twigil marks dynamic variables. These are looked up through the caller’s scope, but that’s not the important part for this section. Your program automatically sets these values. Some of them are about the environment of the program:</p>
</div>
<div class="paragraph">
<p>twigil标志着动态变量。这些是通过调用者的范围查找的，但这不是本节的重要部分。你的程序会自动设置这些值。其中一些是关于该计划的环境：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
To exit type &#39;exit&#39; or &#39;^D&#39;
&gt; $*EXECUTABLE
&#34;/Applications/Rakudo/bin/raku&#34;.IO
&gt; $*PROGRAM
&#34;interactive&#34;.IO
&gt; $*USER
hamadryas
&gt; $*CWD
&#34;/Users/hamadryas&#34;.IO</code></pre>
</div>
</div>
<div class="paragraph">
<p>Others provide information about your version of Raku. This information might be useful if you need to report an issue:</p>
</div>
<div class="paragraph">
<p>其他人提供有关你的Raku版本的信息。如果你需要报告问题，此信息可能很有用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; $*PERL
Raku (6.c)
&gt; $*VM
moar (2018.04)</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are other dynamic variables for the standard <strong>filehandles</strong>. Each program gets output, input, and error filehandles. The standard output (the default place where output goes) is in <code>$*OUT</code> and standard error is in <code>$*ERR</code>. These are <code>IO::Handle</code> objects and you can call <code>.put</code> on them to make output:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">标准文件句柄还有其他动态变量。每个程序都获得输出，输入和错误文件句柄。标准输出（输出的默认位置）在$ * OUT中，标准错误在$ * ERR中。这些是IO </dt>
<dd>
<p>Handle对象，你可以在它们上调用.put来进行输出：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$*OUT.put: &#39;Hello Hamadryas!&#39;;
$*ERR.put: &#39;Hello Hamadryas!&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 1.2What is the <code>$*CWD</code> variable? What’s its value on your system?</p>
</div>
<div class="paragraph">
<p>EXERCISE 1.2 $ * CWD变量是什么？它对你的系统有什么价值？</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_making_and_running_a_program">1.6. Making and Running a Program</h3>
<div class="paragraph">
<p>It’s time you wrote a program. That’s just a plain-text file that contains your source code. You don’t need any special software to create these files. They must be plain text though; word processors insert extra stuff and the compiler won’t tolerate that.</p>
</div>
<div class="paragraph">
<p>The first line in the program is typically the shebang line. That’s a Unix thing that lets a text file pretend to be a program. When you “run” the text file the system sees that the first two characters are <code>#!</code>. It uses the rest of that line as the name of the program that will actually run the code. That’s the <strong>interpreter</strong>:</p>
</div>
<div class="paragraph">
<p>是时候写一个程序了。这只是一个包含源代码的纯文本文件。你不需要任何特殊软件来创建这些文件。但它们必须是纯文本;字处理器插入额外的东西，编译器不会容忍。</p>
</div>
<div class="paragraph">
<p>该计划的第一行通常是shebang线。这是一个让文本文件伪装成程序的Unix东西。当你“运行”文本文件时，系统会看到前两个字符是＃！。它使用该行的其余部分作为实际运行代码的程序的名称。那是翻译：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/Applications/Rakudo/bin/raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your package (or custom installation) may have installed it somewhere else, in which case you’d use that path:</p>
</div>
<div class="paragraph">
<p>你的包（或自定义安装）可能已将其安装在其他位置，在这种情况下你将使用该路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/local/bin/raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some people use <strong>env</strong> since that looks through your <code>PATH</code> to find the program:</p>
</div>
<div class="paragraph">
<p>有些人使用env，因为它通过你的PATH查找程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/bin/env raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>Windows doesn’t know about shebangs, but it’s a good idea to include the shebang anyway since useful programs tend to escape into the world (life will find a way). For the rest of the book I’ll leave off the shebang line just to save space.</p>
</div>
<div class="paragraph">
<p>The rest of your file is your program. Here’s a common one that tests that you’ve probably done everything right. If you can run this program you’ve probably installed everything correctly:</p>
</div>
<div class="paragraph">
<p>Windows不知道shebangs，但是最好包括shebang，因为有用的程序往往会逃到这个世界（生活会找到一种方式）。为了本书的其余部分，为了节省空间，我将离开shebang线。</p>
</div>
<div class="paragraph">
<p>你文件的其余部分是你的程序。这是一个常见的测试，你可能已经做好了一切。如果你可以运行这个程序，你可能已正确安装了一切：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Hello World!&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ensure your editor is set to encode your file as UTF-8. Save the file using any name that you like. <strong>raku</strong> doesn’t care about the name, although the docs suggest a <strong>.p6</strong> or <strong>.pl6</strong> extension.</p>
</div>
<div class="paragraph">
<p>Run your program from the command line:</p>
</div>
<div class="paragraph">
<p>确保你的编辑器设置为将文件编码为UTF-8。使用你喜欢的任何名称保存文件。 raku并不关心名称，尽管文档建议使用.p6或.pl6扩展名。</p>
</div>
<div class="paragraph">
<p>从命令行运行你的程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku hello-world.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you do this <strong>raku</strong> first compiles the program. It sees all of your program text and parses it. That’s the compile time part of the process. If it finds no problem it then runs what it has already compiled.</p>
</div>
<div class="paragraph">
<p>If you want to check your program without running it you can use the <code>-c</code> switch. This is a syntax check:</p>
</div>
<div class="paragraph">
<p>当你这样做时raku首先编译程序。它会查看所有程序文本并对其进行解析。这是该过程的编译时间部分。如果它没有发现任何问题，则运行它已编译的内容。</p>
</div>
<div class="paragraph">
<p>如果要在不运行程序的情况下检查程序，可以使用-c开关。这是语法检查：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku -c hello-world.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most errors at this point are syntax errors; you wrote a program that Raku couldn’t parse.</p>
</div>
<div class="paragraph">
<p>EXERCISE 1.3Create the “Hello World” program and get it to run. Use any tools you like for that.</p>
</div>
<div class="paragraph">
<p>此时的大多数错误都是语法错误;你写了一个Raku无法解析的程序。</p>
</div>
<div class="paragraph">
<p>练习1.3创建“Hello World”程序并让它运行。使用你喜欢的任何工具。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结">1.7. 总结</h3>
<div class="paragraph">
<p>You’ve seen the basic structure of a program and how you build up a program from smaller elements. You wrote some very small programs. You have some insights into the documentation; you’ll get more practice with that throughout your programming career. Now the trick is to make slightly larger programs.</p>
</div>
<div class="paragraph">
<p>你已经了解了程序的基本结构以及如何从较小的元素构建程序。你写了一些很小的程序。你对文档有一些了解;在整个编程生涯中，你将获得更多练习。现在的诀窍是制作稍大的程序。
== 猜数字</p>
</div>
<div class="paragraph">
<p>ou’re about to be thrown in the deep end. There are some basic things you need to know to write useful programs, and you’ll meet a lot of them in this chapter so you can write a number-guessing program by the end. It’s quite a bit to take in all at once but it should make the rest of the chapters more interesting.</p>
</div>
<div class="paragraph">
<p>你将要陷入深渊。编写有用的程序需要了解一些基本的东西，本章中你会遇到很多基本的东西，所以你可以在最后编写一个数字猜测程序。一下子就可以完全接受它，但它应该让其他章节更有趣。</p>
</div>
</div>
<div class="sect2">
<h3 id="_绑定和赋值">1.8. 绑定和赋值</h3>
<div class="paragraph">
<p>You read a little about variables in [Chapter 1](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch01.html#camelia-introduction" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch01.html#camelia-introduction</a>). To store a value in a variable you assign to it. The item assignment operator, <code>=</code>, stores a single thingy for you. <code>$number</code> is a scalar variable; it can store exactly one thingy. This is item assignment because there’s one thingy. This “sets” the value:</p>
</div>
<div class="paragraph">
<p>你将在第1章中阅读一些关于变量的内容。将值存储在你为其分配的变量中。项目赋值运算符=为你存储单个东西。 $ number是一个标量变量;它可以存储一个东西。这是项目分配，因为有一个东西。这“设置”了价值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $number = 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you decide that you don’t want that value you can replace it:</p>
</div>
<div class="paragraph">
<p>如果你认为不需要该值，则可以替换它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$number = 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes you want a value that you can’t change (more likely a value you don’t want another part of your program to change). Instead of the assignment operator you can use the binding operator, <code>:=</code>, to set the value:</p>
</div>
<div class="paragraph">
<p>有时你想要一个你无法改变的值（更可能是你不希望程序的另一部分改变的值）。你可以使用绑定运算符：=来设置值，而不是赋值运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sides-of-a-square := 4;
$sides-of-a-square = 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you try to change the value you get an error:</p>
</div>
<div class="paragraph">
<p>当你尝试更改该值时，你会收到错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Cannot assign to an immutable value</code></pre>
</div>
</div>
<div class="paragraph">
<p>It’s not the binding operator that makes the variable immutable. It merely makes the thingy on the left the same as the one on the right. In this case, <code>$sides-of-square</code> is actually <code>4</code> and not just a variable that happens to store <code>4</code>. You can’t assign to <code>4</code>, so you can’t assign to <code>$sides-of-a-square</code>.</p>
</div>
<div class="paragraph">
<p>If you first assign to a scalar variable then <strong>bind</strong> to that variable you end up with two names for the same variable:</p>
</div>
<div class="paragraph">
<p>它不是使变量成为不可变的绑定运算符。它只是让左边的东西和右边的东西相同。在这种情况下，$ sides-of-square实际上是4而不仅仅是恰好存储4的变量。你不能分配给4，所以你不能分配到$ side-of-a-square。</p>
</div>
<div class="paragraph">
<p>如果你首先分配给标量变量然后绑定到该变量，则最终会为同一个变量使用两个名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $number = 3;
my $sides := $number;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can change <code>$sides</code> or <code>$number</code>, and the “other” will change. But there is no “other” to change because they are the same thing! You might think of these as aliases, but it’s a bit more complicated.</p>
</div>
<div class="paragraph">
<p>There’s an important concept here that you should learn early. A variable assignment with <code>=</code> creates a container, then puts a value in that container. A container is just a box that can store a value. You can add, remove, and replace the value in that box. This is mostly invisible to you because the language handles it for you.</p>
</div>
<div class="paragraph">
<p>The binding operator skips this containerization. It aliases the thingy on the right side directly. If it’s already a container that’s what you bind to. You can break down the action of assignment into two steps. First you bind to an anonymous container. That’s right: a container can exist without a name. An anonymous container is just the <code>$</code> sigil:</p>
</div>
<div class="paragraph">
<p>你可以更改$ sides或$ number，“other”将更改。但是没有“其他”可以改变，因为它们是同一个东西！你可能会将这些视为别名，但它有点复杂。</p>
</div>
<div class="paragraph">
<p>这里有一个重要的概念，你应该尽早学习。带=的变量赋值创建一个容器，然后在该容器中放入一个值。容器只是一个可以存储值的盒子。你可以添加，删除和替换该框中的值。这对你来说几乎是不可见的，因为语言会为你处理它。</p>
</div>
<div class="paragraph">
<p>绑定操作员跳过此容器化。它直接在右侧别名。如果它已经是一个与你绑定的容器。你可以将分配操作分解为两个步骤。首先绑定到匿名容器。没错：容器可以没有名字而存在。一个匿名的容器只是$ sigil：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $number := $;</code></pre>
</div>
</div>
<div class="paragraph">
<p>After that you can change the value in the container using <code>=</code>:</p>
</div>
<div class="paragraph">
<p>之后，你可以使用=更改容器中的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$number = 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes you’ll need to know if the thingy you have is a container, and there will be times you’ll want to skip the container. Start thinking about this early, before you develop bad habits, and your programming life will be easier.</p>
</div>
<div class="paragraph">
<p>有时你需要知道你拥有的东西是否是一个容器，有时候你会想要跳过容器。在你养成坏习惯之前就开始考虑这个问题，你的编程生活会更容易。</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_main_program">1.9. A MAIN Program</h3>
<div class="paragraph">
<p>In [Chapter 1](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch01.html#camelia-introduction" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch01.html#camelia-introduction</a>) you saw some examples of statements. This is a complete program:</p>
</div>
<div class="paragraph">
<p>在第1章中，你看到了一些语句示例。这是一个完整的程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Hello Raku!&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you’ve programmed in some other languages you may have encountered a subroutine called <code>main</code> or something similar. Those languages probably required you to put your program inside that routine; when you ran your program it automatically ran that subroutine for you. Raku is a little different because it assumes that your entire file is already that <code>main</code>.</p>
</div>
<div class="paragraph">
<p>You can still have such a subroutine though. If you define a <code>MAIN</code> subroutine (all caps!) your program will call that automatically if you run the program:</p>
</div>
<div class="paragraph">
<p>如果你使用其他语言进行编程，则可能遇到了一个名为main或类似的子程序。那些语言可能要求你把你的程序放在那个例程中;当你运行程序时，它会自动为你运行该子程序。 Raku有点不同，因为它假设你的整个文件已经是主要文件。</p>
</div>
<div class="paragraph">
<p>你仍然可以拥有这样的子程序。如果你定义一个MAIN子程序（所有大写！），你的程序将在你运行程序时自动调用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN {
    put &#39;Hello Raku!&#39;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You won’t read about subroutines until [Chapter 11](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch11.html#camelia-subroutines" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch11.html#camelia-subroutines</a>), so trust me for a bit on this one. You’ll read more of an explanation of <code>MAIN</code> as you go through the book.</p>
</div>
<div class="paragraph">
<p>EXERCISE 2.1Create both versions of the “Hello Raku” program. The one-line version and <code>MAIN</code> version should give you the same output.</p>
</div>
<div class="paragraph">
<p>在第11章之前，你不会阅读关于子程序的内容，所以请相信我一点。在阅读本书时，你将阅读更多关于MAIN的解释。</p>
</div>
<div class="paragraph">
<p>EXERCISE 2.1创建“Hello Raku”程序的两个版本。单行版本和MAIN版本应该为你提供相同的输出。</p>
</div>
<div class="sect3">
<h4 id="_program_arguments">1.9.1. Program Arguments</h4>
<div class="paragraph">
<p>You probably have seen other command-line programs that take arguments. The filenames you give to <strong>more</strong> or <strong>type</strong> are arguments that tell those programs which file’s contents you want to see:</p>
</div>
<div class="paragraph">
<p>你可能已经看过其他带参数的命令行程序。你提供给更多或类型的文件名是告诉这些程序你想要查看哪些文件内容的参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% more hello-world.p6

C:\ type hello-world.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your Raku program can take arguments too. When you try it with your existing program you get a help message instead of the output that you expected:</p>
</div>
<div class="paragraph">
<p>你的Raku程序也可以参数。当你使用现有程序尝试它时，你会得到一条帮助消息，而不是你期望的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku hello-world-main.p6 1 2 3
Usage:
  hello-world-main.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>To accept arguments you have to tell <code>MAIN</code> to expect them. Your program had an implicit set of empty parentheses in it. Those parentheses define the parameters, which are the templates for the arguments. Arguments are what you get; parameters are what you wanted. In this case you didn’t specify any parameters, so your program expects no arguments and complains if you try to give it some:</p>
</div>
<div class="paragraph">
<p>要接受参数，你必须告诉MAIN期望它们。你的程序中有一组隐含的空括号。这些括号定义参数，这些参数是参数的模板。争论就是你得到的;参数是你想要的。在这种情况下，你没有指定任何参数，因此如果你尝试给它一些，你的程序不需要参数和抱怨：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN () {
    put &#39;Hello Raku!&#39;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can change this. You can specify a variable in the parameter list. One parameter allows your <code>MAIN</code> subroutine to take exactly one argument. Change your <code>put</code> statement to output the value in <code>$thingy</code> by defining a signature after the subroutine name:</p>
</div>
<div class="paragraph">
<p>你可以改变这个。你可以在参数列表中指定变量。一个参数允许MAIN子例程只取一个参数。通过在子例程名称后定义签名，更改put语句以输出$ thingy中的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ( $thingy ) {
    put $thingy;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you run this program with no command-line arguments you get a different help message. You needed one argument and gave it none. Curiously, the help message tells you the name of the variable you used in the parameter:</p>
</div>
<div class="paragraph">
<p>如果在没有命令行参数的情况下运行此程序，则会收到不同的帮助消息。你需要一个论点并且没有给它。奇怪的是，帮助消息告诉你在参数中使用的变量的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku main-one-thingy.p6
Usage:
  main-one-thingy.p6 &lt;thingy&gt;

% raku main-one-thingy.p6 Hello
Hello</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quote the entire value or escape the whitespace (Unix shells only) to preserve whitespace inside a value you want to give to the thingy:</p>
</div>
<div class="paragraph">
<p>引用整个值或转义空格（仅限Unix shell）以保留要为thingy赋值的内部空格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku main-one-thingy.p6 &#34;Hello Raku&#34;
Hello Raku

% raku main-one-thingy.p6 Hello\ Perl\ 6
Hello Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can specify more than one parameter by separating them with commas. You can also output multiple things in a single <code>put</code> by separating them with commas:</p>
</div>
<div class="paragraph">
<p>你可以通过用逗号分隔多个参数来指定它们。你也可以通过用逗号分隔它们来输出单个put中的多个内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ( $thingy1, $thingy2 ) {
    put &#39;1: &#39;, $thingy1;
    put &#39;2: &#39;, $thingy1;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you have to give your program two arguments. If you don’t give it exactly two arguments it doesn’t work:</p>
</div>
<div class="paragraph">
<p>现在你必须给你的程序两个参数。如果你不准确地给它两个参数它不起作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku main-two-thingys.p6 Hamadryas
Usage:
  main-two-thingys.p6 &lt;thingy1&gt; &lt;thingy2&gt;

% raku main-two-thingys.p6 Hamadryas perlicus
1: Hamadryas
2: perlicus</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong>Hamadryas perlicus</strong> is the (un)scientific name I’ve given to the butterfly on the cover. Sometimes I call him “Hama” for short because it rhymes with “llama.”
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Sometimes you don’t want to specify two arguments even though you need two values. You can specify a default value for some parameters. Use the <code>=</code> to specify the default:</p>
</div>
<div class="paragraph">
<p>Hamadryas perlicus *是我在封面上给蝴蝶的（非）学名。有时我称他为“哈马”，因为它与“美洲驼”押韵。</p>
</div>
<div class="paragraph">
<p>有时你不希望指定两个参数，即使你需要两个值。你可以为某些参数指定默认值。使用=指定默认值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ( $thingy1, $thingy2 = &#39;perlicus&#39; ) {
    put &#39;1: &#39;, $thingy1;
    put &#39;2: &#39;, $thingy2;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you call it with two arguments it works as before, but when you specify exactly one argument it uses the default for the second:</p>
</div>
<div class="paragraph">
<p>当你用两个参数调用它时，它像以前一样工作，但是当你指定一个参数时，它使用第二个参数的默认值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku main-two-thingys-default.p6 Hamadryas februa
1: Hamadryas
2: februa

% raku main-two-thingys-default.p6 Hamadryas
1: Hamadryas
2: perlicus</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any parameters with defaults have to show up after those without them. You’ll see much more about parameters in [Chapter 11](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch11.html#camelia-subroutines" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch11.html#camelia-subroutines</a>).</p>
</div>
<div class="paragraph">
<p>EXERCISE 2.2Create a program that takes three command-line arguments and outputs them on separate, numbered lines. Give two of the parameters default values.</p>
</div>
<div class="paragraph">
<p>任何带有默认值的参数都必须显示在没有它们的参数之后。你将在第11章中看到有关参数的更多信息。</p>
</div>
<div class="paragraph">
<p>练习2.2创建一个带有三个命令行参数的程序，并将它们输出到不同的编号行上。给出两个参数默认值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_prompting_for_values">1.9.2. Prompting for Values</h4>
<div class="paragraph">
<p>The <code>prompt</code> routine outputs a message asking for input. When you type some text followed by Return `prompt`reads that text and returns it. You can assign that value to a variable:</p>
</div>
<div class="paragraph">
<p>提示例程输出要求输入的消息。当你键入一些文本，然后返回提示时，将读取该文本并将其返回。你可以将该值分配给变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $answer = prompt &#39;What is your favorite number? &#39;;
put &#39;Your answer was [&#39;, $answer, &#39;]&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you run the program you see the prompt and start typing right after it on the same line:</p>
</div>
<div class="paragraph">
<p>运行程序时，你会看到提示并在同一行后面开始输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku prompt.p6
What is your favorite number? 137
Your answer was [137]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value you get back from <code>prompt</code> does not include the line ending from Return.</p>
</div>
<div class="paragraph">
<p>EXERCISE 2.3Write a program that asks for your name and then outputs a greeting to that name. If your name is Gilligan it should output “Hello Gilligan.” Can you use a <code>MAIN</code> subroutine and only prompt if there’s no command-line argument?</p>
</div>
<div class="paragraph">
<p>从提示中返回的值不包括以Return结尾的行。</p>
</div>
<div class="paragraph">
<p>练习2.3写一个程序，询问你的名字，然后输出一个问候语到该名称。如果你的名字是Gilligan，它应该输出“Hello Gilligan。”你能使用MAIN子程序，只有在没有命令行参数的情况下才会提示吗？</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_literal_numbers">1.10. Literal Numbers</h3>
<div class="paragraph">
<p>Literal values are those that you type directly into the program. They are fixed and are sometimes called “hardcoded” values because they exist directly in the program instead of coming from input or configuration. These are terms, and you can write them in several ways.</p>
</div>
<div class="paragraph">
<p>An integer is a whole number. These are the numbers of everyday life expressed with the digits from 0 to 9:</p>
</div>
<div class="paragraph">
<p>文字值是你直接在程序中键入的值。它们是固定的，有时称为“硬编码”值，因为它们直接存在于程序中，而不是来自输入或配置。这些是术语，你可以通过多种方式编写它们。</p>
</div>
<div class="paragraph">
<p>整数是整数。这些是用0到9的数字表示的日常生活数量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">137
4
-19
0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Digital computers are more comfortable with powers of two. Prefix a literal number with <code>0x</code> to specify a hexadecimal number. That’s base 16 and uses the digits 0 to 9 and the letters <strong>A</strong> to <strong>F</strong> (in either case) to represent 0 to 15:</p>
</div>
<div class="paragraph">
<p>数字计算机更适合两种能力。使用0x前缀一个文字数字以指定十六进制数字。这是基数16并使用数字0到9和字母A到F（在任何一种情况下）代表0到15：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">0x89
0xBEEF
-0x20</code></pre>
</div>
</div>
<div class="paragraph">
<p>Octal numbers are base 8 and use the digits 0 to 7. Prefix a literal octal number with <code>0o</code>:</p>
</div>
<div class="paragraph">
<p>八进制数是基数8并使用数字0到7.用0o前缀一个文字八进制数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">0o211
-0o177</code></pre>
</div>
</div>
<div class="paragraph">
<p>Binary numbers are base 2 and use the digits 0 and 1. These are handy when you deal with binary formats. Prefix them with <code>0b</code>:</p>
</div>
<div class="paragraph">
<p>二进制数字是基数2并使用数字0和1.当你处理二进制格式时，这些都很方便。用0b作为前缀：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">0b10001001</code></pre>
</div>
</div>
<div class="paragraph">
<p>Choose a representation that’s easy for you to understand or that’s natural for the task. The compiler converts those representations into values that the physical computer can use. It doesn’t care which one you use; they are just numbers. These are all the same value:</p>
</div>
<div class="paragraph">
<p>选择一个易于理解或对任务而言很自然的表示。编译器将这些表示转换为物理计算机可以使用的值。它并不关心你使用哪一个;他们只是数字。这些都是相同的价值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">137           # decimal,     base 10
0b10001001    # binary,      base  2
0o211         # octal,       base  8
0x89          # hexadecimal, base 16</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 2.4In the REPL try the different base examples. What decimal value does the REPL echo?</p>
</div>
<div class="paragraph">
<p>Perhaps you don’t like the ASCII digits 0 to 9. You can use any digits that Unicode supports; Raku knows about anything that’s a number character. Eastern Arabic numerals work. Notice that the radix prefixes are the same:</p>
</div>
<div class="paragraph">
<p>EXERCISE 2.4在REPL中尝试不同的基础示例。 REPL回显的十进制值是多少？</p>
</div>
<div class="paragraph">
<p>也许你不喜欢ASCII数字0到9.你可以使用Unicode支持的任何数字; Raku知道任何数字角色。东部阿拉伯数字工作。请注意，基数前缀是相同的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">١٣٧
0b١٠٠٠١٠٠١
0o٢١١
0x٨٩</code></pre>
</div>
</div>
<div class="paragraph">
<p>So do Bengali digits:</p>
</div>
<div class="paragraph">
<p>孟加拉语数字也是如此：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">১৩৭
0b১০০০১০০১
0o২১১
0x৮৯</code></pre>
</div>
</div>
<div class="paragraph">
<p>I don’t encourage you to represent numbers like this in your program, but Raku understands them. This is useful when you are processing text that contains them. Your program will be able to convert these to a number type.</p>
</div>
<div class="paragraph">
<p>You can choose other bases up to base 36. You’ve already seen base 16, which uses 0 to 9 and <strong>A</strong> to <strong>F</strong>. Base 17 would add <strong>G</strong>, and so on up to base 36, which includes <strong>Z</strong>. Use a colon before the base (in decimal), then put the digits inside angle brackets:</p>
</div>
<div class="paragraph">
<p>我不鼓励你在你的程序中代表这样的数字，但Raku理解它们。当你处理包含它们的文本时，这非常有用。你的程序将能够将这些转换为数字类型。</p>
</div>
<div class="paragraph">
<p>你可以选择基数为36的其他基数。你已经看过基数为16，使用0到9和A到F.基数17将添加G，依此类推到基数36，其中包括Z.使用冒号之前基数（十进制），然后将数字放在尖括号内：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">:7<i class="conum" data-value="254"></i><b>(254)</b>
:19&lt;IG88&gt;
:26&lt;HAL9000&gt;
:36&lt;THX1138&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 2.5Try the unusual base examples in the REPL. What decimal numbers are they?</p>
</div>
<div class="paragraph">
<p>练习2.5尝试REPL中不寻常的基础示例。它们的十进制数是多少？</p>
</div>
<div class="sect3">
<h4 id="_formatting_numbers">1.10.1. Formatting Numbers</h4>
<div class="paragraph">
<p>Literal numbers are objects. You can call methods on objects. The <code>.base</code> method allows you to specify the base that you want to represent:</p>
</div>
<div class="paragraph">
<p>文字数字是对象。你可以在对象上调用方法。 .base方法允许你指定要表示的基数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put 0x89.base: 10;     #  137</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can choose some other base, up to 36:</p>
</div>
<div class="paragraph">
<p>你可以选择其他一些基地，最多36个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put 0x89.base:  2;     # 10001001
put 0x89.base:  8;     # 211
put 0x89.base: 16;     # 89</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 2.6Write a program that takes a decimal number as its single command-line argument. Output its binary, octal, decimal, and hexadecimal values. What happens if you give it a hexadecimal number on the command line? What if you specify the decimal number in Eastern Arabic digits?</p>
</div>
<div class="paragraph">
<p>In the previous exercise you couldn’t specify a hexadecimal number as an argument. That’s because you weren’t actually specifying a number as an argument. It was text made up of digit characters. If you want to use a hexadecimal number you have to tell your program how to convert the number. You can use <code>.parse-base</code> for that. You tell it which base you expect and it does the rest:</p>
</div>
<div class="paragraph">
<p>练习2.6编写一个以十进制数作为单个命令行参数的程序。输出二进制，八进制，十进制和十六进制值。如果在命令行上给它一个十六进制数，会发生什么？如果你在东部阿拉伯数字中指定十进制数怎么办？</p>
</div>
<div class="paragraph">
<p>在上一个练习中，你无法将十六进制数指定为参数。那是因为你实际上没有指定一个数字作为参数。它是由数字字符组成的文本。如果要使用十六进制数，则必须告诉程序如何转换数字。你可以使用.parse-base。你告诉它你期望的基础，剩下的就是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $number = $thingy.parse-base: 16;</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 2.7Modify your answer from the previous exercise to accept a hexadecimal number command-line argument. Your program will now only handle hexadecimal numbers if you’re using only what you’ve seen so far.</p>
</div>
<div class="paragraph">
<p>练习2.7修改上一练习中的答案以接受十六进制数字命令行参数。如果你只使用到目前为止看到的内容，你的程序现在只能处理十六进制数字。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_numeric_operations">1.11. Numeric Operations</h3>
<div class="paragraph">
<p>Numeric operators transform numbers into new values. The simplest demonstration is to immediately output the result. The <code>+</code> is the addition operator:</p>
</div>
<div class="paragraph">
<p>数字运算符将数字转换为新值。最简单的演示是立即输出结果。 +是加法运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put 2 + 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also store the result in a variable and then output it. The item assignment is an operation and so is the addition. The <code>+</code> happens first because it has higher precedence:</p>
</div>
<div class="paragraph">
<p>你还可以将结果存储在变量中，然后将其输出。项目分配是一项操作，添加也是如此。 +首先发生，因为它具有更高的优先级：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum = 2 + 2;
put $sum;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are operators for subtraction (<code>-</code>), multiplication (<code><strong></strong></code><strong>), division (<code>/</code>), and exponentiation (<code></code></strong><code>*</code>). You’ll see more in the next chapter.</p>
</div>
<div class="paragraph">
<p>Outputting a single number is easy. If you want to output a series of numbers, you could have multiple lines:</p>
</div>
<div class="paragraph">
<p>有减法（ - ），乘法（<strong>），除法（/）和取幂（</strong>*）的运算符。你将在下一章中看到更多内容。</p>
</div>
<div class="paragraph">
<p>输出单个数字很容易。如果要输出一系列数字，可以有多行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum = 0;
put $sum + 1;
put $sum + 1 + 1;
put $sum + 1 + 1 + 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each time you add one more to it. That repeats a lot of structure. You can back up a little to make an improvement where the <code>put</code> statement is the same in each case:</p>
</div>
<div class="paragraph">
<p>每次再添加一个。这重复了很多结构。在每种情况下，put语句相同时，你可以稍微备份以进行改进：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum = 0;

$sum = $sum + 1;
put $sum;

$sum = $sum + 1;
put $sum;

$sum = $sum + 1;
put $sum;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>$sum</code> variable shows up on the left and right of the assignment. That’s okay; the compiler’s not going to get confused. It evaluates everything on the right side using the current value of <code>$sum</code>. When it’s reduced the right side to its value it assigns that to <code>$sum</code>, replacing the value that’s already there. You’re still doing the same thing over and over again, but now that same thing looks exactly like the other things.</p>
</div>
<div class="paragraph">
<p>Now it’s time to introduce <code>loop</code>. It repeatedly executes the code inside its braces. This code will run until you interrupt the program (probably with Control-C):</p>
</div>
<div class="paragraph">
<p>$ sum变量显示在赋值的左侧和右侧。没关系;编译器不会混淆。它使用$ sum的当前值评估右侧的所有内容。当它将右侧减少到它的值时，它会将其分配给$ sum，替换已存在的值。你仍然一遍又一遍地做同样的事情，但现在同样的事情看起来和其他事情完全一样。</p>
</div>
<div class="paragraph">
<p>现在是时候介绍循环了。它重复执行括号内的代码。此代码将一直运行，直到你中断程序（可能使用Control-C）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum = 0;
loop {
    $sum = $sum + 1;
    put $sum;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can combine the two statements inside <code>loop</code>. The result of an assignment is the value that you assigned. Here, you add to <code>$sum</code> then assign that result back to <code>$sum</code>, and use that expression as the value you give to <code>put</code>:</p>
</div>
<div class="paragraph">
<p>你可以在循环内组合这两个语句。赋值的结果是你指定的值。在这里，你添加$ sum然后将该结果分配回$ sum，并将该表达式用作你放置的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum = 0;
loop {
    put $sum = $sum + 1;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This sort of structure is so common that it has its own operator: the <code>++</code> unary prefix autoincrement operator. It adds one before you use the value:</p>
</div>
<div class="paragraph">
<p>这种结构很常见，它有自己的运算符：++一元前缀自动增量运算符。它在你使用该值之前添加一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum = 0;
loop {
    put ++$sum;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s also a unary postfix version. It adds one to the value, but after you use it:</p>
</div>
<div class="paragraph">
<p>还有一个一元的后缀版本。它会在值中添加一个，但在你使用它之后：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum = 0;
loop {
    put $sum++;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 2.8What’s the difference in output in the two programs that use the prefix and postfix autoincrement operators? Can you figure it out without running the programs?</p>
</div>
<div class="paragraph">
<p>So far you’ve declared variables with <code>my</code>. That limits their definition to the current scope. That’s a problem for variables you want in a <code>loop</code> if they should keep their values. This wouldn’t work because each time through the <code>loop</code> would get a new variable even though you used the same name:</p>
</div>
<div class="paragraph">
<p>练习2.8使用前缀和后缀自动增量运算符的两个程序的输出差异是什么？如果不运行程序，你能搞清楚吗？</p>
</div>
<div class="paragraph">
<p>到目前为止，你已经用我的声明了变量。这将他们的定义限制在当前范围内。如果它们应该保留它们的值，那么在循环中你想要的变量就是一个问题。这不起作用，因为即使你使用相同的名称，每次循环都会获得一个新变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop {
    my $sum = 0;
    put $sum++;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Declare the variable with <code>state</code> instead: this makes the variable private to the block but doesn’t reset it each time through it. A <code>state</code> declaration only executes the first time through the block and is ignored after that. The assignment to <code>$sum</code> happens once:</p>
</div>
<div class="paragraph">
<p>用状态声明变量：这使得变量对块是私有的，但每次都不会重置它。状态声明仅在块中第一次执行，之后将被忽略。 $ sum的赋值发生一次：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop {
    state $sum = 0;
    put $sum++;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a bit nicer because everything about <code>$sum</code> is contained inside the block. Always try to give variables the smallest scope they need. If they don’t need to be outside the block define them inside it.</p>
</div>
<div class="paragraph">
<p>Those operators add or subtract one. If you want to increment by a different number you’re back to using <code>+</code>:</p>
</div>
<div class="paragraph">
<p>这有点好，因为$ sum的所有内容都包含在块中。始终尝试为变量提供所需的最小范围。如果他们不需要在块之外定义它们。</p>
</div>
<div class="paragraph">
<p>那些运营商增加或减少一个。如果你想增加一个不同的数字，你就回到了使用+：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop {
    state $sum = 0;
    put $sum = $sum + 2;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s still one too many <code>$sum`s in that code. There’s a special form of the assignment operator that lets you shorten this. You can put the infix operator before the `=</code>, like this:</p>
</div>
<div class="paragraph">
<p>那段代码中仍然有太多$ sum。有一种特殊形式的赋值运算符可以让你缩短它。你可以在=之前放置中缀运算符，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$sum += 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This convenient shorthand is binary assignment. It’s the same as using the variable on both sides of the <code>=</code> but it’s easier to type:</p>
</div>
<div class="paragraph">
<p>这种方便的简写是二进制赋值。它与在=的两侧使用变量相同，但更容易输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$sum = $sum + 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most binary operators can do this, even if they are multiple characters:</p>
</div>
<div class="paragraph">
<p>大多数二元运算符都可以执行此操作，即使它们是多个字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$product *= 5;
$quotient /= 2;
$is-divisible %%= 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 2.9Rewrite the looping program to output only multiples of three by adding the appropriate interval to the previous value. Further modify the program to accept the multiple as a command-line argument.</p>
</div>
<div class="paragraph">
<p>练习2.9通过将适当的间隔添加到上一个值，重写循环程序以仅输出三的倍数。进一步修改程序以接受多个作为命令行参数。</p>
</div>
</div>
<div class="sect2">
<h3 id="_conditional_execution">1.12. Conditional Execution</h3>
<div class="paragraph">
<p>This chapter has been working its way to a number-guessing program. You know a little bit about numbers, command-line arguments, prompting, and looping. Next you need to know how to decide between two or more paths in your code. That comes in two parts: comparing things to get an answer and using that answer to select the next thing to do.</p>
</div>
<div class="paragraph">
<p>本章一直致力于数字猜测程序。你对数字，命令行参数，提示和循环有一点了解。接下来，你需要知道如何在代码中的两个或多个路径之间做出决定。这分为两部分：比较事情以获得答案并使用该答案选择下一步要做的事情。</p>
</div>
<div class="sect3">
<h4 id="_boolean_values">1.12.1. Boolean Values</h4>
<div class="paragraph">
<p>Boolean values are logical values that can be one thing or the other: yes or no, on or off, or <code>True</code> or <code>False</code>. These are of type [<code>Bool</code>](<a href="https://docs.raku.org/type/Bool.html" class="bare">https://docs.raku.org/type/Bool.html</a>). You’ll use these values to decide between different paths in your program. First, a little Boolean math.</p>
</div>
<div class="paragraph">
<p>You can combine Boolean values with logical operators. The <code>&amp;&amp;</code> logical AND operator evaluates to <code>True</code> if both operands are <code>True</code>. The <code>||</code> logical OR operator evaluates to <code>True</code> if one or more operators are <code>True</code>:</p>
</div>
<div class="paragraph">
<p>布尔值是逻辑值，可以是一个或另一个：是或否，打开或关闭，或者是True或False。这些是Bool类型。你将使用这些值来决定程序中的不同路径。首先，一点布尔数学。</p>
</div>
<div class="paragraph">
<p>你可以将布尔值与逻辑运算符组合使用。如果两个操作数均为True，则&amp;&amp; logical AND运算符的计算结果为True。 ||如果一个或多个运算符为True，则逻辑OR运算符的计算结果为True：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; True &amp;&amp; True
True
&gt; True &amp;&amp; False
False
&gt; True || True
True
&gt; True || False
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>All of these operators have spelled out “word” versions. These are the lowest-precedence operators (aside from the sequence operators). These operations always happen last:</p>
</div>
<div class="paragraph">
<p>所有这些运营商都拼写出“单词”版本。这些是优先级最低的运算符（除了序列运算符）。这些操作总是最后发生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; True and True
True
&gt; True and False
False
&gt; True or False
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>!</code> unary prefix operator changes one [<code>Bool</code>](<a href="https://docs.raku.org/type/Bool.html" class="bare">https://docs.raku.org/type/Bool.html</a>) value to the other one: <code>True</code> becomes <code>False</code>, and the other way around. This is called negating the condition. <code>not</code> is the low-precedence version of that:</p>
</div>
<div class="paragraph">
<p>的！一元前缀运算符将一个Bool值更改为另一个：True变为False，反之亦然。这被称为否定条件。不是那个低优先级的版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; ! True
False
&gt; ! False
True
&gt; not True
False
&gt; not False
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>Many objects can collapse themselves to a [Bool](<a href="https://docs.raku.org/type/Bool.html" class="bare">https://docs.raku.org/type/Bool.html</a>) value when needed, but it’s up to each object how it does that. For numbers, <code>0</code> is <code>False</code> and everything else is <code>True</code>.</p>
</div>
<div class="paragraph">
<p>For most objects (not just numbers) you can use a prefix <code>?</code> to coerce into either <code>True</code> or <code>False</code>. It calls the <code>.Bool</code> method on the object. The builtin types know how to convert their values to Booleans using whatever rule they decide. For numbers, <code>0</code> is <code>False</code> and everything else is <code>True</code>:</p>
</div>
<div class="paragraph">
<p>许多对象可以在需要时将自身折叠为Bool值，但是由每个对象决定它是如何做到的。对于数字，0为False，其他所有为True。</p>
</div>
<div class="paragraph">
<p>对于大多数对象（不仅仅是数字），你可以使用前缀？强迫无论是真还是假。它在对象上调用.Bool方法。内置类型知道如何使用他们决定的任何规则将其值转换为布尔值。对于数字，0为False，其他一切为True：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; ?1
True
&gt; ?0
False
&gt; ?-1
True
&gt; 1.Bool
True
&gt; 0.Bool
False
&gt; (-1).Bool
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.so</code> method and <code>so</code> routine do the same thing:</p>
</div>
<div class="listingblock">
<div class="title">so方法和例程也做同样的事情：</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; 1.so
True
&gt; 0.so
False
&gt; (-1).so
True
&gt; so 0
False
&gt; so 1
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>Type objects know what they are but they have no concrete value. They are always <code>False</code>:</p>
</div>
<div class="paragraph">
<p>类型对象知道它们是什么，但它们没有具体的价值。他们总是错的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; Int.so
False</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some things that want Boolean values will implicitly do these coercions for you.</p>
</div>
<div class="paragraph">
<p>一些需要布尔值的东西会隐式地为你做这些强制。</p>
</div>
<div class="sect4">
<h5 id="_short_circuit_operators">SHORT-CIRCUIT OPERATORS</h5>
<div class="paragraph">
<p>The logical operators don’t really evaluate to Boolean values. <code>&amp;&amp;</code> and <code>||</code> test their expressions for <code>True</code> or <code>False</code>, but the entire structure evaluates to the last expression it evaluated.</p>
</div>
<div class="paragraph">
<p><code>||</code> needs only one expression to be <code>True</code> for the entire thing to be <code>True</code>. If it gets back anything that’s <code>True</code>, then the entire thing is <code>True</code>. All of these are <code>False</code>, but you can see the last expression <code>||</code> evaluated:</p>
</div>
<div class="paragraph">
<p>逻辑运算符并不真正评估为布尔值。 &amp;&amp;和||测试他们的表达式是True还是False，但整个结构的计算结果是它评估的最后一个表达式。</p>
</div>
<div class="paragraph">
<p>||只需要一个表达式为True，整个事物就是True。如果它返回任何真实的东西，那么整个事情就是真的。所有这些都是假的，但你可以看到最后一个表达式||评价：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 0 || Nil
Nil
&gt; 0 || False
False
&gt; 0 || Failure
(Failure)</code></pre>
</div>
</div>
<div class="paragraph">
<p>These are <code>True</code>. When <code>||</code> finds any value that would evaluate to <code>True</code> as a Boolean it stops right away. These are sometimes called short-circuit operators:</p>
</div>
<div class="paragraph">
<p>这些是真的。当||找到任何值将被评估为True的值作为它立即停止的布尔值。这些有时被称为短路运营商：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; True || 0
True
&gt; 137 || True
137</code></pre>
</div>
</div>
<div class="paragraph">
<p>It’s the same with <code>&amp;&amp;</code>. It returns the last expression it evaluated. If that value is <code>False</code> then one of those expressions was <code>False</code>:</p>
</div>
<div class="paragraph">
<p>与&amp;&amp;相同。它返回它评估的最后一个表达式。如果该值为False，则其中一个表达式为False：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 0 &amp;&amp; 137
0
&gt; 42 &amp;&amp; 8
8</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s a third operator that’s similar. The defined-or operator, <code>//</code>, tests its left side for definedness. If the left value is defined that’s the result, even if that value is <code>False</code>:</p>
</div>
<div class="paragraph">
<p>还有第三个类似的运营商。定义的或运算符//测试其左侧的定义。如果定义左值是结果，即使该值为False：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 0 // 137
0
&gt; Nil // 19
19</code></pre>
</div>
</div>
<div class="paragraph">
<p>A type object is never defined:</p>
</div>
<div class="paragraph">
<p>永远不会定义类型对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; Int // 7
7</code></pre>
</div>
</div>
<div class="paragraph">
<p>The defined-or is part of a common technique to set a value if a variable doesn’t already have one (or has one that is not defined). You’ll see it as a binary assignment:</p>
</div>
<div class="paragraph">
<p>如果变量还没有（或者没有定义一个变量），则定义或者是设置值的常用技术的一部分。你会将其视为二进制赋值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$value //= 137;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_comparing_things">1.12.2. Comparing Things</h4>
<div class="paragraph">
<p>A comparator evaluates to <code>True</code> or <code>False</code> based on some relative measure. The numeric equality operator, <code>==</code>, compares two numbers to test if they are exactly the same. If they are the same it evaluates to <code>True</code>; otherwise it evaluates to <code>False</code>:</p>
</div>
<div class="paragraph">
<p>比较器根据某些相对度量计算为True或False。数字相等运算符==，比较两个数字以测试它们是否完全相同。如果它们相同则评估为True;否则评估为False：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 1 == 1
True
&gt; 1 == 3
False</code></pre>
</div>
</div>
<div class="paragraph">
<p>The numeric inequality operator <code>!=</code> tests that two numbers are <strong>not</strong> the same:</p>
</div>
<div class="paragraph">
<p>数值不等式运算符！=测试两个数字不相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 1 != 1
False
&gt; 1 != 3
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some operators have two versions. You just saw the “ASCII” version, but there’s also a “fancy” Unicode version with <code>≠</code>:</p>
</div>
<div class="paragraph">
<p>一些运营商有两个版本。你刚看到“ASCII”版本，但也有一个“奇特”的Unicode版本，≠：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 1 ≠ 3
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of a literal value you can compare a variable. It doesn’t matter which side you put the values on:</p>
</div>
<div class="paragraph">
<p>你可以比较变量而不是文字值。将值放在哪一方并不重要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; my $number = 37
37
&gt; $number == 38
False
&gt; 39 == $number
False
&gt; $number == 37
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can have an expression on either side of the comparator or variables on both sides:</p>
</div>
<div class="paragraph">
<p>你可以在比较器的任一侧或两侧的变量上都有一个表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 2 + 2 == 4
True
&gt; 5 == 2
False
&gt; my $thing1 = 17
17
&gt; my $thing2 = 13
13
&gt; $thing1 == $thing2
False
&gt; $thing1 != $thing2
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>&gt;</code> tests that the first operand is numerically greater than the second number and the <code>&lt;</code> tests that the first is less than the second:</p>
</div>
<div class="paragraph">
<p><code>&gt;</code> 测试第一个操作数在数值上大于第二个数字，并且&lt;测试第一个操作数小于第二个数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 1 &gt; 3
False
&gt; 1 &lt; 3
True
&gt; 3 &lt; 3
False</code></pre>
</div>
</div>
<div class="paragraph">
<p>With an equals sign the test can include the number. <code>&gt;=</code> tests that the first number is numerically equal to or greater than the second, and <code>⇐</code> tests that it is less than or equal:</p>
</div>
<div class="paragraph">
<p>使用等号，测试可以包括数字。 &gt; =测试第一个数字在数值上等于或大于第二个数字，并且⇐测试它是否小于或等于：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 3 &lt; 3
False
&gt; 3 &lt;= 3
True
&gt; 7 &gt; 7
False
&gt; 7 &gt;= 7
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also write these with fancier symbols: <code>&gt;=</code> as <code>≥</code> and <code>⇐</code> as <code>≤</code>.</p>
</div>
<div class="paragraph">
<p>Although not a comparator, the <code>%%</code> operator also returns a Boolean. It tests if the number on the left side is evenly divisible by the number on the right side. This is quite handy:</p>
</div>
<div class="paragraph">
<p>你也可以使用更高的符号来编写这些符号：&gt; =as≥且⇐as≤。</p>
</div>
<div class="paragraph">
<p>虽然不是比较器，但%%运算符也返回一个布尔值。它测试左侧的数字是否可以被右侧的数字整除。这非常方便：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 10 %% 2
True
&gt; 10 %% 3
False</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_chained_comparisons">CHAINED COMPARISONS</h5>
<div class="paragraph">
<p>You can chain comparison operators. You can test that a number is inside or outside of a window (remember the <code>&gt;</code> at the start of the input lines is the REPL prompt) like this:</p>
</div>
<div class="paragraph">
<p>你可以链接比较运算符。你可以测试一个数字是在窗口内部还是外部（请记住输入行开头的&gt;是REPL提示符），如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; $n  = 10
10
&gt; 7 &lt; $n &lt; 15
True
&gt; 7 &lt;= $n &lt; 15
True
&gt; 7 &lt; $n &gt; 15
False
&gt; 7 &gt; $n &lt; 15
False</code></pre>
</div>
</div>
<div class="paragraph">
<p>Without this you’d have to perform additional and separate comparisons:</p>
</div>
<div class="paragraph">
<p>如果没有这个，你必须进行额外的和单独的比较：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; 7 &lt; $n and $n &lt; 15
True</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_conditionally_running_a_statement">CONDITIONALLY RUNNING A STATEMENT</h5>
<div class="paragraph">
<p>The <code>if</code> keyword allows you to evaluate a statement only when some condition is satisfied. The postfix form is the easiest. The part after the <code>if</code> is the condition; it evaluates to <code>True</code> or <code>False</code>:</p>
</div>
<div class="paragraph">
<p>if关键字允许你仅在满足某些条件时评估语句。后缀形式是最简单的。 if之后的部分是条件;它评估为真或假：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $number = 10;
put &#39;The number is even&#39; if $number %% 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The condition is satisfied when it evaluates to <code>True</code>. “Satisfaction” is getting what you want; the <code>if</code> wants (roughly) its condition to be <code>True</code> before it allows the statement to run. If the condition is <code>False</code> the program skips that statement.</p>
</div>
<div class="paragraph">
<p>The <code>if</code> condition is a Boolean context; it calls <code>.Bool</code> for you when you don’t do it explicitly. All of these are the same, but you’ll probably do the last one:</p>
</div>
<div class="paragraph">
<p>在评估为True时满足条件。 “满意”正在得到你想要的东西;在允许语句运行之前，if（大致）将其条件设置为True。如果条件为False，程序将跳过该语句。</p>
</div>
<div class="paragraph">
<p>if条件是布尔上下文;当你不明确地做它时，它会调用.Bool。所有这些都是一样的，但你可能会做最后一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Always outputs&#39; if 1.Bool;
put &#39;Always outputs&#39; if 1.so;
put &#39;Always outputs&#39; if ?1;
put &#39;Always outputs&#39; if 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this you can improve your looping program. Previously you had no way to stop it. The <code>last</code> keyword immediately leaves the loop:</p>
</div>
<div class="paragraph">
<p>有了这个，你可以改善你的循环程序。以前你无法阻止它。最后一个关键字立即离开循环：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop {
    state $sum = 0;
    put $sum++;
    last;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This outputs one line then finishes the loop. That’s what <code>last</code> said to do, but that’s not very useful. This version evaluates <code>last</code> only when <code>$sum</code> is <code>5</code>:</p>
</div>
<div class="paragraph">
<p>这输出一行然后完成循环。这就是上次说的，但这并不是很有用。仅当$ sum为5时，此版本才会评估最后一次：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop {
    state $sum = 0;
    put $sum++;
    last if $sum == 5;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 2.10What is the output of this program? Can you work it out without running the program?</p>
</div>
<div class="paragraph">
<p>The <code>next</code> command is similar to <code>last</code>, but it goes on to the next iteration of the loop. You can use a postfix `if`to skip numbers that are divisible by two (when more than one thingy is using a variable in a condition it’s probably better to change it in a separate step):</p>
</div>
<div class="paragraph">
<p>练习2.10这个程序的输出是什么？你可以在不运行程序的情况下解决问题吗？</p>
</div>
<div class="paragraph">
<p>下一个命令与last类似，但它继续循环的下一次迭代。你可以使用后缀if跳过可被2整除的数字（当一个条件中有多个东西使用变量时，最好在单独的步骤中更改它）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop {
    state $sum = 0;
    $sum += 1;
    next if $sum %% 2;
    put $sum;
    last if $sum &gt; 5;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you get the odd numbers:</p>
</div>
<div class="paragraph">
<p>现在你得到奇数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1
3
5
7</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_conditional_branching">1.12.3. Conditional Branching</h4>
<div class="paragraph">
<p>You can also write <code>if</code> in a block form. The code inside the block runs only when the <code>if</code> is satisfied:</p>
</div>
<div class="paragraph">
<p>你也可以用块形式写。块中的代码仅在满足if时运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $number %% 2 {
    put &#39;The number is even&#39;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use parentheses for <strong>grouping</strong> if you like but they can’t be immediately next to the <code>if</code>; there must be some whitespace:</p>
</div>
<div class="paragraph">
<p>如果你愿意，可以使用括号进行分组，但不能紧跟if;必须有一些空白：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if ($number %% 2) {
    put &#39;The number is even&#39;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>With no space between the <code>if</code> and the <code>(</code> it looks like a subroutine call, which it isn’t. This is a syntax error:</p>
</div>
<div class="paragraph">
<p>if和the之间没有空格（它看起来像子程序调用，它不是。这是语法错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if($number %% 2) {  # ERROR!
    put &#39;The number is even&#39;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>An <code>unless</code> is the opposite sense of <code>if</code>. It executes its block when the condition is <code>False</code>. Another way to think about that is that it skips the block when the condition is <code>True</code>:</p>
</div>
<div class="paragraph">
<p>除非是相反的if。它在条件为False时执行其块。另一种思考方式是在条件为True时跳过块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unless $number %% 2 {
    put &#39;The number is odd&#39;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some people prefer an <code>if</code> with a negated condition:</p>
</div>
<div class="paragraph">
<p>有些人更喜欢具有否定条件的if：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if ! $number %% 2 {
    put &#39;The number is odd&#39;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>An <code>else</code> allows you to provide a default block to run when the <code>if</code> is not satisfied:</p>
</div>
<div class="paragraph">
<p>如果不满足if，则允许你提供默认块以运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $number %% 2 {
    put &#39;The number is even&#39;;
    }
else {
    put &#39;The number is odd&#39;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>These different possibilities are branches of your code. You go down one or the other branch but not both. This is one example of a control structure that decides which code runs.</p>
</div>
<div class="paragraph">
<p>The entire <code>if</code> structure evaluates to a value when you put a <code>do</code> in front of it. The <code>do</code> allows you to treat a control structure as an expression. The result is the last evaluated expression from inside the structure. This way you can isolate only the parts that are different, then use one statement for output:</p>
</div>
<div class="paragraph">
<p>这些不同的可能性是代码的分支。你去一个或另一个分支，但不是两个。这是决定运行哪些代码的控制结构的一个示例。</p>
</div>
<div class="paragraph">
<p>当你在它前面放置一个do时，整个if结构的计算结果为一个值。 do允许你将控制结构视为表达式。结果是结构内部的最后一个计算表达式。这样，你只能隔离不同的部分，然后使用一个语句进行输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $type = do if $number %% 2 { &#39;even&#39; }
              else            { &#39;odd&#39;  }

put &#39;The number is &#39;, $type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can skip the intermediate variable (although if that’s confusing it’s okay to do it the longer way):</p>
</div>
<div class="paragraph">
<p>你可以跳过中间变量（虽然如果这让人感到困惑，可以用更长的方式去做）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;The number is &#39;,
    do if $number %% 2 { &#39;even&#39; }
       else            { &#39;odd&#39;  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s a shortcut for this. The conditional operator has three parts: the condition, the <code>True</code> branch, and the <code>False</code> branch. Between those parts are <code>??</code> and <code>!!</code>:</p>
</div>
<div class="paragraph">
<p>这有一个捷径。条件运算符有三个部分：条件，True分支和False分支。那些部分之间是??和!!：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">CONDITION ?? TRUE BRANCH !! FALSE BRANCH</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using this operator you can rewrite the preceding example. The particular formatting isn’t important, but this fits nicely on the page and lines up the different parts. You don’t use a block, which makes this useful for short bits of code:</p>
</div>
<div class="paragraph">
<p>使用此运算符可以重写前面的示例。特定的格式并不重要，但这非常适合页面并排列不同的部分。你不使用一个块，这使得这对短代码有用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;The number is &#39;,
    $number %% 2 ?? &#39;even&#39; !! &#39;odd&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An <code>elsif</code> specifies another branch with its own condition, so you have three ways this code might run. Some people think zero is neither odd nor even, and they can add another branch for that:</p>
</div>
<div class="paragraph">
<p>elsif指定另一个具有自己条件的分支，因此你可以通过三种方式运行此代码。有些人认为零既不是奇数也不是偶数，他们可以为此添加另一个分支：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $number == 0 {
    put &#39;The number is zero&#39;;
    }
elsif $number %% 2 {
    put &#39;The number is even&#39;;
    }
else {
    put &#39;The number is odd&#39;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code works, but it has some repeated structure because each branch has a <code>put</code>. A <code>do</code> cleans that up nicely. Here’s another way to write that:</p>
</div>
<div class="paragraph">
<p>这段代码有效，但它有一些重复的结构，因为每个分支都有一个put。 A做得很好清理。这是写另一种方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;The number is &#39;, do
       if $number == 0 { &#39;zero&#39; }
    elsif $number %% 2 { &#39;even&#39; }
    else               { &#39;odd&#39;  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 2.11Create a program that outputs the numbers from 1 to 100. However, if the number is a multiple of three, output “Fizz” instead of the number. If it’s a multiple of five, output “Buzz”. If it’s a multiple of both three and five, output “FizzBuzz”.</p>
</div>
<div class="paragraph">
<p>练习2.11创建一个从1到100输出数字的程序。但是，如果数字是3的倍数，则输出“Fizz”而不是数字。如果它是五的倍数，则输出“Buzz”。如果它是三个和五个的倍数，则输出“FizzBuzz”。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_putting_it_all_together">1.13. Putting It All Together</h3>
<div class="paragraph">
<p>With a few more things you can now write the number-guessing program. The <code>.rand</code> method returns a fractional number between 0 and the integer (exclusively):</p>
</div>
<div class="paragraph">
<p>通过更多的东西，你现在可以编写数字猜测程序。 .rand方法返回0和整数（仅限）之间的小数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 100.rand
62.549491627582</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.Int</code> method coerces that to a whole number. It discards the fractional portion; it does not round the number. Put that together with <code>.rand</code> and you get a whole number between 0 and the starting number:</p>
</div>
<div class="listingblock">
<div class="title">Int方法强制转换为整数。它丢弃了小数部分;它没有数字。将它与.rand一起放在0和起始编号之间的整数：</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 100.rand.Int
23</code></pre>
</div>
</div>
<div class="paragraph">
<p>Put that together in a complete program. Choose the number, then test what side of another number (sometimes called the “pivot”) it’s on:</p>
</div>
<div class="paragraph">
<p>把它放在一个完整的程序中。选择数字，然后测试它所在的另一个数字（有时称为“数据透视”）的哪一侧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $number = 100.rand.Int;

if $number &gt; 50 {
    put &#39;The number is greater than 50&#39;;
    }
elsif $number &lt; 50 {
    put &#39;The number is less than 50&#39;;
    }
else {
    put &#39;The number is 50&#39;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run that several times and you should get different output eventually:</p>
</div>
<div class="paragraph">
<p>运行几次，你最终会得到不同的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku random.p6
The number is less than 50
% raku random.p6
The number is less than 50
% raku random.p6
The number is greater than 50</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 2.12Wrap the pivot program in a <code>MAIN</code> subroutine so you can specify the highest possible number as a command-line argument. Default to <code>100</code> if you don’t supply an argument. Adjust that so the program can take another command-line argument to specify the pivot number.</p>
</div>
<div class="paragraph">
<p>In the previous exercise you set the default for the second argument using a hard-coded literal integer:</p>
</div>
<div class="paragraph">
<p>练习2.12在MAIN子例程中包含pivot程序，以便你可以将最高可能的数字指定为命令行参数。如果你不提供参数，则默认为100。调整它，以便程序可以使用另一个命令行参数来指定数据透视表编号。</p>
</div>
<div class="paragraph">
<p>在上一个练习中，你使用硬编码的文字整数设置第二个参数的默认值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ( $highest = 100, $pivot = 50 ) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you run the program with one command-line argument that is less than <code>50</code> (or whatever you chose as your default) the output will always be the same:</p>
</div>
<div class="paragraph">
<p>如果使用一个小于50的命令行参数（或者你选择作为默认值的任何内容）运行程序，则输出将始终相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku number-program.p6 37
The number is less than 50</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use parameters you’ve already specified to compute defaults for other parameters. Use <code>$highest</code> to compute <code>$pivot</code>:</p>
</div>
<div class="paragraph">
<p>你可以使用已指定的参数来计算其他参数的默认值。使用$ highest来计算$ pivot：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ( $highest = 100, $pivot = $highest / 2 ) {</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 2.13Modify your answer to the previous exercise so you can set the pivot to half the highest value. Default to <code>50</code> if you don’t specify two arguments.</p>
</div>
<div class="paragraph">
<p>Now you have everything you need to write your number-guessing program. Your program chooses a secret number that you then have to figure out. This early in the book that seems like a complicated program, but you’ve seen just enough to make it:</p>
</div>
<div class="paragraph">
<p>练习2.13修改上一练习的答案，以便将枢轴设置为最高值的一半。如果未指定两个参数，则默认为50。</p>
</div>
<div class="paragraph">
<p>现在，你拥有编写数字猜测程序所需的一切。你的程序会选择一个你必须弄清楚的密码。在本书的早期，这看起来像一个复杂的程序，但你已经看到了足够的成就：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Choose a secret number (<code>.rand</code>).</p>
</li>
<li>
<p>Loop repeatedly until the person guesses the number (<code>next</code> and <code>last</code>).</p>
</li>
<li>
<p>Get the person’s guess (<code>prompt</code>).</p>
</li>
<li>
<p>Give the person a hint about their guess. Tell them if they are too high or low (comparators, <code>if</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>•选择一个密码（•。和•）。</p>
</div>
<div class="paragraph">
<p>反复循环，直到该人猜到该号码（下一个和最后一个）。</p>
</div>
<div class="paragraph">
<p>得到这个人的猜测（提示）。</p>
</div>
<div class="paragraph">
<p>给这个人一个关于他们猜测的暗示。告诉他们是否太高或太低（比较，如果）。</p>
</div>
<div class="paragraph">
<p>EXERCISE 2.14Implement the number-guessing program. If you supply a command-line argument use that as the maximum number; otherwise use 100. It may help to immediately output the secret number as you get your program working.</p>
</div>
<div class="paragraph">
<p>练习2.14实施数字猜测程序。如果提供命令行参数，请将其用作最大数字;否则使用100.当你的程序正常工作时，可能有助于立即输出密码。</p>
</div>
</div>
<div class="sect2">
<h3 id="_summary">1.14. Summary</h3>
<div class="paragraph">
<p>You made it! First chapters are typically the toughest because you’re getting your bearings. You’ve made at least one meaty program that incorporates several things that you haven’t seen in depth yet. You can take input from the command line or from a prompt. You can compare values and follow different code branches. Not bad for a first chapter.</p>
</div>
<div class="paragraph">
<p>你做到了！第一章通常是最难的，因为你得到了你的支持。你已经制作了至少一个丰富的程序，其中包含了一些你还没有深入见过的东西。你可以从命令行或提示中获取输入。你可以比较值并遵循不同的代码分支。对于第一章来说还不错。
== 数字</p>
</div>
<div class="paragraph">
<p>This chapter steps back from the breadth of the previous chapter to focus on the idea of numbers and their representation in your programs. Raku supports several types of numbers and works hard to keep them exact as long as it can.</p>
</div>
<div class="paragraph">
<p>本章从前一章的广度开始，重点介绍数字的概念及其在程序中的表示。 Raku 支持多种类型的数字，并且尽可能地努力保持它们的准确性。</p>
</div>
</div>
<div class="sect2">
<h3 id="_number_types">1.15. Number Types</h3>
<div class="paragraph">
<p>Not all numbers are created alike. You’ve seen whole numbers, how to do basic mathematical operations on them, and how to compare them. But whole numbers are just one of the numeric types. You can see what type a number is by calling <code>.^name</code> on it:</p>
</div>
<div class="paragraph">
<p>并非所有数字都是相同的。你已经看过整数，如何对它们进行基本的数学运算，以及如何比较它们。但整数只是数字类型之一。你可以通过调用 <code>.^name</code> 来查看数字的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 137.^name
Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s an [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>), short for “integer”—whole numbers, positive or negative, and zero. The compiler recognizes it because it has decimal digits; it parses it and creates the object for you. But try it with a negative number:</p>
</div>
<div class="paragraph">
<p>这是一个 [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html)，是“整数”的缩写" class="bare">https://docs.raku.org/type/Int.html)，是“整数”的缩写</a> - 整数，正数或负数，以及零。编译器识别它，因为它有十进制数字;它解析它并为你创建对象。但尝试使用负数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; -137.^name
Cannot convert string to number</code></pre>
</div>
</div>
<div class="paragraph">
<p>The minus sign isn’t actually part of the number. It’s an operator (a unary prefix one) that <strong>negates</strong> the positive number. That means that <code>-137</code> isn’t a term; it’s an expression. The <code>.^name</code> happens first and evaluates to <code>Int`as before. When `-</code> tries to negate the type name it realizes it can’t do that and complains. You can fix the ordering problem with parentheses—things inside parentheses happen before those outside:</p>
</div>
<div class="paragraph">
<p>减号实际上不是数字的一部分。它是一个运算符（一个一元前缀）否定正数。这意味着 <code>-137</code> 不是一个项;这是一个表达式。 <code>.^name</code> 首先发生，并计算为之前的 <code>Int</code>。当 <code>-</code> 试图否定类型名称时，它意识到它无法做到并抱怨。你可以使用括号修复顺序问题 - 括号内的事情发生在外部之前：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; (-137).^name</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are other types of numbers, some of which are shown in [Table 3-1](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch03.html#camelia-numbers-TABLE-examples" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch03.html#camelia-numbers-TABLE-examples</a>).</p>
</div>
<div class="paragraph">
<p>还有其他类型的数字，其中一些如表3-1所示。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Class</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>137</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">正整数 (whole number)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-17</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">负整数 (whole number)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>3.1415926</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[<code>Rat</code>](<a href="https://docs.raku.org/type/Rat.html" class="bare">https://docs.raku.org/type/Rat.html</a>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">分数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>6.026e34</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[<code>Num</code>](<a href="https://docs.raku.org/type/Num.html" class="bare">https://docs.raku.org/type/Num.html</a>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">科学计数法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0+i</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[<code>Complex</code>](<a href="https://docs.raku.org/type/Complex.html" class="bare">https://docs.raku.org/type/Complex.html</a>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">带有实部和虚部的复数</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>EXERCISE 3.1Call <code>.^name</code> on some of the other kinds of numbers from [Table 3-1](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch03.html#camelia-numbers-TABLE-examples" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch03.html#camelia-numbers-TABLE-examples</a>). What other sorts of numbers does Raku support? Which ones need parentheses to group them?</p>
</div>
<div class="paragraph">
<p>练习3.1Call。^表3-1中其他一些数字的名称。 Raku支持哪些其他类型的数字？哪些人需要括号将它们分组？</p>
</div>
</div>
<div class="sect2">
<h3 id="_integers">1.16. Integers</h3>
<div class="paragraph">
<p>The integers are the whole numbers. You’ve seen that they can be represented in many ways and in different bases:</p>
</div>
<div class="paragraph">
<p>整数是整数。你已经看到它们可以通过多种方式和不同的基础来表示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">137
-19
0x89
:7<i class="conum" data-value="254"></i><b>(254)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>Including underscores between digits can make larger numbers easier to read. They aren’t part of the number and can only come between digits (so, not two in a row). You could separate by thousands:</p>
</div>
<div class="paragraph">
<p>在数字之间加上下划线可以使更大的数字更容易阅读。它们不是数字的一部分，只能在数字之间（因此，不是连续两个）。你可以分成几千：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">123_456_789</code></pre>
</div>
</div>
<div class="paragraph">
<p>Two hexadecimal digits represent an <strong>octet</strong>; it’s easy to see those when you have underscores between pairs ofdigits:</p>
</div>
<div class="paragraph">
<p>两个十六进制数字代表一个八位字节;当你在数字对之间有下划线时很容易看到它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">0x89_AB_CD_EF</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_类型约束">1.16.1. 类型约束</h4>
<div class="paragraph">
<p>When you declare a variable without assigning to it there’s still “something” there. It’s a type object with the type [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html)—a" class="bare">https://docs.raku.org/type/Any.html)—a</a> generic type that’s the basis for most Raku objects:</p>
</div>
<div class="paragraph">
<p>当你声明一个变量但没有为其赋值时，变量里仍然存在“某些东西”。它是一个类型为[<code>Any</code>](<a href="https://docs.raku.org/type/Any.html)类型的类型对象，它是大多数" class="bare">https://docs.raku.org/type/Any.html)类型的类型对象，它是大多数</a> Raku 对象的基础：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $number;
put $number.^name;  # Any</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you coerce [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>) to a Boolean value you get <code>False</code>. Any type object is undefined, but this is slightly more undefined because it’s a general class.</p>
</div>
<div class="paragraph">
<p>When you want to assign to a container that holds a type object you have to replace it with a value of the same type or something based on that type. You can replace [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>) with almost any literal value:</p>
</div>
<div class="paragraph">
<p>如果你强转[<code>Any</code>](<a href="https://docs.raku.org/type/Any.html)为布尔值，你会得到" class="bare">https://docs.raku.org/type/Any.html)为布尔值，你会得到</a> <code>False</code>。任何类型对象都是未定义的，但这稍微未定义，因为它是一个通用类。</p>
</div>
<div class="paragraph">
<p>如果要给包含类型对象的容器赋值，则必须使用相同类型的值或基于该类型的值替换它。你可以使用几乎任何字面值替换[<code>Any</code>](<a href="https://docs.raku.org/type/Any.html)：" class="bare">https://docs.raku.org/type/Any.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $number;      # starts as Any
$number = 137;
$number = &#39;Hamadryas&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s the same as explicitly constraining the value to the [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>) type. Without an assignment the variable gets the type object of its constraint:</p>
</div>
<div class="paragraph">
<p>这与显式约束[<code>Any</code>](<a href="https://docs.raku.org/type/Any.html)类型的值相同。如果没有赋值，变量将获取其约束的类型对象：" class="bare">https://docs.raku.org/type/Any.html)类型的值相同。如果没有赋值，变量将获取其约束的类型对象：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Any $number;  # starts as Any
$number = 137;
$number = &#39;Hamadryas&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can be as specific as you like. If your variable should only store an integer you can use the [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>) type to constrain it even before you assign to it. Even without a value it knows its type:</p>
</div>
<div class="paragraph">
<p>你可以随心所欲。如果你的变量只应存储一个整数，则可以使用 [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>) 类型在赋值给它之前对其进行约束。即使没有值，它也知道它的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int $number;
put $number2.^name;  # Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>Whatever you assign to it must be an [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>) (or something derived from an [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html)" class="bare">https://docs.raku.org/type/Int.html)</a>):</p>
</div>
<div class="paragraph">
<p>无论你给它赋什么值，它必须是一个 [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html)（或从" class="bare">https://docs.raku.org/type/Int.html)（或从</a> [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>) 派生的东西）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int $number;
$number = 137;
$number = &#39;Hamadryas&#39;;  # NOPE! Error</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you try to assign something that is not the correct type you get an error:</p>
</div>
<div class="paragraph">
<p>当你尝试分配不正确类型的内容时，你会收到错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Type check failed in assignment to $n; expected Int but got Str</code></pre>
</div>
</div>
<div class="paragraph">
<p>This check happens when you assign to the variable. Raku calls this “gradual typing.” You don’t have to use it until you want it, but you still have to be careful to obey it when you do use it. The compiler can’t catch all type errors before you run the program.</p>
</div>
<div class="paragraph">
<p>You can use types in your <code>MAIN</code> signature too. These types apply to the command-line arguments. If you don’t supply appropriate values you’ll get an error right away:</p>
</div>
<div class="paragraph">
<p>给变量赋值时会发生此检查。 Raku 将此称为“渐进类型”。直到你需要它时才使用，但是在使用它时仍然需要小心遵守它。在运行程序之前，编译器无法捕获所有类型错误。</p>
</div>
<div class="paragraph">
<p>你也可以在 <code>MAIN</code> 签名中使用类型。这些类型应用于命令行参数。如果你没有提供合适的值，你将立即收到错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ( Int $n ) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 3.2Create a program that takes two arguments from the command line and outputs their types. Try it with numbers and text in each position. What types do you get?</p>
</div>
<div class="paragraph">
<p>When you ran your program for the previous exercise you saw the type name <code>IntStr</code>. This is an allomorph—a type that’s both an [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>) and a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) at the same time.</p>
</div>
<div class="paragraph">
<p>All of the command-line arguments are actually text, even though some of them look like numbers. There’s a hidden <code>val</code> routine that inspects the arguments and turns those that look like some sort of number into the appropriate allomorph. This type has the behavior of both numbers and strings at the same time. You might think that’s a little weird at first, but it’s one of the things that allows a language such as Raku to easily process text.</p>
</div>
<div class="paragraph">
<p>练习3.2 创建一个从命令行获取两个参数并输出其类型的程序。在每个位置尝试使用数字和文本。你得到什么类型？</p>
</div>
<div class="paragraph">
<p>当你为上一个练习运行程序时，你看到了类型名称 <code>IntStr</code>。这是一个同质异形的类型，它同时是 [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>) 和 [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)。" class="bare">https://docs.raku.org/type/Str.html)。</a></p>
</div>
<div class="paragraph">
<p>所有命令行参数实际上都是文本，即使它们中的一些看起来像数字。有一个隐藏的 <code>val</code> 例程，它检查参数并将那些看起来像某种数字的数字转换为适当的同质异形。此类型同时具有数字和字符串的行为。你可能认为一开始有点奇怪，但这是允许像 Raku 这样的语言轻松处理文本的事情之一。</p>
</div>
</div>
<div class="sect3">
<h4 id="_智能匹配">1.16.2. 智能匹配</h4>
<div class="paragraph">
<p>智能匹配运算符 <code>~~</code> 代表了许多种比较，并为其操作数选择了正确的比较。<code>~~</code> 的左侧是值或变量，<code>~~</code> 的右侧是类型，如果值是该类型或从该类型派生的，则返回 <code>True</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 1 ~~ Int
True
&gt; 1.^mro
((Int) (Cool) (Any) (Mu))
&gt; 1 ~~ Cool
True
&gt; 1 ~~ Any
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是有效的，因为字面量是隐式创建的对象并知道它们是什么。将其与任何其他类型进行比较，即使该值可能是该类型的合法值，也会返回 <code>False</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 1 ~~ Complex
False</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，你可以使用以所需类型命名的强转方法轻松地转换数字类型（如果类型提供了一个）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
To exit type &#39;exit&#39; or &#39;^D&#39;
&gt; 1.Complex
1+0i
&gt; 1.Complex ~~ Complex
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>Smart matching is easy with <code>given-when</code>. Two things happen with this feature. First, <code>given</code> binds $_ to the value of the variable you specify. The $_ is the topic; this allows you to write some code that uses <code>$_</code> to process the current thing you care about without knowing what that thing is.</p>
</div>
<div class="paragraph">
<p>Second, <code>when</code> looks at the condition you supply. If there’s no explicit comparator it smart matches <code>$_</code> against the value you gave it. The first <code>when</code> block that is satisfied is the one that wins. A <code>default</code> block (no condition!) catches it when no <code>when</code> does.</p>
</div>
<div class="paragraph">
<p>The conditions for these <code>when</code> s are type objects to smart match against $_:</p>
</div>
<div class="paragraph">
<p>有了 <code>given-when</code> 智能匹配就很容易了。这个功能发生了两件事。首先，<code>given</code> 将 $_ 绑定到你指定的变量的值上。 $_ 是主题;这允许你编写一些使用 <code>$_</code> 的代码来处理你正关心的当前事物，而不需知道那是什么东西。</p>
</div>
<div class="paragraph">
<p>其次，<code>when</code> 查找你提供的条件。如果没有显式的比较器，它将 <code>$_</code> 与你给出的值进行智能匹配。第一个满足的 <code>when</code> 块是获胜的块。没有时，<code>default</code> 块（无条件！）会捕获它。</p>
</div>
<div class="paragraph">
<p>这些 <code>when</code> 的条件是与 <code>$_</code> 智能匹配的类型对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given $some-number {
    when Int     { put &#39;Saw an integer&#39; }
    when Complex { put &#39;Saw a complex number&#39; }
    when Rat     { put &#39;Eek! Saw a rat!&#39; }
    default      { put &#39;Saw something&#39; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Making everything explicit, you’d get something like this mess of repeated typing:</p>
</div>
<div class="paragraph">
<p>要让一切都清楚，你会得到类似这种重复输入的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given $some-number -&gt; $_ {
    when $_ ~~ Int     { put &#39;Saw an integer&#39; }
    when $_ ~~ Complex { put &#39;Saw a complex number&#39; }
    when $_ ~~ Rat     { put &#39;Eek! Saw a rat!&#39; }
    default            { put &#39;Saw something&#39; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can make this shorter using <code>do</code> in the same way you did with <code>if</code>. The last evaluated expression becomes the value of the entire <code>given</code> structure:</p>
</div>
<div class="paragraph">
<p>使用 <code>do</code> 可以使用与 <code>if</code> 相同的方式缩短代码。最后计算的表达式成为整个 <code>given</code> 结构的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Saw &#39;, do given $some-number {
    when Int     { &#39;an integer&#39; }
    when Complex { &#39;a complex number&#39; }
    when Rat     { &#39;a rat! Eek!&#39; }
    default      { &#39;something&#39; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 3.3Using <code>given</code>, create a program that reports the type of number you specify on the command line. Try it with arguments such as <code>17</code>, <code>17.0</code>, <code>17i</code>, and <code>Hamadryas</code>.</p>
</div>
<div class="paragraph">
<p>There’s another interesting thing you can do with $_. A method call dot with no object to the left uses <code>$_</code> as the object:</p>
</div>
<div class="paragraph">
<p>练习3.3 使用 <code>given</code>，创建一个程序，报告你在命令行上指定的数字类型。尝试使用诸如 <code>17</code>, <code>17</code>. <code>0,17i</code> 和 <code>Hamadryas</code> 之类的参数。</p>
</div>
<div class="paragraph">
<p>你可以用 $_ 做另一个有趣的事情。左边没有对象的方法调用点使用 $_ 作为对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_.put;
.put;

put $_.roots unless $_.is-prime;
put .roots unless .is-prime;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use a postfix <code>given</code> to set <code>$_</code> for a single statement to avoid typing out a variable multiple times. You’ll see the implicit topic much more as you go through the book:</p>
</div>
<div class="paragraph">
<p>你可以使用后缀 <code>given</code> 为单个语句设置 <code>$_</code>，以避免多次输入同一变量。在阅读本书时，你会多次看到隐式的主题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $some-number = 19;
put .^name, &#39; &#39;, .is-prime given $some-number;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_有理数">1.17. 有理数</h3>
<div class="paragraph">
<p>Raku represents nonwhole numbers as fractions using integers. You might literally represent it as a number with a decimal point (sometimes called a <strong>floating-point number</strong>), but the compiler turns that into a fraction. You can see the numerator and denominator for that reduced fraction:</p>
</div>
<div class="paragraph">
<p>Raku 使用整数表示非全数字作为分数。你可能会将其表示为带小数点的数字（有时称为浮点数），但编译器将其转换为分数。你可以看到化简后的分数的分子和分母：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 3.1415926
3.1415926
&gt; 3.1415926.^name
Rat
&gt; 3.1415926.numerator
15707963
&gt; 3.1415926.denominator
5000000</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 3.4 Create a program that takes a single decimal number command-line argument and shows it to you as a fraction. What are the numerator and denominator?</p>
</div>
<div class="paragraph">
<p>You can add rational numbers to get another fraction; Raku does the work for you:</p>
</div>
<div class="paragraph">
<p>练习3.4 创建一个接受单个十进制数字命令行参数的程序，并将其作为分数显示给你。分子和分母是什么？</p>
</div>
<div class="paragraph">
<p>你可以添加有理数来得到另一个分数; Raku 为你完成工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 1/7 + 1/3
0.476190</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.perl</code> method shows you how Raku thinks about it. You can see the fraction with the least common multiple in the denominator:</p>
</div>
<div class="paragraph">
<p><code>.perl</code> 方法向你展示 Raku 如何思考它。你可以看到这个分数的分母中有最小公倍数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; (1/7 + 1/3).perl
&lt;10/21&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It didn’t divide the numbers then try to store the result as a floating-point number; that would lose accuracy. It keeps it as an exact fraction as long as it can. This means that these sums are exactly right.</p>
</div>
<div class="paragraph">
<p>Try this in your favorite programming language:</p>
</div>
<div class="paragraph">
<p>它没有除以数字，然后尝试将结果存储为浮点数;那会失去准确性。只要它可以，它就将它保持为精确的分数。这意味着这些总和是完全正确的。</p>
</div>
<div class="paragraph">
<p>用你最喜欢的编程语言试试这个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 0.1 + 0.2
0.3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way to define a [<code>Rat</code>](<a href="https://docs.raku.org/type/Rat.html" class="bare">https://docs.raku.org/type/Rat.html</a>) is to write it as a literal fraction inside angle brackets, <code>&lt;&gt;</code>:</p>
</div>
<div class="paragraph">
<p>定义 [<code>Rat</code>](<a href="https://docs.raku.org/type/Rat.html" class="bare">https://docs.raku.org/type/Rat.html</a>) 的另一种方法是将其写为尖括号内的字面量分数，<code>&lt;&gt;</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &lt;10/21&gt;
0.476190
&gt; &lt;10/21&gt;.^name
Rat
&gt; &lt;10/21&gt;.perl
&lt;10/21&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It’s the same in a program:</p>
</div>
<div class="paragraph">
<p>它在程序中是相同的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $seventh = &lt;1/7&gt;;
my $third   = &lt;1/3&gt;;

my $added = $seventh + $third;

put $added.perl;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can’t do this with a variable inside the angle brackets. You’ll see what’s going on in the next chapter, but inside the <code>&lt;&gt;</code> that’s not really a variable. The <code>$</code> is a literal character:</p>
</div>
<div class="paragraph">
<p>你无法使用尖括号内的变量执行此操作。你将在下一章中看到会发生什么事情，但在 <code>&lt;&gt;</code> 里面它并不是真正的变量。在 <code>&lt;&gt;</code> 里面 <code>$</code> 是一个字面量字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &lt;1/$n&gt;
1/$n</code></pre>
</div>
</div>
<div class="paragraph">
<p>At some point the fractions will be too large and you’ll get an error. Here’s a program that adds the reciprocals of the powers of two. It uses <code>loop</code> and uses <code>++</code> to make higher powers of two:</p>
</div>
<div class="paragraph">
<p>在某些时候，分数将太大，你会得到一个错误。这是一个程序，它将 2 的幂的倒数相加。它使用 <code>loop</code> 并使用 <code>++</code> 来获得 2 的更高的幂：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n   = 0;
my $sum = 0;
loop {
    $sum += 1 / 2**$n++;
    put .numerator, &#39;/&#39;, .denominator, &#39; = &#39; given $sum;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You get progressively larger fractions even though this series converges on <code>2</code>. Eventually it fails because the denominator is limited to a 64-bit integer size:</p>
</div>
<div class="paragraph">
<p>即使该系列收敛于 <code>2</code>，你也会逐渐获得更大的分数。最终它会失败，因为分母限制为 64 位整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku converging.p6
1/1 = 1
3/2 = 1.5
7/4 = 1.75
15/8 = 1.875
31/16 = 1.9375
63/32 = 1.96875
...
4611686018427387903/2305843009213693952 = 2
9223372036854775807/4611686018427387904 = 2
18446744073709551615/9223372036854775808 = 2
No such method &#39;numerator&#39; for invocant of type &#39;Num&#39;.</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s another class that can handle this. A [<code>FatRat</code>](<a href="https://docs.raku.org/type/FatRat.html" class="bare">https://docs.raku.org/type/FatRat.html</a>) is a fraction with an arbitrarily large denominator. This is the first time you get to construct an object directly. Call the <code>.new</code> method with the numerator and denominator:</p>
</div>
<div class="paragraph">
<p>还有另一个类可以处理这个问题。 [<code>FatRat</code>](<a href="https://docs.raku.org/type/FatRat.html" class="bare">https://docs.raku.org/type/FatRat.html</a>) 是具有任意大分母的分数。这是你第一次直接构造对象。使用分子和分母调用 <code>.new</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum = FatRat.new: 0, 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you have an existing [<code>Rat</code>](<a href="https://docs.raku.org/type/Rat.html" class="bare">https://docs.raku.org/type/Rat.html</a>) you can turn it into a [<code>FatRat</code>](<a href="https://docs.raku.org/type/FatRat.html" class="bare">https://docs.raku.org/type/FatRat.html</a>) with a method. You’d do that when you know you are going to need it later when you do math with another [<code>FatRat</code>](<a href="https://docs.raku.org/type/FatRat.html" class="bare">https://docs.raku.org/type/FatRat.html</a>):</p>
</div>
<div class="paragraph">
<p>如果你有一个现有的 [<code>Rat</code>](<a href="https://docs.raku.org/type/Rat.html)，可以使用方法将其转换为" class="bare">https://docs.raku.org/type/Rat.html)，可以使用方法将其转换为</a> [<code>FatRat</code>](<a href="https://docs.raku.org/type/FatRat.html)。当你用另一个"><code>FatRat</code></a>(<a href="https://docs.raku.org/type/FatRat.html" class="bare">https://docs.raku.org/type/FatRat.html</a>) 做数学时，如果你知道以后需要它，你会这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fatrat = &lt;10/21&gt;.FatRat;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you need to add a [<code>FatRat</code>](<a href="https://docs.raku.org/type/FatRat.html" class="bare">https://docs.raku.org/type/FatRat.html</a>) to the existing one, you can construct that one in the same way:</p>
</div>
<div class="paragraph">
<p>当你需要将 [<code>FatRat</code>](<a href="https://docs.raku.org/type/FatRat.html" class="bare">https://docs.raku.org/type/FatRat.html</a>) 添加到现有的 [<code>FatRat</code>](<a href="https://docs.raku.org/type/FatRat.html" class="bare">https://docs.raku.org/type/FatRat.html</a>) 时，你可以以相同的方式构造它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">FatRat.new: 1, 2**$n++</code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise the program is the same, although this version will run much longer. Notice that all the fractions need to be [<code>FatRat</code>](<a href="https://docs.raku.org/type/FatRat.html)s" class="bare">https://docs.raku.org/type/FatRat.html)s</a> to keep it going:</p>
</div>
<div class="paragraph">
<p>否则程序是相同的，虽然这个版本将运行更长时间。请注意，所有分数都需要 [<code>FatRat</code>](<a href="https://docs.raku.org/type/FatRat.html" class="bare">https://docs.raku.org/type/FatRat.html</a>) 才能保持运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n   = 0;
my $sum = FatRat.new: 0, 1;
loop {
    $sum += FatRat.new: 1, 2**$n++;
    put $sum.^name;
    put .numerator, &#39;/&#39;, .denominator, &#39; = &#39;, $_ given $sum;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 3.5Create a program that sums the series of fractions 1, 1/2, 1/3, and so on. This is the harmonic series. Calculate the partial sum up to a denominator of 100. Output the value at each stage of the sum.</p>
</div>
<div class="paragraph">
<p>练习3.5 创建一个程序，对一系列分数 1,1/2,1/3 等求和。这是谐波系列。计算分母总和为 100 的分母。在总和的每个阶段输出值。</p>
</div>
</div>
<div class="sect2">
<h3 id="_imaginary_and_complex_numbers">1.18. Imaginary and Complex Numbers</h3>
<div class="paragraph">
<p>Imaginary numbers are multiples of the square root of –1. Impossible, you say? I’m not going to explain that in this book but Raku has them. If you’re an electrical engineer you’ve likely run into complex numbers when modeling certain properties.</p>
</div>
<div class="paragraph">
<p>Raku has a term for the imaginary unit; it’s <code>i</code>. The number <code>5i</code> is imaginary; it’s five times the imaginary unit. Try it in the REPL:</p>
</div>
<div class="paragraph">
<p>虚数是 -1 的平方根的倍数。你说不可能吗？我不打算在本书中解释，但 Raku有它们。如果你是电气工程师，在对某些属性进行建模时可能会遇到复数。</p>
</div>
<div class="paragraph">
<p>Raku 有一个虚数单位的术语;它是 <code>i</code>。数字 <code>5i</code> 是虚拟的;它是虚部单位的五倍。在 REPL 中尝试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 5i
0+5i
&gt; 5*i
0+5i
&gt; 5\i
0+5i
&gt; 5\ i
0+5i</code></pre>
</div>
</div>
<div class="paragraph">
<p>That was four ways to write the same thing. The first way puts two terms, <code>5</code> and <code>i</code>, next to each other with no whitespace or separator. That works and is likely to be the way you’ll type it most of the time. The second multiplies <code>5</code> and <code>i</code> to get the same result. The last two use <code>\</code> to create unspace. One has no space and the other has some space.</p>
</div>
<div class="paragraph">
<p>You can’t have only whitespace between the digits and the <code>i</code>, or the compiler will think that you have terms in a row (because you do):</p>
</div>
<div class="paragraph">
<p>这是写同样事情的四种方式。第一种方法是将两个项 <code>5</code> 和 <code>i</code> 放在一起，没有空格或分隔符。这很有效，很可能是你大部分时间打字的方式。第二个乘以 <code>5</code> 和 <code>i</code> 得到相同的结果。最后两个使用 <code>\</code> 来创建 unspace。一个没有空格，另一个有空格。</p>
</div>
<div class="paragraph">
<p>你不能只有数字和 <code>i</code> 之间的空格，否则编译器会认为你有连续的项（因为你这样做）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 5 i
===SORRY!=== Error while compiling:
Two terms in a row
------&gt; 5⏏ i</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you tried the imaginary number <code>5i</code> in the REPL you got back <code>0 + 5i</code>. That’s a real number added to an imaginary number. Taken together they form a complex number that has real and imaginary parts.</p>
</div>
<div class="paragraph">
<p>To get the real or imaginary parts of the number you can use the <code>.re</code> or <code>.im</code> methods, which take their short names from the common math notation:</p>
</div>
<div class="paragraph">
<p>当你在 REPL 中尝试了虚数 <code>5i</code> 时，你得到了 <code>0 + 5i</code>。这是实数和虚数相加。总之，它们一块儿形成了一个具有实部和虚部的复数。</p>
</div>
<div class="paragraph">
<p>要获取数字的实部或虚数部分，可以使用 <code>.re</code> 或 <code>.im</code> 方法，这些方法的常用数学符号采用短名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; my $z = 137+9i;
137+9i
&gt; $z.^name
Complex
&gt; $z.re
137
&gt; $z.im
9</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can add, subtract, and multiply [<code>Complex</code>](<a href="https://docs.raku.org/type/Complex.html" class="bare">https://docs.raku.org/type/Complex.html</a>) numbers. Multiplication involves cross terms with the real part of one number multiplied by the imaginary part of the other:</p>
</div>
<div class="paragraph">
<p>你可以相加，减去和乘以[<code>复数</code>](<a href="https://docs.raku.org/type/Complex.html)。乘法涉及交叉项，其中一个数字的实部乘以另一个数的虚部：" class="bare">https://docs.raku.org/type/Complex.html)。乘法涉及交叉项，其中一个数字的实部乘以另一个数的虚部：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; (5+9i) * (6+3i)
3+69i
&gt; (5+9i) + (6+3i)
11+12i
&gt; (5+9i) - (6+3i)
-1+6i
&gt; (5+9i) / (6+3i)
1.26666666666667+0.866666666666667i</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can even multiply <code>i</code> by itself:</p>
</div>
<div class="paragraph">
<p>你甚至可以让 <code>i</code> 和自身相乘：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; i*i
-1</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_numbers_small_and_large">1.19. Numbers Small and Large</h3>
<div class="paragraph">
<p>Everything that doesn’t fit into the specific numeric types is in the general [<code>Num</code>](<a href="https://docs.raku.org/type/Num.html" class="bare">https://docs.raku.org/type/Num.html</a>) type. The number <code>e</code> (the natural base) is one of those numbers:</p>
</div>
<div class="paragraph">
<p>所有不符合特定数字类型的东西都是通用的 [<code>Num</code>](<a href="https://docs.raku.org/type/Num.html" class="bare">https://docs.raku.org/type/Num.html</a>) 类型。数字 <code>e</code>（自然基数）就是这些数字之一：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; e.^name
Num
&gt; e
2.71828182845905</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use infinities. Putting all the nuances and uses aside, for this book <code>Inf</code> is just something that’s larger than any integer. You’ll see it in use later:</p>
</div>
<div class="paragraph">
<p>你也可以使用无穷大。把所有的细微差别和用法放在一边，对于这本书，<code>Inf</code> 只是比任何整数都大的东西。你会在后面看到它在使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; Inf.^name
Num
&gt; (-Inf).^name
Num</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can write numbers in exponential notation. You can specify a power of 10 after an <strong>e</strong> of either case. This is a different sort of <strong>e</strong> than the term you just saw:</p>
</div>
<div class="paragraph">
<p>你可以用指数表示法编写数字。在任一情况下，你都可以在 <strong>e</strong> 后面指定 10 的幂。这与你刚刚看到的术语不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">6.02214e23
6.02214E23</code></pre>
</div>
</div>
<div class="paragraph">
<p>These are the same as multiplying the number by a power of 10 that you construct explicitly:</p>
</div>
<div class="paragraph">
<p>这些与将数字乘以你显式地构造的 10 的幂相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">6.02214 * 10**23</code></pre>
</div>
</div>
<div class="paragraph">
<p>These numbers aren’t [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html)s" class="bare">https://docs.raku.org/type/Int.html)s</a> or [<code>Rat</code>](<a href="https://docs.raku.org/type/Rat.html)s" class="bare">https://docs.raku.org/type/Rat.html)s</a>, although you might be able to convert them. They are the more general [<code>Num</code>](<a href="https://docs.raku.org/type/Num.html" class="bare">https://docs.raku.org/type/Num.html</a>) type:</p>
</div>
<div class="paragraph">
<p>这些数字不是[<code>整数</code>](<a href="https://docs.raku.org/type/Int.html)或"><code>有理数</code></a>(<a href="https://docs.raku.org/type/Rat.html)，尽管你可能可以转换它们。它们是更通用的"><code>Num</code></a>(<a href="https://docs.raku.org/type/Num.html)类型：" class="bare">https://docs.raku.org/type/Num.html)类型：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put 1e3.^name;  # 1000, but still a Num
put 1e3.Int;    # 1000, but now an Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>Very small numbers have a negative power of 10:</p>
</div>
<div class="paragraph">
<p>非常小的数字具有10的负数幂：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">6.626176e-34</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use this on not-so-small numbers too:</p>
</div>
<div class="paragraph">
<p>你也可以在不那么小的数字上使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">7.297351e-3</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 3.6What is 7.297351e-3 as a fraction? What’s its reciprocal?</p>
</div>
<div class="paragraph">
<p>练习3.6 7.297351e-3 作为分数是什么？它的倒数是什么？</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_numeric_hierarchy">1.20. The Numeric Hierarchy</h3>
<div class="paragraph">
<p>Raku thinks about numbers relative to their “width.” [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>) comprises the positive and negative whole numbers and is relatively narrow. The [<code>Rat</code>](<a href="https://docs.raku.org/type/Rat.html" class="bare">https://docs.raku.org/type/Rat.html</a>) type includes the whole numbers and some of the numbers between them (the ones that can be fractions).</p>
</div>
<div class="paragraph">
<p>[<code>Rat</code>](<a href="https://docs.raku.org/type/Rat.html" class="bare">https://docs.raku.org/type/Rat.html</a>) is “wider” not because its endpoints are greater but because there are more numbers between the same endpoints. [<code>FatRat</code>](<a href="https://docs.raku.org/type/FatRat.html" class="bare">https://docs.raku.org/type/FatRat.html</a>) is even wider because it pushes the endpoints farther apart to contain even more numbers.</p>
</div>
<div class="paragraph">
<p>Even wider than the rationals, fat or otherwise, are plain ol’ [<code>Num</code>](<a href="https://docs.raku.org/type/Num.html)s" class="bare">https://docs.raku.org/type/Num.html)s</a>. Those include the rest of the numbers; the ones that you can’t represent as fractions. We typically call this wider set the <code>Real`s but Raku calls them [`Num</code>](<a href="https://docs.raku.org/type/Num.html)s" class="bare">https://docs.raku.org/type/Num.html)s</a>.</p>
</div>
<div class="paragraph">
<p>And when you think that you are the widest that you can go, the numbers go sideways into the plane of the [<code>Complex</code>](<a href="https://docs.raku.org/type/Complex.html" class="bare">https://docs.raku.org/type/Complex.html</a>) numbers.</p>
</div>
<div class="paragraph">
<p>Sometimes you may want to go narrower or wider. Many Raku objects have coercer methods that can do that for you. Start with an [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>) and turn it into a [<code>Complex</code>](<a href="https://docs.raku.org/type/Complex.html" class="bare">https://docs.raku.org/type/Complex.html</a>) number. This goes wider:</p>
</div>
<div class="paragraph">
<p>Raku 考虑数字相对于它们的“宽度”. [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>) 包含正整数和负数，并且相对较窄。 [<code>Rat</code>](<a href="https://docs.raku.org/type/Rat.html" class="bare">https://docs.raku.org/type/Rat.html</a>) 类型包括整数和它们之间的一些数字（可以是分数的数字）。</p>
</div>
<div class="paragraph">
<p>[<code>Rat</code>](<a href="https://docs.raku.org/type/Rat.html" class="bare">https://docs.raku.org/type/Rat.html</a>) “更宽”并不是因为它的端点更大，而是因为相同端点之间的数字更多。 [<code>FatRat</code>](<a href="https://docs.raku.org/type/FatRat.html" class="bare">https://docs.raku.org/type/FatRat.html</a>) 更宽，因为它将端点推得更远，以包含更多数字。</p>
</div>
<div class="paragraph">
<p>比有理数，fat 或其他的数字更宽的是纯粹的 [<code>Num</code>](<a href="https://docs.raku.org/type/Num.html)。其中包括其他数字;那些你不能表示为分数的。我们通常称这个更广泛的集合为" class="bare">https://docs.raku.org/type/Num.html)。其中包括其他数字;那些你不能表示为分数的。我们通常称这个更广泛的集合为</a> [<code>Complex</code>](<a href="https://docs.raku.org/type/Complex.html)，但" class="bare">https://docs.raku.org/type/Complex.html)，但</a> Raku 称它们为 [<code>Num</code>](<a href="https://docs.raku.org/type/Num.html" class="bare">https://docs.raku.org/type/Num.html</a>) 。</p>
</div>
<div class="paragraph">
<p>当你认为自己是最宽泛的时候，数字就会横向进入[<code>复数</code>](<a href="https://docs.raku.org/type/Complex.html)的平面。" class="bare">https://docs.raku.org/type/Complex.html)的平面。</a></p>
</div>
<div class="paragraph">
<p>有时你可能想要更窄或更宽。许多 Raku 对象都有强转方法，可以为你做到这一点。从 [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>) 开始并将其转换为[<code>复数</code>](<a href="https://docs.raku.org/type/Complex.html)。这更广泛：" class="bare">https://docs.raku.org/type/Complex.html)。这更广泛：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 6.Complex
6+0i</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or start with a [<code>Complex</code>](<a href="https://docs.raku.org/type/Complex.html" class="bare">https://docs.raku.org/type/Complex.html</a>) number and go narrower. This one can also be an [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>):</p>
</div>
<div class="paragraph">
<p>或者从[<code>复数</code>](<a href="https://docs.raku.org/type/Complex.html)开始，然后变窄。这个也可以是" class="bare">https://docs.raku.org/type/Complex.html)开始，然后变窄。这个也可以是</a> [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html)：" class="bare">https://docs.raku.org/type/Int.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; (6+0i).Int
6</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can do those coercions because you know something about the numbers. If you want the narrowest type without knowing what it is beforehand, you can use <code>.narrow</code>. If you tried to convert π to an [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>) you wouldn’t get an error, but you wouldn’t get π. If you use <code>.narrow</code> you get a [<code>Num</code>](<a href="https://docs.raku.org/type/Num.html" class="bare">https://docs.raku.org/type/Num.html</a>), the narrowest you can go:</p>
</div>
<div class="paragraph">
<p>你可以做那些强转，因为你对数字有所了解。如果你想要最窄的类型而不知道它是什么，你可以使用 <code>.narrow</code>。如果你尝试将 <strong>π</strong> 转换为 [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html)，则不会出现错误，但你不会得到" class="bare">https://docs.raku.org/type/Int.html)，则不会出现错误，但你不会得到</a> <strong>π</strong>。如果你使用 <code>.narrow</code> 你得到一个 [<code>Num</code>](<a href="https://docs.raku.org/type/Num.html)，你可以去的最窄的：" class="bare">https://docs.raku.org/type/Num.html)，你可以去的最窄的：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; (π+0i).Int
3
&gt; (π+0i).Int == π
False
&gt; (π+0i).narrow.^name
Num
&gt; (π+0i).narrow == π
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>有时你不能变得更窄：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; (6+3i).narrow.^name
Complex</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 3.7Modify the number-guessing program from the previous chapter so you have to guess a complex number. You have to decide high and low in two directions this time.</p>
</div>
<div class="paragraph">
<p>练习3.7 修改前一章中的数字猜测程序，这样你就必须猜出一个复数。这次你必须决定两个方向的高低。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_2">1.21. 总结</h3>
<div class="paragraph">
<p>That’s most of the story with numbers. You saw some of the methods you can use, and you’ll find even more in the documentation for each type. You also saw a bit about constraining variables to only the type you want, and you’ll become more sophisticated with that.</p>
</div>
<div class="paragraph">
<p>这是数字的大部分故事。你看到了一些可以使用的方法，你可以在每种类型的文档中找到更多。你还看到了一些关于将变量限制为你想要的类型的信息，并且你将变得更加复杂。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_字符串">2. 字符串</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Strings represent the text data in your program as [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) objects. Raku’s facility with text data and its manipulation is one of its major attractions. This chapter focuses on the many ways that you can create [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a>; for any job you have there’s likely a feature that makes that easy for you. Along with that you’ll see a bit about inspecting, extracting, and comparing text in preparation for loftier goals coming up.</p>
</div>
<div class="paragraph">
<p>字符串将程序中的文本数据表示为[<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)对象。" class="bare">https://docs.raku.org/type/Str.html)对象。</a> Raku 的文本数据和它的文本操作天赋是其主要吸引力之一。本章重点介绍可以创建[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)的多种方法;对于你的任何工作，可能有一个功能，使你的工作变得容易。除此之外，你还会看到有关检查，提取和比较文本的内容，以便为即将出现的更高目标做准备。" class="bare">https://docs.raku.org/type/Str.html)的多种方法;对于你的任何工作，可能有一个功能，使你的工作变得容易。除此之外，你还会看到有关检查，提取和比较文本的内容，以便为即将出现的更高目标做准备。</a></p>
</div>
<div class="sect2">
<h3 id="_literal_quoting">2.1. Literal Quoting</h3>
<div class="paragraph">
<p>You can type literal text directly into your program. What you type is what the text is, and the compiler does not interpret it as anything other than exactly what you typed. You can surround literal text with half-width corner brackets, <code>｢</code> and <code>｣</code>:</p>
</div>
<div class="paragraph">
<p>你可以直接在程序中键入字面文本。你键入的内容是文本的内容，编译器会将其解释为你输入的内容。你可以使用半角括号`｢` 和 `｣`来包围字面文本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢Literal string｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is your first encounter with a paired delimiter. These characters mark the beginning and end of the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>). There’s an opening character and a closing character that surround your text.</p>
</div>
<div class="paragraph">
<p>Any character that you use is interpreted as exactly what it is, with no special processing:</p>
</div>
<div class="paragraph">
<p>这是你第一次遇到配对分隔符。这些字符标记[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)的开头和结尾。文本周围有一个开口字符和一个闭合字符。" class="bare">https://docs.raku.org/type/Str.html)的开头和结尾。文本周围有一个开口字符和一个闭合字符。</a></p>
</div>
<div class="paragraph">
<p>你使用的任何字符都被解释为它的确切含义，没有特殊处理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢Literal &#39;&#34; string with \ and {} and /｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can’t use only one of the delimiter characters in the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>). These won’t work:</p>
</div>
<div class="paragraph">
<p>你不能只使用[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)中的一个分隔符。这些不起作用：" class="bare">https://docs.raku.org/type/Str.html)中的一个分隔符。这些不起作用：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢ Unpaired ｢ Delimiters ｣
｢ Unpaired ｣ Delimiters ｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, if you pair delimiters in the text the compiler will figure out if they are balanced—the opening delimiter comes first and a closing delimiter pairs with it:</p>
</div>
<div class="paragraph">
<p>但是，如果在文本中对分隔符进行配对，编译器将确定它们是否是平衡的 - 开口分隔符首先出现，并且闭合分隔符与它配对：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢ Del｢i｣miters ｣</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The Raku language is a collection of sublanguages, or slangs. Once inside a particular slang the compiler parses your source code by that slang’s rules. The quoting language is one of those slangs.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>If your literal text has corner brackets in it you can use a generalized quoting mechanism. These start with a <code>Q</code>(or <code>q</code>) and can get as limiting or as permissive as you like, as you’ll see in this chapter.</p>
</div>
<div class="paragraph">
<p>After the <code>Q</code> you can select almost any character to be the delimiter. It can’t be a character valid in a variable name, because that would make it look like a name instead of a delimiter. The paired characters are common; the opening character has to be on the left and its closing partner has to be on the right. Perhaps you want to use square brackets instead of corner brackets. Now the <code>｣</code> isn’t special because it’s not a delimiter:</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Raku 语言是一个子语言或方言的集合。一旦进入特定的方言，编译器就会根据该方言的规则解析你的源代码。引用语言是其中一个方言。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果你的字面文本中包含角括号，则可以使用通用引用机制。这些以 <code>Q</code>（或 <code>q</code> ）开头，可以像你想的那样得到限制或许可，正如你将在本章中看到的那样。</p>
</div>
<div class="paragraph">
<p>在 <code>Q</code> 之后，你可以选择几乎任何字符作为分隔符。它不能是变量名中有效的字符，因为这会使它看起来像名称而不是分隔符。配对字符很常见;开口字符必须位于左侧，其闭合字符必须位于右侧。也许你想使用方括号而不是角括号。现在，这并不特别，因为它不是分隔符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Q[Unpaired ｣ Delimiters]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most of the paired characters act the same:</p>
</div>
<div class="paragraph">
<p>大多数配对字符的行为相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Q{Unpaired ｣ Delimiters}
Q&lt;Unpaired ｣ Delimiters&gt;
Q&lt;&lt;Unpaired ｣ Delimiters&gt;&gt;
Q«Works»</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s one exception. You can’t have an open parenthesis right after the <code>Q</code> because that makes it look like a subroutine call (but it’s not):</p>
</div>
<div class="paragraph">
<p>有一个例外。在 <code>Q</code> 之后你不能有开口圆括号，因为这使它看起来像一个子程序调用（但它不是）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Q(Does not compile)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You don’t have to use paired characters. You can use the same character for the opening and closing delimiter:</p>
</div>
<div class="paragraph">
<p>你不必使用配对字符。你可以对开口和闭合分隔符使用相同的字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Q/hello/</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can store a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) in a variable or output it immediately:</p>
</div>
<div class="paragraph">
<p>你可以将[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)存储在变量中或立即输出：" class="bare">https://docs.raku.org/type/Str.html)存储在变量中或立即输出：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $greeting = Q/Hello World!/;
put Q/Hello World!/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>And you can call methods on your [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) just like you could do with numbers:</p>
</div>
<div class="paragraph">
<p>你可以在你的[[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>)](<a href="https://docs.raku.org/type/Str.html)上调用方法，就像你对数字一样：" class="bare">https://docs.raku.org/type/Str.html)上调用方法，就像你对数字一样：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Q/Hello World!/.^name;  # Str
Q/Hello World!/.put;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_escaped_strings">2.2. Escaped Strings</h3>
<div class="paragraph">
<p>One step up from literal [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> are escaped strings. The single tick acts as the delimiter for these [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a>. These are often called single-quoted strings:</p>
</div>
<div class="paragraph">
<p>从字面[[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>)](<a href="https://docs.raku.org/type/Str.html)向上一步是转义字符串。单个记号作为这些"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)的分隔符。这些通常称为单引号字符串：" class="bare">https://docs.raku.org/type/Str.html)的分隔符。这些通常称为单引号字符串：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#39;Hamadryas perlicus&#39;
Hamadryas perlicus</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to have the single tick as a character in the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) you can escape it with a backslash. That tells the quoting slang that the next character isn’t the delimiter but belongs as literal text:</p>
</div>
<div class="paragraph">
<p>如果你想让单个记号作为[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)中的一个字符，你可以用反斜杠来转义它。这告诉引用方言的下一个字符不是分隔符但属于字面文本：" class="bare">https://docs.raku.org/type/Str.html)中的一个字符，你可以用反斜杠来转义它。这告诉引用方言的下一个字符不是分隔符但属于字面文本：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#39;The escaped \&#39; stays in the string&#39;
The escaped &#39; stays in the string</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the <code>\</code> is the escape character, you can escape it to get a literal backslash:</p>
</div>
<div class="paragraph">
<p>由于 <code>\</code> 是转义字符，你可以转义它以获得字面反斜杠：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#39;Escape the \\ backslash&#39;
Escape the \ backslash</code></pre>
</div>
</div>
<div class="paragraph">
<p>A DOS path can be quite annoying to type, but escaped and literal [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> take care of that:</p>
</div>
<div class="paragraph">
<p>DOS 路径可能非常烦人，但是转义和字面[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)负责：" class="bare">https://docs.raku.org/type/Str.html)负责：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#39;C:\\Documents and Settings\\Annoying\\Path&#39;
C:\Documents and Settings\Annoying\Path
&gt; Q/C:\Documents and Settings\Annoying\Path/
C:\Documents and Settings\Annoying\Path</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to use a different delimiter for an escaped string you use the lowercase <code>q</code> followed by the delimiter that you want (following the same rules as for the literal quoting delimiters):</p>
</div>
<div class="paragraph">
<p>如果要对转义字符串使用不同的分隔符，请使用小写 <code>q</code> 后跟所需的分隔符（遵循与字面引用分隔符相同的规则）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">q{Unpaired &#39; Delimiters}
q&lt;Unpaired &#39; Delimiters&gt;
q&lt;&lt;Unpaired &#39; Delimiters&gt;&gt;
q«Works»</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_adverbs_for_quoting">2.2.1. Adverbs for Quoting</h4>
<div class="paragraph">
<p>Adverbs modify how something works and are a big part of Raku. You’ll see more of these in [Chapter 9](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch09.html#camelia-hashes" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch09.html#camelia-hashes</a>), but you’ll get a taste for them in this chapter. Adverbs start with a colon followed by letters or numbers.</p>
</div>
<div class="paragraph">
<p>All of the quoting methods you’ll see in this chapter are modifications of basic literal quoting. You use adverbs to adjust the quoting behavior.</p>
</div>
<div class="paragraph">
<p>The <code>:q</code> adverb modifies <code>Q</code> to become an escaping quote. There must be some whitespace after the adverb, but it’s optional after the <code>Q</code>:</p>
</div>
<div class="paragraph">
<p>副词会修改某些东西的工作方式，并且是 Raku 的重要组成部分。你将在第9章中看到更多这些内容，但在本章中你将会对它们有所了解。副词以冒号开头，后跟字母或数字。</p>
</div>
<div class="paragraph">
<p>你将在本章中看到的所有引用方法都是对基本字面引用的修改。你使用副词来调整引用行为。</p>
</div>
<div class="paragraph">
<p><code>:q</code> 副词修改 <code>Q</code> 成为转义引用。在副词之后必须有一些空格，但在 <code>Q</code> 之后它是可选的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; Q:q &#39;This quote \&#39; escapes \\&#39;
This quote &#39; escapes \
&gt; Q :q &#39;This quote \&#39; escapes \\&#39;
This quote &#39; escapes \</code></pre>
</div>
</div>
<div class="paragraph">
<p>This form doesn’t specifically escape the single tick; it escapes the backslash and the delimiter characters. A backslash that doesn’t precede a delimiter or another backslash is interpreted as a literal backslash:</p>
</div>
<div class="paragraph">
<p>这种形式并没有特别转义单个记号;它转义了反斜杠和分隔符字符。不在分隔符或另一个反斜杠之前的反斜杠被解释为字面反斜杠：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; Q :q  ｢This quote \&#39; escapes｣
This quote \&#39; escapes
&gt; Q :q  ｢This quote \｢ escapes｣
This quote ｢ escapes
&gt; Q :q  ｢This quote \｢\｣ escapes｣
This quote ｢ escapes</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>:single</code> adverb is a longer version of <code>:q</code> and might help you remember what you want:</p>
</div>
<div class="paragraph">
<p><code>:single</code> 副词是 <code>:q</code> 的较长版本，可能会帮助你记住你想要的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; Q :single &#39;This quote \&#39; escapes&#39;
This quote &#39; escapes</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most of the time you aren’t going to work this hard. The common uses of quoting have default delimiters so you don’t even see the <code>Q</code>. Even though many [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> would be more correctly represented with strict literal quoting, most people tend to use the single ticks simply because it’s easier to type. No matter which quoting method you use you get the same type of object.</p>
</div>
<div class="paragraph">
<p>大多数时候你不打算这么努力。引用的常见用法具有默认分隔符，因此你甚至不会看到 <code>Q</code>.即使使用严格的字面引用更准确地表示许多[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)，大多数人倾向于使用单个记号，因为它更容易键入。无论使用哪种引用方法，都可以获得相同类型的对象。" class="bare">https://docs.raku.org/type/Str.html)，大多数人倾向于使用单个记号，因为它更容易键入。无论使用哪种引用方法，都可以获得相同类型的对象。</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_string_operators_and_methods">2.2.2. String Operators and Methods</h4>
<div class="paragraph">
<p>Use the concatenation operator, <code>~</code>, to combine [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a>. Some people call this “string addition.” The output shows the two [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> as one with nothing else between them:</p>
</div>
<div class="paragraph">
<p>使用连接运算符 <code>~</code> 来组合[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)。有些人将此称为“字符串添加。”输出显示两个"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)合为一个，它们之间没有其他内容：" class="bare">https://docs.raku.org/type/Str.html)合为一个，它们之间没有其他内容：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = &#39;Hamadryas&#39; ~ &#39;perlicus&#39;;
put $name;      # Hamadryasperlicus</code></pre>
</div>
</div>
<div class="paragraph">
<p>You could add a space yourself by putting it in one of the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a>, but you can also concatenate more than two [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> at a time:</p>
</div>
<div class="paragraph">
<p>你可以在两个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)之间添加一个空格，但你也可以一次连接两个以上的"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)：" class="bare">https://docs.raku.org/type/Str.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Hamadryas &#39; ~ &#39;perlicus&#39;;
put &#39;Hamadryas&#39; ~ &#39; &#39; ~ &#39;perlicus&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>join</code> routine glues together [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> with the first [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) you give it:</p>
</div>
<div class="paragraph">
<p><code>join</code> 例程将[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)与你给它的第一个"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)粘在一起：" class="bare">https://docs.raku.org/type/Str.html)粘在一起：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly-name = join &#39; &#39;, &#39;Hamadryas&#39;, &#39;perlicus&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can make larger [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> by repeating a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>). The <code>x</code> is the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) replication operator. It repeats the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) the number of times you specify. This is handy for making a text-based divider or ruler for your output:</p>
</div>
<div class="paragraph">
<p>你可以通过重复[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)来制作更大的"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)。" class="bare">https://docs.raku.org/type/Str.html)。</a><code>x</code> 是[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)复制运算符。它会重复"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)指定的次数。这对于为输出创建基于文本的分隔符或标尺很方便：" class="bare">https://docs.raku.org/type/Str.html)指定的次数。这对于为输出创建基于文本的分隔符或标尺很方便：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;-&#39; x 70;
put &#39;.123456789&#39; x 7;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.chars</code> methods tells you how many characters are in the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>):</p>
</div>
<div class="paragraph">
<p><code>.chars</code> 方法告诉你[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)中有多少个字符：" class="bare">https://docs.raku.org/type/Str.html)中有多少个字符：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Hamadryas&#39;.chars;  # 9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) with at least one character is <code>True</code> as a Boolean, including the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) of the single character <code>0</code>:</p>
</div>
<div class="paragraph">
<p>任何具有至少一个字符的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)都是" class="bare">https://docs.raku.org/type/Str.html)都是</a> <code>True</code> 作为布尔值，包括单个字符 <code>0</code> 的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)：" class="bare">https://docs.raku.org/type/Str.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put ?&#39;Hamadryas&#39;;       # True
put ?&#39;0&#39;;               # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>The empty string has no characters. It consists only of the opening delimiter and the closing delimiter. It’s <code>False</code> as a Boolean:</p>
</div>
<div class="paragraph">
<p>空字符串没有字符。它仅包含开口分隔符和闭合分隔符。它作为布尔值是假的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;&#39;.chars;           # 0
put ?&#39;&#39;;                # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>Be careful that when you test a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) you test the right thing. A [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) type object is also <code>False</code>, but `.DEFINITE`can tell them apart:</p>
</div>
<div class="paragraph">
<p>小心，当你测试一个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)你测试正确的东西。" class="bare">https://docs.raku.org/type/Str.html)你测试正确的东西。</a> [<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)类型对象也是" class="bare">https://docs.raku.org/type/Str.html)类型对象也是</a> <code>False</code>，但 <code>.DEFINITE</code> 可以将它们区分开：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;&#39;.DEFINITE         # True
put Str.DEFINITE        # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is handy in a conditional expression where you don’t care what the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) is (empty, <code>&#39;0&#39;</code>, or anything else) as long as it’s not a type object:</p>
</div>
<div class="paragraph">
<p>这在条件表达式中很方便，只要它不是类型对象，你不关心[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)是什么（空，" class="bare">https://docs.raku.org/type/Str.html)是什么（空，</a><code>&#39;0&#39;</code> 或其他任何东西）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given $string {
    when .DEFINITE {
        put .chars ?? &#39;Has characters&#39; !! &#39;Is empty&#39;;
        }
    default { put &#39;Type object&#39; }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.lc</code> method changes all the characters in a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) to lowercase, and <code>.uc</code> changes them to uppercase:</p>
</div>
<div class="paragraph">
<p><code>.lc</code> 方法将[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)中的所有字符更改为小写，" class="bare">https://docs.raku.org/type/Str.html)中的所有字符更改为小写，</a><code>.uc</code> 将它们更改为大写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;HaMAdRyAs&#39;.lc;     # hamadryas
put &#39;perlicus&#39;.uc;      # PERLICUS</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.tclc</code> method uses title case, lowercasing everything then capitalizing the first character of the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>):</p>
</div>
<div class="paragraph">
<p><code>.tclc</code> 方法使用标题大小写，小写所有内容然后大写[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)的第一个字符：" class="bare">https://docs.raku.org/type/Str.html)的第一个字符：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;hamadryas PERLICUS&#39;.tc;    # Hamadryas perlicus</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 4.1Write a program to report the number of characters in the text you enter.</p>
</div>
<div class="paragraph">
<p>EXERCISE 4.2Modify the previous exercise to continually prompt for text and report the number of characters in your answers until you provide an empty answer.</p>
</div>
<div class="paragraph">
<p>练习4.1 编写一个程序来报告你输入的文本中的字符数。</p>
</div>
<div class="paragraph">
<p>练习4.2 修改上一个练习以不断提示文本并报告答案中的字符数，直到你提供空答案。</p>
</div>
</div>
<div class="sect3">
<h4 id="_looking_inside_strings">2.2.3. Looking Inside Strings</h4>
<div class="paragraph">
<p>You can also inspect a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) to find out things about it. The <code>.contains</code> method returns a Boolean value indicating whether it finds one [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)—the" class="bare">https://docs.raku.org/type/Str.html)—the</a> substring—inside the target [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>):</p>
</div>
<div class="paragraph">
<p>你也可以检查一下[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)来找出它的相关信息。" class="bare">https://docs.raku.org/type/Str.html)来找出它的相关信息。</a> <code>.contains</code> 方法返回一个布尔值，指示它是否找到一个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)-子字符串-在目标"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)内：" class="bare">https://docs.raku.org/type/Str.html)内：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#39;Hamadryas perlicus&#39;.contains( &#39;perl&#39; )
True
&gt; &#39;Hamadryas perlicus&#39;.contains( &#39;Perl&#39; )
False</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of parentheses you can put a colon followed by the substring to search for:</p>
</div>
<div class="paragraph">
<p>你可以使用冒号后跟子字符串来代替圆括号来搜索：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#39;Hamadryas perlicus&#39;.contains: &#39;perl&#39;
True
&gt; &#39;Hamadryas perlicus&#39;.contains: &#39;Perl&#39;
False</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.starts-with</code> and <code>.ends-with</code> methods do the same thing as <code>.contains</code> but require the substring to appear at a particular location:</p>
</div>
<div class="paragraph">
<p><code>.starts-with</code> 和 <code>.ends-with</code> 方法与 <code>.contains</code> 的作用相同，但要求子字符串出现在特定位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; &#39;Hamadryas perlicus&#39;.starts-with: &#39;Hama&#39;
True
&gt; &#39;Hamadryas perlicus&#39;.starts-with: &#39;hama&#39;
False
&gt; &#39;Hamadryas perlicus&#39;.ends-with: &#39;us&#39;
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>These methods are case sensitive. The case of each character in the substring must match the case in the target [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>). If it’s uppercase in the substring it must be uppercase in the target. If you want case insensitivity you canuse <code>.fc</code> to make a “caseless” [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>). This “case folding” method is especially designed for comparisons:</p>
</div>
<div class="paragraph">
<p>这些方法区分大小写。子字符串中每个字符的大小写必须与目标[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)中的大小写匹配。如果它在子字符串中是大写的，则它在目标中必须为大写。如果你想要不区分大小写，你可以使用" class="bare">https://docs.raku.org/type/Str.html)中的大小写匹配。如果它在子字符串中是大写的，则它在目标中必须为大写。如果你想要不区分大小写，你可以使用</a> <code>.fc</code> 来制作一个“无大小写”的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)。这种“大小写折叠”方法专门用于比较：" class="bare">https://docs.raku.org/type/Str.html)。这种“大小写折叠”方法专门用于比较：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; &#39;Hamadryas perlicus&#39;.fc.starts-with: &#39;hama&#39;
False</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.fc</code> also knows about equivalent characters such as the <strong>ss</strong> and the sharp <strong>ß</strong>. The method doesn’t change the text; it evaluates to a new [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) based on a long list of rules about equivalence defined by Unicode. You should case fold both the target and substrings if you want to allow these sorts of variations:</p>
</div>
<div class="paragraph">
<p><code>.fc</code> 也知道相等的字符，如 <strong>ss</strong> 和 <strong>sharpß</strong>。该方法不会改变文本; 它基于由 Unicode 定义的关于等价的一长串规则列表来计算新的 [<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)。如果要允许这些变化，你应该折叠目标字符串和子字符串串：" class="bare">https://docs.raku.org/type/Str.html)。如果要允许这些变化，你应该折叠目标字符串和子字符串串：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; &#39;Reichwaldstrasse&#39;.contains: &#39;straße&#39;
False
&gt; &#39;Reichwaldstrasse&#39;.fc.contains: &#39;straße&#39;
False
&gt; &#39;Reichwaldstrasse&#39;.contains: &#39;straße&#39;.fc
True
&gt; &#39;Reichwaldstrasse&#39;.fc.contains: &#39;straße&#39;.fc
True</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.substr</code> extracts a substring by its starting position and length inside the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>). The counting starts with zero at the first character:</p>
</div>
<div class="paragraph">
<p><code>.substr</code> 通过[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)中的起始位置和长度提取子字符串。计数从第一个字符的零开始：" class="bare">https://docs.raku.org/type/Str.html)中的起始位置和长度提取子字符串。计数从第一个字符的零开始：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Hamadryas perlicus&#39;.substr: 10, 4;     # perl</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.index</code> method tells you where it finds a substring inside the larger [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) (still counting from zero), or returns <code>Nil</code> if it can’t find the substring:</p>
</div>
<div class="paragraph">
<p><code>.index</code> 方法告诉你它在较大的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)内部找到一个子字符串（仍然从零开始计数），或者如果它找不到子字符串则返回" class="bare">https://docs.raku.org/type/Str.html)内部找到一个子字符串（仍然从零开始计数），或者如果它找不到子字符串则返回</a> <code>Nil</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $i = &#39;Hamadryas perlicus&#39;.index: &#39;p&#39;;
put $i ?? &#39;Found at &#39; ~ $i !! &#39;Not in string&#39;; # Found at 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use both of them together to figure out where to start:</p>
</div>
<div class="paragraph">
<p>同时使用它俩来确定从哪里开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = &#39;Hamadryas perlicus&#39;;
put do given $s.index: &#39;p&#39; {
    when Nil { &#39;Not found&#39; }
    when Int { $s.substr: $_, 4 }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 4.3Repeatedly prompt for text and report if it contains the substring “Hamad”. Stop prompting if the answer has no characters (an empty answer). Can you make this work regardless of casing?</p>
</div>
<div class="paragraph">
<p>练习4.3 如果包含子字符串 “Hamad”，则重复提示文本和报告。如果答案没有字符，则停止提示（空答案）。如果没有大小写，你能做到这一点吗？</p>
</div>
</div>
<div class="sect3">
<h4 id="_normal_form_grapheme">2.2.4. Normal Form Grapheme</h4>
<div class="paragraph">
<p>Raku is Unicode all the way down. It works on graphemes, which most of us think of as “characters” in the everyday sense. These are the full expression of some idea, such as <strong>e</strong>, <strong>é</strong>, or ![img](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/assets/butterfly.png" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/assets/butterfly.png</a>). It expects your source code to be UTF-8 encoded and outputs UTF-8 text. All of these work, although they each represent a different language:</p>
</div>
<div class="paragraph">
<p>Raku 一直是支持 Unicode 的。它适用于字素，我们大多数人都认为它是日常意义上的“字符”。这些是一些想法的完整表达，例如e，é，或 ![img](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/assets/butterfly.png)。它希望你的源代码是" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/assets/butterfly.png)。它希望你的源代码是</a> UTF-8 编码并输出 UTF-8 文本。所有这些都有效，虽然它们各自代表不同的语言：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#39;көпөлөк&#39;
&#39;तितली&#39;
&#39;蝴蝶&#39;
&#39;Con bướm&#39;
&#39;tauriņš&#39;
&#39;πεταλούδα&#39;
&#39;भंबीरा&#39;
&#39;פרפר&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use emojis too:</p>
</div>
<div class="paragraph">
<p>你也可以使用表情符号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = &#39;&#39;;
put $string;</code></pre>
</div>
</div>
<div class="paragraph">
<p>One of the Raku “characters” might be made of up two or more entries in the Universal Character Database (<strong>UCD</strong>). Raku refers to entries in the UCD as codes and to their composition as a “character.” It’s not the best terminology. In this book, <strong>character</strong> means grapheme and <strong>code point</strong> refers to an entry in the UCD.</p>
</div>
<div class="paragraph">
<p>Why does any of that matter? The <code>.chars</code> method tells you the length of the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) in graphemes. Consider the Hebrew word for “caterpillar.” It has 11 graphemes but 14 code points:</p>
</div>
<div class="paragraph">
<p>其中一个 Raku “字符”可能由通用字符数据库（UCD）中的两个或多个条目组成。 Raku 将 UCD 中的条目称为代码，将其组成称为“字符”。这不是最好的术语。在本书中，字符表示字素，而代码点表示 UCD 中的条目。</p>
</div>
<div class="paragraph">
<p>为什么这有关系？ <code>.chars</code> 方法告诉你字素中[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)的长度。考虑希伯来语中的“caterpillar”一词。它有" class="bare">https://docs.raku.org/type/Str.html)的长度。考虑希伯来语中的“caterpillar”一词。它有</a> 11 个字素，但有 14 个代码点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#39;קאַטערפּיללאַר&#39;.chars
11
&gt; &#39;קאַטערפּיללאַר&#39;.codes
14</code></pre>
</div>
</div>
<div class="paragraph">
<p>Why the different counts? There are graphemes such as <code>אַ</code> that are more than one code point (in that case, the two code points are the Hebrew Aleph and patah diacritical mark). Most of the time you won’t care about this. If you do, you can get a list of the code points with <code>.ords</code>:</p>
</div>
<div class="paragraph">
<p>为什么是不同的计数？像 <code>אַ</code> 这样的字素不止一个代码点（在这种情况下，两个代码点是希伯来语Aleph和patah变音符号）。大多数时候你不会关心这个。如果这样做，你可以用 <code>.ords</code> 获得的代码点列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; &#39;קאַטערפּיללאַר&#39;.ords
(1511 1488 1463 1496 1506 1512 1508 1468 1497 1500
1500 1488 1463 1512)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_string_comparisons">2.2.5. String Comparisons</h4>
<div class="paragraph">
<p>[<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) objects know if they are relatively greater than, less than, or the same as another [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>). Raku uses lexicographic comparison to go through the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> character by character.</p>
</div>
<div class="paragraph">
<p>The numbers comparison operators are symbols, but the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> use operators made up of letters. The <code>eq</code> operator tests if the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> are exactly equal. Case matters. Every character at each position in the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) must be exactly the same in each [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>):</p>
</div>
<div class="paragraph">
<p>[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) 对象知道它们是否比另一个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)相对大，小于或相同。" class="bare">https://docs.raku.org/type/Str.html)相对大，小于或相同。</a> Raku 使用字典比较来逐字逐句地浏览[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)。" class="bare">https://docs.raku.org/type/Str.html)。</a></p>
</div>
<div class="paragraph">
<p>数字比较运算符是符号，但[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)使用由字母组成的运算符。" class="bare">https://docs.raku.org/type/Str.html)使用由字母组成的运算符。</a> <code>eq</code> 运算符测试[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)是否完全相等。大小写敏感。" class="bare">https://docs.raku.org/type/Str.html)是否完全相等。大小写敏感。</a> [<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)中每个位置的每个字符在每个"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)中必须完全相同：" class="bare">https://docs.raku.org/type/Str.html)中必须完全相同：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#39;Hamadryas&#39; eq &#39;hamadryas&#39;
False
&gt; &#39;Hamadryas&#39; eq &#39;Hamadryas&#39;
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>gt</code> operator evaluates to <code>True</code> if the first [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) is strictly lexicographically greater than the second (<code>ge</code> allows it to be greater than or equal to the second [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)" class="bare">https://docs.raku.org/type/Str.html)</a>). This is not a dictionary comparison, so case matters. The lowercase letters come after the uppercase ones and so are “greater”:</p>
</div>
<div class="paragraph">
<p>如果第一个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)严格按字典顺序排列大于第二个（" class="bare">https://docs.raku.org/type/Str.html)严格按字典顺序排列大于第二个（</a><code>ge</code> 允许它大于或等于第二个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)），则`gt`运算符的计算结果为" class="bare">https://docs.raku.org/type/Str.html)），则`gt`运算符的计算结果为</a> <code>True</code>。这不是字典比较，因此大小写敏感。小写字母位于大写字母之后，因此“更大”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#39;Hama&#39; gt &#39;hama&#39;
False
&gt; &#39;hama&#39; gt &#39;Hama&#39;
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>The uppercase letters come before the lowercase ones, so any [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) that starts with a lowercase letter is greater than any [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) that starts with an uppercase letter:</p>
</div>
<div class="paragraph">
<p>大写字母位于小写字母之前，因此任何以小写字母开头的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)都大于以大写字母开头的任何"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)：" class="bare">https://docs.raku.org/type/Str.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#39;alpha&#39; gt &#39;Omega&#39;
True
&gt; &#39;α&#39; gt &#39;Ω&#39;
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can get some weird results if you compare numbers as [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a>. The character <code>2</code> is greater than the character <code>1</code>, so any [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) starting with <code>2</code> is greater than any [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) starting with <code>1</code>:</p>
</div>
<div class="paragraph">
<p>如果将数字作为[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)进行比较，你可能会得到一些奇怪的结果。字符`2`大于字符`1`，因此从`2`开始的任何"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)都大于从`1`开始的任何"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)：" class="bare">https://docs.raku.org/type/Str.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#39;2&#39; gt &#39;10&#39;
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>lt</code> operator evaluates to <code>True</code> if the first [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) is lexicographically less than the second (<code>le</code> allows it to be less than or equal to the second [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)" class="bare">https://docs.raku.org/type/Str.html)</a>):</p>
</div>
<div class="paragraph">
<p>如果第一个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)在字典上小于第二个（" class="bare">https://docs.raku.org/type/Str.html)在字典上小于第二个（</a><code>le</code> 允许它小于或等于第二个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)），则" class="bare">https://docs.raku.org/type/Str.html)），则</a> <code>lt</code> 运算符求值为 <code>True</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#39;Perl 5&#39; lt &#39;Raku&#39;
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don’t care about their case you can lowercase both sides with <code>.lc</code>:</p>
</div>
<div class="paragraph">
<p>如果你不关心他们的大小写你可以使用 <code>.lc</code> 小写双方：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#39;Hamadryas&#39;.lc eq &#39;hamadryas&#39;.lc
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>This wouldn’t work for the Reichwaldstrasse example you saw previously. If you wanted to allow for equivalent representations you’d use <code>.fc</code>:</p>
</div>
<div class="paragraph">
<p>这对你之前看到的 Reichwaldstrasse 例子不起作用。如果你想允许等效表示，请使用 <code>.fc</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#39;Reichwaldstrasse&#39;.lc eq &#39;Reichwaldstraße&#39;.lc
False
&gt; &#39;Reichwaldstrasse&#39;.fc eq &#39;Reichwaldstraße&#39;.fc
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with numbers, you can chain the comparisons:</p>
</div>
<div class="paragraph">
<p>与数字一样，你可以链接比较：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#39;aardvark&#39; lt &#39;butterfly&#39; lt &#39;zebra&#39;
True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_prompting_for_input">2.2.6. Prompting for Input</h4>
<div class="paragraph">
<p>You’ve already used <code>prompt</code> for simple things. When you call it your program reads a single line and chops off the newline that you typed. A small modification of the program shows you what sort of type you get back:</p>
</div>
<div class="paragraph">
<p>你已经将 <code>prompt</code> 用于简单的提示了。当你调用它时，你的程序读取一行并切掉你键入的换行符。对程序进行一些小修改即可显示你获得的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $answer = prompt( &#39;What\&#39;s your favorite animal? &#39; );
put &#39;$answer is type &#39;, $answer.^name;
put &#39;You chose &#39;, $answer;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you answer the question you get a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>):</p>
</div>
<div class="paragraph">
<p>当你回答这个问题时，你会得到一个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)：" class="bare">https://docs.raku.org/type/Str.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku prompt.p6
What&#39;s your favorite animal? Fox
$answer is type Str
You chose Fox</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you don’t type anything other than a Return the answer is still a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>), but it’s an empty [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>):</p>
</div>
<div class="paragraph">
<p>当你没有输入除了换行符之外的任何东西时，答案仍然是一个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)，但它是一个空"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)：" class="bare">https://docs.raku.org/type/Str.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku prompt.p6
What&#39;s your favorite animal?
$answer is type Str
You chose</code></pre>
</div>
</div>
<div class="paragraph">
<p>You end input with Control-D, which is the same as not typing anything. In that case it returns an [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>) type object. Notice that the line showing the type appears on the same line as the prompt text—you never typed a Return. There’s also a warning about that [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>) value, and finally your last line of output:</p>
</div>
<div class="paragraph">
<p>你使用 Control-D 结束输入，这与不输入任何内容相同。在这种情况下，它返回一个[<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>) 类型的对象。请注意，显示该类型的行与提示文本显示在同一行 - 你从未键入Return。还有关于[<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>) 值的警告，最后是你的最后一行输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku prompt.p6
What&#39;s your favorite animal? $answer is type Any
Use of uninitialized value $answer of type Any in string context.
You chose</code></pre>
</div>
</div>
<div class="paragraph">
<p>To guard against this problem you can test <code>$answer</code>. The [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>) type object is always <code>False</code>. So is the empty [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>):</p>
</div>
<div class="paragraph">
<p>为了防止这个问题，你可以测试 <code>$answer</code>。 [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>)  类型对象始终为 <code>False</code>。空的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)也是如此：" class="bare">https://docs.raku.org/type/Str.html)也是如此：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $answer = prompt( &#39;What\&#39;s your favorite animal? &#39; );
put do
    if $answer { &#39;You chose &#39; ~ $answer }
    else       { &#39;You didn\&#39;t choose anything.&#39; }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>prompt</code> takes whatever you type, including whitespace. If you put some spaces at the beginning and end that’s what shows up in the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>):</p>
</div>
<div class="paragraph">
<p><code>prompt`接受你输入的任何内容，包括空格。如果你在开头和结尾放置一些空格，那就是[`字符串</code>](<a href="https://docs.raku.org/type/Str.html)中出现的空格：" class="bare">https://docs.raku.org/type/Str.html)中出现的空格：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku prompt.p6
What&#39;s your favorite animal?                 Butterfly
You chose                 Butterfly</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see this better if you put in something to surround the answer portion of the output, such as <code>&lt;&gt;</code> in this example:</p>
</div>
<div class="paragraph">
<p>如果你在输出的答案部分放置一些东西，你可以更好地看到这一点，例如本例中的 <code>&lt;&gt;</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $answer = prompt( &#39;What\&#39;s your favorite animal? &#39; );
put do
   if $answer { &#39;You chose &lt;&#39;, $answer, &#39;&gt;&#39; }
   else       { &#39;You didn&#39;t choose anything&#39; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you can easily see the extra space in <code>$answer</code>:</p>
</div>
<div class="paragraph">
<p>现在，你可以轻松地在 <code>$answer</code> 中看到额外的空格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku prompt.p6
What&#39;s your favorite animal?                 Butterfly
You chose &lt;                Butterfly            &gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.trim</code> method takes off the surrounding whitespace and gives you back the result:</p>
</div>
<div class="paragraph">
<p><code>.trim</code> 方法去掉周围的空格并返回结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $answer = prompt( &#39;What\&#39;s your favorite animal? &#39; ).trim;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you apply it to <code>$answer</code> by itself it doesn’t work:</p>
</div>
<div class="paragraph">
<p>如果你将它自己应用于 <code>$answer</code> 那么它不起作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$answer.trim;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You need to assign the result to <code>$answer</code> to get the updated value:</p>
</div>
<div class="paragraph">
<p>你需要将结果赋值给 <code>$answer</code> 以获取更新后的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$answer = $answer.trim;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That requires you to type <code>$answer</code> twice. However, you know about binary assignment so you can shorten that to use the variable name once:</p>
</div>
<div class="paragraph">
<p>这要求你输入两次 <code>$answer</code>。但是，你知道二进制赋值，因此你可以缩短它以使用变量名称一次：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$answer .= trim;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don’t want to remove the whitespace from both sides you can use either <code>.trim-leading</code> or <code>.trim-trailing</code> for the side that you want.</p>
</div>
<div class="paragraph">
<p>如果你不想从两侧删除空格，可以使用 <code>.trim-leading</code> 或 <code>.trim-trailing</code> 作为所需的一侧。</p>
</div>
</div>
<div class="sect3">
<h4 id="_number_to_string_conversions">2.2.7. Number to String Conversions</h4>
<div class="paragraph">
<p>You can easily convert numbers to [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> with the <code>.Str</code> method. They may not look like what you started with. These look like number values but they are actually [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) objects where the digits you see are characters:</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>.Str</code> 方法轻松地将数字转换为[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)。它们可能看起来不像开始那样。这些看起来像数字值但它们实际上是"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)对象，其中你看到的数字是字符：" class="bare">https://docs.raku.org/type/Str.html)对象，其中你看到的数字是字符：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 4.Str
4
&gt; &lt;4/5&gt;.Str
0.8
&gt; (13+7i).Str
13+7i</code></pre>
</div>
</div>
<div class="paragraph">
<p>The unary prefix version of <code>~</code> does the same thing:</p>
</div>
<div class="paragraph">
<p><code>~</code> 的一元前缀版本做同样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; ~4
4
&gt; ~&lt;4/5&gt;
0.8
&gt; ~(13+7i)
13+7i</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you use a number in a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) operation it automatically converts it to its [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) form:</p>
</div>
<div class="paragraph">
<p>如果在[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)操作中使用数字，它会自动将其转换为"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)形式：" class="bare">https://docs.raku.org/type/Str.html)形式：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#39;Hamadryas &#39; ~ &lt;4/5&gt;
Hamadryas 0.8
&gt; &#39;Hamadryas &#39; ~ 5.5
Hamadryas 5.5</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_string_to_number_conversions">2.2.8. String to Number Conversions</h4>
<div class="paragraph">
<p>Going from [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> to numbers is slightly more complicated. If the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) looks like a number you can convert it to some sort of number with the unary prefix version of <code>+</code>. It converts the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) to the number of the narrowest form, which you can check with <code>.^name</code>:</p>
</div>
<div class="paragraph">
<p>从[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)到数字稍微复杂一些。如果"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)看起来像一个数字，你可以使用一元前缀版本`+" class="bare">https://docs.raku.org/type/Str.html)看起来像一个数字，你可以使用一元前缀版本`+</a><code>将其转换为某种数字。它将[`字符串</code>](<a href="https://docs.raku.org/type/Str.html)转换为最窄形式的数字，你可以查看" class="bare">https://docs.raku.org/type/Str.html)转换为最窄形式的数字，你可以查看</a> <code>^name</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; +&#39;137&#39;
137
&gt; (+&#39;137&#39;).^name
Int
&gt; +&#39;1/2&#39;
0.5
&gt; (+&#39;1/2&#39;).^name
Rat</code></pre>
</div>
</div>
<div class="paragraph">
<p>This only works for decimal digits. You can have the decimal digits 0 to 9 and a possible decimal point followed by more decimal digits. An underscore is allowed with the same rules as for literal numbers. The conversion ignores surrounding whitespace:</p>
</div>
<div class="paragraph">
<p>这仅适用于十进制数字。你可以使用小数位数0到9以及可能的小数点后跟更多的十进制数字。允许使用与字面数相同的规则的下划线。转换忽略了周围的空格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; +&#39; 1234 &#39;
1234
&gt; +&#39; 1_234 &#39;
1234
&gt; +&#39; 12.34 &#39;
12.34</code></pre>
</div>
</div>
<div class="paragraph">
<p>Anything else, such as two decimal points, causes an error:</p>
</div>
<div class="paragraph">
<p>其他任何内容，例如两个小数点，都会导致错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; +&#39;12.34.56&#39;
Cannot convert string to number: trailing characters after number</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you perform numerical operations on a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) it’s automatically converted to a number:</p>
</div>
<div class="paragraph">
<p>当你对[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)执行数值运算时，它会自动转换为数字：" class="bare">https://docs.raku.org/type/Str.html)执行数值运算时，它会自动转换为数字：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#39;2&#39; + 3
5
&gt; &#39;2&#39; + &#39;4&#39;
6
&gt; &#39;2&#39; ** &#39;8&#39;
256</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 4.4Write a program that prompts for two numbers then outputs their sum, difference, product, and quotient. What happens if you enter something that’s not a number? (You don’t need to handle any errors.)</p>
</div>
<div class="paragraph">
<p>In the previous exercise you should have been able to create a conversion error even though you didn’t have the tools to handle it. If you want to check if a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) can convert to a number you can use the <code>val</code> routine. That gives you an object that does the [<code>Numeric</code>](<a href="https://docs.raku.org/type/Numeric.html" class="bare">https://docs.raku.org/type/Numeric.html</a>) role if it can convert the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>). Use the smart match operator to check that it worked:</p>
</div>
<div class="paragraph">
<p>练习4.4 写一个程序，提示输入两个数字，然后输出它们的和，差，乘积和商。如果你输入的不是数字，会发生什么？ （你不需要处理任何错误。）</p>
</div>
<div class="paragraph">
<p>在上一个练习中，即使你没有处理它的工具，你也应该能够创建转换错误。如果要检查[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)是否可以转换为数字，可以使用" class="bare">https://docs.raku.org/type/Str.html)是否可以转换为数字，可以使用</a> <code>val</code> 例程。如果它可以转换[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)，那么它将为你提供一个执行" class="bare">https://docs.raku.org/type/Str.html)，那么它将为你提供一个执行</a> [<code>Numeric</code>](<a href="https://docs.raku.org/type/Numeric.html" class="bare">https://docs.raku.org/type/Numeric.html</a>) 角色的对象。使用智能匹配运算符检查它是否有效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $some-value = prompt( &#39;Enter any value: &#39; );
my $candidate = val( $some-value );

put $candidate, &#39; &#39;, do
    if $candidate ~~ Numeric { &#39; is numeric&#39; }
    else                     { &#39; is not numeric&#39; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This seems complicated now because you haven’t read about interpolated [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> yet. It will be much clearer by the end of this chapter.</p>
</div>
<div class="paragraph">
<p>EXERCISE 4.5Update the previous exercise to handle nonnumeric values that would cause a conversion error. If one of the values isn’t numeric, output a message saying so.</p>
</div>
<div class="paragraph">
<p>Sometimes your text is numeric but not decimal. The <code>.parse-base</code> method can convert it for you. It takes a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) that looks like a nondecimal number and turns it into a number:</p>
</div>
<div class="paragraph">
<p>现在这看起来很复杂，因为你还没有读过有关插值的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)。到本章结尾将会更清楚。" class="bare">https://docs.raku.org/type/Str.html)。到本章结尾将会更清楚。</a></p>
</div>
<div class="paragraph">
<p>练习4.5 更新上一个练习以处理可能导致转换错误的非数字值。如果其中一个值不是数字，则输出一条说明的消息。</p>
</div>
<div class="paragraph">
<p>有时你的文本是数字但不是小数。 <code>.parse-base</code> 方法可以为你转换它。它需要一个看起来像非十进制数字的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)并将其转换为数字：" class="bare">https://docs.raku.org/type/Str.html)并将其转换为数字：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $octal  = &#39;0755&#39;.parse-base: 8;     # 493
my $number = &#39;IG88&#39;.parse-base: 36;    # 860840</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the same thing the colon form was doing in [Chapter 3](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch03.html#camelia-numbers" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch03.html#camelia-numbers</a>):</p>
</div>
<div class="paragraph">
<p>这与第3章中的冒号对形式所做的相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">:8<i class="conum" data-value="0755"></i><b>(0755)</b>
:36&lt;IG88&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interpolated_strings">2.3. Interpolated Strings</h3>
<div class="paragraph">
<p>You’ve taken a long path through this chapter to get to the quoting mechanism that you’re likely to use the most. An interpolated string replaces special sequences within the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) with other characters. These [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> will also make easier some of the code you’ve already seen.</p>
</div>
<div class="paragraph">
<p>Interpolated [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> use the double quote, <code>&#34;</code>, as the default delimiter and are sometimes called double-quoted strings. You need to escape the <code>&#34;</code> if you want one in the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>), and you can escape the <code>\</code>:</p>
</div>
<div class="paragraph">
<p>你已经通过本章走了很长的路，以了解你可能最常使用的引用机制。插值字符串用其他字符替换[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)中的特殊序列。这些"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)也会使你已经看过的一些代码变得更容易。" class="bare">https://docs.raku.org/type/Str.html)也会使你已经看过的一些代码变得更容易。</a></p>
</div>
<div class="paragraph">
<p>插值[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)使用双引号" class="bare">https://docs.raku.org/type/Str.html)使用双引号</a> <code>&#34;</code> 作为默认分隔符，有时也称为双引号字符串。如果你想在[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)中使用双引号你需要转义" class="bare">https://docs.raku.org/type/Str.html)中使用双引号你需要转义</a> <code>&#34;</code>，你也可以转义 <code>\</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; &#34;Hamadryas perlicus&#34;
Hamadryas perlicus
&gt; &#34;The escaped \&#34; stays in the string&#34;
The escaped &#34; stays in the string
&gt; &#34;Escape the \\ backslash&#34;
Escape the \ backslash</code></pre>
</div>
</div>
<div class="paragraph">
<p>The backslash also starts other special interpolating sequences. A <code>\t</code> represents a tab character. A <code>\n</code> represents a newline:</p>
</div>
<div class="paragraph">
<p>反斜杠也会启动其他特殊插值序列。 <code>\t</code> 表示制表符。 <code>\n</code> 表示换行符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;First line\nSecond line\nThird line&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want a character that’s not easy to type you can put its code number (a hexadecimal value) after <code>\x</code> or inside <code>\x[]</code>. Don’t use the <code>0x</code> prefix; the <code>\x</code> already assumes that:</p>
</div>
<div class="paragraph">
<p>如果你想要一个不容易输入的字符，你可以在 <code>\x</code> 之后或在 <code>\x[]</code> 之内输入它的代码号（十六进制值）。不要使用 <code>0x</code> 前缀; <code>\x</code> 已经假定：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;The snowman is \x[2603]&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Several comma-separated code numbers inside <code>\x[]</code> turn into multiple characters:</p>
</div>
<div class="paragraph">
<p><code>\x[]</code> 内的几个以逗号分隔的代码编号变为多个字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;\x[1F98B, 2665, 1F33B]&#34;;  #</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you know the name of the character you can put that inside <code>\c[]</code>. You don’t quote these names and the names are case insensitive:</p>
</div>
<div class="paragraph">
<p>如果你知道字符的名称，可以将其放在 <code>\c[]</code> 中。你不引起这些名称，并且名称不区分大小写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;\c[BUTTERFLY, BLACK HEART, TACO]&#34;;  #</code></pre>
</div>
</div>
<div class="paragraph">
<p>Those are nice, but it’s much more handy to interpolate variables. When a double-quoted [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) recognizes a sigiled variable name it replaces the variable with its value:</p>
</div>
<div class="paragraph">
<p>这些很好，但插入变量更方便。当双引号[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)识别出一个带符号的变量名时，它用它的值替换变量：" class="bare">https://docs.raku.org/type/Str.html)识别出一个带符号的变量名时，它用它的值替换变量：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = &#39;Hamadryas perlicus&#39;;
put &#34;The best butterfly is $name&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The quoting slang looks for the longest possible variable name (and not the longest name actually defined). If the text after the variable name looks like it could be a variable name that’s the variable it looks for:</p>
</div>
<div class="paragraph">
<p>引用方言查找可能的最长变量名称（而不是实际定义的最长名称）。如果变量名后面的文本看起来像是一个变量名，那就是它所寻找的变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = &#39;Hamadryas perlicus&#39;;
put &#34;The best butterfly is $name-just saying!&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a compile-time error:</p>
</div>
<div class="paragraph">
<p>这是一个编译时错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Variable &#39;$name-just&#39; is not declared</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need to separate the variable name from the rest of the text in the double-quoted [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) you can surround the entire variable in braces:</p>
</div>
<div class="paragraph">
<p>如果你需要将变量名与双引号[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)中的其余文本分开，则可以在花括号中包围整个变量：" class="bare">https://docs.raku.org/type/Str.html)中的其余文本分开，则可以在花括号中包围整个变量：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = &#39;Hamadryas perlicus&#39;;
put &#34;The best butterfly is {$name}-just saying!&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Escape a literal <code>$</code> where it might look like a sigil that starts a variable name:</p>
</div>
<div class="paragraph">
<p>转义一个字面 <code>$</code>，它可能看起来像一个启动变量名称的sigil：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;I used the variable \$name&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now here’s the powerful part. You can put any code you like inside the braces. The quoting slang will evaluate the code and replace the braces with the last evaluated expression:</p>
</div>
<div class="paragraph">
<p>现在这是强大的部分。你可以把任何你喜欢的代码放在花括号内。引用方言将计算代码并用最后计算的表达式替换花括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;The sum of two and two is { 2 + 2 }&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This means that the previous programs in this chapter are much easier to type than they first appear. You can construct the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) inside the delimiters rather than using a series of separate [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a>:</p>
</div>
<div class="paragraph">
<p>这意味着本章中的先前程序比首次出现时更容易键入。你可以在分隔符内构造[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)而不是使用一系列单独的"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)：" class="bare">https://docs.raku.org/type/Str.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $answer = prompt( &#39;What\&#39;s your favorite animal? &#39; );
put &#34;\$answer is type {$answer.^name}&#34;;
put &#34;You chose $answer&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like with the previous [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a>, you can choose a different delimiter for interpolated [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a>. Use <code>qq</code> (double <code>q</code> for double quoting) in front of the delimiter:</p>
</div>
<div class="paragraph">
<p>与之前的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)一样，你可以为插值的"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)选择不同的分隔符。在分隔符前面使用" class="bare">https://docs.raku.org/type/Str.html)选择不同的分隔符。在分隔符前面使用</a> <code>qq</code> （两个 <code>q</code> 表示双引号）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put qq/\$answer is type {$answer.^name}/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>\n</code> is interpolated as a newline and the <code>\t</code> becomes a tab:</p>
</div>
<div class="paragraph">
<p><code>\n</code> 插值为换行符，<code>\t</code> 变为制表符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put qq/\$answer is:\n\t$answer/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) has two lines and the second one is indented:</p>
</div>
<div class="paragraph">
<p>这个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)有两行，第二行是缩进的：" class="bare">https://docs.raku.org/type/Str.html)有两行，第二行是缩进的：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">answer is:
    Hamadryas perlicus</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>qq//</code> is the same as <code>Q</code> with the <code>:qq</code> or <code>:double</code> adverb:</p>
</div>
<div class="paragraph">
<p><code>qq//</code> 与带有 <code>:qq</code> 或 <code>:double</code> 副词的 <code>Q</code> 相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put Q :qq /\$answer is type {$answer.^name}/;
put Q :double /\$answer is type {$answer.^name}/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to interpolate only part of a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) you can use <code>\qq[]</code> for that part:</p>
</div>
<div class="paragraph">
<p>如果只想插入[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)的一部分，可以使用" class="bare">https://docs.raku.org/type/Str.html)的一部分，可以使用</a> <code>\qq[]</code> 作为该部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $genus = &#39;Hamadryas&#39;;
put &#39;$genus is \qq[$genus]&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Going the other way, you can turn off interpolation for part of a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) by making that part act like a single-quoted [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) with <code>\q[]</code>:</p>
</div>
<div class="paragraph">
<p>换句话说，你可以通过使该部分与 <code>\q[]</code> 的单引号[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)一起使用来关闭部分"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)的插值：" class="bare">https://docs.raku.org/type/Str.html)的插值：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;\q[$genus] is $genus&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>[Table 4-1](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch04.html#camelia-strings-TABLE-backslashes" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch04.html#camelia-strings-TABLE-backslashes</a>) shows many other special sequences available inside a double-quoted context.</p>
</div>
<div class="paragraph">
<p>[表4-1](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch04.html#camelia-strings-TABLE-backslashes)显示了很多双引号上下文中其它可用的特殊序列。" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch04.html#camelia-strings-TABLE-backslashes)显示了很多双引号上下文中其它可用的特殊序列。</a></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Escape sequence</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The ASCII bell character</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Backspace</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\r</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Carriage return</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\n</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Newline</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\t</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tab</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\f</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Form feed</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\c[</code><strong>NAME</strong><code>]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Character by name</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\q[…]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single quote the part inside the brackets</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\qq[…]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double quote the part inside the brackets</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\x[</code><strong>ABCD</strong><code>]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Character by code number in hex</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>EXERCISE 4.6Modify your character-counting program to show the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) as well as the number of characters it counts. For example, <code>&#39;Hamadryas&#39; has 10 characters</code>. You should be able to output a single interpolated [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>).</p>
</div>
<div class="paragraph">
<p>练习4.6 修改你的字符计数程序，以显示[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)以及它所计算的字符数。例如，&#39;Hamadryas&#39;" class="bare">https://docs.raku.org/type/Str.html)以及它所计算的字符数。例如，&#39;Hamadryas&#39;</a> 有10个字符。你应该能够输出单个插值的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)。" class="bare">https://docs.raku.org/type/Str.html)。</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_here_docs">2.4. Here Docs</h3>
<div class="paragraph">
<p>For multiline quoting you could use the quoting you’ve seen so far, but every character between those delimiters matters. This often results in ugly outdenting:</p>
</div>
<div class="paragraph">
<p>对于多行引用，你可以使用到目前为止看到的引用，但这些分隔符之间的每个字符都很重要。这通常导致丑陋的外观：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $multi-line = &#39;
    Hamadryas perlicus: 19
    Vanessa atalanta: 17
    Nymphalis antiopa: 0
    &#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Interpolating <code>\n</code> doesn’t make it any prettier:</p>
</div>
<div class="paragraph">
<p>插入换行符 <code>\n</code> 不会使它更漂亮：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $multi-line = &#34;Hamadryas perlicus: 19\n...&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A here doc is a special way of quoting a multiline text. Specify a delimiter with the <code>:heredoc</code> adverb. The[<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) ends when the slang finds that same [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) on a line by itself:</p>
</div>
<div class="paragraph">
<p>here doc 是一种引用多行文本的特殊方式。使用 <code>:heredoc</code> 副词指定分隔符。当该方言在一条线上找到相同的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)时，"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)结束：" class="bare">https://docs.raku.org/type/Str.html)结束：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $multi-line = q :heredoc/END/;
    Hamadryas perlicus: 19
    Vanessa atalanta: 17
    Nymphalis antiopa: 0
    END

put $multi-line;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This also strips the same indentation it finds before the closing delimiter. The output ends up with no indention even though it had it in the literal code:</p>
</div>
<div class="paragraph">
<p>这也剥离了它在结束分隔符之前找到的相同缩进。输出最终没有缩进，即使它在字面代码中有缩进：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Hamadryas perlicus: 19
Vanessa atalanta: 17
Nymphalis antiopa: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>:to</code> adverb does the same thing as <code>:heredoc</code>:</p>
</div>
<div class="paragraph">
<p><code>:to</code> 副词与 <code>:heredoc</code> 副词的作用相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $multi-line = q :to&lt;HERE&gt;;
    Hamadryas perlicus: 19
    Vanessa atalanta: 17
    Nymphalis antiopa: 0
    HERE</code></pre>
</div>
</div>
<div class="paragraph">
<p>This works with the other quoting forms too:</p>
</div>
<div class="paragraph">
<p>这与其他引用形式一起使用也有效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put Q :to/END/;
    These are&#39;t special: $ \
    END

put qq :to/END/;
    The genus is $genus
    END</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_shell_strings">2.5. Shell Strings</h3>
<div class="paragraph">
<p>Shell strings are the same sort of quoting that you’ve seen so far, but they don’t construct a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) to store in your program. They create an external command to run in the shell. A shell string captures the command’s output and gives it to you. [Chapter 19](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch19.html#camelia-interprocess" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch19.html#camelia-interprocess</a>) covers this, but here’s something to get you started.</p>
</div>
<div class="paragraph">
<p><code>qx</code> uses the same rules as escaped [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a>. The <strong>hostname</strong> command works on both Unix and Windows systems:</p>
</div>
<div class="paragraph">
<p>Shell 字符串与你到目前为止看到的引用相同，但它们不构造要存储在程序中的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)。它们创建一个外部命令以在" class="bare">https://docs.raku.org/type/Str.html)。它们创建一个外部命令以在</a> shell 中运行。 shell 字符串捕获命令的输出并将其提供给你。第19章介绍了这一点，但这里有一些东西可以帮助你入门。</p>
</div>
<div class="paragraph">
<p><code>qx</code> 使用与转义的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)相同的规则。" class="bare">https://docs.raku.org/type/Str.html)相同的规则。</a> <strong>hostname</strong> 命令适用于 Unix 和 Windows 系统：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $uname = qx/hostname/;
put &#34;The hostname is $uname&#34;;
put &#34;The hostname is { qx/hostname/ }&#34;; # quoting inside quoting</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this output there’s a blank line between the lines because it includes the newline in the normal command output:</p>
</div>
<div class="paragraph">
<p>在此输出中，行之间有一个空行，因为它包含正常命令输出中的换行符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">The hostname is hamadryas.local

The hostname is hamadryas.local</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use <code>.chomp</code> to fix that. If there’s a newline on the end of the text it removes it (although <code>put</code> adds its own):</p>
</div>
<div class="paragraph">
<p>使用 <code>.chomp</code> 来解决这个问题。如果文本末尾有换行符，则删除它（尽管 <code>put</code> 添加了自己的换行符）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $uname = qx/hostname/.chomp;
put &#34;The hostname is $uname&#34;;
put &#34;The hostname is { qx/hostname/.chomp }&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>print</code> doesn’t add a newline for you, so you don’t need to remove the one from the command output:</p>
</div>
<div class="paragraph">
<p>`print`不会为你添加换行符，因此你无需从命令输出中删除该换行符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">print &#34;The hostname is { qx/hostname/ }&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>qx</code> and <code>qqx</code> are shortcuts for single and double quoting [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> with the <code>:x</code> or <code>:exec</code> adverbs:</p>
</div>
<div class="paragraph">
<p><code>qx</code> 和 <code>qqx</code> 是带有 <code>:x</code> 或 <code>:exec</code> 副词的单引号和双引号[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)的快捷方式：" class="bare">https://docs.raku.org/type/Str.html)的快捷方式：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">print Q :q      :x    /hostname/;
print Q :q      :exec /hostname/;
print Q :single :exec /hostname/;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_shell_safety">2.5.1. Shell Safety</h4>
<div class="paragraph">
<p>In the previous examples, the shell looks through its <code>PATH</code> environment variable to find the <strong>hostname</strong> command and executes the first one that it finds. Since people can set their <code>PATH</code> (or something can set it for them), you might not get the command you expect. If you use an absolute path you don’t have this problem. Literal quoting is handy to avoid inadvertent escaping:</p>
</div>
<div class="paragraph">
<p>在前面的示例中，shell 查看其 <code>PATH</code> 环境变量以查找 <strong>hostname</strong> 命令并执行它找到的第一个命令。由于人们可以设置他们的 <code>PATH</code>（或者某些东西可以为他们设置），你可能无法得到你期望的命令。如果使用绝对路径，则不会出现此问题。字面引用可以避免无意中的转义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put Q :x &#39;/bin/hostname&#39;;
put Q :x &#39;C:\Windows\System32\hostname.exe&#39;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
I won’t cover secure programming techniques here, but I do write more about these problems in <strong>Mastering Perl</strong>. Although that’s a Perl 5 book, the risks to your program are the same.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Although you have not seen hashes yet ([Chapter 9](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch09.html#camelia-hashes)" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch09.html#camelia-hashes)</a>), you could change the environment for your program. If you set <code>PATH</code> to the empty [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) your program won’t be able to search for any programs:</p>
</div>
<div class="paragraph">
<p>我不会在这里介绍安全编程技术，但我在 Mastering Perl 中写了更多关于这些问题的内容。虽然这是一本 Perl 5书，但你的程序风险是一样的。</p>
</div>
<div class="paragraph">
<p>虽然你还没有看到哈希（第9章），但你可以更改程序的环境。如果将 <code>PATH</code> 设置为空[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)，则程序将无法搜索任何程序：" class="bare">https://docs.raku.org/type/Str.html)，则程序将无法搜索任何程序：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">%*ENV&lt;PATH&gt; = &#39;&#39;;
print Q :x &#39;hostname&#39;;       # does not find this
print Q :x &#39;/bin/hostname&#39;;  # this works</code></pre>
</div>
</div>
<div class="paragraph">
<p>If that’s too restrictive you can set the <code>PATH</code> to exactly the directories that you consider safe:</p>
</div>
<div class="paragraph">
<p>如果限制太多，你可以将 <code>PATH</code> 设置为你认为安全的目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">%*ENV&lt;PATH&gt; = &#39;/bin:/sbin&#39;;
print Q :x &#39;hostname&#39;;       # does not find this
print Q :x &#39;/bin/hostname&#39;;  # this works</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s also a double-quoted form of shell [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a>:</p>
</div>
<div class="paragraph">
<p>还有一个双引号形式的shell [<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)：" class="bare">https://docs.raku.org/type/Str.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $new-date-string = &#39;...&#39;;
my $output = qqx/date $new-date-string/</code></pre>
</div>
</div>
<div class="paragraph">
<p>What’s in that <code>$new-date-string</code>? If it descends from user data, external configuration, or something else that you don’t control, you might be in for a surprise. That could be malicious or merely accidental, so be careful:</p>
</div>
<div class="paragraph">
<p>那个 <code>$new-date-string</code> 中有什么？如果它来自用户数据，外部配置或你无法控制的其他内容，你可能会感到惊讶。这可能是恶意的或仅仅是偶然的，所以要小心：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $new-date-string = &#39;; /bin/rm -rf&#39;;
my $output = qqx/date $new-date-string/</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 4.7Write a program to capture the output of <strong>hostname</strong>. Make it work on both Windows and Unix systems. <code>$*DISTRO.is-win</code> is <code>True</code> if you are on Windows and <code>False</code> otherwise.</p>
</div>
<div class="paragraph">
<p>练习4.7 编写一个程序来捕获主机名的输出。使其适用于 Windows 和 Unix 系统。如果你在 Windows上，<code>$* DISTRO.is-win</code> 为 <code>True</code>，否则为 <code>False</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fancier_quoting">2.6. Fancier Quoting</h3>
<div class="paragraph">
<p>You can combine adverbs in generalized quoting to use just the features that you need. Suppose that you want to interpolate only things in braces but nothing else. You can use the <code>:c</code> adverb:</p>
</div>
<div class="paragraph">
<p>你可以在通用引用中组合副词，以仅使用所需的功能。假设你只想在花括号中插入内容而不是其他内容。你可以使用 <code>:c</code> 副词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; Q :c &#34;The \r and \n stay, but 2 + 2 = { 2 + 2 }&#34;
The \r and \n stay, but 2 + 2 = 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>To get only variable interpolation use the <code>:s</code> adverb. No other processing happens:</p>
</div>
<div class="paragraph">
<p>要只获得变量插值，请使用 <code>:s</code> 副词。没有其他处理发生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; my $name = &#39;Hamadryas&#39;
Hamadryas
&gt; Q :s &#34;\r \n { 2 + 2 } $name&#34;
\r \n { 2 + 2 } Hamadryas</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can combine adverbs to get any mix of features that you like. Cluster the adverbs or space them out. They work the same either way:</p>
</div>
<div class="paragraph">
<p>你可以组合副词来获得你喜欢的任何功能组合。聚集副词或将它们分开。他们的工作方式相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; Q :s:c &#34;\r \n { 2 + 2 } $name&#34;
\r \n 4 Hamadryas
&gt; Q :s:c:b &#34;\r \n { 2 + 2 } $name&#34;

 4 Hamadryas
&gt; Q :s :c :b &#34;\r \n { 2 + 2 } $name&#34;

 4 Hamadryas</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>:qq</code> adverb is actually the combination of <code>:s :a :h :f :c :b</code>. This interpolates all of the variables, the stuff in braces, and all backslash sequences. If you don’t want to interpolate everything, you can turn off an adverb. This might be easier than specifying several just to leave one out. Put a <code>!</code> in front of the one to disable. <code>:!c</code> turns off brace interpolation:</p>
</div>
<div class="paragraph">
<p><code>:qq</code> 副词实际上是 <code>:s :a :h :f :c :b</code> 的组合。这会插入所有变量、花括号中的内容以及所有反斜杠序列。如果你不想插入所有内容，可以关闭副词。这可能比指定几个更简单，只留下一个。放一个 <code>!</code> 在需要禁用的副词前面。 <code>:!c</code> 关闭花括号插值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">qq :!c /No { 2+2 } interpolation/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Selected quoting forms and adverbs are summarized in [Table 4-2](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch04.html#camelia-strings-TABLE-summary" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch04.html#camelia-strings-TABLE-summary</a>) and [Table 4-3](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch04.html#camelia-strings-TABLE-quoting_adverbs" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch04.html#camelia-strings-TABLE-quoting_adverbs</a>).</p>
</div>
<div class="paragraph">
<p>表4-2和表4-3总结了选定的引用形式和副词。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Short name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>｢…｣</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Literal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default delimiter, corner brackets</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Q ‘…’</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Literal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generalized quoting with alternate delimiter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Q[…]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Literal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generalized quoting with paired delimiter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>‘…’</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Escaped</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default delimiter, single quote</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>q{…}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Escaped</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Use alternate paired delimiter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Q:q […]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Escaped</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generalized quoting with <code>:q</code> adverb</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>“…”</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolated</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default delimiter, double quote</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>qq[…]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolated</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Use alternate paired delimiter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Q:qq ‘…’</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolated</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generalized quoting with <code>:qq</code> adverb</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Q:c ‘…{ }…’</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolated</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generalized quoting only interpolating closures</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Q:to(HERE)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Literal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Here doc</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>q:to(HERE)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Escaped</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Here doc</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>qq:to(HERE)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolated</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Here doc</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Short name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:x</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:exec</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute shell command and return results</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:q</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:single</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolate <code>\\</code>, <code>\qq[…]</code>, and an escaped delimiter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:qq</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:double</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolate with <code>:s</code>, <code>:a</code>, <code>:h</code>, <code>:f</code>, <code>:c</code>, <code>:b</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:s</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:scalar</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolate <code>$</code> variables</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:array</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolate <code>@</code> variables</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:h</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:hash</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolate <code>%</code> variables</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:f</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:function</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolate <code>&amp;</code> calls</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:c</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:closure</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolate code in <code>{…}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:backslash</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolate <code>\n</code>, <code>\t</code>, and others</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:to</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:heredoc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parse result as here doc terminator</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:v</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:val</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convert to allomorph if possible</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_summary_2">2.7. Summary</h3>
<div class="paragraph">
<p>The quoting slang offers several ways to represent and combine text, so you can get exactly what you need in an easy fashion. Once you have the text, you have many options for looking inside the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) to find or extract parts of it. This is still early in the book, though. You’ll see more features along the way and then really have fun in [Chapter 15](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1</a>).</p>
</div>
<div class="paragraph">
<p>引用方言提供了几种表示和组合文本的方法，因此你可以轻松地获得所需的内容。获得文本后，你可以在[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)内部查找或提取部分内容。不过，这仍然是本书的早期版本。在第15章中，你将看到更多功能，变得真正有趣。" class="bare">https://docs.raku.org/type/Str.html)内部查找或提取部分内容。不过，这仍然是本书的早期版本。在第15章中，你将看到更多功能，变得真正有趣。</a>
== 创建块</p>
</div>
<div class="paragraph">
<p>Blocks are the thingys that group multiple statements into a single thingy. You’ve already used some of them, based on the faith I asked you to have in the introduction. Now it’s time to look at those more closely. This chapter covers the basics and works up to simple subroutines. You’ll see just enough here to get you through the next cou‐ ple of chapters, then quite a bit more in Chapter 11.</p>
</div>
</div>
<div class="sect2">
<h3 id="_存储_blocks">2.8. 存储 Blocks</h3>
<div class="paragraph">
<p>你可以把 Block 存储在一个变量中而不立即执行它。now 是一个内置项, 它能够给你一个 Instant。使用 := 进行绑定让右侧和左侧一样。这意味着 $block 和 Block 相同:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $block := { now };</code></pre>
</div>
</div>
<div class="paragraph">
<p>你不能对 $block 赋值, 因为没有涉及到容器。</p>
</div>
<div class="paragraph">
<p>你本没必要绑定到 Block 的。赋值也是可以的, 并且你可以在后面更改值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $block = { now };
$block = &#39;Hamadryas&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这不是那么有趣, 因为你可以在你能使用 now 的任何地方使用它。但是计算一个 1 分钟之后的时间的 Block 怎么样？给 now 加上 60 秒：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $minute-later := { now + 60 };</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你执行 Block 的时候, 它的结果是最后一个被求值的表达式的值。使用 () 操作符执行 Block：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put $minute-later();  # some Instant
sleep 2;
put $minute-later();  # some Instant 62 seconds later</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为 $block 是一个对象, 你可以像方法那样调用 ()：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put $minute-later.();  # some Instant
sleep 2;
put $minute-later.();  # some Instant 62 seconds later</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用 callable 变量来代替标量变量；下面这些使用 &amp; 符号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;hour-later := { now + 3_600 };

put &amp;hour-later();  # some Instant
sleep 2;
put &amp;hour-later();  # some Instant an hour later</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 &amp;block 形式你可以在调用的时候不带 &amp; 符号, 甚至不带圆括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;hour-ago := { now - 3_600 };

put &amp;hour-ago();   # some Instant
sleep 2;
put hour-later();  # some Instant two seconds later

put hour-ago;      # some Instant immediately</code></pre>
</div>
</div>
<div class="paragraph">
<p>任何一种方式, Block 都不是一个子例程(即将到来的)，所以你不能使用 return（稍后将详细介绍）。它不知道怎么将结果传递给调用它的代码。下面这段代码即使不起作用，它也会编译：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $block := -&gt; { return now };</code></pre>
</div>
</div>
<div class="paragraph">
<p>你会得到一个运行时错误，你会在第十一章了解更多关于它的：</p>
</div>
<div class="paragraph">
<p>在任何例程外面尝试返回</p>
</div>
<div class="sect3">
<h4 id="_带参数的_blocks">2.8.1. 带参数的 Blocks</h4>
<div class="paragraph">
<p>签名定义了 Block 的参数。这包含了你给予 Block 在参数上的个数（参数数量），类型和约束。</p>
</div>
<div class="paragraph">
<p>如果 Block 没有签名那么它期望零个参数。然而，如果你在 Block 中使用 $_，那么它创建了一个带有单个可选参数的签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $one-arg := { put &#34;The argument was $_&#34; };

$one-arg();             # The argument was (with warning!)
$one-arg(5);            # The argument was 5
$one-arg(&#39;Hamadryas&#39;);  # The argument was Hamadryas</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你更改那个 $_，那么你就更改了原始值（如果它是可变的）因为隐式的签名让那个参数可写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $one-arg := {
    put &#34;The argument is $_&#34;;
    $_ = 5;
    };

my $var = &#39;Hamadryas&#39;;
say &#34;\$var starts as $var&#34;;
$one-arg($var);
say &#34;\$var is now $var&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出显示了 Block 更改了变量的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$var starts as Hamadryas
The argument is Hamadryas
$var is now 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你在 Block 中使用 @_，那么你可以传递零个或多个参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $many-args := {
    put &#34;The argument are @_[]&#34;;
    }

$many-args( &#39;Hamadryas&#39;, &#39;perlicus&#39; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中 @_ 是一个 Array，但是你必须等到下一章才能看到那些能做些什么。</p>
</div>
<div class="paragraph">
<p><strong>练习 5.3</strong></p>
</div>
<div class="paragraph">
<p>创建一个移除尾部空白并小写化它的参数的 Block。原始值可能更改。当你正态化数据的时候你可能想使用这些东西。</p>
</div>
<div class="sect4">
<h5 id="_隐式参数">隐式参数</h5>
<div class="paragraph">
<p>Blocks 变得更漂亮。你可以在 Block 里面使用占位符变量（或隐式参数）来指定你需要多少个参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $adding-block := { $^a + $^b }</code></pre>
</div>
</div>
<div class="paragraph">
<p>^ 表示一个占位符变量，它告诉编译器为 Block 构建一个隐式签名。你的 Blocks 拥有和占位符值同样多的参数个数并且你必须为每一个参数提供一个实参：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $adding-block := { $^a + $^b };

$adding-block();           # Nope - too few parameters
$adding-block( 1 );        # Nope - too few still
$adding-block( 1, 37 );    # Just right!
$adding-block( 1, 2, 3 );  # Nope - too many parameters</code></pre>
</div>
</div>
<div class="paragraph">
<p>参数是根据它们名字的字典顺序而不是你使用他们的顺序赋值给占位符变量的。下面的这些 Blocks 把两个数相除；不同之处在于它们使用占位符变量的顺序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $forward-division  := { $^a / $^b };
my $backward-division := { $^b / $^a };</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以用同样的参数以同样的顺序来调用它们。即使你使用相同的占位符名并且传递相同的参数，但是你得到不同的答案：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put $forward-division( 2, 3 );   # 0.66667
put $backward-division( 2 ,3 );  # 1.5</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以重用同一个占位符变量而不需要创建额外的参数。下面这个仍然是一个参数并且这个参数和自身相乘：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $square := { $^a * $^a }</code></pre>
</div>
</div>
<div class="paragraph">
<p>调用 .signature 会给你那个 Block 的 Signature 对象。使用 say 输出它会给你一个 .gist 表示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $square := { $^a * $^a }
say $square.signature;   # ($a)</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 5.4</strong></p>
</div>
<div class="paragraph">
<p>创建一个使用三个占位符变量的 Block 并计算三个数中的最大的数。 max 例程能帮到你。使用不同的参数运行这个 Block。</p>
</div>
</div>
<div class="sect4">
<h5 id="_显式签名">显式签名</h5>
<div class="paragraph">
<p>尖尖的箭头是签名的开始，在签名里面你可以指定你的参数。→ 和 { 之间什么都没有的话，那么你的签名拥有零个参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $block := -&gt; { put &#34;You called this block&#34;; };</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你调用这个 Block 的时候你不必指定参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put $block();     # No argument, so it works
put $block( 2 );  # Error - too many parameters</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 → 和 { 之间定义形参：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $block := -&gt; $a { put &#34;You called this block with $a&#34;; };</code></pre>
</div>
</div>
<div class="paragraph">
<p>签名中形参的顺序决定了实参填充的顺序。如果 $b 是第一个形参，那么它就获取第一个实参。它们的词典顺序不影响：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $block := -&gt; $b, $a { $a / $b };
put $block( 2, 3);  # 1.5
put $block( 3, 2);  # 0.666667</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些参数是位置参数。还有另外一种形式的参数，其中你能指定哪个行参得到哪个实参。这些是命名参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $block := -&gt; :$b, :$a { $a / $b };
put $block( b =&gt; 3, a =&gt; 2 );  # 0.666667
put $block( a =&gt; 3, b =&gt; 2 );  # 1.5</code></pre>
</div>
</div>
<div class="paragraph">
<p>你会在第十一章看到更多关于签名的东西，但是这些已经足够你入门了。</p>
</div>
</div>
<div class="sect4">
<h5 id="_类型约束_2">类型约束</h5>
<div class="paragraph">
<p>形参变量可以约束它们允许的类型。下面这个 Block 数值上进行俩个值相除但是它不强制你给它传数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $block := -&gt; $b, $a { $a / $b };
$block( 1, 2 );
$block( &#39;Hamadryas&#39;, &#39;perlicus&#39; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二个调用失败了：</p>
</div>
<div class="paragraph">
<p>Cannot convert string to number: base-10 number must
begin with valid digits …​</p>
</div>
<div class="paragraph">
<p>它在 Block 里面失败了。它根本就没到达代码里面。如果你正在做数值操作你应该只允许数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $block := -&gt; Numeric $b, Numeric $a { $a / $b };

put $block( 1, 2 );
put $block( &#39;Hamadryas&#39;, &#39;perlicus&#39; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个调用有效但是第二个调用尝试使用 Str 但是失败了：</p>
</div>
<div class="paragraph">
<p>2
Type check failed in binding to parameter &#39;$b&#39;;
expected Numeric but got Str (&#34;Hamadryas&#34;)</p>
</div>
<div class="paragraph">
<p>如果 Numeric 类型对你来说太宽了，选择另一种类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $block := -&gt; Int $b, Int $a { $a / $b };</code></pre>
</div>
</div>
<div class="paragraph">
<p>这仍然有个问题，尽管。那个 Int 约束允许任何智能匹配为 Int 的东西。 Int 类型对象满足这个约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$block( Int, 3 ); # 调用仍旧有效</code></pre>
</div>
</div>
<div class="paragraph">
<p>这让它通过了形参守卫然后在除法里面失败了。在类型的后面添加一个 :D 来约束参数为一个有定义的值。类型对象总是未定义的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $block := -&gt; Int:D $b, Int:D $a { $a / $b };</code></pre>
</div>
</div>
<div class="paragraph">
<p>你会在第十一章看到更多关于签名的信息。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_简单子例程">2.9. 简单子例程</h3>
<div class="paragraph">
<p>子例程是带有额外功能的代码块。代替尖尖的箭头，这里你使用 sub：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $subroutine := sub { put &#34;Called subroutine!&#34; };</code></pre>
</div>
</div>
<div class="paragraph">
<p>你以同样的方式执行它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$subroutine();</code></pre>
</div>
</div>
<div class="paragraph">
<p>子例程可以返回值（Block 不能）。调用 Sub 会计算一些值并在所调用的作用域里让你可见。</p>
</div>
<div class="paragraph">
<p>之前的 Blocks 处理了输出。从子例程里处理输出通常不是一种好形式，因为它做了两份工作：计算值然后输出。它不够灵活因为它决定了怎么处理值。返回值让你稍后决定：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $subroutine := sub { return &#34;Called subroutine!&#34; };
put $subroutine();</code></pre>
</div>
</div>
<div class="paragraph">
<p>你应该保存结果而不是输出结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result = $subroutine();</code></pre>
</div>
</div>
<div class="paragraph">
<p>return 退出最里层的例程（Sub 的超类）。如果一个 Block 在某种 Routine 之内， 你可以在那个 Block 里面使用一个 return，然后你立即执行该 Block。这会立即结束该子例程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $subroutine := sub {
    -&gt; { # not a sub!
       return &#34;Called subroutine!&#34;
    }.(); # 立即执行

    put &#39;This is unreachable and will never run&#39;;
    };

put $subroutine();   # Called subroutine!</code></pre>
</div>
</div>
<div class="paragraph">
<p>你很可能在使用 Block 的东西上使用它，例如 if 结构。所有的这些 Blocks 都能使用 return，因为它们在 Routine 之内，它知道如何处理它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $subroutine := sub {
    if now.Int %% 2 { return &#39;Even&#39; }
    else            { return &#39;Odd&#39;  }
    };

put $subroutine();</code></pre>
</div>
</div>
<div class="paragraph">
<p>do if 只需要一个 return：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $subroutine := sub {
    return do if now.Int %% 2 { &#39;Even&#39; }
              else            { &#39;Odd&#39;  }
    };

put $subroutine();</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_命名子例程">2.9.1. 命名子例程</h4>
<div class="paragraph">
<p>子例程可以拥有名字。在 sub 后面指定名字。然后你可以通过子例程的名字执行子例程，和通过它的变量执行一样。它们做同样的事情因为它们实际上是同样的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $subroutine := sub show-me { return &#34;Called subroutine!&#34; };
put $subroutine.(); # Called subroutine!
put show-me();      # Called subroutine!</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常你会把变量也一块儿跳过：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub show-me { return &#34;Called subroutine!&#34; };
put show-me();      # Called subroutine!</code></pre>
</div>
</div>
<div class="paragraph">
<p>要定义子例程的签名，把签名放在子例程名字后面的圆括号中（这和 Block 稍微有点不同）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub divide ( Int:D $a, Int:D $b ) { $a / $b }
put divide( 5, 7 );  # 0.714286</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果它不会使解析器产生歧义，你可以省略掉圆括号。这是同样的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put divide 5, 7;     # 714286</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个子例程定义是一个表达式，就像 Block 那样。如果你在闭合花括号之后还有除了末尾空格之外的其它东西，则需要分号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub divide ( Int:D $a, Int:D $b ) { $a / $b }; put divide( 5, 7 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>子例程默认是词法作用域的。如果你在 Block 里面定义一个子例程，那么它只存在于 Block 里面。外部作用域不知道 divide 的存在，所以这是错误的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    sub divide ( Int:D $a, Int:D $b ) { $a / $b }
    put divide( 5, 7 );
}

put divide( 3, 2 );  # Error!</code></pre>
</div>
</div>
<div class="paragraph">
<p>这和词法变量名拥有同样的优点：你不必知道所有其它的子例程来定义你自己的。这也意味着如果你有一个想要临时替代的子例程，你可以在你需要的作用域里创建你自己的版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub divide ( Int:D $a, Int:D $b ) { $a / $b }
put divide 1, 137;

{ # a scope for the fixed version of divide
sub divide ( Numeric $b, Numeric $a ) {
    put &#34;Calling my private divide!&#34;;
    $a / $b
    }

put divide 1.1, 137.003;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_whatever_code">2.10. Whatever Code</h3>
<div class="paragraph">
<p>这一章的目的是为了接触这个遍及语言的有趣的特性。在下面几章你会需要这个特性。</p>
</div>
<div class="paragraph">
<p><code>Whatever</code>， 也就是 *，是某个东西的替身，你会在之后填充它。填充到它里面的东西决定了它应该是什么。这儿来看看它在表达式中长什么样，让某个东西加上 2:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum = * + 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你知道这儿的 * 不是用于乘法，因为乘法需要两个操作数。所以发生了什么？编译器认出了 * 并创建了一个 WhateverCode（也叫做形实转换程序）。它是一个没有定义自己的作用域的代码段，但是不被立即执行。它最像带有一个参数的 Block：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum := { $^a + 2 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>调用带有一个参数的 WhateverCode 来获取最后的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$sum = * + 2;
put $sum( 135 );   # 137</code></pre>
</div>
</div>
<div class="paragraph">
<p>获取你想要两个参数。你可以使用两个 * 并且你的 WhateverCode 会接受两个参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum = * + *;
put $sum( 135, 2 );   # 137</code></pre>
</div>
</div>
<div class="paragraph">
<p>Whatever * 出现在很多其它有趣的结构中；这是你为什么这么早阅读本书中关于子例程的东西的原因。现在就有两个有趣的用途。</p>
</div>
<div class="sect3">
<h4 id="_subsets">2.10.1. Subsets</h4>
<div class="paragraph">
<p>WhateverCode 允许你把代码插入到语句中。你可以用它们来创建更有趣的带有 subset 和 where 的类型。首先定义一个不带约束的新类型。你告诉 subset 你想以哪个已存在的类型开始。下面创建一个和 Int 同样的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset PositiveInt of Int;
my PositiveInt $x = -5;
put $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这在运行时检查赋值。你放到 $x 中的类型必须是一个 PositiveInt，但是（目前为止）它和 Int 一样。 -5 是一个 Int 数， 所以这正常工作。</p>
</div>
<div class="paragraph">
<p>现在通过指定一个带有代码块儿的 where 子句来约束 Int 的合法值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset PositiveInt of Int where { $^a &gt; 0 };
my PositiveInt $x = -5;
put $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你给 $x 赋值时你会触发运行时类型检查。变量 $x 知道它必须是一个 PositiveInt。它接受一个可能适合 PositiveInt 的值并把它传入 where 子句中的 Block。如果那段代码计算为 True，那么变接受那个值。如果计算结果为 False，你会得到一个错误：</p>
</div>
<div class="paragraph">
<p>Type check failed in assignment to $x;
expected PositiveInt but got Int (-5)</p>
</div>
<div class="paragraph">
<p>Whatever 允许你省略一些打字。* 会为你做大部分工作。它代表你想要测试的东西。这些不是完整的类型但是表现得像它们本来的那样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset PositiveInt of Int where * &gt; 0;
my PositiveInt $x = -5;
put $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦你有了 subset，你就能在签名中使用它了。如果参数不是正整数你得到一个运行时错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset PositiveInt of Int where * &gt; 0;

sub add-numbers ( PositiveInt $n, PositiveInt $m ) {
    $n + $m
    }

put add-numbers 5, 11;    # 16
put add-numbers -5, 11;   # Error</code></pre>
</div>
</div>
<div class="paragraph">
<p>你不需要定义一个显式的 subset，尽管。你可以在签名中使用 where。当你只需要约束一次时这很有用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add-numbers ( $n where * &gt; 0, $m where * &gt; 0 ) {
    $n + $m
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>随着你继续你会看到更多的 subsets；不用很多代码来限制值，它们很方便。你还没有读到关于模块的东西，但是 Subset::Common 有几个例子，你可能会决定不错。</p>
</div>
<div class="paragraph">
<p><strong>练习 5.5</strong></p>
</div>
<div class="paragraph">
<p>使用 subset 创建一个不允许分母为零的 divide 子例程。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_3">2.11. 总结</h3>
<div class="paragraph">
<p>这一章提供了子例程简明介绍和像代码那样的东西。有简单的 Block 以组织代码并定义作用域，还有更复杂的子例程，知道怎么样回传值给它的调用者。它们中的每一个都有复杂的方式来处理参数。这一章让你了解足够的细节，所以你可以在下面几章中使用它们。你会在第十一章看到更强大的子例程特性。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_positionals">3. Positionals</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Your programming career is likely to be, at its heart, about moving and transforming ordered lists of some kind. Those might be to-do lists, shopping lists, lists of web pages, or just about anything else.</p>
</div>
<div class="paragraph">
<p>The broad term for such as list is [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>). Not everything in this chapter is strictly one of those; it’s okay to pretend that they are, though. The language easily interchanges among many of the types you’ll see in this chapter, and it’s sometimes important to keep them straight. Mind their differences and their different uses to get exactly the behavior you want.</p>
</div>
<div class="paragraph">
<p>This is the first chapter where you’ll experience the laziness of the language. Instead of computing things immediately as you specify them in your code, your program will remember it needs to do something. It then only does it if you later use it. This feature allows you to have infinite lists and sequences without actually creating them.</p>
</div>
<div class="paragraph">
<p>从本质上讲，你的编程职业可能是移动和转换某种有序列表。这些可能是待办事项列表，购物清单，网页列表或其他任何内容。</p>
</div>
<div class="paragraph">
<p>列表的广义术语是 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html)。并非本章中的所有内容都是其中之一;但是可以假装他们是。Raku" class="bare">https://docs.raku.org/type/Positional.html)。并非本章中的所有内容都是其中之一;但是可以假装他们是。Raku</a> 很容易在本章中看到的许多类型之间进行交换，有时候保持它们是正确的。注意他们的差异和他们的不同用途，以获得你想要的行为。</p>
</div>
<div class="paragraph">
<p>这是你将体验这门语言懒惰的第一章。在你的代码中指定它们时，你的程序将记住它需要做某事，而不是立即计算事物。它只会在你以后使用它时才会这样做。此功能允许你拥有无限的列表和序列，而无需实际创建它们。</p>
</div>
<div class="sect2">
<h3 id="_constructing_a_list">3.1. Constructing a List</h3>
<div class="paragraph">
<p>A [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) is an immutable series of zero or more items. The simplest [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) is the empty list. You can construct one with no arguments. The [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) as a whole is one thingy and you can store it in a scalar:</p>
</div>
<div class="paragraph">
<p>[<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) 是零个或多个项目的不可变系列。最简单的 [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) 是空列表。你可以构造一个没有参数的列表。你可以将列表作为一个整体存储在标量中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $empty-list = List.new;
put &#39;Elements: &#39;, $empty-list.elems;  # Elements: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.elems</code> method returns the number of elements, which is <code>0</code> for the empty [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>). This might seem like a trivial result, but imagine those cases where you want to return no results: an empty [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) can be just as meaningful as a nonempty one.</p>
</div>
<div class="paragraph">
<p>Instead of the call to <code>.new</code>, you can use empty parentheses to do the same thing. Normally parentheses simply group items, but this is special syntax:</p>
</div>
<div class="paragraph">
<p><code>.elems</code> 方法返回元素的个数，对于空列表，它返回 <code>0</code>。可能这看起来像一个微不足道的结果，但想象一下你想要返回没有结果的那些情况：一个空的列表可以和非空列表一样有意义。</p>
</div>
<div class="paragraph">
<p>你可以使用空括号来执行相同的操作，而不是调用 <code>.new</code>。通常括号只是对项目进行分组，但这是特殊的语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $empty-list = (); # Also the empty List</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s also a special object for that. <code>Empty</code> clearly shows your intent:</p>
</div>
<div class="paragraph">
<p>还有一个特殊的对象。<code>Empty</code> 显示你的意图：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $empty-list = Empty;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can specify elements in <code>.new</code> by separating the elements with commas. Both the colon and parentheses forms work:</p>
</div>
<div class="paragraph">
<p>你可以通过用逗号分隔元素来指定 <code>.new</code> 中的元素。冒号和括号形式都有用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly-genus = List.new:
    &#39;Hamadryas&#39;, &#39;Sostrata&#39;, &#39;Junonia&#39;;

my $butterfly-genus = List.new(
    &#39;Hamadryas&#39;, &#39;Sostrata&#39;, &#39;Junonia&#39;
    );</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You cannot make an empty [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) with <code>$()</code>: that’s just <code>Nil</code>.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>The <code>$(…​)</code> with a list inside also constructs a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>). The <code>$</code> indicates that it is an item. This one happens to be a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) object. You can check the number of elements in it with <code>.elems</code>:</p>
</div>
<div class="paragraph">
<p>你不能用 <code>$()</code> 创建一个空列表：那只是 <code>Nil</code>。</p>
</div>
<div class="paragraph">
<p>带有列表的 <code>$(…​)</code> 也构造了一个列表。 <code>$</code> 表示它是一个项。这恰好是一个 [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) 对象。你可以使用 <code>.elems</code> 检查其中的元素数量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly-genus = $(&#39;Hamadryas&#39;, &#39;Sostrata&#39;, &#39;Junonia&#39;);
put $butterfly-genus.elems;     # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or you can leave off the <code>$</code> in front of the parentheses. You still need the grouping parentheses because item assignment is higher precedence than the comma:</p>
</div>
<div class="paragraph">
<p>或者你可以去掉括号前留下的 <code>$</code>。你仍然需要分组括号，因为项赋值的优先级高于逗号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly-genus = (&#39;Hamadryas&#39;, &#39;Sostrata&#39;, &#39;Junonia&#39;);
put $butterfly-genus.elems;     # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>A container can be an element in a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>). When you change the value in the container it looks like the [<code>List</code>](<a href="https://docs.raku.org/type/List.html)changes" class="bare">https://docs.raku.org/type/List.html)changes</a>, but it doesn’t actually change because the container is the [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) item and that container itself was still the [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) item:</p>
</div>
<div class="paragraph">
<p>列表中的元素可以是容器。当你更改容器中的值时，看起来像是列表更改了，但它实际上没有更改，因为容器是列表项，并且该容器本身仍然是列表项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = &#39;Hamadryas perlicus&#39;;
my $butterflies = ( $name, &#39;Sostrata&#39;, &#39;Junonia&#39; );
put $butterflies; # (Hamadryas perlicus Sostrata Junonia)

$name = &#39;Hamadryas&#39;;
put $butterflies; # (Hamadryas Sostrata Junonia)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You don’t need the named variable, though. You can use an anonymous scalar container as a placeholder that you’ll fill in later. Since it has no value (or even a type), it’s an [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>) type object:</p>
</div>
<div class="paragraph">
<p>但是，你不需要命名变量。你可以使用匿名标量容器作为占位符，稍后你将填写。由于它没有值（甚至是类型），因此它是一个Any类型的对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterflies = ( $, &#39;Sostrata&#39;, &#39;Junonia&#39; );
put $butterflies; # ((Any) Sostrata Junonia)</code></pre>
</div>
</div>
<div class="paragraph">
<p>All of this quoting and comma separating is a bit tedious, but there’s a shortcut. You can quote a list with <code>qw</code>. It creates items by breaking the text apart by whitespace. This makes a three-element [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>):</p>
</div>
<div class="paragraph">
<p>所有这些引用和逗号分离有点单调乏味，但有一条捷径。你可以用 <code>qw</code> 引起列表。它通过用空格分隔文本来创建项目。这使得三元素列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly-genus = qw&lt;Hamadryas Sostrata Junonia&gt;;
put &#39;Elements: &#39;, $butterfly-genus.elems;  # Elements: 3</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>qw</code> is another form of the generalized quoting you saw in [Chapter 4](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch04.html#camelia-strings" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch04.html#camelia-strings</a>). It uses the <code>:w</code> adverb and returns a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>). You won’t see this form much, but it’s what you’re doing here:</p>
</div>
<div class="paragraph">
<p><code>qw`是你在第4章中看到的另一种形式的广义引用。它使用 `:w</code> 副词并返回一个[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)。你不会看到这个形式太多，但这是你在这里做的：" class="bare">https://docs.raku.org/type/List.html)。你不会看到这个形式太多，但这是你在这里做的：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly-genus = Q :w/Hamadryas Sostrata Junonia/</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s still too much work. You can enclose the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> in angle brackets and leave out the item quoting and the separating commas. This acts the same as <code>qw</code>:</p>
</div>
<div class="paragraph">
<p>那仍然是太多的工作。你可以将[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)括在尖括号中，并省略每项的引号和逗号分隔符。这与" class="bare">https://docs.raku.org/type/Str.html)括在尖括号中，并省略每项的引号和逗号分隔符。这与</a> <code>qw</code> 相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly-genus = &lt;Hamadryas Sostrata Junonia&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>&lt;&gt;</code> only works if you don’t have whitespace inside your [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a>. This gives you four elements because the space between <code>&#39;Hamadryas</code> and <code>perlicus&#39;</code> separates them:</p>
</div>
<div class="paragraph">
<p>只有在[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)中没有空格时，" class="bare">https://docs.raku.org/type/Str.html)中没有空格时，</a><code>&lt;&gt;</code> 才有效。这给你四个元素，因为 <code>&#39;Hamadryas</code> 和 <code>perlicus&#39;</code> 之间的空格将它们分开：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterflies = &lt; &#39;Hamadryas perlicus&#39; Sostrata Junonia &gt;;
put &#39;Elements: &#39;, $butterflies.elems;  # Elements: 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku has thought of that too and provides a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) quoting mechanism with quote protection. The <code>&lt;&lt;&gt;&gt;</code> keeps the thingy in quotes as one item even though it has whitespace in it:</p>
</div>
<div class="paragraph">
<p>Raku 也考虑过这一点并提供带引号保护的[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)引用机制。" class="bare">https://docs.raku.org/type/List.html)引用机制。</a> <code>&lt;&lt;&gt;&gt;</code> 将引号中的东西保持为一个项，即使它里面有空格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterflies = &lt;&lt; &#39;Hamadryas perlicus&#39; Sostrata Junonia &gt;&gt;;
put &#39;Elements: &#39;, $butterflies.elems;  # Elements: 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the <code>&lt;&lt;&gt;&gt;</code> you can interpolate a variable. After that the value of the variable is an item but isn’t linked to the original variable:</p>
</div>
<div class="paragraph">
<p>使用 <code>&lt;&lt;&gt;&gt;</code> 可以插入变量。之后，变量的值是一个项，但没有链接到原始变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = &#39;Hamadryas perlicus&#39;;
my $butterflies = &lt;&lt; $name Sostrata Junonia &gt;&gt;;
say $butterflies;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of <code>&lt;&lt;&gt;&gt;</code>, you can use the fancier quoting with the single-character <code>«»</code> version (double angle quotes). These are sometimes called French quotes:</p>
</div>
<div class="paragraph">
<p>你可以使用单字符 <code>«»</code> 版本（双角引号）的更好看的引号代替 <code>&lt;&lt;&gt;&gt;</code>。这些有时被称为法语引号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterflies = « $name Sostrata Junonia »;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both of these quote-protecting forms are the same as the <code>:ww</code> adverb for <code>Q</code>:</p>
</div>
<div class="paragraph">
<p>这两个引号保护形式都与 <code>Q</code> 的 <code>:ww</code> 副词相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterflies = Q :ww/ &#39;Hamadryas perlicus&#39; Sostrata Junonia /;
put &#39;Elements: &#39;, $butterflies.elems;  # Elements: 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes you want a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) where all the elements are the same. The <code>xx</code> list replication operator does that for you:</p>
</div>
<div class="paragraph">
<p>有时你需要一个[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)，其中所有元素都相同。" class="bare">https://docs.raku.org/type/List.html)，其中所有元素都相同。</a> <code>xx</code> 列表复制操作符为你执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $counts = 0 xx 5; # ( 0, 0, 0, 0, 0 )</code></pre>
</div>
</div>
<div class="paragraph">
<p>A [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) interpolates into a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) like any other scalar variable:</p>
</div>
<div class="paragraph">
<p>[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)像任何其他标量变量一样插入到"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)中：" class="bare">https://docs.raku.org/type/Str.html)中：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterflies = &lt;&lt; &#39;Hamadryas perlicus&#39; Sostrata Junonia &gt;&gt;;
put &#34;Butterflies are: $butterflies&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) stringifies by putting spaces between its elements. You can’t tell where one element stops and the next starts:</p>
</div>
<div class="paragraph">
<p>[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)通过在其元素之间放置空格来进行字符串化。你无法分辨元素停止的位置和下一个元素的开始：" class="bare">https://docs.raku.org/type/List.html)通过在其元素之间放置空格来进行字符串化。你无法分辨元素停止的位置和下一个元素的开始：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Butterflies are: Hamadryas perlicus Sostrata Junonia</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.join</code> method allows you to choose what goes between the elements:</p>
</div>
<div class="paragraph">
<p><code>.join</code> 方法允许你选择元素之间的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterflies = &lt;&lt; &#39;Hamadryas perlicus&#39; Sostrata Junonia &gt;&gt;;
put &#34;Butterflies are: &#34;, $butterflies.join: &#39;, &#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the output has commas between the elements:</p>
</div>
<div class="paragraph">
<p>现在输出元素之间有逗号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Butterflies are: Hamadryas perlicus, Sostrata, Junonia</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can combine both of these, which makes it easier to also surround the [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) items with characters to set them off from the rest of the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>):</p>
</div>
<div class="paragraph">
<p>你可以将这两者结合起来，这样可以更容易地使用字符围绕[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)项，以便将它们与"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)的其余部分相关联：" class="bare">https://docs.raku.org/type/Str.html)的其余部分相关联：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterflies = &lt;&lt; &#39;Hamadryas perlicus&#39; Sostrata Junonia &gt;&gt;;
put &#34;Butterflies are: /{$butterflies.join: &#39;, &#39;}/&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you needed to parse this [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) in some other program you’d know to grab the elements between the slashes:</p>
</div>
<div class="paragraph">
<p>如果你需要在其他程序中解析这个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)你知道要抓取斜杠之间的元素：" class="bare">https://docs.raku.org/type/Str.html)你知道要抓取斜杠之间的元素：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Butterflies are: /Hamadryas perlicus, Sostrata, Junonia/</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 6.1Write a program that takes two arguments. The first is a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) and the second is the number of times to repeat it. Use <code>xx</code> and <code>.join</code> to output the text that number of times on separate lines.</p>
</div>
<div class="paragraph">
<p>练习6.1 编写一个带有两个参数的程序。第一个是[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)，第二个是重复它的次数。使用" class="bare">https://docs.raku.org/type/Str.html)，第二个是重复它的次数。使用</a> <code>xx</code> 和 <code>.join</code> 在单独的行上输出该次数的文本。</p>
</div>
<div class="sect3">
<h4 id="_iterating_all_the_elements">3.1.1. Iterating All the Elements</h4>
<div class="paragraph">
<p>Iteration is the repetition of a set of operations for each element of a collection. The <code>for</code> control structure iterates through each element of a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) and runs its [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) once for each element as the topic. You can use the <code>.List</code> method to treat the one thing in your scalar variable (your [<code>List</code>](<a href="https://docs.raku.org/type/List.html)" class="bare">https://docs.raku.org/type/List.html)</a>) as its individual elements:</p>
</div>
<div class="paragraph">
<p>迭代是对集合的每个元素重复一组操作。 <code>for</code> 控制结构遍历[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)的每个元素，并为每个元素作为主题运行一次"><code>Block</code></a>(<a href="https://docs.raku.org/type/Block.html)。你可以使用" class="bare">https://docs.raku.org/type/Block.html)。你可以使用</a> <code>.List</code> 方法将标量变量（[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)）中的一个元素视为其各个元素：" class="bare">https://docs.raku.org/type/List.html)）中的一个元素视为其各个元素：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $butterfly-genus.List {
    put &#34;Found genus $_&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You get one line per element:</p>
</div>
<div class="paragraph">
<p>每个元素得到一行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Found genus Hamadryas
Found genus Sostrata
Found genus Junonia</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although I tend to call these things [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html)s" class="bare">https://docs.raku.org/type/Positional.html)s</a> there is actually a separate role for [<code>Iterable</code>](<a href="https://docs.raku.org/type/Iterable.html)s" class="bare">https://docs.raku.org/type/Iterable.html)s</a> that does the magic to make <code>for</code> work. The [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html)s" class="bare">https://docs.raku.org/type/Positional.html)s</a> I present in this book also do the [<code>Iterable</code>](<a href="https://docs.raku.org/type/Iterable.html" class="bare">https://docs.raku.org/type/Iterable.html</a>) role, so I don’t distinguish them even though I’m strictly wrong.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Calling <code>.List</code> is a bit annoying though, so there’s a shortcut for it. Prefix the variable with <code>@</code> to do the same thing:</p>
</div>
<div class="paragraph">
<p>虽然我倾向于将这些东西称为“[<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html)”，但"><code>Iterable</code></a>(<a href="https://docs.raku.org/type/Iterable.html)实际上有一个单独的角色可以为工作带来魔力。我在本书中提出的定位也做了"><code>Iterable</code></a>(<a href="https://docs.raku.org/type/Iterable.html)角色，所以即使我严重错误，我也不区分它们。" class="bare">https://docs.raku.org/type/Iterable.html)角色，所以即使我严重错误，我也不区分它们。</a></p>
</div>
<div class="paragraph">
<p>调用 <code>.List</code> 虽然有点烦人，所以有一个快捷方式。使用 <code>@</code> 前缀变量来执行相同的操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @$butterfly-genus {
    put &#34;Found genus $_&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Skip the <code>$</code> sigil altogether and use the <code>@</code> sigil to store a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) in a variable:</p>
</div>
<div class="paragraph">
<p>完全跳过 <code>$</code> sigil并使用 <code>@</code> sigil 将 [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) 存储在变量中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @butterfly-genus = (&#39;Hamadryas&#39;, &#39;Sostrata&#39;, &#39;Junonia&#39;);

for @butterfly-genus {
    put &#34;Found genus $_&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is actually different from the item assignment you’ve seen before. It’s a list assignment where the <code>=</code> operator has a lower precedence:</p>
</div>
<div class="paragraph">
<p>这实际上与你之前看到的项赋值不同。这是一个列表赋值，其中 <code>=</code> 运算符的优先级较低：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @butterfly-genus = &#39;Hamadryas&#39;, &#39;Sostrata&#39;, &#39;Junonia&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Why would you choose <code>$</code> or <code>@</code>? Assigning to <code>$butterfly-genus</code> gives you a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) and all the restrictions of that type. You can’t add or remove elements. You can change the values inside a container but not the container itself. What do you get when you assign this way?</p>
</div>
<div class="paragraph">
<p>你为什么选择 <code>$</code> 或 <code>@</code>? 赋值给` $butterfly-genus` 会给你一个[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)以及该类型的所有限制。你无法添加或删除元素。你可以更改容器内的值，但不能更改容器本身。当你指定这种方式时你会得到什么？" class="bare">https://docs.raku.org/type/List.html)以及该类型的所有限制。你无法添加或删除元素。你可以更改容器内的值，但不能更改容器本身。当你指定这种方式时你会得到什么？</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @butterfly-genus = &#39;Hamadryas&#39;, &#39;Sostrata&#39;, &#39;Junonia&#39;;
put @butterfly-genus.^name;  # Array</code></pre>
</div>
</div>
<div class="paragraph">
<p>You get an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>), which you’ll see more of later in this chapter. An [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) relaxes all those restrictions. It allows you to add and remove elements and change values. Choose the type that does what you want. If you want the data to stay the same, choose the one that can’t change.</p>
</div>
<div class="paragraph">
<p>This looks a little better with interpolation, which means you’re less likely to forget explicit whitespace around words:</p>
</div>
<div class="paragraph">
<p>你得到一个[<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)，你将在本章后面看到更多。"><code>数组</code></a>(<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) 放宽了所有这些限制。它允许你添加和删除元素并更改值。选择满足你需求的类型。如果你希望数据保持不变，请选择无法更改的数据。</p>
</div>
<div class="paragraph">
<p>插值看起来好一点，这意味着你不太可能忘记单词周围的显式空格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @butterfly-genus {
    put &#34;$_ has {.chars} characters&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You’ll often want to give your variable a meaningful name. You can use a pointy [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) to name your parameter instead of using the topic variable, <code>$_</code>:</p>
</div>
<div class="paragraph">
<p>你经常希望为变量赋予有意义的名称。你可以使用尖头[<code>块</code>](<a href="https://docs.raku.org/type/Block.html)来命名参数，而不是使用主题变量" class="bare">https://docs.raku.org/type/Block.html)来命名参数，而不是使用主题变量</a> <code>$_</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @butterfly-genus -&gt; $genus {
    put &#34;$genus has {$genus.chars} characters&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That looks a lot like the definition of a subroutine with <code>→ { …​ }</code>, because that’s what it is. That parameter is lexical to that [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) just as it would be in a subroutine.</p>
</div>
<div class="paragraph">
<p>If your [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) has more than one parameter, then the <code>for</code> takes as many elements as it needs to fill in all of them. This goes through the [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) by twos:</p>
</div>
<div class="paragraph">
<p>这看起来很像是带有 <code>→ { …​ }</code> 的子程序的定义，因为它就是它的本质。该参数对于该[<code>块</code>](<a href="https://docs.raku.org/type/Block.html)是词法的，就像它在子例程中一样。" class="bare">https://docs.raku.org/type/Block.html)是词法的，就像它在子例程中一样。</a></p>
</div>
<div class="paragraph">
<p>如果你的[<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)有多个参数，那么" class="bare">https://docs.raku.org/type/Block.html)有多个参数，那么</a> <code>for</code> 需要尽可能多的元素来填充所有这些参数。这每俩个元素遍历[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)：" class="bare">https://docs.raku.org/type/List.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @list = &lt;1 2 3 4 5 6 7 8&gt;;

for @list -&gt; $a, $b {
    put &#34;Got $a and $b&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each iteration of the [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) takes two elements:</p>
</div>
<div class="paragraph">
<p>[<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) 的每次迭代都接收两个元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Got 1 and 2
Got 3 and 4
Got 5 and 6
Got 7 and 8</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ensure that you have enough elements to fill all of the parameters or you’ll get an error. Try that bit of code with one less element to see what happens!</p>
</div>
<div class="paragraph">
<p>You can use placeholder variables in your [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>), but in that case you don’t want to use a pointy [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>), which would already create a signature for you. Using placeholder variables also works:</p>
</div>
<div class="paragraph">
<p>确保你有足够的元素来填充所有参数，否则你将收到错误。用少一个元素尝试那些代码来看看会发生什么！</p>
</div>
<div class="paragraph">
<p>你可以在块中使用占位符变量，但在这种情况下，你不希望使用尖头块，这会为你创建签名。使用占位符变量也有效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @list = &lt;1 2 3 4 5 6 7 8&gt;;

for @list {
    put &#34;Got $^a and $^b&#34;;
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_reading_lines_of_input">READING LINES OF INPUT</h5>
<div class="paragraph">
<p>The <code>lines</code> routine reads lines of input from the files you specify on the command line, or from standard input if you don’t specify any. You’ll read more about this in [Chapter 8](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch08.html#camelia-files" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch08.html#camelia-files</a>) but it’s immediately useful with <code>for</code>:</p>
</div>
<div class="paragraph">
<p><code>lines</code> 例程从你在命令行中指定的文件中读取输入行，如果未指定任何文件，则从标准输入读取。你将在第8章中详细了解这一点，但它对以下内容非常有用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for lines() {
    put &#34;Got line $_&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your programs reads and reoutputs all of the lines from all of the files. The line ending was autochomped; it was automatically stripped from the value because that’s probably what you wanted. The <code>put</code> adds a line ending for you:</p>
</div>
<div class="paragraph">
<p>你的程序会读取并重新输出所有文件中的所有行。换行符是自动切除的;它会自动从值中删除，因为这可能是你想要的。 <code>put</code> 为你添加换行符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku your-program.p6 file1.txt file2.txt
Got line ...
Got line ...
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>You need those parentheses even without an argument. The <code>lines</code> routine can take an argument that tells it how many lines to grab:</p>
</div>
<div class="paragraph">
<p>即使没有参数，你也需要这些圆括号。<code>lines</code> 例程可以接收一个参数来告诉它要抓取多少行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for lines(17) {
    put &#34;Got line $_&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can break the lines into “words.” This takes a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) (or something that can turn into a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)" class="bare">https://docs.raku.org/type/Str.html)</a>) and gives you back the nonwhitespace chunks as separate elements:</p>
</div>
<div class="paragraph">
<p>你可以将这些行分解成“单词”。这接收一个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) （或者可以变成[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)的东西），并将非空白块作为单独的元素返回：" class="bare">https://docs.raku.org/type/Str.html)的东西），并将非空白块作为单独的元素返回：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;Hamadryas perlicus sixus&#34;.words; # (Hamadryas perlicus sixus)
put &#34;Hamadryas perlicus sixus&#34;.words.elems; # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Combine this with <code>lines</code> to iterate one word at a time:</p>
</div>
<div class="paragraph">
<p>将其与 <code>lines</code> 组合以一次迭代一个单词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for lines.words { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.comb</code> method takes it one step further by breaking it into characters:</p>
</div>
<div class="paragraph">
<p><code>.comb</code> 方法通过将其分解为字符更进一步：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for lines.comb { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You’ll see more about <code>.comb</code> in [Chapter 16](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch16.html#camelia-regex2" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch16.html#camelia-regex2</a>), where you’ll learn how to tell it to divide up the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>).</p>
</div>
<div class="paragraph">
<p>With those three things you can implement your own <strong>wc</strong> program:</p>
</div>
<div class="paragraph">
<p>你将在第16章中看到更多关于 <code>.comb</code> 的内容，在那里你将学习如何划分[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)。" class="bare">https://docs.raku.org/type/Str.html)。</a></p>
</div>
<div class="paragraph">
<p>有了这三个东西你可以实现自己的 <strong>wc</strong> 程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for lines() {
    state $lines = 0;
    state $words = 0;
    state $chars = 0;
    $lines++;
    $words += .words;
    $chars += .comb;
    LAST {
        put &#34;lines: $lines\nwords: $words\nchars: $chars&#34;;
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The character count with this version doesn’t count all of the characters because the line ending was automatically removed.</p>
</div>
<div class="paragraph">
<p>EXERCISE 6.2Read the lines from the files you specify on the command line. Output each line prefixed by the line number. At the end of each line show the number of “words” in the line.</p>
</div>
<div class="paragraph">
<p>EXERCISE 6.3Output all of the lines of the butterfly census file (from [<strong><a href="https://www.learningraku.com/downloads/" class="bare">https://www.learningraku.com/downloads/</a></strong>](<a href="https://www.learningraku.com/downloads/)" class="bare">https://www.learningraku.com/downloads/)</a>) that contain the genus <strong>Pyrrhogyra</strong>. How many lines did you find? If you don’t want to use that file try something else you have lying around.</p>
</div>
<div class="paragraph">
<p>此版本的字符计数不会计算所有字符，因为换行符会自动删除。</p>
</div>
<div class="paragraph">
<p>练习6.2 从命令行中指定的文件中读取行。输出以行号为前缀的每一行。在每行的末尾显示行中“单词”的数量。</p>
</div>
<div class="paragraph">
<p>练习6.3 输出包含 <strong>Pyrrhogyra</strong> 属的蝴蝶人口普查文件（来自https://www.learningraku.com/downloads/）的所有行。你找到了多少行？如果你不想使用该文件，请尝试其他的东西。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ranges">3.2. Ranges</h3>
<div class="paragraph">
<p>A [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) specifies the inclusive bounds of possible values without creating all of the items that would be in that [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>). A [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) can be infinite because it doesn’t create all the elements; a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) would take up all your memory.</p>
</div>
<div class="paragraph">
<p>Create a [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) with <code>..</code> and your bounds on either side:</p>
</div>
<div class="paragraph">
<p>[<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) 指定可能值的包含范围，而不创建该列表中的所有项。[<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) 可以是无限的，因为它不会创建所有元素;[<code>列表</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) 会占用你所有的内存。</p>
</div>
<div class="paragraph">
<p>使用 <code>..</code> 创建一个 [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html)，并在两边创建边界：" class="bare">https://docs.raku.org/type/Range.html)，并在两边创建边界：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $digit-range =   0 .. 10;
my $alpha-range = &#39;a&#39; .. &#39;f&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the lefthand value is larger than the righthand value you still get a [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>), but it will have no elements and you won’t get a warning:</p>
</div>
<div class="paragraph">
<p>如果左手值大于右手值，你仍然得到一个 [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html)，但它没有元素，你不会收到警告：" class="bare">https://docs.raku.org/type/Range.html)，但它没有元素，你不会收到警告：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $digit-range = 10 .. 0;
put $digit.elems; # 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can exclude one or both endpoints with <code>^</code> on the appropriate side of the <code>..</code> operator. Some people call thesethe cat ears:</p>
</div>
<div class="paragraph">
<p>你可以在 <code>..</code> 运算符的适当一侧使用 <code>^</code> 排除一个或两个端点。有人称这些是猫耳朵：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $digit-range = 0 ^..  10;  # exclude  0        ( 1..10 )
my $digit-range = 0  ..^ 10;  # exclude 10        ( 0..9  )
my $digit-range = 0 ^..^ 10;  # exclude  0 and 10 ( 1..9  )</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a shortcut for a numeric range starting from 0, use the <code>^</code> and the upper (exclusive) bound. This is very common Raku code:</p>
</div>
<div class="paragraph">
<p>作为从 0 开始的数字范围的快捷方式，使用 <code>^</code> 和上限（不包括）。这是非常常见的 Raku 代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $digit-range = ^10; # Same as 0 ..^ 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>This gives you the values <code>0</code> to <code>9</code>, which is 10 values altogether even though <code>10</code> is not part of the range.</p>
</div>
<div class="paragraph">
<p>EXERCISE 6.4How many items are in the range from <code>&#39;aa&#39;</code> to <code>&#39;zz&#39;</code>? How many from <code>&#39;a&#39;</code> to <code>&#39;zz&#39;</code>?</p>
</div>
<div class="paragraph">
<p>A [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) knows its bounds. To see all of the values it would produce you can use <code>.List</code> to turn it into a list. Be aware that if your [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) is very large you might suddenly hog most of the memory on your system, so this isn’t something you’d normally want to do. It’s nice for debugging though:</p>
</div>
<div class="paragraph">
<p>这将为你提供值 <code>0</code> 到 <code>9</code>，即使 <code>10</code> 不是 [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) 的一部分，也是 <code>10</code> 个值。</p>
</div>
<div class="paragraph">
<p>练习6.4 <code>&#39;aa&#39;</code> 到 <code>&#39;zz&#39;</code> [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html)内有多少项？从" class="bare">https://docs.raku.org/type/Range.html)内有多少项？从</a> <code>&#39;a&#39;</code> 到 <code>&#39;zz&#39;</code> 有多少？</p>
</div>
<div class="paragraph">
<p>[<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) 知道它的界限。要查看它将生成的所有值，你可以使用 <code>.List</code> 将其转换为列表。请注意，如果你的[<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) 非常大，你可能会突然占用系统上的大部分内存，因此这通常不是你想要做的事情。虽然调试很好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; my $range = &#39;a&#39; .. &#39;f&#39;;
&#34;a&#34;..&#34;f&#34;
&gt; $range.elems
6
&gt; $range.List
(a b c d e f)</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 6.5Show all of the spreadsheet cell addresses from <code>B5</code> to <code>F9</code>.</p>
</div>
<div class="paragraph">
<p>A smart match against a [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) checks if a value is between the [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html)’s" class="bare">https://docs.raku.org/type/Range.html)’s</a> bounds:</p>
</div>
<div class="paragraph">
<p>练习6.5 显示从 <code>B5</code> 到 <code>F9</code> 的所有电子表格单元格地址。</p>
</div>
<div class="paragraph">
<p>针对 [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) 的智能匹配检查值是否在 [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) 的边界之间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 7 ~~ 0..10
True
&gt; 11 ~~ ^10
False</code></pre>
</div>
</div>
<div class="paragraph">
<p>A [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) isn’t a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>), though. Any value between the bounds is part of the [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>), even if it’s not a value that you would get if you listified the [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>):</p>
</div>
<div class="paragraph">
<p>但是，[<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) 不是[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)。边界之间的任何值都是"><code>Range</code></a>(<a href="https://docs.raku.org/type/Range.html)的一部分，即使它不是你为"><code>Range</code></a>(<a href="https://docs.raku.org/type/Range.html)列表化时得到的值：" class="bare">https://docs.raku.org/type/Range.html)列表化时得到的值：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 1.37 ~~ 0..10
True
&gt; 9.999 ~~ 0..10
True
&gt; -137 ~~ -Inf..Inf # infinite range!
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>Excluding the endpoint doesn’t mean that the last element is the next-lowest integer. Here, it’s the exact value <code>10</code> that’s excluded; everything positive and less than <code>10</code> is still in the [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>):</p>
</div>
<div class="paragraph">
<p>排除端点并不意味着最后一个元素是下一个最小的整数。在这里，它被排除在外的确切值 <code>10</code>;一切积极且小于 <code>10</code> 的东西仍然在范围内：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; 9.999 ~~ ^10
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is quite different from the listified version!</p>
</div>
<div class="paragraph">
<p>这与listified版本完全不同！</p>
</div>
<div class="sect3">
<h4 id="_the_coercer">3.2.1. The @ Coercer</h4>
<div class="paragraph">
<p>A [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) isn’t a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>). In some situations it acts like separate elements instead of merely bounds but in others it maintains its rangeness. Usually that works because something implicitly coerces it for you.</p>
</div>
<div class="paragraph">
<p>Start with a [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>). Output it using <code>put</code> and <code>say</code>. These show you different representations because their text representations of the object are different: <code>put</code> uses <code>.Str</code> and <code>say</code> uses <code>.gist</code>:</p>
</div>
<div class="paragraph">
<p>[<code>Range</code>](<a href="https://docs.raku.org/type/Range.html)不是"><code>列表</code></a>(<a href="https://docs.raku.org/type/List.html)。在某些情况下，它的作用类似于单独的元素，而不仅仅是边界，但在其他情况下，它保持其范围。通常这是有效的，因为某些内容会暗中强转它。" class="bare">https://docs.raku.org/type/List.html)。在某些情况下，它的作用类似于单独的元素，而不仅仅是边界，但在其他情况下，它保持其范围。通常这是有效的，因为某些内容会暗中强转它。</a></p>
</div>
<div class="paragraph">
<p>从 [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) 开始。用 <code>put</code> 和 <code>say</code> 输出它。这些显示了不同的表示形式，因为它们的对象的文本表示是不同的：<code>put</code> 使用 <code>.Str</code>， <code>say</code> 使用 <code>.gist</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $range = 0..3;
put $range.^name; # Range
say $range;       # 0..3
put $range;       # 0 1 2 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>This distinction in the representation of the object is important. When you see <code>say</code> in this book it’s because I want to show you <code>.gist</code> because that’s closer to a summary of the object.</p>
</div>
<div class="paragraph">
<p>You can make that a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) by coercing it with the <code>.List</code> method:</p>
</div>
<div class="paragraph">
<p>这种对象表示的区别很重要。当你看到本书中的说法时，这是因为我想向你展示 <code>.gist</code>，因为它更接近于对象的摘要。</p>
</div>
<div class="paragraph">
<p>你可以通过使用 <code>.List</code> 方法强制它来创建 [<code>列表</code>](<a href="https://docs.raku.org/type/List.html)：" class="bare">https://docs.raku.org/type/List.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list = $range.List;
put $list.^name; # List
say $list;       # (0 1 2 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which one of these you have matters. A [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) works differently in a smart match because the element must be part of the [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>):</p>
</div>
<div class="paragraph">
<p>你有哪些重要事项。 [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) 在智能匹配中的工作方式不同，因为该元素必须是[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)的一部分：" class="bare">https://docs.raku.org/type/List.html)的一部分：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;In range? &#34;, 2.5 ~~ $range;  # True
put &#34;In list? &#34;, 2.5  ~~ $list;   # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of typing <code>.List</code> everywhere that you want something treated as such, you can use the prefix list context operator, <code>@</code>, just like you’ve seen with the context operators <code>+</code> and <code>~</code>:</p>
</div>
<div class="paragraph">
<p>你可以使用前缀列表上下文运算符 <code>@</code>，而不是在你想要的上下文运算符 <code>+</code> 和 <code>~</code> 中使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $range = 0..3;

put &#34;In range? &#34;,  2.5 ~~ $range;       # True (Range object)
put &#34;In .List? &#34;,  2.5 ~~ $range.List;  # False (List object)
put &#34;In @?     &#34;,  2.5 ~~ @$range;      # False (List object)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Later you’ll use the <code>@</code> sigil for [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) variables. For now it’s a convenient way to treat something like a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>).</p>
</div>
<div class="paragraph">
<p>稍后你将对[<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)变量使用" class="bare">https://docs.raku.org/type/Array.html)变量使用</a> <code>@</code> sigil。现在，它是一种方便的方式来处理像[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)这样的东西。" class="bare">https://docs.raku.org/type/List.html)这样的东西。</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sequences">3.3. Sequences</h3>
<div class="paragraph">
<p>A sequence, [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>), knows how to make a future [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>). It’s similar to a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) but it’s lazy. It knows where its values will come from and defers producing them until you actually need them.</p>
</div>
<div class="paragraph">
<p>序列 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 知道如何创建未来的 [<code>List</code>](<a href="https://docs.raku.org/type/List.html)。它类似于" class="bare">https://docs.raku.org/type/List.html)。它类似于</a> [<code>List</code>](<a href="https://docs.raku.org/type/List.html)，但它很惰性的。它知道它的值来自哪里，并推迟生产它们，直到你真正需要它们为止。" class="bare">https://docs.raku.org/type/List.html)，但它很惰性的。它知道它的值来自哪里，并推迟生产它们，直到你真正需要它们为止。</a></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) isn’t really a [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) but it has a way to fake it. Rather than explain that I’m going to fake it too.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>You call <code>.reverse</code> on a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) to flip the list around. When you call [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) methods it just works:</p>
</div>
<div class="paragraph">
<p>[<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 不是真正的 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) ，但它有办法伪造它。多说无意，我也会伪造它。</p>
</div>
<div class="paragraph">
<p>你在列表上调用 <code>.reverse</code> 来翻转列表。当你调用[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)方法时，它只是起作用：" class="bare">https://docs.raku.org/type/List.html)方法时，它只是起作用：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $countdown = &lt;1 2 3 4 5&gt;.reverse;
put $countdown.^name; # Seq
put $countdown.elems; # 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result isn’t actually a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>), but in most common cases that isn’t important. The things that try to use it as a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) will get what they expect, and there’s no immediate need to create another [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) when the [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) knows the values from the original one.</p>
</div>
<div class="paragraph">
<p>However, calling <code>.eager</code> converts the [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) to a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>):</p>
</div>
<div class="paragraph">
<p>结果实际上不是 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html)，但在大多数常见情况下并不重要。尝试将其用作"><code>列表</code></a>(<a href="https://docs.raku.org/type/List.html)的东西将获得他们期望的东西，并且当"><code>Seq</code></a>(<a href="https://docs.raku.org/type/Seq.html)知道原始值的值时，不需要立即创建另一个"><code>List</code></a>(<a href="https://docs.raku.org/type/List.html)。" class="bare">https://docs.raku.org/type/List.html)。</a></p>
</div>
<div class="paragraph">
<p>但是，调用 <code>.eager</code> 会将 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 转换为 [<code>List</code>](<a href="https://docs.raku.org/type/List.html)：" class="bare">https://docs.raku.org/type/List.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $countdown = &lt;1 2 3 4 5&gt;.reverse.eager;
put $countdown.^name; # Seq
put $countdown.elems; # 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you assign the [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) to a variable with the <code>@</code> sigil the [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) also turns into a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>). This is an eager assignmentto an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) (coming up soon):</p>
</div>
<div class="paragraph">
<p>如果将 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 赋值给带有 <code>@</code> sigil的变量，[<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 也会变成 [<code>List</code>](<a href="https://docs.raku.org/type/List.html)。这是对"><code>数组</code></a>(<a href="https://docs.raku.org/type/Array.html)的急切赋值（即将推出）：" class="bare">https://docs.raku.org/type/Array.html)的急切赋值（即将推出）：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @countdown = &lt;1 2 3 4 5&gt;.reverse;
put @countdown.^name; # Array
put @countdown.elems; # 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.pick</code> method chooses a random element from a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>):</p>
</div>
<div class="paragraph">
<p><code>.pick</code> 方法从 [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) 中选择一个随机元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $range = 0 .. 5;
my $sequence = $range.reverse;
say $sequence.^name; # Seq;

put $sequence.pick;  # 5 (or maybe something else)</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default you can only iterate through a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) once. You use an item, then move on to the next one. This means that a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) needs to know how to make the next element, and once it uses it it can discard it—it doesn’t remember past values. If you try to use the [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) after it’s gone through all of its elements you get an error:</p>
</div>
<div class="paragraph">
<p>默认情况下，你只能迭代一次 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html)。你使用项，然后转到下一项。这意味着" class="bare">https://docs.raku.org/type/Seq.html)。你使用项，然后转到下一项。这意味着</a> [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 需要知道如何制作下一个元素，一旦它使用它就可以丢弃它 - 它不记得过去的值。如果你尝试使用 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 后，它会遇到所有元素，则会出现错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put $sequence.pick;  # 3 (or maybe something else)
put $sequence;       # Error</code></pre>
</div>
</div>
<div class="paragraph">
<p>The error tells you what to do:</p>
</div>
<div class="paragraph">
<p>错误告诉你该怎么做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">This Seq has already been iterated, and its values consumed
(you might solve this by adding .cache on usages of the Seq, or
by assigning the Seq into an array)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding <code>.cache</code> remembers the elements of the [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) so you can reuse them. After the <code>.pick</code> there’s no error:</p>
</div>
<div class="paragraph">
<p>添加 <code>.cache</code> 会记住 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 的元素，因此你可以重用它们。在 <code>.pick</code> 之后没有错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $range = 0 .. 5;
my $sequence = $range.reverse.cache;
say $sequence.^name; # Seq;

put $sequence.pick;  # 5 (or maybe something else)
put $sequence;       # 5 4 3 2 1 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>This isn’t something you want to do carelessly, though. Part of the benefit of the [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) is the memory saving it provides by not duplicating data unless it needs to.</p>
</div>
<div class="paragraph">
<p>不过，这不是你想要做的事情。 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 的部分好处是它提供的内存节省，除非需要，否则不会复制数据。</p>
</div>
<div class="sect3">
<h4 id="_infinite_lazy_lists">3.3.1. Infinite Lazy Lists</h4>
<div class="paragraph">
<p>The [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) has to make all of the elements to <code>.pick</code> one of them. Once it does that it forgets them and doesn’t have a way to make more elements. Raku does this to support infinite lazy lists. You make these with the triple-dot sequence operator, <code>…​</code>. By binding to the [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) you give it a name without immediately reducing it to its values:</p>
</div>
<div class="paragraph">
<p>[<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 必须使所有元素能 <code>.pick</code> 其中之一。一旦它这样做就会忘记它们，并且没有办法制作更多的元素。 Raku这样做是为了支持无限的惰性列表。你使用三点序列运算符 <code>…​</code> 来制作它们。通过绑定到 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html)，你给它一个名字，而不是立即将它减少到它的值：" class="bare">https://docs.raku.org/type/Seq.html)，你给它一个名字，而不是立即将它减少到它的值：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $number-sequence := 1 ... 5;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s the integers from 1 to 5. The [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) looks at the start and figures out how to get to the end. That sequence is easy; it adds a whole number.</p>
</div>
<div class="paragraph">
<p>You can make an exclusive endpoint (but not an exclusive startpoint). This [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) is the integers from 1 to 4:</p>
</div>
<div class="paragraph">
<p>这是从 1 到 5 的整数。 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 查看开始并找出如何到达终点。这个序列很简单;它增加了一个整数。</p>
</div>
<div class="paragraph">
<p>你可以创建一个独占端点（但不是一个独占的起点）。此 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 是 1 到 4 的整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $exclusive-sequence := 1 ...^ 5;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) can’t count down, but a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) can. This one subtracts whole numbers:</p>
</div>
<div class="paragraph">
<p>[<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) 不能倒数，但是 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 可以。这一个减去整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $countdown-sequence := 5 ... 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same thing works for letters:</p>
</div>
<div class="paragraph">
<p>同样的事情适用于字母：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $alphabet-sequence := &#39;a&#39; ... &#39;z&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can tell the [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) how to determine the next element. You can specify more than one item for the start to give it the pattern:</p>
</div>
<div class="paragraph">
<p>你可以告诉 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 如何确定下一个元素。你可以为开头指定多个项目以为其指定模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s := 0, 1, 2 ... 256; # 257 numbers, 0 .. 256</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the series of whole numbers from 0 to 256. That’s the easiest pattern there. But add a 4 after the 2 and it’s a different series. Now it’s the powers of 2:</p>
</div>
<div class="paragraph">
<p>这是一系列从 0 到 256 的整数。这是最简单的模式。但是在 2 之后添加 4，这是一个不同的系列。现在它是 2 的幂：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s := 0, 1, 2, 4 ... 256; # powers of 2
say $s; # (0 1 2 4 8 16 32 64 128 256)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>…​</code> can figure out arithmetic or geometric series. But it gets better. If you have a more complicated series you can give it a rule to make the next item. That rule can be a [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) that grabs the previous argument and transforms it. Here it adds 0.1 to the previous element until it gets to 1.8. You couldn’t do this with a [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>):</p>
</div>
<div class="paragraph">
<p><code>…​</code> 可以算出算术或几何系列。但它变得更好。如果你有一个更复杂的系列，你可以给它一个规则来制作下一个项。该规则可以是一个阻止前一个参数并对其进行转换的块。这里它将前一个元素加 0.1，直到达到 1.8。你无法使用 [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) 执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s := 1, { $^a + 0.1 } ... 1.8;
say $s; # (1 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you have more than one positional parameter in your [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) it looks farther back in the series. Here are the Fibonacci numbers up to 21:</p>
</div>
<div class="paragraph">
<p>如果你的 [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) 中有多个位置参数，它会在系列中看起来更远。以下是最多 21 的斐波那契数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s := 1, 1, { $^a + $^b } ... 21;
say $s; # (1 1 2 3 5 8 13 21)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) only ends when it creates an item that is exactly equal to the endpoint. If you change that to <code>20</code> you get an infinite series and your program hangs while it creates every element so it can count them:</p>
</div>
<div class="paragraph">
<p>[<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 仅在创建与端点完全相同的项目时结束。如果将其更改为 <code>20</code>，则会得到一个无限系列，并且程序会在创建每个元素时挂起，以便计算它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s := 1, 1, { $^a + $^b } ... 20;
say $s.elems;  # never gets an answer but keeps trying</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of a literal endpoint you can give it a [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>). The [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) stops when the [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) evaluates to <code>True</code> (but keeps the element that makes it <code>True</code>):</p>
</div>
<div class="paragraph">
<p>而不是字面端点，你可以给它一个[<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)。当"><code>Block</code></a>(<a href="https://docs.raku.org/type/Block.html)计算为" class="bare">https://docs.raku.org/type/Block.html)计算为</a> <code>True</code> 时，[<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 停止（但保持使其为 <code>True</code> 的元素）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s := 1, 1, { $^a + $^b } ... { $^a &gt; 20 };
say $s.elems; # (1 1 2 3 5 8 13 21)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Those [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)s" class="bare">https://docs.raku.org/type/Block.html)s</a> are unwieldy, but you know that you can shorten them with [<code>Whatever</code>](<a href="https://docs.raku.org/type/Whatever.html)s" class="bare">https://docs.raku.org/type/Whatever.html)s</a>. Do the endpoint first:</p>
</div>
<div class="paragraph">
<p>那些 [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) 很笨重，但你知道你可以用 [<code>Whatever</code>](<a href="https://docs.raku.org/type/Whatever.html" class="bare">https://docs.raku.org/type/Whatever.html</a>) 缩短它们。首先执行端点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s := 1, 1, { $^a + $^b } ... * &gt; 20;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can reduce the first [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) with two [<code>Whatever</code>](<a href="https://docs.raku.org/type/Whatever.html)s" class="bare">https://docs.raku.org/type/Whatever.html)s</a>. That [<code>WhateverCode</code>](<a href="https://docs.raku.org/type/WhateverCode.html" class="bare">https://docs.raku.org/type/WhateverCode.html</a>) sees two `*`s and knows it needs two elements:</p>
</div>
<div class="paragraph">
<p>你可以使用两个 [<code>Whatever</code>](<a href="https://docs.raku.org/type/Whatever.html" class="bare">https://docs.raku.org/type/Whatever.html</a>) 减少第一个 [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)。" class="bare">https://docs.raku.org/type/Block.html)。</a> [<code>WhateverCode</code>](<a href="https://docs.raku.org/type/WhateverCode.html" class="bare">https://docs.raku.org/type/WhateverCode.html</a>) 看到两个 <code>*</code> 并知道它需要两个元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s := 1, 1, * + * ... * &gt; 20;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That stops the Fibonacci numbers at 21. What if you wanted all of the Fibonacci numbers? The [<code>Whatever</code>](<a href="https://docs.raku.org/type/Whatever.html" class="bare">https://docs.raku.org/type/Whatever.html</a>) by itself can be the endpoint and in that context it is never <code>True</code>; this series never ends:</p>
</div>
<div class="paragraph">
<p>这会阻止斐波那契数字为 21.若你想要所有斐波那契数字怎么办？ [<code>Whatever</code>](<a href="https://docs.raku.org/type/Whatever.html" class="bare">https://docs.raku.org/type/Whatever.html</a>) 本身可以是端点，在这种情况下它永远不会是真的;这个系列永远不会结束</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s := 1, 1, * + * ... *;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is one of the reasons <code>.gist</code> exists. It gives a summary of the object. It knows that this is an infinite [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) so it doesn’t try to represent it:</p>
</div>
<div class="paragraph">
<p>这是其中一个原因 <code>.gist</code> 存在。它给出了对象的摘要。它知道这是一个无限的 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 所以它不会试图表示它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put $s.gist; # (...)
say $s;      # (...), .gist implicitly</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s it. That’s the heart of [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>). It can produce an infinite number of values but it doesn’t do it immediately. It knows the pattern to get to the next one.</p>
</div>
<div class="paragraph">
<p>Recall that a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) doesn’t remember all the values. Once it goes through them it doesn’t store them or regenerate them. In this example it reverses the list and exhausts the series. That’s all in the first <code>put</code>. There’s nothing left for the second <code>put</code>:</p>
</div>
<div class="paragraph">
<p>而已。这是 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 的核心。它可以产生无限数量的值，但它不会立即执行。它知道进入下一个模式的模式。</p>
</div>
<div class="paragraph">
<p>回想一下 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 不记得所有的值。一旦它通过它们就不会存储它们或重新生成它们。在此示例中，它会反转列表并耗尽系列。这是第一次投入。第二次放置没有任何东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s := 1 ... 5;

put $s.reverse; # (5 4 3 2 1)
put $s;         # Error</code></pre>
</div>
</div>
<div class="paragraph">
<p>You get this error:</p>
</div>
<div class="paragraph">
<p>你收到这个错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">This Seq has already been iterated, and its values consumed
(you might solve this by adding .cache on usages of the Seq, or
by assigning the Seq into an array)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The error tells you what to do. You can call <code>.cache</code> on a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) to force it to remember the values, even if this will eat up all of your memory:</p>
</div>
<div class="paragraph">
<p>该错误告诉你该怎么做。你可以在 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 上调用 <code>.cache</code> 来强制它记住这些值，即使这会占用你所有的内存：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s := 1 ... 5;
put $s.cache.reverse; # 5 4 3 2 1
put $s;               # 1 2 3 4 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>Should you need to treat a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) as a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>), coerce it with <code>@</code>. This generates all of its values:</p>
</div>
<div class="paragraph">
<p>如果你需要将 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 视为[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)，请使用" class="bare">https://docs.raku.org/type/List.html)，请使用</a> <code>@</code> 强制它。这会生成所有值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = ( 1 ... 5 );
put $s.^name; # Seq

my $list-from-s = @$s;
put $list-from-s.^name; #List</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most of the time a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) will act like a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>), but sometimes you need to give some hints.</p>
</div>
<div class="paragraph">
<p>大多数情况下，[<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 会像 [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) 一样，但有时你需要提供一些提示。</p>
</div>
</div>
<div class="sect3">
<h4 id="_gathering_values">3.3.2. Gathering Values</h4>
<div class="paragraph">
<p>The previous [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html)s" class="bare">https://docs.raku.org/type/Seq.html)s</a> could easily compute their next values based on the ones that came before. That’s not always the case. A <code>gather</code> with a [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) returns a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>). When you want the next value the <code>gather</code> runs the code. A <code>take</code> produces a value. Here’s the same thing as <code>1 …​ 5</code> using <code>gather</code>:</p>
</div>
<div class="paragraph">
<p>之前的 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 可以根据之前的 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 轻松计算下一个值。情况并非总是如此。带有块的聚集返回 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html)。当你想要下一个值时，聚集会运行代码。拍摄会产生一个价值。这与使用" class="bare">https://docs.raku.org/type/Seq.html)。当你想要下一个值时，聚集会运行代码。拍摄会产生一个价值。这与使用</a> <code>gather</code> 的 <code>1 …​ 5</code> 相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $seq := gather {
    state $previous = 0;

    while $previous++ &lt; 5 { take $previous }
    }

say $seq;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each time the code encounters a <code>take</code> it produces a value, then waits until the next time something asks for a value. The [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) stops when the code gets to the end of the <code>gather</code> [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>). In this example, the <code>while</code> [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)runs" class="bare">https://docs.raku.org/type/Block.html)runs</a> once for each access to the [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>).</p>
</div>
<div class="paragraph">
<p>You don’t need the braces for the [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) if the statement fits on one line. This is an infinite [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>):</p>
</div>
<div class="paragraph">
<p>每次代码遇到一个 <code>take</code> 它产生一个值，然后等到下一次有东西要求一个值。当代码到达 <code>gather</code></p>
</div>
<div class="literalblock">
<div class="content">
<pre>[`块`](https://docs.raku.org/type/Block.html)的末尾时， [`Seq`](https://docs.raku.org/type/Seq.html) 停止。在这个例子中，`while`  [`Block`](https://docs.raku.org/type/Block.html) 每次访问  [`Seq`](https://docs.raku.org/type/Seq.html) 一次。</pre>
</div>
</div>
<div class="paragraph">
<p>如果语句适合一行，则不需要[<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)的大括号。这是一个无限的" class="bare">https://docs.raku.org/type/Block.html)的大括号。这是一个无限的</a> [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html)：" class="bare">https://docs.raku.org/type/Seq.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $seq := gather take $++ while 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Those are easily done with the tools you already had. What about a random [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) of random values? This <code>gather</code> keeps choosing one value from <code>@array</code>, forever:</p>
</div>
<div class="paragraph">
<p>使用你已有的工具可以轻松完成这些工作。随机值的随机 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 怎么样？这个 <code>gather</code> 永远从 <code>@array</code> 中选择一个值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array = &lt;red green blue purple orange&gt;;
my $seq := gather take @array.pick(1) while 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here’s a <code>gather</code> that provides only the lines of input with <code>eq</code> in them. It doesn’t have to wait for all of the input to start producing values. And since the [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) controls access to the lines, you don’t need to use or store them right away:</p>
</div>
<div class="paragraph">
<p>这是一个 <code>gather</code>，它只提供带有 <code>eq</code> 的输入行。它不必等待所有输入开始生成值。由于 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 控制对行的访问，因此你无需立即使用或存储它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $seq := gather for lines() { next unless /eq/; take $_ };

for $seq -&gt; $item {
    put &#34;Got: $item&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can store these in a [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) without being eager:</p>
</div>
<div class="paragraph">
<p>你可以将它们存储在一个 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) 而不是急切的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @seq = lazy gather for lines() { next unless /eq/; take $_ };

for @seq -&gt; $item {
    put &#34;Got: $item&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>It doesn’t matter how you create the [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>). Once you have it you can use it and pass it around like any other sequence.</p>
</div>
<div class="paragraph">
<p>EXERCISE 6.6Use <code>gather</code> and <code>take</code> to produce an infinite cycle of alternating values from an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) of color names. When you get to the end of the array, go back to the beginning and start again.</p>
</div>
<div class="paragraph">
<p>你如何创建 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 并不重要。一旦你拥有它，你可以使用它并像任何其他序列一样传递它。</p>
</div>
<div class="paragraph">
<p>练习6.6 使用 <code>gather</code> 和 <code>take</code> 从颜色名称数组中产生无限循环的交替值。当你到达数组的末尾时，回到开头并重新开始。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_single_element_access">3.4. Single-Element Access</h3>
<div class="paragraph">
<p>You can extract a particular element by its position in the object, whether that’s a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>), [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>), [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>), or other type of [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) thingy. Each position has an <code>index</code> that’s a positive integer (including 0). To get the element, append <code>[</code><strong>POSITION</strong><code>]</code> to your thingy:</p>
</div>
<div class="paragraph">
<p>你可以通过它在对象中的位置来提取特定元素，无论是 [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>), [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>), [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 还是其他类型的 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) thingy。每个位置都有一个正整数（包括0）的索引。要获取元素，请将[POSITION]附加到你的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly-genus = &lt;Hamadryas Sostrata Junonia&gt;;
my $first-butterfly = $butterfly-genus[0];
put &#34;The first element is $first-butterfly&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>[</code><strong>POSITION</strong><code>]`is a postcircumfix operator. Operators are actually methods ([Chapter 12](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch12.html#camelia-classes)" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch12.html#camelia-classes)</a>), so you can use the method dot between the object and the `[</code><strong>POSITION</strong><code>]</code> (although you mostly won’t):</p>
</div>
<div class="paragraph">
<p><code>[`POSITION]是一个 postcircumfix 运算符。操作符实际上是方法（第12章），因此你可以使用对象和</code>[` POSITION <code>]</code> 之间的方法点（尽管你通常不会）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $first-butterfly = $butterfly-genus.[0];</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can interpolate either form in double-quoted [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a>:</p>
</div>
<div class="paragraph">
<p>你可以在双引号[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)中插入任一形式：" class="bare">https://docs.raku.org/type/Str.html)中插入任一形式：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;The first butterfly is $butterfly-genus[0]&#34;;
put &#34;The first butterfly is $butterfly-genus.[0]&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the index counts from zero the last position is one less than the number of elements. The <code>.end</code> methodknows that position:</p>
</div>
<div class="paragraph">
<p>由于索引从零开始计数，因此最后一个位置比元素数少一个。 <code>.end</code> 方法知道该位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $end = $butterfly-genus.end;               # 2
my $last-butterfly = $butterfly-genus[$end];  # Junonia</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the thingy happens to be a lazy list you’ll get an error trying to find its end element; you can check if it is with <code>.is-lazy</code> and perhaps do something different in that case:</p>
</div>
<div class="paragraph">
<p>如果thingy恰好是一个懒惰的列表，你会在尝试找到它的结束元素时遇到错误;你可以检查它是否与 <code>.is-lazy</code> 一起，并且可能在这种情况下做一些不同的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly-genus = &lt;Hamadryas Sostrata Junonia&gt;;
$butterfly-genus = (1 ... * );
put do if $butterfly-genus.is-lazy { &#39;Lazy list!&#39; }
       else {
            my $end = $butterfly-genus.end;
            $butterfly-genus[$end]
            }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you specify a position less than <code>0</code> you get an error. If you try to do it with a literal value the error message tells you that you’ve carried a habit over from a different language:</p>
</div>
<div class="paragraph">
<p>如果指定小于 <code>0</code> 的位置，则会出现错误。如果你尝试使用文字值来执行此操作，则错误消息会告诉你，你已经习惯使用其他语言：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$butterfly-genus[-1];  # fine in Perl 5, but error in Raku!</code></pre>
</div>
</div>
<div class="paragraph">
<p>The error message tells you to use <code>*-1</code> instead, which you’ll read more about in just a moment:</p>
</div>
<div class="paragraph">
<p>错误消息告诉你使用 <code>*-1</code> 代替，你将在稍后阅读更多信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Unsupported use of a negative -1 subscript to index from the end;
in Raku please use a function such as *-1</code></pre>
</div>
</div>
<div class="paragraph">
<p>But if you’ve put that index in a variable, perhaps as the result of poor math, you get a different error:</p>
</div>
<div class="paragraph">
<p>但是如果你把这个索引放在变量中，也许是因为数学不好，你会得到一个不同的错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $end = -1;
$butterfly-genus[$i];</code></pre>
</div>
</div>
<div class="paragraph">
<p>This time it tells you that you are out of bounds:</p>
</div>
<div class="paragraph">
<p>这次它告诉你你已经出界了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Index out of range. Is: -1, should be in 0..^Inf</code></pre>
</div>
</div>
<div class="paragraph">
<p>This doesn’t work the same way on the other side. If you try to access an element beyond the last one, you get back <code>Nil</code> with no error message:</p>
</div>
<div class="paragraph">
<p>这在另一方面不起作用。如果你尝试访问超出最后一个元素的元素，则会返回 <code>Nil</code> 而不显示任何错误消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $end = $butterfly-genus.end;
$butterfly-genus[$end + 1];  # Nil!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Curiously, though, you can’t use <code>Nil</code> to tell if you specified a wrong position because <code>Nil</code> can be an element of a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>):</p>
</div>
<div class="paragraph">
<p>但奇怪的是，你不能使用 <code>Nil</code> 来判断你是否指定了错误的位置，因为 <code>Nil</code> 可以是 [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) 的一个元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $has-nil = ( &#39;Hamadryas&#39;, Nil, &#39;Junonia&#39;, Nil );
my $butterfly = $has-nil.[3]; # works, but still Nil!</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also put almost any code you like inside the square brackets. It should evaluate to an [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>), but if it doesn’t the operator will try to convert it to one. You can skip the <code>$end</code> variable you’ve used so far and use`.end` directly:</p>
</div>
<div class="paragraph">
<p>你也可以将几乎任何你喜欢的代码放在方括号内。它应该评估为 [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html)，但如果不是，则运算符将尝试将其转换为1。你可以跳过你到目前为止使用的" class="bare">https://docs.raku.org/type/Int.html)，但如果不是，则运算符将尝试将其转换为1。你可以跳过你到目前为止使用的</a> <code>$end</code> 变量并直接使用 <code>.end</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $last-butterfly = $butterfly-genus[$butterfly-genus.end];</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you wanted the next-to-last element, you could subtract one:</p>
</div>
<div class="paragraph">
<p>如果你想要倒数第二个元素，你可以减去一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $next-to-last = $butterfly-genus[$butterfly-genus.end - 1];</code></pre>
</div>
</div>
<div class="paragraph">
<p>This way of counting from the end is quite tedious though, so there’s a shorter way to do it. A [<code>Whatever</code>](<a href="https://docs.raku.org/type/Whatever.html" class="bare">https://docs.raku.org/type/Whatever.html</a>) starinside the <code>[]</code> is the number of elements in the list (not the last index!). That * is one greater than the last position. Subtract <code>1</code> from <code>*</code> to get the index for the last element:</p>
</div>
<div class="paragraph">
<p>这种从末尾计算的方式相当繁琐，所以有一个更短的方法来做到这一点。 [<code>Whatever</code>](<a href="https://docs.raku.org/type/Whatever.html)，" class="bare">https://docs.raku.org/type/Whatever.html)，</a>是列表中元素的数量（不是最后一个索引！）。那个*比最后一个位置大一个。从*中减去1以获取最后一个元素的索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $last-butterfly = $butterfly-genus[*-1];</code></pre>
</div>
</div>
<div class="paragraph">
<p>To get the next-to-last element, subtract one more:</p>
</div>
<div class="paragraph">
<p>要获得倒数第二个元素，再减去一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $next-to-last = $butterfly-genus[*-2];</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you subtract more than the number of elements, you’ll get <code>Nil</code> (rather than an out-of-index error like you would without the <code>*</code>).</p>
</div>
<div class="paragraph">
<p>If you have a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) it will create whatever items it needs to get to the one that you ask for. The triangle numbers add the index of the element to the previous number to get the next number in the series. If you want the fifth one ask for that index:</p>
</div>
<div class="paragraph">
<p>如果你减去超过元素的数量，你将得到 <code>Nil</code> （而不是像你没有 <code>*</code> 那样的索引之外的错误）。</p>
</div>
<div class="paragraph">
<p>如果你有一个 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html)，它将创建你需要的任何物品到你要求的那个。三角形数字将元素的索引添加到前一个数字，以获得系列中的下一个数字。如果你想要第五个请求该索引：" class="bare">https://docs.raku.org/type/Seq.html)，它将创建你需要的任何物品到你要求的那个。三角形数字将元素的索引添加到前一个数字，以获得系列中的下一个数字。如果你想要第五个请求该索引：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $triangle := 0, { ++$ + $^a } ... *;
say $triangle[4];</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 6.7The squares of numbers is the sequence where you add <strong>2n–1</strong> to the previous value. <strong>n</strong> is the position in the sequence. Use the sequence operator <code>…​</code> to compute the square of 25.</p>
</div>
<div class="paragraph">
<p>练习6.7 数字的平方是将 2n-1加到前一个值的序列。 n 是序列中的位置。使用序列运算符 <code>…​</code> 来计算 25 的平方。</p>
</div>
<div class="sect3">
<h4 id="_changing_a_single_element">3.4.1. Changing a Single Element</h4>
<div class="paragraph">
<p>If your [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) element is a container you can change its value. Previously you used an anonymous scalar container as a placeholder in one of your lists:</p>
</div>
<div class="paragraph">
<p>如果[<code>List</code>](<a href="https://docs.raku.org/type/List.html)元素是容器，则可以更改其值。以前，你使用匿名标量容器作为其中一个列表中的占位符：" class="bare">https://docs.raku.org/type/List.html)元素是容器，则可以更改其值。以前，你使用匿名标量容器作为其中一个列表中的占位符：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterflies = ( $, &#39;Sostrata&#39;, &#39;Junonia&#39; );
say $butterflies; # ((Any) perlicus Sostrata Junonia)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can’t change the container, but you can change the value that’s in the container:</p>
</div>
<div class="paragraph">
<p>你无法更改容器，但可以更改容器中的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$butterflies.[0] = &#39;Hamadryas&#39;;
say $butterflies; # (Hamadryas Sostrata Junonia)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you try to change an item that is not a container you get an error:</p>
</div>
<div class="paragraph">
<p>如果你尝试更改不是容器的项目，则会收到错误消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$butterflies.[1] = &#39;Ixias&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The error tells you that the element there is something that you cannot change:</p>
</div>
<div class="paragraph">
<p>该错误告诉你该元素有一些你无法更改的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Cannot modify an immutable Str (...)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_multiple_element_access">3.4.2. Multiple-Element Access</h4>
<div class="paragraph">
<p>You can access multiple elements at the same time. A slice specifies more than one index in the brackets:</p>
</div>
<div class="paragraph">
<p>你可以同时访问多个元素。切片在括号中指定多个索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly-genus = &lt;Hamadryas Sostrata Junonia&gt;;
my ( $first, $last ) = $butterfly-genus[0, *-1];
put &#34;First: $first Last: $last&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that you can declare multiple variables at the same time by putting them in parentheses after the <code>my</code>. Since that’s not a subroutine call you still need a space after <code>my</code>. The output shows the first and last elements:</p>
</div>
<div class="paragraph">
<p>请注意，你可以通过将多个变量放在 <code>my</code> 之后的括号中来同时声明多个变量。因为这不是一个子程序调用，你仍需要一个空格。输出显示第一个和最后一个元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">First: Hamadryas Last: Junonia</code></pre>
</div>
</div>
<div class="paragraph">
<p>The indices can come from a [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>). If you’ve stored that in a scalar variable you have to coerce or <strong>flatten</strong> it:</p>
</div>
<div class="paragraph">
<p>指数可以来自一个  [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html)。如果你将它存储在标量变量中，你必须强制或压扁它：" class="bare">https://docs.raku.org/type/Positional.html)。如果你将它存储在标量变量中，你必须强制或压扁它：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put $butterfly-genus[ 1 .. *-1 ];    # Sostrata Junonia

my $indices = ( 0, 2 );
put $butterfly-genus[ @$indices ];  # Hamadryas Junonia
put $butterfly-genus[ |$indices ];  # Hamadryas Junonia

my @positions = 1, 2;
put $butterfly-genus[ @positions ]; # Sostrata Junonia</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assigning to multiple elements works the same way inside the brackets. However, the elements must be mutable. If they aren’t containers you won’t be able to change them:</p>
</div>
<div class="paragraph">
<p>分配给多个元素在括号内的工作方式相同。但是，元素必须是可变的。如果它们不是容器，你将无法更改它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly-genus = ( $, $, $ );
$butterfly-genus[ 1 ] = &#39;Hamadryas&#39;;
$butterfly-genus[ 0, *-1 ] = &lt;Gargina Trina&gt;;
put $butterfly-genus;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can fix that by using an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>), which you’re about to read more about. The [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) automatically containerizes its elements:</p>
</div>
<div class="paragraph">
<p>你可以通过使用一个[<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)来修复它，你将要阅读更多。" class="bare">https://docs.raku.org/type/Array.html)来修复它，你将要阅读更多。</a> [<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)自动容纳其元素：" class="bare">https://docs.raku.org/type/Array.html)自动容纳其元素：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @butterfly-genus = &lt;Hamadryas Sostrata Junonia&gt;;
@butterfly-genus[ 0, *-1 ] = &lt;Gargina Trina&gt;;
put @butterfly-genus;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_arrays">3.5. Arrays</h3>
<div class="paragraph">
<p>You can’t change a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>). Once constructed it is what it is and keeps the same number of elements. You can’t add or remove any elements. Unless the item is a container, each [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) item’s value is fixed.</p>
</div>
<div class="paragraph">
<p>[<code>Array</code>](<a href="https://docs.raku.org/type/Array.html)s" class="bare">https://docs.raku.org/type/Array.html)s</a> are different. They containerize every item so that you can change any of them, and the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) itself is a container. You could start with the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) class to make an object:</p>
</div>
<div class="paragraph">
<p>你无法更改[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)。一旦构造它就是它的原因并保持相同数量的元素。你无法添加或删除任何元素。除非该项是容器，否则每个"><code>列表</code></a>(<a href="https://docs.raku.org/type/List.html)项的值都是固定的。" class="bare">https://docs.raku.org/type/List.html)项的值都是固定的。</a></p>
</div>
<div class="paragraph">
<p>[<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)是不同的。它们将每个项目包含在内，以便你可以更改它们中的任何项目，而"><code>数组</code></a>(<a href="https://docs.raku.org/type/Array.html)本身就是一个容器。你可以从"><code>Array</code></a>(<a href="https://docs.raku.org/type/Array.html)类开始创建一个对象：" class="bare">https://docs.raku.org/type/Array.html)类开始创建一个对象：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly-genus = Array.new: &#39;Hamadryas&#39;, &#39;Sostrata&#39;, &#39;Junonia&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You’ll probably never see that, though. Instead, you can use square brackets to make an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>). Each item in the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) becomes a container even if it didn’t start as one:</p>
</div>
<div class="paragraph">
<p>但是你可能永远都看不到。相反，你可以使用方括号来制作[<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)。" class="bare">https://docs.raku.org/type/Array.html)。</a> [<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)中的每个项目都成为一个容器，即使它没有以一个方式启动：" class="bare">https://docs.raku.org/type/Array.html)中的每个项目都成为一个容器，即使它没有以一个方式启动：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly-genus = [&#39;Hamadryas&#39;, &#39;Sostrata&#39;, &#39;Junonia&#39;];</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since every item is a container you can change any value by assigning to it through a single-element access:</p>
</div>
<div class="paragraph">
<p>由于每个项目都是容器，因此你可以通过单元素访问权限分配任何值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$butterfly-genus.[1] = &#39;Paruparo&#39;;
say $butterflies; # [Hamadryas Paruparo Junonia]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This new behavior gets its own sigil, the <code>@</code> (which looks a bit like an <strong>a</strong> for <strong>Array</strong>). When you assign a listy thing to an <code>@</code> variable you get an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>):</p>
</div>
<div class="paragraph">
<p>这个新行为得到了自己的印记，<code>@</code> （看起来有点像一个数组）。当你为 <code>@</code> 变量分配一个listy的东西时，你得到一个数组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @butterfly-genus = &lt;Hamadryas Sostrata Junonia&gt;;
put @butterfly-genus.^name;  # Array</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>=</code> here is the list assignment operator you met earlier. Since you have an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) on the left side of the operator the <code>=</code> knows it’s the list variety. That one is lower precedence than the comma, so you can leave off the grouping parentheses you’ve been using so far:</p>
</div>
<div class="paragraph">
<p>这里的 <code>=</code> 是你之前遇到的列表赋值运算符。由于运算符左侧有一个数组，因此 <code>=</code> 知道它是列表种类。那个优先级低于逗号，所以你可以不用你到目前为止使用的分组括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @butterfly-genus = 1, 2, 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 6.8You’ve already used an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) that you haven’t seen. <code>@*ARGS</code> is the collection of [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> that you’ve specified on the command line. Output each element on its own line.</p>
</div>
<div class="paragraph">
<p>练习6.8 你已经使用过一个你没见过的[<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)。" class="bare">https://docs.raku.org/type/Array.html)。</a> <code>@*ARGS</code> 是你在命令行中指定的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)集合。输出每个元素在自己的行上。" class="bare">https://docs.raku.org/type/Str.html)集合。输出每个元素在自己的行上。</a></p>
</div>
<div class="sect3">
<h4 id="_constructing_an_array">3.5.1. Constructing an Array</h4>
<div class="paragraph">
<p>There’s a hidden list assignment here that makes this possible. In its expanded form there are a couple of steps. Greatly simplified, the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) sets up a scalar container for the number of items it will hold and binds to that:</p>
</div>
<div class="paragraph">
<p>这里有一个隐藏的列表分配，这使得这成为可能。在其扩展形式中，有几个步骤。大大简化了，[<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) 为它将保持并绑定到的项目数量设置了一个标量容器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @butterfly-genus := ( $, $, $ ); # binding</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then it assigns the items in the incoming list to the containers in the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>):</p>
</div>
<div class="paragraph">
<p>然后它将传入列表中的项目分配给 [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) 中的容器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@butterfly-genus = &lt;Hamadryas Sostrata Junonia&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You don’t need to do any of this yourself because it happens automatically when you assign to an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) (the <code>@`variable). [`Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) items are always containers, and the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) itself is a container.</p>
</div>
<div class="paragraph">
<p>The square brackets construct an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) (and it’s the square brackets that index [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html)s" class="bare">https://docs.raku.org/type/Array.html)s</a>). You can assign to a scalar or [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) variable:</p>
</div>
<div class="paragraph">
<p>你不需要自己执行任何操作，因为它在你分配给数组（<code>@variable</code> ）时会自动发生。数组项始终是容器，[<code>Array</code>](<a href="https://docs.raku.org/type/Array.html)本身是容器。" class="bare">https://docs.raku.org/type/Array.html)本身是容器。</a></p>
</div>
<div class="paragraph">
<p>方括号构造一个数组（它是索引数组的方括号）。你可以分配标量或数组变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $array = [ &lt;Hamadryas Sostrata Junonia&gt; ];
put $array.^name;      # Array
put $array.elems;      # 3
put $array.join: &#39;|&#39;;  # Hamadryas|Sostrata|Junonia

my @array = [ &lt;Hamadryas Sostrata Junonia&gt; ];
put @array.^name;      # Array
put @array.elems;      # 3
put @array.join: &#39;|&#39;;  # Hamadryas|Sostrata|Junonia</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are going to assign to <code>@array</code> you don’t need the brackets, though. This is the same thing:</p>
</div>
<div class="paragraph">
<p>但是，如果要分配给 <code>@array</code>，则不需要括号。这是一回事：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array = &lt;Hamadryas Sostrata Junonia&gt;;
put @array.^name;      # Array
put @array.elems;      # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>The brackets are handier when you want to skip the variable. You would do this for temporary data structures or subroutine arguments. You’ll see more of those as you go on.</p>
</div>
<div class="paragraph">
<p>如果要跳过变量，括号更方便。你可以为临时数据结构或子例程参数执行此操作。随着你的继续，你会看到更多这些。</p>
</div>
</div>
<div class="sect3">
<h4 id="_interpolating_arrays">3.5.2. Interpolating Arrays</h4>
<div class="paragraph">
<p>A double-quoted [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) can interpolate single or multiple elements of a [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) or even all the elements. Use the brackets to select the elements that you want:</p>
</div>
<div class="paragraph">
<p>双引号[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)可以插入"><code>Positional</code></a>(<a href="https://docs.raku.org/type/Positional.html)的单个或多个元素甚至所有元素。使用括号选择所需的元素：" class="bare">https://docs.raku.org/type/Positional.html)的单个或多个元素甚至所有元素。使用括号选择所需的元素：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterflies = &lt;Hamadryas Sostrata Junonia&gt;;
put &#34;The first butterfly is $butterflies[0]&#34;;
put &#34;The last butterfly is $butterflies[*-1]&#34;;
put &#34;Both of those are $butterflies[0,*-1]&#34;;
put &#34;All the butterflies are $butterflies[]&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When it interpolates multiple elements it inserts a space between the elements:</p>
</div>
<div class="paragraph">
<p>当它插入多个元素时，它会在元素之间插入一个空格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">The first butterfly is Hamadryas
The last butterfly is Junonia
Both of those are Hamadryas Junonia
All the butterflies are Hamadryas Sostrata Junonia</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can interpolate [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html)s" class="bare">https://docs.raku.org/type/Range.html)s</a> too:</p>
</div>
<div class="paragraph">
<p>你也可以插入 [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html)：" class="bare">https://docs.raku.org/type/Range.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $range = 7 .. 13;
put &#34;The first is $range[0]&#34;;    # The first is 7
put &#34;The last is $range[*-1]&#34;;   # The last is 13
put &#34;All are $range&#34;;            # All are 7 8 9 10 11 12 13</code></pre>
</div>
</div>
<div class="paragraph">
<p>The other [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html)s" class="bare">https://docs.raku.org/type/Positional.html)s</a> behave similarly based on how they generate their elements.</p>
</div>
<div class="paragraph">
<p>其他 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) 基于它们如何生成元素的行为类似。</p>
</div>
</div>
<div class="sect3">
<h4 id="_array_operations">3.5.3. Array Operations</h4>
<div class="paragraph">
<p>Since the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) is a container you can change it. Unlike with a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>), you can add and remove items. The <code>.shift</code> method removes the first item from the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) and gives it back to you. That item is no longer in the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>):</p>
</div>
<div class="paragraph">
<p>由于 [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) 是容器，你可以更改它。与 [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) 不同，你可以添加和删除项目。 <code>.shift</code> 方法从数组中删除第一个项目并将其返回给你。该项不再在数组中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @butterfly-genus = &lt;Hamadryas Sostrata Junonia&gt;;
my $first-item = @butterfly-genus.shift;
say @butterfly-genus;  # [Sostrata Junonia]
say $first-item;       # Hamadryas</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) is empty you get a [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>), but you won’t learn about those until [Chapter 7](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch07.html#camelia-failures" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch07.html#camelia-failures</a>). You don’t get an immediate error; the error shows up when you try to use it later:</p>
</div>
<div class="paragraph">
<p>如果[<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)为空，则会出现" class="bare">https://docs.raku.org/type/Array.html)为空，则会出现</a> [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html)，但在第7章之前你将不会了解这些故障。你没有立即收到错误;稍后尝试使用时会出现错误：" class="bare">https://docs.raku.org/type/Failure.html)，但在第7章之前你将不会了解这些故障。你没有立即收到错误;稍后尝试使用时会出现错误：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array = Empty;
my $element = @array.shift;
put $element.^name;  # Failure (soft exception)</code></pre>
</div>
</div>
<div class="paragraph">
<p>That error is <code>False</code> but won’t complain when it’s in a conditional:</p>
</div>
<div class="paragraph">
<p>该错误是 <code>False</code> 的，但是当它处于条件状态时不会抱怨：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">while my $element = @array.shift { put $element }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.pop</code> method removes the last item:</p>
</div>
<div class="paragraph">
<p><code>.pop</code> 方法删除最后一项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @butterfly-genus = &lt;Hamadryas Sostrata Junonia&gt;;
my $first-item = @butterfly-genus.pop;
say @butterfly-genus;  # [Hamadryas Sostrata]
say $first-item;       # Junonia</code></pre>
</div>
</div>
<div class="paragraph">
<p>To add one or more items to the front of the list, use <code>.unshift</code>. One top-level item becomes one element in the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>):</p>
</div>
<div class="paragraph">
<p>要将一个或多个项添加到列表的前面，请使用 <code>.unshift</code>。一个顶级项目成为数组中的一个元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @butterfly-genus = Empty;
@butterfly-genus.unshift: &lt;Hamadryas Sostrata&gt;;
say @butterfly-genus;  # [Hamadryas Sostrata]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.push</code> adds a list of items to the end of the list:</p>
</div>
<div class="paragraph">
<p>`.push`将一个项列表添加到列表的末尾：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@butterfly-genus.push: &lt;Junonia&gt;;
say @butterfly-genus;  # [Hamadryas Sostrata Junonia]</code></pre>
</div>
</div>
<div class="paragraph">
<p>With <code>.splice</code> you can add elements to or remove them from anywhere in the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>). It takes a starting index, a length, and the items to remove from the list. It gives you the elements it removed:</p>
</div>
<div class="paragraph">
<p>使用 <code>.splice</code>，你可以在[<code>Array</code>](<a href="https://docs.raku.org/type/Array.html)中的任何位置添加元素或从中删除元素。它需要一个起始索引，一个长度以及要从列表中删除的项目。它为你提供了删除的元素：" class="bare">https://docs.raku.org/type/Array.html)中的任何位置添加元素或从中删除元素。它需要一个起始索引，一个长度以及要从列表中删除的项目。它为你提供了删除的元素：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @butterfly-genus = 1 .. 10;
my @removed = @butterfly-genus.splice: 3, 4;
say @removed;          # [4 5 6 7]
say @butterfly-genus;  # [1 2 3 8 9 10]</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can give <code>.splice</code> items to replace those that you removed:</p>
</div>
<div class="paragraph">
<p>你可以提供 <code>.splice</code> 项目来替换你删除的项目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @butterfly-genus = 1 .. 10;
my @removed = @butterfly-genus.splice: 5, 2, &lt;a b c&gt;;
say @removed;          # [6 7]
say @butterfly-genus;  # [1 2 3 4 5 a b c 8 9 10]</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the length is 0 you don’t remove anything, but you can still insert items. You get an empty [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) back:</p>
</div>
<div class="paragraph">
<p>如果长度为 0，则不会删除任何内容，但仍可以插入项目。你得到一个空[<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)：" class="bare">https://docs.raku.org/type/Array.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @butterfly-genus = &#39;a&#39; .. &#39;f&#39;;
my @removed = @butterfly-genus.splice: 5, 0, &lt;X Y Z&gt;;
say @removed;          # []
say @butterfly-genus;  # [a b c d e X Y Z f]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each of these [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) methods have routine versions:</p>
</div>
<div class="paragraph">
<p>这些[<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)方法中的每一个都有例程版本：" class="bare">https://docs.raku.org/type/Array.html)方法中的每一个都有例程版本：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $first = shift @butterfly-genus;
my $last  = pop @butterfly-genus;

unshift @butterfly-genus, &lt;Hamadryas Sostrata&gt;;
push @butterfly-genus, &lt;Junonia&gt;

splice @butterfly-genus, $start-pos, $length, @elements;</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 6.9Start with an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) that holds the letters from <strong>a</strong> to <strong>f</strong>. Use the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) operators to move those elements to a new [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) that will have the same elements in reverse order.</p>
</div>
<div class="paragraph">
<p>EXERCISE 6.10Start with the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) that holds the letters from <strong>a</strong> to <strong>f</strong>. Use only <code>.splice</code> to make these changes: remove the first element, remove the last element, add a capital <strong>A</strong> to the front of the list, and add a capital <strong>F</strong> to the end of the list.</p>
</div>
<div class="paragraph">
<p>练习6.9 启动一个包含从 a 到 f 的字母的[<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)。使用"><code>数组</code></a>(<a href="https://docs.raku.org/type/Array.html)运算符将这些元素移动到一个新的"><code>数组</code></a>(<a href="https://docs.raku.org/type/Array.html)，它将以相反的顺序具有相同的元素。" class="bare">https://docs.raku.org/type/Array.html)，它将以相反的顺序具有相同的元素。</a></p>
</div>
<div class="paragraph">
<p>EXERCISE 6.10 从包含 a 到 f 的字母的[<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)开始。仅使用" class="bare">https://docs.raku.org/type/Array.html)开始。仅使用</a> <code>.splice</code> 进行这些更改：删除第一个元素，删除最后一个元素，将大写 A 添加到列表的前面，然后将大写字母 F 添加到列表的末尾。</p>
</div>
</div>
<div class="sect3">
<h4 id="_lists_of_lists">3.5.4. Lists of Lists</h4>
<div class="paragraph">
<p>A [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) can be an element of another [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) (or [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html)" class="bare">https://docs.raku.org/type/Seq.html)</a>). Depending on your previous language experience your reaction to this idea will be either “Of course!” or “This is so wrong!”</p>
</div>
<div class="paragraph">
<p>The <code>.permutations</code> method produces a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) of sublists where each one represents a unique ordering of all the elements of the original:</p>
</div>
<div class="paragraph">
<p>[<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) 可以是另一个 [<code>List</code>](<a href="https://docs.raku.org/type/List.html)（或" class="bare">https://docs.raku.org/type/List.html)（或</a> [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html)）的元素。根据你之前的语言经验，你对此想法的反应将是“当然！”或“这是错误的！”" class="bare">https://docs.raku.org/type/Seq.html)）的元素。根据你之前的语言经验，你对此想法的反应将是“当然！”或“这是错误的！”</a></p>
</div>
<div class="paragraph">
<p><code>.permutations</code> 方法生成一个 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 的子列表，其中每个子列表代表原始元素的唯一排序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list = ( 1, 2, 3 );
say $list.permutations;
put &#34;There are {$list.permutations.elems} elements&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output shows a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) of [<code>List</code>](<a href="https://docs.raku.org/type/List.html)s" class="bare">https://docs.raku.org/type/List.html)s</a> where each element is another [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>):</p>
</div>
<div class="paragraph">
<p>输出显示[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)的"><code>列表</code></a>(<a href="https://docs.raku.org/type/List.html)，其中每个元素是另一个"><code>列表</code></a>(<a href="https://docs.raku.org/type/List.html)：" class="bare">https://docs.raku.org/type/List.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))
There are 6 elements</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can make these directly. This [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) has two elements, both of which are [<code>List</code>](<a href="https://docs.raku.org/type/List.html)s" class="bare">https://docs.raku.org/type/List.html)s</a>:</p>
</div>
<div class="paragraph">
<p>你可以直接制作这些。此[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)有两个元素，两个元素都是"><code>列表</code></a>(<a href="https://docs.raku.org/type/List.html)：" class="bare">https://docs.raku.org/type/List.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list = ( &lt;a b&gt;, &lt;1 2&gt; );
put $list.elems;             # 2
say $list;                   # ((a b) (1 2))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can explicitly create the sublists with parentheses:</p>
</div>
<div class="paragraph">
<p>你可以使用括号显式创建子列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list = ( 1, 2, (&#39;a&#39;, &#39;b&#39;) );
put $list.elems;  # 3
say $list;        # (1 2 (a b))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can separate sublists with semicolons. Elements between <code>;</code> end up in the same sublist, although sublists of a single element are just that element:</p>
</div>
<div class="paragraph">
<p>你可以使用分号分隔子列表。<code>;</code> 之间的元素最终在同一个子列表中，尽管单个元素的子列表只是该元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list = ( 1; &#39;Hamadryas&#39;; &#39;a&#39;, &#39;b&#39; );
put $list.elems;       # 3
say $list;             # (1 2 (a b))
put $list.[0].^name;   # Int
put $list.[1].^name;   # Str
put $list.[*-1].^name; # List</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_flattening_lists">3.5.5. Flattening Lists</h4>
<div class="paragraph">
<p>You may be more comfortable with flat [<code>List</code>](<a href="https://docs.raku.org/type/List.html)s" class="bare">https://docs.raku.org/type/List.html)s</a>, if you want a bunch of elements with no structure. <code>.flat</code> extracts all the elements of the sublist and makes it a single-level <strong>simple list</strong>. The flat [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) created here has four elements instead of three:</p>
</div>
<div class="paragraph">
<p>如果你想要一堆没有结构的元素，你可能会更喜欢平面[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)。" class="bare">https://docs.raku.org/type/List.html)。</a> <code>.flat</code> 提取子列表的所有元素，并使其成为单级简单列表。这里创建的平面[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)有四个元素而不是三个：" class="bare">https://docs.raku.org/type/List.html)有四个元素而不是三个：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list = ( 1, 2, (&#39;a&#39;, &#39;b&#39;) );
put $list.elems;  # 3

my $flat = $list.flat;
put $flat.elems;  # 4
say $flat;        # (1 2 a b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This works all the way down into sublists of sublists (of sublists…). Here, the last element is a sublist that has a sublist. The flat [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) ends up with six elements:</p>
</div>
<div class="paragraph">
<p>这一直有效地进入子列表（子列表…​…​）的子列表中。这里，最后一个元素是一个具有子列表的子列表。平面[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)最终有六个元素：" class="bare">https://docs.raku.org/type/List.html)最终有六个元素：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list = ( 1, 2, (&#39;a&#39;, &#39;b&#39;, (&#39;X&#39;, &#39;Z&#39;) ) );
put $list.elems;  # 3

my $flat = $list.flat;
put $flat.elems;  # 6
say $flat;        # (1 2 a b X Z)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes you don’t want a sublist to flatten. In that case you can itemize it by putting a <code>$</code> in front of the parentheses. An itemized element resists flattening:</p>
</div>
<div class="paragraph">
<p>有时你不希望子列表变平。在这种情况下，你可以通过在圆括号前加一个 <code>$</code> 来项化它。项化的元素抵制展平：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list = ( 1, 2, (&#39;a&#39;, &#39;b&#39;, $(&#39;X&#39;, &#39;Z&#39;) ) );
put $list.elems;  # 3

my $flat = $list.flat;
put $flat.elems;  # 5
say $flat;        # (1 2 a b (X Z))</code></pre>
</div>
</div>
<div class="paragraph">
<p>A [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) held in a scalar variable is already itemized and does not flatten:</p>
</div>
<div class="paragraph">
<p>标量变量中保存的[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)已项化，并未展平：" class="bare">https://docs.raku.org/type/List.html)已项化，并未展平：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly-genus = (&#39;Hamadryas&#39;, &#39;Sostrata&#39;, &#39;Junonia&#39;);

my $list = ( 1, 2, (&#39;a&#39;, &#39;b&#39;, $butterfly-genus ) );
my $flat = $list.flat;
say $flat;        # (1 2 a b (Hamadryas Sostrata Junonia))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then what do you do to un-itemize something? You can use the prefix <code>|</code> to flatten it. This decontainerizes thethingy:</p>
</div>
<div class="paragraph">
<p>那么你怎么做才能不项化一些事情呢？你可以使用前缀 <code>|</code> 压扁它。这使得这些东西解容器化了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly-genus = (&#39;Hamadryas&#39;, &#39;Sostrata&#39;, &#39;Junonia&#39;);

my $list = ( 1, 2, (&#39;a&#39;, &#39;b&#39;, |$butterfly-genus ) );
my $flat = $list.flat;
put $flat.elems;  # 7
say $flat;        # (1 2 a b Hamadryas Sostrata Junonia)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>|</code> takes certain types ([<code>Capture</code>](<a href="https://docs.raku.org/type/Capture.html" class="bare">https://docs.raku.org/type/Capture.html</a>), [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>), [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>), [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>), and [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html)" class="bare">https://docs.raku.org/type/Hash.html)</a>) and flattens them. You’ll see more of this in [Chapter 11](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch11.html#camelia-subroutines" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch11.html#camelia-subroutines</a>). It actually creates a [<code>Slip</code>](<a href="https://docs.raku.org/type/Slip.html" class="bare">https://docs.raku.org/type/Slip.html</a>), which is a type of [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) that automatically flattens into an outer list. You could coerce your [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) with <code>.Slip</code> to get the same thing:</p>
</div>
<div class="paragraph">
<p><code>|</code> 接收某些类型（[<code>Capture</code>](<a href="https://docs.raku.org/type/Capture.html)，"><code>Pair</code></a>(<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>), [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>), [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>), and [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html)并展平它们。你将在第11章中看到更多内容。它实际上创建了一个" class="bare">https://docs.raku.org/type/Hash.html)并展平它们。你将在第11章中看到更多内容。它实际上创建了一个</a> [<code>Slip</code>](<a href="https://docs.raku.org/type/Slip.html)，它是一种" class="bare">https://docs.raku.org/type/Slip.html)，它是一种</a> [<code>List</code>](<a href="https://docs.raku.org/type/List.html)，可以自动展平到外部列表中。你可以使用" class="bare">https://docs.raku.org/type/List.html)，可以自动展平到外部列表中。你可以使用</a> <code>.Slip</code> 强制你的 [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) 来获得相同的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list = ( 1, 2, (&#39;a&#39;, &#39;b&#39;, $butterfly-genus.Slip ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the elements in <code>$butterfly-genus</code> are at the same level as the other elements in its sublist:</p>
</div>
<div class="paragraph">
<p>现在 <code>$butterfly-genus</code> 中的元素与其子列表中的其他元素处于同一级别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1 2 (a b Hamadryas Sostrata Junonia))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>slip</code> routine does the same thing:</p>
</div>
<div class="paragraph">
<p><code>slip</code> 例程做同样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list = ( 1, 2, (&#39;a&#39;, &#39;b&#39;, slip $butterfly-genus ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>These [<code>Slip</code>](<a href="https://docs.raku.org/type/Slip.html)s" class="bare">https://docs.raku.org/type/Slip.html)s</a> will be handy later in this chapter.</p>
</div>
<div class="paragraph">
<p>这些[<code>Slip</code>](<a href="https://docs.raku.org/type/Slip.html)将在本章后面方便使用。" class="bare">https://docs.raku.org/type/Slip.html)将在本章后面方便使用。</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_interesting_sublists">3.5.6. Interesting Sublists</h4>
<div class="paragraph">
<p>Here’s something quite useful. The <code>.rotor</code> method breaks up a flat [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) into a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) of [<code>List</code>](<a href="https://docs.raku.org/type/List.html)s" class="bare">https://docs.raku.org/type/List.html)s</a> where each sublist has the number of elements you specify. You can get five sublists of length 2:</p>
</div>
<div class="paragraph">
<p>这儿有一些非常有用的东西。 <code>.rotor</code> 方法将平面[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)拆分为"><code>列表</code></a>(<a href="https://docs.raku.org/type/List.html)的"><code>列表</code></a>(<a href="https://docs.raku.org/type/List.html)，其中每个子列表都包含你指定的元素数。你可以获得" class="bare">https://docs.raku.org/type/List.html)，其中每个子列表都包含你指定的元素数。你可以获得</a> 5 个长度为 2 的子列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list = 1 .. 10;
my $sublists = $list.rotor: 2;
say $sublists;        # ((1 2) (3 4) (5 6) (7 8) (9 10))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is especially nice to iterate over multiple items at the same time. It grabs the number of items that you specify and supplies them as a single [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>):</p>
</div>
<div class="paragraph">
<p>这对于同时迭代多个项尤其有用。它会抓取你指定的项数并将它们作为单个[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)提供：" class="bare">https://docs.raku.org/type/List.html)提供：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list = 1 .. 10;
for $list.rotor: 3 {
    .say
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default it only grabs exactly the number you specify. If there aren’t enough elements it doesn’t give you a partial [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>). This output is missing <code>10</code>:</p>
</div>
<div class="paragraph">
<p>默认情况下，它只捕获你指定的数字。如果没有足够的元素，它不会给你一个部分[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)。此输出没有" class="bare">https://docs.raku.org/type/List.html)。此输出没有</a> <code>10</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1 2 3)
(4 5 6)
(7 8 9)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want a short sublist at the end, the <code>:partial</code> adverb will do that:</p>
</div>
<div class="paragraph">
<p>如果你想在结尾处有一个简短的子列表，那么 <code>:partial</code> 副词将会这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list = 1 .. 10;
for $list.rotor: 3, :partial {
    .say
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now there’s a short list in the last iteration:</p>
</div>
<div class="paragraph">
<p>现在在最后一次迭代中有一个短的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1 2 3)
(4 5 6)
(7 8 9)
(10)</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 6.11Use <code>lines</code> and <code>.rotor</code> to read chunks of three lines from input. Output the middle line in each chunk.</p>
</div>
<div class="paragraph">
<p>练习6.11 使用 <code>lines</code> 和 <code>.rotor</code> 从输入中读取三行的块。输出每个块的中间行。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_combining_lists">3.6. Combining Lists</h3>
<div class="paragraph">
<p>Making and manipulating [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html)s" class="bare">https://docs.raku.org/type/Positional.html)s</a> is only the first level of your programming skill. Raku has several facilities to manage, combine, and process multiple [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) things together.</p>
</div>
<div class="paragraph">
<p>制作和操作 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) 只是编程技巧的第一级。 Raku 有几个工具来管理，组合和处理多个 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) 事物。</p>
</div>
<div class="sect3">
<h4 id="_the_zip_operator_z">3.6.1. The Zip Operator, Z</h4>
<div class="paragraph">
<p>The <code>Z</code> operator takes elements from the same positions in the lists you provide and creates sublists from them:</p>
</div>
<div class="paragraph">
<p><code>Z</code> 运算符从你提供的列表中的相同位置获取元素，并从中创建子列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &lt;1 2 3&gt; Z &lt;a b c&gt;;  # ((1 a) (2 b) (3 c))</code></pre>
</div>
</div>
<div class="paragraph">
<p>When it reaches the end of the shortest list, it stops. It doesn’t matter which list is shorter:</p>
</div>
<div class="paragraph">
<p>当它到达最短列表的末尾时，它会停止。哪个列表更短并不重要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &lt;1 2 3&gt; Z &lt;a b&gt;;  # ((1 a) (2 b))

say &lt;1 2&gt; Z &lt;a b c&gt;;  # ((1 a) (2 b))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>zip</code> routine does the same thing:</p>
</div>
<div class="paragraph">
<p><code>zip</code> 例程做同样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say zip( &lt;1 2 3&gt;, &lt;a b&gt; );  # ((1 a) (2 b))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This one gives the same output because <code>$letters</code> doesn’t have enough elements to make more sublists:</p>
</div>
<div class="paragraph">
<p>这个给出相同的输出，因为 <code>$letters</code> 没有足够的元素来制作更多的子列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $numbers = ( 1 .. 10 );
my $letters = ( &#39;a&#39; .. &#39;c&#39; );

say @$numbers Z @$letters; # ((1 a) (2 b) (3 c))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can do it with more than two lists:</p>
</div>
<div class="paragraph">
<p>你可以使用两个以上的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $numbers = ( 1 .. 3 );
my $letters = ( &#39;a&#39; .. &#39;c&#39; );
my $animals = &lt; 🐈 🐇 🐀 &gt;; # cat rabbit rat
say @$numbers Z @$letters Z @$animals;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each sublist has three elements:</p>
</div>
<div class="paragraph">
<p>每个子列表都有三个元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">((1 a 🐈)(2 b 🐇)(3 c 🐀))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>zip</code> does the same thing as <code>Z</code>:</p>
</div>
<div class="paragraph">
<p><code>zip`和 `Z</code> 做同样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say zip @$numbers, @$letters, @$animals;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use it with <code>for</code>:</p>
</div>
<div class="paragraph">
<p>你可以将它和 <code>for</code> 一块使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for zip @$numbers, @$letters, @$animals {
    .say;
}


(1 a 🐈)
(2 b 🐇)
(3 c 🐀)</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 6.12Use the <code>Z</code> operator to make an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) of [<code>List</code>](<a href="https://docs.raku.org/type/List.html)s" class="bare">https://docs.raku.org/type/List.html)s</a> that pair each letter with its position in the alphabet.</p>
</div>
<div class="paragraph">
<p>练习6.12 使用 <code>Z</code> 运算符创建一个[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)的"><code>数组</code></a>(<a href="https://docs.raku.org/type/Array.html)，将每个字母与其在字母表中的位置配对。" class="bare">https://docs.raku.org/type/Array.html)，将每个字母与其在字母表中的位置配对。</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_the_cross_operator_x">3.6.2. The Cross Operator, X</h4>
<div class="paragraph">
<p>The <code>X</code> cross operator combines every element of one [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) with every element of another:</p>
</div>
<div class="paragraph">
<p><code>X</code> 交叉运算符将一个 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) 的每个元素与另一个 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) 的每个元素组合在一起：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @letters = &lt;A B C&gt;;
my @digits  = 1, 2, 3;

my @crossed = @letters X @digits;
say @crossed;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output shows that every letter was paired with every number:</p>
</div>
<div class="paragraph">
<p>输出显示每个字母都与每个数字配对：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[(A 1) (A 2) (A 3) (B 1) (B 2) (B 3) (C 1) (C 2) (C 3)]</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 6.13 A deck of 52 playing cards has four suits, ♣ ♡ ♠ ♢, each with 13 cards, 2 to 10, jack, queen, king, and ace. Use the cross operator to make a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) of [<code>List</code>](<a href="https://docs.raku.org/type/List.html)s" class="bare">https://docs.raku.org/type/List.html)s</a> that represents each card. Output the list of cards so all the cards of one suit show up on the same line.</p>
</div>
<div class="paragraph">
<p>练习6.13 一副 52 张的扑克牌有四套花色，♣♡♠♢，每套有 13 张纸牌，2 到 10，J，Q，K，小王和大王。使用交叉运算符创建代表每张纸牌的[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)的"><code>列表</code></a>(<a href="https://docs.raku.org/type/List.html)。输出纸牌的列表，以便一套花色的所有纸牌显示在同一条线上。" class="bare">https://docs.raku.org/type/List.html)。输出纸牌的列表，以便一套花色的所有纸牌显示在同一条线上。</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_the_hyperoperators">3.6.3. The Hyperoperators</h4>
<div class="paragraph">
<p>Instead of combining [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html)s" class="bare">https://docs.raku.org/type/Positional.html)s</a>, you can operate on pairs of them to create a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) of the results. The hyperoperators can do that. Surround the <code>+</code> operator with <code>&lt;&lt;&gt;&gt;</code>. This numerically adds the first element of <code>@right</code> to the first element of <code>@left</code>. The result of that addition becomes the first element of the result. This happens for the second elements, then the third, and so on:</p>
</div>
<div class="paragraph">
<p>你可以对其中的一对进行操作，而不是组合 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html)，以创建结果"><code>列表</code></a>(<a href="https://docs.raku.org/type/List.html)。" class="bare">https://docs.raku.org/type/List.html)。</a> hyperoperators 可以做到这一点。使用 <code>&lt;&lt;&gt;&gt;</code> 包围 <code>+</code> 运算符。这在数字上将 <code>@right</code> 的第一个元素加到 <code>@left</code> 的第一个元素中。相加的结果成为结果的第一个元素。这发生在第二个元素上，然后是第三个元素上，依此类推：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @right = 1, 2, 3;
my @left  = 5, 9, 4;

say @left &lt;&lt;+&gt;&gt; @right;  # [6 11 7]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pick a different operator and follow the same process. The concatenation operator joins the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) versions of each element:</p>
</div>
<div class="paragraph">
<p>选择一个不同的运算符并按照相同的过程。连接运算符连接每个元素的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)版本：" class="bare">https://docs.raku.org/type/Str.html)版本：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @right = 1, 2, 3;
my @left  = 5, 9, 4;

say @left &lt;&lt;~&gt;&gt; @right;  # [51 92 43]</code></pre>
</div>
</div>
<div class="paragraph">
<p>If one of the sides has fewer elements the <code>&lt;&lt;&gt;&gt;</code> hyper recycles elements from the shorter one. It doesn’t matter which side the shorter list is on. Here, <code>@left</code> has fewer elements. When it’s time to operate on the third elements the hyper starts at the beginning of <code>@left</code> again to reuse <code>11</code>:</p>
</div>
<div class="paragraph">
<p>如果其中一边具有较少的元素，则 <code>&lt;&lt;&gt;&gt;</code>  hyper 会从较短的元素中循环该元素。短列表的哪一方无关紧要。在这里，<code>@left</code> 有更少的元素。当是时候对第三个元素进行操作时，hyper 会在 <code>@left</code> 的开头再次开始重用 <code>11</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @right =  3,  5, 8;
my @left  = 11, 13;

say @left &lt;&lt;+&gt;&gt; @right;  # [14 18 19]
say @right &lt;&lt;+&gt;&gt; @left;  # [14 18 19]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Point the angle brackets toward the inside to insist that both sides have the same number of elements. You’ll get an error when the sizes don’t match:</p>
</div>
<div class="paragraph">
<p>将尖括号指向内侧以确保两侧具有相同数量的元素。当大小不匹配时，你会收到错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @left &gt;&gt;+&lt;&lt; @right;  # Error!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another option is to allow one side to be smaller than the other but to not recycle elements. If both sets of angle brackets point away from the shorter side then the hyper does not reuse elements from the shorter side:</p>
</div>
<div class="paragraph">
<p>另一种选择是允许一侧比另一侧小但不循环元素。如果两组尖括号都指向较短的一侧，那么 hyper 不会重用短边的元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @long  =  3,  5, 8;
my @short = 11, 13;

say @short &gt;&gt;+&gt;&gt; @long;    # [14 18]    no recycling
say @long  &gt;&gt;+&gt;&gt; @short;   # [14 18 19]

say @short &lt;&lt;+&lt;&lt; @long;    # [14 18 19]
say @long  &lt;&lt;+&lt;&lt; @short;   # [14 18]    no recycling</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of the double angle brackets you can use the fancier <code>»«</code> versions:</p>
</div>
<div class="paragraph">
<p>你可以使用更漂亮的 <code>»«</code> 版本代替双角括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @long  =  3,  5, 8;
my @short = 11, 13;

say @short  «+» @long;    # [14 18 19]
say @short  »+« @long;    # Error

say @short  »+» @long;    # [14 18]  no recycling
say @long   »+» @short;   # [14 18 19]

say @short  «+« @long;    # [14 18 19]
say @long   «+« @short;   # [14 18]  no recycling</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_reduction_operator">3.6.4. The Reduction Operator</h4>
<div class="paragraph">
<p>The reduction operator is a bit different from <code>Z</code>, <code>X</code>, or the hyperoperators. It turns a [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) into a single value by operating on two elements at a time to turn them into one element.</p>
</div>
<div class="paragraph">
<p>The prefix <code>[]</code> is the reduction operator. On the inside you put a binary operator. It applies that operator to the first two elements of its [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) to get a single value. It replaces those two values with the result; this makes the input one element shorter. It keeps doing this until there’s one element left. That’s the final value.</p>
</div>
<div class="paragraph">
<p>Here’s a quick way to sum some numbers:</p>
</div>
<div class="paragraph">
<p>简化运算符与 <code>Z</code>，<code>X</code> 或超运算符略有不同。它通过一次操作两个元素将 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) 转换为单个值，将它们转换为单个值。</p>
</div>
<div class="paragraph">
<p>前缀 <code>[]</code> 是简化运算符。在里面你放了一个二元运算符。它将该运算符应用于其 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) 的前两个元素以获取单个值。它用结果替换这两个值;这使得输入一个元素更短。它一直这样做，直到剩下一个元素。这是最终值。</p>
</div>
<div class="paragraph">
<p>这是一个快速的方法来合计一些数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum = [+] 1 .. 10;  # 55</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the same as this expression if you write out the steps:</p>
</div>
<div class="paragraph">
<p>如果你写出以下步骤，则与此表达式相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(((((((((1 + 2) + 3) + 4) + 5) + 6) + 7) + 8) + 9) + 10)</code></pre>
</div>
</div>
<div class="paragraph">
<p>And to do a factorial:</p>
</div>
<div class="paragraph">
<p>计算阶乘：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $factorial = [*] 1 .. 10;  # 3628800</code></pre>
</div>
</div>
<div class="paragraph">
<p>Are all the values <code>True</code>? Apply the <code>&amp;&amp;</code> to the first two elements and replace them with the result until there’s one element left. At the end use the <code>?</code> ( or <code>.so</code>) to coerce the result to a Boolean:</p>
</div>
<div class="paragraph">
<p>所有的值都是 <code>True</code> 吗？将 <code>&amp;&amp;</code> 应用于前两个元素并将其替换为结果，直到剩下一个元素。最后使用 <code>?</code>  （或 <code>.so</code> ）将结果强制转换为布尔值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $condition = ?( [&amp;&amp;] 1 .. 10 );  # True
my $condition = ?( [&amp;&amp;] ^10 );      # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s a binary <code>max</code> operator too:</p>
</div>
<div class="paragraph">
<p>还有一个二元的 <code>max</code> 运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $max = 1 max 137; # 137;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can put that inside the brackets. This makes one pass through the elements to discover the largest numeric value:</p>
</div>
<div class="paragraph">
<p>你可以把它放在方括号内。这使得一个遍历元素以发现最大的数值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $max = [max] @numbers</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to use your own subroutine, use an extra set of braces and the <code>&amp;</code> sigil to make it look like an operator:</p>
</div>
<div class="paragraph">
<p>如果你想使用自己的子程序，请使用额外的方括号和 <code>&amp;</code> sigil使其看起来像一个运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub longest {
    $^a.chars &gt; $^b.chars ?? $^a !! $^b;
}

my $longest =
    [[&amp;longest]] &lt;Hamadryas Rhamma Asterocampa Tanaecia&gt;;

put &#34;Longest is $longest&#34;; # Longest is Asterocampa</code></pre>
</div>
</div>
<div class="paragraph">
<p>That trick works to convert a subroutine to a binary operator:</p>
</div>
<div class="paragraph">
<p>该技巧可以将子例程转换为二元运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$first [&amp;longest] $second</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_filtering_lists">3.7. Filtering Lists</h3>
<div class="paragraph">
<p>The <code>.grep</code> method filters a [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) to get the elements that satisfy your condition. Any element that satisfies the condition becomes part of the new [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>):</p>
</div>
<div class="paragraph">
<p><code>.grep</code> 方法过滤 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) 以获取满足条件的元素。满足条件的任何元素都将成为新 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 的一部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $evens = (0..10).grep: * %% 2;  # (0 2 4 6 8 10)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) works too. The current element shows up in <code>$_</code>:</p>
</div>
<div class="paragraph">
<p>[<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) 也有效。当前元素出现在 `$_`中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $evens = (0..10).grep: { $_ %% 2 };  # (0 2 4 6 8 10)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If your condition is only a type <code>.grep</code> smart matches the current element against that type:</p>
</div>
<div class="paragraph">
<p>如果你的条件只是一种类型 <code>.grep</code>  将当前元素与该类型智能匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $allomorphs = &lt;137 2i 3/4 a b&gt;;
my $int-strs = $allomorphs.grep: IntStr;      # (137)
my $rat-strs = $allomorphs.grep: RatStr;      # (3/4)
my $img-strs = $allomorphs.grep: ComplexStr;  # (2i)
my $strs     = $allomorphs.grep:  Str;        # (a b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember that a smart match against a type includes matching anything that type is based on. Trying to get all the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> finds everything since the <code>&lt;&gt;</code> creates allomorphs and every element matches [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>):</p>
</div>
<div class="paragraph">
<p>请记住，针对类型的智能匹配包括匹配基于类型的任何内容。试图得到所有的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)会找出所有的东西，因为" class="bare">https://docs.raku.org/type/Str.html)会找出所有的东西，因为</a> <code>&lt;&gt;</code> 创建了同质异形并且每个元素都匹配[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)：" class="bare">https://docs.raku.org/type/Str.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $everything = $allomorphs.grep: Str; # (1 2i 3/4 a b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.does</code> method checks if the element has a role. Here, you want the elements that <strong>don’t</strong> do that role—if it can be a number, you don’t want it:</p>
</div>
<div class="paragraph">
<p><code>.does</code> 方法检查元素是否具有角色。在这里，你需要该元素不执行该角色 - 如果它可以是数字，则你不需要它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $just-str = $allomorphs.grep: { ! .does(Numeric) };  # (a b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can specify some adverbs with <code>.grep</code>. The <code>:v</code> adverb (for “values”) gives the same list you get without it:</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>.grep</code> 指定一些副词。 <code>:v</code> 副词（对于“值”）给出了没有它的相同列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $int-strs = $allomorphs.grep: IntStr, :v;  # same thing</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>:k</code> adverb (for key) gives the positions of the matching elements. This returns <code>1</code> because that’s the index of the matching element:</p>
</div>
<div class="paragraph">
<p><code>:k</code> 副词（用于键）给出匹配元素的位置。这返回 <code>1</code>，因为这是匹配元素的索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $int-strs = $allomorphs.grep: ComplexStr, :k;  # (1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can get both the key and the value with <code>:kv</code>. You get a flat [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) in key-value order:</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>:kv</code> 获取键和值。你可以按键值顺序获得一个平面[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)：" class="bare">https://docs.raku.org/type/List.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $int-strs = $allomorphs.grep: RatStr, :kv;  # (2 3/4)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If multiple elements match you get a longer [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>). The even positions are still keys:</p>
</div>
<div class="paragraph">
<p>如果多个元素匹配，则获得更长的 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html)。偶数位置仍是键：" class="bare">https://docs.raku.org/type/Seq.html)。偶数位置仍是键：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$allomorphs.grep: { ! .does(Numeric) }, :kv;  # (3 a 4 b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s also a routine form of <code>grep</code>. The [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) comes after the matcher:</p>
</div>
<div class="paragraph">
<p>还有一种例程形式的 <code>grep</code>。[<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) 在匹配器之后：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $matched = grep IntStr, @$allomorphs;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_transforming_a_list">3.8. Transforming a List</h3>
<div class="paragraph">
<p><code>.map</code> creates a new [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) based on an existing one by creating zero or more elements from each input element. Here’s an example that returns a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) of squares. <code>.map</code> can take a [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) or [<code>WhateverCode</code>](<a href="https://docs.raku.org/type/WhateverCode.html" class="bare">https://docs.raku.org/type/WhateverCode.html</a>) (although that’s a lot of `*`s):</p>
</div>
<div class="paragraph">
<p><code>.map`通过从每个输入元素创建零个或多个元素，基于现有的 [`Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 创建新的 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html)。这是一个返回平方的" class="bare">https://docs.raku.org/type/Seq.html)。这是一个返回平方的</a> [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 的示例。 <code>.map</code> 可以接收一个 [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) 或 [<code>WhateverCode</code>](<a href="https://docs.raku.org/type/WhateverCode.html)（虽然那有很多" class="bare">https://docs.raku.org/type/WhateverCode.html)（虽然那有很多</a> <code>*</code> 号 ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $squares = (1..5).map: { $_ ** 2 }; # (0 1 4 9 16 25)
my $squares = (1..5).map: * ** 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s a routine version of <code>map</code> that does the same :</p>
</div>
<div class="paragraph">
<p>有一个例程版本的 <code>map</code> 做同样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $even-squares = map { $_ ** 2 }, @(1..5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Perhaps you want to lowercase everything:</p>
</div>
<div class="paragraph">
<p>也许你想要将字符串都变成小写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $lowered = $words.map: *.lc;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You might return no output elements, but you can’t merely return the empty [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) because it will show up as an element in the new [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>). In this example the <code>|()</code> indicates an empty [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) slipped into the bigger [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>):</p>
</div>
<div class="paragraph">
<p>你可能不返回任何输出元素，但你不能仅返回空[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)，因为它将显示为新"><code>列表</code></a>(<a href="https://docs.raku.org/type/List.html)中的元素。在这个例子中，" class="bare">https://docs.raku.org/type/List.html)中的元素。在这个例子中，</a><code>|()</code> 表示一个空[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)滑入更大的">列表</a>(<a href="https://docs.raku.org/type/List.html)：" class="bare">https://docs.raku.org/type/List.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $even-squares = (0..9).map: { $_ %% 2 ?? $_**2 !! |()  }; # (0 4 16 36 64)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use these methods together. This selects the even numbers then squares them:</p>
</div>
<div class="paragraph">
<p>你可以一起使用这些方法。这将选择偶数然后将它们平方：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $squares = $allomorphs
    .grep( { ! .does(Numeric) } )
    .map(  { $_ %% 2 ?? $_**2 !! |()  } );</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sorting_lists">3.9. Sorting Lists</h3>
<div class="paragraph">
<p>Often you want a list in some order. Perhaps that’s increasing numerical or alphabetic order, by the length of the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a>, or anything else that makes sense for you. You can do this with <code>.sort</code>:</p>
</div>
<div class="paragraph">
<p>通常你想要一个按顺序排列的列表。也许以数字递增或字母顺序，按[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)的长度，或任何其他对你有意义的顺序。你可以使用" class="bare">https://docs.raku.org/type/Str.html)的长度，或任何其他对你有意义的顺序。你可以使用</a> <code>.sort</code> 执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sorted = ( 7, 5, 9, 3, 2 ).sort;   # (2 3 5 7 9)

my $sorted = &lt;p e r l 6&gt;.sort;         # (6 e l p r)</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, <code>.sort</code> compares each pair of elements with <code>cmp</code>. If the two elements are numbers, it compares them as numbers. If it thinks they are [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a>, it compares them as such. Here’s a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) comparison that may surprise you the first time you see it (and annoy you hereafter):</p>
</div>
<div class="paragraph">
<p>默认情况下，<code>.sort</code> 用  <code>cmp</code> 比较每对元素。如果这两个元素是数字，则将它们作为数字进行比较。如果它认为它们是[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)，那么就比较它们。这是一个"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)比较，你可能会在第一次看到它时感到惊讶（并在此后惹恼你）：" class="bare">https://docs.raku.org/type/Str.html)比较，你可能会在第一次看到它时感到惊讶（并在此后惹恼你）：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sorted = qw/1 11 10 101/.sort;     # (1 10 101 11)</code></pre>
</div>
</div>
<div class="paragraph">
<p>What happened? Since you constructed the list with <code>qw</code>, you got a list of [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) objects. These compare character by character, so the text <code>101</code> is “less than” the text <code>11</code>. This isn’t dictionary sorting, though. Try it with upper- and lowercase letters:</p>
</div>
<div class="paragraph">
<p>发生了什么？由于你使用 <code>qw</code> 构建了列表，因此你获得了[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)对象的列表。这些字符逐字符比较，因此文本`101`" class="bare">https://docs.raku.org/type/Str.html)对象的列表。这些字符逐字符比较，因此文本`101`</a> “小于”文本 <code>11</code>。但这不是字典排序。尝试用大写和小写字母：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sorted = qw/a A b B c C/.sort;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Did you get what you expected? Some of you probably guessed incorrectly. The lowercase code points come after the uppercase ones, for they are greater:</p>
</div>
<div class="paragraph">
<p>你得到了你的期望吗？你们中的一些人可能猜错了。小写代码点位于大写代码之后，因为它们更大：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(A B C a b c)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>cmp</code> sorts by the code number in the Universal Character Set (UCS). If you are used to ASCII, the code number is the same thing. Above ASCII, you may not get what you expect.</p>
</div>
<div class="paragraph">
<p>`cmp `按通用字符集（UCS）中的代码编号排序。如果你习惯使用 ASCII，则代码编号是相同的东西。在 ASCII 之上，你可能无法得到你期望的结果。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is a <code>.collate</code> method that can handle Unicode collation for language-specific sorting, but it’s experimental.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>You can tell <code>.sort</code> how to compare the elements. For dictionary order (so case does not matter), you have to do a bit more work. The <code>.sort</code> method can take a routine that decides how to sort. Start with the default `.sort`fully written out with its comparison:</p>
</div>
<div class="paragraph">
<p>有一种 <code>.collate</code> 方法可以处理特定于语言的排序的 Unicode 排序规则，但它是实验性的。</p>
</div>
<div class="paragraph">
<p>你可以告诉 <code>.sort</code> 如何比较元素。对于字典顺序（所以大小写无关紧要），你必须做更多的工作。 <code>.sort</code> 方法可以采用一个例程来决定如何排序。从默认的 <code>.sort</code> 完整写出来与其比较开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sorted = qw/a A b B c C/.sort: { $^a cmp $^b }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also write that with two [<code>Whatever</code>](<a href="https://docs.raku.org/type/Whatever.html)s" class="bare">https://docs.raku.org/type/Whatever.html)s</a> so you don’t have to type the braces. This is the same thing:</p>
</div>
<div class="paragraph">
<p>你也可以使用两个 [<code>Whatever</code>](<a href="https://docs.raku.org/type/Whatever.html" class="bare">https://docs.raku.org/type/Whatever.html</a>) 来编写它，这样你就不必键入花括号。这是一样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sorted = qw/a A b B c C/.sort: * cmp *</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to compare them case insensitively, you can call the <code>.fc</code> method to do a proper case folding:</p>
</div>
<div class="paragraph">
<p>如果你想不区分大小写的比较它们，你可以调用 <code>.fc</code> 方法进行正确的大小写折叠：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sorted = qw/a A b B c C/.sort: *.fc cmp *.fc</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you get the order that ignores case:</p>
</div>
<div class="paragraph">
<p>现在你得到忽略大小写的顺序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(A a B b C c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, if you want to make the same transformation on both elements, you don’t need to write it twice; <code>.sort</code> will figure it out. It saves the result and reuses it for all comparisons. This means that Raku has a builtinSchwartzian transform (a Perl 5 idiom for a cached-key sort)!</p>
</div>
<div class="paragraph">
<p>但是，如果要对两个元素进行相同的转换，则不需要将其写两次; <code>.sort</code> 会弄清楚的。它保存结果并重复使用它进行所有比较。这意味着 Raku 具有内置的 Schwartzian 变换（用于缓存按键排序的 Perl 5 惯用法）！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sorted = qw/a A b B c C/.sort: *.fc;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s a problem with <code>cmp</code>, though. The order of elements you get depends on the type and order of elements in your input:</p>
</div>
<div class="paragraph">
<p>但是 <code>cmp</code> 存在问题。你获得的元素的顺序取决于输入中元素的类型和顺序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for ^5 {
    my @numbers = (1, 2, 11, &#39;21&#39;, 111, 213, &#39;7&#39;, 77).pick: *;
    say @numbers.sort;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.pick</code> method randomly chooses from the [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) the number of elements you specify. The <code>*</code> translates to the number of elements in the [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>). The effect is a shuffled [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) of the same elements. Some of these are [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html)s" class="bare">https://docs.raku.org/type/Int.html)s</a> and some are [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a>. Depending on which element shows up where, they sort differently:</p>
</div>
<div class="paragraph">
<p><code>.pick</code> 方法从[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)中随机选择你指定的元素数。" class="bare">https://docs.raku.org/type/List.html)中随机选择你指定的元素数。</a> <code>*</code> 转换为[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)中的元素数。效果是相同元素的混乱列表。其中一些是"><code>整数</code></a>(<a href="https://docs.raku.org/type/Int.html)，一些是"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)。根据哪个元素显示在哪里，它们的排序方式不同：" class="bare">https://docs.raku.org/type/Str.html)。根据哪个元素显示在哪里，它们的排序方式不同：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1 2 11 111 21 77 213 7)
(1 2 11 111 21 213 7 77)
(1 2 11 21 77 111 213 7)
(1 2 11 111 21 7 77 213)
(1 2 11 21 77 111 213 7)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use <code>leg</code> (*l*ess-*e*qual-*g*reater) if you want to order these by their [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) values every time:</p>
</div>
<div class="paragraph">
<p>如果你希望每次按[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)值排序，请使用" class="bare">https://docs.raku.org/type/Str.html)值排序，请使用</a> <code>leg</code>（小于等于大于）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @numbers.sort: * leg *;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want numbers, use <code>&lt;⇒</code>:</p>
</div>
<div class="paragraph">
<p>如果你想按数字值排序，请使用 <code>&lt;⇒</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @numbers.sort: * &lt;=&gt; *;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can coerce the input to the type you want:</p>
</div>
<div class="paragraph">
<p>或者，你可以将输入强制转换为所需的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @numbers.sort: +*;  # numbers

say @numbers.sort: ~*;  # strings</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, there’s a routine version of <code>.sort</code>. It has a single-argument form that takes a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) and a two-argument form that takes a sort routine and a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>):</p>
</div>
<div class="paragraph">
<p>最后，还有 <code>.sort</code> 的例程版本。它有一个单参数形式，它接受一个[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)和一个带有排序例程和"><code>列表</code></a>(<a href="https://docs.raku.org/type/List.html)的双参数形式：" class="bare">https://docs.raku.org/type/List.html)的双参数形式：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sorted = sort $list;
my $sorted = sort *.fc, $list;</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 6.14Represent a deck of cards as a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) of [<code>List</code>](<a href="https://docs.raku.org/type/List.html)s" class="bare">https://docs.raku.org/type/List.html)s</a>. Create five poker hands of five cards from that. Output the cards in ascending order of their ranks.</p>
</div>
<div class="paragraph">
<p>练习6.14将一副牌作为[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)的"><code>列表</code></a>(<a href="https://docs.raku.org/type/List.html)。从中创建五手五张牌。按名次的升序输出卡片。" class="bare">https://docs.raku.org/type/List.html)。从中创建五手五张牌。按名次的升序输出卡片。</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_sorting_on_multiple_comparisons">3.10. Sorting on Multiple Comparisons</h3>
<div class="paragraph">
<p>You can use a [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) to create more complicated comparisons, comparing two things that are the same in one regard in another way. When two people’s lasts names are the same, you can sort by the first name. If you sort these with the default <code>.sort</code> you probably won’t get what you want:</p>
</div>
<div class="paragraph">
<p>你可以使用[<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)来创建更复杂的比较，以另一种方式比较两个在一个方面相同的事物。当两个人的姓名相同时，你可以按名字排序。如果你使用默认的" class="bare">https://docs.raku.org/type/Block.html)来创建更复杂的比较，以另一种方式比较两个在一个方面相同的事物。当两个人的姓名相同时，你可以按名字排序。如果你使用默认的</a> <code>.sort</code> 对它们进行排序，你可能无法获得所需内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @butterflies = (
    &lt;John Smith&gt;,
    &lt;Jane Smith&gt;,
    &lt;John Doe&gt;,
    &lt;Jon Smithers&gt;,
    &lt;Jim Schmidt&gt;,
    );

my @sorted = @butterflies.sort;

put @sorted.join: &#34;\n&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This comes out in alphabetical order, if you consider the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) to be the combination of the sublist elements as a single [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>):</p>
</div>
<div class="paragraph">
<p>如果你认为[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)是子列表元素组合为单个"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)，则按字母顺序排列：" class="bare">https://docs.raku.org/type/Str.html)，则按字母顺序排列：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Jane Smith
Jim Schmidt
John Doe
John Smith
Jon Smithers</code></pre>
</div>
</div>
<div class="paragraph">
<p>Change the sort to work only on the second element of each sublist:</p>
</div>
<div class="paragraph">
<p>将排序更改为仅适用于每个子列表的第二个元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @sorted = @butterflies.sort: *.[1];

put @sorted.join: &#34;\n&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last names sort in alphabetical order now, but the first names show up out of order (though that may depend on the ordering of your input):</p>
</div>
<div class="paragraph">
<p>姓氏现在按字母顺序排序，但名字显示不按顺序排列（尽管这可能取决于输入的顺序）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">John Doe
Jim Schmidt
John Smith
Jane Smith
Jon Smithers</code></pre>
</div>
</div>
<div class="paragraph">
<p>A more complex comparison can fix that. In each sublist, compare the last names to each other. If they are the same, add another comparison with the logical <code>or</code>:</p>
</div>
<div class="paragraph">
<p>更复杂的比较可以解决这个问题。在每个子列表中，将姓氏相互比较。如果它们相同，则添加另一个与逻辑 <code>or</code> 的比较：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @sorted = @butterflies.sort: {
    $^a.[1] leg $^b.[1]  # last name
        or
    $^a.[0] leg $^b.[0]  # first name
    };</code></pre>
</div>
</div>
<div class="paragraph">
<p>When it compares the sublists for <code>(John Smith)</code> and <code>(Jane Smith)</code> it tries the last names and finds that they are the same. It then sorts on the first names and produces the result that you probably want:</p>
</div>
<div class="paragraph">
<p>当它比较（<code>John Smith</code>）和（<code>Jane Smith</code>）的子列表时，它会尝试姓氏并发现它们是相同的。然后它对名字进行排序并产生你可能想要的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">John Doe
Jim Schmidt
Jane Smith
John Smith
Jon Smithers</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 6.15 Create a deck of cards and create five hands of five cards each. In each hand sort the cards by their rank. If the ranks are the same sort them by their suits.</p>
</div>
<div class="paragraph">
<p>练习6.15 创建一副牌并创建五手五张牌。每手按照等级对牌进行排序。如果排名与他们的花色相同。</p>
</div>
</div>
<div class="sect2">
<h3 id="_summary_3">3.11. Summary</h3>
<div class="paragraph">
<p>The [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>), [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>), and [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) types are [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html)s" class="bare">https://docs.raku.org/type/Positional.html)s</a>, and the [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) type can fake it when it needs to. This allows some amazing lazy features where you don’t have to do anything until you actually need it. Not only that, but with a little practice you won’t even need to think about it.</p>
</div>
<div class="paragraph">
<p>Once you have your data structures, you have some powerful ways to combine them to make much more complex data structures. Some of these may be daunting at first. Don’t ignore them. You’ll find that your programming career will be easier with judiciously chosen structures that are easy to manipulate.</p>
</div>
<div class="paragraph">
<p>[<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>), [<code>Range</code>](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>), 和 [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) 类型是 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html)，"><code>Seq</code></a>(<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 类型可以在需要时伪造它。这允许一些惊人的惰性功能，你不需要做任何事情，直到你真正需要它。不仅如此，通过一些练习，你甚至不需要考虑它。</p>
</div>
<div class="paragraph">
<p>拥有数据结构后，你可以通过一些强大的方法将它们组合在一起，从而构建更复杂的数据结构。其中一些可能一开始令人生畏。不要忽视它们。你会发现，通过易于操作的明智选择的结构，你的编程生涯将变得更加容易。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_当出错的时候">4. 当出错的时候</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku doesn’t always immediately give up when something goes wrong. It can fail softly. If the result of that problem doesn’t affect anything else in the program there’s no need to complain about it. However, the moment it becomes a problem that passive failure demands your attention.</p>
</div>
<div class="paragraph">
<p>This chapter shows you the error mechanisms and how to deal with them. You’ll see how to handle the problems that your program notices on your behalf as well as detect and report problems on your own.</p>
</div>
<div class="paragraph">
<p>当出现问题时，Raku 并不总是立即放弃。它可能会轻轻失败。如果该问题的结果不影响程序中的任何其他内容，则无需抱怨它。然而，当它成为问题的那一刻被动失败就要引起你的注意了。</p>
</div>
<div class="paragraph">
<p>本章向你介绍错误机制以及如何处理它们。你将看到如何处理你的程序以你的名义注意到的问题，以及如何自行检测和报告问题。</p>
</div>
<div class="sect2">
<h3 id="_异常">4.1. 异常</h3>
<div class="paragraph">
<p>Here’s a bit of code that tries to convert nonnumeric text into a number. Maybe something else didn’t put the right value in the variable:</p>
</div>
<div class="paragraph">
<p>这里有一些代码试图将非数字文本转换为数字。也许其他东西没有在变量中放入正确的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $m = &#39;Hello&#39;;
my $value = +$m;
put &#39;Hello there!&#39;;  # no error, so, works?</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your program doesn’t complain because you don’t do anything with the problematic result. Change the program to output the result of what you think was a numeric conversion:</p>
</div>
<div class="paragraph">
<p>你的程序没有抱怨，因为你没有对有问题的结果做任何事情。更改程序以输出你认为是数字转换的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $m = &#39;Hello&#39;;
my $value = +$m;
put $value;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you get some error output instead:</p>
</div>
<div class="paragraph">
<p>现在你得到一些错误输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Cannot convert string to number: base-10 number must
begin with valid digits or &#39;.&#39; in &#39;⏏Hello&#39; (indicated by ⏏)
    in block &lt;unit&gt; at ... line 2

Actually thrown at:
    in block &lt;unit&gt; at ... line 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Look at that error message. It reports two line numbers. The error occurred on line 2, but it wasn’t until line 3 (the one with <code>put</code>) that it became a problem. That’s the soft failure. What’s actually in <code>$result</code>? It’s a [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) object:</p>
</div>
<div class="paragraph">
<p>看看那条错误信息。它报告两个行号。错误发生在第 2 行，但直到第 3 行（带有 <code>put</code> 的那行）才成为问题。那是软失败。 <code>$result</code> 中的实际内容是什么？这是一个 [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) 对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $m = &#39;Hello&#39;;
my $value = +$m;
put &#34;type is {$value.^name}&#34;;  # type is Failure</code></pre>
</div>
</div>
<div class="paragraph">
<p>These soft failures can be quite handy in cases where you don’t care if something didn’t work. If you can’t log a message because the logger is broken what are you going to do about it? Log the failure? Similarly, sometimes you don’t care if something fails because that might be a common case. It’s up to you to make those decisions, though.</p>
</div>
<div class="paragraph">
<p>The [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) is really a wrapper around an [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>), so you need to know about exceptions first.</p>
</div>
<div class="paragraph">
<p>如果你不关心某些事情是否有效，这些软故障可能非常方便。如果由于记录器坏了而无法记录消息，你打算怎么做呢？记录失败？同样，有时你不关心某些事情是否失败，因为这可能是一种常见的情况。不过，由你决定做出决定。</p>
</div>
<div class="paragraph">
<p>[<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) 实际上是[<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)的包装，因此你首先需要了解异常。" class="bare">https://docs.raku.org/type/Exception.html)的包装，因此你首先需要了解异常。</a></p>
</div>
<div class="sect3">
<h4 id="_捕获异常">4.1.1. 捕获异常</h4>
<div class="paragraph">
<p>Something that wants to report an exception throws it. You’d say “the subroutine threw an exception.” Some people might say it “raised an exception.” It’s the same thing. If you don’t handle an exception it stops your program.</p>
</div>
<div class="paragraph">
<p>A <code>try</code> wraps some code and can catch an [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>). If it catches an [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) it puts it into the <code>$!</code> special variable:</p>
</div>
<div class="paragraph">
<p>想要报告异常的东西会抛出它。你会说“子程序抛出了异常。” 有些人可能会说它“引发了异常。”这是同样的事情。如果你不处理异常，它将停止你的程序。</p>
</div>
<div class="paragraph">
<p><code>try</code> 包装一些代码并可以捕获[<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)。如果它捕获一个" class="bare">https://docs.raku.org/type/Exception.html)。如果它捕获一个</a> [<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)，它会将异常放入" class="bare">https://docs.raku.org/type/Exception.html)，它会将异常放入</a> <code>$!</code> 特殊变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">try {
    my $m = &#39;Hello&#39;;
    my $value = +$m;
    put &#34;value is {$value.^name}&#34;;
}
put &#34;ERROR: $!&#34; if $!;

put &#39;Got to the end.&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You catch the [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) and your program continues:</p>
</div>
<div class="paragraph">
<p>你捕获[<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)并你的程序继续：" class="bare">https://docs.raku.org/type/Exception.html)并你的程序继续：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">ERROR: Cannot convert string to number
Got to the end.</code></pre>
</div>
</div>
<div class="paragraph">
<p>With a single line you don’t need the braces:</p>
</div>
<div class="paragraph">
<p>使用单行你不需要大括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $m = &#39;Hello&#39;;
try my $value = +$m;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the code succeeds <code>try</code> gives back the value. You can move the <code>try</code> to the other side of the assignment:</p>
</div>
<div class="paragraph">
<p>如果代码成功，则 <code>try</code> 返回值。你可以将 <code>try</code> 移动到赋值的另一侧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $m = &#39;Hello&#39;;
my $value = try +$m;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) types are under <code>X</code> and inherit from [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)—in" class="bare">https://docs.raku.org/type/Exception.html)—in</a> this example it’s`X::Str::Numeric`:</p>
</div>
<div class="paragraph">
<p>大多数 [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) 类型都在 <code>X</code> 下，并且从 [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) 继承 - 在这个例子中，它是 <code>X::Str::Numeric</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;Exception type is {$!.^name}&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If there was no [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>), the thingy in <code>$!</code> is [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>). This is a bit annoying because [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) inherits from [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>) too. The <code>$!</code> in a condition is defined if there was a problem. Use it with <code>given</code> and smart match against the types you want to handle. A <code>default</code> [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) handles anything you don’t:</p>
</div>
<div class="paragraph">
<p>如果没有 [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)，" class="bare">https://docs.raku.org/type/Exception.html)，</a><code>$!</code> 里面的东西就是 [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html)。这有点烦人，因为" class="bare">https://docs.raku.org/type/Any.html)。这有点烦人，因为</a> [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) 也继承了 [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html)。" class="bare">https://docs.raku.org/type/Any.html)。</a> 如果出现问题，<code>$!</code> 就处于定义状态。使用 <code>given</code> 和智能匹配你要处理的类型。<code>default</code>  [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) 处理你不需要的任何内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Problem was &#39;, do given $! {
    when X::Str::Numeric { ... }
    default { ... }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>[<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) types use different methods to give you more information. Each type defines a method that makes sense for its error. Look at each type to see which information it captures for you. The [<code>X::Str::Numeric</code>](<a href="https://docs.raku.org/type/X::Str::Numeric%20)"><code>Exception</code></a>(<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) type knows at which position in the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) it discovered the problem:</p>
</div>
<div class="paragraph">
<p>[<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)类型使用不同的方法为你提供更多信息。每种类型都定义了一种对其错误有意义的方法。查看每种类型以查看它为你捕获的信息。" class="bare">https://docs.raku.org/type/Exception.html)类型使用不同的方法为你提供更多信息。每种类型都定义了一种对其错误有意义的方法。查看每种类型以查看它为你捕获的信息。</a> [<code>X::Str::Numeric</code>](<a href="https://docs.raku.org/type/X::Str::Numeric%20" class="bare">https://docs.raku.org/type/X::Str::Numeric%20</a>) [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)类型知道它在"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)中发现问题的位置：" class="bare">https://docs.raku.org/type/Str.html)中发现问题的位置：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Problem was &#39;, do given $! {
    when X::Str::Numeric  { &#34;Char at {.pos} is not numeric&#34; }
    when X::Numeric::Real { &#34;Trying to convert to {.target}&#34; }
    default { ... }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>$!</code> and <code>given</code> happen outside of the <code>try</code>. A <code>CATCH</code> [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) inside the <code>try</code> can do the same thing. The [<code>X::Str::Numeric</code>](<a href="https://docs.raku.org/type/X::Str::Numeric%20" class="bare">https://docs.raku.org/type/X::Str::Numeric%20</a>) [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) shows up in <code>$_</code>:</p>
</div>
<div class="paragraph">
<p><code>$!</code>  和 <code>given</code> 发生在 <code>try</code> 之外。 <code>try</code> 中的 <code>CATCH</code> [<code>块</code>](<a href="https://docs.raku.org/type/Block.html)可以做同样的事情。" class="bare">https://docs.raku.org/type/Block.html)可以做同样的事情。</a> [<code>X::Str::Numeric</code>](<a href="https://docs.raku.org/type/X::Str::Numeric%20" class="bare">https://docs.raku.org/type/X::Str::Numeric%20</a>)  [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) 出现在 <code>$_</code> 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">try {
    CATCH {
        when X::Str::Numeric { put &#34;ERROR: {.reason}&#34; }
        default { put &#34;Caught {.^name}&#34; }
        }
    my $m = &#39;Hello&#39;;
    my $value = +$m;
    put &#34;value is {$value.^name}&#34;;
    }

put &#39;Got to the end.&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>X::Str::Numeric</code> [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) is thrown at the line <code>my $value = +$m;</code>, then it skips the rest of the [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>). Handle this by outputting an error and continuing with the program:</p>
</div>
<div class="paragraph">
<p><code>X::Str::Numeric</code> [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) 在 <code>my $value =+ $m;</code> 这一行被抛出，然后跳过[<code>块</code>](<a href="https://docs.raku.org/type/Block.html)的其余部分。通过输出错误并继续执行程序来处理：" class="bare">https://docs.raku.org/type/Block.html)的其余部分。通过输出错误并继续执行程序来处理：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">ERROR: base-10 number must begin with valid digits or &#39;.&#39;
Got to the end.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most of these objects inherit from [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) and have a <code>.message</code> method that provides more information. Catch those with <code>default</code> where you can output the name of the type:</p>
</div>
<div class="paragraph">
<p>这些对象中的大多数都继承自[<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)，并且具有提供更多信息的" class="bare">https://docs.raku.org/type/Exception.html)，并且具有提供更多信息的</a> <code>.message</code> 方法。使用 <code>default</code> 捕获那些异常，你可以输出类型的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">try {
    CATCH {
        default { put &#34;Caught {.^name} with ｢{.message}｣&#34; }
        }
    my $m = &#39;Hello&#39;;
    my $value = +$m;
    put &#34;value is {$value.^name}&#34;;
    }

put &#34;Got to the end.&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the output has the same message that the unhandled error showed you:</p>
</div>
<div class="paragraph">
<p>现在输出与未处理的错误显示的消息相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Caught X::Str::Numeric with ｢Cannot convert string to number:
base-10 number must begin with valid digits or &#39;.&#39; in &#39;⏏Hello&#39;
(indicated by ⏏)｣
Got to the end.</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 7.1Divide a number by zero. What [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) type do you get?</p>
</div>
<div class="paragraph">
<p>练习7.1 将数字除以零。你得到什么 [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) 类型？</p>
</div>
</div>
<div class="sect3">
<h4 id="_backtraces">4.1.2. Backtraces</h4>
<div class="paragraph">
<p>The [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) contains a [<code>Backtrace</code>](<a href="https://docs.raku.org/type/Backtrace.html" class="bare">https://docs.raku.org/type/Backtrace.html</a>) object that documents the path of the error. This example has three levels of subroutine calls with some code at the end that throws an [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>):</p>
</div>
<div class="paragraph">
<p>[<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) 包含一个 [<code>Backtrace</code>](<a href="https://docs.raku.org/type/Backtrace.html" class="bare">https://docs.raku.org/type/Backtrace.html</a>) 对象，用于记录错误的路径。此示例有三个级别的子例程调用，最后的一些代码抛出[<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)：" class="bare">https://docs.raku.org/type/Exception.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub top    { middle()    }
sub middle { bottom()    }
sub bottom { 5 + &#34;Hello&#34; }

top();</code></pre>
</div>
</div>
<div class="paragraph">
<p>You don’t handle the [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) in <code>middle</code>, you don’t handle it in <code>top</code>, and finally, you don’t handle it at the top level. The [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) complains and shows you its path through the code:</p>
</div>
<div class="paragraph">
<p>你不在 <code>middle</code> 中处理[<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)，你不在顶部处理它，最后，你不在" class="bare">https://docs.raku.org/type/Exception.html)，你不在顶部处理它，最后，你不在</a> <code>top</code> 中处理它。 [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) 会抱怨并向你展示其代码的路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Cannot convert string to number: base-10 number must
begin with valid digits or &#39;.&#39; in &#39;⏏Hello&#39; (indicated by ⏏)
  in sub bottom at backtrace.p6 line 3
  in sub middle at backtrace.p6 line 2
  in sub top at backtrace.p6 line 1
  in block &lt;unit&gt; at backtrace.p6 line 5

Actually thrown at:
  in sub bottom at backtrace.p6 line 3
  in sub middle at backtrace.p6 line 2
  in sub top at backtrace.p6 line 1
  in block &lt;unit&gt; at backtrace.p6 line 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>Don’t fret when you see long messages like this. Find the first level of the error and think about that. Work your way through the chain one level at a time. Often a simple fix makes it all go away.</p>
</div>
<div class="paragraph">
<p>You can handle the [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) anywhere in that chain. The simplest option might be to wrap the call to <code>bottom</code> in a <code>try</code>. With a single-line expression you can omit the [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) around the code. In <code>middle</code>, you don’t specify a <code>CATCH</code> so there’s a default handler that discards the [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>):</p>
</div>
<div class="paragraph">
<p>当你看到像这样的长信息时，不要担心。找出错误的第一级并考虑一下。一次一个层次地通过链条。通常一个简单的修复使它全部消失。</p>
</div>
<div class="paragraph">
<p>你可以在该链中的任何位置处理[<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)。最简单的选择可能是在" class="bare">https://docs.raku.org/type/Exception.html)。最简单的选择可能是在</a> <code>try</code> 中将调用包装到 <code>bottom</code>。使用单行表达式，你可以省略代码周围的[<code>块</code>](<a href="https://docs.raku.org/type/Block.html)。在" class="bare">https://docs.raku.org/type/Block.html)。在</a> <code>middle</code> 中，你没有指定 <code>CATCH</code>，因此有一个默认处理程序可以丢弃[<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)：" class="bare">https://docs.raku.org/type/Exception.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub top    { middle()      }
sub middle { try bottom()  }
sub bottom { 137 + &#39;Hello&#39; }

put top();</code></pre>
</div>
</div>
<div class="paragraph">
<p>That program doesn’t produce an error (or any output). That’s probably not what you want. The middle layer can handle the case where you can’t convert a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) to a number by returning the special number <code>NaN</code> (for “not a number”):</p>
</div>
<div class="paragraph">
<p>该程序不会产生错误（或任何输出）。这可能不是你想要的。中间层可以通过返回特殊数字 <code>NaN</code> （意思是“非数字”）来处理无法将[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)转换为数字的情况：" class="bare">https://docs.raku.org/type/Str.html)转换为数字的情况：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub top    { middle() }
sub middle {
    try {
        CATCH { when X::Str::Numeric { return NaN } }
        bottom()
        }
}

sub bottom { 137 + &#39;Hello&#39; }

put top();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Change the code to make a different error that the <code>CATCH</code> in <code>middle</code> doesn’t handle. Try to divide by zero and convert the result to a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>):</p>
</div>
<div class="paragraph">
<p>更改代码以产生 <code>middle</code> 中的 <code>CATCH</code> 无法处理的其他错误。尝试除以零并将结果转换为[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)：" class="bare">https://docs.raku.org/type/Str.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub top    { middle() }
sub middle {
    try {
        CATCH { when X::Str::Numeric { return NaN } }
        bottom()
        }
}

sub bottom { ( 137 / 0 ).Str  }

put top();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>CATCH</code> in <code>middle</code> doesn’t handle this new type of error, so the [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) interrupts the program at the call to <code>top</code>:</p>
</div>
<div class="paragraph">
<p><code>middle</code> 中的 <code>CATCH</code> 不处理这种新类型的错误，因此[<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)在调用" class="bare">https://docs.raku.org/type/Exception.html)在调用</a> <code>top</code> 时中断程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Attempt to divide 137 by zero using div
  in sub bottom at nan.p6 line 12
  in sub middle at nan.p6 line 8
  in sub top at nan.p6 line 4
  in block &lt;unit&gt; at nan.p6 line 14</code></pre>
</div>
</div>
<div class="paragraph">
<p>Catch this one inside <code>top</code>. The [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) passes through <code>middle</code>, which has nothing to handle it. Since nothing handles that error it continues up the chain and ends up in <code>top</code>, which handles it by returning the special value <code>Inf</code> (for infinity):</p>
</div>
<div class="paragraph">
<p>在 <code>top</code> 里面捕获这个异常。[<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)通过" class="bare">https://docs.raku.org/type/Exception.html)通过</a> <code>middle</code>，没有任何处理它。由于没有处理该错误，它会继续向上链接并最终到达 <code>top</code>，通过返回特殊值 <code>Inf</code> （意思是无穷大）来处理它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub top {
    try {
        CATCH {
            when X::Numeric::DivideByZero { return Inf }
        }
        middle()
    }
}
sub middle {
    try {
        CATCH {
            when X::Str::Numeric { return NaN }
        }
        bottom()
    }
}

sub bottom { ( 137 / 0 ).Str  }

put top();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Extend this process as far up the chain as you like. The next example changes the error by trying to call an undefined method on <code>137</code>:</p>
</div>
<div class="paragraph">
<p>根据你的喜好将这个过程延伸到链上。下一个示例通过尝试在 <code>137</code> 上调用未定义的方法来更改错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub top {
    try {
        CATCH {
            when X::Numeric::DivideByZero { return Inf }
        }
        middle()
    }
}

sub middle {
    try {
        CATCH {
            when X::Str::Numeric { return NaN }
        }
        bottom()
    }
}

sub bottom { 137.unknown-method }

try {
    CATCH {
        default { put &#34;Uncaught exception {.^name}&#34; }
    }
    top();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s a new sort of error that you don’t handle so far:</p>
</div>
<div class="paragraph">
<p>到目前为止，这是一种新的错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Uncaught exception X::Method::NotFound</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes you don’t care about unfound methods. If it’s there you call it and if not you want to ignore it. There’s special syntax for this. If you place a <code>?</code> after the method call dot, you don’t get an [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) if the method is not found:</p>
</div>
<div class="paragraph">
<p>有时你不关心未找到的方法。如果它在那里你就调用它，如果不是你就忽略它。这有特殊的语法。如果在方法调用点之后你放一个 <code>?</code>，如果找不到该方法，则不会出现[<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)：" class="bare">https://docs.raku.org/type/Exception.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub bottom { 137.?unknown-method }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rethrowing_errors">4.1.3. Rethrowing Errors</h4>
<div class="paragraph">
<p>It gets better. You can catch an exception but not handle it. Modify the <code>CATCH</code> in <code>middle</code> to intercept <code>X::Method::NotFound</code> and output a message, then <code>.rethrow</code> it:</p>
</div>
<div class="paragraph">
<p>它变得更好了。你可以捕获异常但不处理它。修改 <code>middle</code> 里面的 <code>CATCH</code> 以拦截 <code>X::Method::NotFound</code> 并输出一条消息，然后 <code>.rethrow</code> 它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub top    {
    try {
        CATCH {
            when X::Numeric::DivideByZero { return Inf }
        }
        middle()
    }
}

sub middle {
    try {
        CATCH {
            when X::Str::Numeric     { return NaN }
            when X::Method::NotFound {
                put &#34;What happened?&#34;;
                .rethrow
            }
        }
        bottom()
    }
}

sub bottom { 137.unknown-method  }

try {
    CATCH {
        default { put &#34;Uncaught exception {.^name}&#34; }
    }
    top();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see that <code>middle</code> was able to do its work but the [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) was ultimately handled by <code>top</code>:</p>
</div>
<div class="paragraph">
<p>你可以看到 <code>middle</code> 能够完成它的工作，但是[<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)最终由" class="bare">https://docs.raku.org/type/Exception.html)最终由</a> <code>top</code> 处理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">What happened?
Uncaught exception X::Method::NotFound</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 7.2Implement a subroutine whose only code is <code>…​</code>. That denotes code that you intend to fill in later. Call that from another subroutine and catch the [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>). What’s the type you get? Can you output your own [<code>Backtrace</code>](<a href="https://docs.raku.org/type/Backtrace.html)?" class="bare">https://docs.raku.org/type/Backtrace.html)?</a></p>
</div>
<div class="paragraph">
<p>练习7.2 实现一个子程序，其唯一的代码是 <code>…​</code> 。这表示你打算稍后填写的代码。从另一个子例程调用它并捕获[<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)。你得到的是什么类型的？你能输出自己的"><code>Backtrace</code></a>(<a href="https://docs.raku.org/type/Backtrace.html)吗？" class="bare">https://docs.raku.org/type/Backtrace.html)吗？</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_throwing_your_own_exceptions">4.1.4. Throwing Your Own Exceptions</h4>
<div class="paragraph">
<p>Up to now you’ve seen exceptions that come from problems in the source code. Those are easy to see without complicating the examples. You can also throw your own [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)s" class="bare">https://docs.raku.org/type/Exception.html)s</a>. The easiest way is to use <code>die</code> with a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) argument:</p>
</div>
<div class="paragraph">
<p>到目前为止，你已经看到源代码中存在问题的异常。这些很容易看到，而不会使示例复杂化。你也可以抛出自己的[<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)。最简单的方法是使用带有"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)参数的" class="bare">https://docs.raku.org/type/Str.html)参数的</a> <code>die</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">die &#39;Something went wrong!&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>die</code> subroutine takes the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) as the message for an [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) of type [<code>X::AdHoc</code>](<a href="https://docs.raku.org/type/X::AdHoc.html" class="bare">https://docs.raku.org/type/X::AdHoc.html</a>). That’s a catch-all type for anything that doesn’t have a more appropriate type.</p>
</div>
<div class="paragraph">
<p>Dying with a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) is the same as constructing an [<code>X::AdHoc</code>](<a href="https://docs.raku.org/type/X::AdHoc.html" class="bare">https://docs.raku.org/type/X::AdHoc.html</a>). You can <code>die</code> with a particular [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) type by constructing it yourself:</p>
</div>
<div class="paragraph">
<p><code>die</code> 子例程将[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)作为" class="bare">https://docs.raku.org/type/Str.html)作为</a> [<code>X::AdHoc</code>](<a href="https://docs.raku.org/type/X::AdHoc.html" class="bare">https://docs.raku.org/type/X::AdHoc.html</a>) 类型的[<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)的消息。对于没有更合适类型的任何东西来说，这是一种全能类型。" class="bare">https://docs.raku.org/type/Exception.html)的消息。对于没有更合适类型的任何东西来说，这是一种全能类型。</a></p>
</div>
<div class="paragraph">
<p>带有[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)的死亡与构建"><code>X::AdHoc</code></a>(<a href="https://docs.raku.org/type/X::AdHoc.html)相同。你可以通过自己构建它来使用特定的"><code>Exception</code></a>(<a href="https://docs.raku.org/type/Exception.html)类型：" class="bare">https://docs.raku.org/type/Exception.html)类型：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">die X::AdHoc.new( payload =&gt; &#34;Something went wrong!&#34; );</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You’re actually creating a [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) here, but you won’t see the <code>⇒</code> until [Chapter 9](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch09.html#camelia-hashes" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch09.html#camelia-hashes</a>) or named parameters until [Chapter 11](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch11.html#camelia-subroutines" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch11.html#camelia-subroutines</a>), so take this on faith.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>The <code>die</code> is important. Merely constructing the [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) does not throw it:</p>
</div>
<div class="paragraph">
<p>你实际上是在这里创建一个[<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)，但在第11章之前你不会看到" class="bare">https://docs.raku.org/type/Pair.html)，但在第11章之前你不会看到</a> <code>⇒</code> 或者直到第11章，所以请相信这一点。</p>
</div>
<div class="paragraph">
<p><code>die</code> 很重要。仅仅构建[<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)并不会抛出它：" class="bare">https://docs.raku.org/type/Exception.html)并不会抛出它：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># nothing happens
X::AdHoc.new( payload =&gt; &#34;Something went wrong!&#34; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can <code>.throw</code> it yourself if you like, though. This is the same as <code>die</code>:</p>
</div>
<div class="paragraph">
<p>不过，如果你愿意，你可以自己 <code>.throw</code>。这跟 <code>die</code> 是一样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">X::AdHoc
    .new( payload =&gt; &#34;Something went wrong!&#34; )
    .throw;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also create [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)s" class="bare">https://docs.raku.org/type/Exception.html)s</a> of other predefined types. The [<code>X::NYI</code>](<a href="https://docs.raku.org/type/X::NYI.html" class="bare">https://docs.raku.org/type/X::NYI.html</a>) type is for features not yetimplemented:</p>
</div>
<div class="paragraph">
<p>你还可以创建其他预定义类型的 [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)。" class="bare">https://docs.raku.org/type/Exception.html)。</a> [<code>X::NYI</code>](<a href="https://docs.raku.org/type/X::NYI.html" class="bare">https://docs.raku.org/type/X::NYI.html</a>) 类型用于未实现的功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">X::NYI.new: features =&gt; &#39;Something I haven&#39;t done yet&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 7.3Modify the previous exercise to <code>die</code> with a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) argument. What type do you catch? Further modify that to <code>die</code> with an <code>X::StubCode</code> object that you construct yourself.</p>
</div>
<div class="paragraph">
<p>练习7.3 使用[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)参数修改上一个练习。你捕获了什么类型？使用你自己构建的" class="bare">https://docs.raku.org/type/Str.html)参数修改上一个练习。你捕获了什么类型？使用你自己构建的</a> <code>X::StubCode</code> 对象进一步修改它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_defining_your_own_exception_types">4.1.5. Defining Your Own Exception Types</h4>
<div class="paragraph">
<p>It’s a bit early to create subclasses—you’ll see how to do that in [Chapter 12](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch12.html#camelia-classes)—but" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch12.html#camelia-classes)—but</a> with a little faith you can do this right away. Base your class on [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) without doing anything else:</p>
</div>
<div class="paragraph">
<p>创建子类有点早 - 你会在第12章看到如何做到这一点 - 但有一点信心你可以马上做到这一点。将你的类基于[<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)而不做任何其他事情：" class="bare">https://docs.raku.org/type/Exception.html)而不做任何其他事情：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class X::MyException is Exception {}

sub my-own-error {
    die X::MyException.new: payload =&gt; &#39;I did this&#39;;
}

my-own-error();</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you run the <code>my-own-error</code> subroutine it dies with the new error type that you’ve defined:</p>
</div>
<div class="paragraph">
<p>当你运行 <code>my-own-error</code> 子例程时，它会以你定义的新错误类型失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Died with X::MyException</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that your new type exists you can use it in a <code>CATCH</code> (or smart match). Even without any sort of customization its name is enough to tell you what happened:</p>
</div>
<div class="paragraph">
<p>既然你的新类型存在，你可以在 <code>CATCH</code> （或智能匹配）中使用它。即使没有任何自定义，它的名字也足以告诉你发生了什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">try {
    CATCH {
        when X::MyException { put &#39;Caught a custom error&#39; }
    }

my-own-error();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>[Chapter 12](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch12.html#camelia-classes" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch12.html#camelia-classes</a>) will cover class creation and show you more about what you can do inside a class and how to reuse existing classes.</p>
</div>
<div class="paragraph">
<p>第12章将涵盖类的创建，并向你展示更多关于你可以在类中做什么以及如何重用现有类。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_failures">4.2. Failures</h3>
<div class="paragraph">
<p>[<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html)s" class="bare">https://docs.raku.org/type/Failure.html)s</a> are wrappers around unthrown [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)s" class="bare">https://docs.raku.org/type/Exception.html)s</a>. They’re passive until you try to use them later—hence “soft” exceptions. They don’t interrupt your program until something tries to use them as a normal value. It’s then that they throw their [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)s" class="bare">https://docs.raku.org/type/Exception.html)s</a>.</p>
</div>
<div class="paragraph">
<p>As a Boolean a [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) is always <code>False</code>. You can “disarm” the [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) by checking it. That might be with an <code>if</code>, with a logical test, or by Booleanizing it with <code>.so</code> or <code>?</code>. All of those mark the [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) as handled and prevent it from implicitly throwing its [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>):</p>
</div>
<div class="paragraph">
<p>[<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) 是围绕unthrown [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) 的包装器。它们是被动的，直到你以后尝试使用它们 - 因此是“软”异常。在尝试将它们用作正常值之前，它们不会中断你的程序。然后，他们抛出了他们的异常。</p>
</div>
<div class="paragraph">
<p>作为布尔值，[<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) 始终为 <code>False</code>。你可以通过检查来“解除”[<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html)。这可能是使用" class="bare">https://docs.raku.org/type/Failure.html)。这可能是使用</a> <code>if</code>，进行逻辑测试，或者使用 <code>.so</code> 或 <code>?</code> 进行布尔化。所有这些都将[<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html)标记为已处理并阻止它隐式抛出其异常：" class="bare">https://docs.raku.org/type/Failure.html)标记为已处理并阻止它隐式抛出其异常：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result = do-something();
if $result { ... }
my $did-it-work = ?$results;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) is always undefined; maybe you want to set a default value if you encounter one:</p>
</div>
<div class="paragraph">
<p>[<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) 总是未定义的;也许你想要设置一个默认值，如果你遇到一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $other-result = $result // 0;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can handle a [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) yourself without the <code>try</code>. The <code>.exception</code> method extracts that object so you can inspect it:</p>
</div>
<div class="paragraph">
<p>没有 <code>try</code> 你也可以自己处理[<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html)。" class="bare">https://docs.raku.org/type/Failure.html)。</a> <code>.exception</code> 方法提取该对象，以便你可以检查它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unless $result {
    given $result.exception {
        when    X::AdHoc { ... }
        default          { ... }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Create your own [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html)s" class="bare">https://docs.raku.org/type/Failure.html)s</a> by substituting <code>die</code> with <code>fail</code>:</p>
</div>
<div class="paragraph">
<p>通过将 <code>die</code> 替换为 <code>fail</code> 来创建自己的[<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html)：" class="bare">https://docs.raku.org/type/Failure.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">fail &#34;This ends up as an X::AdHoc&#34;;

fail My::X::SomeException.new(
    :payload( &#39;Something wonderful&#39; ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you use <code>fail</code> in a subroutine the [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) object becomes the return value. Instead of <code>die</code>-ing you should probably use <code>fail</code> so that the programmers who use your code can decide for themselves how to handle the problem.</p>
</div>
<div class="paragraph">
<p>EXERCISE 7.4Create a subroutine that takes two arguments and returns their sum. If either argument is not a number return a [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) object saying so. How would you handle the [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html)?" class="bare">https://docs.raku.org/type/Failure.html)?</a></p>
</div>
<div class="paragraph">
<p>在子例程中使用 <code>fail</code> 时，[<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) 对象将成为返回值。你应该使用 <code>fail</code> 而不是 <code>die</code>，以便使用你的代码的程序员可以自己决定如何处理问题。</p>
</div>
<div class="paragraph">
<p>练习7.4 创建一个带有两个参数并返回其总和的子程序。如果任一参数不是数字，则返回[<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html)对象。你会如何处理"><code>Failure</code></a>(<a href="https://docs.raku.org/type/Failure.html)？" class="bare">https://docs.raku.org/type/Failure.html)？</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_warnings">4.3. Warnings</h3>
<div class="paragraph">
<p>Instead of <code>die</code>-ing you can use <code>warn</code> to give the same message without stopping the program or forcing the program to catch the [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>):</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>warn</code> 而不是 <code>die</code> 来提供相同的消息，而无需停止程序或强制程序捕获异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">warn &#39;Something funny is going on!&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Warnings are a type of [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) and you can catch them. They aren’t the same type of exception so they don’t show up in a <code>CATCH</code> [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>). They are control exceptions that you catch in a <code>CONTROL</code> [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>):</p>
</div>
<div class="paragraph">
<p>警告是一种[<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)，你可以捕获它们。它们不是同一类型的异常，因此它们不会出现在" class="bare">https://docs.raku.org/type/Exception.html)，你可以捕获它们。它们不是同一类型的异常，因此它们不会出现在</a> <code>CATCH</code> [<code>块</code>](<a href="https://docs.raku.org/type/Block.html)中。它们是你在CONTROL" class="bare">https://docs.raku.org/type/Block.html)中。它们是你在CONTROL</a> [<code>块</code>](<a href="https://docs.raku.org/type/Block.html)中捕获的控制异常：" class="bare">https://docs.raku.org/type/Block.html)中捕获的控制异常：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">try {
    CONTROL {
        put &#34;Caught an exception, in the try&#34;;
        put .^name;
    }
    do-that-thing-you-do();
}

sub do-that-thing-you-do {
    CONTROL {
        put &#34;Caught an exception, in the sub&#34;;
        put .^name;
    }
    warn &#34;This is a warning&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don’t care about the warnings (they are annoying after all) you can wrap the annoying code in a <code>quietly</code> [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>):</p>
</div>
<div class="paragraph">
<p>如果你不关心警告（毕竟它们很烦人），你可以将烦人的代码包装在一个 <code>quietly</code> [<code>块</code>](<a href="https://docs.raku.org/type/Block.html)中：" class="bare">https://docs.raku.org/type/Block.html)中：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">quietly {
    do-that-thing-you-do();
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 7.5Modify the previous exercise to <code>warn</code> for each argument that cannot be converted to a number. Once you’ve seen those warnings, further modify the program to ignore the warnings.</p>
</div>
<div class="paragraph">
<p>练习7.5 修改上一个练习，以警告(<code>warn</code>)每个无法转换为数字的参数。一旦看到这些警告，进一步修改程序以忽略警告。</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_wisdom_of_exceptions">4.4. The Wisdom of Exceptions</h3>
<div class="paragraph">
<p>[<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)s" class="bare">https://docs.raku.org/type/Exception.html)s</a> can be a contentious subject. Some people love them and some hate them. Since they are a feature, you need to know about them. I want to leave you with some words of caution before you get yourself in too much trouble. Your love/hate relationship with [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)s" class="bare">https://docs.raku.org/type/Exception.html)s</a> will most likely fluctuate over your career.</p>
</div>
<div class="paragraph">
<p>[<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)s" class="bare">https://docs.raku.org/type/Exception.html)s</a> are a way of communicating information. By design this feature expects you to recognize the type of error and handle it appropriately. This implies that you can actually handle the error. If you encounter a situation that your program cannot correct, an [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) might not be the appropriate feature to use.</p>
</div>
<div class="paragraph">
<p>Even if your program could correct the error, many people don’t expect most programmers to handle errors. Your [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) may be a nuisance that they catch and ignore. Think about that before you spend too much time crafting fine-grained [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) types that cover all situations.</p>
</div>
<div class="paragraph">
<p>As part of program flow [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)s" class="bare">https://docs.raku.org/type/Exception.html)s</a> are really a fancy break mechanism. You’re in one bit of code, then suddenly in another. Those cases should truly be exceptional and rare. Anything else that you expect to happen you should handle with normal program flow.</p>
</div>
<div class="paragraph">
<p>That’s all I’ll say about that. Perhaps you have a different opinion. That’s fine. Read more about this on your own and judge your particular situation.</p>
</div>
<div class="paragraph">
<p>[<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>) 可能是一个有争议的主题。有些人喜欢他们，有些人讨厌他们。由于它们是一个功能，你需要了解它们。在你遇到太多麻烦之前，我想给你一些谨慎的话。你与[<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)的爱/恨关系很可能会在你的职业生涯中波动。" class="bare">https://docs.raku.org/type/Exception.html)的爱/恨关系很可能会在你的职业生涯中波动。</a></p>
</div>
<div class="paragraph">
<p>[<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)是一种沟通信息的方式。根据设计，此功能要求你识别错误类型并正确地处理它。这意味着你可以正确地处理错误。如果遇到程序无法纠正的情况，则"><code>异常</code></a>(<a href="https://docs.raku.org/type/Exception.html)这个功能可能不适用。" class="bare">https://docs.raku.org/type/Exception.html)这个功能可能不适用。</a></p>
</div>
<div class="paragraph">
<p>即使你的程序可以纠正错误，许多人也不希望大多数程序员处理错误。你的[<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)可能是他们捕获和忽视的麻烦。在花费太多时间制作涵盖所有情况的细粒度异常类型之前，请考虑一下。" class="bare">https://docs.raku.org/type/Exception.html)可能是他们捕获和忽视的麻烦。在花费太多时间制作涵盖所有情况的细粒度异常类型之前，请考虑一下。</a></p>
</div>
<div class="paragraph">
<p>作为程序流程的一部分，[<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)实际上是一种奇特的破坏机制。你在一点代码中，然后突然在另一个代码中。这些情况应该是特殊和罕见的。你期望发生的任何其他事情都应该处理正常的程序流程。" class="bare">https://docs.raku.org/type/Exception.html)实际上是一种奇特的破坏机制。你在一点代码中，然后突然在另一个代码中。这些情况应该是特殊和罕见的。你期望发生的任何其他事情都应该处理正常的程序流程。</a></p>
</div>
<div class="paragraph">
<p>这就是我要说的全部内容。也许你有不同的意见。没关系。自己阅读更多相关信息并判断你的具体情况。</p>
</div>
</div>
<div class="sect2">
<h3 id="_summary_4">4.5. Summary</h3>
<div class="paragraph">
<p>[<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)s" class="bare">https://docs.raku.org/type/Exception.html)s</a> are a feature of Raku, but it doesn’t hit you over the head with them. They can be soft failures until they would actually cause a problem.</p>
</div>
<div class="paragraph">
<p>[<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)是" class="bare">https://docs.raku.org/type/Exception.html)是</a> Raku 的一个功能，但它并没有让你头脑发热。它们可能是软故障，直到它们实际上会导致问题。</p>
</div>
<div class="paragraph">
<p>Don’t become overwhelmed by the different types of [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html)s" class="bare">https://docs.raku.org/type/Exception.html)s</a> your program may report. You’ll continue to see these throughout the rest of the book. Use them appropriately (whatever definition you choose) and effectively to note problems in your program. Try to detect those as early as you can.</p>
</div>
<div class="paragraph">
<p>不要被你的程序可能报告的不同类型的[<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)所淹没。在本书的其余部分中，你将继续看到这些内容。适当地使用它们（无论你选择何种定义）并有效地记录程序中的问题。尽可能早地检测这些。" class="bare">https://docs.raku.org/type/Exception.html)所淹没。在本书的其余部分中，你将继续看到这些内容。适当地使用它们（无论你选择何种定义）并有效地记录程序中的问题。尽可能早地检测这些。</a>
== 文件和目录,输入和输出</p>
</div>
<div class="paragraph">
<p>读写文本是许多你想要编写的程序的基础。你将数据存储在文件中并稍后检索该数据。本章是关于你需要执行此操作的所有功能。在此过程中，你将看到如何处理文件路径，移动文件以及使用目录。大多数情况都是使用你已经看过的相同语法完成的，但现在使用不同对象的类型。</p>
</div>
<div class="paragraph">
<p>本章中的许多任务可能由于程序之外的原因而失败。如果你希望在不同的目录中工作或希望某个文件存在，那么如果这些条件不为真，你可能不希望继续。这只是一个处理外部资源的程序的事实。</p>
</div>
</div>
<div class="sect2">
<h3 id="_文件路径">4.6. 文件路径</h3>
<div class="paragraph">
<p>[<code>IO::Path</code>](<a href="https://docs.raku.org/type/IO::Path.html" class="bare">https://docs.raku.org/type/IO::Path.html</a>) 对象表示文件路径。它知道如何根据文件系统的规则组合和拆分路径。只要路径的形式符合这些规则，该路径与实际存在的文件无关。你马上会看到如何处理丢失的文件。现在，在任何[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)上调用" class="bare">https://docs.raku.org/type/Str.html)上调用</a> <code>.IO</code> 将其转换为 [<code>IO::Path</code>](<a href="https://docs.raku.org/type/IO::Path.html" class="bare">https://docs.raku.org/type/IO::Path.html</a>) 对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $unix-path = &#39;/home&#39;.IO;
my $windows-path = &#39;C:/Users&#39;.IO;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要构建更深的路径，请使用 <code>.add</code>。你一次可以有多个层级。 <code>.add</code> 不会改变原始对象;它为你提供了一个新对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $home-directory = $unix-path.add: &#39;hamadryas&#39;;
my $file = $unix-path.add: &#39;hamadryas/file.txt&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要在那里构建路径，请赋值回原始对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$unix-path  = $unix-path.add: &#39;hamadryas/file.txt&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>二元赋值形式可能更有用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$unix-path .= add: &#39;hamadryas/file.txt&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.basename</code> 和 <code>.parent</code> 方法拆分路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $home = &#39;/home&#39;.IO;
my $user = &#39;hamadryas&#39;;    # Str or IO::File will work
my $file = &#39;file.txt&#39;.IO;

my $path = $home.add( $user ).add( $file );

put &#39;Basename: &#39;, $path.basename;  # Basename: file.txt
put &#39;Dirname: &#39;,  $path.parent;    # Dirname: /home/hamadryas</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>.basename`返回一个[`字符串</code>](<a href="https://docs.raku.org/type/Str.html)，而不是另一个" class="bare">https://docs.raku.org/type/Str.html)，而不是另一个</a> [<code>IO::Path</code>](<a href="https://docs.raku.org/type/IO::Path.html)。如果需要，可以再次使用" class="bare">https://docs.raku.org/type/IO::Path.html)。如果需要，可以再次使用</a> <code>.IO</code>。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用 <code>.parent</code>，你可以决定向上升多少个层级：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $home = &#39;/home&#39;.IO;
my $user = &#39;hamadryas&#39;;
my $file = &#39;file.txt&#39;.IO;

my $path = $home.add( $user ).add( $file );

put $path;                        # /home/hamadryas/file.txt
put &#39;One up:&#39;, $path.parent;      # One up: /home/hamadryas
put &#39;Two up: &#39;, $path.parent(2);  # Two up: /home</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以提出问题，以确定你是否有绝对路径或相对路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $home = &#39;/home&#39;.IO;
my $user = &#39;hamadryas&#39;;
my $file = &#39;file.txt&#39;.IO;

for $home, $file {
    put &#34;$_ is &#34;, .is-absolute ?? &#39;absolute&#39; !! &#39;relative&#39;;
    # put &#34;$_ is &#34;, .is-relative ?? &#39;relative&#39; !! &#39;absolute&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使相对路径成为绝对路径。没有参数 <code>.absolute</code> 在你创建 [<code>IO::Path</code>](<a href="https://docs.raku.org/type/IO::Path.html" class="bare">https://docs.raku.org/type/IO::Path.html</a>) 对象时使用当前工作目录。如果你想要一些其他的基目录，给它一个参数。无论哪种方式，你得到一个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)而不是另一个" class="bare">https://docs.raku.org/type/Str.html)而不是另一个</a> [<code>IO::Path</code>](<a href="https://docs.raku.org/type/IO::Path.html" class="bare">https://docs.raku.org/type/IO::Path.html</a>) 对象。 <code>.absolute</code> 方法不关心该路径是否实际存在：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $file = &#39;file.txt&#39;.IO;
put $file.absolute;           # /home/hamadryas/file.txt
put $file.absolute( &#39;/etc&#39; ); # /etc/file.txt
put $file.absolute( &#39;/etc/../etc&#39; ); # /etc/../etc/file.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>调用 <code>.resolve</code> 会检查文件系统。它弄清楚了 <code>.</code> 和 <code>..</code> 并将符号链接转换为目标。请注意 <code>/etc/..</code> 被替换为 <code>/private</code>，因为 <code>/etc</code> 是 macOS 上 <code>/private/etc</code> 的符号链接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $file = &#39;file.txt&#39;.IO;
put $file.absolute( &#39;/etc/..&#39; ); # /etc/../file.txt
put $file.absolute( &#39;/etc/..&#39; ).IO.resolve; # /private/file.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用 <code>:completely</code> 强调该文件存在。如果路径的任何部分（除了最后的部分）不存在或无法解析，则会收到错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $file = &#39;file.txt&#39;.IO;

{
CATCH {
    default { put &#34;Caught {.^name}&#34; }   # Caught X::IO::Resolve
    }
put $file.absolute( &#39;/homer/..&#39; ).IO.resolve: :completely; # fails
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_文件测试操作符">4.6.1. 文件测试操作符</h4>
<div class="paragraph">
<p>文件测试操作符回答有关文件路径的问题。他们中的大多数都返回 <code>True</code> 或 <code>False</code>。从[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)开始调用" class="bare">https://docs.raku.org/type/Str.html)开始调用</a> <code>.IO</code> 方法来创建 [<code>IO::Path</code>](<a href="https://docs.raku.org/type/IO::Path.html" class="bare">https://docs.raku.org/type/IO::Path.html</a>) 对象。使用 <code>.e</code> 检查文件是否存在（表8-1显示了其他文件测试）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $file = &#39;/some/path&#39;;

unless $file.IO.e {
    put &#34;The file &lt;$file&gt; does not exist!&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为什么是 <code>.e</code>？它来自 Unix 测试程序，它使用命令行开关（例如 <code>-e</code>）来回答有关路径的问题。那些相同的字母成为方法的名称。表8-1显示了文件测试。其中大多数与类似语言中的相同，尽管一些多字母将多个测试组合成一个。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Method</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The question it answers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>e</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存在</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>d</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是一个目录</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>f</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是一个普通文件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>s</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件大小(字节)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>l</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是一个符号连接</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>r</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对当前用户是可读的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>w</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对当前用户是可写的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rw</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对当前用户是可读和可写的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>x</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对当前用户是可执行的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rwx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对当前用户是可读，可写，可执行的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>z</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件存在，零字节</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Almost all of the file tests return a [Boolean](<a href="https://docs.raku.org/type/Bool" class="bare">https://docs.raku.org/type/Bool</a>) value. The one odd test is <code>.s</code>, which asks for the file size in bytes. That’s not a [Boolean](<a href="https://docs.raku.org/type/Bool" class="bare">https://docs.raku.org/type/Bool</a>), so how would it note a problem such as a missing file? It might return <code>0</code> in that case, because a file can have nothing in it (hence the <code>.z</code> method to ask if it exists with zero size). <code>.s</code> returns a [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html)instead" class="bare">https://docs.raku.org/type/Failure.html)instead</a> of <code>False</code> if there’s a problem:</p>
</div>
<div class="paragraph">
<p>几乎所有文件测试都返回一个[布尔值](<a href="https://docs.raku.org/type/Bool)。一个奇怪的测试是" class="bare">https://docs.raku.org/type/Bool)。一个奇怪的测试是</a> <code>.s</code>，它以字节为单位询问文件大小。这不是[布尔值](<a href="https://docs.raku.org/type/Bool)，那么它会如何记录丢失文件等问题？在这种情况下，它可能返回" class="bare">https://docs.raku.org/type/Bool)，那么它会如何记录丢失文件等问题？在这种情况下，它可能返回</a> <code>0</code>，因为文件中可能没有任何内容（因此 <code>.z</code> 方法询问它是否存在，大小为零）。如果出现问题，<code>.s</code> 会返回 [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) 而不是 <code>False</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $file = &#39;not-there&#39;;
given $file.IO {
    CATCH {
        # $_ in here is the exception
        when X::IO::NotAFile
            { put &#34;$file is not a plain file&#34; }
        when X::IO::DoesNotExist
            { put &#34;$file does not exist&#34;      }
        }
    put &#34;Size is { .s }&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在尝试获取其大小之前，你可能会检查文件是否存在并且是纯文件（尽管 <code>.f</code> 表示 <code>.e</code> ），但这种方式可能不太安全，因为文件可能会在你进入[<code>块</code>](<a href="https://docs.raku.org/type/Block.html)和当你尝试获取文件大小之间消失：" class="bare">https://docs.raku.org/type/Block.html)和当你尝试获取文件大小之间消失：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $file = &#39;not-there&#39;;
given $file.IO {
    when .e &amp;&amp; .f { put &#34;Size is { .s }&#34;   }
    when .e       { put &#34;Not a plain file&#34; }
    default       { put &#34;Does not exist&#34;   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但这不是文件测试的唯一语法。还有副词版本。你可以智能地匹配你想要的测试。此示例使用 [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 来组合测试，即使你在第14章之前不会看到这些测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $file.IO ~~ :e &amp; :f {  # Junction!
    put &#34;Size is { .s }&#34;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>练习8.1 创建一个程序，该程序从命令行参数中获取文件列表，并报告当前用户是否可读，可写或可执行。如果文件不存在，你会怎么做？</p>
</div>
</div>
<div class="sect3">
<h4 id="_文件元数据">4.6.2. 文件元数据</h4>
<div class="paragraph">
<p>文件记录的不仅仅是其内容。他们保留有关自己的额外信息;这就是元数据。 <code>.mode</code> 方法返回文件的 POSIX 权限（如果你的文件系统支持这样的事情）。这是一个整数，表示用户，组和其他所有人的设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $file = &#39;/etc/hosts&#39;;
my $mode = $file.IO.mode;
put $mode.fmt: &#39;%04o&#39;;   # 0644</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
某些 POSIX 或 Unix 特定的想法不适用于 Windows。在我写的时候，没有特定于 Windows 的模块来填补这些空白。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>每组权限需要三位：一个用于读，一个用于写和一个用于执行。你使用位运算符（你还没有看到它们）从单个数字中提取单独的权限。</p>
</div>
<div class="paragraph">
<p>按位 AND 运算符 <code>+&amp;</code>，使用位掩码（例如以下示例中的 <code>0o700</code>）隔离集合。按位右移运算符 <code>+&gt;</code>，提取正确的数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $file = &#39;/etc/hosts&#39;;
my $mode = $file.IO.mode;
put $mode.fmt: &#39;%04o&#39;;   # 0644

my $user  = ( $mode +&amp; 0o700 ) +&gt; 6;
my $group = ( $mode +&amp; 0o070 ) +&gt; 3;
my $all   = ( $mode +&amp; 0o007 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>在每个权限集内，你可以使用另一个掩码来隔离你想要的位。在这部分你将最终得到 <code>True</code> 或 <code>False</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put qq:to/END/;
mode: { $mode.fmt: &#39;%04o&#39; }
  user:  $user
    read:    { ($user +&amp; 0b100).so }
    write:   { ($user +&amp; 0b010).so }
    execute: { ($user +&amp; 0b001).so }
  group: { $group }
  all:   { $all }
END</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用 <code>chmod</code> 子例程更改这些权限。给它相同的数字。将它表示为十进制数字可能最简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">chmod $file.IO.chmod: 0o755;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_file_times">FILE TIMES</h5>
<div class="paragraph">
<p><code>.modified</code>，<code>.accessed</code> 和 <code>.changed</code> 方法返回表示文件的修改，访问和 inode 更改时间的 [<code>Instant</code>](<a href="https://docs.raku.org/type/Instant.html" class="bare">https://docs.raku.org/type/Instant.html</a>) 对象（如果你的系统支持这些）。你可以使用 <code>.DateTime</code> 方法将 [<code>Instant</code>](<a href="https://docs.raku.org/type/Instant.html" class="bare">https://docs.raku.org/type/Instant.html</a>) 转换为人类可读的日期：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $file = &#39;/home/hamadryas/.bash_profile&#39;;

given $file.IO {
    if .e {
        put qq:to/HERE/
            Name:    $_
                Modified: { .modified.DateTime }
                Accessed: { .accessed.DateTime }
                Changed:  { .changed.DateTime  }
                Mode:     { .mode     }
            HERE
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这给出了这样的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Name:    /home/hamadryas/.bash_profile
    Modified: 2018-08-15T01:19:09Z
    Accessed: 2018-08-16T10:07:00Z
    Changed:  2018-08-15T01:19:09Z
    Mode:     0664</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_linking_and_unlinking_files">4.6.3. Linking and Unlinking Files</h4>
<div class="paragraph">
<p>文件名是你存储在某处的某些数据的标签。重要的是要记住名称不是数据。同样，目录或文件夹的隐喻就是这样。它并不真正“包含”文件。它知道它应该记住的文件名列表。牢记这一点应该使下一部分更容易掌握。</p>
</div>
<div class="paragraph">
<p>名称是数据的链接，相同的数据可以有多个链接。只要有链接，你就可以获得该数据。这并不意味着数据在没有链接时会消失。存储的那些部分仅用于其他部分。这就是你有时可以恢复数据的原因。你的特定文件系统可能会以不同的方式执行操作，但这是基本的想法。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
通常，你删除链接的能力取决于目录权限，而不是文件权限。你实际上是从目录所包含的文件列表中删除该文件。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要删除文件，请使用 <code>.unlink</code> 删除指向它的链接。你没有删除数据;这就是为什么它不被称为 <code>.delete</code> 或类似的东西的原因。其他指向相同数据的链接可能仍然存在。如果 <code>.unlink</code> 可以删除该文件，则返回 <code>True</code>。如果失败则返回 <code>X::IO::Unlink</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $file = &#39;/etc/hosts&#39;.IO;

try {
CATCH {
    when X::IO::Unlink { put .message }
    }
$file.unlink;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用子例程形式同时删除多个文件。它返回你必须从备份还原的文件的名称（也称为成功取消链接的文件）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @unlinked-files = unlink @files;</code></pre>
</div>
</div>
<div class="paragraph">
<p>[<code>集合</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) 的差集在这里很有用，虽然在第 14 章之前你不会看到 [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html)。请注意，你可以取消链接不存在的文件，它们不会出现在" class="bare">https://docs.raku.org/type/Set.html)。请注意，你可以取消链接不存在的文件，它们不会出现在</a> <code>@error-files</code> 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @error-files = @files.Set (-) @unlinked-files.Set;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以删除原始文件名，但数据仍然存在。文件背后的数据一直存在，直到所有链接消失。这些都不能删除目录，但你马上会看到如何做到这一点。</p>
</div>
<div class="paragraph">
<p>使用 <code>.link</code> 为某些数据创建新标签。该路径必须与数据位于同一磁盘或分区上。如果这不起作用，则失败并抛出 <code>X::IO::Link</code> 异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $file = &#39;/Users/hamadryas/test.txt&#39;.IO;

{
CATCH {
    when X::IO::Unlink { ... }
    when X::IO::Link { ... }
    }

$file.link: &#39;/Users/hamadryas/test2.txt&#39;;
$file.unlink;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有另一种链接，称为符号链接（简称“符号链接”）。这不是一个实际的链接;它是指向另一个文件名（“目标”）的文件。当文件系统遇到符号链接时，它会使用目标路径。</p>
</div>
<div class="paragraph">
<p>目标是最终文件名。你创建的符号链接指向该文件名。在目标上调用 <code>.symlink</code> 来创建指向它的文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
CATCH {
    when X::IO::Symlink { ... }
    }

$target.symlink: &#39;/opt/different/disk/test.txt&#39;;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_重命名和复制文件">4.6.4. 重命名和复制文件</h4>
<div class="paragraph">
<p>要更改文件名，请使用 <code>.rename</code>。与 <code>.link</code> 一样，这仅适用于同一磁盘或分区。它会在不移动数据的情况下更改标签。如果它无法做到这一点，则会失败并抛出 <code>X::IO::Rename</code> 异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $file = &#39;/Users/hamadryas/test.txt&#39;.IO;

{
CATCH {
    when X::IO::Rename { put .message }
    }
$file.rename: &#39;/home/hamadryas/other-dir/new-name.txt&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以将数据复制（<code>.copy</code>）到其他设备或分区。这会将数据物理地放在磁盘上的新位置上。原始数据及其链接保留在原地，复制的数据有自己的链接。之后，两者没有连接，你有两个单独的数据副本。如果它不起作用，则会失败并抛出 <code>X::IO::Copy</code> 异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $file = &#39;/Users/hamadryas/test.txt&#39;.IO;

{
CATCH {
    when X::IO::Copy { put .message }
    }
$file.copy: &#39;/opt/new-name.txt&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>.move</code> 首先复制数据然后删除原始数据。如果文件已经存在， <code>.copy</code> 将替换新文件（并且它具有正确的权限））：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $file = &#39;/Users/hamadryas/test.txt&#39;.IO;

{
CATCH {
    when X::IO::Move { put .message }
    }
$file.copy: &#39;/opt/new-name.txt&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>:create-only</code> 副词来阻止替换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$file.copy: &#39;/opt/new-name.txt&#39;, :create-only;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.move</code> 方法结合了 <code>.copy</code> 和 <code>.unlink</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$file.move: &#39;/opt/new-name.txt&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>复制文件后 <code>.move</code> 可能无法删除原始文件。你可能希望在开始之前检查该权限，但无法保证权限不会更改。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_操作目录">4.7. 操作目录</h3>
<div class="paragraph">
<p>程序启动时，会知道它的当前工作目录。当前工作目录存储在特殊变量 <code>$*CWD</code> 中。处理相对文件路径时，程序会在当前目录中查找：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;Current working directory is $*CWD&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要更改该目录，请使用 <code>chdir</code>。给它一个绝对路径来改变到那个目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">chdir( &#39;/some/other/path&#39; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>给它一个相对路径来改变到当前工作目录的子目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">chdir( &#39;a/relative/path&#39; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果失败，则返回带有`X::IO::Chdir` [<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)的" class="bare">https://docs.raku.org/type/Exception.html)的</a> [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html)：" class="bare">https://docs.raku.org/type/Failure.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unless my $dir = chdir $subdir {
    ... # handle the error
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>不带参数的`chdir`会给你一个错误。你可能希望转到你的家目录。如果需要，请使用 <code>$*HOME</code> 作为参数。这是存储家目录的特殊变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">chdir( $*HOME );</code></pre>
</div>
</div>
<div class="paragraph">
<p>如何设置 <code>$*HOME</code> 取决于你的特定系统。在类 Unix 系统上，这可能是 <code>HOME</code> 环境变量。在 Windows 上，它可能是 <code>HOMEPATH</code>。</p>
</div>
<div class="paragraph">
<p>练习8.2 输出你的家目录路径。创建一个现有子目录的新路径并切换到该目录。输出当前工作目录的值。如果子目录不存在会发生什么？</p>
</div>
<div class="paragraph">
<p>有时你只需要为程序的一小部分更改目录，之后你就想回到你开始的地方。 <code>indir</code> 子例程接收目录和代码块并运行该代码，就好像它是当前的工作目录一样。它实际上并没有弄乱 <code>$*CWD</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result = indir $dir, { ... };
unless $result {
    ... # handle the error
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果一切正常，则 <code>indir</code> 返回块的结果，尽管可能是 <code>False</code> 值甚至是 [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html)。如果" class="bare">https://docs.raku.org/type/Failure.html)。如果</a> <code>indir</code> 无法更改到目录，则返回 [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html)。小心你正在处理的情况！" class="bare">https://docs.raku.org/type/Failure.html)。小心你正在处理的情况！</a></p>
</div>
<div class="sect3">
<h4 id="_目录清单">4.7.1. 目录清单</h4>
<div class="paragraph">
<p><code>dir`获取目录中的文件[`序列</code>](<a href="https://docs.raku.org/type/Seq.html)作为" class="bare">https://docs.raku.org/type/Seq.html)作为</a> [<code>IO::Path</code>](<a href="https://docs.raku.org/type/IO::Path.html" class="bare">https://docs.raku.org/type/IO::Path.html</a>) 对象。它包含隐藏文件（但不包括 <code>.</code> 和 <code>..</code> 虚拟文件）。如果不带参数则它使用当前目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @files = dir();
my $files = dir();</code></pre>
</div>
</div>
<div class="paragraph">
<p>With an argument it gets a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) of the files in the specified directory:</p>
</div>
<div class="paragraph">
<p>如果 <code>dir</code> 带参数，则它获取指定目录中的文件[<code>序列</code>](<a href="https://docs.raku.org/type/Seq.html)：" class="bare">https://docs.raku.org/type/Seq.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @files = dir( &#39;/etc&#39; );

for dir( &#39;/etc&#39; ) -&gt; $file {
    put $file;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>[<code>序列</code>](<a href="https://docs.raku.org/type/Seq.html)中的元素包含该路径组件。相对目录参数返回相对路径。如果在创建"><code>序列</code></a>(<a href="https://docs.raku.org/type/Seq.html)后更改工作目录，那些路径可能无效：" class="bare">https://docs.raku.org/type/Seq.html)后更改工作目录，那些路径可能无效：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say dir( &#39;/etc&#39; ); # (&#34;/etc/emond.d&#34;.IO ...)
say dir( &#39;lib&#39; ); # (&#34;lib/raku&#34;.IO ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果遇到问题，<code>dir `会返回 [`Failure</code>](<a href="https://docs.raku.org/type/Failure.html)，例如不存在的目录。" class="bare">https://docs.raku.org/type/Failure.html)，例如不存在的目录。</a></p>
</div>
<div class="paragraph">
<p><code>dir</code> 的另一个不错的功能是：它知道要跳过哪些条目。有一个可选的第二个参数，可以测试条目以决定它们是否应该成为结果的一部分。默认情况下，测试是一个 [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)（第14章），它排除了" class="bare">https://docs.raku.org/type/Junction.html)（第14章），它排除了</a> <code>.</code> 和 <code>..</code> 虚拟目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say dir( &#39;lib&#39;, test =&gt; none( &lt;. ..&gt; ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>练习8.3 输出另一个目录中所有文件的列表。每行显示一个并给每行编号。你能对文件列表进行排序吗？如果你没有想要浏览的目录，请在类 Unix 系统上尝试 <code>/etc</code>，或在 Windows 上尝试 <code>C:\rakudo</code>。</p>
</div>
<div class="paragraph">
<p>练习8.4 创建一个接收目录名并列出其中所有文件的程序。下降到子目录并列出他们的文件。稍后你将在第19章中使用该程序。</p>
</div>
</div>
<div class="sect3">
<h4 id="_创建目录">4.7.2. 创建目录</h4>
<div class="paragraph">
<p>你可以使用 <code>mkdir</code> 创建自己的目录。如果这是你要求的，它可以立即为你创建多层级的子目录。如果 <code>mkdir</code> 无法创建目录，则会抛出 <code>X::IO::Mkdir</code>  [<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)：" class="bare">https://docs.raku.org/type/Exception.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">try {
    CATCH {
        when X::IO::Mkdir { put &#34;Exception is {.message}&#34; }
    }
    my $subdir = &#39;Butterflies&#39;.IO.add: &#39;Hamadryas&#39;;
    mkdir $subdir;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可选的第二个参数是 Unix 风格的八进制模式（Windows 忽略此参数）。 Unix 权限最容易读作八进制数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">mkdir $subdir, 0o755;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以从[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)开始，然后使用" class="bare">https://docs.raku.org/type/Str.html)开始，然后使用</a> <code>.IO</code> 将其转换为 [<code>IO::Path</code>](<a href="https://docs.raku.org/type/IO::Path.html" class="bare">https://docs.raku.org/type/IO::Path.html</a>) 对象，然后在所有这些对象上调用 <code>.mkdir</code>。你省略或不省略模式都可以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$subdir.IO.mkdir;
$subdir.IO.mkdir: 0o755;</code></pre>
</div>
</div>
<div class="paragraph">
<p>练习8.5 编写一个程序来创建一个在命令行中指定的子目录。将完整路径指定为参数时会发生什么？如果目录已经存在怎么办？</p>
</div>
</div>
<div class="sect3">
<h4 id="_移除目录">4.7.3. 移除目录</h4>
<div class="paragraph">
<p>有两种方法可以删除目录，但你可能只想使用其中一种。在开始使用这些之前，你可能会考虑使用虚拟机的快照或在无法删除任何重要内容的特殊帐户中工作。小心！</p>
</div>
<div class="paragraph">
<p>第一个是 <code>rmdir</code>，只要目录是空的（没有文件或子目录）就删除一个或多个目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @directories-removed = rmdir @dirs;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用方法形式，你可以一次删除一个。如果失败则抛出 <code>X::IO::Rmdir</code> [<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)：" class="bare">https://docs.raku.org/type/Exception.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">try {
    CATCH {
        when X::IO::Rmdir { ... }
    }
    $directory.IO.rmdir;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这有点不方便。通常，你希望删除目录及其包含的所有内容。 <code>File::Directory::Tree</code> 中的 <code>rmtree</code> 子例程对此非常有用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use File::Directory::Tree;
my $result = try rmtree $directory;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_格式化输出">4.8. 格式化输出</h3>
<div class="paragraph">
<p>你可以在输出值之前格式化值，也可以将值插入到[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)中。选项遵循你在其他语言中已经看到的内容，因此你只能在这里体验它们。" class="bare">https://docs.raku.org/type/Str.html)中。选项遵循你在其他语言中已经看到的内容，因此你只能在这里体验它们。</a></p>
</div>
<div class="paragraph">
<p>将模板[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)赋予" class="bare">https://docs.raku.org/type/Str.html)赋予</a> <code>.fmt</code> 以描述值的显示方式。模板使用指令; 这些指令以 <code>%</code> 开头，并用字符来描述格式。下面这些是以十六进制（<code>%x</code>），八进制（<code>%o</code>）和二进制（<code>％b</code>）格式化的同一个数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = 108;

put .fmt: &#39;%x&#39;;    # 6c
put .fmt: &#39;%X&#39;;    # 6C (uppercase!)
put .fmt: &#39;%o&#39;;    # 154
put .fmt: &#39;%b&#39;;    # 1101100</code></pre>
</div>
</div>
<div class="paragraph">
<p>某些指令有额外的选项，这些选项出现在 <code>％</code> 和字母之间。数字指定列的最小宽度（尽管可能会溢出）。前导零使用零填充未使用的列。插值[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)时可以看到这种情况;格式化输出周围的字符清楚地表明" class="bare">https://docs.raku.org/type/Str.html)时可以看到这种情况;格式化输出周围的字符清楚地表明</a> <code>.fmt</code> 创建了什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;$_ is ={.fmt: &#39;%b&#39;}=&#34;;    # 108 is =1101100=
put &#34;$_ is ={.fmt: &#39;%8b&#39;}=&#34;;   # 108 is = 1101100=
put &#34;$_ is ={.fmt: &#39;%08b&#39;}=&#34;;  # 108 is =01101100=</code></pre>
</div>
</div>
<div class="paragraph">
<p>模板文本可以包含其他字符。如果这些不是指令的一部分，则它们是字面字符。这会将前面的示例翻出来，因此所有字符都在模板中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put .fmt: &#34;$_ is =%08b=&#34;;  # 108 is =01101100=</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想要一个字面的 <code>％</code> 符号则用另一个 <code>％</code> 转义它。 <code>％f</code> 指令格式化一个浮点数，这对百分比很方便。你可以指定总宽度（包括小数点）和小数位数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = 1;
my $d = 7;
put (100*$n/$d).fmt: &#34;$n/$d is %5.2f%%&#34;;  # 1/7 is 14.29%</code></pre>
</div>
</div>
<div class="paragraph">
<p>省略总宽度仍然有效，并允许你仅指定小数位数。这会将最终显示的十进制数字舍入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put (100*$n/$d).fmt: &#34;$n/$d is %.2f%%&#34;;  # 1/7 is 14.29%</code></pre>
</div>
</div>
<div class="paragraph">
<p>Calling <code>.fmt</code> on a [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) formats each element according to the template, joins them with a space, and gives you a single [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>):</p>
</div>
<div class="paragraph">
<p>在 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) 上调用 <code>.fmt</code> 会根据模板格式化每个元素，将它们与空格连接，并为你提供单个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)：" class="bare">https://docs.raku.org/type/Str.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put ( 222, 173, 190, 239 ).fmt: &#39;%02x&#39;;  # de ad be ef</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.fmt</code> 的第二个参数更改分隔符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put ( 222, 173, 190, 239 ).fmt: &#39;%02x&#39;, &#39;&#39;;  # deadbeef</code></pre>
</div>
</div>
<div class="paragraph">
<p>`sprintf`可以通过更多的控制来完成同样的工作。这是一个例程，它接收同样的模板作为它的第一个参数，然后是一个值列表。每个值按顺序填充一个指令。你不必输出结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = sprintf( &#39;%2d %s&#39;, $line-number, $line );</code></pre>
</div>
</div>
<div class="paragraph">
<p>`printf`执行相同的操作并直接将结果输出到标准输出（不添加换行符）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">printf &#39;%2d %s&#39;, $line-number, $line;</code></pre>
</div>
</div>
<div class="paragraph">
<p>[表8-2](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch08.html#camelia-files-TABLE-directives)列出了一些可用的" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch08.html#camelia-files-TABLE-directives)列出了一些可用的</a> <code>sprintf</code> 指令。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Directive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>%d</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">十进制有符号整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>%u</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">十进制无符号整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>%o</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">八进制无符号整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>%x</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">十六进制无符号整数 (小写)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>%X</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">十六进制无符号整数 (大写)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>%b</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">二进制无符号整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>%f</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">浮点数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>%s</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文本值</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>练习8.6 创建一个使用 <code>printf</code> 的程序，并将右对齐文本输出到你指定的列数。输出标尺线可能会对你有所帮助。</p>
</div>
<div class="sect3">
<h4 id="_常见的格式化任务">4.8.1. 常见的格式化任务</h4>
<div class="paragraph">
<p>使用 <code>％f</code> 舍入数字。指定整个模板的宽度和小数位数。小数点和后续数字计为宽度的一部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put (2/3).fmt: &#39;%4.2f&#39;;  # 0.67;</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，总宽度不限制列。它至少是那个列数，但可能更多：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put (2/3).fmt: &#39;%4.5f&#39;;  # 0.66667;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你不关心宽度，可以将其省略。这只是将值舍入为你指定的小数位数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put (2/3).fmt: &#39;%.3f&#39;;  # 0.667;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>%</code> 之后的 <code>#</code> 添加了数字系统前缀，但不是 Raku 使用的前缀。它是宇宙其余部分使用的前缀; 八进制数得到前导零：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put 108.fmt: &#39;%#x&#39;; # 0x6c
put 108.fmt: &#39;%#o&#39;; # 0154</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>％s</code> 格式化文本值。使用宽度它将值向右推，并在必要时用空格填充它。 宽度前面的 <code>-</code> 将文本推向左侧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Hamadryas&#39;.fmt: &#39;|%s|&#39;;    # |Hamadryas|
put &#39;Hamadryas&#39;.fmt: &#39;|%15s|&#39;;  # |      Hamadryas|
put &#39;Hamadryas&#39;.fmt: &#39;|%-15s|&#39;; # |Hamadryas      |</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>sprintf</code> 创建柱状输出。宽度使一切排成一行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = sprintf &#39;%02d %-20s %5d %5d %5d&#39;, @values;</code></pre>
</div>
</div>
<div class="paragraph">
<p>练习8.7 输出你在命令行中指定的两个数字的百分比。将输出限制为三位小数。</p>
</div>
<div class="paragraph">
<p>练习8.8 输出一个12乘12的乘法表。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_标准文件句柄">4.9. 标准文件句柄</h3>
<div class="paragraph">
<p>文件句柄是程序和文件之间的连接。你可以免费获得其中的三个。两个用于输出，一个用于输入。标准输出是你从本书开始以来一直使用的输出。它是输出的默认文件句柄。你还使用了标准错误，因为这是用于警告和错误的文件句柄。标准输入将你的程序连接到某人试图提供的数据上。</p>
</div>
<div class="paragraph">
<p>在继续阅读和编写任意文件的一般过程之前，你可能会发现查看基本文件句柄很有用。如果你已经知道这些事情，那么跳过本节并无不妥。</p>
</div>
<div class="sect3">
<h4 id="_标准输出">4.9.1. 标准输出</h4>
<div class="paragraph">
<p>标准输出是大多数输出方法的默认文件句柄。当你在其例程形式中使用其中任何一个时，你就正在使用标准输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put $up-the-dishes;
say $some-stuff;
print $some-stuff;
printf $template, $thing1, $thing2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>$*OUT</code> 上调用方法会使其显式化。这是保存默认文件句柄的特殊变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$*OUT.put: $up-the-dishes;
$*OUT.say: $some-stuff;
$*OUT.print: $some-stuff;
$*OUT.printf: $template, $thing1, $thing2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可能在某些时候在命令行上使用了重定向。 <code>&gt;</code> 将程序的标准输出发送到文件（或其他地方）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku program.p6 &gt; output.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要运行程序但不关心输出，可以将其发送到空设备。输出无处可去，然后消失了。这在 Unix 系统和 Windows 中略有不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku program.p6 &gt; /dev/null
C:\ raku program.p6 &gt; NUL</code></pre>
</div>
</div>
<div class="paragraph">
<p>练习8.9 创建一个将内容写入标准输出的程序。运行该程序并将输出重定向到文件。再次运行它并将输出重定向到空设备。</p>
</div>
</div>
<div class="sect3">
<h4 id="_标准错误">4.9.2. 标准错误</h4>
<div class="paragraph">
<p>标准错误是输出的另一种途径。当程序不希望影响正常输出时，程序通常会对警告和其他消息使用标准错误。你可以在不搞乱格式化输出的情况下获得警告。</p>
</div>
<div class="paragraph">
<p><code>warn</code> 将其消息输出到标准错误，程序继续。顾名思义，当你遇到一个你可以预料到并且你认为有人应该知道的情况时，它就是为警告而设计的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">warn &#39;You need to use a number between 0 and 255&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>fail</code> 和 <code>die</code> 是相似的。他们将消息发送到标准错误，但他们也可以停止你的程序，除非你捕获或处理它们。</p>
</div>
<div class="paragraph">
<p><code>note</code> 就像 <code>say</code>;它在其参数上调用 <code>.gist</code> 并将结果输出到标准错误。这对调试输出很有用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">note $some-object;</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常这种输出是通过某些命令行开关或其他设置启用的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">note $some-object if $debugging &gt; 0;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出方法适用于 <code>$*ERR</code>，它保存默认错误文件句柄：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$*ERR.put: &#39;This is a warning message&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你在终端中工作时，通常会同时看到标准输出和标准错误（或“合并”）。用 <code>2&gt;</code> 重定向错误输出;获取文件描述符编号 2（标准错误）并将其发送到不是终端的某个地方。如果你不理解任何一个，只需按照例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku program.p6 2&gt; error_output.txt
C:\ raku program.p6 2&gt; error_output.txt

% raku program.p6 2&gt; /dev/null
C:\ raku program.p6 2&gt; NUL</code></pre>
</div>
</div>
<div class="paragraph">
<p>将文件描述符 2 重定向到文件描述符 1 以合并标准输出和错误。同样，你可以按照示例进行操作，而无需追根究底：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku program.p6 2&gt;&amp;1 /dev/null</code></pre>
</div>
</div>
<div class="paragraph">
<p>练习8.10 创建一个程序，输出标准输出和标准错误。运行它并将标准输出重定向到文件。再次运行它，但将标准错误重定向到空设备。</p>
</div>
</div>
<div class="sect3">
<h4 id="_标准输入">4.9.3. 标准输入</h4>
<div class="paragraph">
<p>当你使用没有命令行参数的 <code>lines()</code> 时，它会从标准输入读取。数据流入你的程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for lines() {
    put ++$, &#39;: &#39;, $_;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你的程序会等待你输入内容并将其输出给你：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku no-args.p6
Hello Raku
0: Hello Raku
this is the second line
1: this is the second line</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you only want standard input you can explicitly use <code>$*IN</code>. Call <code>.lines</code> as follows:</p>
</div>
<div class="paragraph">
<p>如果你只想要标准输入，则可以显式地使用 <code>$*IN</code>。像下面这样调用 <code>.lines</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $*IN.lines() {
    put ++$, &#39;: &#39;, $_;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>标准输入也可以来自另一个程序。你可以将一个程序的输出传递给另一个程序的输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku out-err.p6 | raku no-args.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>练习8.11 创建两个程序。第一个应输出包含第一个参数的命令行文件中的所有行。将其输出通过管道输出到第二个程序，读取其输入并以全部大写形式输出。将第一个程序的输出通过管道输入到第二个程序。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_读取输入">4.10. 读取输入</h3>
<div class="paragraph">
<p>你已经看到了将数据导入程序的几种方法。<code>prompt</code> 例程输出一条消息并等待一行输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $answer = prompt( &#39;Enter some stuff&gt; &#39; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>用 <code>slurp</code> 一次性读取整个文件。<code>slup</code> 作为方法或例程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $entire-file = $filename.IO.slurp;
my $entire-file = slurp $filename;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你无法阅读该文件，你将收到 [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html)。始终检查你是否能够做你想做的事情：" class="bare">https://docs.raku.org/type/Failure.html)。始终检查你是否能够做你想做的事情：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unless my $entire-file = slurp $filename.IO.slurp {
    ... # handle error
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_读取行">4.10.1. 读取行</h4>
<div class="paragraph">
<p>在第6章中，你了解了如何使用 <code>lines()</code> 从你在命令行中指定的文件名中读取行。通过 <code>@*ARGS</code> 并在单个文件上调用 <code>lines</code> 来自己完成此操作。你可以过滤掉不存在或存在其他问题的文件（<code>lines()</code> 不执行的操作）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @*ARGS {
    put &#39;=&#39; x 20, &#39; &#39;, $_;

    # maybe more error checking here
    unless .IO.e { put &#39;Does not exist&#39;; next }

    for .IO.lines() {
        put &#34;$_:&#34;, ++$, &#39; &#39;, $_;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这代码有点太多了。 <code>lines()</code> 从 <code>$*ARGFILES</code> 文件句柄读取。这与显式使用它是一样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $*ARGFILES.lines() {
    put ++$, &#39;: &#39;, $_;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>$*ARGFILES.path</code> 提取当前文件名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $*ARGFILES.lines() {
    put &#34;{$*ARGFILES.path}:&#34;, ++$, &#39; &#39;, $_;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这不会处理为每个文件开始编号为新鲜的行，但是有一个技巧：<code>$*ARGFILES</code> 知道在切换文件时让你在发生这种情况时运行一些代码。给  <code>.on-switch</code> 一个代码块，以便在文件更改时运行。用它来重置持久计数器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for lines() {
    state $lines = 1;
    FIRST { $*ARGFILES.on-switch = { $lines = 1 } }

    put &#34;{$*ARGFILES.path}:{$lines++} $_&#34;;
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当我写这篇文章时，如果 <code>lines</code> 遇到一个无法读取的文件，则抛出一个你无法恢复的[<code>异常</code>](<a href="https://docs.raku.org/type/Exception.html)。我会忽略这一点，因为我希望情况很快就会改变。" class="bare">https://docs.raku.org/type/Exception.html)。我会忽略这一点，因为我希望情况很快就会改变。</a>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>练习8.12 创建一个程序，输出你在命令行中指定的所有文件的行。在输出每个文件的行之前输出显示其名称的文件横幅。完成上一个文件后会发生什么？</p>
</div>
</div>
<div class="sect3">
<h4 id="_读取文件">4.10.2. 读取文件</h4>
<div class="paragraph">
<p>Both <code>slurp</code> and <code>lines</code> handle the details implicitly. <code>open</code> lets you do it in whatever manner you like. It returns a filehandle that you use to get the data from the file. If there’s a problem <code>open</code> returns a [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>):</p>
</div>
<div class="paragraph">
<p><code>slurp</code> 和 <code>lines</code> 都隐式地处理细节。 <code>open</code> 允许你以任何你喜欢的方式来做。它返回一个文件句柄，用于从文件中获取数据。如果出现问题，则 <code>open</code> 返回[<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html)：" class="bare">https://docs.raku.org/type/Failure.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open &#39;not-there&#39;;
unless $fh {
    put &#34;Error: { $fh.exception }&#34;;
    exit;
}

for $fh.lines() { .put }</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可能更喜欢方法形式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = $filename.IO.open;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以更改编码，行结束处理和特定行结束。 <code>:enc</code> 副词设置输入编码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open &#39;not-there&#39;, :enc(&#39;latin1&#39;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>To keep the line endings instead of autochomping them, use <code>:chomp</code>:</p>
</div>
<div class="paragraph">
<p>要保留行结尾而不是自动切除，请使用 <code>:chomp</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open &#39;not-there&#39;, :chomp(False);</code></pre>
</div>
</div>
<div class="paragraph">
<p>行结尾设置为 <code>:nl-in</code> 并且可以是多个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)，其中任何一个都可以工作：" class="bare">https://docs.raku.org/type/Str.html)，其中任何一个都可以工作：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open &#39;not-there&#39;, :nl-in( &#34;\f&#34; );
my $fh = open &#39;not-there&#39;, :nl-in( [ &#34;\f&#34;, &#34;\v&#34; ] );</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你不想结束行（比如 <code>slurp</code>），空的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)或" class="bare">https://docs.raku.org/type/Str.html)或</a> <code>False</code> 会起作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open &#39;not-there&#39;, :nl-in( &#39;&#39; );
my $fh = open &#39;not-there&#39;, :nl-in( False );</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以读取单行。告诉 <code>.lines</code> 你想要多少行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $next-line = $fh.lines: 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.lines</code> 是惰性的。那实际上没有读取一行。直到你尝试使用 <code>$next-line</code> 时它才会这样做。如果你想让它立即发生，你可以让它急切：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $next-line = $fh.lines(1).eager;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想要所有的行你仍然可以从文件句柄 <code>.slurp</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $rest-of-data = $fh.slurp;</code></pre>
</div>
</div>
<div class="paragraph">
<p>完成后关闭文件句柄。程序将在某些时候自动为你执行此操作，但你不希望这些事情可能会在程序结束时出现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$fh.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>练习8.13 打开在命令行中指定的每个文件。输出第一行和最后一行。在这两者之间报告你遗漏的行数。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_写出">4.11. 写出</h3>
<div class="paragraph">
<p>写文件的最简单方法是使用 <code>spurt</code>。给它一个文件名和一些数据，它为你完成剩下的工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">spurt $path, $data;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果文件已存在，则会覆盖已存在的任何内容。要添加已经存在的内容，请使用 <code>:append</code> 副词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">spurt $path, $data, :append;</code></pre>
</div>
</div>
<div class="paragraph">
<p>仅当文件尚不存在时，你才可以通过指定 <code>:exclusive</code> 来输出数据。如果文件已经存在，则会失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">spurt $path, $data, :exclusive;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当 <code>spurt</code> 工作时，它返回 <code>True</code>。如果出现问题则返回 [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html)：" class="bare">https://docs.raku.org/type/Failure.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unless spurt $path, $data {
    ... # handle error
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_打开文件以写入">4.11.1. 打开文件以写入</h4>
<div class="paragraph">
<p>使用 <code>spurt</code> 可能很方便，但每次使用它时，你真正打开了一个文件，写入文件并关闭它。如果你想继续添加到文件中，你可以自己打开文件并保持打开状态，直到完成为止：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unless my $fh = open $path, :w {
    ...;
    }

$fh.print: $data;
$fh.print: $more-data;</code></pre>
</div>
</div>
<div class="paragraph">
<p>任何输出方法都适用于文件句柄：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$fh.put: $data;
$fh.say: $data;</code></pre>
</div>
</div>
<div class="paragraph">
<p>完成文件后调用 <code>.close</code>。这可确保较低级别可能已缓冲的任何数据都会进入文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$fh.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你不喜欢默认行分隔符，则可以指定自己的行分割符。当你有多行的项要包含在一起作为单个记录时，换页符`\f`，作为“行”分隔符很方便：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unless my $fh = open $path, :w, :nl-out(&#34;\f&#34;) {
    ...;  # handle the error
    }

$fh.print: ...;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>try</code> 可能更干净：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = try open $path, :w, :exclusive, :enc(&#39;latin1&#39;), :nl-out(&#34;\f&#34;);
if $! {
    ... # handle the error
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>练习8.14 创建一个程序，该程序将你在命令行中指定的两个数字之间的所有素数写入文件。如果文件已存在，你应该怎么做？</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_二进制文件">4.12. 二进制文件</h3>
<div class="paragraph">
<p>二进制文件不是基于字符的。图像，电影等都是例子。你不希望文件阅读器将这些解码为 Perl 的内部字符格式;你想要原始数据。使用带有 <code>:bin</code> 副词的 <code>slurp</code> 来读取。它返回一 [<code>Buf</code>](<a href="https://docs.raku.org/type/Buf.html" class="bare">https://docs.raku.org/type/Buf.html</a>) 而不是返回一个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)。你可以像任何其他" class="bare">https://docs.raku.org/type/Str.html)。你可以像任何其他</a> [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) 一样处理 [<code>Buf</code>](<a href="https://docs.raku.org/type/Buf.html)：" class="bare">https://docs.raku.org/type/Buf.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $buffer = slurp $filename, :bin;  # Buf object
for @$buffer { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用相同的 <code>:bin</code> 副词打开文件以获取其原始内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unless my $fh = open $path, :bin {
    ... # handle the error
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_移动">4.12.1. 移动</h4>
<div class="paragraph">
<p>告诉 <code>.read</code> 要读取多少个八位字节，它返回一个 [<code>Buf</code>](<a href="https://docs.raku.org/type/Buf.html)，其中每个元素是" class="bare">https://docs.raku.org/type/Buf.html)，其中每个元素是</a> 0 到 255 之间的整数（无符号8位范围）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Buf $buffer = $fh-&gt;read( $count );</code></pre>
</div>
</div>
<div class="paragraph">
<p>[<code>Buf</code>](<a href="https://docs.raku.org/type/Buf.html" class="bare">https://docs.raku.org/type/Buf.html</a>) 是一种 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html)。每个八位字节都是缓冲区的一个元素，你可以通过它的位置获得一个八位字节：" class="bare">https://docs.raku.org/type/Positional.html)。每个八位字节都是缓冲区的一个元素，你可以通过它的位置获得一个八位字节：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $third_byte = $buffer[2];</code></pre>
</div>
</div>
<div class="paragraph">
<p>下次调用 <code>.read</code> 时，你将从文件中你离开的位置开始获取八位字节。使用 <code>.seek</code> 移动到其他位置。指定`SeekFromCurrent` 从你离开的位置移动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $relative_position = 137;
$fh.seek( $relative_position, SeekFromCurrent );</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用负值向后移动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $negative_position = -137;
$fh.seek( $negative_position, SeekFromCurrent );</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果指定 <code>SeekFromBeginning</code>，它将从文件的开头开始计数并移动到你指定的绝对位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $absolute_position = 1370;
$fh.seek( $absolute_position, SeekFromBeginning );</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 8.15 写一个小的十六进制转储程序。一次读取16个八位字节的原始文件。打印每个八位字节的十六进制值，它们之间有空格，末尾有换行符。每行应该有这样的形式：<code>20 50 65 72 6c 20 36 2c 20 4d 6f 61 72 56 4d 20</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_写二进制文件">4.12.2. 写二进制文件</h4>
<div class="paragraph">
<p>另一方面，你可以将八位字节写入文件。使用相同的 <code>:bin</code> 副词打开文件进行写入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unless my $fh = open $path, :w, :bin {
    ...;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>.write</code> 并给它一个 [<code>Buf</code>](<a href="https://docs.raku.org/type/Buf.html" class="bare">https://docs.raku.org/type/Buf.html</a>) 对象。每个元素必须是 0 到 255 之间的整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $buf = Buf.new: 82, 97, 107, 117, 100, 111, 10;
$fh.write: $buf;</code></pre>
</div>
</div>
<div class="paragraph">
<p>用十六进制表示它们可能更容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $buf = Buf.new: &lt;52 61 6b 75 64 6f 0a&gt;.map: *.parse-base: 16;</code></pre>
</div>
</div>
<div class="paragraph">
<p>练习8.16 实现程序将 [<code>Buf</code>](<a href="https://docs.raku.org/type/Buf.html" class="bare">https://docs.raku.org/type/Buf.html</a>) 写入文件。最终文件中的内容是什么？</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_4">4.13. 总结</h3>
<div class="paragraph">
<p>你在本章中看到的功能可能是你编写的许多有用程序的核心。你可以将数据放入文件中，以后再检索该数据。你可以创建目录，将文件移动到这些目录中，或者将它们全部删除。大多数操作简单明了;一旦你知道了正确的对象，你就能轻松找到所需的方法。然而，这些东西中的大多数都与外部世界相互作用，并在事情无法解决时抱怨。不要忽视那些抱怨！
== Associative</p>
</div>
<div class="paragraph">
<p>[<code>Associative</code>](<a href="https://docs.raku.org/type/Associative.html" class="bare">https://docs.raku.org/type/Associative.html</a>) 使用被称为键的任何名字索引到值。[<code>Associative</code>](<a href="https://docs.raku.org/type/Associative.html)是无序的，因为键没有相对顺序。其他语言具有类似的数据类型，它们称为关联数组，字典，散列，映射或类似的东西。有几种类型的专用关联数据结构，你已经使用了其中的一些。" class="bare">https://docs.raku.org/type/Associative.html)是无序的，因为键没有相对顺序。其他语言具有类似的数据类型，它们称为关联数组，字典，散列，映射或类似的东西。有几种类型的专用关联数据结构，你已经使用了其中的一些。</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_pairs">4.14. Pairs</h3>
<div class="paragraph">
<p>A [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) has a single key and a value. You’ve already used these in their adverbial form, although you didn’t know they were [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)s" class="bare">https://docs.raku.org/type/Pair.html)s</a>. Create a [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) through general object construction with the name and value as arguments:</p>
</div>
<div class="paragraph">
<p>[<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) 具有单个键和值。你已经以他们的副词形式使用了这些，虽然你不知道他们是 [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)。通过一般对象构造创建一个" class="bare">https://docs.raku.org/type/Pair.html)。通过一般对象构造创建一个</a> [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)，名称和值作为参数：" class="bare">https://docs.raku.org/type/Pair.html)，名称和值作为参数：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pair = Pair.new: &#39;Genus&#39;, &#39;Hamadryas&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>⇒</code> is the [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) constructor. You don’t have to quote the lefthand side because the <code>⇒</code> does that for you as long as it looks like a term:</p>
</div>
<div class="paragraph">
<p><code>⇒</code> 是 [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) 构造函数。你不必将左侧用引号引起来，因为 <code>⇒</code> 为你做了，只要它看起来像一个项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pair = Genus =&gt; &#39;Hamadryas&#39;;  # this works
my $nope = ⛇    =&gt; &#39;Hamadryas&#39;;  # this doesn&#39;t</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any value can be a [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) value. Here’s a value that’s a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>):</p>
</div>
<div class="paragraph">
<p>[<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) 的值可以是任意值。下面这个 [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) 的值是一个 [<code>List</code>](<a href="https://docs.raku.org/type/List.html)：" class="bare">https://docs.raku.org/type/List.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pair = Pair.new: &#39;Colors&#39;, &lt;blue black grey&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Combining <code>.new</code> and <code>⇒</code> probably doesn’t do what you want. Passing it a single [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) means that you are missing its value. The <code>.new</code> method thinks that the [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) is the key and you forgot the value:</p>
</div>
<div class="paragraph">
<p>结合 <code>.new</code> 和 <code>⇒</code> 可能不会做你想要的。给 <code>.new</code> 传递单个 [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) 就意味着你丢掉了值。 <code>.new</code> 方法认为 [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) 是键，而你忘记了值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pair = Pair.new: &#39;Genus&#39; =&gt; &#39;Hamadryas&#39;;  # WRONG!</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_副词">4.14.1. 副词</h4>
<div class="paragraph">
<p>A more common syntax is the adverbial form that you have already seen with <code>Q</code> quoting. Start with a colon, add the unquoted name, and specify the value inside <code>&lt;&gt;</code> for allomorphic quoting or inside <code>()</code> where you quote the value yourself:</p>
</div>
<div class="paragraph">
<p>更常见的语法是你在 <code>Q</code> 引用中已经看到的副词形式。从冒号开始，添加不带引号的名字，并在 <code>&lt;&gt;</code> 内指定用于异形引号的值，或在 <code>()</code> 中指定你自己用引号引起的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pair = :Genus&lt;Hamadryas&gt;;
my $pair = :Genus(&#39;Hamadryas&#39;);

my $genus = &#39;Hamadryas&#39;;
my $pair  = :Genus($genus);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Without an explicit value an adverb has the value <code>True</code>:</p>
</div>
<div class="paragraph">
<p>如果没有显式的值，那么副词的值为 <code>True</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pair = :name;  #  name =&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using an adverb with <code>Q</code> with no value means you turn on that feature (everything else is <code>False</code> by default):</p>
</div>
<div class="paragraph">
<p>使用不带值的 <code>Q</code> 的副词意味着你开启该功能（默认情况下其他所有内容都为 <code>False</code>）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Q :double /The name is $butterfly/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you’d like it to be <code>False</code> instead, put a <code>!</code> in front of the key name:</p>
</div>
<div class="paragraph">
<p>如果你想要它是假的，那就放一个 <code>!</code> 在键名前面：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pair = :!name; #  name =&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can create a [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) from a scalar variable. The identifier becomes the key and the value is the variable’s value. You’ll see more of this coming up:</p>
</div>
<div class="paragraph">
<p>你可以从标量变量创建一个 [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)。标识符成为键，值是变量的值。你会看到更多这样的事情：" class="bare">https://docs.raku.org/type/Pair.html)。标识符成为键，值是变量的值。你会看到更多这样的事情：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $Genus = &#39;Hamadryas&#39;;
my $pair = :$Genus;   # same as &#39;Genus&#39; =&gt; &#39;Hamadryas&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s also a tricky syntax that reverses a numeric value and alpha-headed text key. This is a bit prettier for adverbs representing positions, such as <code>1st</code>, <code>2nd</code>, <code>3rd</code>, and so on:</p>
</div>
<div class="paragraph">
<p>还有一种棘手的语法可以反转数值和带字母的文本键。这对于代表位置的副词来说有点漂亮，比如 <code>1st</code>, <code>2nd</code>, `3rd`等等：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pair = :2nd; # same as nd =&gt; 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.key</code> and <code>.value</code> methods extract those parts of the [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>):</p>
</div>
<div class="paragraph">
<p><code>.key</code> 和 <code>.value</code> 方法提取 [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) 中的那些部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;{$p.key} =&gt; {$pair.value}\n&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.kv</code> method returns both as a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>):</p>
</div>
<div class="paragraph">
<p><code>.kv</code> 方法作为 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 返回：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put join &#39; =&gt; &#39;, $pair.kv;</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 9.1Develop a subroutine that creates [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)s" class="bare">https://docs.raku.org/type/Pair.html)s</a> for the numbers from 0 to 10. Given the argument <code>1</code>, it returns the [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) <code>:1st</code>. Given <code>2</code>, it returns <code>:2nd</code>. Given <code>3</code>, it returns <code>:3rd</code>. For all other numbers, it uses <code>th</code> as the suffix.</p>
</div>
<div class="paragraph">
<p>练习9.1 开发一个子例程，为 0 到 10 之间的数字创建 [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)。给定参数" class="bare">https://docs.raku.org/type/Pair.html)。给定参数</a> <code>1</code>，它返回 [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) <code>:1st</code>。给定 <code>2</code>，它返回：<code>:2nd</code>。给定 <code>3</code>，它返回：<code>:3rd</code>。对于所有其他数字，它使用 <code>th</code> 作为后缀。</p>
</div>
</div>
<div class="sect3">
<h4 id="_修改_pair">4.14.2. 修改 Pair</h4>
<div class="paragraph">
<p>You can’t change the key of a [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>). You’d have to make a new [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) to get a different key:</p>
</div>
<div class="paragraph">
<p>你无法更改 [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) 的键。你必须创建一个新的 [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) 才能获得不同的键：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pair = &#39;Genus&#39; =&gt; &#39;Hamadryas&#39;;
$pair.key = &#39;Species&#39;;  # Nope!</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) value is a container you can change the value inside the container, but if you constructed it with a literal [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) there’s no container and you can’t change the value:</p>
</div>
<div class="paragraph">
<p>如果 [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) 的值是容器，则可以更改容器内的值，但如果使用文字[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)构造它，则没有容器，并且你无法更改值：" class="bare">https://docs.raku.org/type/Str.html)构造它，则没有容器，并且你无法更改值：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pair = &#39;Genus&#39; =&gt; &#39;Hamadryas&#39;;
$pair.value = &#39;Papillo&#39;; # Nope!</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can assign to it if that value came from a variable storing a container:</p>
</div>
<div class="paragraph">
<p>如果该值来自存储容器的变量，则可以为其分配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = &#39;Hamadryas&#39;;
my $pair = &#39;Genus&#39; =&gt; $name;
$pair.value = &#39;Papillo&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember that not all variables are mutable. You may have bound to a value:</p>
</div>
<div class="paragraph">
<p>请记住，并非所有变量都是可变的。你可能已经绑定了一个值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name := &#39;Hamadryas&#39;;  # bound directly to value, no container
my $pair = &#39;Genus&#39; =&gt; $name;
$pair.value = &#39;Papillo&#39;;  # Nope! Still a fixed value</code></pre>
</div>
</div>
<div class="paragraph">
<p>To ensure that you get a container, assign the value to an anonymous scalar. You don’t create a new named variable and you end up with a container:</p>
</div>
<div class="paragraph">
<p>要确保获得容器，请将值指定给匿名标量。你不创建新的命名变量，最终得到一个容器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pair = &#39;Genus&#39; =&gt; $ = $name;
$pair.value = &#39;Papillo&#39;;  # Works!</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.freeze</code> the [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) to make the value immutable no matter how it came to you:</p>
</div>
<div class="paragraph">
<p>冻结(<code>.freeze</code>) [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) 以使值不可变，无论它以怎样呈现给你：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = &#39;Hamadryas&#39;;
my $pair = &#39;Genus&#39; =&gt; $name;
$pair.freeze;
$pair.value = &#39;Papillo&#39;;  # Nope!</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s one last thing about [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)s" class="bare">https://docs.raku.org/type/Pair.html)s</a>. You can line up the colon forms head-to-foot and it will create a list even though you don’t use commas:</p>
</div>
<div class="paragraph">
<p>[<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) 的最后一件事。你可以将冒号形式从头到脚排列，即使你不使用逗号，它也会创建一个列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pairs = ( :1st:2nd:3rd:4th );</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s the same as the form with commas:</p>
</div>
<div class="paragraph">
<p>这与逗号形式相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pairs = ( :1st, :2nd, :3rd, :4th );</code></pre>
</div>
</div>
<div class="paragraph">
<p>You’ve already seen this with <code>Q</code>: you can turn on several features by lining up adverbs. The <code>:q:a:c</code> here arethree separate adverbs:</p>
</div>
<div class="paragraph">
<p>你已经在 <code>Q</code> 中看过这个：你可以通过排列副词来开启几个功能。 <code>:q:a:c</code> 这里有三个单独的副词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Q :q:a:c /Single quoting @array[] interpolation {$name}/;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_maps">4.15. Maps</h3>
<div class="paragraph">
<p>A [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) is an immutable mapping of zero or more keys to values. You can look up the value if you know the key. Here’s a translation of color names to their RGB values. The <code>.new</code> method takes a list of [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> and their values:</p>
</div>
<div class="paragraph">
<p>[<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) 是零或多个键与值的不可变映射。如果你知道键，则可以查找该值。这是颜色名到 RGB 值的转换。 <code>.new</code> 方法接收[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)及其值的列表：" class="bare">https://docs.raku.org/type/Str.html)及其值的列表：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $color-name-to-rgb = Map.new:
    &#39;red&#39;,    &#39;FF0000&#39;,
    &#39;green&#39;,  &#39;00FF00&#39;,
    &#39;blue&#39;,   &#39;0000FF&#39;,
    ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use the <strong>fat arrow</strong> to make a list of [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)s" class="bare">https://docs.raku.org/type/Pair.html)s</a>:</p>
</div>
<div class="paragraph">
<p>你可以使用胖箭头来创建 [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) 列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $color-name-to-rgb = Map.new:
    &#39;red&#39;    =&gt; &#39;FF0000&#39;,
    &#39;green&#39;  =&gt; &#39;00FF00&#39;,
    &#39;blue&#39;   =&gt; &#39;0000FF&#39;,
    ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the fat arrow notation with autoquoting won’t work; the method thinks these are named arguments instead of [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)s" class="bare">https://docs.raku.org/type/Pair.html)s</a> for the [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) and they are treated as options to the method instead of keys and values. This gives you a [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) with no keys or values:</p>
</div>
<div class="paragraph">
<p>使用带有自动引用功能的胖箭头符号将不起作用;该方法认为这些是命名参数而不是映射的[<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)，它们被视为方法的选项而不是键和值。这为你提供了没有键或值的"><code>Map</code></a>(<a href="https://docs.raku.org/type/Map.html)：" class="bare">https://docs.raku.org/type/Map.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># don&#39;t do this!
my $color-name-to-rgb = Map.new:
    red    =&gt; &#39;FF0000&#39;,
    green  =&gt; &#39;00FF00&#39;,
    blue   =&gt; &#39;0000FF&#39;,
    ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) is fixed; you can’t change it once you’ve created it. This may be exactly what you want since it can keep something else from accidentally modifying it:</p>
</div>
<div class="paragraph">
<p>[<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) 是固定的;一旦你创建它就不能改变它。这可能正是你想要的，因为它可以防止其他东西意外修改它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$color-name-to-rgb&lt;green&gt; = &#39;22DD22&#39;; # Error!</code></pre>
</div>
</div>
<div class="paragraph">
<p>To look up one of the color codes you subscript the object. This is similar to [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html)s" class="bare">https://docs.raku.org/type/Positional.html)s</a> but uses different postcircumfix characters. Use the autoquoting <code>&lt;&gt;</code> or quote it yourself with <code>{}</code>:</p>
</div>
<div class="paragraph">
<p>要查找其中一个颜色代码，你可以下标该对象。这与 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) 类似，但使用不同的 postcircumfix 字符。使用autoquoting  <code>&lt;&gt;</code> 或使用 <code>{}</code> 自行引用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put $color-name-to-rgb&lt;green&gt;;    # quoted key with allomorph
put $color-name-to-rgb{&#39;green&#39;};  # quoted key
put $color-name-to-rgb{$color};   # quoted key with interpolation</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to look up more than one key at a time, you can use a slice to get a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) of values:</p>
</div>
<div class="paragraph">
<p>如果要一次查找多个键，可以使用切片获取值[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)：" class="bare">https://docs.raku.org/type/List.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @rgb = $color-name-to-rgb&lt;red green&gt;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_checking_keys">4.15.1. Checking Keys</h4>
<div class="paragraph">
<p>To check that a key exists before you try to use it, add the <code>:exists</code> adverb after the single-element access. This won’t create the key. You’ll get <code>True</code> if the key is in the [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) and <code>False</code> otherwise:</p>
</div>
<div class="paragraph">
<p>要在尝试使用键之前检查键是否存在，请在单元素访问后添加 <code>:exists</code> 副词。这不会创建键。如果键在 [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) 中，则为 <code>True</code>，否则为 <code>False</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $color-name-to-rgb{$color}:exists {
    $color-name-to-rgb{$color} = &#39;22DD22&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.keys</code> method returns a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) of keys:</p>
</div>
<div class="paragraph">
<p><code>.keys</code> 方法返回一个键的[<code>序列</code>](<a href="https://docs.raku.org/type/Seq.html)：" class="bare">https://docs.raku.org/type/Seq.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $color-name-to-rgb.keys {
    put &#34;$^key =&gt; {$color-name-to-rgb{$^key}}&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You do something similar to get only the values:</p>
</div>
<div class="paragraph">
<p>你做类似的事情只得到值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @rgb-values = $color-name-to-rgb.values;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.kv</code> method returns a key and its value at the same time. This saves you some complexity inside the [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>):</p>
</div>
<div class="paragraph">
<p><code>.kv</code> 方法同时返回键及其值。这可以节省[<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)内部的一些复杂性：" class="bare">https://docs.raku.org/type/Block.html)内部的一些复杂性：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $color-name-to-rgb.kv -&gt; $name, $rgb {
    put &#34;$name =&gt; $rgb&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Placeholder values inside the [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) (but not a pointy [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)" class="bare">https://docs.raku.org/type/Block.html)</a>) can do most of the work for you:</p>
</div>
<div class="paragraph">
<p>[<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) 中的占位符值（但不是尖头[<code>块</code>](<a href="https://docs.raku.org/type/Block.html)）可以为你完成大部分工作：" class="bare">https://docs.raku.org/type/Block.html)）可以为你完成大部分工作：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $color-name-to-rgb.kv {
    put &#34;$^k =&gt; $^v&#34;;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_creating_from_a_positional">4.15.2. Creating from a Positional</h4>
<div class="paragraph">
<p>You can create a [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) from a [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) using <code>.map</code>. That returns a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) that you can use as arguments to <code>.new</code>. These create new values based on the original ones:</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>.map</code> 从 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) 创建 [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html)。返回一个可以用作" class="bare">https://docs.raku.org/type/Map.html)。返回一个可以用作</a> <code>.new</code> 参数的 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html)。这些基于原始值创建新值：" class="bare">https://docs.raku.org/type/Seq.html)。这些基于原始值创建新值：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $plus-one-seq =  (1..3).map: * + 1;
my $double       = (^3).map: { $^a + $^a }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although the [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) type and the <code>.map</code> method have the same name and do a similar job, one is an immutable object that provides the translation whereas the other is a method that transforms a [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) into a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>).
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>虽然 [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) 类型和 <code>.map</code> 方法具有相同的名称并执行类似的工作，但是一个是提供转换的不可变对象，而另一个是将 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) 转换为 [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>) 的方法。</p>
</div>
<div class="paragraph">
<p>Your [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) or thunk can take more than one parameter. Use two parameters to construct [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)s" class="bare">https://docs.raku.org/type/Pair.html)s</a>:</p>
</div>
<div class="paragraph">
<p>你的[<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)或实形转换程序可以接受多个参数。使用两个参数构建"><code>Pair</code></a>(<a href="https://docs.raku.org/type/Pair.html)：" class="bare">https://docs.raku.org/type/Pair.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pairs = (^3).map: { $^a =&gt; 1 }; # (0 =&gt; 1 1 =&gt; 1 2 =&gt; 1)
my $pairs = (^3).map: * =&gt; 1;       # same thing</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s also a routine form of <code>map</code> where the code comes first and the values come after it. There’s a required comma between them in either form:</p>
</div>
<div class="paragraph">
<p>还有一种例程形式的 <code>map</code>，其中代码先出现，值出现在代码之后。两种形式之间都有一个必需的逗号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pairs = map { $^a =&gt; 1 }, ^3;
my $pairs = map * =&gt; 1, ^3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result of the <code>.map</code> can go right into the arguments for <code>.new</code>:</p>
</div>
<div class="paragraph">
<p><code>.map</code> 的结果可以直接进入 <code>.new</code> 的参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $map-thingy = Map.new: (^3).map: { $^a =&gt; 1 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>These examples work because you want to produce [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)s" class="bare">https://docs.raku.org/type/Pair.html)s</a>. If you want to simply create multiple items for a larger list you need to create a [<code>Slip</code>](<a href="https://docs.raku.org/type/Slip.html" class="bare">https://docs.raku.org/type/Slip.html</a>) so you don’t end up with a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) of [<code>List</code>](<a href="https://docs.raku.org/type/List.html)s" class="bare">https://docs.raku.org/type/List.html)s</a>:</p>
</div>
<div class="paragraph">
<p>这些示例有效，因为你想要生成 [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)。如果你只想为更大的列表创建多个项目，则需要创建一个" class="bare">https://docs.raku.org/type/Pair.html)。如果你只想为更大的列表创建多个项目，则需要创建一个</a> [<code>Slip</code>](<a href="https://docs.raku.org/type/Slip.html)，这样你就不会得到"><code>列表</code></a>(<a href="https://docs.raku.org/type/List.html)的"><code>列表</code></a>(<a href="https://docs.raku.org/type/List.html)：" class="bare">https://docs.raku.org/type/List.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list = map { $^a, $^a * 2 }, 1..3; # ((1 2) (2 4) (3 6))
put $list.elems;  # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can fix that with <code>slip</code>. This creates a [<code>Slip</code>](<a href="https://docs.raku.org/type/Slip.html" class="bare">https://docs.raku.org/type/Slip.html</a>) object that automatically flattens into the structure that contains it:</p>
</div>
<div class="paragraph">
<p>你可以用 <code>slip</code> 修复它。这将创建一个[<code>Slip</code>](<a href="https://docs.raku.org/type/Slip.html)对象，该对象会自动展平到包含它的结构中：" class="bare">https://docs.raku.org/type/Slip.html)对象，该对象会自动展平到包含它的结构中：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list = map { slip $^a, $^a * 2 }, 1..3; # (1 2 2 4 3 6)
put $list.elems;  # 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 9.2Rewrite the subroutine from the previous section using a [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) to decide which [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) you should return. If a number is not in the [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>), use <code>th</code>. Add a new rule that numbers ending in <code>5</code> (but not <code>15</code>) should get the suffix <code>ty</code> (like, <code>5ty</code>).</p>
</div>
<div class="paragraph">
<p>练习9.2使用 [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) 重写上一节中的子程序，以决定应该返回哪一个 [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)。如果数字不在" class="bare">https://docs.raku.org/type/Pair.html)。如果数字不在</a> [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) 中，请使用 <code>th</code>。添加一个新规则，以 <code>5</code> （但不是 <code>15</code>）结尾的数字应该得到后缀 <code>ty</code>（如，<code>5ty</code>）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_检查允许的值">4.15.3. 检查允许的值</h4>
<div class="paragraph">
<p>A common use for a [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) is to look up permissible values. Perhaps you only allow certain inputs in your subroutines. You can make those the keys of a [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>). If they are in the [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) they are valid. If they aren’t, well, they aren’t.</p>
</div>
<div class="paragraph">
<p>[<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) 的常见用途是查找允许的值。也许你只允许子程序中的某些输入。你可以把它们作为[<code>Map</code>](<a href="https://docs.raku.org/type/Map.html)的键。如果他们在"><code>Map</code></a>(<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) 中他们是有效的。如果他们不是，那么，他们不是。</p>
</div>
<div class="paragraph">
<p>Go through the list of colors and return the color names, which you’ll use as the keys, and some value (<code>1</code> is serviceable). You really want just the keys, so you can look them up later:</p>
</div>
<div class="paragraph">
<p>浏览颜色列表并返回颜色名称（你将用作键）和一些值（1可用）。你真的只想要键，所以你可以稍后查看它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @permissable_colors = &lt;red green blue&gt;;
my $permissable_colors =
    Map.new: @permissable_colors.map: * =&gt; 1;

loop {
    my $color = prompt &#39;Enter a color: &#39;;
    last unless $color;

    if $permissable_colors{$color}:exists {
        put &#34;$color is a valid color&#34;;
        }
    else {
        put &#34;$color is an invalid color&#34;;
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This sort of data structure makes the lookup time the same no matter how many keys you have. Consider what you’d have to do with just the [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>). This <code>scan-array</code> subroutine checks each element of the array until it finds a match:</p>
</div>
<div class="paragraph">
<p>无论你拥有多少个键，这种数据结构都会使查找时间保持不变。考虑一下你只需要列表。此扫描数组子例程检查数组的每个元素，直到找到匹配项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub scan-array ( $list, $item ) {
    for @$list {
        return True if $^element eq $item;
        }
    return False;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You might shorten your search by using <code>.first</code> to stop when it finds an appropriate element. At worst this checks every element every time:</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>.first</code> 缩短搜索范围，以便在找到合适的元素时停止搜索。在最坏的情况下，每次检查每个元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub first-array ( Array $array, $item ) {
    $array.first( * eq $item ).Bool;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 9.3Use the <code>.map</code> technique to construct a [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) from numbers between 1 and 10 (inclusively) to their squares. Create a loop to prompt for a number. If the number is in the [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>), print its square.</p>
</div>
<div class="paragraph">
<p>练习9.3使用 <code>.map</code> 技术从1到10之间的数字（包括）构造一个[<code>Map</code>](<a href="https://docs.raku.org/type/Map.html)到它们的正方形。创建一个循环以提示输入数字。如果数字在"><code>Map</code></a>(<a href="https://docs.raku.org/type/Map.html)中，则打印其正方形。" class="bare">https://docs.raku.org/type/Map.html)中，则打印其正方形。</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hashes">4.16. Hashes</h3>
<div class="paragraph">
<p>The [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) is like a [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) but mutable. You can add or delete keys and update values. This is the [<code>Associative</code>](<a href="https://docs.raku.org/type/Associative.html)type" class="bare">https://docs.raku.org/type/Associative.html)type</a> you’ll probably use the most. Create a [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) through its object constructor:</p>
</div>
<div class="paragraph">
<p>[<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html)就像" class="bare">https://docs.raku.org/type/Hash.html)就像</a> [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html)，但却是可变的。你可以添加或删除键并更新值。这是你可能最常使用的关联类型。通过其对象构造函数创建一个"><code>Hash</code></a>(<a href="https://docs.raku.org/type/Hash.html)：" class="bare">https://docs.raku.org/type/Hash.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $color-name-to-rgb = Hash.new:
    &#39;red&#39;,    &#39;FF0000&#39;,
    &#39;green&#39;,  &#39;00FF00&#39;,
    &#39;blue&#39;,   &#39;0000FF&#39;,
    ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s a bit tedious. You can enclose the key-value list in <code>%()</code> instead:</p>
</div>
<div class="paragraph">
<p>这有点乏味。你可以将键值列表括在 <code>%()</code> 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $color-name-to-rgb = %(  # Still makes a Hash
    &#39;red&#39;,    &#39;FF0000&#39;,
    &#39;green&#39;,  &#39;00FF00&#39;,
    &#39;blue&#39;,   &#39;0000FF&#39;,
    );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Curly braces also work, but this is a discouraged form. With the fat arrow there are [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)s" class="bare">https://docs.raku.org/type/Pair.html)s</a> inside the braces so the parser thinks this is a [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>):</p>
</div>
<div class="paragraph">
<p>花括号也有效，但这是一种沮丧的形式。使用胖箭头，在大括号内有[<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)，所以解析器认为这是一个"><code>Hash</code></a>(<a href="https://docs.raku.org/type/Hash.html)：" class="bare">https://docs.raku.org/type/Hash.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $color-name-to-rgb = {  # Still makes a Hash
    &#39;red&#39;   =&gt; &#39;FF0000&#39;,
    &#39;green&#39; =&gt; &#39;00FF00&#39;,
    &#39;blue&#39;  =&gt; &#39;0000FF&#39;,
    };</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the parser doesn’t get enough hints about the contents of the braces, you might end up with a [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) instead of a [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>):</p>
</div>
<div class="paragraph">
<p>如果解析器没有获得关于花括号内容的足够提示，那么最终可能会使用[<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)而不是"><code>Hash</code></a>(<a href="https://docs.raku.org/type/Hash.html)：" class="bare">https://docs.raku.org/type/Hash.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $color-name-to-rgb = {  # This is a Block!
    &#39;red&#39;,   &#39;FF0000&#39;,
    &#39;green&#39;, &#39;00FF00&#39;,
    &#39;blue&#39;,  &#39;0000FF&#39;,
    };</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s a special sigil for [<code>Associative</code>](<a href="https://docs.raku.org/type/Associative.html" class="bare">https://docs.raku.org/type/Associative.html</a>). If you use the <code>%</code> sigil you can assign a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) to create your [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>):</p>
</div>
<div class="paragraph">
<p>[<code>Associative</code>](<a href="https://docs.raku.org/type/Associative.html" class="bare">https://docs.raku.org/type/Associative.html</a>) 有一个特殊的印记。如果你使用 <code>%</code> sigil，你可以指定一个[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)来创建你的"><code>哈希</code></a>(<a href="https://docs.raku.org/type/Hash.html)：" class="bare">https://docs.raku.org/type/Hash.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %color-name-to-rgb =
    &#39;red&#39;,    &#39;FF0000&#39;,
    &#39;green&#39;,  &#39;00FF00&#39;,
    &#39;blue&#39;,   &#39;0000FF&#39;
    ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Perhaps you don’t like your definition of blue. You can assign a new value to it. Notice that the sigil does not change for the single-element access:</p>
</div>
<div class="paragraph">
<p>也许你不喜欢你对蓝色的定义。你可以为其重新赋值。请注意，单元素访问的sigil不会更改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">%color&lt;blue&gt; = &#39;0000AA&#39;;  # a bit darker</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can remove a key with the <code>:delete</code> adverb. It returns the value of the just-deleted key:</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>:delete</code> 副词删除键。它返回刚刚删除的键的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $rgb = %color&lt;blue&gt;:delete</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can add new colors by assigning to the key that you want:</p>
</div>
<div class="paragraph">
<p>你可以通过分配所需的键来添加新颜色：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">%color&lt;mauve&gt; = &#39;E0B0FF&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 9.4Update your ordinal suffix program to use a [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>). That’s the easy part. Once you’ve got that working, use your [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) to cache values so you don’t have to compute their result again.</p>
</div>
<div class="paragraph">
<p>练习9.4 更新你的序数后缀程序以使用[<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html)。这很容易。一旦起效了，使用你的"><code>Hash</code></a>(<a href="https://docs.raku.org/type/Hash.html)缓存值，这样你就不必再次计算他们的结果。" class="bare">https://docs.raku.org/type/Hash.html)缓存值，这样你就不必再次计算他们的结果。</a></p>
</div>
<div class="sect3">
<h4 id="_accumulating_with_a_hash">4.16.1. Accumulating with a Hash</h4>
<div class="paragraph">
<p>Counting is another common use for a [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>). The key is the thing you want to count and its value is the number of times you’ve encountered it. First, you need something to count. Here’s a program that simulates rolling some dice:</p>
</div>
<div class="paragraph">
<p>计数是[<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html)的另一种常见用法。键是你想要计算的东西，它的值是你遇到它的次数。首先，你需要一些东西来计算。这是一个模拟滚动骰子的程序：" class="bare">https://docs.raku.org/type/Hash.html)的另一种常见用法。键是你想要计算的东西，它的值是你遇到它的次数。首先，你需要一些东西来计算。这是一个模拟滚动骰子的程序：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ( $die-count = 2, $sides = 6, $rolls = 137 ) {
    my $die_sides = 6;

    for ^$rolls {
        my $roll = (1..$sides).roll($die-count).List;
        my $sum = [+] $roll;
        put &#34;($roll) is $sum&#34;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.roll</code> method picks an element from your [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) the number of times you specify. Each time it picks an element is independent of other times, so it might repeat some values. This produces output that shows the individual die values and the sum of the values:</p>
</div>
<div class="paragraph">
<p><code>.roll</code> 方法从[<code>List</code>](<a href="https://docs.raku.org/type/List.html)中选择一个元素指定的次数。每次拾取元素都与其他时间无关，因此它可能会重复某些值。这会生成输出，显示各个芯片值和值的总和：" class="bare">https://docs.raku.org/type/List.html)中选择一个元素指定的次数。每次拾取元素都与其他时间无关，因此它可能会重复某些值。这会生成输出，显示各个芯片值和值的总和：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(3 4) is 7
(4 1) is 5
(6 4) is 10
(2 6) is 8
(6 6) is 12
(1 4) is 5
(5 6) is 11</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you have several things to count. Start by counting the sums. Inside that <code>for</code>, use the sum as the [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) key and the number of times you encounter it as the value:</p>
</div>
<div class="paragraph">
<p>现在你需要考虑几件事。首先计算总和。在 <code>for</code> 里面，使用 sum 作为 [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) 键以及你遇到它的次数作为值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ( $die-count = 2, $sides = 6, $rolls = 137 ) {
    my $die_sides = 6;

    my %sums;
    for ^$rolls {
        my $roll = (1..$sides).roll($die-count).List;
        my $sum = [+] $roll;
        %sums{$sum}++;
        }

    # sort the hash by its value
    my $seq = %sums.keys.sort( { %sums{$^a} } ).reverse;

    for @$seq {
        put &#34;$^a: %sums{$^a}&#34;
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you get a dice sum frequency report:</p>
</div>
<div class="paragraph">
<p>现在你得到一个骰子和的频率报告：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">7: 27
8: 25
5: 19
4: 13
9: 12
6: 11
11: 9
10: 8
3: 7
2: 3
12: 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are motivated enough, you can compare those values to the probabilities for perfect dice. But there’s another interesting thing you can count—the rolls themselves. If you use <code>$roll</code> as the key it stringifies it. You can then count the unique stringifications. Sort the results so equivalent rolls such as <code>(1 6)</code> and <code>(6 1)</code> become the same key:</p>
</div>
<div class="paragraph">
<p>如果你有足够的动力，你可以将这些值与完美骰子的概率进行比较。但是你可以计算另一个有趣的事情 - rolls 本身。如果你使用 <code>$roll</code> 作为键，则将其字符串化。然后，你可以计算唯一的字符串。对结果进行排序，使等效的卷（如`(1 6)` 和 <code>(6 1)</code>）成为相同的键：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ( $die-count = 2, $sides = 6, $rolls = 137 ) {
    my $die_sides = 6;

    my %sums;
    for ^$rolls {
        my $roll = (1..$sides).roll($die-count).sort.List;
        %sums{$roll}++;
        }


    my $seq = %sums.keys.sort( { %sums{$^a} } ).reverse;

    for @$seq {
        put &#34;$^a: %sums{$^a}&#34;
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you get a sorted list of your dice rolls:</p>
</div>
<div class="paragraph">
<p>现在你得到一个你的骰子卷的排序列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">3 4: 15
1 4: 11
1 2: 10
2 5: 9
3 5: 9
3 6: 9
2 3: 8</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 9.5Create a program to count the occurrences of words in a file and output the words sorted by their count. Store each lowercased word as the key in a hash and increment its value every time you see it. Don’t worry about punctuation or other characters; you’ll learn how to deal with those later. What happens if two words have the same count?</p>
</div>
<div class="paragraph">
<p>练习9.5 创建一个程序来计算文件中单词的出现次数，并输出按其计数排序的单词。将每个小写单词作为键存储在哈希中，并在每次看到它时增加其值。不要担心标点符号或其他字符;你将学习如何在以后处理这些问题。如果两个单词的计数相同，会发生什么？</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multilevel_hashes">4.17. Multilevel Hashes</h3>
<div class="paragraph">
<p>Hash values can be almost anything, including another [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) or [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>). Here’s an example with a couple of [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html)es" class="bare">https://docs.raku.org/type/Hash.html)es</a> that count the number of butterflies in the <strong>Hamadryas</strong> and <strong>Danaus</strong> genera:</p>
</div>
<div class="paragraph">
<p>散列值几乎可以是任何值，包括另一个散列或数组。这是一个有几个哈希数的例子，它们计算了哈马德里亚斯和丹那属的蝴蝶数量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %Hamadryas = map { slip $_, 0 }, &lt;
    februa
    honorina
    velutina
    &gt;;

my %Danaus = map { slip $_, 0 }, &lt;
    gilippus
    melanippus
    &gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>But you want to contain all of that in one big [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>), so you construct that. The [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) value is another [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>):</p>
</div>
<div class="paragraph">
<p>但是你想在一个大[<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html)中包含所有这些，所以你构建它。哈希值是另一个哈希：" class="bare">https://docs.raku.org/type/Hash.html)中包含所有这些，所以你构建它。哈希值是另一个哈希：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %butterflies = (
    &#39;Hamadryas&#39; =&gt; %Hamadryas,
    &#39;Danaus&#39;    =&gt; %Danaus,
    );

say %butterflies;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>%butterflies</code> data structure looks like this (using the discouraged braces form):</p>
</div>
<div class="paragraph">
<p><code>%butterflies</code> 数据结构看起来像这样（使用不鼓励的花括号形式）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{Danaus =&gt; {gilippus =&gt; 0, melanippus =&gt; 0},
Hamadryas =&gt; {februa =&gt; 0, honorina =&gt; 0, velutina =&gt; 0}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Suppose you want to see the count for <strong>Danaus melanippus</strong>. You have to look in the top-level [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) to get the value for <code>Danaus</code>, then take that value and look at its <code>melanippus</code> keys:</p>
</div>
<div class="paragraph">
<p>假设你想看看Danaus melanippus的数量。你必须查看顶级Hash以获取Danaus的值，然后获取该值并查看其melanippus键：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $genus = %butterflies&lt;Danaus&gt;;
my $count = $genus&lt;melanippus&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s too much work. Line up the subscripts in one expression:</p>
</div>
<div class="paragraph">
<p>那工作太多了。在一个表达式中排列下标：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;Count is  %butterflies&lt;Danaus&gt;&lt;melanippus&gt;&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you want to count a particular butterfly, you can do that:</p>
</div>
<div class="paragraph">
<p>当你想要计算一只特定的蝴蝶时，你可以这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">%butterflies&lt;Danaus&gt;&lt;melanippus&gt;++;</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 9.6Read the lines from the butterfly census file (from [<strong><a href="https://www.learningraku.com/downloads/" class="bare">https://www.learningraku.com/downloads/</a></strong>](<a href="https://www.learningraku.com/downloads/)" class="bare">https://www.learningraku.com/downloads/)</a>) and break each line into a genus and species. Count each combination of genus and species. Report your results.</p>
</div>
<div class="paragraph">
<p>练习9.6 读取蝴蝶人口普查文件中的行（来自https://www.learningraku.com/downloads/），并将每行划分为属和种。计算属和物种的每个组合。报告你的结果。</p>
</div>
<div class="paragraph">
<p>EXERCISE 9.7Modify the previous exercise to write the genus and species counts to a file. Each line of the file should have the genus, species, and count separated by a tab. You’ll need this file for an exercise in [Chapter 15](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1</a>).</p>
</div>
<div class="paragraph">
<p>练习9.7 修改上一个练习，将属和种类计数写入文件。文件的每一行都应具有由制表符分隔的属，种和计数。你将需要此文件进行第15章的练习。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_5">4.18. 总结</h3>
<div class="paragraph">
<p>[<code>Associative</code>](<a href="https://docs.raku.org/type/Associative.html)s" class="bare">https://docs.raku.org/type/Associative.html)s</a> let you quickly get from a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) to another value. There are several types that facilitate this. At the lowest level is the [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) of one key and one value. A [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) fixes those once created (much like a [<code>List</code>](<a href="https://docs.raku.org/type/List.html)" class="bare">https://docs.raku.org/type/List.html)</a>), while a [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) is more flexible (much like an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html)" class="bare">https://docs.raku.org/type/Array.html)</a>). These will probably be some of the most useful and hard-working data structures that you’ll encounter.</p>
</div>
<div class="paragraph">
<p>[<code>Associative</code>](<a href="https://docs.raku.org/type/Associative.html)让你快速从"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)到另一个值。有几种类型可以促进这一点。最低级别是一对一键和一个值。" class="bare">https://docs.raku.org/type/Str.html)到另一个值。有几种类型可以促进这一点。最低级别是一对一键和一个值。</a> [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) 修复了曾经创建的（很像[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)），而"><code>Hash</code></a>(<a href="https://docs.raku.org/type/Hash.html)更灵活（很像数组）。这些可能是你将遇到的一些最有用和最勤奋的数据结构。" class="bare">https://docs.raku.org/type/Hash.html)更灵活（很像数组）。这些可能是你将遇到的一些最有用和最勤奋的数据结构。</a>
== 使用模块</p>
</div>
<div class="paragraph">
<p>Modules allow you to compartmentalize, distribute, and reuse code. Someone creates a general solution to something, then packages it so you can reuse it in your programs. Sometimes people make these modules available to everyone. You can find some Raku modules at <strong><a href="https://modules.raku.org" class="bare">https://modules.raku.org</a></strong></p>
</div>
<div class="paragraph">
<p>You don’t have to understand the code inside a module to benefit from its features. You can usually follow the examples in its documentation even if it uses syntax that you haven’t already seen.</p>
</div>
<div class="paragraph">
<p>模块允许你划分，分发和重用代码。有人创建了一个通用的解决方案，然后将其打包，以便你可以在程序中重用它。有时人们会向所有人提供这些模块。你可以在 <strong><a href="https://modules.raku.org" class="bare">https://modules.raku.org</a></strong> 找到一些 Raku 模块。</p>
</div>
<div class="paragraph">
<p>你无需了解模块内部的代码即可从其功能中受益。你通常可以按照其文档中的示例进行操作，即使它使用你尚未看到的语法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_installing_modules">4.19. Installing Modules</h3>
<div class="paragraph">
<p><strong>zef</strong> is one of the Raku module managers. It can install, update, and uninstall modules. It comes with Rakudo Star but you can install it yourself:</p>
</div>
<div class="paragraph">
<p><strong>zef</strong> 是 Raku 的模块管理器之一。它可以安装，更新和卸载模块。它附带在 Rakudo Star 中，但你可以自行安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% git clone https://github.com/ugexe/zef.git
% cd zef
% raku -Ilib bin/zef install .</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you have <strong>zef</strong> you can install modules. The <code>Task::Popular</code> module installs those most used by other modules:</p>
</div>
<div class="paragraph">
<p>一旦你有了 <strong>zef</strong>，你就可以安装模块了。 <code>Task::Popular</code> 模块安装其他模块最常用的模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% zef install Task::Popular</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can install a module by name if the author has registered it in the module ecosystem:</p>
</div>
<div class="paragraph">
<p>如果作者已在模块生态系统中注册了模块，你可以按名称安装模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% zef install HTTP::Tiny</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also tell it to install the code directly from a Git repository:</p>
</div>
<div class="paragraph">
<p>你也可以告诉它直接从 Git 仓库安装代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% zef install https://github.com/sergot/http-useragent.git

% zef install git://github.com/sergot/http-useragent.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ensure that you are using the clone URL and not the project page URL.</p>
</div>
<div class="paragraph">
<p>You can install from a local directory if the module infrastructure is there and there’s a <strong>META6.json</strong> file. You have to make the argument to <strong>zef</strong> not look like a module name. This one looks for a module directory in the current directory:</p>
</div>
<div class="paragraph">
<p>确保你使用的是克隆 URL，而不是项目页面 URL。</p>
</div>
<div class="paragraph">
<p>如果存在模块基础结构且存在 <strong>META6.json</strong> 文件，则可以从本地目录进行安装。你必须使 <strong>zef</strong> 的参数看起来不像模块名。这个在当前目录中查找模块目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% zef install ./json-tiny</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can install the modules from the current directory by using the <code>.</code> as the current working directory:</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>.</code> 作为当前工作目录从当前目录安装模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% zef install .</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You may find references to <strong>panda</strong>, an early module installation tool. It’s the old, unsupported tool. *zef*is the new hotness. Double-check the [documentation](<a href="https://docs.raku.org/language/modules" class="bare">https://docs.raku.org/language/modules</a>), though, since the favored tool may change by the time you read this book.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>EXERCISE 10.1Install the <code>Inline::Perl5</code> module by its name. You’ll use that module later in this chapter. Install the <code>Grammar::Debugger</code> module by its repository URL. You’ll use that module in [Chapter 17](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch17.html#camelia-grammars" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch17.html#camelia-grammars</a>). Find and clone the <code>Grammar::Tracer</code> module repository, change into its local directory, and install it from that directory.</p>
</div>
<div class="paragraph">
<p>你可以找到对 <strong>panda</strong> 的参考，这是一个早期的模块安装工具。这是旧的，不受支持的工具。 <strong>zef</strong> 是新秀。但请仔细检查[文档](<a href="https://docs.raku.org/language/modules)，因为在你阅读本书时，受欢迎的工具可能会发生变化。" class="bare">https://docs.raku.org/language/modules)，因为在你阅读本书时，受欢迎的工具可能会发生变化。</a></p>
</div>
<div class="paragraph">
<p>练习10.1 按名称安装 <code>Inline::Perl5</code> 模块。你将在本章后面使用该模块。通过其仓库 URL 安装 <code>Grammar::Debugger</code> 模块。你将在第 17 章中使用该模块。查找并克隆 <code>Grammar::Tracer</code> 模块仓库，切换到其本地目录，然后从该目录安装它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_加载模块">4.20. 加载模块</h3>
<div class="paragraph">
<p>You load a module into your program with <code>need</code>. This searches through the module <strong>repository</strong> looking for a match. If you’ve installed modules with <strong>zef</strong> they should be in the repository (in the next section I show you how to tell your program to look in other places too):</p>
</div>
<div class="paragraph">
<p>你使用 <code>need</code> 将模块加载到程序中。这将搜索模块存储库以查找匹配项。如果你已经使用 <strong>zef</strong> 安装了模块，那么它们应该在存储库中（在下一节中，我将向你展示如何告诉你的程序在其他地方查找）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">need Number::Bytes::Human;
my $human = Number::Bytes::Human.new;

put $human.format(123435653); # &#39;118M&#39;
put $human.parse(&#39;3GB&#39;);      # 3221225472</code></pre>
</div>
</div>
<div class="paragraph">
<p>Loading a module with <code>use</code> does the same thing but also automatically <strong>imports</strong> anything the module has set to export. This allows modules to define thingys in your current scope as if you’d defined the code there yourself:</p>
</div>
<div class="paragraph">
<p>使用 <code>use</code> 加载模块会做同样的事情，但也会自动导入模块设置为导出的任何内容。这允许模块在当前作用域内定义东西，就像你自己定义了代码一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Number::Bytes::Human;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the same as doing a <code>need</code> and then an <code>import</code>:</p>
</div>
<div class="paragraph">
<p>这与执行 <code>need</code> 然后 <code>import</code> 相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">need Number::Bytes::Human;
import Number::Bytes::Human;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some modules import things automatically and others wait until you ask for them. You can specify a list after the module name that asks for specific imports. The <code>Number::Bytes::Human</code> module uses an adverb for that:</p>
</div>
<div class="paragraph">
<p>有些模块自动导入东西，有些模块会等到你要求它们。你可以在要求特定导入的模块名称后指定一个列表。 <code>Number::Bytes::Human</code> 模块为此使用一个副词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Number::Bytes::Human :functions;

put format-bytes(123435653); # &#39;118M&#39;
put parse-bytes(&#39;3GB&#39;);     # 3221225472</code></pre>
</div>
</div>
<div class="paragraph">
<p>No matter which way you load it, follow the examples in the documentation (or maybe look in the module tests).</p>
</div>
<div class="paragraph">
<p>无论你以哪种方式加载，请按照文档中的示例（或者查看模块测试）。</p>
</div>
<div class="sect3">
<h4 id="_查找模块">4.20.1. 查找模块</h4>
<div class="paragraph">
<p>When you install a module with <strong>zef</strong> the module’s filename becomes a digest of that file and is saved in one of the module repositories—this allows several versions and sources of the file to be simultaneously installed. You can see this path with the command <code>zef locate</code>:</p>
</div>
<div class="paragraph">
<p>当你使用 <strong>zef</strong> 安装模块时，模块的文件名将成为该文件的摘要并保存在其中一个模块存储库中 - 这允许同时安装该文件的多个版本和源。你可以使用命令 <code>zef locate</code> 查看此路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% zef locate Number::Bytes::Human
===&gt; From Distribution: Number::Bytes::Human:ver&lt;0.0.3&gt;:auth&lt;&gt;:api&lt;&gt;
Number::Bytes::Human =&gt; /opt/raku/site/sources/A5EA...</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the output, the module shows up in a cryptically named file. Raku uses several methods to store and retrieve compunits in repositories. This is very flexible but also much more than I have space to explain here. For the most part you don’t need to worry about that.</p>
</div>
<div class="paragraph">
<p>正如你在输出中看到的那样，该模块显示在一个文件名加密过的文件中。 Raku 使用几种方法来存储和检索存储库中的 compunits。这非常灵活，但也比我在这里解释的要多。在大多数情况下，你无需担心这一点。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The repository system is complicated because it can manage the same module name with different versions or authors. This means it’s possible to store or load old and new module versions simultaneously.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>存储库系统很复杂，因为它可以使用不同的版本或作者管理相同的模块名称。这意味着可以同时存储或加载新旧模块版本。</p>
</div>
<div class="sect4">
<h5 id="_lib_指令">LIB 指令</h5>
<div class="paragraph">
<p>No matter where the module is, you need to tell your program where to find it. <strong>zef</strong> uses the repositories that <strong>raku*has configured by default. The <code>lib</code> pragma can add a directory as a repository. You can store plain files in there (that is, unmanaged by Raku). The module name is translated to a path by replacing <code>::</code> with a <code>/</code> and adding a *.pm</strong> or <strong>.pm6</strong> extension:</p>
</div>
<div class="paragraph">
<p>无论模块在哪里，你都需要告诉你的程序在哪里找到它。 <strong>zef</strong> 使用 <strong>raku</strong> 默认配置的存储库。 <code>lib</code> 指令可以将目录添加为存储库。你可以在其中存储普通文件（即，不受 Raku 管理）。通过将 <code>::</code> 替换为 <code>/</code> 并添加 <code>.pm</code> 或 <code>.pm6</code> 扩展名将模块名称转换为路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use lib &lt;/path/to/module/directory&gt;;
use Number::Bytes::Human</code></pre>
</div>
</div>
<div class="paragraph">
<p>This looks for <strong>Number/Bytes/Human.pm</strong> or <strong>Number/Bytes/Human.pm6</strong> in <strong>/path/to/module/directory</strong>.</p>
</div>
<div class="paragraph">
<p>You can specify multiple directories:</p>
</div>
<div class="paragraph">
<p>这将在 <strong>/path/to/module/directory</strong> 中查找 <strong>Number/Bytes/Human.pm</strong> 或 <strong>Number/Bytes/Human.pm6</strong>。</p>
</div>
<div class="paragraph">
<p>你可以指定多个目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use lib &lt;/path/to/module/directory /other/path&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or specify <code>lib</code> multiple times:</p>
</div>
<div class="paragraph">
<p>或者多次指定 <code>lib</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use lib &#39;/path/to/module/directory&#39;;
use lib &#39;/other/path&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Relative paths resolve themselves according to the current working directory:</p>
</div>
<div class="paragraph">
<p>相对路径根据当前工作目录自行解析：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use lib &lt;module/directory&gt;;  # looks for module/ in current dir</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.</code> works as the current working directory. People tend to do this if the module file and the program are in the same directory:</p>
</div>
<div class="paragraph">
<p>这个 <code>.</code> 作为当前工作目录。如果模块文件和程序在同一目录中，人们倾向于这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use lib &lt;.&gt;:</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should carefully consider using the current working directory in your library search path. Since it’s a relative location you’re never quite sure where it’s looking. Running your program from a different directory (with a command like the following) means your program looks in a different directory and probably won’t find the module:</p>
</div>
<div class="paragraph">
<p>你应该仔细考虑在库搜索路径中使用当前工作目录。由于它是一个相对位置，你永远不能确定它在哪里。从不同的目录运行程序（使用如下命令）意味着你的程序在不同的目录中查找，可能找不到该模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku bin/my-program</code></pre>
</div>
</div>
<div class="paragraph">
<p>It takes a bit more work to figure out the relative directory. Your program’s path is in the special variable <code>$<strong>PROGRAM</strong></code><strong>. You can turn that into an [<code>IO::Path</code>](<a href="https://docs.raku.org/type/IO::Path.html" class="bare">https://docs.raku.org/type/IO::Path.html</a>) object with <code>.IO</code> and use <code>.parent</code> to get its directory. You can use that to add a *lib</strong> directory at the same level as your program:</p>
</div>
<div class="paragraph">
<p>找出相对目录需要更多的工作。你的程序路径位于特殊变量 <code>$<strong>PROGRAM</strong></code><strong> 中。你可以使用 <code>.IO</code> 将其转换为 [<code>IO::Path</code>](<a href="https://docs.raku.org/type/IO::Path.html" class="bare">https://docs.raku.org/type/IO::Path.html</a>) 对象，并使用 <code>.parent</code> 来获取其目录。你可以使用它来添加与程序相同级别的 *lib</strong> 目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># random-between.p6
use lib $*PROGRAM.IO.parent;
use lib $*PROGRAM.IO.parent.add: &#39;lib&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s also the <code>$?FILE</code> <strong>compile-time variable</strong>:</p>
</div>
<div class="paragraph">
<p>还有 <code>$?FILE</code> 编译时变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use lib $?FILE.IO.parent;
use lib $?FILE.IO.parent.add: &#39;lib&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For this to work you must add the paths to search before you try to load the library. It does no good to tell it where to look after it has already looked!</p>
</div>
<div class="paragraph">
<p>为此，你必须在尝试加载库之前添加要搜索的路径。告诉它已经看过它在哪里照顾它没有用！</p>
</div>
</div>
<div class="sect4">
<h5 id="_环境">环境</h5>
<div class="paragraph">
<p>The <code>PERL6LIB</code> environment variable applies to every program you run in the current session. Separate the directories with commas (no matter which system you are using). Here it is in <strong>bash</strong> syntax:</p>
</div>
<div class="paragraph">
<p><code>PERL6LIB</code> 环境变量适用于你在当前会话中运行的每个程序。用逗号分隔目录（无论你使用哪个系统）。这是 <strong>bash</strong> 语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% export PERL6LIB=/path/to/module/directory,/other/path</code></pre>
</div>
</div>
<div class="paragraph">
<p>And in Windows syntax:</p>
</div>
<div class="paragraph">
<p>在 Windows 语法中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> C:\ set PERL6LIB=C:/module/directory,C:/other/path</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_i_开关">-I 开关</h5>
<div class="paragraph">
<p>The <code>-I</code> switch to <strong>raku</strong> works for a single run of a program. This is handy inside a project repository (a different sort of repository!) that you haven’t installed. You can use the development version of the module from the project repository instead of a previous one you might have installed:</p>
</div>
<div class="paragraph">
<p><code>-I</code> 切换到 <strong>raku</strong> 适用于单个程序运行。这在你尚未安装的项目存储库（不同类型的存储库！）中很方便。你可以使用项目存储库中的模块开发版本，而不是之前安装的模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku -Ilib bin/my_program.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specify more than one extra directory with multiple <code>-I</code> switches or by separating them with commas:</p>
</div>
<div class="paragraph">
<p>使用多个 <code>-I</code> 开关指定多个额外目录，或者用逗号分隔它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku -Ilib -I../lib bin/my_program.p6
% raku -Ilib,../lib bin/my_program.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see the <code>-I</code> at work if you want to use <strong>prove</strong> to run Raku module tests. The argument to <code>-e</code> is the interpreter to use (with Perl 5 being the default). You want a <strong>raku</strong> that looks for the development modules in the current repository:</p>
</div>
<div class="paragraph">
<p>如果要使用 <strong>prove</strong> 来运行 Raku 模块测试，可以看到 <code>-I</code> 在工作。 <code>-e</code> 参数是要使用的解释器（Perl 5 是默认值）。你需要一个在当前存储库中查找开发模块的 <strong>raku</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% prove -e &#34;raku -Ilib&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>$*REPO</code> variable can tell you where Raku will look for modules. These aren’t just directories. The repositories could be almost anything—including other code:</p>
</div>
<div class="paragraph">
<p><code>$*REPO</code> 变量可以告诉你 Raku 在哪里寻找模块。这些不仅仅是目录。存储库几乎可以是任何东西 - 包括其他代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $*REPO.repo-chain -&gt; $item {
    say $item;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 10.2Create a program to show the repository chain. Run it in several situations using <code>PERL6LIB</code>, <code>-I</code>, and <code>use lib</code>.</p>
</div>
<div class="paragraph">
<p>EXERCISE 10.2 创建一个程序来显示存储库链。使用 <code>PERL6LIB</code>，<code>-I</code> 和 <code>use lib</code> 在几种情况下运行它。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_lexical_effect">4.20.2. Lexical Effect</h4>
<div class="paragraph">
<p>Loading a module only affects the current scope. If you load a module in a [<code>Block</code>](<a href="https://docs.raku.org/type/Block" class="bare">https://docs.raku.org/type/Block</a>) it’s only available in that[<code>Block</code>](<a href="https://docs.raku.org/type/Block" class="bare">https://docs.raku.org/type/Block</a>), and anything it imports is only available in that [<code>Block</code>](<a href="https://docs.raku.org/type/Block" class="bare">https://docs.raku.org/type/Block</a>). Outside of the [<code>Block</code>](<a href="https://docs.raku.org/type/Block" class="bare">https://docs.raku.org/type/Block</a>) the program doesn’t know about the module:</p>
</div>
<div class="paragraph">
<p>加载模块仅影响当前作用域。如果在[<code>块</code>](<a href="https://docs.raku.org/type/Block" class="bare">https://docs.raku.org/type/Block</a>) 中加载模块，它只在该[<code>块</code>](<a href="https://docs.raku.org/type/Block)中可用，并且它导入的任何内容仅在该"><code>块</code></a>(<a href="https://docs.raku.org/type/Block)中可用。在" class="bare">https://docs.raku.org/type/Block)中可用。在</a> [<code>块</code>](<a href="https://docs.raku.org/type/Block" class="bare">https://docs.raku.org/type/Block</a>) 之外，程序不知道该模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
use Number::Bytes::Human;

my $human = Number::Bytes::Human.new; # works in here

put $human.format(123435653); # &#39;118M&#39;
}

my $human = Number::Bytes::Human.new; # ERROR: not defined here</code></pre>
</div>
</div>
<div class="paragraph">
<p>You’ll get an odd error where your program is looking for a subroutine that has a name that’s the same as the last part of the module name:</p>
</div>
<div class="paragraph">
<p>你的程序正在寻找一个名称与模块名称的最后部分相同的子程序，你会得到一个奇怪的错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Could not find symbol &#39;&amp;Human&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can limit module imports to just where you need them. If you only need it in a subroutine you can load it there:</p>
</div>
<div class="paragraph">
<p>你可以将模块导入限制在你需要的位置。如果你只需要在子程序中，你可以在那里加载它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub translate-it ( Int $bytes ) {
    use Number::Bytes::Human;
    state $human = Number::Bytes::Human.new;
    $human.format( $bytes );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This means that you could load different versions of the same module for different parts of your program. The <code>lib</code> declaration is lexically scoped as well:</p>
</div>
<div class="paragraph">
<p>这意味着你可以为程序的不同部分加载同一模块的不同版本。 <code>lib</code> 声明也是词法作用域的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub stable-version {
    use Number::Bytes::Human;
    ...
}

sub experimental-version {
    use lib &lt;/home/hamadryas/dev-module/lib&gt;;
    use Number::Bytes::Human;
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This sort of thing is often handy to convert data formats when they change between module versions:</p>
</div>
<div class="paragraph">
<p>当模块版本之间的数据格式发生变化时，转换数据格式通常很方便：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub translate-to-new-format ( Str $file ) {
    my $data = do {
        use lib &lt;/path/to/legacy/lib&gt;;
        use Module::Format;
        Module::Format.new.load: $file;
    };

    use Module::Format; # new version
    Module::Format.new.save: $data, $file;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_在运行时加载模块">4.20.3. 在运行时加载模块</h4>
<div class="paragraph">
<p><code>need</code> and <code>use</code> load a module as the program compiles. Sometimes you don’t know which module you want until you want to use it, or you know that you might use one of several modules but only want to load the one you’ll actually use. You can wait until runtime to load it with <code>require</code>. If the module isn’t there the `require`throws an exception:</p>
</div>
<div class="paragraph">
<p><code>need</code> 和 <code>use</code> 在程序编译时加载模块。有时你不知道你想要使用哪个模块直到你要使用它，或者你知道你可能使用几个模块中的一个但只想加载你实际使用的模块。你可以等到运行时使用 <code>require</code> 加载它。如果模块不在那里，则 <code>require</code> 抛出异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">try require Data::Dump::Tree;
if $! { die &#34;Could not load module!&#34; }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Even if the module fails to load, the <code>require</code> still creates the type. You can’t rely on the type being defined as a signal of successful loading.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Perhaps you want to check that a module is installed before you try to load it. The <code>$*REPO</code> object has a`.resolve` method that can find a module from its dependency specification:</p>
</div>
<div class="paragraph">
<p>即使模块无法加载，<code>require</code> 仍会创建类型。你不能依赖被定义的类型作为成功加载的信号。</p>
</div>
<div class="paragraph">
<p>也许你想在尝试加载模块之前检查模块是否已安装。 <code>$*REPO</code> 对象有一个 <code>.resolve</code> 方法，可以从其依赖项规范中找到一个模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $dependency-spec =
    CompUnit::DependencySpecification.new: :short-name($module);

if $*REPO.resolve: $dependency-spec {
    put &#34;Found $module&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 10.3Write a program that reports whether a module is installed. Try this with <code>Number::Bytes::Human</code> (assuming you installed it so it is present) and <code>Does::Not::Exist</code> (or any other name that isn’t a module).</p>
</div>
<div class="paragraph">
<p>练习10.3 编写一个报告模块是否已安装的程序。尝试使用 <code>Number::Bytes::Human</code>（假设你安装它以便它存在）和 <code>Does::Not::Exist</code>（或任何其他不是模块的名称）。</p>
</div>
<div class="sect4">
<h5 id="_插值模块名">插值模块名</h5>
<div class="paragraph">
<p>You can interpolate a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) where you’d normally have a literal class name by putting the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) inside <code>::()</code>:</p>
</div>
<div class="paragraph">
<p>你可以通过将[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)放入" class="bare">https://docs.raku.org/type/Str.html)放入</a> <code>::()</code> 来插入一个通常具有字面类名称的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)：" class="bare">https://docs.raku.org/type/Str.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">require ::($module);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Anywhere you’d use the literal class name you can use that <code>::($module)</code>. When you want to create an object but you don’t know the literal module name, you interpolate it just as you did in the <code>require</code>:</p>
</div>
<div class="paragraph">
<p>在你使用字面类名称的任何地方，你都可以使用 <code>::($module)</code>。如果要创建对象但不知道字面模块名称，则可以像在 <code>require</code> 中一样进行插值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $new-object = ::($module).new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Not only that, but you can use a method name from a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) by putting it in double quotes. You must use the parentheses for the argument list when you do this:</p>
</div>
<div class="paragraph">
<p>不仅如此，你还可以通过将其放在双引号中来使用[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)中的方法名称。执行此操作时，必须使用圆括号作为参数列表：" class="bare">https://docs.raku.org/type/Str.html)中的方法名称。执行此操作时，必须使用圆括号作为参数列表：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$new-object.&#34;$method-name&#34;( @args );</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use the return value of <code>require</code>. If it was able to load the module that value is the type:</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>require</code> 的返回值。如果它能够加载模块的值是类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $class-i-loaded = (require ::($module));
my $object = $class-i-loaded.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This might work better with a literal name that you don’t want to repeatedly type:</p>
</div>
<div class="paragraph">
<p>对于你不想重复输入的字面名称，这可能会更好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $class-i-loaded = (require Digest::MD5);
my $object = $class-i-loaded.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Checking this is a bit tricky. You can’t simply check for the type because that will be defined no matter which way it goes. Check that it’s not a [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>):</p>
</div>
<div class="paragraph">
<p>检查这个有点棘手。你无法简单地检查类型，因为无论它采用何种方式，都将对其进行定义。检查它不是 [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html)：" class="bare">https://docs.raku.org/type/Failure.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $module = &#39;Hamadryas&#39;;

try require ::($module);
put ::($module).^name; # Failure
say ::($module).^mro;  # ((Failure) Nil (Cool) (Any) (Mu))
if ::($module) ~~ Failure {
    put &#34;Couldn&#39;t load $module!&#34;; # Couldn&#39;t load Hamadryas!
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>These aren’t tricks to use frequently, but they are there as a last resort should you need them. Here’s a program that lets you choose which dumper class to use. It uses a [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) to translate the class name to the method name it uses. At the end it merely dumps the only [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) defined in the program:</p>
</div>
<div class="paragraph">
<p>这些不是经常使用的技巧，但如果你需要它们，它们是最后的手段。这是一个程序，可以让你选择要使用的转储程序类。它使用 [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) 将类名转换为它使用的方法名。最后它只转储程序中定义的唯一 [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ( Str $class = &#39;PrettyDump&#39; ) {
    my %dumper-adapters = %(
        &#39;Data::Dump::Tree&#39; =&gt; &#39;ddt&#39;,
        &#39;PrettyDump&#39;       =&gt; &#39;dump&#39;,
        &#39;Pretty::Printer&#39;  =&gt; &#39;pp&#39;,
        );

    CATCH {
        when X::CompUnit::UnsatisfiedDependency {
            note &#34;Could not find $class&#34;;
            exit 1;
        }
        default {
            note &#34;Some other problem with $class: {.message}&#34;;
            exit 2;
        }
    }
    require ::($class);

    my $method = %dumper-adapters{$class};
    unless $method {
        note &#34;Do not know how to dump with $class&#34;;
        exit 2;
    }

    put ::($class).new.&#34;$method&#34;( %dumper-adapters );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 10.4Modify the dumping program. Create another subroutine that takes a list of modules and returns the ones that are installed. Use that subroutine to provide the default for <code>MAIN</code>.</p>
</div>
<div class="paragraph">
<p>练习10.4 修改转储程序。创建另一个子例程，该子例程获取模块列表并返回已安装的模块。使用该子例程为 <code>MAIN</code> 提供默认值。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_从_web_抓取数据">4.21. 从 Web 抓取数据</h3>
<div class="paragraph">
<p><code>HTTP::UserAgent</code> is a handy module to fetch data from the web. Install it with <strong>zef</strong> and follow the example:</p>
</div>
<div class="paragraph">
<p><code>HTTP::UserAgent</code> 是一个方便的模块，用于从 Web 抓取数据。用 <strong>zef</strong> 安装它并按照示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use HTTP::UserAgent;
my $ua = HTTP::UserAgent.new;
$ua.timeout = 10;

my $url = ...;
my $response = $ua.get( $url );
my $data = do with $response {
    .is-success ?? .content !! die .status-line
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you have the data you can do whatever you like, including reading some lines from it:</p>
</div>
<div class="paragraph">
<p>获得数据后，你可以随意执行任何操作，包括从中读取一些行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $data.lines(5) -&gt; $line {
    put ++$, &#39;: &#39;, $line;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 10.5Write a program that fetches the URL you provide on the command line, then outputs its contents to standard output.</p>
</div>
<div class="paragraph">
<p>练习10.5 编写一个程序，用于抓取你在命令行上提供的 URL，然后将其内容输出到标准输出。</p>
</div>
</div>
<div class="sect2">
<h3 id="_在_raku_中运行_perl_5">4.22. 在 Raku 中运行 Perl 5</h3>
<div class="paragraph">
<p>One of Raku’s original goals was Perl 5 interoperability. Larry Wall said that if the new Raku could run “with 95-percent accuracy 95 percent of the [Perl 5] scripts, and 100-percent accuracy 80 percent of the [Perl 5] scripts, then that’s getting into the ballpark.” This meant, as a goal, that a lot of the current Perl 5 contents of the Comprehensive Perl Archive Network (CPAN) would be available in Raku.</p>
</div>
<div class="paragraph">
<p>The <code>Inline::Perl5</code> module allows you to load Perl 5 modules or evaluate Perl 5 snippets from a Raku program. Add the source <code>:from&lt;Perl5&gt;</code> after the module you want to load, then translate the syntax to Raku (so, <code>.</code> for a method call and so on). You don’t have to load <code>Inline::Perl5</code> explicitly in this case:</p>
</div>
<div class="paragraph">
<p>Raku 最初的目标之一是 Perl 5 的互操作性。 Larry Wall 表示，如果新的 Raku 能够“以 95% 的[Perl 5]脚本 95% 的准确率运行，并且 80% 的[Perl 5]脚本能够 100% 准确地运行，那么它就会进入可变通范围。”这意味着，作为一个目标，Raku 中将提供 Comprehensive Perl Archive Network（CPAN）的许多当前 Perl 5 内容。</p>
</div>
<div class="paragraph">
<p><code>Inline::Perl5</code> 模块允许你加载 Perl 5 模块或计算 Raku 程序中的 Perl 5 片段。在要加载的模块之后添加源：<code>:from&lt;Perl5&gt;</code>，然后将语法转换为 Raku（因此，<code>.</code> 用于方法调用等等。）。在这种情况下，你不必显式加载 <code>Inline::Perl5</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Business::ISBN:from&lt;Perl5&gt;;
my $isbn = Business::ISBN.new( &#39;9781491977682&#39; );
say $isbn.as_isbn10.as_string;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can have Perl 5 code in your program and call it when you need it, dropping in and out of it as you like. Create an object that will handle the Perl 5 code for you:</p>
</div>
<div class="paragraph">
<p>你可以在程序中使用 Perl 5 代码，并在需要时调用它，根据需要加入和退出。创建一个将为你处理 Perl 5 代码的对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Inline::Perl5;
my $p5 = Inline::Perl5.new;

$p5.run: q:to/END/;
    sub p5_test { return &#39;Hello from Perl 5!&#39; }
END

put &#39;Hello from Raku!&#39;;

$p5.run: &#39;print p5_test()&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 10.6Compare the results of the Perl 5 and 6 versions of <code>Digest::MD5</code> by loading them into the same program. Get the digest of the program itself. You can use <code>slurp</code> to read the entire contents of a file.</p>
</div>
<div class="paragraph">
<p>练习10.6将 <code>Digest::MD5</code> 的 Perl 5 和 Raku 版本的结果加载到同一程序中。获取程序本身的摘要。你可以使用 <code>slurp</code> 来读取文件的全部内容。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_6">4.23. 总结</h3>
<div class="paragraph">
<p>You’ve learned how to find and install modules with <strong>zef</strong>. You can often simply follow the example in the module’s documentation to get what you want. Before you set out to program something, see if someone else has already done it.</p>
</div>
<div class="paragraph">
<p>You’re not limited to modules from Raku either. The <code>Inline</code> modules allow you to use code from other languages. If you have a favorite module you might not have to give it up.</p>
</div>
<div class="paragraph">
<p>你已经学会了如何使用 <strong>zef</strong> 查找和安装模块。你通常可以按照模块文档中的示例来获得所需内容。在你开始编程之前，看看其他人是否已经做过了。</p>
</div>
<div class="paragraph">
<p>你不仅限于 Raku 的模块。<code>Inline</code> 模块允许你使用其他语言的代码。如果你有一个喜欢的模块，你可能不必放弃它。
== 子例程</p>
</div>
<div class="paragraph">
<p>Now it’s time for more sophisticated subroutines. You were introduced to them in [Chapter 5](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch05.html#camelia-blocks" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch05.html#camelia-blocks</a>) but you only saw enough to support the upcoming chapters. Now that you’ve seen [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html)s" class="bare">https://docs.raku.org/type/Array.html)s</a> and [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html)es" class="bare">https://docs.raku.org/type/Hash.html)es</a>, there’s much more you can do with subroutine signatures.</p>
</div>
<div class="paragraph">
<p>现在是更复杂的子例程的时候了。你在第五章见过它们了，但你只看到足以支持即将到来的章节。现在你已经看过[<code>数组</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) 和 [<code>哈希</code>](<a href="https://docs.raku.org/type/Hash.html)，你可以用子例程签名做更多的事情。" class="bare">https://docs.raku.org/type/Hash.html)，你可以用子例程签名做更多的事情。</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_a_basic_subroutine">4.24. A Basic Subroutine</h3>
<div class="paragraph">
<p>When you run a subroutine you get some sort of result: the last evaluated expression. That’s the return value. This sets basic routines apart from the simpler [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)s" class="bare">https://docs.raku.org/type/Block.html)s</a> you saw in [Chapter 5](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch05.html#camelia-blocks" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch05.html#camelia-blocks</a>). A [<code>Routine</code>](<a href="https://docs.raku.org/type/Routine.html" class="bare">https://docs.raku.org/type/Routine.html</a>) knows how to send a value back to the code that called it. This subroutine returns a different [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) if the argument is odd or even:</p>
</div>
<div class="paragraph">
<p>当你运行子例程时，你会得到某种结果：最后被计算的表达式。这是返回值。这将基础子例程和你在第五章中看到的更简单的 [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) 区分开。[<code>例程</code>](<a href="https://docs.raku.org/type/Routine.html)知道如何将值发送回调用它的代码。如果参数为奇数或偶数，则此子例程返回不同的"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)：" class="bare">https://docs.raku.org/type/Str.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub odd-or-even {
    if ( @_[0] %% 2 ) { &#39;Even&#39; }
    else              { &#39;Odd&#39;  }
    }

odd-or-even( 2 );    # Even
odd-or-even( 137 );  # Odd</code></pre>
</div>
</div>
<div class="paragraph">
<p>Without a signature the arguments show up in @_. Each subroutine has its own version of that variable so it doesn’t conflict with any other subroutine’s @_. This code calls one subroutine that calls another. <code>top-call`shows its `@_</code> before and after <code>show-args</code>:</p>
</div>
<div class="paragraph">
<p>如果没有签名，则参数会出现在 @_ 中。每个子例程都有自己的变量版本，因此它不会与任何其它子例程的 @_ 冲突。此代码调用一个调用另一个子例程的子例程。 <code>top-callshows</code> 显示 <code>show-args</code> 之前和之后的 <code>@_</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">top-call( &lt;Hamadryas perlicus&gt; );

sub show-args { say @_ }
sub top-call {
    put &#34;Top: @_[]&#34;;
    show-args( &lt;a b c&gt; );
    put &#34;Top: @_[]&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even though both use <code>@<em></em></code><em> they are separate. The <code>@</code></em> in <code>top-call</code> isn’t disturbed by <code>show-args</code>:</p>
</div>
<div class="paragraph">
<p>尽管两者都使用 <code>@<em></em></code><em>，但它们是分开的。 <code>top-call</code> 中的 <code>@</code></em> 不受 <code>show-args</code> 的干扰：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Top: Hamadryas perlicus
[a b c]
Top: Hamadryas perlicus</code></pre>
</div>
</div>
<div class="paragraph">
<p>The subroutine definition is lexically scoped. If you need it for only part of the code you can hide it in a [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>). Outside the [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) that subroutine is not visible:</p>
</div>
<div class="paragraph">
<p>子例程定义是词法范围的。如果只需要部分代码，则可以将其隐藏在 Block 中。在 Block 之外，子例程不可见：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
put odd-or-even( 137 );
sub odd-or-even { ... } # only defined in this block
}

put odd-or-even( 37 );  # undeclared routine!</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_额外的参数">4.24.1. 额外的参数</h4>
<div class="paragraph">
<p>What does <code>odd-or-even</code> accept, though? The parameter is an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) but you only use the first element. These calls still work without warnings or errors:</p>
</div>
<div class="paragraph">
<p>但是 <code>odd-or-even</code> 接受了什么？参数是一个数组，但你只使用第一个元素。这些调用仍然有效，没有警告或错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put odd-or-even( 2, 47        );  # Even
put odd-or-even( 137, &#39;Hello&#39; );  # Odd</code></pre>
</div>
</div>
<div class="paragraph">
<p>This isn’t necessarily wrong. It depends on what you are trying to do. Maybe you specifically want as many arguments as the caller decides to send:</p>
</div>
<div class="paragraph">
<p>这不一定是错的。这取决于你想要做什么。也许你特别想要调用者决定发送尽可能多的参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub plus-minus {
    [-]
    @_
        .rotor(2, :partial)
        .map: { $^a[0] + ($^a[1] // 0) }
    }

put plus-minus( 9,1,2,3 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the signatures you’ll see later in the chapter you’ll be able to control this to get the situation that you want.</p>
</div>
<div class="paragraph">
<p>使用你将在本章后面看到的签名，你将能够控制它以获得你想要的情况。</p>
</div>
</div>
<div class="sect3">
<h4 id="_显式返回">4.24.2. 显式返回</h4>
<div class="paragraph">
<p>You can explicitly return from anywhere in a subroutine with <code>return</code>. This distinguishes a subroutine from the [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)s" class="bare">https://docs.raku.org/type/Block.html)s</a> you used in [Chapter 5](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch05.html#camelia-blocks" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch05.html#camelia-blocks</a>). This version is the same thing but with an explicit <code>return</code>:</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>return</code> 从子例程中的任何位置显式返回。这将子例程与你在第五章中使用的 Block 区分开来。这个版本是相同的，但具有明确的返回：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub odd-or-even ( $n ) {
    if ( $n %% 2 ) { return &#39;Even&#39; }
    else           { return &#39;Odd&#39;  }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Call this with extra arguments and you get an error:</p>
</div>
<div class="paragraph">
<p>使用额外的参数调用此方法会出现错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put odd-or-even( 2, 47 );  # Error</code></pre>
</div>
</div>
<div class="paragraph">
<p>The message tells you the argument list does not match the signature:</p>
</div>
<div class="paragraph">
<p>该消息告诉你参数列表与签名不匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Calling odd-or-even(Int, Int) will never work with declared signature ($n)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You could write this differently. <code>do</code> converts the entire <code>if</code> structure into something that evaluates to its last evaluated expression. Return the value of the <code>do</code> instead of repeating the <code>return</code>:</p>
</div>
<div class="paragraph">
<p>你可以用不同的方式写出来。<code>do</code> 将整个 <code>if</code> 结构转换为计算其最后计算的表达式的内容。返回 <code>do</code> 的值而不是重复 <code>return</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub odd-or-even ( $n ) {
    return do {
        if ( $n %% 2 ) { &#39;Even&#39; }
        else           { &#39;Odd&#39;  }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The conditional operator is the same thing expressed differently:</p>
</div>
<div class="paragraph">
<p>条件运算符是同样的东西，它以不同的方式表达：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub odd-or-even ( $n ) {
    return $n %% 2 ?? &#39;Even&#39; !! &#39;Odd&#39;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another way to do the same thing is to have a default return value but return sooner for other situations:</p>
</div>
<div class="paragraph">
<p>另一种做同样事情的方法是使用默认返回值，但在其他情况下更快返回：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub odd-or-even ( $n ) {
    return &#39;Even&#39; if $n %% 2;
    &#39;Odd&#39;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or back to where you started with an implicit return:</p>
</div>
<div class="paragraph">
<p>或者回到你开始的隐式返回：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub odd-or-even ( $n ) { $n %% 2 ?? &#39;Even&#39; !! &#39;Odd&#39; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>These techniques are more appealing in more complex situations that I’m not going to show here. No matter which of these serves your situation, they all do the same thing: they send a value back to the code that called it.</p>
</div>
<div class="paragraph">
<p>这些技术在更复杂的情况下更具吸引力，我不会在这里展示。无论哪种情况适合你的情况，它们都会做同样的事情：它们将值发送回调用它的代码。</p>
</div>
<div class="paragraph">
<p>EXERCISE 11.1Create a subroutine that returns the least common multiple of two integers. Use that in a program that takes two integers from the command line. The particulars of this exercise are very simple but it’s the structure of the subroutine definitions that matter.</p>
</div>
<div class="paragraph">
<p>练习11.1创建一个返回两个整数的最小公倍数的子程序。在从命令行获取两个整数的程序中使用它。这个练习的细节非常简单，但重要的是子程序定义的结构。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_递归">4.25. 递归</h3>
<div class="paragraph">
<p>Subroutines can call themselves; this is called recursion. The classic example is Fibonacci numbers, where the next number in the series is the sum of the preceding two given that the first two numbers are 0 and 1:</p>
</div>
<div class="paragraph">
<p>子程序可以调用自己;这称为递归。典型的例子是 Fibonacci 数，其中系列中的下一个数字是前两个的总和，前两个数字是 0 和 1：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub fibonacci ( $n ) {
    return 0 if $n == 0;  # special case of n = 0
    return 1 if $n == 1;
    return fibonacci( $n - 1 ) + fibonacci( $n - 2 );
    }

say fibonacci( 10 );  # 55</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you call this subroutine with the value of <code>10</code> it calls itself twice to get the values for <code>9</code> and <code>8</code>. When it calls itself for <code>9</code>, it creates two more calls for <code>8</code> and <code>7</code>. It keeps creating more and more calls to itself until the arguments are <code>0</code> or <code>1</code>. It can then return a value one level up, working its way back to where it started.</p>
</div>
<div class="paragraph">
<p>当你使用值 <code>10</code> 调用此子例程时，它会调用自身两次以获取 <code>9</code> 和 <code>8</code> 的值。当它自己调用 <code>9</code> 时，它会为 <code>8</code> 和 <code>7</code> 创建两个以上的调用。它会不断创建对自身的调用，直到参数为 <code>0</code> 或 <code>1</code>.然后它可以返回一个级别的值，然后返回到它开始的位置。</p>
</div>
<div class="paragraph">
<p>A Raku subroutine knows what it is inside its own [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>). The variable <code>&amp;?ROUTINE</code> is the same subroutine object. You don’t have to know the current subroutine’s name. This is the same thing:</p>
</div>
<div class="paragraph">
<p>Raku 子程序知道它自己的 Block 内部是什么。变量`&amp;?ROUTINE`是相同的子程序对象。你不必知道当前子例程的名称。这是同样的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub fibonacci ( $n ) {
    return 0 if $n == 0;
    return 1 if $n == 1;
    return &amp;?ROUTINE( $n - 1 ) + &amp;?ROUTINE( $n - 2 );
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is only slightly better. You’ll read more about this later when you encounter <code>multi</code> subroutines.</p>
</div>
<div class="paragraph">
<p>这稍微好一点。当你遇到 <code>multi</code> 子程序时，你将在以后阅读更多相关信息。</p>
</div>
<div class="paragraph">
<p>EXERCISE 11.2Another favorite example of recursion is the factorial function. Start with a positive whole number and multiply it by all the strictly positive numbers that come before it. The factorial of 6 would be 6*5*4*3*2*1. Implement this as a recursive function. Once you’ve done that, implement it in the amazingly simple Raku fashion. How big a number can you get your program to produce?</p>
</div>
<div class="paragraph">
<p>练习11.2递归的另一个例子是阶乘函数。从正整数开始，然后乘以前面的所有严格正数。阶乘为6将为65432 * 1。将其实现为递归函数。完成后，以非常简单的Raku方式实现它。你的程序可以产生多大的数字？</p>
</div>
<div class="sect3">
<h4 id="_迭代而不是递归">4.25.1. 迭代而不是递归</h4>
<div class="paragraph">
<p>You can turn many recursive solutions into iterative ones. Instead of repeatedly calling subroutines with all the overhead they entail (each call sets up a new scope, defines new variables, and so on), rearrange things so you don’t need a subroutine.</p>
</div>
<div class="paragraph">
<p>你可以将许多递归解决方案转换为迭代解决方案。而不是重复调用子程序，它们需要所有开销（每个调用设置一个新的作用域，定义新的变量，等等），重新排列事物，这样你就不需要子程序了。</p>
</div>
<div class="paragraph">
<p>The factorial case is easy. The reduction operator does that for you:</p>
</div>
<div class="paragraph">
<p>阶乘这个情况很容易。规约运算符为你执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $factorial = [*] 1 .. $n;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The operators are actually methods, so you don’t actually avoid calling something.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>运算符实际上是方法，所以你实际上避免不了调用某些东西。</p>
</div>
<div class="paragraph">
<p>The Fibonacci case is easy too when you use a [<code>Seq</code>](<a href="https://docs.raku.org/type/Seq.html" class="bare">https://docs.raku.org/type/Seq.html</a>):</p>
</div>
<div class="paragraph">
<p>使用 <code>Seq</code> 时，Fibonacci 案例也很简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fibonacci := 1, 1, * + * ... *;
put &#34;Fib(5) is &#34;, $fibonacci[5];</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can make a queue of things to work on. With a queue you can add items anywhere you like. Instead of processing the next thingy immediately you can put it at the end of the queue. When it’s time to process the next thingy you can take it from the beginning, end, or middle. You can add as many elements as you want:</p>
</div>
<div class="paragraph">
<p>你可以创建一个可以处理的事物队列。使用队列，你可以在任何地方添加项目。不要立即处理下一个东西，而是将它放在队列的末尾。当处理下一件事时，你可以从开始，结束或中间开始。你可以根据需要添加任意数量的元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @queue = ( ... );
while @queue {
    my $thingy = @queue.shift; # or .pop
    ... # generate more items to process
    @queue.append: @additional-items; # or .push or .unshift
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_在库中存储子程序">4.26. 在库中存储子程序</h3>
<div class="paragraph">
<p>Start with a simple subroutine to choose a random integer between two integers (including the endpoints). Use <code>.rand</code> and coerce the result with <code>.Int</code>, then shift the result into the right range:</p>
</div>
<div class="paragraph">
<p>从一个简单的子程序开始，选择两个整数（包括端点）之间的随机整数。使用 <code>.rand</code> 并使用 <code>.Int</code> 强制结果，然后将结果移动到正确的范围：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub random-between ( $i, $j ) {
    ( $j - $i ).rand.Int + $i;
    }

say random-between( -10, -3 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>You might need to convince yourself that works. Your program gets its job done, so you don’t think about it again. Then you write a different program doing something similar and you want to use that subroutine again. You do what many people don’t want to admit to: you cut and paste the subroutine into a different program. Again, it works. Or does it?</p>
</div>
<div class="paragraph">
<p>你可能需要说服自己有所作为。你的程序完成了它的工作，所以你不要再考虑它了。然后你编写一个不同的程序做类似的事情，你想再次使用该子程序。你做了许多人不愿意承认的事情：你将子程序剪切并粘贴到另一个程序中。再次，它的工作原理。或者是吗？</p>
</div>
<div class="paragraph">
<p>Did you really get a number between <code>$i</code> and <code>$j</code> inclusively?</p>
</div>
<div class="paragraph">
<p>你真的得到了$ i和$ j之间的数字吗？</p>
</div>
<div class="paragraph">
<p>EXERCISE 11.3What’s the maximum number that <code>random-between</code> produces for any <code>$i</code> and <code>$j</code>? Write a program that figures it out by running <code>random-between</code> repeatedly to see the actual range of results.</p>
</div>
<div class="paragraph">
<p>练习11.3任意$ i和$ j之间随机产生的最大数量是多少？编写一个程序，通过反复运行随机查看结果的实际范围来计算出来。</p>
</div>
<div class="paragraph">
<p>Once you’ve done that exercise you know that <code>random-between</code> didn’t ever select the second endpoint as one of the random values. If you had copied it into other programs it would have been wrong in several places. There’s a way to fix that.</p>
</div>
<div class="paragraph">
<p>一旦你完成了这个练习，你就知道随机中断之间并没有选择第二个端点作为随机值之一。如果你把它复制到其他程序中，它会在几个地方出错。有办法解决这个问题。</p>
</div>
<div class="paragraph">
<p>To use the same subroutine in several programs you can define it once in a library. That’s a separate file that you can import into your program.</p>
</div>
<div class="paragraph">
<p>要在多个程序中使用相同的子程序，可以在库中定义一次。这是一个单独的文件，你可以导入到你的程序中。</p>
</div>
<div class="paragraph">
<p>Move <code>random-between</code> to a new file that has the <strong>.pm</strong> or <strong>.pm6</strong> extension:</p>
</div>
<div class="paragraph">
<p>随机移动到具有.pm或.pm6扩展名的新文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># MyRandLibrary.pm6
sub random-between ( $i, $j ) {
    ( $j - $i ).rand.Int + $i;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In your original program import your library with <code>use</code>. Set <code>lib</code> as you saw in [Chapter 10](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch10.html#camelia-using_modules" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch10.html#camelia-using_modules</a>):</p>
</div>
<div class="paragraph">
<p>在你的原始程序中导入你的库使用。按照第10章中的说明设置lib：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># random-between.p6
use lib <i class="conum" data-value="1"></i><b>(1)</b>
use MyRandLibrary;
say random-between( -10, -3 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your program finds your library but now you get a different error:</p>
</div>
<div class="paragraph">
<p>你的程序找到了你的库，但现在你收到了另一个错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku random-between.p6
===SORRY!=== Error while compiling ...
Undeclared routine:
    random-between used at line ...</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_导出子程序">4.26.1. 导出子程序</h4>
<div class="paragraph">
<p>Subroutines are lexically scoped by default, so they can’t be seen outside their files. If you want another file to use them you need to export those subroutines. The <code>is export</code> trait does that and comes right after the signature:</p>
</div>
<div class="paragraph">
<p>默认情况下，子例程在词法上是作用域的，因此不能在文件外看到它们。如果你想要使用其他文件，则需要导出这些子例程。出口特征是这样做的，并在签名后立即出现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># MyRandLibrary.pm6
sub random-between ( $i, $j ) is export {
    ( $j - $i ).rand.Int + $i;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your program now finds the library, imports the subroutine, and produces a number between your endpoints:</p>
</div>
<div class="paragraph">
<p>你的程序现在找到库，导入子例程，并在端点之间生成一个数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku random-between.p6
11</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 11.4Create the library that exports the <code>random-between</code> subroutine and use it in a program to get a random number between the two command-line arguments. What happens when the first argument is greater than the second? What happens if one of the arguments is not a number?</p>
</div>
<div class="paragraph">
<p>练习11.4创建导出random-between子例程的库，并在程序中使用它来获取两个命令行参数之间的随机数。当第一个参数大于第二个参数时会发生什么？如果其中一个参数不是数字，会发生什么？</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_位置参数">4.27. 位置参数</h3>
<div class="paragraph">
<p>There are two types of parameters. The first are the positional parameters that you’ve seen already in [Chapter 5](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch05.html#camelia-blocks" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch05.html#camelia-blocks</a>). These parameters handle the arguments by their order in the argument list. We’ll look at them in a bit more detail here. You’ll see the other sort, named parameters, later in this chapter.</p>
</div>
<div class="paragraph">
<p>有两种类型的参数。第一个是你在第5章中已经看到的位置参数。这些参数按参数列表中的顺序处理参数。我们将在这里详细介绍它们。你将在本章后面看到另一种命名参数。</p>
</div>
<div class="paragraph">
<p>With no explicit signature the arguments show up in the array <code>@<em></em></code><em>. Each subroutine gets its own <code>@</code></em> so it doesn’t conflict with that for any other subroutine. So, if you write this:</p>
</div>
<div class="paragraph">
<p>没有明确的签名，参数显示在数组@<em>中。每个子程序都有自己的@</em>，因此它不会与任何其他子程序冲突。所以，如果你这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub show-the-arguments {
    put &#34;The arguments are: &#34;, @_.gist;
    }

show-the-arguments( 1, 3, 7 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>You get:</p>
</div>
<div class="paragraph">
<p>你得到：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">The arguments are: [1 3 7]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>@<em></em></code><em> inside the subroutine automatically adds the implicit signature. But it’s not as simple as an explicit <code>@</code></em><code>`parameter by itself. This signature expects a single [`Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) argument:</p>
</div>
<div class="paragraph">
<p>在子例程中使用@_会自动添加隐式签名。但它本身并不像显式的@_parameter那么简单。此签名需要一个Positional参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub show-the-arguments ( @_ ) { # Single Positional argument
    put &#34;The arguments are: &#34;, @_.gist;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Calling it with multiple arguments is a compile-time error:</p>
</div>
<div class="paragraph">
<p>使用多个参数调用它是编译时错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">show-the-arguments( 1, 3, 7 );   # Won&#39;t compile</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>( @_ )</code> signature wants a single argument that’s some sort of [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) (not necessarily an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html)" class="bare">https://docs.raku.org/type/Array.html)</a>):</p>
</div>
<div class="paragraph">
<p>（@_）签名需要一个参数，它是某种Positional（不一定是数组）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">show-the-arguments( [ 1, 3, 7 ] );   # Single argument</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_slurpy_parameters_吞噬参数">4.27.1. Slurpy Parameters 吞噬参数</h4>
<div class="paragraph">
<p>A slurpy parameter gets all of the remaining arguments into a single [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>). Prefix the array parameter with a <code>*</code>. This is the same as the version with no explicit signature:</p>
</div>
<div class="paragraph">
<p>一个slurpy参数将所有剩余的参数都放入一个Array中。使用*前缀数组参数。这与没有显式签名的版本相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub show-the-arguments ( *@_ ) {  # slurpy
    put &#34;The arguments are: &#34;, @_.gist;
    }

show-the-arguments( 1, 3, 7 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output shows the three numbers:</p>
</div>
<div class="paragraph">
<p>输出显示三个数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">The arguments are: [1 3 7]</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s not much special about <code>@_</code>. You can use your own variable name instead:</p>
</div>
<div class="paragraph">
<p>@_没什么特别之处。你可以使用自己的变量名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub show-the-arguments ( *@args ) {  # slurpy
    put &#34;The arguments are: &#34;, @args.gist;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Try it with something slightly different now. Include a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) as one of the arguments:</p>
</div>
<div class="paragraph">
<p>现在尝试使用略有不同的东西。包含List作为参数之一：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub show-the-arguments ( *@args ) {  # slurpy
    put &#34;The arguments are: &#34;, @args.gist;
    }

show-the-arguments( 1, 3, ( 7, 6, 5 ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Did you expect this output? It’s a flat [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) with no structure:</p>
</div>
<div class="paragraph">
<p>你有没有期待这个输出？这是一个没有结构的平面列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">The arguments are: [1 3 7 6 5]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This isn’t a problem with formatting the data; the slurpy parameter flattens the data. Try it again with another level:</p>
</div>
<div class="paragraph">
<p>这不是格式化数据的问题; slurpy参数使数据变平。再试一次另一个级别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">show-the-arguments( 1, 3, ( 7, (6, 5) ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>You get the same output with no structure:</p>
</div>
<div class="paragraph">
<p>你得到相同的输出，没有结构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">The arguments are: [1 3 7 6 5]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The slurpy parameter only flattens objects that you can iterate. If you itemize one of the [<code>List</code>](<a href="https://docs.raku.org/type/List.html)s" class="bare">https://docs.raku.org/type/List.html)s</a> that item is no longer iterable. Items resist flattening:</p>
</div>
<div class="paragraph">
<p>slurpy参数仅展平你可以迭代的对象。如果你列出其中一个列表，则该项目不再可迭代。物品抗压扁：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">show-the-arguments( 1, 3, ( 7, $(6, 5) ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output is a bit different:</p>
</div>
<div class="paragraph">
<p>输出有点不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">The arguments are: [1, 3, 7, (6, 5)]</code></pre>
</div>
</div>
<div class="paragraph">
<p>How about this one?</p>
</div>
<div class="paragraph">
<p>这个怎么样？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">show-the-arguments( [ 1, 3, ( 7, $(6, 5) ) ] );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) you have an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>). Remember that an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) already itemizes each of its elements. The <code>( 7, $(6, 5) )</code> is itemized because it’s an element of an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>):</p>
</div>
<div class="paragraph">
<p>而不是List你有一个数组。请记住，数组已经逐项列出了每个元素。 （7，$（6,5））是逐项列出的，因为它是数组的一个元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">The arguments are: [1, 3, (7, $(6, 5))]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use a <code>**</code> in front of the parameter if you don’t want this automatic flattening:</p>
</div>
<div class="paragraph">
<p>如果你不希望这种自动展平，请在参数前面使用 <code>**</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub show-nonflat-arguments ( **@args ) {  # nonflattening slurpy
    put &#34;The nonflat arguments are: &#34;, @args.gist;
    }

show-nonflat-arguments( [ 1, 3, ( 7, $(6, 5) ) ] );</code></pre>
</div>
</div>
<div class="paragraph">
<p>This output has a double set of square brackets around the data. The single argument is the inner [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) and the entire argument list is the outer one:</p>
</div>
<div class="paragraph">
<p>此输出在数据周围有一组双方括号。单个参数是内部数组，整个参数列表是外部数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">The nonflat arguments are: [[1 3 (7 (6 5))]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 11.5Create a subroutine that outputs its argument count and shows each argument on a separate line. Try it with these argument lists:`1, 3, 7 1, 3, ( 7, 6, 5 ) 1, 3, ( 7, $(6, 5) ) [ 1, 3, ( 7, $(6, 5) ) ]`</p>
</div>
<div class="paragraph">
<p>练习11.5创建一个子程序，输出其参数计数并在一个单独的行上显示每个参数。尝试使用这些参数列表：<code>1,3,7 1,3,3（7,6,5）1,3，（7，$（6,5））[1,3，（7，$（6， 5））]</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_have_it_both_ways">4.27.2. Have It Both Ways</h4>
<div class="paragraph">
<p>What if you want both flattening and nonflattening at the same time? If there’s one argument, you want to flatten that. If there’s more than one argument you want to leave that [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) alone. Use a <code>+</code> in front of a parameter to use the single argument rule:</p>
</div>
<div class="paragraph">
<p>如果你想要同时展平和不展平怎么办？如果有一个论点，你想要弄平。如果有多个参数，你希望单独保留该列表。在参数前面使用+来使用单个参数规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub show-plus-arguments ( +@args ) {  # single argument rule
    put &#34;There are {@args.elems} arguments&#34;;
    put &#34;The nonflat arguments are: &#34;, @args.gist;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you pass one argument that argument is flattened into <code>@args</code>. With more than one argument you don’t get flattening:</p>
</div>
<div class="paragraph">
<p>如果你传递一个参数，将参数展平为@args。如果有多个参数，你就不会变平：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = (1,3,7);

show-plus-arguments( @a );    # flattened
show-plus-arguments( @a, 5 ); # not flattened</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output shows the difference. In your first call to <code>show-plus-arguments</code> it looks like you have single [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) argument. By the time it gets inside the subroutine that [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) has been flattened into three `Int`arguments:</p>
</div>
<div class="paragraph">
<p>输出显示差异。在第一次调用show-plus-arguments时，看起来你有单个Array参数。当它进入子程序时，Array已被展平为三个Intarguments：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">There are 3 arguments
The nonflat arguments are: [1 3 7]
There are 2 arguments
The nonflat arguments are: [[1 3 7] 5]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your second call has the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) along with <code>5</code>. With more than one argument you don’t get flattening and the argument list has an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) argument and an [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>) argument.</p>
</div>
<div class="paragraph">
<p>你的第二个调用有数组和5.有多个参数你没有变平，参数列表有一个Array参数和一个Int参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_combining_slurpies">4.27.3. Combining Slurpies</h4>
<div class="paragraph">
<p>You can have only one slurpy [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) parameter, since it will take up the rest of the positional arguments. However, you can have positional parameters before a slurpy parameter:</p>
</div>
<div class="paragraph">
<p>你可以只有一个slurpy Array参数，因为它将占用其余的位置参数。但是，你可以在slurpy参数之前获得位置参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub show-the-arguments ( $i, $j, *@args ) {  # slurpy
    put &#34;The arguments are i: $i j: $j and @args[]&#34;;
    }

show-the-arguments( 1, 3, 7, 5 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first two arguments fill in <code>$i</code> and <code>$j</code> and anything left over goes into <code>@args</code>:</p>
</div>
<div class="paragraph">
<p>前两个参数填写$ i和$ j，剩下的任何内容都会输入@args：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">The arguments are i: 1 j: 3 and 7 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>What if you put all but one of the arguments into an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html)?" class="bare">https://docs.raku.org/type/Array.html)?</a></p>
</div>
<div class="paragraph">
<p>如果将除一个参数之外的所有参数放入数组中该怎么办？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = ( 3, 7, 5 );
show-the-arguments( 1, @a );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the output shows that <code>$j</code> has an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) value and <code>@args</code> has nothing:</p>
</div>
<div class="paragraph">
<p>现在输出显示$ j有一个Array值而@args什么都没有：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">The arguments are i: 1 j: 3 7 5 and</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 11.6Create a library that provides a <code>head</code> and a <code>tail</code> function that each take a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) parameter. Make your <code>head`function return the first item in the [`List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) and your <code>tail</code> function return everything else. Do not change the original [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>). If you’re used to Lisp you might call these <code>car</code> and <code>cdr</code>:`use lib &lt;.&gt;; use HeadsTails;  my @a = &lt;1 3 5 7 11 13&gt;;  say head( @a );  # 1 say tail( @a );  # [ 3 5 7 11 13 ]`</p>
</div>
<div class="paragraph">
<p>练习11.6创建一个提供head和tail函数的库，每个函数都有一个List参数。让你的headfunction返回List中的第一项，你的tail函数返回其他所有内容。请勿更改原始列表。如果你习惯使用Lisp，可以将这些汽车和cdr称为：使用lib &lt;。&gt;;使用HeadsTails;我的@a = &lt;1 3 5 7 11 13&gt;;说头（@a）; ＃1说尾巴（@a）; ＃[3 5 7 11 13]</p>
</div>
</div>
<div class="sect3">
<h4 id="_optional_and_default_arguments">4.27.4. Optional and Default Arguments</h4>
<div class="paragraph">
<p>By default all positional parameters require arguments. A question mark, <code>?</code>, after a parameter marks it as optional so that you don’t need to supply an argument. This subroutine takes one or two arguments:</p>
</div>
<div class="paragraph">
<p>默认情况下，所有位置参数都需要参问号？后面的参数将其标记为可选，这样你就不需要提供参数。该子例程需要一个或两个参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub one-or-two ( $a, $b? ) {
    put $b.defined ?? &#34;Got $a and $b&#34; !! &#34;Got $a&#34;;
    }

one-or-two( &#39;Hamadryas&#39; );
one-or-two( &#39;Hamadryas&#39;, &#39;perlicus&#39; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you have an optional argument you probably want a default value. Assign to a parameter to give it a default value. That assignment occurs only when you don’t supply an argument:</p>
</div>
<div class="paragraph">
<p>如果你有可选参数，则可能需要默认值。分配给参数以为其提供默认值。只有在你不提供参数时才会发生该分配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub one-or-two ( $a, $b = 137 ) {
    put $b.defined ?? &#34;Got $a and $b&#34; !! &#34;Got $a&#34;;
    }

one-or-two( 19 );                      # one number
one-or-two( &#39;Hamadryas&#39;, &#39;perlicus&#39; ); # two strings
one-or-two( &lt;Hamadryas perlicus&gt; );    # one array
one-or-two( |&lt;Hamadryas perlicus&gt; );   # flattened array</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output shows that the arguments fill in the parameters differently each time:</p>
</div>
<div class="paragraph">
<p>输出显示参数每次填充参数的方式不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Got 19 and 137
Got Hamadryas and perlicus
Got Hamadryas perlicus and 137
Got Hamadryas and perlicus</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can’t have required positional parameters after an optional one:</p>
</div>
<div class="paragraph">
<p>在可选项之后，你不能拥有所需的位置参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub one-or-two ( $a?, $b ) {
    put $b.defined ?? &#34;Got $a and $b&#34; !! &#34;Got $a&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s a compile-time error:</p>
</div>
<div class="paragraph">
<p>这是一个编译时错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Error while compiling
Cannot put required parameter $b after optional parameters</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_parameter_traits">4.27.5. Parameter Traits</h4>
<div class="paragraph">
<p>The parameter variables are filled in with read-only aliases to the original data. You see the same values but you can’t change them. This subroutine tries to add one to its value:</p>
</div>
<div class="paragraph">
<p>参数变量用原始数据的只读别名填充。你看到相同的值但无法更改它们。此子例程尝试在其值中添加一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub increment ( $a ) { $a++ }

my $a = 137;
put increment( $a );</code></pre>
</div>
</div>
<div class="paragraph">
<p>This doesn’t work because you can’t change the parameter variable:</p>
</div>
<div class="paragraph">
<p>这不起作用，因为你无法更改参数变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Cannot resolve caller postfix:&lt;++&gt;(Int); the following candidates
match the type but require mutable arguments:</code></pre>
</div>
</div>
<div class="paragraph">
<p>The read-only alias is the default. You can change that by applying traits to the parameters. Apply the `is copy`trait to get a mutable value that’s separate from the original argument. You can change it without changing the original value:</p>
</div>
<div class="paragraph">
<p>只读别名是默认值。你可以通过将特征应用于参数来更改它。应用is copytrait以获取与原始参数分开的可变值。你可以在不更改原始值的情况下进行更改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub mutable-copy ( $a is copy ) { $a++; put &#34;Inside: $a&#34; }

my $a = 137;

put &#34;Before: $a&#34;;
mutable-copy( $a );
put &#34;After: $a&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output shows that the original variable’s value did not change:</p>
</div>
<div class="paragraph">
<p>输出显示原始变量的值未更改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Before: 137
Inside: 138
After: 137</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use the <code>is rw</code> trait to change the original value. If the argument is a writable container you can change the value. If the value is not some sort of container you’ll get an error:</p>
</div>
<div class="paragraph">
<p>使用is rw trait更改原始值。如果参数是可写容器，则可以更改该值。如果该值不是某种容器，则会出现错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub read-write ( $a is rw ) { $a++ }

my $a  = 137;
my $b :=  37;
my \c  =   7;

read-write( $a );  # writable so okay
read-write( $b );  # literal,  not mutable - ERROR!
read-write( c );   # constant, not mutable - ERROR!
read-write( 5 );   # literal,  not mutable - ERROR!</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_参数约束">4.27.6. 参数约束</h4>
<div class="paragraph">
<p>You can constrain a parameter to a particular type. You already saw some of this in [Chapter 5](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch05.html#camelia-blocks" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch05.html#camelia-blocks</a>):</p>
</div>
<div class="paragraph">
<p>你可以将参数约束为特定类型。你已经在第5章中看到了一些内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub do-something ( Int:D $n ) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The sigils impose their own constraints. An <code>@</code> accepts something that is a [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>), the <code>%</code> accepts something that does [<code>Associative</code>](<a href="https://docs.raku.org/type/Associative.html" class="bare">https://docs.raku.org/type/Associative.html</a>), and the <code>&amp;</code> accepts something that does [<code>Callable</code>](<a href="https://docs.raku.org/type/Callable.html" class="bare">https://docs.raku.org/type/Callable.html</a>):</p>
</div>
<div class="paragraph">
<p>这些印记强加了自己的约束。 @接受一个定位的东西，％接受一个做关联的东西，而接受一些做Callable的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub wants-pos   ( @array ) { put &#34;Got a positional: @array[]&#34; }
sub wants-assoc ( %hash )  { put &#34;Got an associative: {%hash.gist}&#34; }
sub wants-code  ( &amp;code )  { put &#34;Got code&#34; }

wants-pos( &lt;a b c&gt; );
wants-assoc( Map.new: &#39;a&#39; =&gt; 1 );
wants-code( { put &#34;Mini code&#34; } );</code></pre>
</div>
</div>
<div class="paragraph">
<p>These won’t work because they don’t supply the right types of arguments:</p>
</div>
<div class="paragraph">
<p>这些不起作用，因为它们不提供正确类型的参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">wants-pos( %hash );
wants-assoc( &lt;x y z&gt; );
wants-code( 1 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, something that accepts a code block can specify its own signature that must match the argument’s signature. Put the desired signature after the parameter variable:</p>
</div>
<div class="paragraph">
<p>此外，接受代码块的东西可以指定自己的签名，该签名必须与参数的签名匹配。在参数变量后面放置所需的签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub one-arg  ( &amp;code:( $a ), $A )         { &amp;code.($A) }
sub two-args ( &amp;code:( $a, $b ), $A, $B ) { &amp;code.($A, $B) }

one-arg( { put &#34;Got $^a&#34; }, &#39;Hamadryas&#39; );

two-args( { put &#34;Got $^a and $^b&#34; }, &#39;Hamadryas&#39;, &#39;perlicus&#39; );</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_same_name_different_signature">4.28. Same Name, Different Signature</h3>
<div class="paragraph">
<p>You can define the same subroutine name twice by giving it different signatures. Each of these is a candidate. A dispatcher decides which candidate to call based on your arguments. There are several things the dispatcher considers, in this order:</p>
</div>
<div class="paragraph">
<p>你可以通过为其指定不同的签名来定义相同的子例程名称两次。这些都是候选人。调度员根据你的参数决定调用哪个候选者。调度员按以下顺序考虑以下几点：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Literal value</p>
</li>
<li>
<p>Number of arguments (arity)</p>
</li>
<li>
<p>Types of arguments</p>
</li>
<li>
<p>Other constraints</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To define candidates, declare the subroutine with <code>multi</code>. And since <code>multi</code> works on a subroutine by default (you’ll see methods in [Chapter 12](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch12.html#camelia-classes)" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch12.html#camelia-classes)</a>), you can leave off the <code>sub</code>:</p>
</div>
<div class="paragraph">
<p>要定义候选项，请使用multi声明子例程。并且由于默认情况下多个工作在子程序上（你将在第12章中看到方法），你可以不使用子工具：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub some-subroutine { ... }
multi some-subroutine { ... }</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_literal_value_parameters">4.28.1. Literal Value Parameters</h4>
<div class="paragraph">
<p>You can also make a signature that has a literal value. These `multi`s are selected when the argument value is the same as the literal parameter:</p>
</div>
<div class="paragraph">
<p>你还可以创建具有文字值的签名。当参数值与文字参数相同时，选择这些multis：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi something (  1 ) { put &#34;Got a one&#34; }
multi something (  0 ) { put &#34;Got a zero&#34; }
multi something ( $a ) { put &#34;Got something else&#34; }

something(   1 );
something(   0 );
something( 137 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The literal value parameters decide the appropriate subroutine for the first two cases:</p>
</div>
<div class="paragraph">
<p>文字值参数决定前两种情况的相应子例程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Got a one
Got a zero
Got something else</code></pre>
</div>
</div>
<div class="paragraph">
<p>What if you wanted a [<code>Rat</code>](<a href="https://docs.raku.org/type/Rat.html" class="bare">https://docs.raku.org/type/Rat.html</a>) as one of the literal values? Put the value inside <code>&lt;&gt;</code> so the compiler doesn’t think the <code>/</code> is the start of a regex ([Chapter 15](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1)" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1)</a>):</p>
</div>
<div class="paragraph">
<p>如果你想将鼠作为字面值之一，该怎么办？将值放在&lt;&gt;中，这样编译器就不会认为/是正则表达式的开头（第15章）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi something ( 1 )       { put &#34;Got a one&#34; }
multi something ( 0 )       { put &#34;Got a zero&#34; }
multi something ( &lt;1/137&gt; ) { put &#34;Got something fine&#34; }
multi something ( $b )      { put &#34;Got something else&#34; }

something( 1 );
something( 0 );
something( 1/137 );
something( &#39;Hello&#39; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Think about the previous Fibonacci example:</p>
</div>
<div class="paragraph">
<p>想想之前的Fibonacci示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub fibonacci ( $n ) {
    return 0 if $n == 0;
    return 1 if $n == 1;
    return &amp;?ROUTINE( $n - 1 ) + &amp;?ROUTINE( $n - 2 );
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>That implementation has two special cases for <code>0</code> and <code>1</code>. You have to provide special code to handle those. You can move those special cases away from the main idea by giving each case its own <code>multi</code>:</p>
</div>
<div class="paragraph">
<p>该实现有两个特殊情况0和1.你必须提供特殊代码来处理这些。你可以通过为每个案例提供自己的多个来移动这些特殊情况远离主要想法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi fibonacci ( 0 ) { 0 }
multi fibonacci ( 1 ) { 1 }

multi fibonacci ( $n ) {
    return fibonacci( $n - 1 ) + fibonacci( $n - 2 );
    }

put fibonacci(0);
put fibonacci(1);
put fibonacci(5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that you can’t use <code>&amp;?ROUTINE</code> because <code>$n-1</code> might not be handled by the same subroutine.</p>
</div>
<div class="paragraph">
<p>请注意，你不能使用＆？ROUTINE，因为$ n-1可能无法由同一子例程处理。</p>
</div>
</div>
<div class="sect3">
<h4 id="_number_of_arguments">4.28.2. Number of Arguments</h4>
<div class="paragraph">
<p>Declare the <code>sub</code> with <code>multi</code>. One candidate takes a single positional argument and the other candidate takes two positional arguments:</p>
</div>
<div class="paragraph">
<p>用multi声明sub。一个候选者采用单个位置参数，另一个候选者采用两个位置参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi subsomething ( $a     ) { put &#34;One argument&#34;; }
multi subsomething ( $a, $b ) { put &#34;Two arguments&#34;; }

something( 1 );
something( 1, 3 );
# something();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output shows that you called two different subroutines:</p>
</div>
<div class="paragraph">
<p>输出显示你调用了两个不同的子例程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">One argument
Two arguments</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uncomment the call with no arguments, and you’ll get a compile-time error. The compiler knows no signatures can match:</p>
</div>
<div class="paragraph">
<p>取消注释没有参数的调用，你将得到一个编译时错误。编译器知道没有签名可以匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Calling something() will never work with any of these multi signatures:
    ($a)
    ($a, $b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can shorten the <code>multi sub</code> to simply <code>multi</code> since that implies <code>sub</code>:</p>
</div>
<div class="paragraph">
<p>你可以将multi sub简化为multi，因为这意味着sub：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi something ( $a     ) { put &#34;One argument&#34;;  }
multi something ( $a, $b ) { put &#34;Two arguments&#34;; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This sort of dispatch depends on <strong>arity</strong>—the number of arguments that you supply. This means that the compiler also knows when you try to define subroutines with the same arity, like this:</p>
</div>
<div class="paragraph">
<p>这种调度取决于arity  - 你提供的参数数量。这意味着编译器也知道你何时尝试使用相同的arity定义子例程，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi something ( $a ) { put &#34;One argument&#34;; }
multi something ( $b ) { put &#34;Also one arguments&#34;; } # Error</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is also a runtime error because the dispatcher can’t choose one candidate over the other (and it won’t run all of them):</p>
</div>
<div class="paragraph">
<p>这也是一个运行时错误，因为调度程序不能选择一个候选项而不是另一个候选项（它不会运行所有这些候选项）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Ambiguous call to &#39;something&#39;; these signatures all match:
:($a)
:($b)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_parameter_types">4.28.3. Parameter Types</h4>
<div class="paragraph">
<p>You can also choose amongst `multi`s by parameter type. These each take the same number of arguments but distinguish them by type:</p>
</div>
<div class="paragraph">
<p>你还可以通过参数类型在multis中进行选择。这些参数都采用相同数量的参数，但按类型区分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi something ( Int:D $a ) { put &#34;Int argument&#34;;  }
multi something ( Str:D $a ) { put &#34;Str arguments&#34;; }

something( 137 );
something( &#39;Hamadryas&#39; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>These call different subroutines because the argument types are different:</p>
</div>
<div class="paragraph">
<p>这些调用不同的子例程，因为参数类型不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Int argument
Str arguments</code></pre>
</div>
</div>
<div class="paragraph">
<p>You might have the different subroutines take the same type. In those cases you can select the right one by a custom constraint. The dispatcher chooses the most specific one:</p>
</div>
<div class="paragraph">
<p>你可能有不同的子例程采用相同的类型。在这些情况下，你可以通过自定义约束选择正确的约束。调度员选择最具体的一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi something ( Int:D $a ) { put &#34;Odd arguments&#34;; }
multi something ( Int:D $a where * %% 2 ) { put &#34;Even argument&#34; }

something( 137 );
something( 538 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that this works regardless of the order in which you define the subroutines:</p>
</div>
<div class="paragraph">
<p>请注意，无论你定义子例程的顺序如何，这都有效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Odd arguments
Even arguments</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the next example the first subroutine constrains its parameter to numbers that are odd. The second subroutine constrains its parameter to numbers greater than 5. These both have one parameter and they both have a `where`clause, so the dispatcher chooses the first one it encounters:</p>
</div>
<div class="paragraph">
<p>在下一个示例中，第一个子例程将其参数约束为奇数。第二个子例程将其参数约束为大于5的数字。这两个参数都有一个参数，它们都有一个whereclause，所以调度程序选择它遇到的第一个参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub something ( Int:D $a where * % 2 ) { put &#34;Odd number&#34; }
multi sub something ( Int:D $a where * &gt; 5 ) { put &#34;Greater than 5&#34; }

something( 137 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The argument satisfies either signature. The output shows that the first subroutine ran:</p>
</div>
<div class="paragraph">
<p>该论点满足任一签名。输出显示第一个子例程运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Odd number</code></pre>
</div>
</div>
<div class="paragraph">
<p>Reverse the order of definition:</p>
</div>
<div class="paragraph">
<p>颠倒定义的顺序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub something ( Int:D $a where * &gt; 5 ) { put &#34;Greater than 5&#34; }
multi sub something ( Int:D $a where * % 2 ) { put &#34;Odd number&#34; }

something( 137 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first defined subroutine still runs even though it’s a different definition:</p>
</div>
<div class="paragraph">
<p>第一个定义的子例程仍然运行，即使它是一个不同的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Greater than 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>What if you do <strong>not</strong> want multiple definitions with the same name? Declare one of the subroutines without`multi`:</p>
</div>
<div class="paragraph">
<p>如果你不希望使用相同名称的多个定义，该怎么办？声明一个没有多个子程序的子程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub something ( Int $a ) { put &#34;Odd arguments&#34; }

multi something ( Int $a where * %% 2 ) { # redefinition!
    put &#34;Even argument&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You get a compile-time error asking if you meant that to be a <code>multi sub</code>:</p>
</div>
<div class="paragraph">
<p>你得到一个编译时错误，询问你是否认为这是一个多子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">===SORRY!=== Error while compiling
Redeclaration of routine &#39;something&#39; (did you mean to declare a multi-sub?)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_named_parameters">4.29. Named Parameters</h3>
<div class="paragraph">
<p>Named parameters do not depend on their position in the parameter or argument lists. By default they are optional. You can specify them anywhere in the arguments and in any order. These are often used to set options for a routine or method.</p>
</div>
<div class="paragraph">
<p>命名参数不依赖于它们在参数或参数列表中的位置。默认情况下，它们是可选的你可以在参数中的任何位置以任何顺序指定它们。这些通常用于设置例程或方法的选项。</p>
</div>
<div class="paragraph">
<p>Specify named parameters with a colon before the parameter variable. In the signature, use the unquoted parameter variable name, the fat arrow, and the value that you want to supply. The order of the names or values does not matter:</p>
</div>
<div class="paragraph">
<p>在参数变量之前使用冒号指定命名参数。在签名中，使用不带引号的参数变量名称，胖箭头和要提供的值。名称或值的顺序无关紧要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add ( Int:D :$a, Int:D :$b ) {
    $a + $b;
    }

put add( a =&gt; 1,  b =&gt; 36 );  # 37
put add( b =&gt; 36, a =&gt; 1  );  # Same thing</code></pre>
</div>
</div>
<div class="paragraph">
<p>For this to work you cannot quote the keys or use variables as the keys. This call is actually two [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html" class="bare">https://docs.raku.org/type/Pair.html</a>) objects treated as positional parameters:</p>
</div>
<div class="paragraph">
<p>为此，你无法引用键或使用变量作为键。这个调用实际上是两个被视为位置参数的Pair对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put add( &#39;a&#39; =&gt; 1,  &#39;b&#39; =&gt; 36 );     # Will not work!
put add( $keya =&gt; 1, $keyb =&gt; 36 );  # Will not work!</code></pre>
</div>
</div>
<div class="paragraph">
<p>More often you’ll use the adverb syntax. With values that are positive integers you can specify the value first and the name after it:</p>
</div>
<div class="paragraph">
<p>更常见的是，你将使用副词语法。对于正整数值，你可以先指定值，然后指定其后的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put add( :a(1), :b(36) );  # 37
put add( :36b, :1a );      # 37</code></pre>
</div>
</div>
<div class="paragraph">
<p>Default values and other constraints work the same as they do with positional parameters:</p>
</div>
<div class="paragraph">
<p>默认值和其他约束与位置参数的作用相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add ( Int:D :$a = 0, Int:D :$b = 0 ) {
    $a + $b;
    }

put add();       # 0
put add( :36b ); # 36</code></pre>
</div>
</div>
<div class="paragraph">
<p>You don’t have to use the same names for the arguments and the parameter variables. In complicated code in <code>power-of</code> you might not want to retype <code>$base</code> or <code>$power</code> every time. The subroutine still uses the long names for the interface but the implementation can use the short names:</p>
</div>
<div class="paragraph">
<p>你不必对参数和参数变量使用相同的名称。在功能复杂的代码中，你可能不希望每次都重新键入$ base或$ power。子例程仍然使用接口的长名称，但实现可以使用短名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub power-of ( Int:D :power($n) = 0, Int:D :base($a) ) {
    $a ** $n
    }

put power-of( base =&gt; 2, power =&gt; 5 ); # 32</code></pre>
</div>
</div>
<div class="paragraph">
<p>So far these named parameters have all taken values. Without any other constraints and no argument value, a named parameter is a Boolean. The adverb form with no value (and no constraint) gets <code>True</code> (because that’s what [<code>Pair</code>](<a href="https://docs.raku.org/type/Pair.html)s" class="bare">https://docs.raku.org/type/Pair.html)s</a> do):</p>
</div>
<div class="paragraph">
<p>到目前为止，这些命名参数都采用了值。没有任何其他约束和参数值，命名参数是布尔值。没有值（并且没有约束）的副词形式为True（因为这就是Pairs所做的）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub any-args ( :$state ) { say $state  }
any-args( :state );  #  True</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>!</code> in front of the adverb name makes it a <code>False</code> value:</p>
</div>
<div class="paragraph">
<p>一个 ！在副词名称前面使其成为一个假值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">any-args( :!state );  #  False</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_required_named_parameters">4.29.1. Required Named Parameters</h4>
<div class="paragraph">
<p>A positional parameter is required simply because it exists, and you have to mark it as optional to make it such. That’s reversed with named parameters, which are optional unless you say otherwise. The parameters get their default values if you don’t specify them:</p>
</div>
<div class="paragraph">
<p>仅需要位置参数因为它存在，并且你必须将其标记为可选，以使其成为可能。这与命名参数相反，除非你另有说明，否则这些参数是可选的。如果你不指定参数，参数将获得其默认值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub not-required ( :$option ) { say $option; }

not-required();            # (Any)
not-required( :option  );  # True
not-required( :!option );  # False
not-required( :5option );  # 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make <code>option</code> mandatory put a <code>!</code> after it in the signature (this is not the same as <code>!</code> before an argument):</p>
</div>
<div class="paragraph">
<p>要强制选择放一个！在签名之后（这与参数之前的！不一样）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub not-required ( :$option! ) { say $option; }

not-required();            # Error!</code></pre>
</div>
</div>
<div class="paragraph">
<p>The error tells you that you forgot an argument:</p>
</div>
<div class="paragraph">
<p>该错误告诉你忘记了一个参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Required named parameter &#39;option&#39; not passed</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_named_parameters_for_free">4.29.2. Named Parameters for Free</h4>
<div class="paragraph">
<p>Rather than define every named parameter, you can accept all of them. Don’t specify any in your parameters and they all show up in <code>%<em></em></code><em>. This is the equivalent of <code>@</code></em> but for named parameters. Each routine gets its own version of this variable:</p>
</div>
<div class="paragraph">
<p>你可以接受所有参数，而不是定义每个命名参数。不要在参数中指定任何参数，它们都显示在％_中。这相当于@_但是对于命名参数。每个例程都有自己的变量版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub any-args { say %_ }
any-args( genus =&gt; &#39;Hamadryas&#39; );
any-args( genus =&gt; &#39;Hamadryas&#39;, species =&gt; &#39;perlicus&#39; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>You didn’t define either <code>:genus</code> or <code>:species</code> but they show up in <code>%_</code>:</p>
</div>
<div class="paragraph">
<p>你没有定义：genus或：species但是它们出现在％_中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{genus =&gt; Hamadryas}
{genus =&gt; Hamadryas, species =&gt; perlicus}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A slurpy [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) does the same thing:</p>
</div>
<div class="paragraph">
<p>一个邋H的哈希做同样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub any-args ( *%args ) { say %args }
any-args( genus =&gt; &#39;Hamadryas&#39; );
any-args( genus =&gt; &#39;Hamadryas&#39;, species =&gt; &#39;perlicus&#39; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s how that implicit <code>%_</code> worked. When you use it in a subroutine you automatically get a slurpy for it in the signature:</p>
</div>
<div class="paragraph">
<p>这就是隐含的％_的工作方式。当你在子例程中使用它时，你会在签名中自动获取它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub any-args { say %_ }
sub any-args ( *%_ ) { say %_ }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mixed_parameters">4.29.3. Mixed Parameters</h4>
<div class="paragraph">
<p>You can mix positional and named parameters. If you use <code>@<em></em></code><em> and <code>%</code></em> in the code they are both in the implicit signature:</p>
</div>
<div class="paragraph">
<p>你可以混合位置和命名参数。如果在代码中使用@<em>和％</em>，则它们都在隐式签名中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub any-args {
    put &#39;@_ =&gt; &#39;, @_.gist;
    put &#39;%_ =&gt; &#39;, %_.gist;
    }

any-args( &#39;Hamadryas&#39;, 137, :status, :color(&#39;Purple&#39;) );

@_ =&gt; [Hamadryas 137]
%_ =&gt; {color =&gt; Purple, status =&gt; True}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can mix in the named parameters in any order that you like. The positional parameters have to be in the right order but named parameters can come between them:</p>
</div>
<div class="paragraph">
<p>你可以按你喜欢的任何顺序混合命名参数。位置参数必须是正确的顺序，但命名参数可以介于它们之间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">any-args( :color(&#39;Purple&#39;), &#39;Hamadryas&#39;, :status, 137  );</code></pre>
</div>
</div>
<div class="paragraph">
<p>It’s the same if you name the parameters yourself:</p>
</div>
<div class="paragraph">
<p>如果你自己命名参数，则相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub any-args ( *@args, *%named ) {
    put &#39;@args =&gt; &#39;, @args.gist;
    put &#39;%named =&gt; &#39;, %named.gist;
    }

any-args( :color(&#39;Purple&#39;), &#39;Hamadryas&#39;, :status, 137  );</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_return_types">4.30. Return Types</h3>
<div class="paragraph">
<p>You can constrain the return values of subroutines. If you try to return a value that doesn’t fit the restriction you get a runtime [<code>Exception</code>](<a href="https://docs.raku.org/type/Exception.html" class="bare">https://docs.raku.org/type/Exception.html</a>). Specify the type after the signature with a <code>-→</code>. You want this subroutine to return a defined [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>):</p>
</div>
<div class="paragraph">
<p>你可以约束子例程的返回值。如果你尝试返回不符合限制的值，则会获得运行时异常。使用 - &gt;指定签名后的类型。你希望此子例程返回已定义的Int：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub returns-an-int ( Int:D $a, Int:D $b --&gt; Int:D ) { $a + $b }

put returns-an-int( 1, 3 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>That works:</p>
</div>
<div class="paragraph">
<p>这样可行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">4</code></pre>
</div>
</div>
<div class="paragraph">
<p>But what if you make a mistake where you return a <code>Str</code>?</p>
</div>
<div class="paragraph">
<p>但是，如果你在返回Str时犯了错误怎么办？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub returns-an-int ( Int:D $a, Int:D $b --&gt; Int:D ) { ($a + $b).Str }

put returns-an-int( 1, 3 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>At runtime you get an error because the types do not match:</p>
</div>
<div class="paragraph">
<p>在运行时，你会收到错误，因为类型不匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Type check failed for return value; expected Int but got Str (&#34;4&#34;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>An alternate way is to note it with <code>returns</code> (with an <code>s</code> at the end) outside of the signature’s parentheses:</p>
</div>
<div class="paragraph">
<p>另一种方法是在签名的括号外面用返回（在末尾有一个s）注意它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub returns-an-int ( Int $a, Int $b ) returns Int { $a + $b }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You might also see these forms that do the same thing:</p>
</div>
<div class="paragraph">
<p>你可能还会看到这些表单执行相同的操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub returns-an-int ( Int $a, Int $b ) of Int { $a + $b }

my Int sub returns-an-int ( Int $a, Int $b ) { $a + $b }</code></pre>
</div>
</div>
<div class="paragraph">
<p>No matter which way you define the return type you can always return either <code>Nil</code> or a [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) object (usually to signal that something went wrong). All of these calls “succeed” even though some of them don’t return a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>):</p>
</div>
<div class="paragraph">
<p>无论你以何种方式定义返回类型，都可以始终返回Nil或Failure对象（通常表示出现问题）。所有这些调用都“成功”，即使其中一些不返回Str：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub does-not-work ( Int:D $a --&gt; Str ) {
    return Nil if $a == 37;
    fail &#39;Is not a fine number&#39; unless $a == 137;
    return &#39;Worked!&#39;
    }

put does-not-work(  37 ).^name;   # Nil
put does-not-work( 137 ).^name;   # Str
put does-not-work( 538 ).^name;   # Failure</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can’t make complex checks in the constraint, but you can define a subset that does these. Here’s one that returns either a [<code>Rat</code>](<a href="https://docs.raku.org/type/Rat.html" class="bare">https://docs.raku.org/type/Rat.html</a>) or, if you try to divide by zero, an <code>Inf</code>:</p>
</div>
<div class="paragraph">
<p>你不能在约束中进行复杂检查，但可以定义执行这些检查的子集。这里有一个返回Rat或者，如果你试图除以零，一个Inf：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset RatInf where Rat:D | Inf;

sub divide ( Int:D $a, Int:D $b --&gt; RatInf ) {
    return Inf if $b == 0;
    $a / $b;
    }

put divide( 1, 3 );  # &lt;1/3&gt;
put divide( 1, 0 );  # Inf</code></pre>
</div>
</div>
<div class="paragraph">
<p>That <code>Rat:D | Inf</code> is a [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>). You’ll see those in [Chapter 14](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch14.html#camelia-junctions" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch14.html#camelia-junctions</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_summary_5">4.31. Summary</h3>
<div class="paragraph">
<p>Much of the work of ensuring your program does the right things can be done with the judicious use of constraints on the inputs and outputs of subroutines. With a little planning these features will catch the cases that you did not expect and that shouldn’t show up in your program. Once they’ve been found you can work your way through the code to find them even sooner—and the sooner you find them, the easier your debugging life should be.</p>
</div>
<div class="paragraph">
<p>确保你的程序做正确的事情的大部分工作可以通过明智地使用子程序的输入和输出的约束来完成。通过一些计划，这些功能将捕获你不期望的并且不应该出现在你的程序中的情况。一旦找到它们，你就可以通过代码更快地找到它们 - 并且越早找到它们，你的调试生活就越容易。
== 类</p>
</div>
<div class="paragraph">
<p>A class is the blueprint for an object and manages an object and its behavior. It declares attributes to define what an object will store and <strong>methods</strong> to define how an object can behave. Classes model the world in a way that makes it easier for your program to do its job.</p>
</div>
<div class="paragraph">
<p>类是对象的蓝图，用于管理对象及其行为。它声明属性以定义对象将存储的内容以及定义对象行为方式的方法。类以一种使程序更容易完成其工作的方式对世界建模。</p>
</div>
<div class="paragraph">
<p>I’m mostly going to ignore object-oriented analysis and design. This chapter is about the mechanism of classes and objects. The examples show you how things work and do not endorse a particular way. Use what works for your task and stop using that when it doesn’t.</p>
</div>
<div class="paragraph">
<p>我大多会忽略面向对象的分析和设计。本章是关于类和对象的机制。这些例子向你展示了如何运作并且不支持某种特定方式。使用适用于你的任务的内容，并在不执行任务时停止使用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_your_first_class">4.32. Your First Class</h3>
<div class="paragraph">
<p>Declare a class by giving it a name and a [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) of code:</p>
</div>
<div class="paragraph">
<p>通过给出一个名称和一个代码块来声明一个类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s it! It looks like this class is empty, but it’s not. You get much of its basic behavior for free even though you don’t see it explicitly. Try calling some methods on it. You can see that it derives from [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>) and [<code>Mu</code>](<a href="https://docs.raku.org/type/Mu.html" class="bare">https://docs.raku.org/type/Mu.html</a>) and that you can create new objects:</p>
</div>
<div class="paragraph">
<p>而已！看起来这个类是空的，但事实并非如此。即使你没有明确地看到它，你也可以免费获得许多基本行为。尝试调用一些方法。你可以看到它派生自 [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>) 和 [<code>Mu</code>](<a href="https://docs.raku.org/type/Mu.html)，你可以创建新对象：" class="bare">https://docs.raku.org/type/Mu.html)，你可以创建新对象：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
&gt; class Butterfly {}
(Butterfly)
&gt; Butterfly.^mro
((Butterfly) (Any) (Mu))
&gt; my $object = Butterfly.new
Butterfly.new
&gt; $object.^name
Butterfly
&gt; $object.defined
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can have as many of these class declarations as you like in one file:</p>
</div>
<div class="paragraph">
<p>你可以在一个文件中包含任意数量的类声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {}
class Moth {}
class Lobster {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>These types are available to your program as soon as they are defined in the code, but not before. If you try to use one before you define it you get a compilation error:</p>
</div>
<div class="paragraph">
<p>只要在代码中定义了这些类型，就可以使用这些类型，但没定义之前不能使用。如果在定义类之前就尝试使用它，则会出现编译错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly = Butterfly.new;  # Too soon!

class Butterfly {};  # Error: Illegally post-declared type</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of defining all of your classes at the beginning of the file (and having to scroll past all of them to get to the good stuff), you’re more likely to want one class per file so you can easily find the class definition again. In that case you can use <code>unit</code> to declare that the entire file is your class definition. You don’t use a [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>):</p>
</div>
<div class="paragraph">
<p>而不是在文件的开头定义所有类（并且必须滚动浏览所有类以获得好的东西），你更可能每个文件都需要一个类，这样你就可以轻松地再次找到类定义。在这个例子中，你可以使用 <code>unit</code> 声明整个文件是你的类定义。你没使用[<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)：" class="bare">https://docs.raku.org/type/Block.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit class Butterfly;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Put your class in <strong>Butterfly.pm6</strong> (or <strong>Butterfly.pm</strong>) and load it from your program:</p>
</div>
<div class="paragraph">
<p>将你的类放在 Butterfly.pm6（或 Butterfly.pm）中并从你的程序中加载它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Butterfly;</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 12.1Create a single-file program that has the <code>Butterfly</code>, <code>Moth</code>, and <code>Lobster</code> empty class definitions. Create a new object for each, even though the objects don’t do anything interesting yet.</p>
</div>
<div class="paragraph">
<p>练习12.1创建一个具有 <code>Butterfly</code>，<code>Moth</code> 和 <code>Lobster</code> 的空类定义的单文件程序。为每个类创建一个新对象，即使对象没有做任何有趣的事情。</p>
</div>
<div class="paragraph">
<p>EXERCISE 12.2Define the <code>Butterfly</code>, <code>Moth</code>, and <code>Lobster</code> classes in separate files named after the classes they contain. The class files should be in the same directory as the program that loads them. Load those files in your program and create new objects for each.</p>
</div>
<div class="paragraph">
<p>练习12.2将 <code>Butterfly</code>，<code>Moth</code> 和 <code>Lobster</code> 类定义在以它们包含的类命名的单独文件中。类文件应与加载它们的程序位于同一目录中。在程序中加载这些文件并为每个文件创建新对象。</p>
</div>
</div>
<div class="sect2">
<h3 id="_定义方法">4.33. 定义方法</h3>
<div class="paragraph">
<p>Methods are like subroutines but know who called them and can be inherited; instead of <code>sub</code> you define these with <code>method</code>. This example uses it to output the type name:</p>
</div>
<div class="paragraph">
<p>方法就像子程序，但知道是谁调用它们并且可以继承;  你用 <code>method</code> 而不是 <code>sub</code> 来定义方法。此示例使用方法来输出类型名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    method who-am-i () { put &#34;I am a &#34; ~ self.^name }
    }

Butterfly.who-am-i;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That <code>self</code> term is the invocant of the method. That’s the object that called the method. It doesn’t need to be in the signature. It also doesn’t need to be in the method. Calling a method on <code>$</code> does the same thing (you’ll see why later):</p>
</div>
<div class="paragraph">
<p>那个 <code>self</code> 是该方法的调用者。这是调用方法的对象。它不需要在签名中。它也不需要在方法中。在 <code>$</code> 上调用方法会做同样的事情（稍后你会明白为什么）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    method who-am-i () { put &#34;I am a &#34; ~ $.^name }
    }

Butterfly.who-am-i;  # I am a Butterfly</code></pre>
</div>
</div>
<div class="paragraph">
<p>Give the invocant a different name by putting it before a colon in the signature. C++ people might like <code>$this</code>:</p>
</div>
<div class="paragraph">
<p>通过将调用者放在签名中的冒号前面，为调用者指定一个不同的名称。 C++ 人可能会喜欢 <code>$this</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method who-am-i ( $this : ) { put &#34;I am a &#34; ~ $this.^name }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A backslash makes the invocant name a term so you don’t need a sigil:</p>
</div>
<div class="paragraph">
<p>反斜杠使调用名称成为一个项，因此你不需要使用 sigil：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method who-am-i ( \this : ) { put &#34;I am a &#34; ~ this.^name; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default topic can be the invocant, which means that it’s implicit inside the [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>):</p>
</div>
<div class="paragraph">
<p>默认主题可以是调用者，这意味着它隐含在 [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method who-am-i ( $_ : ) { put &#34;I am a &#34; ~ .^name; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to change the invocant name, choose something that describes what it represents:</p>
</div>
<div class="paragraph">
<p>如果要更改调用者的名称，请选择描述其代表内容的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method who-am-i ( $butterfly : ) { ... }</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_私有方法">4.33.1. 私有方法</h4>
<div class="paragraph">
<p>A private method is available only inside the class where it’s defined. You use these to compartmentalize code that you don’t want code outside the class to know about.</p>
</div>
<div class="paragraph">
<p>私有方法仅在定义它的类中可用。你可以使用它们来划分你不希望类外部代码知道的代码。</p>
</div>
<div class="paragraph">
<p>Previously <code>who-am-i</code> directly called <code>.^name</code>. That’s a very specific way to figure out the “type.” You might want to change that later or use other methods to figure it out, and other methods in your class may need the same thing. Hide it in a method, <code>what’s-the-name</code>:</p>
</div>
<div class="paragraph">
<p>以前我是谁直接调用 <code>.^name</code>。这是一种非常具体的方法来确定“类型”。你可能希望稍后更改它或使用其他方法来解决它，并且你的类中的其他方法可能需要相同的东西。将其隐藏在一个方法中，<code>what’s-the-name</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    method who-am-i () { put &#34;I am a &#34; ~ self.what&#39;s-the-name }

    method what&#39;s-the-name () { self.^name }
    }

Butterfly.who-am-i;             # I am a Butterfly
put Butterfly.what&#39;s-the-name;  # Butterfly</code></pre>
</div>
</div>
<div class="paragraph">
<p>That works, but it’s now available as a method that you didn’t intend anyone to use outside of the class. Prefix the method name with a <code>!</code> to hide it from code outside the class. Replace the method call dot with a <code>!</code> too:</p>
</div>
<div class="paragraph">
<p>这起作用了，但它现在可以作为一种方法，你不打算任何人在类外使用。在方法的名字上加上前缀 <code>!</code> 以从类外的代码中隐藏它。也用 <code>!</code> 替换方法调用点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    method who-am-i () { put &#34;I am a &#34; ~ self!what&#39;s-the-name }

    method !what&#39;s-the-name () { self.^name }
    }

Butterfly.who-am-i;  # I am a Butterfly
put Butterfly.what&#39;s-the-name;  # Butterfly</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you get an error if you try to use it outside the class:</p>
</div>
<div class="paragraph">
<p>现在，如果你尝试在类外使用它，则会出现错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">No such method &#39;what&#39;s-the-name&#39; for invocant of type &#39;Butterfly&#39;.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_subroutines">4.33.2. Defining Subroutines</h4>
<div class="paragraph">
<p>A class can contain subroutines. Since subroutines are lexically scoped they are also invisible outside the class. A subroutine can do the same job as a private method. To make this work you need to pass the object as a subroutine argument:</p>
</div>
<div class="paragraph">
<p>类可以包含子例程。由于子程序是词法作用域的，因此它们在类外也是不可见的。子例程可以执行与私有方法相同的工作。要完成这项工作，你需要将该对象作为子例程参数传递：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    method who-am-i () { put &#34;I am a &#34; ~ what&#39;s-the-name( self ) }

    sub what&#39;s-the-name ($self) { $self.^name }
    }

Butterfly.who-am-i;  # I am a Butterfly</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_对象">4.34. 对象</h3>
<div class="paragraph">
<p>Objects are particular instances of a class; sometimes those terms are used interchangeably. Each object has its own variables and data, separate from all the others. Each object, however, still shares the behavior of the class.</p>
</div>
<div class="paragraph">
<p>对象是类的特定实例;有时这些术语可以互换使用。每个对象都有自己的变量和数据，与其他对象分开。但是，每个对象仍然共享该类的行为。</p>
</div>
<div class="paragraph">
<p>Start with the simplest class, as before. To create an object you need a constructor method. Any method that creates an object is a constructor. By default that is <code>.new</code>:</p>
</div>
<div class="paragraph">
<p>像以前一样，从最简单的类开始。要创建对象，你需要一个构造函数方法。创建对象的任何方法都是构造函数。默认情况下是 <code>.new</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {}

my $butterfly = Butterfly.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The object is a defined instance of the class (the type object is the undefined one). The <code>.DEFINITE</code> method tells you which one you have:</p>
</div>
<div class="paragraph">
<p>该对象是类的已定义实例（类型对象是未定义的对象）。 <code>.DEFINITE</code> 方法告诉你用的是哪一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put $butterfly.DEFINITE
    ?? &#39;I have an object&#39; !! &#39;I have a type&#39;;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Every object also has a <code>.defined</code> method, but each class can change what that means. Any object of the [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) class is undefined, so it’s always <code>False</code> as a conditional. Use <code>.DEFINITE</code> to avoid that gotcha.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>每个对象也有一个 <code>.defined</code> 方法，但每个类都可以改变它的含义。 [<code>Failure</code>](<a href="https://docs.raku.org/type/Failure.html" class="bare">https://docs.raku.org/type/Failure.html</a>) 类的任何对象都是未定义的，因此它作为条件总是 <code>False</code>。使用 <code>.DEFINITE</code> 来避免这种问题。</p>
</div>
<div class="sect3">
<h4 id="_私有属性">4.34.1. 私有属性</h4>
<div class="paragraph">
<p>Attributes are per-object data. You declare these with <code>has</code>. The attribute variables use a twigil to denote their access. Before you see the easy way you should see the hard way so you appreciate it more. The <code>$!</code> twigil defines a private attribute:</p>
</div>
<div class="paragraph">
<p>属性是每个对象都具有的数据。你用 <code>has</code> 声明属性。属性变量使用 twigil 来表示它们的访问权限。在你看到简单的方法之前，你应该看到困难的方式让你更加欣赏它。 <code>$!</code> twigil 定义一个私有属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has $!common-name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By itself this <code>has</code> definition doesn’t effectively add anything to your class. Nothing can see the attribute, so you have no way to change its value.</p>
</div>
<div class="paragraph">
<p>这个 <code>has</code> 定义本身并没有有效地为你的类添加任何东西。什么都看不到属性，所以你无法改变它的值。</p>
</div>
<div class="paragraph">
<p>The special <code>.BUILD</code> method is automatically called after <code>.new</code> with the same arguments. You can define your own <code>.BUILD</code> to bind or assign a value to your private attribute (or do any other work that you want):</p>
</div>
<div class="paragraph">
<p>使用相同的参数在 <code>.new</code> 之后自动调用特殊的 <code>.BUILD</code> 方法。你可以定义自己的 <code>.BUILD</code> 来绑定值到你的私有属性上或为你的私有属性赋值（或者执行你想要的任何其他工作）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has $!common-name;

    method BUILD ( :$common-name ) {
        $!common-name = $common-name;
    }
}

my $butterfly = Butterfly.new: :common-name(&#39;Perly Cracker&#39;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Be careful here. This <code>.BUILD</code> accepts all named parameters without warning. It doesn’t know which ones you intend to use or what they mean to your class. It’s a default way that almost everything uses to set up objects—but if you misspell a name, you won’t get a warning:</p>
</div>
<div class="paragraph">
<p>这里要小心。此 <code>.BUILD</code> 接受所有命名参数而不发出警告。它不知道你打算使用哪些或它们对你的类意味着什么。这是几乎所有东西都用来设置对象的默认方式 - 但是如果你拼错了名字，你不会收到警告：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly = Butterfly.new: :commen-name(&#39;Perly Cracker&#39;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You also don’t get a warning for leaving something out. Maybe you don’t want to require every setting any time you build an object. You might not want this to fail:</p>
</div>
<div class="paragraph">
<p>你也不会因为遗漏某些属性而得到警告。也许你不希望每次构建对象时就设置好所有的东西。你可能不希望这失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly = Butterfly.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>But if you want to require a named parameter you know how to do that. Put a <code>!</code> after it:</p>
</div>
<div class="paragraph">
<p>但是如果你想要一个命名参数，你知道如何做到这一点。在命名参数后面放一个 <code>!</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has $!common-name;

    method BUILD ( :$common-name! ) { # required now
        $!common-name = $common-name;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the rest of this example that’s not what you want. You’re going to set default values and provide other ways to change the name.</p>
</div>
<div class="paragraph">
<p>对于本示例的其余部分，这不是你想要的。你将设置默认值并提供更改名称的其他方法。</p>
</div>
<div class="paragraph">
<p>You can add an accessor method to allow you to see the name that you’ve stored in the private attribute:</p>
</div>
<div class="paragraph">
<p>你可以添加一个访问器方法，以允许你查看已存储在私有属性中的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has $!common-name;

    method BUILD ( :$common-name ) {
        $!common-name = $common-name;
    }

    method common-name { $!common-name }
}

my $butterfly = Butterfly.new: :common-name(&#39;Perly Cracker&#39;);
put $butterfly.common-name;  # Perly Cracker</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a problem if you don’t supply a <code>:common-name</code>. There’s nothing in <code>$!common-name</code> and you didn’t give <code>.BUILD</code> anything to work with. When you try to output it you get a warning about the empty value:</p>
</div>
<div class="paragraph">
<p>如果你不提供 <code>:common-name</code>，则会出现问题。 <code>$!common-name</code> 中没有任何东西，你没有给 <code>.BUILD</code> 任何东西。当你尝试输出它时，你会收到有关空值的警告：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly = Butterfly.new;
put $butterfly.common-name;  # Warning!</code></pre>
</div>
</div>
<div class="paragraph">
<p>A default value in the <code>common-name</code> method could solve this. If the attribute is not defined you could return an empty [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) (or <code>fail</code> or <code>warn</code>):</p>
</div>
<div class="paragraph">
<p><code>common-name</code> 方法中的默认值可以解决此问题。如果未定义属性，则可以返回空[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)（或" class="bare">https://docs.raku.org/type/Str.html)（或</a> <code>fail</code> 或 <code>warn</code>）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method common-name { $!common-name // &#39;&#39; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>属性可以具有默认值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has $!common-name = &#39;&#39;;
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使属性的默认值更有趣而不是使用空的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)：" class="bare">https://docs.raku.org/type/Str.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has $!common-name = &#39;Unnamed Butterfly&#39;;
    ...
}

my $butterfly = Butterfly.new;
put $butterfly.common-name;  # Unnamed Butterfly!</code></pre>
</div>
</div>
<div class="paragraph">
<p>要更改 <code>$!common-name</code> 的值，你可以使用 <code>rw</code> trait 标记 <code>.common-name</code> 以使其可读可写。如果你为方法赋值，则更改[<code>块</code>](<a href="https://docs.raku.org/type/Block.html)中最后一个东西的值（如果你可以修改它，那就是）。这个"><code>块</code></a>(<a href="https://docs.raku.org/type/Block.html)中的最后一个东西是一个" class="bare">https://docs.raku.org/type/Block.html)中的最后一个东西是一个</a> <code>$!common-name</code> 容器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has $!common-name = &#39;Unnamed butterfly&#39;;

    method BUILD ( :$common-name ) {
        $!common-name = $common-name;
    }

    method common-name is rw { $!common-name }
}

my $butterfly = Butterfly.new;
$butterfly.common-name = &#39;Perly Cracker&#39;;

put $butterfly.common-name;  # Perly Cracker!</code></pre>
</div>
</div>
<div class="paragraph">
<p>The attributes can be typed like other variables. Constraining the type to [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) means you can assign only thattype to <code>.common-name</code>:</p>
</div>
<div class="paragraph">
<p>可以像其他变量一样类型化。将类型约束为[<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)意味着你只能将字符串类型赋值给" class="bare">https://docs.raku.org/type/Str.html)意味着你只能将字符串类型赋值给</a> <code>.common-name</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has Str $!common-name = &#39;Unnamed butterfly&#39;;
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>练习12.3 实现一个带有 <code>$!common-name</code> 私有属性的 <code>Butterfly</code> 类。添加 <code>$!color</code> 私有属性。创建一个新的 <code>Butterfly</code> 对象，设置其名称和颜色，然后输出这些值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_public_attributes">4.34.2. Public Attributes</h4>
<div class="paragraph">
<p>But enough of the hard way. Public attributes do a lot of that work for you. Use <code>$.common-name</code> with a dot instead of a bang (<code>!</code>). The accessor method is automatically defined for you and the default <code>.BUILD</code> handles the setup by filling in the attributes from the named parameters in your call to <code>.new</code>:</p>
</div>
<div class="paragraph">
<p>但足够艰难的方式。公共属性为你做了很多工作。使用带点的 <code>$.common-name</code> 而不是 <code>!</code> 。<code>.</code> 将自动为你定义存取方法，默认的 <code>.BUILD</code> 通过在你对 <code>.new</code> 的调用中填充命名参数的属性来处理设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has $.common-name = &#39;Unnamed Butterfly&#39;
}

my $butterfly = Butterfly.new: :common-name(&#39;Perly Cracker&#39;);
put $butterfly.common-name;  # Perly Cracker</code></pre>
</div>
</div>
<div class="paragraph">
<p>Make it read-write with the <code>rw</code> trait immediately after the attribute name but before the default value. After you create the object you can assign to the <code>.common-name</code> method:</p>
</div>
<div class="paragraph">
<p>在属性名称之后但在默认值之前立即使用 <code>rw</code>  trait 进行读写。创建对象后，可以给 <code>.common-name</code> 方法赋值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has $.common-name is rw = &#39;An unknown butterfly&#39;;
}

my $butterfly = Butterfly.new;
put $butterfly.common-name; # An unknown butterfly

$butterfly.common-name = &#39;Hamadryas perlicus&#39;;
put $butterfly.common-name; # Hamadryas perlicus</code></pre>
</div>
</div>
<div class="paragraph">
<p>The attributes can have types just like other variables. Try to assign the wrong type and you get an exception:</p>
</div>
<div class="paragraph">
<p>属性可以像其他变量一样具有类型。如果尝试分配错误的类型，你会得到一个异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has Str $.common-name is rw = &#39;Unnamed butterfly&#39;;
    }

my $butterfly = Butterfly.new;
$butterfly.common-name = 137;  # Error!</code></pre>
</div>
</div>
<div class="paragraph">
<p>To have a mixture of private and public attributes you have to do some work. You probably don’t want to define your own <code>.BUILD</code> since you’d have to handle everything that the default one does for you. Instead, you can define a private attribute and assign to it later through a method. An <code>rw</code> trait on the method either returns or assigns to the value of the last thingy in the [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>):</p>
</div>
<div class="paragraph">
<p>要拥有私有属性和公共属性的混合，你必须费点劲。你可能不想定义自己的 <code>.BUILD</code>，因为你必须处理默认的一切。相反，你可以定义私有属性，稍后通过方法为其赋值。方法上的 <code>rw</code> 特质要么返回[<code>块</code>](<a href="https://docs.raku.org/type/Block.html)中的最后那个东西，要么给"><code>块</code></a>(<a href="https://docs.raku.org/type/Block.html)中最后一个东西赋值：" class="bare">https://docs.raku.org/type/Block.html)中最后一个东西赋值：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has Str $.common-name is rw = &#39;Unnamed butterfly&#39;;
    has Str $!color;

    method color is rw { $!color }
}

my $butterfly = Butterfly.new;
$butterfly.common-name = &#39;Perly Cracker&#39;;
$butterfly.color = &#39;Vermillion&#39;;

put &#34;{.common-name} is {.color}&#34; with $butterfly;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multi_methods">4.35. multi Methods</h3>
<div class="paragraph">
<p>Read-write methods are one way to handle private attributes, but you can also create <code>multi</code> methods for each case. Although this example looks simple, your validation and conversion requirements can be arbitrarily complex inside the [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)s" class="bare">https://docs.raku.org/type/Block.html)s</a>:</p>
</div>
<div class="paragraph">
<p>读写方法是处理私有属性的一种方法，但你也可以为每种情况创建 <code>multi</code> 方法。虽然这个例子看起来很简单，但是你的验证和转换要求在[<code>块</code>](<a href="https://docs.raku.org/type/Block.html)中可以是任意复杂的：" class="bare">https://docs.raku.org/type/Block.html)中可以是任意复杂的：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has $!common-name = &#39;Unnamed butterfly&#39;;
    has $!color       = &#39;White&#39;;

    multi method common-name ()         { $!common-name }
    multi method common-name ( Str $s ) { $!common-name = $s }

    multi method color ()         { $!color }
    multi method color ( Str $s ) { $!color = $s }
}

my $butterfly = Butterfly.new;
$butterfly.common-name: &#39;Perly Cracker&#39;;
$butterfly.color: &#39;Vermillion&#39;;

put $butterfly.common-name;  # Perly Cracker!</code></pre>
</div>
</div>
<div class="paragraph">
<p>This gets annoying when you have many attributes. There’s another way that you could do this. Return the object in every method that sets a value. This allows you to chain methods to set many attributes in one statement where you don’t repeat the object each time:</p>
</div>
<div class="paragraph">
<p>当你有许多属性时，这会很烦人。还有另一种方法可以做到这一点。在每个设置值的方法中返回对象。这允许你链接方法以在一个语句中设置许多属性，每次不重复对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has $!common-name = &#39;Unnamed butterfly&#39;;
    has $!color       = &#39;White&#39;;

    multi method common-name ()         { $!common-name; }
    multi method common-name ( Str $s ) {
        $!common-name = $s; self
    }

    multi method color ()         { $!color; }
    multi method color ( Str $s ) { $!color = $s; self }
}

my $butterfly = Butterfly
    .new
    .common-name( &#39;Perly Cracker&#39; )
    .color( &#39;Vermillion&#39; );

put &#34;{.common-name} is {.color}&#34; with $butterfly;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That looks similar to using <code>do given</code> to <strong>topicalize</strong> the object and call methods on it:</p>
</div>
<div class="paragraph">
<p>这类似于使用 <code>do given</code> 来主题化对象并在其上调用方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly = do given Butterfly.new {
    .common-name( &#39;Perly Cracker&#39; );
    .color( &#39;Vermillion&#39; );
    };

put &#34;{.common-name} is {.color}&#34; with $butterfly;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which technique you use depends on your task and personal preferences. You haven’t seen this with error handling or complex code, either. Those impact your choice too.</p>
</div>
<div class="paragraph">
<p>你使用哪种技术取决于你的任务和个人喜好。你还没有看到错误处理或复杂代码。那些也会影响你的选择。</p>
</div>
</div>
<div class="sect2">
<h3 id="_inheriting_types">4.36. Inheriting Types</h3>
<div class="paragraph">
<p>An existing type might already do most of what you want. Instead of redefining everything that class already does, you can extend it, also known as inheriting from it. Declare the class with <code>is</code> and the type you want to extend:</p>
</div>
<div class="paragraph">
<p>现有类型可能已经完成了你想要的大部分工作。你可以扩展它，而不是重新定义类已经执行的所有操作，也称为继承它。使用 <code>is</code> 和要扩展的类型声明类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly is Insect {};</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can do this inside the class definition with <code>also</code>:</p>
</div>
<div class="paragraph">
<p>你也可以在类定义中使用 <code>also</code> 执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    also is Insect
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, <code>Insect</code> is a parent class (or super class or base class). <code>Butterfly</code> is the child class (or derived type). The terminology isn’t particularly important; the base type is the more general one and the derived type is the more specific one.</p>
</div>
<div class="paragraph">
<p>在这里，<code>Insect</code> 是一个父类（或超类或基类）。 <code>Butterfly</code> 是子类（或派生类型）。术语不是特别重要;基类型是更通用的类型，派生类型是更具体的类型。</p>
</div>
<div class="paragraph">
<p>Everything you’ve seen in the <code>Butterfly</code> class so far (a name and a color) applies to any insect. The name and color attributes are general things that describe any insect, so should be in the more general class. The`Butterfly` class now has nothing in it (a “null subclass”), but it should still work the same as it did before:</p>
</div>
<div class="paragraph">
<p>到目前为止，你在 <code>Butterfly</code> 上看到的所有东西（名称和颜色）都适用于任何昆虫。名称和颜色属性是描述任何昆虫的通用的东西，因此应该在更通用的类中。 <code>Butterfly</code> 类现在没有任何内容（“null子类”），但它应该仍然像以前一样工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Insect {
    has $.common-name is rw = &#39;Unnamed insect&#39;;
    has $.color       is rw = &#39;Brown&#39;;
}

class Butterfly is Insect {}

my $butterfly = Butterfly.new;
$butterfly.common-name = &#39;Perly Cracker&#39;;
$butterfly.color = &#39;Vermillion&#39;;

put &#34;{.common-name} is {.color}&#34; with $butterfly;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Butterfly</code> can have its own <code>$.color</code> that overrides the one from <code>Insect</code>. Declaring the attribute in`Butterfly` effectively hides the one in its parent class:</p>
</div>
<div class="paragraph">
<p><code>Butterfly`可以有自己的 `$.color</code> 来覆盖 <code>Insect</code> 的那个属性。在 <code>Butterfly</code> 中声明属性有效地隐藏了其父类中的属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Insect {
    has $.common-name is rw = &#39;Unnamed insect&#39;;
    has $.color       is rw = &#39;Brown&#39;;
}

class Butterfly is Insect {
    has $.color       is rw = &#39;Mauve&#39;;
}

my $butterfly = Butterfly.new;
$butterfly.common-name = &#39;Perly Cracker&#39;;

# Perly Cracker is Mauve
put &#34;{.common-name} is {.color}&#34; with $butterfly;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes that’s not the right thing to do. The parent class might need to run some code in its version of the method to make everything else work. Instead of hiding the parent method you want to <strong>wrap</strong> it (or extend it).</p>
</div>
<div class="paragraph">
<p>有时这不是正确的事情。父类可能需要在其方法版本中运行一些代码才能使其他所有东西都有效。你想要包装它（或扩展它）的父方法而不是隐藏父方法。</p>
</div>
<div class="paragraph">
<p>The <code>callsame</code> routine can do this for you. It redispatches the call with the same arguments. You run the parent method in your child method:</p>
</div>
<div class="paragraph">
<p><code>callsame</code> 程序可以为你执行此操作。它使用相同的参数重新调度调用。你在子方法中运行父方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Insect {
    has $.common-name is rw = &#39;Unnamed insect&#39;;
    has $!color = &#39;Brown&#39;;

    method color is rw {
        put &#34;In Insect.color!&#34;;
        $!color
    }
}

class Butterfly is Insect {
    has $!color = &#39;Mauve&#39;;

    method color is rw {
        put &#34;In Butterfly.color!&#34;;
        my $insect-color = callsame;
        put &#34;Insect color was {$insect-color}!&#34;;
        $!color
    }
}

my $butterfly = Butterfly.new;
$butterfly.common-name = &#39;Perly Cracker&#39;;

put &#34;{.common-name} is {.color}&#34; with $butterfly;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inheritance isn’t the only way to add features to your class. You should save inheritance for specific cases where your class is a more specific type of the same thingy.</p>
</div>
<div class="paragraph">
<p>继承不是向类添加功能的唯一方法。对于特定情况，你应该保存继承，其中你的类是更具体的类型。</p>
</div>
<div class="paragraph">
<p>EXERCISE 12.4Create classes for the kingdom, phylum, class, order, family, and genus of a <strong>Hamadryas</strong> butterfly. The phylum inherits from kindgom, the class inherits from phylum, and so on. Each class notes its place in the hierarchy:`class Nymphalidae is Lepidoptera { }`Define a <code>.full-name</code> method in <code>Hamadryas</code> to join all the levels together.The genus <strong>Hamadryas</strong> is classified in <strong>Animalia</strong>, <strong>Arthropodia</strong>, <strong>Insecta</strong>, <strong>Lepidoptera</strong>, and <strong>Nymphalidae</strong>.</p>
</div>
<div class="paragraph">
<p>练习12.4 为Hamadryas 蝴蝶的王国，门，阶级，秩序，家庭和属创建类。门继承自 kindgom，该类继承自门，等等。每个班级都记录了它在层次结构中的位置： <code>class Nymphalidae is Lepidoptera { }</code> 在 <code>Hamadryas</code> 中定义一个完整的名称方法以将所有级别连接在一起.Hamadryas属被分类为Animalia，Arthropodia，Insecta，Lepidoptera和Nymphalidae。</p>
</div>
<div class="sect3">
<h4 id="_checking_inheritance">4.36.1. Checking Inheritance</h4>
<div class="paragraph">
<p>You’ve already seen <code>.^mro</code> to get a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) of classes. The <code>.isa</code> method returns <code>True</code> or <code>False</code> if the type you specify is in that [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>). You can test a type or an object with a type object as the argument (a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)" class="bare">https://docs.raku.org/type/Str.html)</a>):</p>
</div>
<div class="paragraph">
<p>你已经看过 <code>.^mro</code> 获得一个类[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)。如果你指定的类型在该"><code>列表</code></a>(<a href="https://docs.raku.org/type/List.html)中，则" class="bare">https://docs.raku.org/type/List.html)中，则</a> <code>.isa</code> 方法返回 <code>True</code> 或 <code>False</code>。你可以使用类型对象作为参数（[<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)）来测试类型或对象：" class="bare">https://docs.raku.org/type/Str.html)）来测试类型或对象：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put Int.isa: &#39;Cool&#39;;        # True
put Int.isa: Cool;          # True

put Butterfly.isa: Insect;  # True;
put Butterfly.isa: Int      # False;

my $butterfly-object = Butterfly.new;
put $butterfly.isa: Insect; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>Smart matching does the same job. That’s what <code>when</code> is checking if you give it only a type:</p>
</div>
<div class="paragraph">
<p>智能匹配可以完成同样的工作。这就是 <code>when</code> 检查你是否只给它一个类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if Butterfly ~~ Insect {
    put &#34;Butterfly is an Insect&#34;;
}

if $butterfly ~~ Insect {
    put &#34;Butterfly is an Insect&#34;;
}

put do given $butterfly {
    when Int    { &#34;It&#39;s a integer&#34; }
    when Insect { &#34;It&#39;s an insect&#34; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may have been wondering about the name of the <code>.^mro</code> method. That’s for method resolution order in cases where you inherit from multiple classes:</p>
</div>
<div class="paragraph">
<p>你可能一直想知道 <code>.^mro</code> 方法的名称。这是在你从多个类继承的情况下的方法解析顺序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly is Insect is Flier {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>I’m not going to tell you more about multiple inheritance in the hopes that you never do it. It’s possible, but you’ll likely solve your problem with the roles you’ll see in [Chapter 13](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch13.html#camelia-roles" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch13.html#camelia-roles</a>).</p>
</div>
<div class="paragraph">
<p>我不会告诉你更多关于多重继承的信息，希望你永远不会这样做。这是可能的，但你可能会用你在第13章中看到的角色来解决你的问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="_stub_methods">4.36.2. Stub Methods</h4>
<div class="paragraph">
<p>A parent class can define a method but not implement it—this is known as an abstract method (or stub method). Use <code>!!!</code> inside the [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) to denote that something later will implement a method with that name:</p>
</div>
<div class="paragraph">
<p>父类可以定义一个方法但不实现它 - 这称为抽象方法（或存根方法）。在[<code>块</code>](<a href="https://docs.raku.org/type/Block.html)中使用" class="bare">https://docs.raku.org/type/Block.html)中使用</a>  <code>!!!</code> 表示稍后会实现具有该名称的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Insect {
    has $.color is rw = &#39;Brown&#39;;

    method common-name { !!! }
}

class Butterfly is Insect {
    has $.color is rw = &#39;Mauve&#39;;
}

my $butterfly = Butterfly.new;
$butterfly.common-name = &#39;Perly Cracker&#39;;

put &#34;{.common-name} is {.color}&#34; with $butterfly;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you run this the <code>!!!</code> throws an exception:</p>
</div>
<div class="paragraph">
<p>当你运行这个代码时 <code>!!!</code> 抛出异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Stub code executed</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of the <code>!!!</code> you can use <code>…​</code>. The triple dot calls <code>fail</code> instead of <code>die</code>. Either way something else needs to implement that method. A public attribute would do that for you:</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>…​</code> 而不是 <code>!!!</code>。三点调用 <code>fail</code> 而不是 <code>die</code>。无论哪种方式，其他东西都需要实现该方法。公共属性会为你执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly is Insect {
    has $.common-name is rw;
    has $.color       is rw = &#39;Mauve&#39;;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_controlling_object_creation">4.37. Controlling Object Creation</h3>
<div class="paragraph">
<p>Sometimes you want more control over your object creation. When you call <code>.new</code> there are several steps and you’re able to hook into each of them. You don’t need all the gory details at the programmer level so I’ll spare you.</p>
</div>
<div class="paragraph">
<p>有时你希望更好地控制对象创建。当你调用 <code>.new</code> 时，有几个步骤，你可以接入每个步骤。你不需要程序员级别的所有残酷细节，所以我会饶了你。</p>
</div>
<div class="paragraph">
<p>When you call <code>.new</code> you’re reaching into the root of the object system, [<code>Mu</code>](<a href="https://docs.raku.org/type/Mu.html" class="bare">https://docs.raku.org/type/Mu.html</a>). <code>.new</code> calls <code>.bless</code>, which actually creates your object. Now you have an empty object. It’s not quite ready for use yet.</p>
</div>
<div class="paragraph">
<p>当你调用 <code>.new</code> 时，你正在进入对象系统的根，即 <code>Mu</code>。 <code>.new</code> 调用 <code>.bless</code>，它实际上创建了你的对象。现在你有一个空对象。它尚未准备好使用。</p>
</div>
<div class="paragraph">
<p><code>.bless</code> does some more work by calling <code>.BUILDALL</code> on your empty object, passing it all the same arguments that you passed to <code>.new</code>. <code>.BUILDALL</code> visits each class in your inheritance chain, starting with [<code>Mu</code>](<a href="https://docs.raku.org/type/Mu.html" class="bare">https://docs.raku.org/type/Mu.html</a>). You typically don’t want to mess with <code>.BUILDALL</code> since it’s driving the process rather than affecting your objects.</p>
</div>
<div class="paragraph">
<p><code>.bless</code> 通过在空对象上调用 <code>.BUILDALL</code> 来做更多工作，并将所有传递给 <code>.new</code> 的相同参数传递给它。 <code>.BUILDALL</code> 访问继承链中的每个类，从 [<code>Mu</code>](<a href="https://docs.raku.org/type/Mu.html" class="bare">https://docs.raku.org/type/Mu.html</a>) 开始。你通常不希望混淆 <code>.BUILDALL</code>，因为它正在推动流程而不是影响你的对象。</p>
</div>
<div class="paragraph">
<p><code>.BUILDALL</code> calls the <code>.BUILD</code> method in your class if you’ve defined one. <code>.BUILD</code> gets the same arguments as <code>.new</code>. This is how your attributes get their values from your arguments. If no class defined a <code>.BUILD</code> you get the default one that fills in your attributes from the named parameters.</p>
</div>
<div class="paragraph">
<p>如果你定义了一个，则 <code>.BUILDALL</code> 会在你的类中调用 <code>.BUILD</code> 方法。 <code>.BUILD</code> 获得与 <code>.new</code> 相同的参数。这是你的属性从参数中获取其值的方式。如果没有类定义 <code>.BUILD</code>，你将获得从命名参数填充属性的默认类。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The default object creation mechanism wants to work with named parameters. You could rework everything for positional parameters but that would be a lot of work.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认对象创建机制希望使用命名参数。你可以为位置参数重做一切，但这将是很多工作。</p>
</div>
<div class="paragraph">
<p>After <code>.BUILD</code> is done you have a completely built object that’s ready for use (but not the final object yet). The <code>.TWEAK</code> method gives you a chance to adjust that object before you move on to the next class to go through the process again.</p>
</div>
<div class="paragraph">
<p>在 <code>.BUILD</code> 完成后，你有一个完全构建的对象可以使用（但还没有最终的对象）。 <code>.TWEAK</code> 方法让你有机会调整该对象，然后再转到下一个类再次完成该过程。</p>
</div>
<div class="paragraph">
<p>You should declare both <code>.BUILD</code> and <code>.TWEAK</code> with <code>submethod</code>. This is a hybrid of <code>sub</code> and <code>method</code>; it acts just like a method but a subclass doesn’t inherit it (just like you don’t inherit subroutines):</p>
</div>
<div class="paragraph">
<p>你应该用 <code>submethod</code> 声明 <code>.BUILD</code> 和 <code>.TWEAK</code>。这是 <code>sub</code> 和 <code>method</code> 的混合;它就像一个方法，但是一个子类不会继承它（就像你不继承子程序一样）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># $?CLASS is a compile-time variable for the current class
# &amp;?ROUTINE is a compile-time variable for the current routine
class Insect {
    submethod BUILD { put &#34;In {$?CLASS.^name}.{&amp;?ROUTINE.name}&#34; }
    submethod TWEAK { put &#34;In {$?CLASS.^name}.{&amp;?ROUTINE.name}&#34; }
    }

class Butterfly is Insect {
    submethod BUILD { put &#34;In {$?CLASS.^name}.{&amp;?ROUTINE.name}&#34; }
    submethod TWEAK { put &#34;In {$?CLASS.^name}.{&amp;?ROUTINE.name}&#34; }
    }

my $b = Butterfly.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.TWEAK</code> method is called before <code>.BUILDALL</code> moves on to the next class:</p>
</div>
<div class="paragraph">
<p>在 <code>.BUILDALL</code> 之前调用 <code>.TWEAK</code> 方法进入下一个类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">In Insect.BUILD
In Insect.TWEAK
In Butterfly.BUILD
In Butterfly.TWEAK</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that you’ve seen the order in which things happen, let’s look at each step a little more closely.</p>
</div>
<div class="paragraph">
<p>现在你已经看到了事情发生的顺序，让我们更仔细地看一下每一步。</p>
</div>
<div class="sect3">
<h4 id="_building_objects">4.37.1. Building Objects</h4>
<div class="paragraph">
<p><code>.BUILD</code> lets you decide how to treat your newly created object. Start with a <code>submethod</code> that does nothing:</p>
</div>
<div class="paragraph">
<p><code>.BUILD`让你决定如何对待新创建的对象。从一个什么都不做的 `submethod</code> 开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has $.color;
    has $.common-name;

    submethod BUILD {} # does nothing
}

my $butterfly = Butterfly.new: :color(&#39;Magenta&#39;);

put &#34;The butterfly is the color {$butterfly.color}&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The color isn’t set and you get a warning about an uninitialized value:</p>
</div>
<div class="paragraph">
<p>颜色未设置，你会收到有关未初始化值的警告：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">The butterfly is the color
Use of uninitialized value of type Any in string context.</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.BUILDALL</code> found your <code>.BUILD</code> so it used your version to set up the object. The color value in your call to <code>.new</code> isn’t assigned to the <code>$!color</code> attribute because your empty <code>.BUILD</code> didn’t handle that. You need to do that yourself. By default all the named parameters are in <code>%_</code> and <code>.BUILD</code> gets all of the same arguments as`.new`:</p>
</div>
<div class="paragraph">
<p><code>.BUILDALL</code> 找到你的 <code>.BUILD</code> 所以它用你的版本来设置对象。调用 <code>.new</code> 的颜色值未分配给 <code>$!color</code> 属性，因为空的 <code>.BUILD</code> 没有处理它。你需要自己做。默认情况下，所有命名参数都在 <code>％_</code> 和 <code>.BUILD</code> 中获取所有相同的参数作为 <code>.new</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has $.color;
    has $.common-name;

    submethod BUILD {
        $!color = %_&lt;color&gt;;
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use the argument list for <code>.BUILD</code> to automatically define some named parameters to variables:</p>
</div>
<div class="paragraph">
<p>使用 <code>.BUILD</code> 的参数列表自动为变量定义一些命名参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
has $.color;
has $.common-name;

submethod BUILD ( :$color ) {
    $!color = $color;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don’t specify a <code>color</code> named argument you get another warning because the value in <code>$color</code> is uninitialized. In some cases you might want that named parameter to be required, so you put a <code>!</code> after it:</p>
</div>
<div class="paragraph">
<p>如果未指定 <code>color</code> 命名参数，则会收到另一个警告，因为 <code>$color</code> 中的值未初始化。在某些情况下，你可能希望该命名参数是必需的，所以你放一个 <code>!</code> 之后：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has $.color;
    has $.common-name;

    submethod BUILD ( :$color! ) {
        $!color = $color;
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Other times you might want to set a default value. Another attribute won’t work because the object build process hasn’t set its default value yet:</p>
</div>
<div class="paragraph">
<p>其他时候你可能想要设置默认值。另一个属性不起作用，因为对象构建过程尚未设置其默认值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    has $!default-color = &#39;Wine&#39;; # Won&#39;t work
    has $.color;
    has $.common-name;

    submethod BUILD ( :$color! ) {
        $!color = $color // $!default-color; # No setup yet!
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A private method could work; a private method can only be seen from code inside the class and cannot be inherited. A <code>submethod</code> isn’t inheritable either but is still a public method:</p>
</div>
<div class="paragraph">
<p>私有方法可以工作;私有方法只能从类中的代码中看到，不能被继承。<code>submethod</code> 也不是可继承的，但仍然是一种公共方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    method default-color { &#39;Wine&#39; }
    has $.color;
    has $.common-name;

    submethod BUILD ( :$color ) {
        $!color = $color // self.default-color;
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Class variables can do the same job. A lexical variable defined in the class [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) is only visible to the code in the same [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) and the [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)s" class="bare">https://docs.raku.org/type/Block.html)s</a> inside it:</p>
</div>
<div class="paragraph">
<p>类变量可以完成相同的工作。类[<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)中定义的词法变量仅对同一块中的代码及其中的块可见：" class="bare">https://docs.raku.org/type/Block.html)中定义的词法变量仅对同一块中的代码及其中的块可见：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    my $default-color = &#39;Wine&#39;;
    has $.color;
    has $.common-name;

    submethod BUILD ( :$color ) {
        $!color = $color // $default-color;
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>What’s more interesting to <code>.BUILD</code> is the extra setup you don’t want to be part of the interface. Perhaps you want to track when you used the default value so you can distinguish it from the case where the specified color happened to be the same:</p>
</div>
<div class="paragraph">
<p>更有趣的是 <code>.BUILD</code> 是你不希望成为界面一部分的额外设置。你可能希望跟踪何时使用默认值，以便将其与指定颜色恰好相同的情况区分开来：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    my $default-color = &#39;Wine&#39;;
    has $.used-default-color;
    has $.color;

    submethod BUILD ( :$color ) {
        if $color {
            $!color = $color;
            $!used-default-color = False;
            }
        else {
            $!color = $default-color;
            $!used-default-color = True;
            }
        }
    }

my $without = Butterfly.new;
put &#34;Used the default color: {$without.used-default-color}&#34;;

my $with = Butterfly.new: :color(&#39;Wine&#39;);
put &#34;Used the default color: {$with.used-default-color}&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even though those two butterflies are the same color, you know which one specified a color and which one didn’t:</p>
</div>
<div class="paragraph">
<p>即使这两只蝴蝶是相同的颜色，你知道哪一种指定了颜色，哪一种没有指定颜色：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Used the default color: True
Used the default color: False</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tweaking_objects">4.37.2. Tweaking Objects</h4>
<div class="paragraph">
<p>When you create an object you can use <code>.TWEAK</code> to set either the color you supplied as a named argument or the default color:</p>
</div>
<div class="paragraph">
<p>创建对象时，可以使用 <code>.TWEAK</code> 设置作为命名参数提供的颜色或默认颜色：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Insect {
    has $!default-color = &#39;Brown&#39;;
    has $.common-name is rw = &#39;Unnamed insect&#39;;
    has $.color       is rw;

    submethod TWEAK ( :$color ) {
        self.color = $color // $!default-color;
        }
    }

class Butterfly is Insect {}

my $butterfly = Butterfly.new;
$butterfly.common-name = &#39;Perly Cracker&#39;;

put &#34;{.common-name} is {.color}&#34; with $butterfly;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output shows that you got the default from <code>Insect</code>. <code>.TWEAK</code> ran inside <code>Insect</code> and set an attribute inside <code>Insect</code>. The <code>.color</code> method is defined in <code>Insect</code> so it works out:</p>
</div>
<div class="paragraph">
<p>输出显示你从 <code>Insect</code> 获得默认值。 <code>.TWEAK</code> 在 <code>Insect</code> 内部运行并在 <code>Insect</code> 中设置了一个属性。 <code>.color</code> 方法在 <code>Insect</code> 中定义，因此它可以解决：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Perly Cracker is Brown</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you specify a color, that color is actually set:</p>
</div>
<div class="paragraph">
<p>如果指定颜色，则实际设置该颜色：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly = Butterfly.new: :color(&#39;Purple&#39;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can modify <code>Butterfly</code> to have its own default color and <code>.TWEAK</code>. The <code>.TWEAK</code> method is the same but you wouldn’t want to inherit it. It depends on the presence of an attribute that it can’t know the child class has:</p>
</div>
<div class="paragraph">
<p>你可以修改 <code>Butterfly</code> 以拥有自己的默认颜色和 <code>.TWEAK</code>。 <code>.TWEAK</code> 方法是相同的，但你不希望继承它。它取决于它无法知道子类具有的属性的存在：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly is Insect {
    has $.default-color = &#39;Vermillion&#39;;

    submethod TWEAK ( :$color ) {
        self.color = $color // $!default-color;
        }
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_private_classes">4.38. Private Classes</h3>
<div class="paragraph">
<p>You can declare classes with <code>my</code> to make them private to the current scope. At the file level that class is only available in that file. If you load the file that contains it you won’t be able to see it:</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>my</code> 声明类，使其成为当前范围的私有。在文件级别，该类仅在该文件中可用。如果你加载包含它的文件，你将无法看到它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># PublicClass.pm6
my class PrivateClass { # Hidden from outside the file
    method hello { put &#34;Hello from {self.^name}&#34; }
    }

class PublicClass {
    method hello { PrivateClass.hello }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In your program you can load <code>PublicClass</code> and call a method on the <code>PublicClass</code> type. <code>PublicClass`can see `PrivateClass</code> because it’s in the same file. From your program you can’t call <code>PrivateClass</code> directly, though. That scope doesn’t know about that type:</p>
</div>
<div class="paragraph">
<p>在你的程序中，你可以加载 <code>PublicClass</code> 并在 <code>PublicClass</code> 类型上调用方法。 <code>PublicClass</code> 可以看到`PrivateClass`，因为它在同一个文件中。但是，从你的程序中，你无法直接调用 <code>PrivateClass</code>。该范围不知道该类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use PublicClass;
PublicClass.hello;  # Hello from PrivateClass
PrivateClass.hello; # Error: Undeclared name: PrivateClass</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need a class only inside another class (and not the rest of the file), you can declare it inside the class. This can be handy to compartmentalize and organize behavior inside a class:</p>
</div>
<div class="paragraph">
<p>如果你只需要一个类在另一个类（而不是文件的其余部分）中，你可以在类中声明它。这可以方便地划分和组织类中的行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {
    my class PrivateHelper {}
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Private classes are a great tool when you want to compartmentalize some behavior that you need but don’t want to expose to normal users. You can use them for intermediate objects that the main program never need know exist.</p>
</div>
<div class="paragraph">
<p>当你想要划分某些你需要但不想向普通用户公开的行为时，私有类是一个很好的工具。你可以将它们用于主程序永远不需要知道的中间对象。</p>
</div>
<div class="paragraph">
<p>EXERCISE 12.5Create a <code>Butterfly</code> class that contains a private class that tracks when the object was created and updated. Use it to count the number of updates to the class. A method in <code>Butterfly</code> should access the private class to output a summary.</p>
</div>
<div class="paragraph">
<p>EXERCISE 12.5创建一个 <code>Butterfly</code> 类，它包含一个私有类，用于跟踪对象何时被创建和更新。用它来计算类的更新次数。 <code>Butterfly</code> 中的方法应该访问私有类以输出摘要。</p>
</div>
</div>
<div class="sect2">
<h3 id="_summary_6">4.39. Summary</h3>
<div class="paragraph">
<p>Classes will likely be your main way of organizing information in your programs, though you don’t see it so much in this book because you need to see mostly syntactic topics rather than application design advice. I didn’t have the space for good coverage of object-oriented design or analysis, but you should definitely research those on your own. The right design will make your life so much easier.</p>
</div>
<div class="paragraph">
<p>类可能是你在程序中组织信息的主要方式，尽管你在本书中没有看到这么多，因为你需要查看主要的语法主题而不是应用程序设计建议。我没有足够的空间来覆盖面向对象的设计或分析，但你绝对应该自己研究它们。正确的设计将使你的生活变得更加轻松。
== 角色</p>
</div>
<div class="paragraph">
<p>角色是 mixins，可以增强你的类，就像它们的内容被定义在类里一样。一旦定义，它们的源实际上会被遗忘（与父类不同）。你可以使用角色来更改类，从现有类创建新类，以及增强单个对象。它们比继承更灵活，通常是更好的解决方案。角色用于代码重用，而类用于管理对象。</p>
</div>
</div>
<div class="sect2">
<h3 id="_给类添加行为">4.40. 给类添加行为</h3>
<div class="paragraph">
<p>构造一个空的 <code>Butterfly</code> 类。即使没有属性接收参数的值，你也可以为 <code>.new</code> 提供参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {}
my $butterfly = Butterfly.new: :common-name(&#39;Perly Cracker&#39;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在给你的蝴蝶命名。名字应该是 <code>Butterfly</code> 类的一部分吗？名字不是对象. <strong>Hamadryas guatemalena</strong> 是蝴蝶的名字。 Guatemalan Cracker，Calicó 和 Soñadoracomún 也是蝴蝶的名字。这些都是同一只蝴蝶的名字。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
最终，你编写的代码必须在该语言框架内运行。语法有时会让你在认知上将事物分开。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>A name is not a more specific version of something the class already does and it’s not limited to butterflies or butterfly-like things. Many dissimilar things can have a common name—animals, cars, food. Not only that, but different people, cultures, or even sections of your office may choose different names. This fact does not define your thingy or its behavior. It’s not something that makes a butterfly what it is.</p>
</div>
<div class="paragraph">
<p>名字不是该类已经做过的更具体的版本，它不仅限于蝴蝶或蝴蝶般的东西。许多不同的东西可以有一个共同的名字 - 动物，汽车，食物。不仅如此，不同的人，文化，甚至办公部门都可以选择不同的名字。这个事实并没有定义你的东西或它的行为。这不是让蝴蝶成为现实的东西。</p>
</div>
<div class="paragraph">
<p>Create a role that contains everything you need for a common name. Everything about a name (and nothing else!) can show up in that role. The role doesn’t care what sort of thingy uses it, whether that’s a butterfly, a car, or a pizza. Declare it with <code>role</code> just as you would a class:</p>
</div>
<div class="paragraph">
<p>创建一个包含公共名字所需内容的角色。关于名字的所有内容（没有别的！）都可以显示在该角色中。这个角色并不关心什么样的东西使用它，无论是蝴蝶，汽车还是披萨。用 <code>role</code> 声明一个角色就像声明类一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role CommonName {
    has $.common-name is rw = &#39;An unnamed thing&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In fact, a role can act just like a class. You can make an object from a role. This puns the role into a class:</p>
</div>
<div class="paragraph">
<p>事实上，角色就像类一样。你可以从角色创建对象。这个角色变成了一个类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role CommonName {
    has $.common-name is rw = &#39;An unnamed thing&#39;;
}

my $name = CommonName.new: :common-name(&#39;Perly Cracker&#39;);
put $name.common-name; # Perly Cracker</code></pre>
</div>
</div>
<div class="paragraph">
<p>Apply a role to a class with <code>does</code> after the class name in the same way you used <code>is</code> for inheritance:</p>
</div>
<div class="paragraph">
<p>在类名之后使用 <code>does</code> 以类似于继承使用 <code>is</code> 的方式将角色应用于类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly does CommonName {};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Every <code>Butterfly</code> object now has a <code>$.common-name</code> attribute and <code>.new</code> now sets the <code>:common-name</code> using either the default or the name you provide:</p>
</div>
<div class="paragraph">
<p>每个 <code>Butterfly</code> 对象现在都有一个 <code>$.common-name</code> 属性，而 <code>.new</code> 现在使用默认名称或你提供的名称设置 <code>:common-name</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $unnamed-butterfly = Butterfly.new;
put $unnamed-butterfly.common-name;   # An unnamed thing

my $butterfly = Butterfly.new: :common-name(&#39;Perly Cracker&#39;);
put $butterfly.common-name;   # Perly Cracker</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use the same role for something completely different. An SSL certificate has a common name, although its semantic meaning is different:</p>
</div>
<div class="paragraph">
<p>对于完全不同的东西，你可以使用相同的角色。 SSL 证书具有常用名，但其语义含义不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class SSLCertificate does CommonName {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Butterflies and SSL certificates are completely different things and it wouldn’t make sense for them to inherit from the same thing. However, they can use the same role.</p>
</div>
<div class="paragraph">
<p>蝴蝶和 SSL 证书是完全不同的东西，它们从同一个东西继承是没有意义的。但是，他们可以使用相同的角色。</p>
</div>
<div class="paragraph">
<p>EXERCISE 13.1Create a <code>ScientificName</code> role that adds an attribute to store a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) for the scientific name. Apply that role to <code>Butterfly</code>, create an object, and output the scientific name.</p>
</div>
<div class="paragraph">
<p>练习13.1 创建一个 <code>ScientificName</code> 角色，添加一个属性来存储学名的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)。将该角色应用于" class="bare">https://docs.raku.org/type/Str.html)。将该角色应用于</a> <code>Butterfly</code>，创建对象并输出学名。</p>
</div>
<div class="sect3">
<h4 id="_applying_multiple_roles">4.40.1. Applying Multiple Roles</h4>
<div class="paragraph">
<p>You can give a butterfly a scientific name as well as a common name by creating a different role for that. This one has several attributes:</p>
</div>
<div class="paragraph">
<p>你可以通过为蝴蝶创建不同的角色，为蝴蝶提供学名和常用名。这只蝴蝶有几个属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role ScientificName {
    has $.kingdom is rw;
    has $.phylum is rw;
    has $.class is rw;
    has $.order is rw;
    has $.family is rw;
    has $.genus is rw;
    has $.species is rw;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can replace the <code>CommonName</code> role with <code>ScientificName</code> and things work as before:</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>ScientificName</code> 替换 <code>CommonName</code> 角色，并且事情像以前一样工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly does ScientificName {};
my $butterfly = Butterfly.new: :genus(&#39;Hamadryas&#39;);
put $butterfly.genus;  # Hamadryas;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multiple <code>does</code> expressions apply multiple roles:</p>
</div>
<div class="paragraph">
<p>多个 <code>does</code> 表达式应用多个角色：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly does ScientificName does CommonName {};
my $butterfly = Butterfly.new:
    :genus(&#39;Hamadryas&#39;),
    :common-name(&#39;Perly Cracker&#39;)
    ;
put $butterfly.genus;
put $butterfly.common-name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each role inserts its code into <code>Butterfly</code> so it can respond to methods from either source:</p>
</div>
<div class="paragraph">
<p>每个角色都将其代码插入 <code>Butterfly</code> 中，以便它可以响应来自任何一个源的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Hamadryas
Perly Cracker</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 13.2Create a role <code>Lepidoptera</code> to represent butterflies. Fill in everything from kingdom <strong>Animalia</strong>, phylum <strong>Athropoda</strong>, class <strong>Insecta</strong>, and order <strong>Lepidoptera</strong>. Allow the role to change the family, genus, and species. Use that role in your own <code>Butterfly</code> class. After you get that working add the <code>CommonName</code> role.</p>
</div>
<div class="paragraph">
<p>练习13.2 创建一个 <code>Lepidoptera</code> 代表蝴蝶的角色。填写动物界，动物门，昆虫纲和鳞翅目的一切。允许角色改变族，属和物种。在你自己的 <code>Butterfly</code> 类中使用该角色。完成后，添加 <code>CommonName</code> 角色。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_methods_in_roles">4.41. Methods in Roles</h3>
<div class="paragraph">
<p>You can define methods in roles too. Give the <code>ScientificName</code> role a <code>.gist</code> method to create your own human-readable text version of the object:</p>
</div>
<div class="paragraph">
<p>你也可以在角色中定义方法。为 <code>Scientific Name</code> 角色提供一个 <code>.gist</code> 方法，以创建自己的对象的人类可读文本版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role ScientificName {
    ...; # all the attributes specified earlier

    method gist {
        join &#39; &gt; &#39;, $.kingdom, $.genus;
        }
    }

role CommonName {
    has $.common-name is rw;
    }

class Butterfly does ScientificName does CommonName {};

my $butterfly = Butterfly.new:
    :genus(&#39;Hamadryas&#39;),
    :common-name(&#39;Perly Cracker&#39;)
    ;
put $butterfly.genus;
put $butterfly.common-name;
put $butterfly.gist;</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 13.3Update your <code>Lepidoptera</code> role to have a <code>binomial-name</code> method that returns a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) that combines the genus and species of the butterfly (in biospeak that’s the “binomial name”).</p>
</div>
<div class="paragraph">
<p>练习13.3 更新你的 <code>Lepidoptera</code> 角色以拥有 <code>binomial-name</code> 方法，它返回一个结合蝴蝶属和种类的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)（在biospeak中是“二项式名称”）。" class="bare">https://docs.raku.org/type/Str.html)（在biospeak中是“二项式名称”）。</a></p>
</div>
<div class="paragraph">
<p>To reuse these roles you want to make them available for any code to find and load. You can store roles by themselves in files just as you can with classes. Load them with <code>use</code> and they are available in that scope.</p>
</div>
<div class="paragraph">
<p>要重用这些角色，你需要使它们可供任何代码查找和加载。你可以像在类中一样将文件存储在文件中。使用 <code>use</code> 加载它们，它们在该范围内可用。</p>
</div>
<div class="paragraph">
<p>EXERCISE 13.4Separate the <code>Lepidoptera</code> and <code>CommonName</code> roles and the <code>Butterfly</code> class into their own files. Load those files into your program where you create your <code>Butterfly</code> object. Make this program work:`use Butterfly;  my $butterfly = Butterfly.new:     :family(  &#39;Nymphalidae&#39; ),     :genus(   &#39;Hamadryas&#39; ),     :species( &#39;perlicus&#39; ),     ;  put $butterfly.binomial-name;`</p>
</div>
<div class="paragraph">
<p>练习13.4 将 <code>Lepidoptera</code> 和 <code>CommonName</code> 角色还有 <code>Butterfly`类分开到它们自己的文件中。在你要创建 `Butterfly</code> 的地方加载这些文件到你的程序中。使这个程序能工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Butterfly;
my $butterfly = Butterfly.new:
    :family(  &#39;Nymphalidae&#39; ),
    :genus(   &#39;Hamadryas&#39; ),
    :species( &#39;perlicus&#39; ),
;
put $butterfly.binomial-name;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_de_conflicting_roles">4.42. De-Conflicting Roles</h3>
<div class="paragraph">
<p>If two roles try to insert the same names you may have to do extra work. Suppose that both <code>ScientificName`and `CommonName</code> had a <code>.gist</code> method:</p>
</div>
<div class="paragraph">
<p>如果两个角色尝试插入相同的名称，则可能需要执行额外的工作。假设 <code>ScientificName</code> 和 <code>CommonName</code> 都有.gist方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role ScientificName {
    ...; # all the attributes specified earlier

    method gist {
        join &#39; &gt; &#39;, $.kingdom, $.genus;
        }
    }

role CommonName {
    has $.common-name is rw;

    method gist { &#34;Common name: $.common-name&#34; }
    }

class Butterfly does ScientificName does CommonName {};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>.gist</code> method has an explicit signature and isn’t marked with <code>multi</code>. When you try to compile this you get an error telling you that two roles tried to insert the same method:</p>
</div>
<div class="paragraph">
<p><code>.gist</code> 方法具有显式签名，并且未标记为 <code>multi</code>。当你尝试编译它时，你会收到一个错误，告诉你两个角色尝试插入相同的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Method &#39;gist&#39; must be resolved by class Butterfly because
it exists in multiple roles (CommonName, ScientificName)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can add a <code>.gist</code> method to <code>Butterfly</code>. Neither role replaces a method already in the class:</p>
</div>
<div class="paragraph">
<p>你可以向 <code>Butterfly</code> 添加 <code>.gist</code> 方法。这两个角色都不替换类中已有的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role ScientificName {
    ...; # all the attributes specified earlier

    method gist {
        join &#39; &gt; &#39;, $.kingdom, $.genus;
        }
    }

role CommonName {
    has $.common-name is rw;

    method gist { &#34;Common name: $.common-name&#34; }
    }

class Butterfly does ScientificName does CommonName {
    method gist {
        join &#34;\n&#34;,
            join( &#39; &gt; &#39;, $.kingdom, $.genus ),
            &#34;Common name: $.common-name&#34;;
        }
    };</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or if you want both methods from the roles you can distinguish them with different signatures (and use <code>multi</code>). Their role names as a type might do:</p>
</div>
<div class="paragraph">
<p>或者，如果你想要角色中的两种方法，则可以使用不同的签名区分它们（并使用 <code>multi</code> ）。他们的角色名称作为类型可能是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role ScientificName {
    ...; # all the attributes specified earlier

    multi method gist ( ScientificName ) {
        &#34;$.genus $.species&#34;;
        }
    }

role CommonName {
    has $.common-name is rw;

    multi method gist ( CommonName ) {
        &#34;Common name: $.common-name&#34;;
        }
    }

class Butterfly does ScientificName does CommonName {};

my $butterfly = Butterfly.new:
    :genus(&#39;Hamadryas&#39; ),
    :species(&#39;perlicus&#39;),
    :common-name( &#39;Perly Cracker&#39; ),
    ;

put &#39;1. &#39;, $butterfly.gist( CommonName );
put &#39;2. &#39;, $butterfly.gist( ScientificName );</code></pre>
</div>
</div>
<div class="paragraph">
<p>This way you get both methods:</p>
</div>
<div class="paragraph">
<p>这样你就得到了两种方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1. Common name: Perly Cracker
2. Hamadryas perlicus</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can have the same method in the <code>Butterfly</code> class as long as you declare it with <code>multi</code> and give it a unique signature:</p>
</div>
<div class="paragraph">
<p>你可以在 <code>Butterfly</code> 类中使用相同的方法，只要用 <code>multi</code> 声明它并给它一个唯一的签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly does ScientificName does CommonName {
    multi method gist {
        join &#34;\n&#34;, map { self.gist: $_ },
            ( ScientificName, CommonName );
        }
    };
my $butterfly = Butterfly.new:
    :genus(&#39;Hamadryas&#39;),
    :species(&#39;perlicus&#39;),
    :common-name(&#39;Perly Cracker&#39;)
    ;

put &#39;1. &#39;, $butterfly.gist( CommonName );
put &#39;2. &#39;, $butterfly.gist( ScientificName );
put &#39;3. &#39;, $butterfly.gist;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your output shows all three and you can pick whichever you like:</p>
</div>
<div class="paragraph">
<p>你的输出显示全部三个，你可以选择你喜欢的任何一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1. Common name: Perly Cracker
2. Hamadryas perlicus
3. Hamadryas perlicus
Common name: Perly Cracker</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_anonymous_roles">4.43. Anonymous Roles</h3>
<div class="paragraph">
<p>Not every role needs a name. If you want a role that you don’t expect to use again you can add it directly with <code>but</code>. You can apply that directly to a class name. This actually creates a new class with the role applied to it. The new class inherits from the original:</p>
</div>
<div class="paragraph">
<p>并非每个角色都需要一个名字。如果你想要一个不希望再次使用的角色，可以用 <code>but</code> 直接添加它。你可以将其直接应用于类名。这实际上创建了一个应用了角色的新类。新类继承自原始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Butterfly {};
my $class-role = Butterfly but role { has $.common-name };

put $class-role.^name; # Butterfly+{&lt;anon|140470326869504&gt;}
say $class-role.^mro; # ((...) (Butterfly) (Any) (Mu))

my $butterfly = $class-role.new:
    :common-name( &#39;Perly Cracker&#39; );

put $butterfly.common-name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can do the same thing with less work by removing the variables that stored the classes:</p>
</div>
<div class="paragraph">
<p>通过删除存中储类的变量，你可以用更少的工作做同样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly2 = ( Butterfly but role { has $.common-name } ).new:
    :common-name(&#39;Perlicus Cracker&#39;);
put $butterfly2.^name;
put $butterfly2.common-name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s still messy. You can apply it to the object directly:</p>
</div>
<div class="paragraph">
<p>那仍然很混乱。你可以直接将角色应用于对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly = Butterfly.new;
my $butterfly2 = $butterfly
    but role { has $.common-name is rw };
$butterfly2.common-name = &#39;Perlicus Cracker&#39;;
put $butterfly2.^name;
put $butterfly2.common-name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can even skip the variable to store the first object. Without the variable to store the initial object you get something a little shorter:</p>
</div>
<div class="paragraph">
<p>你甚至可以跳过变量来存储第一个对象。如果没有用于存储初始对象的变量，你可以获得更短的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $butterfly = Butterfly.new
    but role { has $.common-name is rw };
$butterfly.common-name = &#39;Perlicus Cracker&#39;;
put $butterfly.^name;
put $butterfly.common-name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This has the drawback that the original object doesn’t know about the roles, so you can’t set the common name in the constructor. Your role has to allow the object to change the value to set a value.</p>
</div>
<div class="paragraph">
<p>这样做的缺点是原始对象不知道角色，因此你无法在构造函数中设置公共名称。你的角色必须允许对象更改值以设置值。</p>
</div>
<div class="paragraph">
<p>Adding a role to an object is handy when you have an object that you may not have created; perhaps it was an argument to your method or the return value from a method you don’t control. In this example you take an argument (and make it <code>is copy</code> so you can add the role). You call <code>show-common-name</code> once with a plain <code>Butterfly</code>. The subroutine sees that the object doesn’t know about <code>common-name</code>, so it adds it. In your second call to <code>show-common-name</code> your argument already has the <code>common-name</code> attribute so it doesn’t need <code>show-common-name</code> to add it:</p>
</div>
<div class="paragraph">
<p>当你有一个你可能没有创建的对象时，为一个对象添加一个角色很方便;也许这是你的方法的参数或你不能控制的方法的返回值。在这个例子中，你接受一个参数（并使它可拷贝(<code>is copy</code>)，这样你就可以添加角色）。你用普通的 <code>Butterfly</code> 调用一次 <code>show-common-name</code>。子例程看到对象不知道 <code>common-name</code>，所以它添加了它。在第二次调用 <code>show-common-name</code> 时，你的参数已经有了 <code>common-name</code> 属性，所以它不需要 <code>show-common-name</code> 来添加它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub show-common-name ( $butterfly is copy ) {
    unless $butterfly.can: &#39;common-name&#39; {
        put &#34;Adding role!&#34;;
        $butterfly = $butterfly
            but role { has $.common-name is rw };
        $butterfly.common-name = &#39;Perlicus Cracker&#39;;
        }

    put $butterfly.common-name;
    }

# an object without the role
my $butterfly = Butterfly.new;
show-common-name( Butterfly.new );

# an object that already has the role
my $class-role = Butterfly but role { has $.common-name };
show-common-name( $class-role.new: :common-name( &#39;Camelia&#39; ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output shows that you added the role in your first call but not the second:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Adding role!
Perlicus Cracker
Camelia</code></pre>
</div>
</div>
<div class="paragraph">
<p>When should you apply your role? Whenever it makes sense for your problem.</p>
</div>
<div class="paragraph">
<p>你应该在什么时候应用你的角色？每当它对你的问题有意义时。</p>
</div>
<div class="paragraph">
<p>EXERCISE 13.5Take your <code>Lepidoptera</code> role to its logical conclusion. Start with a new <code>Animalia</code> role to represent only the kingdom. Create an <code>Arthropoda</code> role to include the <code>Animalia</code> role and represent the phylum. Do this all the way down to the <strong>Hamadryas</strong> genus. From there, create a <code>Hamadrayas</code> class that inherits from <code>Butterfly`but does all the taxonomic roles down to the genus. From the `Hamadrayas</code> class you should be able to set a species. Make this program work:`use lib &lt;.&gt;; use Hamadryas;  my $cracker = Hamadryas.new:     :species( &#39;perlicus&#39; ),     :common-name( &#39;Perly Cracker&#39; ),     ;  put $cracker.binomial-name; put $cracker.common-name;`</p>
</div>
<div class="paragraph">
<p>练习13.5 将你的 <code>Lepidoptera</code> 角色归结为合乎逻辑的结论。从新的 <code>Animalia</code> 角色开始，仅代表王国。创建 <code>Arthropoda</code> 角色以包括 <code>Animalia</code> 角色并代表门。一直这样做到 <strong>Hamadryas</strong> 属。从那里，创建一个继承自`Butterfly` 的 <code>Hamadrayas</code> 类，但将所有的分类角色归结为属。从 <code>Hamadrayas</code> 类，你应该能够设置一个物种。使这个程序工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use lib &lt;.&gt;;
use Hamadryas;
my $cracker = Hamadryas.new:
    :species( &#39;perlicus&#39; ),
    :common-name( &#39;Perly Cracker&#39; ),
    ;
put $cracker.binomial-name; put $cracker.common-name;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_summary_7">4.44. Summary</h3>
<div class="paragraph">
<p>You can define common code in a role and reuse it with disparate things. Since it doesn’t create an inheritance relationship it’s perfectly suited for features that don’t define the basic idea of the type.</p>
</div>
<div class="paragraph">
<p>你可以在角色中定义公共代码，并将其重用于不同的东西。由于它不创建继承关系，因此非常适合未定义类型基本概念的功能。
== Junctions和集合</p>
</div>
</div>
<div class="sect2">
<h3 id="_junctions">4.45. Junctions</h3>
<div class="paragraph">
<p>A [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) is a combination of values that is mostly indistinguishable from a single value. They have their roots in the math of quantum mechanics. You may have heard of Schrödinger’s cat, who is both dead and alive at the same time—an analogy that physicist used to show how ridiculous this all is. Well, the joke was on him.</p>
</div>
<div class="paragraph">
<p>[<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 是一组值，它们与单个值几乎无法区分。它们根植于于量子力学中的数学。你可能听说过薛定谔的猫，同一个时间它既死又活着 - 这个物理学家用来表示这一切是多么荒谬。那个笑话现在应在 Junction 身上了。</p>
</div>
<div class="sect3">
<h4 id="_any">4.45.1. any</h4>
<div class="paragraph">
<p>The first [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) is the <code>any</code>. This “any” is lowercase and is not related to the type [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>). It creates a value that can act like, well, any of the ones you gave it:</p>
</div>
<div class="paragraph">
<p>第一个  [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 是 <code>any</code>。这个“any”是小写的，与 [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>) 类型无关。它会创建一个值，就像你给它的任何一个一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $first-junction = any( 1, 3, 7 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can make a [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) from an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) or any other [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>):</p>
</div>
<div class="paragraph">
<p>你可以从[数组](<a href="https://docs.raku.org/type/Array.html)或任何其他" class="bare">https://docs.raku.org/type/Array.html)或任何其他</a> [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) 创建一个  [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)：" class="bare">https://docs.raku.org/type/Junction.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $junction = any( @array   );   # Array
my $junction = any( 1 ..  10 );   # Range
my $junction = any( 1 ... 10 );   # Sequence</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you have a [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) of three values. It will only ever have three values. You can’t take one away or add one. There’s no interface to extract them or count them. You’re not supposed to know—or even care—which values are in there. In fact, [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) is the only builtin type that does not inherit from [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>):</p>
</div>
<div class="paragraph">
<p>现在你有一个三个值的  [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)。它只会有三个值。你不能拿走一个或添加一个。没有接口可以提取它们或计算它们。你不应该知道" class="bare">https://docs.raku.org/type/Junction.html)。它只会有三个值。你不能拿走一个或添加一个。没有接口可以提取它们或计算它们。你不应该知道</a> - 甚至关心 - 那里有哪些观。事实上， [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 是唯一不从  [<code>Any</code>](<a href="https://docs.raku.org/type/Any.html" class="bare">https://docs.raku.org/type/Any.html</a>) 继承的内置类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku
To exit type &#39;exit&#39; or &#39;^D&#39;
&gt; my $first-junction = any( 1, 3, 7 );
any(1, 3, 7)
&gt; $first-junction.^name
Junction
&gt; $first-junction.^mro
((Junction) (Mu))</code></pre>
</div>
</div>
<div class="paragraph">
<p>These are quite handy in complex conditions. Consider the annoying code you’ve had to write to test if a value is one of three possible numbers:</p>
</div>
<div class="paragraph">
<p>这些在复杂条件下非常方便。考虑一下你必须编写的令人讨厌的代码，以测试值是否是三个可能的数字之一：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = any( 1, 3, 7 );

if $n == 1 || $n == 3 || $n == 7 {
    put &#34;n is one of those values&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Being clever with a [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) doesn’t actually feel that much more clever:</p>
</div>
<div class="paragraph">
<p>聪明的 [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) 实际上并没有感觉更聪明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int %hash = map { $_ =&gt; True }, (1, 3, 7);
if %hash{$n}:exists {
    put &#34;n is one of those values&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Not only does the [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) equal any of those values, but it also equals all of them. This looks like a [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)that" class="bare">https://docs.raku.org/type/Block.html)that</a> would never execute, but it does:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[`Junction`](https://docs.raku.org/type/Junction.html) 不仅等于这些值中的任何一个，而且它也等于所有这些值。这看起来像一个永远不会执行的 [`Block`](https://docs.raku.org/type/Block.html)，但它确实：</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $n == 1 &amp;&amp; $n == 3 &amp;&amp; $n == 7 {
    put &#34;n is all of those values&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) is much closer to how you’d probably describe this in speech:</p>
</div>
<div class="paragraph">
<p>[<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 更接近你可能在演讲中描述的方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $n == any( 1, 3, 7 ) {
    put &#34;n is one of those values&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you operate on a [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) your code may distribute (autothread) that operation over all of its values to produce a [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) of intermediate results. The first step might look like this:</p>
</div>
<div class="paragraph">
<p>当你在 [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 上操作时，你的代码可以在其所有值上分配（自动读取）该操作，以产生中间结果的 [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)。第一步可能如下所示：" class="bare">https://docs.raku.org/type/Junction.html)。第一步可能如下所示：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if any( 1 == $n, 3 == $n, 7 == $n ) {
    put &#34;n is one of those values&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>These evaluate to their Boolean values. If <code>$n</code> is <code>3</code> one of the comparisons is <code>True</code>:</p>
</div>
<div class="paragraph">
<p>这些求值为其布尔值。如果 <code>$n</code> 为 <code>3</code> ，则其中一个比较为 <code>True</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = 3;
if any( False, True, False ) {
    put &#34;n is one of those values&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any <code>True</code> makes the entire junctive expression <code>True</code>:</p>
</div>
<div class="paragraph">
<p>任何一个为 <code>True</code> 会使整个正则表达式为 <code>True</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = 3;
if True {
    put &#34;n is one of those values&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You don’t have to define the [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) in the condition. It might already be in a variable and ready for use:</p>
</div>
<div class="paragraph">
<p>你不必在条件中定义  [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)。它可能已经在变量中并且可以使用：" class="bare">https://docs.raku.org/type/Junction.html)。它可能已经在变量中并且可以使用：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $any = any( 1, 3, 7 );
if $n == $any {
    put &#34;n is one of those values&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here’s the beauty of [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)s—you" class="bare">https://docs.raku.org/type/Junction.html)s—you</a> don’t have to know that you are using one. Here’s an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) that has some “normal” values and one that is a [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>):</p>
</div>
<div class="paragraph">
<p>这是  [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 的美之所在 - 你不知不觉就在使用它。这是一个具有一些“正常”值的[<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)，其中一个元素是" class="bare">https://docs.raku.org/type/Array.html)，其中一个元素是</a> [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)：" class="bare">https://docs.raku.org/type/Junction.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array = 5, any( 1, 7 ), 8, 9;
for @array -&gt; $item {
    put &#34;$item was odd&#34; unless $item %% 2;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The loop works with single “normal” values as well as [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)s" class="bare">https://docs.raku.org/type/Junction.html)s</a>. Notice that the [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) creates two lines of output. The stringification happened for each value:</p>
</div>
<div class="paragraph">
<p>在这个循环中，单个“正常”值以及 [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 都起作用。请注意，[<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 创建了两行输出。每个值都发生了字符串化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">5 was odd
1 was odd
7 was odd
9 was odd</code></pre>
</div>
</div>
<div class="paragraph">
<p>That multiple stringification could change in the future; it wasn’t this way when I started the book and it might change again. The <code>.gist</code> on <code>$item</code> prevents that:</p>
</div>
<div class="paragraph">
<p>多重字符串化可能会在未来发生变化; 当我开始写这本书时它不是这样的，它可能会再次改变。 <code>$item</code> 上的 <code>.gist</code> 可以防止多重字符串化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array = 5, any( 1, 7 ), 8, 9;
for @array -&gt; $item {
    put &#34;{$item.gist} was odd&#34; unless $item %% 2;
    }

5 was odd
any(1, 7) was odd
9 was odd</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 14.1Make an <code>any</code> [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) of the prime numbers between 1 and 10 (so, 2, 3, 5, and 7). Use that [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) to note which numbers from 1 to 10 are prime.</p>
</div>
<div class="paragraph">
<p>练习14.1使用 1 到 10 之间的素数制作一个 <code>any</code> [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)（因此，2,3,5和7）。使用该" class="bare">https://docs.raku.org/type/Junction.html)（因此，2,3,5和7）。使用该</a> [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 来记录从1到10的哪些数字是素数。</p>
</div>
<div class="paragraph">
<p>There’s a symbolic notation for <code>any</code>. The <code>|</code> between values creates a [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>). It looks similar to the <code>||</code> for the logical OR operator but is not related:</p>
</div>
<div class="paragraph">
<p><code>any</code> 有一个象征性的符号。 值之间的 <code>|</code> 创建一个 [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)。它看起来类似于" class="bare">https://docs.raku.org/type/Junction.html)。它看起来类似于</a> <code>||</code> 对于逻辑OR运算符但不相关：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = 3;
my $any = 1 | 3 | 7;
if $n == $any {
    put &#34;n is one of those values&#34;;
    }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Raku uses <code>|</code>, <code>&amp;</code>, and <code>^</code> to create [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)s" class="bare">https://docs.raku.org/type/Junction.html)s</a>. You might be used to these as numeric bit operators in other languages. You’ll find those now are called <code>+|</code>, <code>+^</code>, and <code>+&amp;</code>. That leading <code>+</code> denotes the numeric flavor.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Raku 使用 <code>|</code>，<code>＆</code> 和 <code>^</code> 来创建 [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)。你可能习惯使用其他语言中的数字位运算符。你会发现现在称为" class="bare">https://docs.raku.org/type/Junction.html)。你可能习惯使用其他语言中的数字位运算符。你会发现现在称为</a> <code>+|</code>，<code>+^</code> 和 <code>+&amp;</code> 。前导 <code>+</code> 表示数字风味。</p>
</div>
<div class="paragraph">
<p>You can change [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)s" class="bare">https://docs.raku.org/type/Junction.html)s</a> by affecting their values. Numerically adding to a [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) adds to every value in it:</p>
</div>
<div class="paragraph">
<p>你可以通过影响其值来更改 [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)。以数字方式添加到" class="bare">https://docs.raku.org/type/Junction.html)。以数字方式添加到</a>  [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 会增加其中的每个值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $junction = any( 1, 3, 7 );
$junction += 1;
if $junction %% 2 {
    put &#34;{$junction.gist} is even&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output shows that you were able to add one to each of the values:</p>
</div>
<div class="paragraph">
<p>输出显示你可以为每个值加一：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">any(2, 4, 8) is even</code></pre>
</div>
</div>
<div class="paragraph">
<p>This generally applies to all of the operations, and you can get quite creative with that. What if you add two <code>any</code>[<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)s?" class="bare">https://docs.raku.org/type/Junction.html)s?</a> Think about this for a minute before you read ahead to the output:</p>
</div>
<div class="paragraph">
<p>这通常适用于所有操作，你可以从中获得相当的创意。如果你将两个 <code>any</code>  [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 相加会怎样？在继续读到输出之前，请考虑一分钟：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $any-any = any( 6, 7 ) + any( 9, 11 )
put &#34;Result is $any-any&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now figure out what this means:</p>
</div>
<div class="paragraph">
<p>现在弄清楚这意味着什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Result is any(any(15, 17), any(16, 18))</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s an <code>any</code> of <code>any`s! Suppose you wanted to check if that value was less than `17</code>. This virtual series of steps finds the answer:</p>
</div>
<div class="paragraph">
<p>这是一个里面含有 <code>any</code> 的 <code>any</code>。假设你要检查该值是否小于 <code>17</code>。此虚拟系列步骤可找到答案：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$any-any &lt; 17

any( any(15, 17), any(16, 18) ) &lt; 17

any( any(15, 17) &lt; 17, any(16, 18) &lt; 17 )

any( any(15 &lt; 17, 17 &lt; 17), any(16 &lt; 17, 18 &lt; 17) )

any( any(True,False), any(True, False) )

any( True, True )

True</code></pre>
</div>
</div>
<div class="paragraph">
<p>This has the same effect as <code>any( 15, 16, 17, 18 )</code> but with more steps involved. That’s a warning. If you aren’t careful you could have an explosion of [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)s" class="bare">https://docs.raku.org/type/Junction.html)s</a> in there.</p>
</div>
<div class="paragraph">
<p>这与任何 <code>any( 15, 16, 17, 18 )</code> 具有相同的效果，但涉及更多步骤。这是一个警告。如果你不小心，你可能会爆发 [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)。" class="bare">https://docs.raku.org/type/Junction.html)。</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_all">4.45.2. all</h4>
<div class="paragraph">
<p>An <code>all</code> [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) requires that each of its values satisfy the condition or method you apply:</p>
</div>
<div class="paragraph">
<p><code>all</code>  [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 要求其每个值满足你应用的条件或方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $all-of-u = all( &lt;Danaus Bicyclus Amauris&gt; );
if $all-of-u.contains: &#39;u&#39; {
    put &#34;Everyone has a u&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Perhaps you want to check that all of the values are a particular type. In this example there’s a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) in <code>@mixed-types</code>:</p>
</div>
<div class="paragraph">
<p>也许你想要检查所有值是否为特定类型。在这个例子中，<code>@mixed-types</code> 中有一个 [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)：" class="bare">https://docs.raku.org/type/Str.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @mixed-types = &lt;1 2/3 4+8i Hello&gt;;
if all(@mixed-types) ~~ Numeric {
    put &#34;Every value is a numeric thingy&#34;;
    }
else {
    put &#34;One of these things is not like the others&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Hello</code> cannot become a number, so a smart match against [<code>Numeric</code>](<a href="https://docs.raku.org/type/Numeric.html" class="bare">https://docs.raku.org/type/Numeric.html</a>) fails. The entire [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) evaluates to <code>False</code> because one of its values does.</p>
</div>
<div class="paragraph">
<p><code>Hello</code> 无法成为数字，因此与  [<code>Numeric</code>](<a href="https://docs.raku.org/type/Numeric.html" class="bare">https://docs.raku.org/type/Numeric.html</a>) 的智能匹配失败。整个  [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 的计算结果为 <code>False</code>，因为其值之一是 <code>False</code>。</p>
</div>
<div class="paragraph">
<p>The <code>all</code> is much easier to read than almost anything else that might accomplish the task. Comparing the result of a <code>.grep</code> to the original number of elements in the source is too much typing:</p>
</div>
<div class="paragraph">
<p><code>all</code> 都比其他任何可能完成任务的东西更容易阅读。将 <code>.grep</code> 的结果与源中元素的原始数量进行比较打字太多了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if @mixed-types.grep( * !~~ Numeric ) == +@mixed-types {
    put &#34;One of these things is not a number&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can create an <code>all</code> [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) with the <code>&amp;</code>:</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>&amp;</code> 创建一个 <code>all</code> [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)：" class="bare">https://docs.raku.org/type/Junction.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $all-of-u = &#39;Danaus&#39; &amp; &#39;Bicyclus&#39; &amp; &#39;Amauris&#39;;
if $all-of-u.contains: &#39;u&#39; {
    put &#34;Everyone has a u&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 14.2Using <code>all</code>, test if all the numbers you specify on the command line are prime.</p>
</div>
<div class="paragraph">
<p>练习14.2使用 <code>all</code>，测试你在命令行中指定的所有数字是否为素数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_one">4.45.3. one</h4>
<div class="paragraph">
<p>The <code>one</code> [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) allows only one of its values to satisfy its condition. If more than one would make the condition <code>True</code> the [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) fails:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>`one` [`Junction`](https://docs.raku.org/type/Junction.html) 只允许其中一个值满足其条件。如果不止一个条件为 `True`，则 [`Junction`](https://docs.raku.org/type/Junction.html) 失败：</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put one( 1, 2, 3 ) %% 2 ??     # True
    &#34;Exactly one is even&#34;
        !!
    &#34;More (or less) than one is even&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If more than one thing in the <code>one</code> is <code>True</code>, then the entire [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) is <code>False</code>:</p>
</div>
<div class="paragraph">
<p>如果 <code>one</code> 中的多个是 <code>True</code>，则整个 [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 为 <code>False</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">one( True, True, False ).so    # False;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can create a <code>one</code> [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) with the <code>^</code>:</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>^</code> 创建 <code>one</code>[<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)：" class="bare">https://docs.raku.org/type/Junction.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put ( 1 ^ 2 ^ 3 ) %% 2 ??      # True
    &#34;Exactly one is even&#34;
        !!
    &#34;More (or less) than one is even&#34;;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_none">4.45.4. none</h4>
<div class="paragraph">
<p>The <code>none</code> [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) requires that all of the values cause its condition to be <code>False</code>. That means that everything should evaluate to <code>False</code>. There’s no symbolic operator version for this type:</p>
</div>
<div class="paragraph">
<p><code>none</code>  [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 要求所有值都导致其条件为 <code>False</code>。这意味着一切都应该计算为 <code>False</code>。该类型没有符号运算符版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put none( 1, 2, 3 ) %% 5 ??      True
    &#34;Exactly one is even&#34;
        !!
    &#34;More (or less) than one is even&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 14.3Use <code>none</code> to test if no numbers you specify on the command line are prime. Once you’ve done that, use <code>none`to test that some numbers in an [`Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) are prime.</p>
</div>
<div class="paragraph">
<p>练习14.3如果你在命令行中指定的数字不是素数，则使用 <code>none</code> 来测试。完成后，使用 <code>none</code> 测试，数组中的某些数字是素数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_some_junctive_tricks">4.45.5. Some Junctive Tricks</h4>
<div class="paragraph">
<p>[<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)s" class="bare">https://docs.raku.org/type/Junction.html)s</a> aren’t designed for introspection and you aren’t supposed to care if the value is in a [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>). This isn’t too hard to work around, though.</p>
</div>
<div class="paragraph">
<p>[<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 不是为内省而设计的，你不应该关心这个值是否在一个  [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 中。不过，这并不难解决。</p>
</div>
<div class="paragraph">
<p>You can apply an operation to each value with a hyperoperator ([Chapter 6](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch06.html#camelia-lists)" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch06.html#camelia-lists)</a>). This one adds one to each element:</p>
</div>
<div class="paragraph">
<p>你可以使用超运算符对每个值应用操作（第6章）。这个为每个元素加一：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $junction = any( 1, -3, 7 );
say $junction »+« 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The new [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) has new values. You still aren’t supposed to know what these new values are, but something must know what they are to add one to them:</p>
</div>
<div class="paragraph">
<p>新的  [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 有新的值。你仍然不应该知道这些新值是什么，但肯定知道它们加一之后是什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">any(2, -2, 8)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>»+«</code> surrounds the <code>+</code> because that’s an infix operator and expects arguments on either side of it. You can call a method (a postfix thing) on each item:</p>
</div>
<div class="paragraph">
<p><code>»+«</code> 包围着 <code>+</code>，因为这是一个中缀运算符，并期望它的任何一边都有参数。你可以在每一项上调用一个方法（一个后缀的东西）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$junction&gt;&gt;.is-prime; # any((True), (False), (False))</code></pre>
</div>
</div>
<div class="paragraph">
<p>That method could be <code>.take</code>, which adds the value to the list that <code>gather</code> makes. This means that the values can escape the [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>):</p>
</div>
<div class="paragraph">
<p>该方法可以是 <code>.take</code>，它将值添加到 <code>gather</code> 制作的列表中。这意味着值可以避开 [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)：" class="bare">https://docs.raku.org/type/Junction.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $junction = any( 1, -3, 7 );
my @values = gather $junction».take;
put &#34;Values are @values[]&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Don’t make a habit of this because it’s slightly naughty. You aren’t supposed to know how to do this.</p>
</div>
<div class="paragraph">
<p>不要养成这个习惯，因为它有点顽皮。你不应该知道如何做到这一点。</p>
</div>
<div class="paragraph">
<p>A [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) is handy to allow a combination of types in a type constraint. Use the <code>subset</code> of the [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)of" class="bare">https://docs.raku.org/type/Junction.html)of</a> both types as the constraint:</p>
</div>
<div class="paragraph">
<p>[<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 可以方便地在类型约束中组合类型。使用两种类型的 [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 的 <code>subset</code> 子集作为约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset IntInf where Int | Inf;
sub add ( IntInf $a, IntInf $b ) { $a + $b }

put add( 1, 3 );   # 4
put add( 1, Inf ); # Inf</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 14.4Rewrite the number-guessing game from [Chapter 2](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch02.html#camelia-guessing" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch02.html#camelia-guessing</a>) to have three secret numbers. This time the hints are a bit trickier. If any of the secret numbers are smaller than the guess, tell the person that one or some of them are smaller. Do the same with larger numbers. For a single guess, some numbers may be larger and others smaller. When the person has guessed all of the secret numbers, end the game. Is it easier to use <code>given-when</code> or <code>if</code>? Using all of the [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) types may make this easier.</p>
</div>
<div class="paragraph">
<p>练习14.4 重写第2章的猜数游戏，得到三个秘密数字。这次提示有点棘手。如果任何一个秘密数字小于猜测的值，请告诉该人其中一个或一些较小。用更大的数字做同样的事情。对于单个猜测，一些数字可能更大而其他数字更小。当该人猜出所有秘密数字时，结束游戏。是否更容易使用 - <code>given-when</code> 或 <code>if</code>？使用所有 [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) 类型可以使这更容易。</p>
</div>
<div class="paragraph">
<p>[Table 14-1](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch14.html#camelia-junctions-TABLE-junctions" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch14.html#camelia-junctions-TABLE-junctions</a>) provides a summary of [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)s" class="bare">https://docs.raku.org/type/Junction.html)s</a>.</p>
</div>
<div class="paragraph">
<p>| Junction | Operator | Description                          |
| -------- | -------- | ------------------------------------ |
| <code>any</code>    | \|       | Any of the values will work.         |
| <code>all</code>    | &amp;        | All of the values must work.         |
| <code>one</code>    | ^        | Exactly one of the values will work. |
| <code>none</code>   |          | None of the values can work.         |</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sets">4.46. Sets</h3>
<div class="paragraph">
<p>[<code>Set</code>](<a href="https://docs.raku.org/type/Set.html)s" class="bare">https://docs.raku.org/type/Set.html)s</a> are another way to combine values. They aren’t like [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)s" class="bare">https://docs.raku.org/type/Junction.html)s</a>, where several values can act like one value; they combine zero or more values as its own thingy that you can inspect. Each value can be in the [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html)only" class="bare">https://docs.raku.org/type/Set.html)only</a> once (although there are weighted [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html)s" class="bare">https://docs.raku.org/type/Set.html)s</a> I won’t write about), and once created the [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) is fixed.</p>
</div>
<div class="paragraph">
<p>[<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) 是另一种组合值的方法。它们不像 [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)，其中几个值可以像一个值一样;它们将零个或多个值组合为你可以检查的自己的东西。每个值都只可以在" class="bare">https://docs.raku.org/type/Junction.html)，其中几个值可以像一个值一样;它们将零个或多个值组合为你可以检查的自己的东西。每个值都只可以在</a> [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) 中一次（虽然有加权集合我不会写），一旦创建了集合就固定了。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) is a type of [<code>Associative</code>](<a href="https://docs.raku.org/type/Associative.html" class="bare">https://docs.raku.org/type/Associative.html</a>), so many of the things you already know about those work on [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html)s" class="bare">https://docs.raku.org/type/Set.html)s</a>.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>集合是一种[关联](<a href="https://docs.raku.org/type/Associative.html)类型，因此你已经了解的很多关于">集合</a>(<a href="https://docs.raku.org/type/Set.html)的内容。" class="bare">https://docs.raku.org/type/Set.html)的内容。</a></p>
</div>
<div class="paragraph">
<p>You can create a [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) with a routine or a coercer. Each thingy in the [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>) is a member of the [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>). These are the same:</p>
</div>
<div class="paragraph">
<p>你可以使用例程或强制器创建[<code>集合</code>](<a href="https://docs.raku.org/type/Set.html)。" class="bare">https://docs.raku.org/type/Set.html)。</a> [<code>列表</code>](<a href="https://docs.raku.org/type/List.html)中的每个东西都是" class="bare">https://docs.raku.org/type/List.html)中的每个东西都是</a> [<code>集合</code>](<a href="https://docs.raku.org/type/Set.html)成员。这些都是一样的：" class="bare">https://docs.raku.org/type/Set.html)成员。这些都是一样的：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">set( 1, 2, 3 )
(1, 2, 3).Set</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can store any combination or mixture of thingys, including type objects:</p>
</div>
<div class="paragraph">
<p>你可以存储任何组合或混合物，包括类型对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">set( &lt;♠ ♣ ♥ ♦&gt; )
set( Int, 3, Inf, &#39;Hamadryas&#39;, $(1,2,3) )</code></pre>
</div>
</div>
<div class="paragraph">
<p>A [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) stores a thingy only once. It’s either in the [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) or it isn’t, so it doesn’t need duplicates:</p>
</div>
<div class="paragraph">
<p>[<code>集合</code>](<a href="https://docs.raku.org/type/Set.html)只存储一次东西。它可以在"><code>集合</code></a>(<a href="https://docs.raku.org/type/Set.html)中，也可以不在，因此不需要重复：" class="bare">https://docs.raku.org/type/Set.html)中，也可以不在，因此不需要重复：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put set( 1, 2, 3 ).elems;          # 3
put set( 1, 2, 2, 3, 3, 3 ).elems; # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can check that a value is in the [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) with the <code>(elem)</code> operator:</p>
</div>
<div class="paragraph">
<p>你可以使用`(elem)<code>运算符检查[`集合</code>](<a href="https://docs.raku.org/type/Set.html)中的值：" class="bare">https://docs.raku.org/type/Set.html)中的值：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $set = &lt;♠ ♣ ♥ ♦&gt;.Set;
put &#39;Number is in the set&#39; if &#39;♥&#39; (elem) $set;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s also the fancy Unicode <code>∈</code> operator that tests if the thingy is in the set (or is a “member” of the set):</p>
</div>
<div class="paragraph">
<p>还有花哨的 Unicode <code>∈</code> 运算符，它测试东西是否在集合中（或者是集合的“成员”）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Number is in the set&#39; if &#39;♥&#39; ∈ $set;</code></pre>
</div>
</div>
<div class="paragraph">
<p>These operators know that they need [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html)s" class="bare">https://docs.raku.org/type/Set.html)s</a>, so they coerce what you give them:</p>
</div>
<div class="paragraph">
<p>这些运算符知道他们需要[<code>集合</code>](<a href="https://docs.raku.org/type/Set.html)，所以他们强迫你给他们的东西：" class="bare">https://docs.raku.org/type/Set.html)，所以他们强迫你给他们的东西：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Number is in the set&#39; if &#39;♥&#39; ∈ &lt;♠ ♣ ♥ ♦&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With that operator the [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) is the second operand. The order of operands is reversed for the <code>(cont)</code> and <code>∋</code> operators. Now you test that a [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) contains an element:</p>
</div>
<div class="paragraph">
<p>使用该运算符，[<code>集合</code>](<a href="https://docs.raku.org/type/Set.html)是第二个操作数。对于`(cont" class="bare">https://docs.raku.org/type/Set.html)是第二个操作数。对于`(cont</a>)<code>和 `∋</code> 运算符，操作数的顺序是相反的。现在，你测试一个[<code>集合</code>](<a href="https://docs.raku.org/type/Set.html)包含一个元素：" class="bare">https://docs.raku.org/type/Set.html)包含一个元素：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Number is in the set&#39; if $set (cont) &#39;♥&#39;;
put &#39;Number is in the set&#39; if $set ∋ &#39;♥&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can test that a thingy is not a member of a [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) by either prefacing the ASCII operator with a <code>!</code> or using the Unicode version with the line through it:</p>
</div>
<div class="paragraph">
<p>你可以通过在 ASCII 操作符前面添加一个 <code>!</code> 来测试一个东西不是一个[<code>集合</code>](<a href="https://docs.raku.org/type/Set.html)的成员！或者使用带有直线穿过的Unicode" class="bare">https://docs.raku.org/type/Set.html)的成员！或者使用带有直线穿过的Unicode</a> 版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#39;Number is not in the set&#39; if &#39;♥&#39; !(elem) $set;
put &#39;Number is not in the set&#39; if &#39;♥&#39; ∉ $set;
put &#39;Number is not in the set&#39; if $set !(cont) &#39;♥&#39;;
put &#39;Number is not in the set&#39; if $set ∌ &#39;♥&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can compare [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html)s" class="bare">https://docs.raku.org/type/Set.html)s</a> to other [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html)s" class="bare">https://docs.raku.org/type/Set.html)s</a>. Another [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) that contains only some of the members is a subset. A “strict” or “proper” subset is one that is smaller than the [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) and only contains elements of the [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>). Another way to say that is a proper subset is always smaller. The <code>(&lt;)</code> (or <code>⊂</code>) operator does that with the opening of the angle toward the larger [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>). The order of elements does not matter:</p>
</div>
<div class="paragraph">
<p>你可以将[<code>集合</code>](<a href="https://docs.raku.org/type/Set.html)与其他"><code>集合</code></a>(<a href="https://docs.raku.org/type/Set.html)进行比较。另一个仅包含部分成员的"><code>集合</code></a>(<a href="https://docs.raku.org/type/Set.html)是子集。" class="bare">https://docs.raku.org/type/Set.html)是子集。</a> “严格”或“适当”子集是小于[<code>集合</code>](<a href="https://docs.raku.org/type/Set.html)的子集，仅包含"><code>集合</code></a>(<a href="https://docs.raku.org/type/Set.html)的元素。另一种说法是适当的子集总是更小。" class="bare">https://docs.raku.org/type/Set.html)的元素。另一种说法是适当的子集总是更小。</a> <code>(&lt;)</code>（或 <code>⊂</code>）运算符通过朝向较大的[<code>集合</code>](<a href="https://docs.raku.org/type/Set.html)开放角度来执行此操作。元素的顺序无关紧要：" class="bare">https://docs.raku.org/type/Set.html)开放角度来执行此操作。元素的顺序无关紧要：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">set( 1, 3  )    (&lt;) set( 1, 3, 7 );  # True
set( 3, 1, 7 )  (&lt;) set( 1, 3  );    # False (not smaller)
set( 5, 7 )     ⊂  set( 1, 3, 7 );   # False (5 not in set)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>!</code> in front of the ASCII operator or a line through the Unicode operator negates the condition:</p>
</div>
<div class="paragraph">
<p>ASCII 运算符前面的 <code>!</code> 或通过带有直线穿过的 Unicode 运算符否定条件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">set( 1, 3  )   !(&lt;)   set( 1, 3, 7 );  # False
set( 3, 1, 7 ) !(&lt;)   set( 1, 3  );    # True
set( 5, 7 )     ⊄    set( 1, 3, 7 );  # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use the <code>(&gt;=)</code> or <code>⊆</code> operators if you want to allow the [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html)s" class="bare">https://docs.raku.org/type/Set.html)s</a> to be the same size:</p>
</div>
<div class="paragraph">
<p>如果要允许[<code>集合</code>](<a href="https://docs.raku.org/type/Set.html)具有相同的大小，请使用（" class="bare">https://docs.raku.org/type/Set.html)具有相同的大小，请使用（</a><code>(&gt;=)</code> 或 <code>⊆</code> 运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">set( 1, 3  )   (&lt;=)  set( 1, 3, 7 );  # True
set( 1, 3, 7 ) (&lt;=)  set( 1, 3, 7 );  # True
set( 3, 1, 7 )  ⊆   set( 1, 3  );    # False (subset has 7)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Negate those in the same way:</p>
</div>
<div class="paragraph">
<p>以同样的方式否定这些：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">set( 1, 3  )   !(&lt;=)  set( 1, 3, 7 );  # False
set( 1, 3, 7 ) !(&lt;=)  set( 1, 3, 7 );  # False
set( 3, 1, 7 )   ⊈   set( 1, 3  );    # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also have supersets. That’s just a matter of which one you allow to be the larger [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>). So far you’ve seen examples where you expected the larger [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) to be to the right of the operator. Flip those operators around so you expect the larger [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) to be on the left:</p>
</div>
<div class="paragraph">
<p>你也可以有超集。这只是一个你允许成为更大的[<code>集合</code>](<a href="https://docs.raku.org/type/Set.html)的问题。到目前为止，你已经看到过你希望较大的"><code>集合</code></a>(<a href="https://docs.raku.org/type/Set.html)位于运算符右侧的示例。翻转这些运算符，以便你希望较大的"><code>集合</code></a>(<a href="https://docs.raku.org/type/Set.html)位于左侧：" class="bare">https://docs.raku.org/type/Set.html)位于左侧：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">set( 3, 1, 7 )  (&gt;) set( 1, 3  );    # False (not smaller)
set( 3, 1, 7 )  ⊃   set( 1, 3  );    # False (not smaller)

set( 3, 1, 7 ) !(&gt;)   set( 1, 3  );    # True
set( 3, 1, 7 )  ⊅    set( 1, 3  );    # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>[Table 14-2](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch14.html#camelia-junctions-TABLE-set-operations" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch14.html#camelia-junctions-TABLE-set-operations</a>) shows the rest of the [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) operations.</p>
</div>
<div class="paragraph">
<p>| Operation              | Operator | Code number | Description                                               |
| ---------------------- | -------- | ----------- | --------------------------------------------------------- |
| <code>$a (elem) $set</code>       | ∈        | U+2208      | <code>$a</code> is a member of <code>$set</code>                                |
| <code>$a !(elem) $set</code>      | ∉        | U+2209      | <code>$a</code> is not a member of <code>$set</code>                            |
| <code>$set (cont) $a</code>       | ∋        | U+220B      | <code>$set</code> contains <code>$a</code>                                      |
| <code>$set !(cont) $a</code>      | ∌        | U+220C      | <code>$set</code> does not contain <code>$a</code>                              |
| <code>$set-a (&lt;) $set-b</code>    | ⊂        | U+2282      | <code>$set-a</code> is a proper subset of <code>$set-b</code>                   |
| <code>$set-a !(&lt;) $set-b!</code>  | ⊄        | U+2284      | <code>$set-a</code> is not a proper subset of <code>$set-b</code>               |
| <code>$set-a (⇐) $set-b!</code>  | ⊆        | U+2286      | <code>$set-a</code> is the same or is a subset of <code>$set-b</code>           |
| <code>$set-a !(⇐) $set-b!</code> | ⊈        | U+2288      | <code>$set-a</code> is not the same and isn’t a subset of <code>$set-b</code>   |
| <code>$set-a (&gt;) $set-b!</code>   | ⊃        | U+2283      | <code>$set-a</code> is a proper superset of <code>$set-b</code>                 |
| <code>$set-a !(&gt;) $set-b!</code>  | ⊅        | U+2285      | <code>$set-a</code> is not a proper superset of <code>$set-b</code>             |
| <code>$set-a (&gt;=) $set-b!</code>  | ⊇        | U+2287      | <code>$set-a</code> is the same or is a superset of <code>$set-b</code>         |
| <code>$set-a !(&gt;=) $set-b!</code> | ⊉        | U+2289      | <code>$set-a</code> is not the same and isn’t a superset of <code>$set-b</code> |</p>
</div>
<div class="paragraph">
<p>EXERCISE 14.5In [Chapter 9](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch09.html#camelia-hashes" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch09.html#camelia-hashes</a>) you used a [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) to check allowed values. Do the same thing with a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>). Prompt for some starting colors (perhaps all on one line that you break up into elements). Continue to prompt for colors and report if the color was one of the initial colors. Can you do this ignoring case?</p>
</div>
<div class="paragraph">
<p>练习14.5 在第9章中，你使用了 [<code>Map</code>](<a href="https://docs.raku.org/type/Map.html" class="bare">https://docs.raku.org/type/Map.html</a>) 来检查允许的值。用[<code>列表</code>](<a href="https://docs.raku.org/type/List.html)做同样的事情。提示一些起始颜色（可能在一行中分解为元素）。继续提示颜色并报告颜色是否为初始颜色之一。你能忽略这个案子吗？" class="bare">https://docs.raku.org/type/List.html)做同样的事情。提示一些起始颜色（可能在一行中分解为元素）。继续提示颜色并报告颜色是否为初始颜色之一。你能忽略这个案子吗？</a></p>
</div>
<div class="sect3">
<h4 id="_set_operations">4.46.1. Set Operations</h4>
<div class="paragraph">
<p>You can operate on two [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html)s" class="bare">https://docs.raku.org/type/Set.html)s</a> to create new [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html)s" class="bare">https://docs.raku.org/type/Set.html)s</a>. A union is a combination of two [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html)s" class="bare">https://docs.raku.org/type/Set.html)s</a>. Each element still shows up only once:</p>
</div>
<div class="paragraph">
<p>你可以操作两个[<code>集合</code>](<a href="https://docs.raku.org/type/Set.html)来创建新"><code>集合</code></a>(<a href="https://docs.raku.org/type/Set.html)。并集是两个"><code>集合</code></a>(<a href="https://docs.raku.org/type/Set.html)的组合。每个元素仍然只显示一次：" class="bare">https://docs.raku.org/type/Set.html)的组合。每个元素仍然只显示一次：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">set(1,2) (|) set(3,7);  # set(1 2 3 7)
set(1,2)  ∪  set(3,7);  # set(1 2 3 7)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The intersection makes the [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) of the elements they have in common:</p>
</div>
<div class="paragraph">
<p>交集制作一个它们共有的元素[<code>集合</code>](<a href="https://docs.raku.org/type/Set.html)：" class="bare">https://docs.raku.org/type/Set.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">set(1,3) (&amp;) set(3,7);  # set(3)
set(1,2)  ∩  set(3,7);  # set()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The set difference creates a [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) made up of the elements from the first [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) that aren’t in the second. The `∖`isn’t the ASCII backslash; it’s (U+2216 SET MINUS):</p>
</div>
<div class="paragraph">
<p>差集创建一个由第一个[<code>集合</code>](<a href="https://docs.raku.org/type/Set.html)中不在第二个"><code>集合</code></a>(<a href="https://docs.raku.org/type/Set.html)中的元素组成的"><code>集合</code></a>(<a href="https://docs.raku.org/type/Set.html)。" class="bare">https://docs.raku.org/type/Set.html)。</a> <code>∖</code> 不是 ASCII 反斜杠; 它是（U+2216 SET MINUS）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">set( &lt;a b&gt; ) (-) set( &lt;b c&gt; );  # set(a)
set( &lt;A b&gt; )  ∖  set( &lt;x y&gt; );  # set(A b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The symmetric set difference does a similar thing in both directions. It creates a [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) containing all the elements of either [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) that don’t show up in the other:</p>
</div>
<div class="paragraph">
<p>对称差集在两个方向上做类似的事情。它创建一个[<code>集合</code>](<a href="https://docs.raku.org/type/Set.html)，其中包含任何"><code>集合</code></a>(<a href="https://docs.raku.org/type/Set.html)中未显示在另一个"><code>集合</code></a>(<a href="https://docs.raku.org/type/Set.html)中的所有元素：" class="bare">https://docs.raku.org/type/Set.html)中的所有元素：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">set( &lt;a b&gt; ) (^) set( &lt;b c&gt; );  # set(a c)
set( &lt;A b&gt; )  ⊖  set( &lt;x y&gt; );  # set(A b x y)</code></pre>
</div>
</div>
<div class="paragraph">
<p>These operations are summarized in [Table 14-3](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch14.html#camelia-junctions-TABLE-set-creators" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch14.html#camelia-junctions-TABLE-set-creators</a>).</p>
</div>
<div class="paragraph">
<p>| Operation | Operator | Code number | Description              |
| --------- | -------- | ----------- | ------------------------ |
| (\|)      | ∪        | U+222A      | Union (combination)      |
| (&amp;)       | ∩        | U+2229      | Intersection (overlap)   |
| (-)       | ∖        | U+2216      | Set difference           |
| (^)       | ⊖        | U+2296      | Symmetric set difference |</p>
</div>
<div class="paragraph">
<p>EXERCISE 14.6Create two [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html)s" class="bare">https://docs.raku.org/type/Set.html)s</a> of 10 numbers between 1 and 50. Find their intersection and union.</p>
</div>
<div class="paragraph">
<p>练习14.6在1到50之间创建两组10个数字。找到它们的交集和联合。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_summary_8">4.47. Summary</h3>
<div class="paragraph">
<p>[<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)s" class="bare">https://docs.raku.org/type/Junction.html)s</a> make several values pretend to be a single value, in such a way that you can’t tell which value it is or how many values there are. You create the [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>) in a way that makes the values all work together or separately. A [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html" class="bare">https://docs.raku.org/type/Set.html</a>) also combines values but lets you look inside to see what those values are. You can combine [<code>Set</code>](<a href="https://docs.raku.org/type/Set.html)s" class="bare">https://docs.raku.org/type/Set.html)s</a> in various ways to create new ones. This is handy to tell what’s in, out, or common.</p>
</div>
<div class="paragraph">
<p>[<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)使多个值假装成单个值，这样你就无法判断它是哪个值或者有多少个值。你可以通过使值全部一起或单独工作的方式创建" class="bare">https://docs.raku.org/type/Junction.html)使多个值假装成单个值，这样你就无法判断它是哪个值或者有多少个值。你可以通过使值全部一起或单独工作的方式创建</a> [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html)。" class="bare">https://docs.raku.org/type/Junction.html)。</a> [<code>集合</code>](<a href="https://docs.raku.org/type/Set.html)还可以组合值，但是让你查看这些值是什么。你可以通过各种方式组合"><code>集合</code></a>(<a href="https://docs.raku.org/type/Set.html)来创建新的"><code>集合</code></a>(<a href="https://docs.raku.org/type/Set.html)。这可以很方便地分辨出进出的内容。" class="bare">https://docs.raku.org/type/Set.html)。这可以很方便地分辨出进出的内容。</a>
== 正则表达式</p>
</div>
<div class="paragraph">
<p>Regular expressions (or <strong>regexes</strong>) are patterns that describe a possible set of matching texts. They are a little language of their own, and many characters have a special meaning inside patterns. They may look cryptic at first, but after you learn them you have quite a bit of power.</p>
</div>
<div class="paragraph">
<p>Forget what you’ve seen about patterns in other languages. The Raku pattern syntax started over. It’s less compact but also more powerful. In some cases it acts a bit differently.</p>
</div>
<div class="paragraph">
<p>This chapter shows simple patterns that match particular characters or sets of characters. It’s just the start. In [Chapter 16](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch16.html#camelia-regex2" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch16.html#camelia-regex2</a>) you’ll see fancier patterns and the side effects of matching. In [Chapter 17](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch17.html#camelia-grammars" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch17.html#camelia-grammars</a>) you’ll take it all to the next level.</p>
</div>
<div class="paragraph">
<p>正则表达式（或正则表达式）是描述可能的匹配文本集的模式。它们是自己的一种语言，许多字符在模式中具有特殊含义。它们起初可能看起来很神秘，但是在你学习它们之后你会有相当大的力量。</p>
</div>
<div class="paragraph">
<p>忘记你在其他语言中看到的关于模式的内容。 Raku模式语法重新开始。它不那么紧凑，但也更强大。在某些情况下，它的作用有点不同。</p>
</div>
<div class="paragraph">
<p>本章介绍与特定字符或字符集匹配的简单模式。这只是一个开始。在第16章中，你将看到更漂亮的模式和匹配的副作用。在第17章中，你将把它全部提升到一个新的水平。</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_match_operator">4.48. The Match Operator</h3>
<div class="paragraph">
<p>A pattern describes a set of text values. The simple pattern <code>abc</code> describes all the values that have an <code>a</code> next to a <code>b</code> next to a <code>c</code>. The trick then is to decide if a particular value is in the set of matching values. There are no half or partial matches; it matches or it doesn’t.</p>
</div>
<div class="paragraph">
<p>A pattern inside <code>m/…​/</code> immediately applies itself to the value in <code>$_</code>. If the pattern is in the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) the match operator returns something that evaluates to <code>True</code> in a condition:</p>
</div>
<div class="paragraph">
<p>模式描述了一组文本值。简单模式abc描述了c旁边的b旁边的所有值。然后，技巧是确定特定值是否在匹配值集合中。没有半场比赛或部分比赛;它匹配或不匹配。</p>
</div>
<div class="paragraph">
<p>m /…​/中的模式立即将其自身应用于$ _中的值。如果模式在Str中，则匹配运算符返回在条件中评估为True的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas&#39;;
if m/Hama/ { put &#39;It matched!&#39;; }
else       { put &#39;It missed!&#39;;  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s a bit verbose. The conditional operator takes care of that:</p>
</div>
<div class="paragraph">
<p>这有点冗长。条件运算符负责：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put m/Hama/ ?? &#39;It matched!&#39; !! &#39;It missed!&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You don’t have to match against <code>$_</code>. You can use the smart match to apply it to a different value. That’s the target:</p>
</div>
<div class="paragraph">
<p>你不必匹配$ _。你可以使用智能匹配将其应用于其他值。这是目标：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $genus = &#39;Hamadryas&#39;;
put $genus ~~ m/Hama/ ?? &#39;It matched!&#39; !! &#39;It missed!&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That target could be anything, including an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) or [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>). These match a single item:</p>
</div>
<div class="paragraph">
<p>该目标可以是任何东西，包括数组或哈希。这些匹配单个项目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$genus                ~~ m/Hama/;
@animals[0]           ~~ m/Hama/;
%butterfly&lt;Hamadryas&gt; ~~ m/perlicus/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>But you can also match against multiple items. The object on the left side of the smart match decides how the pattern applies to the object. This matches if any of the elements in <code>@animals</code> matches:</p>
</div>
<div class="paragraph">
<p>但你也可以匹配多个项目。智能匹配左侧的对象决定模式如何应用于对象。如果@animals中的任何元素匹配，则匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if @animals ~~ m/Hama/ {
    put &#34;Matches at least one animal&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the same as matching against a [<code>Junction</code>](<a href="https://docs.raku.org/type/Junction.html" class="bare">https://docs.raku.org/type/Junction.html</a>):</p>
</div>
<div class="paragraph">
<p>这与针对Junction的匹配相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if any(@animals) ~~ m/Hama/ {
    put &#34;Matches at least one animal&#34;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The match operator is commonly used in the condition inside a <code>.grep</code>:</p>
</div>
<div class="paragraph">
<p>匹配运算符通常用于.grep中的条件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @hama-animals = @animals.grep: /Hama/;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_match_operator_syntax">4.48.1. Match Operator Syntax</h4>
<div class="paragraph">
<p>The match operator can use alternate delimiters, similar to the quoting mechanism:</p>
</div>
<div class="paragraph">
<p>匹配运算符可以使用备用分隔符，类似于引用机制：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">m{Hama}
m!Hama!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Whitespace inside the match operator doesn’t matter. It’s not part of the pattern (until you say so, as you’ll see later). All of these are the same, including the last example with vertical whitespace:</p>
</div>
<div class="paragraph">
<p>匹配运算符内的空格并不重要。它不是模式的一部分（直到你这么说，你将在后面看到）。所有这些都是相同的，包括最后一个带有垂直空格的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">m/ Hama /
m{ Hama }
m! Hama !
m/
    Hama
/</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can put spaces between alphabetic characters, but you’ll probably get a warning because Raku wants you to put those together:</p>
</div>
<div class="paragraph">
<p>你可以在字母字符之间放置空格，但你可能会收到警告，因为Raku希望你将它们放在一起：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">m/ Ha ma /</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want a literal space inside the match operator you can escape it (along with other things you’ll see later):</p>
</div>
<div class="paragraph">
<p>如果你想在匹配运算符中使用文字空间，你可以将其转义（以及稍后你会看到的其他内容）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">m/ Ha\ ma /</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quoting whitespace makes it literal too (the space around the quoted whitespace is still insignificant), or you can quote it all together:</p>
</div>
<div class="paragraph">
<p>引用空格也使它成为字面值（引用的空格周围的空间仍然无关紧要），或者你可以将它们全部引用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">m/ Ha &#39; &#39; ma /
m/ &#39;Ha ma&#39; /</code></pre>
</div>
</div>
<div class="paragraph">
<p>You need to quote or escape any character that’s not alphabetic or a number, even if those characters aren’t “special.” The other unquoted characters may be metacharacters that have special meaning in the pattern language.</p>
</div>
<div class="paragraph">
<p>你需要引用或转义任何非字母或数字的字符，即使这些字符不是“特殊”。其他未加引号的字符可能是在模式语言中具有特殊含义的元字符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_successful_matches">4.48.2. Successful Matches</h4>
<div class="paragraph">
<p>If the match operator succeeds it returns a [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) object, which is always a <code>True</code> value. If you <code>put</code> that object it shows you the part of the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) that matched. The <code>say</code> calls <code>.gist</code> and the output is a bit different:</p>
</div>
<div class="paragraph">
<p>如果匹配运算符成功，则返回Match对象，该对象始终为True值。如果你放置该对象，它会向你显示匹配的Str部分。说调用.gist和输出有点不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas&#39;;
my $match = m/Hama/;
put $match; # Hama
say $match; # ?Hama?</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output of <code>say</code> gets interesting as the patterns get more complicated. That makes it useful for the regex chapters, and you’ll see more of that here compared to the rest of the book.</p>
</div>
<div class="paragraph">
<p>If the match does not succeed it returns [<code>Nil</code>](<a href="https://docs.raku.org/type/Nil.html" class="bare">https://docs.raku.org/type/Nil.html</a>), which is always <code>False</code>:</p>
</div>
<div class="paragraph">
<p>随着模式变得更加复杂，say的输出变得有趣。这使得它对正则表达式章节很有用，并且与本书的其余部分相比，你将在这里看到更多。</p>
</div>
<div class="paragraph">
<p>如果匹配不成功，则返回Nil，它始终为False：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas&#39;;
my $match = m/Hama/;
put $match.^name;    # Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>It’s usually a good idea to check the result before you do anything with it:</p>
</div>
<div class="paragraph">
<p>在对它做任何事情之前检查结果通常是个好主意：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if my $match = m/Hama/ { # matched
    say $match;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You don’t need the <code>$match</code> variable though. The result of the last match shows up in the special variable <code>$/</code>, which you’ll see more of later:</p>
</div>
<div class="paragraph">
<p>你不需要 <code>$match</code> 变量。最后一个匹配的结果显示在特殊变量$ /中，稍后你会看到更多：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if m/Hama/ { # matched
    say $/;
    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_a_pattern">4.48.3. Defining a Pattern</h4>
<div class="paragraph">
<p>Useful patterns can get quite long and unwieldy. Use <code>rx//</code> to define a pattern (a [<code>Regex</code>](<a href="https://docs.raku.org/type/Regex.html)" class="bare">https://docs.raku.org/type/Regex.html)</a>) for later use. This pattern is not immediately applied to any target. This allows you to define a pattern somewhere that doesn’t distract from what you are doing:</p>
</div>
<div class="paragraph">
<p>有用的模式可能会变得非常冗长和笨拙。使用rx //定义模式（正则表达式）供以后使用。此模式不会立即应用于任何目标。这允许你在某个地方定义一个不会分散你正在做的事情的模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $genus = &#39;Hamadryas&#39;;
my $pattern = rx/ Hama /; # something much more complicated
$genus ~~ $pattern;</code></pre>
</div>
</div>
<div class="paragraph">
<p>and reuse the pattern wherever you need it:</p>
</div>
<div class="paragraph">
<p>并在任何需要的地方重用模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for lines() -&gt; $line {
    put $line if $line ~~ $pattern;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>It’s possible to combine saved patterns into a larger one. This allows you to decompose complicated patterns into smaller, more tractable ones that you can reuse later (which you’ll do extensively in [Chapter 17](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch17.html#camelia-grammars)" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch17.html#camelia-grammars)</a>):</p>
</div>
<div class="paragraph">
<p>可以将保存的模式组合成更大的模式。这允许你将复杂的模式分解为更小，更易处理的模式，以后可以重复使用（你将在第17章中进行广泛的讨论）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $genus = &#39;Hamadryas&#39;;

my $hama  = rx/Hama/;
my $dryas = rx/dryas/;
my $match = $genus ~~ m/$hama$dryas/;

say $match;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rather than storing a variable in an object, declare a lexical pattern with <code>regex</code>. This looks like a subroutine because it has a [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) but it’s not code inside; it’s a pattern and uses that slang:</p>
</div>
<div class="paragraph">
<p>不是将变量存储在对象中，而是使用正则表达式声明词法模式。这看起来像一个子程序，因为它有一个Block，但它不是代码;这是一种模式并使用俚语：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex hama { Hama }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use this in a pattern by surrounding it with angle brackets:</p>
</div>
<div class="paragraph">
<p>通过用尖括号包围它，在图案中使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $genus = &#39;Hamadryas&#39;;
put $genus ~~ m/&lt;hama&gt;/ ?? &#39;It matched!&#39; !! &#39;It missed!&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can define multiple named regexes and use them together:</p>
</div>
<div class="paragraph">
<p>你可以定义多个已命名的正则表达式并将它们一起使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex hama  { Hama }
my regex dryas { dryas }

$_ = &#39;Hamadryas&#39;;
say m/&lt;hama&gt;&lt;dryas&gt;/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each named regex becomes a submatch. You can see the structure when you output it with <code>say</code>. It shows the overall result and the results of the subpatterns too:</p>
</div>
<div class="paragraph">
<p>每个命名的正则表达式都成为一个子匹配。用say输出它时可以看到结构。它还显示了整个结果和子模式的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">?Hamadryas?
 hama =&gt; ?Hama?
 dryas =&gt; ?dryas?</code></pre>
</div>
</div>
<div class="paragraph">
<p>Treat the [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) object like a [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) (although it isn’t) to get the parts that matched the named regexes. The name of the regex is the “key”:</p>
</div>
<div class="paragraph">
<p>将Match对象视为Hash（尽管不是），以获得与命名正则表达式匹配的部分。正则表达式的名称是“关键”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas&#39;;
my $result =  m/&lt;hama&gt;&lt;dryas&gt;/;

if $result {
    put &#34;First: $result&lt;hama&gt;&#34;;
    put &#34;Second: $result&lt;dryas&gt;&#34;;
    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_predefined_patterns">4.48.4. Predefined Patterns</h4>
<div class="paragraph">
<p>[Table 15-1](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1-TABLE-predefined_patterns" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1-TABLE-predefined_patterns</a>) shows several of the predefined patterns that are ready for you to use. You can define your patterns in a library and export them just like you could with subroutines:</p>
</div>
<div class="paragraph">
<p>[表15-1](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1-TABLE-predefined_patterns)显示了几个准备好的预定义模式供你使用。你可以在库中定义模式，并像子程序一样导出它们：" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1-TABLE-predefined_patterns)显示了几个准备好的预定义模式供你使用。你可以在库中定义模式，并像子程序一样导出它们：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Patterns.pm6
my regex hama is export { Hama }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Load the module and those named regexes are available to your patterns:</p>
</div>
<div class="paragraph">
<p>加载模块和那些名为正则表达式的模式可用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use lib &lt;.&gt;;
use Hama;

$_ = &#39;Hamadryas&#39;;
say m/ &lt;hama&gt; /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>| Predefined pattern | What it matches                                              |
| ------------------ | ------------------------------------------------------------ |
| <code>&lt;alnum&gt;</code>          | Alphabetic and digit characters                              |
| <code>&lt;alpha&gt;</code>          | Alphabetic characters                                        |
| <code>&lt;ascii&gt;</code>          | Any ASCII character                                          |
| <code>&lt;blank&gt;</code>          | Horizontal whitespace                                        |
| <code>&lt;cntrl&gt;</code>          | Control characters                                           |
| <code>&lt;digit&gt;</code>          | Decimal digits                                               |
| <code>&lt;graph&gt;</code>          | <code>&lt;alnum&gt;</code> + <code>&lt;punct&gt;</code>                                        |
| <code>&lt;ident&gt;</code>          | A valid identifier character                                 |
| <code>&lt;lower&gt;</code>          | Lowercase characters                                         |
| <code>&lt;print&gt;</code>          | <code>&lt;graph&gt;</code> + <code>&lt;space&gt;</code>, but without <code>&lt;cntrl&gt;</code>                 |
| <code>&lt;punct&gt;</code>          | Punctuation and symbols beyond ASCII                         |
| <code>&lt;space&gt;</code>          | Whitespace                                                   |
| <code>&lt;upper&gt;</code>          | Uppercase characters                                         |
| <code>&lt;|wb&gt;</code>            | Word boundary (an assertion rather than a character)         |
| <code>&lt;word&gt;</code>           | <code>&lt;alnum&gt;</code> + Unicode marks + connectors, like ‘_’ (extra)     |
| <code>&lt;ws&gt;</code>             | Whitespace (required between word characters, optional otherwise) |
| <code>&lt;ww&gt;</code>             | Within a word (an assertion rather than a character)         |
| <code>&lt;xdigit&gt;</code>         | Hexadecimal digits <code>[0-9A-Fa-f]</code>                             |</p>
</div>
<div class="paragraph">
<p>EXERCISE 15.1Create a program that uses a regular expression to output all of the matching lines from the files you specify on the command line.</p>
</div>
<div class="paragraph">
<p>练习15.1创建一个程序，该程序使用正则表达式输出你在命令行中指定的文件中的所有匹配行。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_matching_nonliteral_characters">4.49. Matching Nonliteral Characters</h3>
<div class="paragraph">
<p>You don’t have to literally type a character to match it. You might have an easier time specifying its code point or name. You can use the same <code>\x[<strong>CODEPOINT</strong>]</code> or <code>\c[<strong>NAME</strong>]</code> that you saw in double-quoted [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> in [Chapter 4](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch04.html#camelia-strings" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch04.html#camelia-strings</a>).</p>
</div>
<div class="paragraph">
<p>If you specify a name it must be all uppercase.</p>
</div>
<div class="paragraph">
<p>You could match the initial capital <strong>H</strong> by name, even though you have to type a literal <code>H</code> in the name:</p>
</div>
<div class="paragraph">
<p>你不必逐字输入匹配它的字符。你可以更轻松地指定其代码点或名称。你可以使用在第4章中双引号Strs中看到的相同\ x [* CODEPOINT <strong>]或\ c [</strong> NAME *]。</p>
</div>
<div class="paragraph">
<p>如果指定名称，则必须全部为大写。</p>
</div>
<div class="paragraph">
<p>你可以按名称匹配初始大写字母H，即使你必须在名称中键入文字H：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/
     \c[LATIN CAPITAL LETTER H] ama
    /;
$_ = &#34;Hamadryas&#34;;

put $pattern ?? &#39;Matched!&#39; !! &#39;Missed!&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can do the same thing with the code point. If you specify a code point use the hexadecimal number (with either case):</p>
</div>
<div class="paragraph">
<p>你可以使用代码点执行相同的操作。如果指定代码点，请使用十六进制数字（两种情况）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/
     \x[48] ama
    /;
$_ = &#34;Hamadryas&#34;;

put $pattern ?? &#39;Matched!&#39; !! &#39;Missed!&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This makes more sense if you want to match a character that’s either hard to type or hard to read. If the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) has the 🐱 character (U+1F431 CAT FACE), you might not be able to distinguish that from 😸 (U+1F638 GRINNING CAT FACE WITH SMILING EYES) without looking very closely. Instead of letting another programmer mistake your intent, you can use the name to save some eyestrain:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/
     \c[CAT FACE]  # or \x[1F431]
    /;
$_ = &#34;This is a catface: 🐱&#34;;
put $pattern ?? &#39;Matched!&#39; !! &#39;Missed!&#39;;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_matching_any_character">4.49.1. Matching Any Character</h4>
<div class="paragraph">
<p>Patterns have <strong>metacharacters</strong> that match something other than their literal selves. Some of these are listed in [Table 15-2](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1-TABLE-chars_to_escape" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1-TABLE-chars_to_escape</a>) (and most you won’t see in this chapter). The <code>.</code> matches any character (<strong>including</strong> a newline). This pattern matches any target that has at least one character:</p>
</div>
<div class="paragraph">
<p>模式具有与其文字自我匹配的元字符。其中一些列在表15-2中（大多数情况下，你不会在本章中看到）。这个。匹配任何字符（包括换行符）。此模式匹配具有至少一个字符的任何目标：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">m/ . /</code></pre>
</div>
</div>
<div class="paragraph">
<p>To match a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) with an <strong>a</strong> and a <strong>c</strong> separated by a character, put the dot between them in the pattern. This skips the lines that don’t match that pattern:</p>
</div>
<div class="paragraph">
<p>要将Str与由字符分隔的a和c匹配，请在模式中将它们放在它们之间。这会跳过与该模式不匹配的行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for lines() {
    next unless m/a.c/;
    .put
    }</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_escaping_characters">ESCAPING CHARACTERS</h5>
<div class="paragraph">
<p>Some characters have special meaning in patterns. The colon introduces an adverb and the <code>#</code> starts a comment. To match those as literal characters you need to escape them. A backslash will do:</p>
</div>
<div class="paragraph">
<p>有些字符在模式中有特殊含义。冒号引入了一个副词，＃开始发表评论。要将它们作为文字字符进行匹配，你需要将它们转义。反斜杠可以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/ \# \: Hama \. /</code></pre>
</div>
</div>
<div class="paragraph">
<p>This means to match a literal backslash, you need to escape that too:</p>
</div>
<div class="paragraph">
<p>这意味着匹配文字反斜杠，你也需要逃避它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/ \# \: Hama \\ /</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can do the same thing with the other pattern metacharacters. To match a literal dot, escape it:</p>
</div>
<div class="paragraph">
<p>你可以使用其他模式元字符执行相同的操作。要匹配文字点，请将其转义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/ \. /</code></pre>
</div>
</div>
<div class="paragraph">
<p>The backslash only escapes the character that comes immediately after it. You can’t escape a literal space character, and you can’t escape a character that isn’t special. [Table 15-2](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1-TABLE-chars_to_escape" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1-TABLE-chars_to_escape</a>) shows what you need to escape, even though I haven’t shown you most of those features yet.</p>
</div>
<div class="paragraph">
<p>反斜杠只会逃避紧随其后的字符。你无法转义文字空格字符，也无法转义不特殊的字符。表15-2显示了你需要逃脱的内容，即使我还没有向你展示大部分功能。</p>
</div>
<div class="paragraph">
<p>| Metacharacter               | Why it’s special                           |
| --------------------------- | ------------------------------------------ |
| <code>#</code>                         | Starts a comment                           |
| <code>\</code>                         | Escapes the next character or a shortcut   |
| <code>.</code>                         | Matches any character                      |
| <code>:</code>                         | Starts an adverb, or prevents backtracking |
| <code>(</code> and <code>)</code>                 | Starts a capture                           |
| <code>&lt;</code> and <code>&gt;</code>                 | Used to create higher-level thingys        |
| <code>[</code>, <code>]</code>, and <code>&#39;</code>           | Used for grouping                          |
| <code>+</code>, <code>|</code>, <code>&amp;</code>, <code>-</code>, and <code>^</code> | Set operations                             |
| <code>?</code>, <code>*</code>, <code>+</code>, and <code>%</code>      | Quantifiers                                |
| <code>|</code>                         | Alternation                                |
| <code>^</code> and <code>$</code>                 | Anchors                                    |
| <code>$</code>                         | Starts a variable or named capture         |
| <code>=</code>                         | Assigns to named captures                  |</p>
</div>
<div class="paragraph">
<p>Characters inside quotes are always their literal selves:</p>
</div>
<div class="paragraph">
<p>引号内的字符总是它们的文字自我：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/ &#39;#:Hama&#39; \\ /</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can’t use the single quotes to escape the backslash since a single backslash will still try to escape the character that comes after it.</p>
</div>
<div class="paragraph">
<p>你不能使用单引号来转义反斜杠，因为单个反斜杠仍会尝试转义后面的字符。</p>
</div>
</div>
<div class="sect4">
<h5 id="_matching_literal_spaces">MATCHING LITERAL SPACES</h5>
<div class="paragraph">
<p>You have a tougher time if you want to match literal spaces. You can’t escape a space with <code>\</code> because unspace isn’t allowed in a pattern. Instead, put quotes around the literal space:</p>
</div>
<div class="paragraph">
<p>如果你想匹配文字空间，你会有更艰难的时间。你无法使用\来转义空格，因为模式中不允许使用空格。相反，在文字空间周围加上引号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/ Hamadryas &#39; &#39; laodamia /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or put the entire sequence in quotes:</p>
</div>
<div class="paragraph">
<p>或者将整个序列放在引号中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/ &#39;Hamadryas laodamia&#39; /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Those single quotes can quickly obscure what belongs where; it can be helpful to spread the pattern across lines and note what you are trying to do:</p>
</div>
<div class="paragraph">
<p>那些单引号很快就会模糊属于哪里;将图案分布在线条上并记下你要做的事情会很有帮助：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/
    Hamadryas    # genus
    &#39; &#39;            # literal space
    laodamia     # species
    /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can make whitespace significant with the <code>:s</code> adverb:</p>
</div>
<div class="paragraph">
<p>你可以使用：s副词使空白显着：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx:s/ Hamadryas laodamia /;

my $pattern = rx/ :s Hamadryas laodamia /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>:s</code> is the short form of <code>:sigspace</code>:</p>
</div>
<div class="paragraph">
<p><code>:s</code> 是 sigspace 的缩写形式：sigspace：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx:sigspace/ Hamadryas laodamia /;

my $pattern = rx/ :sigspace Hamadryas laodamia /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that this will match <code>Hamadryas laodamia</code>, even though the pattern has whitespace at the beginning and end. The <code>:s</code> turns the whitespace in the pattern into a subrule <code>&lt;.ws&gt;</code>:</p>
</div>
<div class="paragraph">
<p>请注意，这将匹配Hamadryas laodamia，即使该模式在开头和结尾都有空格。 ：s将模式中的空格转换为子规则&lt;.ws&gt;：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas laodamia&#39;;
my $pattern = rx/ Hamadryas &lt;.ws&gt; laodamia /;
if m/$pattern/ {
    say $/;  # ?Hamadryas laodamia?
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can combine adverbs, but they each get their own colon. Order does not matter. This pattern has significant whitespace and is case insensitive:</p>
</div>
<div class="paragraph">
<p>你可以结合副词，但每个副词都有自己的冒号。订单无关紧要。此模式具有重要的空白并且不区分大小写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx:s:i/ Hamadryas Laodamia /;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_matching_types_of_characters">4.49.2. Matching Types of Characters</h4>
<div class="paragraph">
<p>So far, you’ve matched literal characters. You typed out the characters you wanted, and escaped them in some cases. There are some sets of characters that are so common they get shortcuts. These start with a backslash followed by a letter that connotes the set of characters. [Table 15-3](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1-TABLE-character_class_shortcuts" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1-TABLE-character_class_shortcuts</a>) shows the list of shortcuts.</p>
</div>
<div class="paragraph">
<p>If you want to match any digit, you can use <code>\d</code>. This matches anything that is a digit, not just the Arabic digits:</p>
</div>
<div class="paragraph">
<p>到目前为止，你已经匹配了字面字符。你键入了所需的字符，并在某些情况下将其转义。有一些字符组很常见，它们可以获得快捷方式。它们以反斜杠开头，后跟一个表示字符集的字母。表15-3显示了快捷方式列表。</p>
</div>
<div class="paragraph">
<p>如果要匹配任何数字，可以使用\ d。这匹配任何数字，而不仅仅是阿拉伯数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ \d /</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each of these shortcuts comes with a complement. <code>\D</code> matches any nondigit.</p>
</div>
<div class="paragraph">
<p>这些快捷方式中的每一个都有补充。 \ D匹配任何非数字。</p>
</div>
<div class="paragraph">
<p>| Shortcut | Characters that match                            |
| -------- | ------------------------------------------------ |
| <code>\d</code>     | Digits (Unicode property <code>N</code> )                   |
| <code>\D</code>     | Anything that isn’t a digit                      |
| <code>\w</code>     | Word characters: letters, digits, or underscores |
| <code>\W</code>     | Anything that isn’t a word character             |
| <code>\s</code>     | Any kind of whitespace                           |
| <code>\S</code>     | Anything that isn’t whitespace                   |
| <code>\h</code>     | Horizontal whitespace                            |
| <code>\H</code>     | Anything that isn’t horizontal whitespace        |
| <code>\v</code>     | Vertical whitespace                              |
| <code>\V</code>     | Anything that isn’t vertical whitespace          |
| <code>\t</code>     | A tab character (specifically, only U+0009)      |
| <code>\T</code>     | Anything that isn’t a tab character              |
| <code>\n</code>     | A newline or carriage return/newline pair        |
| <code>\N</code>     | Anything that isn’t a newline                    |</p>
</div>
<div class="paragraph">
<p>EXERCISE 15.2Write a program that outputs only those lines of input that contain three decimal digits in a row. You wrote most of this program in the previous exercise.</p>
</div>
<div class="paragraph">
<p>练习15.2编写一个程序，只输出那些包含三行十进制数字的输入行。你在上一个练习中写了大部分这个程序。</p>
</div>
<div class="sect4">
<h5 id="_unicode_properties">UNICODE PROPERTIES</h5>
<div class="paragraph">
<p>The Unicode Character Database (UCD) defines the code points and their names and assigns them one or more properties. Each character knows many things about itself, and you can use some of that information to match them. Place the name of the Unicode property in <code>&lt;:…​&gt;</code>. That colon must come right after the opening angle bracket. If you wanted to match something that is a letter, you could use the property <code>Letter</code>:</p>
</div>
<div class="paragraph">
<p>Unicode字符数据库（UCD）定义代码点及其名称，并为它们分配一个或多个属性。每个角色都知道很多关于自身的事情，你可以使用其中的一些信息来匹配它们。将Unicode属性的名称放在&lt;：…​&gt;中。结肠必须在开角支架后面。如果你想匹配一个字母的东西，你可以使用属性字母：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;:Letter&gt; /</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of matching a property, you can match characters that don’t have that particular property. Put a <code>!</code> in front of the property name to negate it. This matches characters that aren’t the title-case letters:</p>
</div>
<div class="paragraph">
<p>你可以匹配没有该特定属性的字符，而不是匹配属性。放一个！在属性名称前面否定它。这匹配不是标题大小写字母的字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;:!TitlecaseLetter&gt; /</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each property has a long form, like <code>Letter</code>, and a short form, in this case <code>L</code>. There are other properties, such as <code>Uppercase_Letter</code> and <code>Lu</code>, or <code>Number</code> and <code>N</code>:</p>
</div>
<div class="paragraph">
<p>每个属性都有一个长格式，如Letter和短格式，在本例中为L.还有其他属性，如Uppercase_Letter和Lu，或Number和N：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;:L&gt; /
/ &lt;:N&gt; /</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can match the characters that belong to certain Unicode blocks or scripts:</p>
</div>
<div class="paragraph">
<p>你可以匹配属于某些Unicode块或脚本的字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;:Block(&#39;Basic Latin&#39;)&gt;
&lt;:Script&lt;Latin&gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even though you can abbreviate these property names I’ll use the longer names in this book. See the documentation for the other properties.</p>
</div>
<div class="paragraph">
<p>即使你可以缩写这些属性名称，我也会在本书中使用较长的名称。请参阅其他属性的文档。</p>
</div>
</div>
<div class="sect4">
<h5 id="_combining_properties">COMBINING PROPERTIES</h5>
<div class="paragraph">
<p>One property might not be enough to describe what you want to match. To build fancier ones, combine them with character class set operators. These aren’t the same operators you saw in [Chapter 14](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch14.html#camelia-junctions" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch14.html#camelia-junctions</a>); they’re special to character classes.</p>
</div>
<div class="paragraph">
<p>The <code>+</code> creates the union of the two properties. Any character that has either property will match:</p>
</div>
<div class="paragraph">
<p>一个属性可能不足以描述你想要匹配的内容。要构建更高级的，将它们与字符类集合运算符组合。这些与第14章中看到的操作符不同;他们对角色课很特别。</p>
</div>
<div class="paragraph">
<p>+创建两个属性的并集。任何具有任何属性的字符都将匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;:Letter + :Number&gt; /
/ &lt;:Open_Punctuation + :Close_Punctuation&gt; /</code></pre>
</div>
</div>
<div class="paragraph">
<p>Subtract one property from another with <code>-</code>. Any character with the first property that doesn’t have the second property will match this. The following example matches all the identifier characters (in the UCD sense, not the Raku sense). There are the characters that can start an identifier and those that can be in the other positions:</p>
</div>
<div class="paragraph">
<p>用 - 减去另一个属性。具有第一个属性但没有第二个属性的任何字符都将与此匹配。以下示例匹配所有标识符字符（在UCD意义上，而不是Raku意义上）。可以启动标识符的字符和可以位于其他位置的字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;:ID_Continue - :Number&gt; /</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can shorten this to not match a character without a particular property. It looks like you leave off the first part of the subtraction; the <code>-</code> comes right after the opening angle bracket. That implies you’re subtracting from all characters. This matches all the characters that don’t have the <code>Letter</code> property:</p>
</div>
<div class="paragraph">
<p>你可以将此缩短为与没有特定属性的角色不匹配。看起来你放弃了减法的第一部分; - 在打开角度支架后面。这意味着你要从所有角色中减去。这匹配所有没有Letter属性的字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;-:Letter&gt; /</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 15.3Write a program to count all of the characters that match either the <code>Letter</code> or <code>Number</code> properties. What percentage of the code points between 1 and 0xFFFD are either letters or numbers? The <code>.chr</code> method may be handy here.</p>
</div>
<div class="paragraph">
<p>练习15.3编写一个程序来计算与Letter或Number属性匹配的所有字符。 1和0xFFFD之间的代码点百分比是字母还是数字？ .chr方法在这里可能很方便。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_user_defined_character_classes">4.49.3. User-Defined Character Classes</h4>
<div class="paragraph">
<p>You can define your own character classes. Put the characters that you want to match inside <code>&lt;[…​]&gt;</code>. These aren’t the same square brackets that you saw earlier for grouping; these are inside the angle brackets. This character class matches either <code>a</code>, <code>b</code>, or <code>3</code>:</p>
</div>
<div class="paragraph">
<p>你可以定义自己的角色类。将要匹配的字符放在&lt;[…​]&gt;中。这些与你之前看到的用于分组的方括号不同;这些都在尖括号内。此字符类匹配a，b或3：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;[ab3]&gt; /</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with everything else so far, this matches one character and that one character can be any of the characters in the character class. This character class matches either case at a single position:</p>
</div>
<div class="paragraph">
<p>与目前为止的所有其他内容一样，它匹配一个字符，并且一个字符可以是字符类中的任何字符。此字符类匹配单个位置的任一个案例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;[Hh]&gt; ama /    # also / [ :i h ] ama /</code></pre>
</div>
</div>
<div class="paragraph">
<p>You could specify the hexadecimal value of the code point. The whitespace is insignificant:</p>
</div>
<div class="paragraph">
<p>你可以指定代码点的十六进制值。空白是微不足道的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;[ \x[48] \x[68] ]&gt; ama /</code></pre>
</div>
</div>
<div class="paragraph">
<p>The character name versions work too:</p>
</div>
<div class="paragraph">
<p>角色名称版本也适用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;[
    \c[LATIN CAPITAL LETTER H]
    \c[LATIN SMALL LETTER H]
    ]&gt;
/</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can make a long list of characters:</p>
</div>
<div class="paragraph">
<p>你可以制作一长串字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;[abcdefghijklmnopqrstuvwxyz]&gt; / # from a to z</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inside the character class the <code><mark></mark></code> is just a <code></code>. If you try to put a comment in there all of the characters in your message become part of the character class:</p>
</div>
<div class="paragraph">
<p>在角色类中，＃只是一个＃。如果你尝试在其中放置注释，则消息中的所有字符都将成为字符类的一部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;[
    \x[48] # uppercase
    \x[68] # lowercase
  ]&gt;
/</code></pre>
</div>
</div>
<div class="paragraph">
<p>You’ll probably get warnings about repeated characters if you try to do that.</p>
</div>
<div class="paragraph">
<p>如果你尝试这样做，你可能会收到有关重复字符的警告。</p>
</div>
<div class="sect4">
<h5 id="_character_class_ranges">CHARACTER CLASS RANGES</h5>
<div class="paragraph">
<p>But that’s too much work. You can use <code>..</code> to specify a range of characters. The literal characters work as well as the hexadecimal values and the names. Notice you don’t quote the literal characters in these ranges:</p>
</div>
<div class="paragraph">
<p>但那工作太多了。你可以使用..指定一系列字符。文字字符以及十六进制值和名称都起作用。请注意，你不引用这些范围中的文字字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;[a..z]&gt; /
/ &lt;[ \x[61] .. \x[7a] ]&gt; /
/ &lt;[ \c[LATIN SMALL LETTER A] .. \c[LATIN SMALL LETTER Z] ]&gt; /</code></pre>
</div>
</div>
<div class="paragraph">
<p>The range doesn’t have to be the only thing in the square brackets:</p>
</div>
<div class="paragraph">
<p>范围不一定是方括号中的唯一内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;[a..z 123456789]&gt; /</code></pre>
</div>
</div>
<div class="paragraph">
<p>You could have two ranges:</p>
</div>
<div class="paragraph">
<p>你可以有两个范围：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;[a..z 1..9]&gt; /</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_negated_character_classes">NEGATED CHARACTER CLASSES</h5>
<div class="paragraph">
<p>Sometimes it’s easier to specify the characters that can’t match. You can create a negated character class by adding a <code>-</code> between the opening angle bracket and the opening square bracket. This example matches any character that is <strong>not</strong> <code>a</code>, <code>b</code>, or <code>3</code>:</p>
</div>
<div class="paragraph">
<p>有时，指定无法匹配的字符会更容易。你可以通过在开角括号和开始方括号之间添加 - 来创建否定字符类。此示例匹配任何不是a，b或3的字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;-[ab3]&gt; /</code></pre>
</div>
</div>
<div class="paragraph">
<p>Space inside a character class is also insignificant:</p>
</div>
<div class="paragraph">
<p>字符类中的空格也是微不足道的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;-[ a b 3 ]&gt; /</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use a negated character class of one character. Quotes inside the character class are literal characters because Raku knows you aren’t quoting:</p>
</div>
<div class="paragraph">
<p>你可以使用一个字符的否定字符类。字符类中的引号是文字字符，因为Raku知道你没有引用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;-[ &#39; ]&gt;  /   # not a quote character</code></pre>
</div>
</div>
<div class="paragraph">
<p>This one matches any character that is not a newline:</p>
</div>
<div class="paragraph">
<p>这个匹配任何不是换行符的字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;-[ \n ]&gt; /   # not a newline</code></pre>
</div>
</div>
<div class="paragraph">
<p>The predefined character class shortcuts can be part of your character class:</p>
</div>
<div class="paragraph">
<p>预定义的字符类快捷方式可以是你的角色类的一部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;-[ \d \s ]&gt; /   # digits or whitespace</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like the Unicode properties, you can combine sets of characters:</p>
</div>
<div class="paragraph">
<p>与Unicode属性一样，你可以组合字符集：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;[abc] + [xyz]&gt; /    # but, also &lt;[abcxyz]&gt;

/ &lt;[a..z] - [ijk]&gt; /   # easier than two ranges</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 15.4Create a program to output all the input lines. Skip any line that contains a letter unless it’s a vowel. Also skip any lines that are blank (that is, only have whitespace).</p>
</div>
<div class="paragraph">
<p>练习15.4创建一个程序来输出所有输入行。跳过包含字母的任何行，除非它是元音。也跳过任何空白行（即只有空格）。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_matching_adverbs">4.50. Matching Adverbs</h3>
<div class="paragraph">
<p>You can change how the match operator works by applying adverbs, just like you changed how <code>Q</code> worked in [Chapter 4](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch04.html#camelia-strings" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch04.html#camelia-strings</a>). There are several, but you’ll only see the most commonly used here.</p>
</div>
<div class="paragraph">
<p>你可以通过应用副词来更改匹配运算符的工作方式，就像你在第4章中更改Q的工作方式一样。有几个，但你只会看到此处最常用的。</p>
</div>
<div class="sect3">
<h4 id="_matching_either_case">4.50.1. Matching Either Case</h4>
<div class="paragraph">
<p>So far a character in your pattern matches exactly the same character in the target. An <code>H</code> only matches an uppercase <strong>H</strong> and not any other sort of <strong>H</strong>:</p>
</div>
<div class="paragraph">
<p>到目前为止，模式中的字符与目标中的字符完全匹配。 H只匹配大写的H而不是任何其他类型的H：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/ Hama /;
put &#39;Hamadryas&#39; ~~ $pattern;  # Matches</code></pre>
</div>
</div>
<div class="paragraph">
<p>Change your pattern by one character. Instead of an uppercase <code>H</code>, use a lowercase one:</p>
</div>
<div class="paragraph">
<p>将模式更改为一个字符。而不是大写的H，使用小写的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/ hama /;
put &#39;Hamadryas&#39; ~~ $pattern;  # Misses because h is not H</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pattern is case sensitive, so this doesn’t match. But you can make it case insensitive with an adverb. The <code>:i`adverb makes the literal alphabetic characters match either case. You can put the adverb right after the `rx</code> or the <code>m</code>:</p>
</div>
<div class="paragraph">
<p>该模式区分大小写，因此不匹配。但是你可以用副词区分大小写。 ：iadverb使文字字母符合两种情况。你可以把副词放在rx或m之后：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx:i/ hama /;
put &#39;Hamadryas&#39; ~~ $pattern;  # Matches, :i outside</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the reason you can’t use the colon as the delimiter!</p>
</div>
<div class="paragraph">
<p>When you use an adverb on the outside of the pattern, that adverb applies to the entire pattern. You can also put the adverb on the inside of the pattern:</p>
</div>
<div class="paragraph">
<p>这就是你不能使用冒号作为分隔符的原因！</p>
</div>
<div class="paragraph">
<p>在模式外部使用副词时，该副词适用于整个模式。你也可以把副词放在模式的内部：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/ :i hama /;
put &#39;Hamadryas&#39; ~~ $pattern;  # Matches, :i inside</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isn’t that interesting? Now you start to see why whitespace isn’t counted as part of the pattern. There’s much more going on besides literal matching of characters.</p>
</div>
<div class="paragraph">
<p>The adverb applies from the point of its insertion to the end of the pattern. In this case it applies to the entire pattern because the <code>:i</code> is at the beginning. Put that adverb later in the pattern, and it applies from there to the rest of the pattern. Here the <code>ha</code> only match lowercase because the adverb shows up later. The rest of the pattern after the <code>:i</code> is case insensitive:</p>
</div>
<div class="paragraph">
<p>那不是很有趣吗？现在你开始明白为什么空格不算作模式的一部分。除了字符的字面匹配之外还有更多的事情要做。</p>
</div>
<div class="paragraph">
<p>副词从插入点到模式结尾。在这种情况下，它适用于整个模式，因为：i在开头。将该副词放在模式中，然后从那里应用到模式的其余部分。 ha只与小写匹配，因为副词会在稍后出现。在以下情况之后的其余模式：i不区分大小写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/ ha :i ma /; # final ma case insensitive</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can group parts of patterns with square brackets. This example groups the <code>am</code> but doesn’t do much else because there’s nothing else special going on:</p>
</div>
<div class="paragraph">
<p>你可以使用方括号对部分图案进行分组。这个例子对am进行分组，但没有做太多其他事情，因为没有其他特别的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/ h [ am ] a /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An adverb inside a group applies only to that group:</p>
</div>
<div class="paragraph">
<p>组内的副词仅适用于该组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/ h [ :i am ] a /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The rules are the same: the adverb applies from the point of its insertion to the end of the group:</p>
</div>
<div class="paragraph">
<p>规则是相同的：副词从插入点到组尾：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/ h [ a :i m ] a /; # matches haMa or hama</code></pre>
</div>
</div>
<div class="paragraph">
<p>At this point, you’re probably going to start mixing up what’s going on. There’s another reason whitespace doesn’t matter—you can add comments to your pattern:</p>
</div>
<div class="paragraph">
<p>在这一点上，你可能会开始混淆正在发生的事情。空白无关紧要的另一个原因 - 你可以为你的模式添加注释：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/
    h
    [       # group this next part
        a
        :i   # case insensitive to end of group
        m
    ]       # end of group
    a
    /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Everything from the <code>#</code> character to the end of the line is a comment. You can use embedded comments too:</p>
</div>
<div class="paragraph">
<p>从＃字符到行尾的所有内容都是注释。你也可以使用嵌入式注释：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/
    :i #`( case insensitive ) Hama
    /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>These aren’t particularly good comments because you’re annotating what the syntax already denotes. As a matter of good practice, you should comment what you are trying to match rather than what the syntax does. However, the world isn’t going to end if you leave a reminder for yourself of what a new concept does.</p>
</div>
<div class="paragraph">
<p>EXERCISE 15.5Write a program that outputs only the lines of input that contain the text <code>ei</code>. You’ll probably want to save this program to build on in later exercises.</p>
</div>
<div class="paragraph">
<p>这些并不是特别好的注释，因为你正在注释语法已经表示的内容。作为一种良好实践，你应该评论你要匹配的内容而不是语法的内容。但是，如果你给自己留下一个新概念的提醒，世界就不会结束。</p>
</div>
<div class="paragraph">
<p>练习15.5编写一个只输出包含文本ei的输入行的程序。你可能想要保存这个程序，以便在以后的练习中继续使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ignoring_marks">4.50.2. Ignoring Marks</h4>
<div class="paragraph">
<p>The <code>:ignoremark</code> adverb changes the pattern so that accents and other marks don’t matter. The marks can be there or not. It works if the marks are in the target or the pattern:</p>
</div>
<div class="paragraph">
<p>：ignoremark副词会更改模式，以便重音和其他标记无关紧要。标记可以存在与否。如果标记在目标或模式中，它可以工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;húdié&#39;;   # ??
put m/ hudie /            ?? &#39;Matched&#39; !! &#39;Missed&#39;;  # Missed
put m:ignoremark/ hudie / ?? &#39;Matched&#39; !! &#39;Missed&#39;;  # Matched

$_ = &#39;hudie&#39;;
put m:ignoremark/ húdié / ?? &#39;Matched&#39; !! &#39;Missed&#39;;  # Matched</code></pre>
</div>
</div>
<div class="paragraph">
<p>It even works if both the target and the pattern have different marks in the same positions:</p>
</div>
<div class="paragraph">
<p>如果目标和模式在相同位置具有不同的标记，它甚至可以工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;hüdiê&#39;;
put m:ignoremark/ húdié / ?? &#39;Matched&#39; !! &#39;Missed&#39;;  # Matched</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some adverbs can show up inside the pattern. They apply to the parts of the pattern that come after them:</p>
</div>
<div class="paragraph">
<p>一些副词可以出现在模式中。它们适用于它们之后的模式部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;hüdiê&#39;;
put m/ :ignoremark hudie / ?? &#39;Matched&#39; !! &#39;Unmatched&#39;;  # Matched</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_global_matches">4.50.3. Global Matches</h4>
<div class="paragraph">
<p>A pattern might be able to match several times in the same text. The <code>:global</code> adverb gets all of the nonoverlapping [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html)es" class="bare">https://docs.raku.org/type/Match.html)es</a>. It returns a [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>):</p>
</div>
<div class="paragraph">
<p>模式可能能够在同一文本中多次匹配。 ：全局副词获取所有不重叠的匹配。它返回一个List：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas perlicus&#39;;
my $matches = m:global/ . s /;
say $matches;   # (?as? ?us?)</code></pre>
</div>
</div>
<div class="paragraph">
<p>No matches gets you an empty [<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>):</p>
</div>
<div class="paragraph">
<p>没有匹配得到一个空列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas perlicus&#39;;
my $matches = m:global/ six /;
say $matches;   # ()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The match operator can find overlapping matches too. Use <code>:overlap</code> to return a potentially longer list. The <code>?uta?</code> and <code>?ani?</code> here both match the same <strong>a</strong>:</p>
</div>
<div class="paragraph">
<p>匹配运算符也可以找到重叠匹配。使用：重叠以返回可能更长的列表。 ？？和？ani？这里两个匹配相同的a：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Bhutanitis thaidina&#39;;

my $global = m:global/ &lt;[aeiou]&gt; &lt;-[aeiou]&gt; &lt;[aeiou]&gt; /;
say $global;  # (?uta? ?iti? ?idi?)

my $overlap = m:overlap/ &lt;[aeiou]&gt; &lt;-[aeiou]&gt; &lt;[aeiou]&gt; /;
say $overlap; # (?uta? ?ani? ?iti? ?idi? ?ina?)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_things_that_use_patterns">4.51. Things That Use Patterns</h3>
<div class="paragraph">
<p>There are many features that you haven’t been able to use so far because you hadn’t seen regexes yet. Now you’ve seen regexes, so you can see these things. There are a couple of [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) methods that work with a pattern to transform values. This section is a taste of the features you’ll use most often.</p>
</div>
<div class="paragraph">
<p>The <code>.words</code> and <code>.comb</code> methods break up text. The <code>.split</code> method is the general case of that. It takes a pattern to decide how to break up the text. Whatever it matches are the parts that disappear. You could break up a line on tabs, for instance:</p>
</div>
<div class="paragraph">
<p>到目前为止，你还无法使用许多功能，因为你尚未看到正则表达式。现在你已经看过正则表达式，所以你可以看到这些东西。有一些Str方法可以使用模式来转换值。本节介绍了你最常使用的功能。</p>
</div>
<div class="listingblock">
<div class="title">words和.comb方法分解文本。 .split方法就是这种情况的一般情况。它需要一种模式来决定如何分解文本。无论它匹配什么是消失的部分。你可以在标签上划分一条线，例如：</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @words = $line.split: / \t /;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.grep</code> can use the match operator to select things. If the match operator succeeds it returns something that’s <code>True</code>, and that element is part of the result:</p>
</div>
<div class="paragraph">
<p>`.grep`可以使用匹配运算符来选择事物。如果匹配运算符成功，则返回一些True，并且该元素是结果的一部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @words-with-e = @word.grep: /:i e/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, to put it all together:</p>
</div>
<div class="paragraph">
<p>或者，把它们放在一起：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @words-with-e = $line.split( / \t / ).grep( /:i e/ );</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.split</code> can specify multiple possible separators. Not all of them need be matches. This breaks up a line on a literal comma or whitespace:</p>
</div>
<div class="paragraph">
<p>`.split`可以指定多个可能的分隔符。并非所有人都需要匹配。这会在文字逗号或空格上划分一行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @words-with-e = $line
    .split( [ &#39;,&#39;, / \s / ] )
    .grep( /:i e/ );</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.comb</code> does a job similar to <code>.split</code>, but it breaks up the text by keeping the parts that matched. This keeps all the nonoverlapping groups of three digits and discards everything else:</p>
</div>
<div class="paragraph">
<p>`.comb`的工作类似于.split，但它通过保留匹配的部分来分解文本。这将保留所有三个数字的非重叠组，并丢弃其他所有内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @digits = $line.comb: /\d\d\d/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With no argument <code>.comb</code> uses the pattern of the single <code>.</code> to match any character. This breaks up a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) into its characters without discarding anything:</p>
</div>
<div class="paragraph">
<p>没有参数.comb使用单一模式。匹配任何角色。这会将Str分解为其角色而不丢弃任何内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @characters = $line.comb: /./;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_substitutions">4.51.1. Substitutions</h4>
<div class="paragraph">
<p>The <code>.subst</code> method works with a pattern to substitute the matched text with other text:</p>
</div>
<div class="listingblock">
<div class="title">subst方法使用模式将匹配的文本替换为其他文本：</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = &#34;This is PERL 6&#34;;
put $line.subst: /PERL/, &#39;Perl&#39;;  # This is Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>This one makes the substitution for the first match:</p>
</div>
<div class="paragraph">
<p>这个替换第一场比赛：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = &#34;PERL PERL PERL&#34;;
put $line.subst: /PERL/, &#39;Perl&#39;;  # Perl PERL PERL</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use the <code>:g</code> adverb to make all possible substitutions:</p>
</div>
<div class="paragraph">
<p>使用：g副词进行所有可能的替换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = &#34;PERL PERL PERL&#34;;
put $line.subst: /PERL/, &#39;Perl&#39;;  # Perl Perl Perl</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each of these returns the modified [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) and leaves the original alone. Use <code>.subst-mutate</code> to change the original value:</p>
</div>
<div class="paragraph">
<p>其中每个都返回修改后的Str并单独留下原始文件。使用.subst-mutate更改原始值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = &#34;PERL PERL PERL&#34;;
$line.subst-mutate: /PERL/, &#39;Perl&#39;, :g;
put $line;  # Perl Perl Perl</code></pre>
</div>
</div>
<div class="paragraph">
<p>These will be much more useful with the regex features you’ll see in the next chapter.</p>
</div>
<div class="paragraph">
<p>EXERCISE 15.6Using <code>.split</code>, output the third column of a tab-delimited file. The butterfly census file you made at the end of [Chapter 9](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch09.html#camelia-hashes" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch09.html#camelia-hashes</a>) would do nicely here.</p>
</div>
<div class="paragraph">
<p>对于你将在下一章中看到的正则表达式功能，这些功能将更加有用。</p>
</div>
<div class="paragraph">
<p>EXERCISE 15.6使用.split，输出制表符分隔文件的第三列。你在第9章结尾处制作的蝴蝶人口普查文件在这里做得很好。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_summary_9">4.52. Summary</h3>
<div class="paragraph">
<p>You haven’t seen the full power of regexes in this chapter since it was mostly about the mechanism of applying the patterns to text. That’s not a big deal—the patterns can be much more sophisticated, but the mechanisms are the same. In the next chapter you’ll see most of the fancier features you’ll regularly use.</p>
</div>
<div class="paragraph">
<p>在本章中你没有看到正则表达式的全部功能，因为它主要是关于将模式应用于文本的机制。这不是什么大问题 - 模式可以更复杂，但机制是相同的。在下一章中，你将看到你经常使用的大多数更高级的功能。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_更漂亮的正则表达式">5. 更漂亮的正则表达式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You won’t see all the rest of the regular expression syntax in this chapter, but you’ll see the syntax you’ll use the most. There’s much more to patterns, but this should get you most of the way through common problems. With grammars ([Chapter 17](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch17.html#camelia-grammars)" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch17.html#camelia-grammars)</a>), the power of even simple patterns will become apparent.</p>
</div>
<div class="paragraph">
<p>在本章中，你不会看到所有其他正则表达式语法，但你将看到最常用的语法。模式有很多，但这应该可以解决常见问题。使用 grammars（第17章），即使是简单模式的威力也会变得明显。</p>
</div>
<div class="sect2">
<h3 id="_量词">5.1. 量词</h3>
<div class="paragraph">
<p>Quantifiers allow you to repeat a part of a pattern. Perhaps you want to match several of the same letter in a row—an <strong>a</strong> followed by one or more <strong>b</strong>’s then another <strong>a</strong>. You don’t care how many <strong>b</strong>’s there are as long as there’s at least one of them. The <code>+</code> quantifier matches the immediately preceding part of the pattern one or more times:</p>
</div>
<div class="paragraph">
<p>量词允许你重复模式的一部分。也许你想要连续匹配几个相同的字母 - 一个 <strong>a</strong> 后跟一个或多个 <strong>b</strong>，然后是另一个*a*。你不在乎有多少 <strong>b</strong>，只要有至少一个 <strong>b</strong> 就好了。 <code>+</code> 量词与紧接其前的部分模式匹配一次或多次：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @strings = &lt; Aa Aba Abba Abbba Ababa &gt;;
for @strings {
    put $_, &#39; &#39;, m/ :i ab+ a / ?? &#39;Matched!&#39; !! &#39;Missed!&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) here doesn’t match because there isn’t at least one <strong>b</strong>. All of the others have an <strong>a</strong> followed by one or more <strong>b*s and another *a</strong>:</p>
</div>
<div class="paragraph">
<p>这里的第一个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)不匹配，因为没有至少一个" class="bare">https://docs.raku.org/type/Str.html)不匹配，因为没有至少一个</a> <strong>b</strong>。所有其他字符串都有一个 <strong>a</strong> 后跟一个或多个 <strong>b</strong>，还有另一个 <strong>a</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Aa Missed!
Aba Matched!
Abba Matched!
Abbba Matched!
Ababa Matched!</code></pre>
</div>
</div>
<div class="paragraph">
<p>A quantifier only applies to the part of the pattern immediately in front of it—that’s the <code>b</code>, not the <code>ab</code>. Group the <code>ab</code> and apply the quantifier to the group (which counts as one thingy):</p>
</div>
<div class="paragraph">
<p>量词仅适用于紧接在其前的部分模式 - 即 <code>b</code>，而不是 <code>ab</code>。将 <code>ab</code> 分组并将量词应用于组（计为一个东西）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @strings = &lt; Aa Aba Abba Abbba Ababa &gt;;
for @strings {
    put $_, &#39; &#39;, m/ :i [ab]+ a / ?? &#39;Matched!&#39; !! &#39;Missed!&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now different [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> match. The ones with repeated <strong>b</strong>’s don’t match because the quantifier applies to the <code>[ab]`group. Only two of the [`Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> have repeated <strong>ab</strong>’s:</p>
</div>
<div class="paragraph">
<p>现在匹配的是不同的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)了。重复" class="bare">https://docs.raku.org/type/Str.html)了。重复</a> <strong>b</strong> 的那些不匹配，因为量词应用于 <code>[ab]</code> 组。只有两个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)重复了" class="bare">https://docs.raku.org/type/Str.html)重复了</a> <strong>ab</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Aa Missed!
Aba Matched!
Abba Missed!
Abbba Missed!
Ababa Matched!</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 16.1Using <strong>butterfly_census.txt</strong> (the file you made at the end of [Chapter 9](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch09.html#camelia-hashes)" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch09.html#camelia-hashes)</a>), use a regex to count the number of distinct butterfly species whose names have two or more consecutive <strong>i</strong>’s. Use the <code>+</code> quantifier in your pattern.</p>
</div>
<div class="paragraph">
<p>练习16.1使用 <strong>butterfly_census.txt</strong>（你在第9章末尾创建的文件），使用正则表达式来计算名称有两个或更多个连续 <strong>i</strong> 的不同蝴蝶物种的数量。在模式中使用 <code>+</code> 量词。</p>
</div>
<div class="sect3">
<h4 id="_zero_or_more">5.1.1. Zero or More</h4>
<div class="paragraph">
<p>The <code><strong></strong></code><strong> quantifier is like <code>+</code> but matches *zero</strong> or more times. This makes that part of the pattern optional. If it matches it can repeat as many times as it likes. Perhaps you want to allow the letter <strong>a</strong> between <strong>b</strong>’s. The <strong>a</strong>’s can be there or not be there:</p>
</div>
<div class="paragraph">
<p><code><strong></strong></code><strong> 量词类似于 <code>+</code> 但匹配零次或多次。这使得该模式的一部分可选。如果它匹配，它可以重复任意次数。也许你想允许 *b</strong> 之间有字母 <strong>a</strong>。 <strong>a</strong> 可以在那里或不在那里：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @strings = &lt; Aba Abba Abbba Ababa &gt;;
for @strings {
    put $_, &#39; &#39;, m/ :i ba*b / ?? &#39;Matched!&#39; !! &#39;Missed!&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> with consecutive <strong>b</strong>’s match because they have zero <strong>a</strong>’s between the <strong>b</strong>’s, but the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) with <strong>bab</strong> also matches because it has zero or more <strong>a</strong>’s between them:</p>
</div>
<div class="paragraph">
<p>带有连续 <strong>b</strong> 的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)匹配了，因为它们在" class="bare">https://docs.raku.org/type/Str.html)匹配了，因为它们在</a> <strong>b</strong> 之间没有 <strong>a</strong>，但是带有 <strong>bab</strong> 的[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)也匹配了，因为它们之间有零或多个" class="bare">https://docs.raku.org/type/Str.html)也匹配了，因为它们之间有零或多个</a> <strong>a</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Aba Missed!
Abba Matched!
Abbba Matched!
Ababa Matched!</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 16.2Adapt your solution from the previous exercise to find the butterfly species names that have consecutive <strong>a</strong>’s that may be separated by either <strong>n</strong> or <strong>s</strong>.</p>
</div>
<div class="paragraph">
<p>练习16.2 从上一个练习中获取解决方案，找到具有连续 <strong>a</strong> 的蝴蝶种类名称，这些名称可以用 <strong>n</strong> 或 <strong>s</strong> 分隔。</p>
</div>
</div>
<div class="sect3">
<h4 id="_greediness">5.1.2. Greediness</h4>
<div class="paragraph">
<p>The <code>+</code> and <code><strong></strong></code><strong> quantifiers are greedy; they match as much of the text as they can. Sometimes that’s too much. Change the earlier example to match another *b</strong> after the quantifier. Now there must be at least two <strong>b</strong>’s in a row:</p>
</div>
<div class="paragraph">
<p><code>+</code> 和 <code><strong></strong></code><strong> 量词是贪婪的;他们尽可能多地匹配文本。有时匹配太多了。更改前面的示例以匹配量词后的另一个 *b</strong>。现在必须连续至少有两个 <strong>b</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @strings = &lt; Aba Abba Abbba Ababa &gt;;
for @strings {
    put $_, &#39; &#39;, m/ :i ab+ ba / ?? &#39;Matched!&#39; !! &#39;Missed!&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) doesn’t match because it doesn’t have one or more <strong>b</strong>’s followed by another <strong>b</strong>. It’s the same for the last [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>). The middle two [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> have enough <strong>b</strong>’s to satisfy both parts of the pattern:</p>
</div>
<div class="paragraph">
<p>第一个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)不匹配，因为它没有一个或多个" class="bare">https://docs.raku.org/type/Str.html)不匹配，因为它没有一个或多个</a> <strong>b</strong>，后面再跟另一个 <strong>b</strong>。对于最后一个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)来说也是如此。中间的两个"><code>字符串</code></a>(<a href="https://docs.raku.org/type/Str.html)有足够的" class="bare">https://docs.raku.org/type/Str.html)有足够的</a> <strong>b</strong> 来满足模式的两个部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Aba Missed!
Abba Matched!
Abbba Matched!
Ababa Missed!</code></pre>
</div>
</div>
<div class="paragraph">
<p>But think about how this works inside the matcher. When it sees the <code>b+</code> it matches as many <strong>b</strong>’s as it can. In <code>Abbba</code>, the <code>b+</code> starts by matching <code>bbb</code>. The <code>b+</code> part of the pattern is satisfied. The matcher moves on to the next part of the pattern, which is another <code>b</code>. The text doesn’t have any leftover <strong>b</strong>’s to satisfy that part because the greedy quantifier matched them all.</p>
</div>
<div class="paragraph">
<p>The match doesn’t fail because of another tactic the matcher can use: it can backtrack on the quantifier that just matched to force it to give up some of the text. The <code>b+</code> needs one or more <strong>b</strong>’s. Whether it matched two or three doesn’t matter, because either satisfies that. Backing up one position in the text leaves a <strong>b</strong> for the next part to match. Once it backs up it tries the next part of the pattern.</p>
</div>
<div class="paragraph">
<p>但想想在匹配器中如何工作。当它看到 <code>b+</code> 时，它尽可能多地匹配 <strong>b</strong>。在 <code>Abbba</code> 中，<code>b+</code> 从匹配 <code>bbb</code> 开始。满足模式的 <code>b+</code> 部分。匹配器移动到模式的下一部分，这是另一个 <code>b</code>。该文本没有任何剩余的 <strong>b</strong> 来满足该部分，因为贪婪的量词把它们全部匹配完了。</p>
</div>
<div class="paragraph">
<p>匹配不会因为匹配器可以使用的另一种策略而失败：它可以回溯刚刚匹配的量词，迫使它放弃一些文本。 <code>b+</code> 需要一个或多个 <strong>b</strong>。它是否匹配两个或三个并不重要，因为要么满足这一点。在文本中回退一个位置会空出一个 <strong>b</strong> 以供下一部分匹配。一旦它回退它就会尝试模式的下一部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="_zero_or_one">5.1.3. Zero or One</h4>
<div class="paragraph">
<p>The <code>?</code> quantifier matches zero or once only; it makes the preceding part of the pattern optional. In this pattern you can have one or two <strong>b</strong>’s because you used <code>?</code> to make one of them optional:</p>
</div>
<div class="paragraph">
<p><code>?</code> 量词匹配零或一次;它使模式的前一部分可选。在这种模式中，你可以使用一个或两个 <strong>b</strong>，因为你使用过 <code>?</code> 使其中一个可选：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @strings = &lt; Aba Abba Abbba Ababa &gt;;
for @strings {
    put $_, &#39; &#39;, m/ :i ab? ba / ?? &#39;Matched!&#39; !! &#39;Missed!&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the first [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) can match because the first <strong>b</strong> can match zero times. The third [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) can’t match because there is more than one <strong>b</strong> and the <code>?</code> can’t match more than one of them:</p>
</div>
<div class="paragraph">
<p>现在第一个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)可以匹配，因为第一个" class="bare">https://docs.raku.org/type/Str.html)可以匹配，因为第一个</a> <strong>b</strong> 可以匹配零次。第三个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)无法匹配，因为有多个" class="bare">https://docs.raku.org/type/Str.html)无法匹配，因为有多个</a> <strong>b</strong> 并且 <code>?</code> 不能匹配多个 <strong>b</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Aba Matched!
Abba Matched!
Abbba Missed!
Ababa Matched!</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_minimal_and_maximal">5.1.4. Minimal and Maximal</h4>
<div class="paragraph">
<p>If you want to match an exact number of times use <code><strong></strong></code><strong>. With a single number after it the <code></code></strong> matches exactly that number of times. This matches exactly three <strong>b</strong>’s:</p>
</div>
<div class="paragraph">
<p>如果要匹配确切的次数，请使用 <code><strong></strong></code><strong>。在它之后有一个数字，<code></code></strong> 恰好匹配那个次数。这恰好与三个 <strong>b</strong> 匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @strings = &lt; Aba Abba Abbba Ababa &gt;;
for @strings {
    put $_, &#39; &#39;, m/ :i ab**3 a / ?? &#39;Matched!&#39; !! &#39;Missed!&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s only one [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) that matches:</p>
</div>
<div class="paragraph">
<p>只有一个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)匹配：" class="bare">https://docs.raku.org/type/Str.html)匹配：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Aba Missed!
Abba Missed!
Abbba Matched!
Ababa Missed!</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use a range after the <code>**</code>. The quantified part must match at least the range minimum and will only match as many repetitions as the range maximum:</p>
</div>
<div class="paragraph">
<p>你可以在 <code>**</code> 之后使用范围。量化部分必须至少匹配范围最小值，并且只匹配范围最大值的重复次数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @strings = &lt; Aba Abba Abbba Ababa Abbbba &gt;;
for @strings {
    put $_, &#39; &#39;, m/ :i a b**2..3 a / ?? &#39;Matched!&#39; !! &#39;Missed!&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Two [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> match—the ones with two or three consecutive <strong>b</strong>’s:</p>
</div>
<div class="paragraph">
<p>两个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)匹配" class="bare">https://docs.raku.org/type/Str.html)匹配</a> - 具有两个或三个连续 <strong>b</strong> 的那个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Aba Missed!
Abba Matched!
Abbba Matched!
Ababa Missed!
Abbbba Missed!</code></pre>
</div>
</div>
<div class="paragraph">
<p>An exclusive range works too. Match two or three times by excluding the <code>1</code> and <code>4</code> endpoints to get the same output:</p>
</div>
<div class="paragraph">
<p>排除范围也有效。通过排除 <code>1</code> 和 <code>4</code> 端点来匹配两到三次以获得相同的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @strings = &lt; Aba Abba Abbba Ababa &gt;;
for @strings {
    put $_, &#39; &#39;, m/ :i ab**1^..^4 a / ?? &#39;Matched!&#39; !! &#39;Missed!&#39;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 16.3Output all the lines from the butterfly census file that have four vowels in a row.</p>
</div>
<div class="paragraph">
<p>EXERCISE 16.4Output all the lines from the butterfly census file that have exactly four repetitions of an <strong>a</strong> followed by a nonvowel (such as in <strong>Paralasa</strong>).</p>
</div>
<div class="paragraph">
<p>练习16.3 输出蝴蝶人口普查文件中连续有四个元音的所有行。</p>
</div>
<div class="paragraph">
<p>练习16.4 输出蝴蝶人口普查文件中的所有行，这些行恰好有四个重复的 <strong>a</strong> 后跟一个非元音（例如在 <strong>Paralasa</strong> 中）。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_controlling_quantifiers">5.2. Controlling Quantifiers</h3>
<div class="paragraph">
<p>Adding a <code>?</code> after any quantifier makes it match as little as possible—the greedy quantifiers become nongreedy. The modified quantifier stops matching when the next part of the pattern can match.</p>
</div>
<div class="paragraph">
<p>These two patterns look for an <strong>H</strong>, some stuff, and then an <strong>s</strong>. The first one is greedy and matches all the way to the final <strong>s</strong>. The second one is nongreedy and stops at the first <strong>s</strong> it encounters. The greedy case matches the entire text but the nongreedy case matches only the first word:</p>
</div>
<div class="paragraph">
<p>在任何量词后面添加 <code>?</code> 使得它尽可能少地匹配 - 贪婪的量词变得不贪婪。当模式的下一部分可以匹配时，修改的量词停止匹配。</p>
</div>
<div class="paragraph">
<p>这两个模式寻找 <strong>H</strong>，然后是一些东西，然后是一个 <strong>s</strong>。第一个是贪婪的，一直匹配到最后的 <strong>s</strong>。第二个是非贪婪的，并在它遇到的第一个 <strong>s</strong> 后停止。贪婪的案例匹配整个文本，但非贪婪的案例只匹配第一个单词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas perlicus&#39;;

say &#34;Greedy: &#34;,    m/ H .*  s /;  # Greedy: ｢Hamadryas perlicus｣
say &#34;Nongreedy: &#34;, m/ H .*? s /;  # Nongreedy: ｢Hamadryas｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>You’ll probably find that you often want to make the quantifiers nongreedy.</p>
</div>
<div class="paragraph">
<p>EXERCISE 16.5Output all the text in the input that appears between underscores. The <strong>Butterflies_and_Moths.txt</strong> file has some interesting nongreedy matches.</p>
</div>
<div class="paragraph">
<p>你可能会发现你经常想让量词不贪婪。</p>
</div>
<div class="paragraph">
<p>练习16.5 输出输入中出现在下划线之间的所有文本。 <strong>Butterflies_and_Moths.txt</strong> 文件有一些有趣的非贪婪匹配。</p>
</div>
<div class="sect3">
<h4 id="_turning_off_backtracking">5.2.1. Turning Off Backtracking</h4>
<div class="paragraph">
<p>The <code>:</code> modifier lets you turn off backtracking by preventing a quantifier from unmatching what it has already matched. In both of these patterns the <code>.+</code> can match everything to the end of the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>). The first one has to unmatch some of that to allow the rest of the pattern to match. The second one uses <code>.+:</code>, which means it can’t give back any of the text to allow the first <strong>s</strong> to match, so that match fails:</p>
</div>
<div class="paragraph">
<p><code>:</code> 修饰符允许你通过阻止量词取消匹配已匹配的内容来关闭回溯。在这两种模式中，<code>.+</code> 可以匹配所有东西直到[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)的末尾。第一个必须与其中一些取消匹配，以允许模式的其余部分匹配。第二个使用" class="bare">https://docs.raku.org/type/Str.html)的末尾。第一个必须与其中一些取消匹配，以允许模式的其余部分匹配。第二个使用</a> <code>.+:</code> ,这意味着它无法归还任何文本以允许第一个匹配，因此匹配失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas perlicus&#39;;
say &#34;Backtracking: &#34;,
    m/ H .+  s \s perlicus/;  # Backtracking: ｢Hamadryas perlicus｣
say &#34;Nonbacktracking: &#34;,
    m/ H .+: s \s perlicus/;  # Nonbacktracking: Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>:</code> can go immediately after the <code><strong></strong></code><strong>. Each tries to match groups of three characters with a <strong>def</strong> at the end. The first one matches the entire [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) because it’s greedy, but then backs up enough to allow <strong>def</strong> to match. The second one uses <code></code></strong><code>:</code>, so it refuses to unmatch the <strong>def</strong> and the pattern fails:</p>
</div>
<div class="paragraph">
<p><code>:</code> 可以直接跟在 <code><strong></strong></code><strong> 后面。每个尝试匹配三个字符的组然后是末尾的 <strong>def</strong>。第一个匹配整个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)，因为它是贪婪的，但后来回退足够多的字符以允许" class="bare">https://docs.raku.org/type/Str.html)，因为它是贪婪的，但后来回退足够多的字符以允许</a> <strong>def</strong> 匹配。第二个使用 <code></code></strong><code>:</code>,因此它拒绝取消匹配 <strong>def</strong> , 模式就失败了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;abcabcabcdef&#39;;
say &#34;Backtracking: &#34;,
    m/ [ ... ] **  3..4 def /;  # ｢abcabcabcdef｣
say &#34;Nonbacktracking: &#34;,
     m/ [ ... ] **: 3..4 def /;  # Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>[Table 16-1](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch16.html#camelia-regex2-TABLE-regex_summary" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch16.html#camelia-regex2-TABLE-regex_summary</a>) summarizes the behavior of the different types of quantifiers.</p>
</div>
<div class="paragraph">
<p>[表16-1](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch16.html#camelia-regex2-TABLE-regex_summary)总结了不同类型量词的行为。" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch16.html#camelia-regex2-TABLE-regex_summary)总结了不同类型量词的行为。</a></p>
</div>
<div class="paragraph">
<p>| Quantifier  | Example       | Meaning                          |
| ----------- | ------------- | -------------------------------- |
| <code>?</code>         | <code>b?</code>          | 零个或一个 <strong>b</strong>                   |
| <code><strong></strong></code><strong>         | <code>b</code></strong>          | 零个或多个 <strong>b</strong>                   |
| <code>+</code>         | <code>b+</code>          | 一个或多个 <strong>b</strong>                   |
| <code><strong> N</strong></code><strong>      | <code>b </code></strong><code> 4</code>      | 正好 4 个 <strong>b</strong>                    |
| <code><strong> M..N</strong></code><strong>   | <code>b </code></strong><code> 2..4</code>   | 两到四个 <strong>b</strong>                     |
| <code><strong> M<sup>..</sup>N</strong></code><strong> | <code>b </code></strong><code> 1<sup>..</sup>5</code> | 带有排除范围的两到四个 <strong>b</strong>       |
| <code>??</code>        | <code>b??</code>         | 零个 <strong>b</strong> (不常见的情况)          |
| <code><strong>?</strong></code><strong>        | <code>b</code></strong><code>?</code>         | 零个或多个 <strong>b</strong>，非贪婪的         |
| <code>+?</code>        | <code>b+?</code>         | 一个或多个 <strong>b</strong>，非贪婪的         |
| <code>?:</code>        | <code>b?:</code>         | 零个或多个 <strong>b</strong>，没有回溯         |
| <code><strong>:</strong></code><strong>        | <code>b</code></strong><code>?</code>         | 零个或多个 <strong>b</strong>，贪婪的，没有回溯 |
| <code>+:</code>        | <code>b+?</code>         | 一个或多个 <strong>b</strong>，没有回溯         |
| <code><strong>: M..N</strong></code><strong>  | <code>b </code></strong><code> 2..4</code>   | 两到四个 <strong>b</strong>，贪婪的，没有回溯   |</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_captures">5.3. Captures</h3>
<div class="paragraph">
<p>When you group with parentheses instead of square brackets you capture parts of the text:</p>
</div>
<div class="paragraph">
<p>当你使用圆括号而不是方括号分组时，你可以捕获文本的一部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;Hamadryas perlicus&#39; ~~ / (\w+) \s+ (\w+) /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the <code>.gist</code> output you see the captures labeled with whole numbers starting from zero. The captures are numbered by their position in their subpattern from left to right:</p>
</div>
<div class="paragraph">
<p>在 <code>.gist</code> 输出中，你会看到标记从零开始的整数的捕获。捕获按照从左到右的子模式中的位置进行编号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢Hamadryas perlicus｣
 0 =&gt; ｢Hamadryas｣
 1 =&gt; ｢perlicus｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can access the captures with postcircumfix indices (but only if the match succeeds). This looks like a [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html" class="bare">https://docs.raku.org/type/Positional.html</a>) but isn’t, but that’s a distinction you don’t need to worry about here. The output shows the same captures you saw before:</p>
</div>
<div class="paragraph">
<p>你可以使用 postcircumfix 索引访问捕获（但仅在匹配成功时）。这看起来像一个 [<code>Positional</code>](<a href="https://docs.raku.org/type/Positional.html)，但不是，但这是一个区别，这里你不需要担心。输出显示你之前看到的相同捕获：" class="bare">https://docs.raku.org/type/Positional.html)，但不是，但这是一个区别，这里你不需要担心。输出显示你之前看到的相同捕获：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $match = &#39;Hamadryas perlicus&#39; ~~ / (\w+) \s+ (\w+) /;

if $match {
    put &#34;Genus: $match[0]&#34;;   # Genus: Hamadryas
    put &#34;Species: $match[1]&#34;; # Species: perlicus
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The special variable <code>$/</code> already stores the result of the last successful match. You can access elements in it directly:</p>
</div>
<div class="paragraph">
<p>特殊变量 <code>$/</code> 已经存储了上次成功匹配的结果。你可以直接访问其中的元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas perlicus&#39;;
if / (\w+) \s+ (\w+) / {
    put &#34;Genus: $/[0]&#34;;    # Genus: Hamadryas
    put &#34;Species: $/[1]&#34;;  # Species: perlicus
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>It gets better. There’s a shorthand to access the captures in <code>$/</code>. The number variables <code>$0</code> and <code>$1</code> are actually <code>$/[0]</code> and <code>$/[1]</code> (and this is true for as many captures as you create):</p>
</div>
<div class="paragraph">
<p>它变得更好了。有一个简写来访问 <code>$/</code> 中的捕获。数字变量 <code>$0</code> 和 <code>$1</code> 实际上是 <code>$/[0]</code> 和 <code>$/[1]</code> (对于你创建的捕获次数，这是正确的)：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas perlicus&#39;;
if / (\w+) \s+ (\w+) / {
    put &#34;Genus: $0&#34;;   # Genus: Hamadryas
    put &#34;Species: $1&#34;; # Species: perlicus
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a previous match fails then <code>$/</code> is empty and you don’t see the values from the previous successful match. An unsuccessful match resets to <code>$/</code> to nothing:</p>
</div>
<div class="paragraph">
<p>如果先前的匹配失败，则 <code>$/</code> 为空，并且你看不到上一次成功匹配的值。不成功的匹配将 <code>$/</code> 重置为空：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = &#39;Hamadryas perlicus&#39;;

my $first-match = $string ~~ m/(perl)(.*)/;
put &#34;0: $0 | 1: $1&#34;;  # 0: perl | 1: icus

my $second-match = $string ~~ m/(ruby)(.*)/;
put &#34;0: $0 | 1: $1&#34;;  # 0:  | 1: -- nothing in these variables</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_named_captures">5.3.1. Named Captures</h4>
<div class="paragraph">
<p>Instead of relying on the numbered captures, you can give them names. These become keys in a [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) in the [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) object. Label a capture with a <code>$&lt;</code><strong>LABEL</strong><code>&gt;=</code> in front of the capturing parentheses:</p>
</div>
<div class="paragraph">
<p>你可以为它们命名，而不是依赖于编号的捕获。这些成为 [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) 对象中 [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) 的键。在捕获的圆括号前用 <code>$ &lt;LABEL&gt;=</code> 标记捕获：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas perlicus&#39;;
if / $&lt;genus&gt;=(\w+) \s+ $&lt;species&gt;=(\w+) / {
    put &#34;Genus: $/&lt;genus&gt;&#34;;      # Genus: Hamadryas
    put &#34;Species: $/&lt;species&gt;&#34;;  # Species: perlicus
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output is often much easier to understand when you label the captures. It’s also easier to modify the pattern without disrupting later code, since the positions of labels don’t matter.</p>
</div>
<div class="paragraph">
<p>As before, you can leave off the slash in <code>$/</code> but only if you use the angle brackets. This looks like [<code>Associative</code>](<a href="https://docs.raku.org/type/Associative.html" class="bare">https://docs.raku.org/type/Associative.html</a>) indexing even though the [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) isn’t an [<code>Associative</code>](<a href="https://docs.raku.org/type/Associative.html" class="bare">https://docs.raku.org/type/Associative.html</a>) type:</p>
</div>
<div class="paragraph">
<p>标记捕获时，输出通常更容易理解。在不破坏后续代码的情况下修改模式也更容易，因为标签的位置无关紧要。</p>
</div>
<div class="paragraph">
<p>和以前一样，只要使用尖括号，就可以省略 <code>$/</code> 中的斜杠。即使 [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) 不是[<code>关联</code>](<a href="https://docs.raku.org/type/Associative.html)类型，这看起来像"><code>关联</code></a>(<a href="https://docs.raku.org/type/Associative.html)索引：" class="bare">https://docs.raku.org/type/Associative.html)索引：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas perlicus&#39;;
if / $&lt;genus&gt;=(\w+) \s+ $&lt;species&gt;=(\w+) / {
    put &#34;Genus: $&lt;genus&gt;&#34;;      # Genus: Hamadryas
    put &#34;Species: $&lt;species&gt;&#34;;  # Species: perlicus
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A label name in a variable works, but in that case you can’t leave off the <code>/</code>:</p>
</div>
<div class="paragraph">
<p>变量中的标签名称有效，但在这种情况下，你不能省略 <code>/</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas perlicus&#39;;
my $genus-key = &#39;genus&#39;;
my $species-key = &#39;species&#39;;
if / $&lt;genus&gt;=(\w+) \s+ $&lt;species&gt;=(\w+) / {
    put &#34;Genus: $/{$genus-key}&#34;;      # Genus: Hamadryas
    put &#34;Species: $/{$species-key}&#34;;  # Species: perlicus
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you save the result the names are in your [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) in the same way they show up in <code>$/</code>:</p>
</div>
<div class="paragraph">
<p>如果你将结果保存，则名称在你的[<code>Match</code>](<a href="https://docs.raku.org/type/Match.html)中的方式与它们在" class="bare">https://docs.raku.org/type/Match.html)中的方式与它们在</a> <code>$/</code> 中显示的方式相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = &#39;Hamadryas perlicus&#39;;
my $match = $string ~~ m/ $&lt;genus&gt;=(\w+) \s+ $&lt;species&gt;=(\w+) /;

if $match {
    put &#34;Genus: $match&lt;genus&gt;&#34;;       # Genus: Hamadryas
    put &#34;Species: $match&lt;species&gt;&#34;;   # Species: perlicus
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>You don’t even need to know the names because you can get those from the [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>). Calling <code>.pairs</code> returns all the names:</p>
</div>
<div class="paragraph">
<p>你甚至不需要知道这些名字，因为你可以从[<code>Match</code>](<a href="https://docs.raku.org/type/Match.html)中得到这些名字。调用" class="bare">https://docs.raku.org/type/Match.html)中得到这些名字。调用</a> <code>.pairs</code> 返回所有名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = &#39;Hamadryas perlicus&#39;;
my $match = $string ~~ m/ $&lt;genus&gt;=(\w+) \s+ $&lt;species&gt;=(\w+) /;

put &#34;Keys are:\n\t&#34;,
    $match
        .pairs
        .map( { &#34;{.key}: {.value}&#34; } )
        .join( &#34;\n\t&#34; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>put</code> shows everything without knowing the names in advance:</p>
</div>
<div class="paragraph">
<p><code>put</code> 会在事先不知道名字的情况下显示所有内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Keys are:
    species: perlicus
    genus: Hamadryas</code></pre>
</div>
</div>
<div class="paragraph">
<p>When patterns get too complex (say, something that you have to spread over multiple lines) the numbered [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) variables will probably proliferate beyond your ability to track them. Names do a much better job of reminding you which capture contains what.</p>
</div>
<div class="paragraph">
<p>当模式变得过于复杂时（比如，你必须分散在多行上），编号的[<code>Match</code>](<a href="https://docs.raku.org/type/Match.html)变量可能会超出你跟踪它们的能力。名称可以更好地提醒你哪个捕获包含什么。" class="bare">https://docs.raku.org/type/Match.html)变量可能会超出你跟踪它们的能力。名称可以更好地提醒你哪个捕获包含什么。</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_a_capture_tree">5.3.2. A Capture Tree</h4>
<div class="paragraph">
<p>Inside capture parentheses you can have additional capture parentheses. Each group gets its own numbering inside the group that contains it:</p>
</div>
<div class="paragraph">
<p>在捕获圆括号内，你可以使用其他捕获圆括号。每个组在包含它的组内获得自己的编号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = &#39;Hamadryas perlicus&#39;;
say $string ~~ m/(perl (&lt;[a..z]&gt;+))/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output shows that there are two `$0`s and one of them is subordinate to the other. The captures are nested so the results are nested:</p>
</div>
<div class="paragraph">
<p>输出显示有两个 <code>$0</code>，其中一个从属于另一个。捕获是嵌套的，因此结果是嵌套的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢perlicus｣
 0 =&gt; ｢perlicus｣
  0 =&gt; ｢icus｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>To access the top-level match, use <code>$/[0]</code> or <code>$0</code>. To get the nested matches you access the next level with the appropriate subscript:</p>
</div>
<div class="paragraph">
<p>要访问顶级匹配，请使用 <code>$/[0]</code> 或 <code>$0</code>。要获取嵌套匹配，你可以使用相应的下标访问下一级别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = &#39;Hamadryas perlicus&#39;;
$string ~~ m/(perl (&lt;[a..z]&gt;+))/;

# explicit $/
say &#34;Top match: $/[0]&#34;;       # Top match: perlicus
say &#34;Inner match: $/[0][0]&#34;;  # Inner match: icus

# or skip the $/
say &#34;Top match: $0&#34;;          # Top match: perlicus
say &#34;Inner match: $0[0]&#34;;     # Inner match: icus</code></pre>
</div>
</div>
<div class="paragraph">
<p>This works for named captures in the same way. The outer captures include the inner text as well as the inner captures:</p>
</div>
<div class="paragraph">
<p>这适用于以相同方式命名的捕获。外部捕获包括内部文本以及内部捕获：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = &#39;Hamadryas perlicus&#39;;
$string ~~ m/
    $&lt;top&gt; = (perl
        $&lt;inner&gt; = (&lt;[a..z]&gt;+)
        )
    /;

# explicit $/
say &#34;Top match: $/&lt;top&gt;&#34;;           # Top match: perlicus
say &#34;Inner match: $/&lt;top&gt;&lt;inner&gt;&#34;;  # Inner match: icus

# or skip the $/
say &#34;Top match: $&lt;top&gt;&#34;;            # Top match: perlicus
say &#34;Inner match: $&lt;top&gt;&lt;inner&gt;&#34;;   # Inner match: icus</code></pre>
</div>
</div>
<div class="paragraph">
<p>It’s not one or the other. You can mix number variables and labels if that makes sense:</p>
</div>
<div class="paragraph">
<p>它不是一个或另一个。如果有意义，你可以混合数字变量和标签：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = &#39;Hamadryas perlicus&#39;;
$string ~~ m/
    ( perl $&lt;inner&gt; = (&lt;[a..z]&gt;+) )
    /;

# explicit $/
say &#34;Top match: $/[0]&#34;;           # Top match: perlicus
say &#34;Inner match: $/[0]&lt;inner&gt;&#34;;  # Inner match: icus

# or skip the $/
say &#34;Top match: $0&#34;;            # Top match: perlicus
say &#34;Inner match: $0&lt;inner&gt;&#34;;   # Inner match: icus</code></pre>
</div>
</div>
<div class="paragraph">
<p>This nesting makes it very easy to construct your pattern. The numbering is localized to the level you are in. If you add other captures to the pattern they only disturb their level.</p>
</div>
<div class="paragraph">
<p>EXERCISE 16.6Extract from the <strong>Butterflies_and_Moths.txt</strong> file all the scientific names between underscores (such as <code><em>Crocallis elinguaria</em></code>). Capture the genus and species separately. Which genus has the most species?</p>
</div>
<div class="paragraph">
<p>这种嵌套使得构建模式变得非常容易。编号已本地化到你所在的层级。如果你在模式中添加其他捕获，则只会影响其层级。</p>
</div>
<div class="paragraph">
<p>练习16.6 从 <strong>Butterflies_and_Moths.txt</strong> 文件中提取下划线之间的所有科学名称（例如 <code><em>Crocallis elinguaria</em></code>）。分别捕获属和种。哪个属种类最多？</p>
</div>
</div>
<div class="sect3">
<h4 id="_backreferences">5.3.3. Backreferences</h4>
<div class="paragraph">
<p>The result of a capture is available inside your patterns. You can use that to match something else in the same pattern. Use the [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) variables to refer to the part that you want:</p>
</div>
<div class="paragraph">
<p>捕获的结果可在模式中使用。你可以使用它来匹配相同模式中的其他内容。使用[<code>Match</code>](<a href="https://docs.raku.org/type/Match.html)变量来引用所需的部分：" class="bare">https://docs.raku.org/type/Match.html)变量来引用所需的部分：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = &#39;abba&#39;;
say $line ~~ / a (.) $0 a  /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output shows the entire match and the capture:</p>
</div>
<div class="paragraph">
<p>输出显示整个匹配和捕获：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢abba｣
 0 =&gt; ｢b｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>Refer to captures at the same level with the number variables. The <code>$0</code> and <code>$1</code> are backreferences to parts of the pattern that have already matched:</p>
</div>
<div class="paragraph">
<p>请参阅与数字变量在同一级别的捕获。 <code>$0</code> 和 <code>$1</code> 是对已经匹配的模式部分的反向引用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = &#39;abccba&#39;;
say $line ~~ / a (.)(.) $1 $0 a  /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are only two captures in the output:</p>
</div>
<div class="paragraph">
<p>输出中只有两个捕获：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢abccba｣
 0 =&gt; ｢b｣
 1 =&gt; ｢c｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the capture is nested you have to do a bit more work. You might think you can subscript the capture variable, but can you see why it fails silently?</p>
</div>
<div class="paragraph">
<p>如果捕获是嵌套的，则必须做更多的工作。你可能认为可以下标捕获变量，但是你能看到它为什么会无声地失败吗？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = &#39;abcca&#39;;
say $line ~~ / a (.(.)) $0[0] a  /;  # does not match!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Those square brackets are pattern metacharacters and not postcircumfix indexers! You think that you have an element in <code>$0</code>, but it’s really <code>$0</code> stringified followed by a group that is the literal text <code>0</code>.</p>
</div>
<div class="paragraph">
<p>To get around this parsing problem surround the subscript access in <code>$()</code> so the pattern sees it as one thing. There’s one more trick to make it work out. Backreferences are only valid at a sequence point where the match operator has filled in all the details. An empty code block can force that:</p>
</div>
<div class="paragraph">
<p>那些方括号是模式元字符而不是 postcircumfix 索引器！你认为你在 <code>$0</code> 有一个元素，但它实际上是 <code>$0</code> 字符串化后跟一个文字文本 <code>0</code> 的组。</p>
</div>
<div class="paragraph">
<p>为了解决这个解析问题围绕 <code>$()</code> 中的下标访问，所以模式将其视为一件事。还有一个技巧可以让它成功。反向引用仅在匹配运算符填充了所有详细信息的序列点有效。空代码块可以强制执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = &#39;abcca&#39;;
say  $line ~~ / a (.(.)) {} $($0[0]) a  /;  # matches</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the <code>$0[0]</code> can match the <strong>c</strong>:</p>
</div>
<div class="paragraph">
<p>现在 <code>$0[0]</code> 可以匹配 <strong>c</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢abcca｣
 0 =&gt; ｢bc｣
  0 =&gt; ｢c｣</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_surrounders_and_separators">5.4. Surrounders and Separators</h3>
<div class="paragraph">
<p>To match something that has prefix and suffix characters, you could type out the pattern in the order it appears in the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>). Here’s an example that matches a word in literal parentheses:</p>
</div>
<div class="paragraph">
<p>要匹配具有前缀和后缀字符的内容，你可以按照它在[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)中出现的顺序输出模式。这是一个与字面括号中的单词匹配的示例：" class="bare">https://docs.raku.org/type/Str.html)中出现的顺序输出模式。这是一个与字面括号中的单词匹配的示例：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = &#39;outside (pupa) outside&#39;;
say $line ~~ / &#39;(&#39; \w+ &#39;)&#39;  /;         # ｢(pupa)｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s not the best way to communicate that you want to match something in parentheses, though. The start and end characters aren’t next to each other in the pattern; you have to read ahead then surmise that the parentheses are circumfix parts of the same idea.</p>
</div>
<div class="paragraph">
<p>Instead, connect the beginning and end patterns with <code>~</code>, then put the interior pattern after that. This describes something surrounded by parentheses subordinate to the structure:</p>
</div>
<div class="paragraph">
<p>不过，这不是你想要在括号中匹配内容的最佳沟通方式。开始和结束字符在模式中不是彼此相邻的;你必须提前阅读，然后推测括号是同一个想法的一部分。</p>
</div>
<div class="paragraph">
<p>相反，用 <code>~</code> 连接开始和结束模式，然后在之后放置内部模式。这描述了从属于结构的括号所包围的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = &#39;outside (pupa) outside&#39;;
say $line ~~ / &#39;(&#39; ~ &#39;)&#39; \w+ /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is automatically nongreedy; it does not grab everything until the last closing parenthesis:</p>
</div>
<div class="paragraph">
<p>这是自动非贪婪的;在最后一个右括号之前它不会抓取所有内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = &#39;outside (pupa) space (pupa) outside&#39;;
say $line ~~ m/ &#39;(&#39; ~ &#39;)&#39; \w+ /; # ｢(pupa)｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>A global match will still find all the instances:</p>
</div>
<div class="paragraph">
<p>全局匹配仍将找到所有实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = &#39;outside (pupa) space (pupa) outside&#39;;
say $line ~~ m:global/ &#39;(&#39; ~ &#39;)&#39; \w+ /; # (｢(pupa)｣ ｢(pupa)｣)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Going the other way, suppose that you want to match a series of things that are separated by other characters. A line of comma-separated values is such a thing:</p>
</div>
<div class="paragraph">
<p>换句话说，假设你想要匹配由其他字符分隔的一系列事物。一行以逗号分隔的值是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = &#39;Hamadryas,Leptophobia,Vanessa,Gargina&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To match the letters separated by commas, you could match the first group of letters then every subsequent occurrence of a comma and another group of letters:</p>
</div>
<div class="paragraph">
<p>要匹配用逗号分隔的字母，你可以匹配第一组字母，然后匹配每个后续的逗号和另一组字母：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $line ~~ / (\w+) [ &#39;,&#39; (\w+) ]+ /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That works, but it’s annoying because you have to use <code>\w+</code> twice even though it’s describing the same thing. The <code>%</code> modifies a quantifier so that the pattern on the right comes between each group:</p>
</div>
<div class="paragraph">
<p>这是有效的，但它很烦人，因为你必须使用 <code>\w+</code> 两次，即使它描述同样的事情。 <code>%</code> 修饰量词，使右侧的模式位于每个组之间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $line ~~ / (\w+)+ % &#39;,&#39; /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output shows that you matched each group of letters:</p>
</div>
<div class="paragraph">
<p>输出显示你匹配了每组字母：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢Hamadryas,Leptophobia,Vanessa,Gargina｣
 0 =&gt; ｢Hamadryas｣
 0 =&gt; ｢Leptophobia｣
 0 =&gt; ｢Vanessa｣
 0 =&gt; ｢Gargina｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>A double percent allows a trailing separator in the overall match:</p>
</div>
<div class="paragraph">
<p>双百分号允许在整体匹配中使用尾分隔符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = &#39;Hamadryas,Leptophobia,Vanessa,&#39;;
say $line ~~ / (\w+)+ %% &#39;,&#39; /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that it matches that comma that follows <strong>Vanessa</strong> but does not create an empty capture after it:</p>
</div>
<div class="paragraph">
<p>请注意，它与 <strong>Vanessa</strong> 后面的逗号匹配，但不会在其后创建空捕获：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢Hamadryas,Leptophobia,Vanessa,｣
 0 =&gt; ｢Hamadryas｣
 0 =&gt; ｢Leptophobia｣
 0 =&gt; ｢Vanessa｣</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although you’d think that CSV files should be simple, they aren’t. In the wild all sorts of weird things happen. The [<code>Text::CSV</code>](<a href="https://modules.raku.org/dist/Text::CSV:cpan:HMBRAND" class="bare">https://modules.raku.org/dist/Text::CSV:cpan:HMBRAND</a>) module handles all of those tricky bits. Use that instead of doing it yourself.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>虽然你认为 CSV 文件应该很简单，但事实并非如此。在野外，各种各样奇怪的事情都会发生。 [<code>Text::CSV</code>](<a href="https://modules.raku.org/dist/Text::CSV:cpan:HMBRAND" class="bare">https://modules.raku.org/dist/Text::CSV:cpan:HMBRAND</a>) 模块处理所有这些棘手的部分。使用它而不是自己做。</p>
</div>
</div>
<div class="sect2">
<h3 id="_断言">5.5. 断言</h3>
<div class="paragraph">
<p>Assertions don’t match text; they require that a certain condition be true at the current position in the text. They match a context instead of characters. Specify these in your pattern to allow the matcher to fail faster. You don’t need to scan the entire text if the pattern should only work at the beginning of the text.</p>
</div>
<div class="paragraph">
<p>断言不匹配文本;他们要求在文本的当前位置某个条件为真。它们匹配上下文而不是字符。在模式中指定这些以允许匹配器更快地失败。如果模式仅适用于文本的开头，则无需扫描整个文本。</p>
</div>
<div class="sect3">
<h4 id="_锚点">5.5.1. 锚点</h4>
<div class="paragraph">
<p>An anchor prevents the pattern from floating over the text to find a place where it can start matching. It requires that a pattern match at a particular position. If the pattern doesn’t match at that position the match can immediately fail and save itself the work of scanning the text.</p>
</div>
<div class="paragraph">
<p>The <code>^</code> forces your pattern to match at the absolute beginning of the text. This matches because the <strong>Hama</strong> comes at the beginning of the text:</p>
</div>
<div class="paragraph">
<p>锚点可防止模式浮动在文本上以找到可以开始匹配的位置。它要求在特定位置匹配模式。如果模式在该位置不匹配，则匹配可能立即失败并自行保存扫描文本的工作。</p>
</div>
<div class="paragraph">
<p><code>^</code> 强制你的模式在文本的绝对开头匹配。下面这个会匹配，因为 <strong>Hama</strong> 出现在文本的开头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;Hamadryas perlicus&#39; ~~ / ^ Hama /;  # ｢Hama｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>Trying to match <strong>perl</strong> after <code>^</code> fails because that pattern is not at the beginning of the text:</p>
</div>
<div class="paragraph">
<p>尝试匹配 <code>^</code> 后面的 <strong>perl</strong> 会失败，因为该模式不在文本的开头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;Hamadryas perlicus&#39; ~~ / ^ perl /;  # Nil (fails)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Without the anchor the match would drift over the text looking at each position to check for <strong>perl</strong>. That’s extra work (and probably incorrect) if you know that you want to match at the beginning. Once the match fails at the beginning it’s immediately done.</p>
</div>
<div class="paragraph">
<p>The <code>$</code> is the end-of-string anchor and does something similar at the end of the text:</p>
</div>
<div class="paragraph">
<p>没有锚点，匹配将漂移在文本上，查看每个位置以检查 <strong>perl</strong>。如果你知道你想在开始时匹配，这是额外的工作（可能是不正确的）。一旦匹配在开始时失败，匹配立即结束。</p>
</div>
<div class="paragraph">
<p><code>$</code> 是字符串结尾的锚点，并在文本末尾执行类似的操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;Hamadryas perlicus&#39; ~~ / icus $ /;  # ｢icus｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>This one doesn’t match because there’s more text after <strong>icus</strong>:</p>
</div>
<div class="paragraph">
<p>这个不匹配，因为 <strong>icus</strong> 之后有更多的文本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;Hamadryas perlicus navitas&#39; ~~ / icus $ /;  # Nil (fails)</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are anchors for the beginning and end of a line; that could be different from the beginning and end of the text. A line ends with a newline and that newline might be in the middle of your multiline text, like in this one (remember that the here doc strips the indention):</p>
</div>
<div class="paragraph">
<p>行的开头和结尾都有锚点;这可能与文本的开头和结尾不同。行以换行符结尾，换行符可能位于多行文本的中间，就像在这一行中一样（请记住，here doc 删除了缩进）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = chomp q:to/END/;   # chomp removes last newline
    Chorinea amazon
    Hamadryas perlicus
    Melanis electron
    END</code></pre>
</div>
</div>
<div class="paragraph">
<p>The beginning-of-line anchor, <code>^^</code>, matches after the absolute beginning of the text or immediately after any newline. These both work because <strong>Chorinea</strong> is at the start of the text and the start of the first line:</p>
</div>
<div class="paragraph">
<p>行首的锚点 <code>^^</code> 在文本的绝对开头之后或在任何换行符之后立即匹配。下面这两者都有效，因为 <strong>Chorinea</strong> 位于文本的开头和第一行的开头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say m/ ^  Chorinea /;  # ｢Chorinea｣
say m/ ^^ Chorinea /;  # ｢Chorinea｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>Likewise, the end-of-line anchor, <code>$$</code>, matches before any newline or at the absolute end of the text. These also both work because <strong>electron</strong> is at the end of the text and the end of the last line:</p>
</div>
<div class="paragraph">
<p>同样，行尾锚点 <code>$$</code> 在任何换行符之前或文本的绝对末尾匹配。下面这些也都有效，因为 <strong>electron</strong> 在文本的末尾和最后一行的结尾：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say m/ electron $  /;  # ｢electron｣
say m/ electron $$ /;  # ｢electron｣</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Hamadryas</strong> can’t match at the absolute beginning of the text but it can match at the beginning of a line:</p>
</div>
<div class="paragraph">
<p><strong>Hamadryas</strong> 在文本的绝对开头不能匹配，但它可以在一行的开头匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say m/ ^  Hamadryas /; # Nil
say m/ ^^ Hamadryas /; # ｢Hamadryas｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, <strong>perlicus</strong> can’t match at the absolute end of the text but it can match at the end of a line:</p>
</div>
<div class="paragraph">
<p>同样，<strong>perlicus</strong> 在文本的绝对末尾不能匹配，但它可以在一行的末尾匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say m/ perlicus $  /;  # Nil
say m/ perlicus $$ /;  # ｢perlicus｣</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_conditions">5.5.2. Conditions</h4>
<div class="paragraph">
<p><strong>Word boundaries</strong> exist when a non-“word” character is next to a “word” character (in either order). Those terms are a bit fuzzy, since you likely think of word characters as the alphabetic characters. They are, however, the ones that match <code>\w</code>, which includes numbers and other things. The beginning and the end of the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) count as nonword characters.</p>
</div>
<div class="paragraph">
<p>EXERCISE 16.7Output all the “word” characters that are not alphabetic characters. How many of them are there? The [Range](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>)<code>0 .. 0xFFFF</code> and the <code>.chr</code> method should be helpful.</p>
</div>
<div class="paragraph">
<p>Assert a word boundary with <code>&lt;|w&gt;</code>. Suppose that you want to match the name <strong>Hamad</strong>. Without a word boundary that would match in <strong>Hamadryas</strong>, but that’s not what you want. The word boundary keeps it from showing up in the middle of another word:</p>
</div>
<div class="paragraph">
<p>*当非“单词”字符紧邻“单词”字符时（以任一顺序），则存在单词边界。这些术语有点模糊，因为你可能会将单词字符视为字母字符。然而，它们是匹配 <code>\w</code> 的，包括数字和其他东西。 [<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)的开头和结尾计为非单词字符。" class="bare">https://docs.raku.org/type/Str.html)的开头和结尾计为非单词字符。</a></p>
</div>
<div class="paragraph">
<p>练习16.7 输出所有非字母字符的“单词”字符。他们中有多少个？ [Range](<a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>) <code>0 .. 0xFFFF</code> 和 <code>.chr</code> 方法应该会有所帮助。</p>
</div>
<div class="paragraph">
<p>用 <code>&lt;|w&gt;</code> 断言单词边界。假设你想要匹配 <strong>Hamad</strong> 这个名字。没有在 <strong>Hamadryas</strong> 中匹配的单词边界，但这不是你想要的。单词边界使它不会出现在另一个单词的中间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas&#39;;
say m/ Hamad /;       # ｢Hamad｣
say m/ Hamad &lt;|w&gt; /;  # Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>That second pattern can’t match because <strong>Hamadryas</strong> has a word character (a letter) following <strong>Hamad</strong>. The next example matches because a space follows <strong>Hamad</strong>:</p>
</div>
<div class="paragraph">
<p>第二种模式无法匹配，因为 <strong>Hamadryas</strong> 在 <strong>Hamad</strong> 之后有一个单词字符（一个字母）。下一个例子匹配，因为 <strong>Hamad</strong> 后面有一个空格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = &#39;Ali Hamad bin Perliana&#39;;
say $name ~~ / Hamad &lt;|w&gt; /;  # ｢Hamad｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>Word boundaries on each side isolate a word. These matches look for <code>dry</code> as its own word because it has word boundaries on each side. The first one fails because it’s in the middle of a bigger word:</p>
</div>
<div class="paragraph">
<p>每一边的单词边界隔离一个单词。这些匹配寻找 <code>day</code> 作为它们自己的单词，因为它的每一边都有单词边界。第一个失败，因为它在一个更大的单词的中间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas&#39;;
say m/ &lt;|w&gt; dry &lt;|w&gt; /;  # Nil

$_ = &#39;The flower is dry&#39;;
say m/ &lt;|w&gt; dry &lt;|w&gt; /;  # ｢dry｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of <code>&lt;|w&gt;</code> you can use the <code>&lt;&lt;</code> or <code>&gt;&gt;</code> to point to where the nonword characters should be:</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>&lt;&lt;</code> 或 <code>&gt;&gt;</code> 代替 <code>&lt;|w&gt;</code> 来指向非单词字符的位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;The flower is dry&#39;;
say m/ &lt;&lt; dry &gt;&gt; /;  # ｢dry｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>The arrows can point either way, but always toward the nonword characters:</p>
</div>
<div class="paragraph">
<p>箭头可以指向任一方向，但始终指向非单词字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;a!bang&#39;;
say m/ &lt;&lt; .+ &gt;&gt; /;   # ｢a!bang｣   - greedy
say m/ &lt;&lt; .+? &gt;&gt; /;  # ｢a｣        - nongreedy
say m/ &gt;&gt; .+ &gt;&gt; /;   # ｢!bang｣
say m/ &gt;&gt; .+ &lt;&lt; /;   # ｢!｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>The opposite of a word boundary assertion is <code>&lt;!|w&gt;</code>. That means that both sides of the assertion must be the same type of character—either both word characters or both nonword characters. Now the results are flipped:</p>
</div>
<div class="paragraph">
<p>单词边界断言的反义词是 <code>&lt;!|w&gt;</code>。这意味着断言的两边必须是相同类型的字符 - 两个单词字符或两个非单词字符。现在翻转结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas&#39;;
say m/ &lt;!|w&gt; dry &lt;!|w&gt; /;  # ｢dry｣

$_ = &#39;The flower is dry&#39;;
say m/ &lt;!|w&gt; dry &lt;!|w&gt; /;  # Nil</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_代码断言">5.5.3. 代码断言</h4>
<div class="paragraph">
<p>Code assertions are perhaps the most amazing and powerful part of regular expressions. You can inspect what’s happened so far and use arbitrarily complex code to decide if you accept that. If your code evaluates to `True`you satisfy the assertion and the pattern can keep matching. Otherwise, your pattern fails.</p>
</div>
<div class="paragraph">
<p>Your code for the assertion shows up in <code>&lt;?{}&gt;</code>. You can put almost anything you like in there:</p>
</div>
<div class="paragraph">
<p>代码断言可能是正则表达式中最令人惊讶和最强大的部分。你可以检查到目前为止发生了什么，并使用任意复杂的代码来决定你是否接受。如果你的代码求值为 <code>True</code> 则你满足断言，并且模式可以保持匹配。否则，你的模式将失败。</p>
</div>
<div class="paragraph">
<p>你的断言代码显示在 <code>&lt;?{}&gt;</code> 中。你可以把几乎任何你喜欢的东西放在那里：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#39;Hamadryas&#39; ~~ m/ &lt;?{ put &#39;Hello!&#39; }&gt; /;   # Hello!</code></pre>
</div>
</div>
<div class="paragraph">
<p>This matches no characters in <strong>Hamadryas</strong> but is also not the null pattern (which is not valid). From inside the assertion you get <code>Hello!</code> as output:</p>
</div>
<div class="paragraph">
<p>这与 <strong>Hamadryas</strong> 中的任何字符都不匹配，但也不是空模式（它是无效的）。从断言内你得到 <code>Hello!</code> 作为输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put
    &#39;Hamadryas&#39; ~~ m/ &lt;?{ put &#39;Hello!&#39; }&gt; /
        ?? &#39;Worked&#39; !! &#39;Failed&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This first outputs from inside the assertion:</p>
</div>
<div class="paragraph">
<p>这首先从断言内部输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Hello!
Worked!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Change the assertion so that <code>False</code> is the last expression:</p>
</div>
<div class="paragraph">
<p>更改断言，以便 <code>False</code> 是最后一个表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put
    &#39;Hamadryas&#39; ~~ m/ &lt;?{ put &#39;Hello!&#39;; False }&gt; /
        ?? &#39;Worked&#39; !! &#39;Failed&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You get much more output. As the code assertion fails the match cursor moves along the text and tries again. Each time the code assertion returns <code>False</code> it tries again. It keeps doing that until it gets to the end of the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>):</p>
</div>
<div class="paragraph">
<p>你得到更多的输出。由于代码断言失败，匹配游标沿文本移动并再次尝试。每次代码断言返回 <code>False</code> 时，它再次尝试。它一直这样做，直到它到达[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)的结尾：" class="bare">https://docs.raku.org/type/Str.html)的结尾：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Hello!
Hello!
Hello!
Hello!
Hello!
Hello!
Hello!
Hello!
Hello!
Hello!
Failed</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here’s something more complex. Suppose you want to match even numbers only. You could create a pattern that looks for an even digit at an end of a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>):</p>
</div>
<div class="paragraph">
<p>这是更复杂的事情。假设你只想匹配偶数。你可以创建一个模式，在[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)的末尾查找偶数：" class="bare">https://docs.raku.org/type/Str.html)的末尾查找偶数：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;538&#39; ~~ m/ ^ \d* &lt;[24680]&gt; $ /;   # ｢538｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>With a code assertion you don’t care which digits you match as long as they are even. This makes the pattern a bit simpler by showing the complexity as code. Your intent may be clearer this way:</p>
</div>
<div class="paragraph">
<p>使用代码断言，只要它们是偶数，就不关心匹配哪些数字。通过将复杂性显示为代码，这使得模式更简单。你的意图可能会更加清晰：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;538&#39; ~~ m/ ^ (\d+) &lt;?{ $0 %% 2 }&gt; /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s a capture and that text also is divisible by two, so that match succeeds:</p>
</div>
<div class="paragraph">
<p>有一个捕获，该文本也可被 2 整除，因此匹配成功：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢538｣
 0 =&gt; ｢538｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>It stills works if the characters aren’t the ASCII decimal digits:</p>
</div>
<div class="paragraph">
<p>如果字符不是 ASCII 十进制数字，它仍然有效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;١٣٨&#39; ~~ m/ ^ (\d+) &lt;?{ $0 %% 2 }&gt; /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or even:</p>
</div>
<div class="paragraph">
<p>甚至：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;١٣٨&#39; ~~ m/ ^ (\d+) &lt;?{ $0 %% ٢ }&gt; /;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_匹配ipv4_地址">匹配IPV4 地址</h5>
<div class="paragraph">
<p>Consider a pattern to match a dotted-decimal IP address. There are four decimal numbers from 0 to 255, such as 127.0.0.1 (the loopback address). You could write a pattern without an assertion, but you have to figure out how to restrict the range of the number:</p>
</div>
<div class="paragraph">
<p>考虑匹配点分十进制 IP 地址的模式。从 0 到 255 有四个十进制数，例如 127.0.0.1（环回地址）。你可以编写一个没有断言的模式，但你必须弄清楚如何限制数字的范围：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $dotted-decimal = rx/ ^
    [
    || [ &lt;[ 0 1 ]&gt; &lt;[ 0 .. 9 ]&gt; ** 0..2 ]  # 0 to 199
    || [
        2
        [
        || &lt;[ 0 .. 4 ]&gt; &lt;[ 0 .. 9 ]&gt;       # 200 to 499
        || 5 &lt;[ 0 .. 5 ]&gt;                  # 250 to 255
        ]
       ]
    ] ** 4 % &#39;.&#39;
    $
    /;

say &#39;127.0.0.1&#39; ~~ $dotted-decimal;  # ｢127.0.0.1｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>Matching on text to suss out numerical values means careful handling of each character position. That’s a lot of work and uses a feature you haven’t seen yet (alternations are coming up). You could reduce that to almost nothing with a code assertion that looks at the text you just matched and tells the pattern if you want to accept it:</p>
</div>
<div class="paragraph">
<p>匹配文本以取代数值意味着仔细处理每个字符位置。这是很多工作，并使用了你还没有看到的功能（备选分支即将到来）。你可以使用代码断言将其减少到几乎为零，该代码断言查看你刚匹配的文本并告诉模式你是否要接受它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $easier = rx/
    ^
    ( &lt;[0..9]&gt;+: &lt;?{ 0 &lt;= $/ &lt;= 255 }&gt; ) ** 4 % &#39;.&#39;
    $
    /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The assertion is <code>&lt;?{ 0 ⇐ $/ ⇐ 255 }&gt;</code>. That <code>$/</code> is the [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) for only that level of parentheses. This allows you to be sloppy in the pattern for matching digits. You don’t care if you match 4, 5, or 20 digits because the code assertion will check that.</p>
</div>
<div class="paragraph">
<p>If that code assertion fails after matching digits, you don’t want to give back some of the digits to try again. You know the next thing must be the <code>.</code> between groups of digits. To prevent any backtracking you use the <code>:</code> on that `+`quantifier. You don’t need this to get the right match but it creates less work to ultimately fail.</p>
</div>
<div class="paragraph">
<p>The <code>%</code> modifies the <code>** 4</code> quantifier so a literal <code>.</code> shows up between each of the four groups of digits.</p>
</div>
<div class="paragraph">
<p>断言是 <code>&lt;?{ 0 ⇐ $/ ⇐ 255 }&gt;</code> 那个 <code>$/</code> 是只有那个括号级别的[<code>Match</code>](<a href="https://docs.raku.org/type/Match.html)。这允许你在匹配数字的模式中马虎。你不关心是否匹配" class="bare">https://docs.raku.org/type/Match.html)。这允许你在匹配数字的模式中马虎。你不关心是否匹配</a> 4, 5 或 20 位数字，因为代码断言将检查该数字。</p>
</div>
<div class="paragraph">
<p>如果代码断言在匹配数字后失败，则你不希望归还一些数字再次尝试。你知道下一件事必须是数字组之间的  <code>.</code> 。要防止任何回溯，请在量词 <code>+</code> 上使用 <code>:</code>。你不需要这个来获得正确的匹配，但它创造的工作量最少，最终失败。</p>
</div>
<div class="paragraph">
<p><code>%</code> 修饰 <code>** 4</code> 量词，所以字面 <code>.</code> 显示在四组数字中的每一组之间。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_alternations">5.6. Alternations</h3>
<div class="paragraph">
<p>Sometimes there are several distinct patterns that might match at the same position. An alternation is a way to specify that. There are two ways to do this: it can match the first alternative that succeeds or it can match the longest one.</p>
</div>
<div class="paragraph">
<p>有时，有几种不同的模式可能在同一位置匹配。交替是一种指定它的方式。有两种方法可以做到这一点：它可以匹配成功的第一个选项，也可以匹配最长的选项。</p>
</div>
<div class="sect3">
<h4 id="_first_match">5.6.1. First Match</h4>
<div class="paragraph">
<p>If you’ve used regexes in other languages you’re probably used to alternations where the leftmost alternative that can match is the one that wins. Set up this type of alternation with a <code>||</code> between the possibilities:</p>
</div>
<div class="paragraph">
<p>如果你已经在其他语言中使用了正则表达式，那么你可能会习惯于可以匹配的最左侧备选分支胜出的备选分支。使用 <code>||</code> 在可能的备选分支之间设置此类备选分支：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/ abc || xyz || 1234 /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Either <code>abc</code>, <code>xyz</code>, or <code>1234</code> can match:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @strings = &lt; 1234 xyz abc 789 &gt;;
for @strings {
    put &#34;$_ matches&#34; if $_ ~~ $pattern;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first three [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)s" class="bare">https://docs.raku.org/type/Str.html)s</a> match because they have at least one of the alternatives:</p>
</div>
<div class="paragraph">
<p>前三个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)匹配，因为他们至少有一个备选分支：" class="bare">https://docs.raku.org/type/Str.html)匹配，因为他们至少有一个备选分支：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1234 matches
xyz matches
abc matches</code></pre>
</div>
</div>
<div class="paragraph">
<p>The alternation has an interesting feature: you can start it with a <code>||</code> with nothing before it. This is the same pattern and does not create an empty alternative at the beginning:</p>
</div>
<div class="paragraph">
<p>备选分支有一个有趣的特点：你可以以一个前面什么都没有的 <code>||</code> 开始。这是相同的模式，并且不会在开头创建一个空的备选分支：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/ || abc || xyz || 1234 /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This looks better spread out so each alternation gets its own line. The reformatted pattern starts with <code>||</code> and has a more pleasing parallel structure that allows you to remove lines without disturbing the other alternatives:</p>
</div>
<div class="paragraph">
<p>这看起来更好地展开，因此每个备选分支单独占一行。重新格式化的模式以 <code>||</code> 开头并且有一个更令人愉悦的并行结构，允许你删除行而不会打扰其他备选分支：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/
    || abc
    || xyz
    || 1234
    /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of placing a <code>||</code> between each alternative, you can put it before a bunch of alternatives. Do that with an [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) directly in your pattern:</p>
</div>
<div class="paragraph">
<p>你可以把 <code>||</code> 放在一堆备选分支之前而不是在每个备选分支之间放置 <code>||</code>。直接在你的模式中使用[<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)执行此操作：" class="bare">https://docs.raku.org/type/Array.html)执行此操作：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/ || @(&lt;abc xyz 1234&gt;) /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An existing variable after the <code>||</code> does the same thing:</p>
</div>
<div class="paragraph">
<p><code>||</code> 之后的现有变量做同样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @variable = &lt;abc xyz 1234&gt;;
my $pattern = rx/ || @variable /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You aren’t interpolating that [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>). The pattern uses the current value of the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) when it matches. In this example the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) has <code>1234</code> as the last element when you define the pattern. Before you use the pattern you change that last element:</p>
</div>
<div class="paragraph">
<p>你没有插值该[<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)。该模式在匹配时使用"><code>数组</code></a>(<a href="https://docs.raku.org/type/Array.html)的当前值。在此示例中，"><code>数组</code></a>(<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) 在定义模式时将 <code>1234</code> 作为最后一个元素。在使用该模式之前，你需要更改最后一个元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @strings = &lt; 1234 xyz abc 56789 &gt;;
my @variable = &lt;abc xyz 1234&gt;;
my $pattern = rx/ || @variable /;

put &#34;Before:&#34;;
for @strings {
    put &#34;\t$_ matches&#34; if $_ ~~ $pattern;
}

# change the array after making the pattern
@variable[*-1] = 789;

put &#34;After:&#34;;
for @strings {
    put &#34;\t$_ matches&#34; if $_ ~~ $pattern;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output shows that you matched with the current value of the variable instead of its value when you created the pattern. Different values match after you change the [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>):</p>
</div>
<div class="paragraph">
<p>输出显示你匹配的变量的当前值，而不是匹配该模式创建时的值。更改[<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)后，匹配到不同的值：" class="bare">https://docs.raku.org/type/Array.html)后，匹配到不同的值：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Before:
    1234 matches
    xyz matches
    abc matches
After:
    xyz matches
    abc matches
    56789 matches</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 16.8Output all the lines from the butterfly census file that have the genus <strong>Lycaena</strong>, <strong>Zizeeria</strong>, or <strong>Hamadryas</strong>. How many different species did you find?</p>
</div>
<div class="paragraph">
<p>练习16.8 输出蝴蝶人口普查文件中有 <strong>Lycaena</strong>，<strong>Zizeeria</strong> 或 <strong>Hamadryas</strong> 属的所有行。你找到了多少种不同的物种？</p>
</div>
</div>
<div class="sect3">
<h4 id="_longest_token_matching">5.6.2. Longest Token Matching</h4>
<div class="paragraph">
<p>Some alternations might have “better” possibilities that could match. Rather than choosing the first specified possibility you can tell the match operator to try all of them, then choose the “best” one. This is generally calledlongest token matching (LTM), but it finds the best, not longest, match.</p>
</div>
<div class="paragraph">
<p>LTM alternation uses a single <code>|</code>. In this pattern all of the alternatives can match. The first possibility it could match is the single <code>a</code>. The “best” match is <code>abcd</code>, though. That’s the match you see in the output:</p>
</div>
<div class="paragraph">
<p>一些备选分支可能具有可以匹配的“更好”的可能性。你可以告诉匹配操作符尝试所有这些，然后选择“最佳”的可能性，而不是选择第一个指定的可能性。这通常称为最长令牌匹配（LTM），但它找到最佳匹配，而不是最长匹配。</p>
</div>
<div class="paragraph">
<p>LTM 备选分支使用单个 <code>|</code>。在这种模式中，所有备选分支都可以匹配。它可以匹配的第一种可能性是单个 <code>a</code>。不过，“最佳”匹配是 <code>abcd</code>。这是你在输出中看到的匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pattern = rx/
    | a
    | ab
    | abcd
    /;

say &#39;abcd&#39; ~~ $pattern;  # ｢abcd｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>An [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>) variable works just like it did in the <code>||</code> examples:</p>
</div>
<div class="paragraph">
<p>[<code>数组</code>](<a href="https://docs.raku.org/type/Array.html)变量就像在" class="bare">https://docs.raku.org/type/Array.html)变量就像在</a> <code>||</code> 例子中一样工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @variable = &lt;a ab abcd&gt;;
my $pattern = rx/ | @variable /;

say &#39;abcd&#39; ~~ $pattern;  # ｢abcd｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>What makes one possibility better than another? There are some rules that decide this. Better patterns have longer tokens, and that’s where the confusion comes in. It’s not actually about how much text it matches; it’s about the pattern.</p>
</div>
<div class="paragraph">
<p>This next part will probably be more than you’ll ever want to know. A pattern can have both declarative and procedural elements. In short, some parts of the pattern merely describe some text and other parts force the match operator to do something. The <code>abc</code> is declarative. The <code>{}</code> inline code is an action.</p>
</div>
<div class="paragraph">
<p>Consider this example. The longest text that might match is <strong>Hamadry</strong>. That alternative has the <code>{True}</code> inline code block in it, though. The second alternative is simply <code>Hamad</code>, and that is the one that matches:</p>
</div>
<div class="paragraph">
<p>是什么让一种可能性比另一种更好？有一些规则可以决定这一点。更好的模式有更长的令牌，这就是困惑的来源。实际上并不是它匹配多少文本;这是关于模式的。</p>
</div>
<div class="paragraph">
<p>下一部分可能比你想知道的要多。模式可以同时具有声明和过程元素。简而言之，模式的某些部分仅描述一些文本，而其他部分则强制匹配操作符执行某些操作。 <code>abc</code> 是声明性的。 <code>{}</code> 内联代码是一个动作。</p>
</div>
<div class="paragraph">
<p>请看这个例子。可能匹配的最长文本是 <strong>Hamadry</strong>。但是，该备选分支中包含 <code>{True}</code> 内联代码块。第二个备选分支只是 <code>Hamad</code>，那是匹配的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;Hamadryas perlicus sixus&#39; ~~ m/
    | Hama{True}dry
    | Hamad
    /;  # ｢Hamad｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the match operator is deciding which one has priority it looks for the pattern that has the longest declarative part. The first one has <code>Hama</code>; the second one has <code>Hamad</code>. That makes the second one the longer token. It’s about the pattern, not the target text. (Ignore that you haven’t read a definition of a token yet.)</p>
</div>
<div class="paragraph">
<p>Sometimes the two patterns can have the same size tokens, like these two alternatives. One has a character class and the other a literal <strong>d</strong>. The more specific one (the literal) wins:</p>
</div>
<div class="paragraph">
<p>当匹配运算符决定哪一个具有优先级时，它会查找具有最长声明部分的模式。第一个有 <code>Hama</code>;第二个有 <code>Hamad</code>。这使得第二个有更长的令牌。它是关于模式，而不是关于目标文本。 （忽略你还没有读过令牌的定义。）</p>
</div>
<div class="paragraph">
<p>有时这两种模式可以具有相同大小的令牌，就像这两个备选分支一样。一个有字符类，另一个有字面值 <strong>d</strong>。更具体的一个（字面的）获胜：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas perlicus sixus&#39;;

say &#39;Hamadryas perlicus sixus&#39; ~~ m/
    | Hama&lt;[def]&gt;{put &#34;first&#34;}
    | Hamad      {put &#34;second&#34;}
    /;  # ｢Hamad｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html)s" class="bare">https://docs.raku.org/type/Block.html)s</a> are only there to show which alternative was “best”:</p>
</div>
<div class="paragraph">
<p>代码[<code>块</code>](<a href="https://docs.raku.org/type/Block.html)仅用于显示哪种备选分支“最佳”：" class="bare">https://docs.raku.org/type/Block.html)仅用于显示哪种备选分支“最佳”：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">second
｢Hamad｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>Change that around to see it still choose the more specific one:</p>
</div>
<div class="paragraph">
<p>改变它，看它仍然选择更具体的一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#39;Hamadryas perlicus sixus&#39;;

say &#39;Hamadryas perlicus sixus&#39; ~~ m/
    | Hamad      {put &#34;first&#34;}
    | Hama&lt;[def]&gt;{put &#34;second&#34;}
    /;  # ｢Hamad｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the first alternative is more specific and it is “best”:</p>
</div>
<div class="paragraph">
<p>现在第一个备选分支更具体，它是“最好的”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">first
｢Hamad｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>So what counts as a <strong>token</strong>? It’s the longest stretch of things that aren’t procedural. As I write this, however, the documentation avoids defining that. It requires deep knowledge of what happens in the guts of the language. It’s a big ugly topic that I’ll now ignore, although the book <strong>Mastering Regular Expressions</strong> by Jeffrey E.F. Friedl(O’Reilly) will tell you most of what you need to know. Perhaps the confusion will sort itself out by the time you read this.</p>
</div>
<div class="paragraph">
<p>什么算作 <strong>token</strong> 呢？这是最长的一些不是程序性的东西。然而，当我写这篇文章时，文档避免了定义它。它需要深入了解语言的内容。虽然 Jeffrey E.F.Friedl（O’Reilly）的“掌握正则表达式”这本书将告诉你大部分你需要知道的东西，但我现在忽略了一个很大的丑陋主题。也许当你读到这篇文章时，这种困惑会自行解决。</p>
</div>
<div class="paragraph">
<p>All of that is to say that the match operator looks at each <code>|</code> alternative and can choose to do the one it thinks provides the best match. The match operator does not have to do them in the order that you typed them.</p>
</div>
<div class="paragraph">
<p>所有这一切都是说匹配运算符会查看每个 <code>|</code> 备选分支，并可以选择做它认为提供最佳匹配的那个。匹配运算符不必按你键入的顺序执行它们。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_summary_10">5.7. Summary</h3>
<div class="paragraph">
<p>In this chapter you saw the common regex features that will solve most of your pattern problems. You can repeat parts of a pattern, capture and extract parts of the text, define alternate patterns that can match, and specify conditions within the pattern. There is much more that patterns can do for you. Practice what you’ve read here and delve into the documentation to discover more.</p>
</div>
<div class="paragraph">
<p>在本章中，你看到了可以解决大多数模式问题的常见正则表达式功能。你可以重复模式的某些部分，捕获和提取文本的某些部分，定义可以匹配的备选分支模式，以及指定模式中的条件。模式可以为你做更多的事情。练习你在这里阅读的内容并深入研究文档以发现更多信息。
== Grammars</p>
</div>
<div class="paragraph">
<p>Grammars are patterns on a higher plane of existence. They integrate and reuse pattern fragments to parse and react to complicated formats. This feature is at the core of Raku in a very literal sense; the language itself is implemented as a grammar. Once you start using it you’ll probably prefer it to regexes for all but the most simple problems.</p>
</div>
<div class="paragraph">
<p>Grammars 是存在于更高层面上的模式。它们集成并重用模式片段来解析复杂的格式并做出反应。从字面意义上讲，这个功能是Raku的核心;语言本身是作为语法实现的。一旦你开始使用它，你可能更喜欢它除了最简单的问题之外的所有正则表达式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_simple_grammar">5.8. A Simple Grammar</h3>
<div class="paragraph">
<p>A grammar is a special sort of package. It can have methods and subroutines but mostly comprises special pattern methods called <code>regex</code>, <code>token</code>, and <code>rule</code>. Each of these define a pattern and apply different modifiers.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Raku tends to refer to <code>regex</code>, <code>token</code>, and <code>rule</code> declarations as “rules,” which can be a bit imprecise at times. In this book, you can tell the difference between the language keyword and the general term by the typesetting. I’ll try to not present an ambiguous situation.
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Start with something simple (too simple for grammars). Define a <code>TOP</code> pattern that matches digits as the starting point. That name is special because <code>.parse</code> uses it by default. In this example, you declare that with <code>regex</code>:</p>
</div>
<div class="paragraph">
<p>Grammar 是一种特殊的包。它可以有方法和子程序，但主要包括称为 <code>regex</code>，<code>token</code> 和 <code>rule</code> 的特殊模式方法。其中每个都定义了一个模式并应用了不同的修饰符。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Raku 倾向于将 <code>regex</code>，<code>token</code> 和 <code>rule</code> 声明称为“规则”，有时可能有点不精确。在本书中，你可以通过排版来区分语言关键字和一般术语。我会尽量不提出模棱两可的情况。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>从简单的东西开始（对于 grammar 来说太简单了）。定义匹配数字作为起点的 <code>TOP</code> 模式。该名称很特殊，因为 <code>.parse</code> 默认使用它。在此示例中，你使用 <code>regex</code> 声明一个 <code>TOP</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Number {
    regex TOP { \d }
    }

my $result = Number.parse( &#39;7&#39; );  # works

put $result ?? &#39;Parsed!&#39; !! &#39;Failed!&#39;;  # Parsed!</code></pre>
</div>
</div>
<div class="paragraph">
<p>This succeeds. <code>.parse</code> applies the grammar to the entire value of <code>7</code>. It starts with the parts that <code>TOP</code> describes. It can match a digit, and the value you pass to <code>.parse</code> is a digit.</p>
</div>
<div class="paragraph">
<p>When <code>.parse</code> succeeds, it returns a [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) object (it returns <code>Nil</code> when it fails). Try it with a different value. Instead of a single digit, try several digits:</p>
</div>
<div class="paragraph">
<p>这成功了。 <code>.parse</code> 将 grammar 应用于整个值 <code>7</code>. 它从 <code>TOP</code> 描述的部分开始。它可以匹配一个数字，你传递给 <code>.parse</code> 的值是一个数字。</p>
</div>
<div class="paragraph">
<p>当 <code>.parse</code> 成功时，它返回一个 [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) 对象（当它失败时返回 <code>Nil</code>）。尝试使用不同的值。尝试几个数字而不是单个数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result = Number.parse( &#39;137&#39; );  # fails (extra digits)

put $result ?? &#39;Parsed!&#39; !! &#39;Failed!&#39;;  # Failed!</code></pre>
</div>
</div>
<div class="paragraph">
<p>This time <code>.parse</code> doesn’t succeed. It starts matching with the first character and ends matching on the last character. It asserts that the text starts, there is a single digit, and the text ends. If <code>.parse</code> sees that there are some characters before or after its match, it fails. It matches everything or not at all. It’s almost the same thing as explicitly using anchors:</p>
</div>
<div class="paragraph">
<p>这次 <code>.parse</code> 没有成功。它开始与第一个字符匹配，并在最后一个字符上结束匹配。它断言文本开始，有一个数字，文本结束。如果 <code>.parse</code> 看到匹配之前或之后有一些字符，则会失败。它匹配全部或根本不匹配。它与显式地使用锚点几乎相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Number {
    regex TOP { ^ \d+ $ }  # explicitly anchored
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>But <code>TOP</code> is only the default starting point for a grammar. You can tell <code>.parse</code> where you’d like to start. This version defines the same pattern but calls it <code>digits</code> instead of <code>TOP</code>:</p>
</div>
<div class="paragraph">
<p>但 <code>TOP</code> 是仅有的 grammar 的默认起点。你可以告诉 <code>.parse</code> 你想要开始的地方。此版本定义相同的模式但称为 <code>digits</code> 而不是 <code>TOP</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Number {
    regex digits { \d+ }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tell <code>.parse</code> where to start with the <code>:rule</code> named argument:</p>
</div>
<div class="paragraph">
<p>使用 <code>:rule</code> 命名参数告诉 <code>.parse</code> 从哪里开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @strings = &#39;137&#39;, &#39;137 &#39;, &#39; 137 &#39;;

for @strings -&gt; $string {
    my $result = Number.parse( $string, :rule&lt;digits&gt; );
    put &#34;｢$string｣ &#34;, $result ?? &#39;Parsed!&#39; !! &#39;Failed!&#39;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first element of <code>@strings</code> parses because it is only digits. The other ones fail because they have extra characters:</p>
</div>
<div class="paragraph">
<p><code>@strings</code> 的第一个元素解析成功了因为它只是数字。其他的失败了因为他们有额外的字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢137｣ parsed!
｢137 ｣ failed!
｢ 137 ｣ failed!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Declare <code>digits</code> with <code>rule</code> instead of <code>regex</code>. This implicitly allows whitespace after any part of your pattern:</p>
</div>
<div class="paragraph">
<p>使用 <code>rule</code> 而不是 <code>regex</code> 声明 <code>digits</code>。这隐式地允许在模式的任何部分之后有空格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Number {
    rule digits { \d+ }  #  not anchored, and works
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the second [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) matches too because the implicit whitespace can match the space at the end (but not the beginning):</p>
</div>
<div class="paragraph">
<p>现在第二个 [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) 也匹配，因为隐式空格可以匹配末尾的空格（但不是开头）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢137｣ parsed!
｢137 ｣ parsed!
｢ 137 ｣ failed!</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>rule</code> applies <code>:sigspace</code> to its pattern. It’s the same thing as adding that adverb to the pattern:</p>
</div>
<div class="paragraph">
<p>该 <code>rule</code> 将 <code>:sigspace</code> 应用到其模式。将该副词添加到模式中是一回事：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Number {
    regex digits { :sigspace \d+ }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:sigspace</code> inserts the predefined <code>&lt;.ws&gt;</code> <strong>after</strong> pattern tokens. Since there’s a dot before the name <code>ws</code>, the <code>&lt;.ws&gt;</code> does not create a capture. It’s the same as adding optional whitespace explicitly:</p>
</div>
<div class="paragraph">
<p><code>:sigspace`在模式标记之后插入预定义的 `&lt;.ws&gt;</code>。由于名称 <code>ws</code> 之前有一个点号，<code>&lt;.ws&gt;</code> 不会创建捕获。它与显式添加可选空格相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Number {
    regex digits { \d+ &lt;.ws&gt; }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of showing <code>Parsed!</code>, you can on success output the [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) object you stored in <code>$result</code>:</p>
</div>
<div class="paragraph">
<p>你可以在成功输出存储在 <code>$result</code> 中的  [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) 对象，而不是显示 <code>Parsed!</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Number {
    regex digits { \d+ &lt;.ws&gt; }
    }

my @strings = &#39;137&#39;, &#39;137 &#39;, &#39; 137 &#39;;

for @strings -&gt; $string {
    my $result = Number.parse( $string, :rule&lt;digits&gt; );
    put $result ?? $result !! &#39;Failed!&#39;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output isn’t that different, but instead of its success status you see the text that matched:</p>
</div>
<div class="paragraph">
<p>输出没有那么不同，但你可以看到匹配到的文本，而不是其成功状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢137｣
｢137 ｣
Failed!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Modify the grammar to remove that dot from <code>&lt;.ws&gt;</code> so it captures whitespace and try again:</p>
</div>
<div class="paragraph">
<p>修改 grammar 以从 <code>&lt;.ws&gt;</code> 中删除该点号，以便捕获空格并再次尝试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Number {
    regex digits { \d+ &lt;ws&gt; }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the output shows the nested levels of named captures:</p>
</div>
<div class="paragraph">
<p>现在输出显示了命名捕获的嵌套级别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢137｣
 ws =&gt; ｢｣
｢137 ｣
 ws =&gt; ｢ ｣
Failed!</code></pre>
</div>
</div>
<div class="paragraph">
<p>This still doesn’t match the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) with leading whitespace. The parser couldn’t match that since <code>rule</code> only inserts <code>&lt;.ws&gt;</code> after explicit parts of the pattern. To match leading whitespace you need to add something to the front of the pattern. The beginning-of-string anchor does that, and now there’s something that <code>&lt;.ws&gt;</code> can come after:</p>
</div>
<div class="paragraph">
<p>这仍然与带有前导空格的 [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) 不匹配。解析器无法匹配，因为 <code>rule</code> 仅在模式的显式部分之后插入 <code>&lt;.ws&gt;</code>。要匹配前导空格，你需要在模式的前面添加一些内容。字符串开头的锚点就是这样，现在有一些 <code>&lt;.ws&gt;</code> 后面可以出现的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Number {
    rule digits { ^ \d+ }    # ^ &lt;.ws&gt; \d+ &lt;.ws&gt;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s also the zero-width always-matches token, <code>&lt;?&gt;</code>:</p>
</div>
<div class="paragraph">
<p>还有零宽度始终匹配的 token 标记，<code>&lt;?&gt;</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Number {
    rule digits { &lt;?&gt; \d+ }  #  &lt;?&gt; &lt;.ws&gt; \d+ &lt;.ws&gt;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most of the time you don’t want to play these games. If you want leading whitespace, you can note that explicitly (and you probably don’t want to capture it):</p>
</div>
<div class="paragraph">
<p>大多数时候你不想玩这些游戏。如果你想要前导空格，你可以显式地注意到（并且你可能不想捕获它）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Number {
    rule digits { &lt;.ws&gt; \d+ }  # &lt;.ws&gt; \d+ &lt;.ws&gt;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use <code>token</code> instead of <code>rule</code> if you don’t want any implicit whitespace:</p>
</div>
<div class="paragraph">
<p>如果你不想要任何隐式空格，请使用 <code>token</code> 而不是 <code>rule</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Number {
    token digits { \d+ }  # just the digits
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You’ll see another feature of <code>rule</code> and <code>token</code> later in this chapter.</p>
</div>
<div class="paragraph">
<p>你将在本章后面看到 <code>rule</code> 和 <code>token</code> 的另一个功能。</p>
</div>
<div class="paragraph">
<p>EXERCISE 17.1Write a grammer to match octal digits, with or without a leading <code>0</code> or <code>0o</code>. Your grammar should parse numbers such as <code>123</code>, <code>0123</code>, and <code>0o456</code>, but not <code>8</code>, <code>129</code>, or <code>o345</code>.</p>
</div>
<div class="paragraph">
<p>练习17.1写一个 grammar 来匹配八进制数字，带或不带前导 <code>0</code> 或 <code>0o</code>。你的 grammar 应该解析诸如 <code>123</code>, <code>0123</code> 和 <code>0o456</code> 之类的数字，但不能解析 <code>8</code> ,<code>129</code> 或 <code>o345</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_rules">5.9. Multiple Rules</h3>
<div class="paragraph">
<p>Grammars wouldn’t be useful if you were limited to one rule. You can define additional rules and use them inside other rules. In the first exercise you had only the <code>TOP</code> rule but you could separate the pattern into parts. Break up the pattern in <code>TOP</code> into rules for <code>prefix</code> and <code>digits</code>. It’s this decomposability that makes it so easy to solve hard parsing problems:</p>
</div>
<div class="paragraph">
<p>如果你只限于一条规则，那么 grammar 就没用了。你可以定义其他规则并在其他规则中使用它们。在第一个练习中，你只有 <code>TOP</code> 规则，但你可以将模式分成几部分。将 <code>TOP</code> 中的模式分解为 `prefix`和`digits`的规则。正是这种可分解性使得解决困难的解析问题变得如此简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar OctalNumber {
    regex TOP          { &lt;prefix&gt;? &lt;digits&gt;  }
    regex prefix       {  [ 0o? ]  }
    regex digits       { &lt;[0..7]&gt;+ }
    }

my $number = &#39;0o177&#39;;
my $result = OctalNumber.parse( $number );
say $result // &#34;failed&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The stringified [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) object shows the overall match and the named subcaptures:</p>
</div>
<div class="paragraph">
<p>字符串化的 [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) 对象显示整体匹配和命名的子捕获：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢0o177｣
 prefix =&gt; ｢0o｣
 digits =&gt; ｢177｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can access the pieces:</p>
</div>
<div class="paragraph">
<p>你可以访问这些部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;Prefix: $result&lt;prefix&gt;&#34;;
put &#34;Digits: $result&lt;digits&gt;&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 17.2Create a grammar to match a Raku variable name with a sigil (ignore sigilless variables, because that’s too easy). Use separate rules to match the sigil and the identifier. Here is a list of candidates to check if you don’t come up with your own:`my @candidates = qw/     sigilless   $scalar  @array   %hash     $123abc    $abc&#39;123 $ab’c123     $two-words $two-    $-dash     /;`</p>
</div>
<div class="paragraph">
<p>You can suppress some of those named captures by prefixing the rule with a dot. You probably don’t care about the prefix, so don’t save it:</p>
</div>
<div class="paragraph">
<p>练习17.2 创建一个 grammar，匹配带有 sigil 的 Raku 变量名（忽略无符号变量，因为这太简单了）。使用单独的规则来匹配 sigil 和标识符。这是一个候选人列表，检查你是否没有自己的：<code>my @candidates = qw/     sigilless   $scalar  @array   %hash     $123abc    $abc&#39;123 $ab’c123     $two-words $two-    $-dash     /;</code></p>
</div>
<div class="paragraph">
<p>你可以通过在规则前加一个点号来抑制某些命名捕获。你可能不关心前缀，所以不要保存它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar OctalNumber {
    regex TOP          { &lt;.prefix&gt;? &lt;digits&gt; }
    regex prefix       {  [ 0o? ]  }
    regex digits       { &lt;[0..7]&gt;+ }
    }

my $number = &#39;0o177&#39;;
my $result = OctalNumber.parse( $number );
say $result // &#34;failed&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output doesn’t include the prefix information:</p>
</div>
<div class="paragraph">
<p>输出不包含前缀信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢0o177｣
 digits =&gt; ｢177｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>This doesn’t make much of a difference in this small example, but imagine a complicated grammar with many, many rules. That brings you to the next big feature of grammars. Besides the grammar itself, you can specify an <strong>action class</strong> that processes the rules as the grammar successfully parses them.</p>
</div>
<div class="paragraph">
<p>这在这个小例子中并没有太大的区别，但想象一下复杂的 grammar 有很多很多规则。这将带你进入 grammar 的下一个重要特征。除 grammar 本身外，你还可以指定一个 action 类来处理规则，因为 grammar 会成功解析它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="_debugging_grammars">5.10. Debugging Grammars</h3>
<div class="paragraph">
<p>There are two modules that can help you figure out what’s going on in your grammar. Both are much more impressive in your terminal.</p>
</div>
<div class="paragraph">
<p>有两个模块可以帮助你弄清楚 grammar 中发生了什么。两者在你的终端中都更令人印象深刻。</p>
</div>
<div class="sect3">
<h4 id="_grammartracer">5.10.1. Grammar::Tracer</h4>
<div class="paragraph">
<p>The <code>Grammar::Tracer</code> module shows you the path through a grammar (and applies to any grammar in its scope). Merely loading the module is enough to activate it:</p>
</div>
<div class="paragraph">
<p><code>Grammar::Tracer</code> 模块向你显示 grammar 的路径（并适用于其作用域内的任何 grammar）。仅加载模块就足以激活它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Grammar::Tracer;

grammar OctalNumber {
    regex TOP          { &lt;prefix&gt;? &lt;digits&gt;  }
    regex prefix       {  [ 0o? ]  }
    regex digits       { &lt;[0..7]&gt;+ }
    }

my $number = &#39;0o177&#39;;
$/ = OctalNumber.parse( $number );
say $/ // &#34;failed&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first part of the output is the trace. It shows which rule it’s in and the result. In this example each one matches:</p>
</div>
<div class="paragraph">
<p>输出的第一部分是跟踪。它显示了它所在的规则和结果。在这个例子中，每个规则都匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">TOP
|  prefix
|  * MATCH &#34;0o&#34;
|  digits
|  * MATCH &#34;177&#34;
* MATCH &#34;0o177&#34;
｢0o177｣
 prefix =&gt; ｢0o｣
 digits =&gt; ｢177｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>Changing the data to include invalid digits, such as <code>0o178</code>, means the grammar will fail. In the trace you can see it matches up to <code>0o17</code> but can’t continue, so you know where in your [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) things went wrong. It could be that the grammar should not match the text or the grammar is not as accommodating as it should be:</p>
</div>
<div class="paragraph">
<p>更改数据以包含无效数字（例如 <code>0o178</code>）意味着 grammar 将失败。在跟踪中，你可以看到它最多匹配到 <code>0o17</code> 但无法继续，因此你就知道  [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>)  中的哪些地方出错了。可能是 grammar 不应该与文本匹配，或者 grammar 不应该像它应该的那样适应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">TOP
|  prefix
|  * MATCH &#34;0o&#34;
|  digits
|  * MATCH &#34;17&#34;
* MATCH &#34;0o17&#34;
digits
* FAIL
digits
* MATCH &#34;0&#34;
failed</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of adding <code>Grammar::Tracer</code> to your program you can load it from the command line with the `-M`switch. You probably don’t mean to leave it in anyway:</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>-M</code> 开关从命令行加载 <code>Grammar::Tracer</code>，而不是将 <code>Grammar::Tracer</code> 添加到程序中。你可能并不是故意把它留下来：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku -MGrammar::Tracer program.p6</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_grammardebugger">5.10.2. Grammar::Debugger</h4>
<div class="paragraph">
<p>The <code>Grammar::Debugger</code> module does the same thing as <code>Grammar::Tracer</code> (they come together in the same distribution) but allows you to proceed one step at a time. When you start it you get a prompt; type <code>h</code> to get a list of commands:</p>
</div>
<div class="paragraph">
<p><code>Grammar::Debugger</code> 模块与 <code>Grammar::Tracer</code> （它们在同一个发行版中）执行相同的操作，但允许你一次执行一个步骤。当你启动它时，你得到一个提示; 键入 <code>h</code> 以获取命令列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku -MGrammar::Debugger test.p6
TOP
&gt; h
    r              run (until breakpoint, if any)
    &lt;enter&gt;        single step
    rf             run until a match fails
    r &lt;name&gt;       run until rule &lt;name&gt; is reached
    bp add &lt;name&gt;  add a rule name breakpoint
    bp list        list all active rule name breakpoints
    bp rm &lt;name&gt;   remove a rule name breakpoint
    bp rm          removes all breakpoints
    q              quit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Typing Enter with no command single-steps through the parse process and gives you a chance to inspect the text and the state of the parser. The <code>rf</code> command will get you to the next failing rule:</p>
</div>
<div class="paragraph">
<p>在没有命令的情况下键入回车键单步执行解析过程，并让你有机会检查文本和解析器的状态。` rf` 命令会使你进入下一个失败的规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; rf
|  prefix
|  * MATCH &#34;0o&#34;
|  digits
|  * MATCH &#34;17&#34;
* MATCH &#34;0o17&#34;
digits
* FAIL
&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_a_simple_action_class">5.11. A Simple Action Class</h3>
<div class="paragraph">
<p>A grammar does its work by descending into its rules to take apart text. You can go the opposite way by processing each part of the parsed text to build a new [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) (or data structure, or whatever you like). You can tell <code>.parse</code> to use an action class to do this.</p>
</div>
<div class="paragraph">
<p>grammar 通过下降到它的规则中分解文本来完成其工作。你可以通过处理已解析文本的每个部分来构建新的 [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html)（或数据结构，或任何你喜欢的任何内容）。你可以告诉" class="bare">https://docs.raku.org/type/Str.html)（或数据结构，或任何你喜欢的任何内容）。你可以告诉</a> <code>.parse</code> 使用 action 类来执行此操作。</p>
</div>
<div class="paragraph">
<p>Here’s a simple action class, <code>OctalActions</code>. It doesn’t need to have the same name as the grammar, but the method names are the same as the rule names. Each method takes a [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) object argument. In this example, the signature uses <code>$/</code>, which is a variable with a few advantages that you’ll see in a moment:</p>
</div>
<div class="paragraph">
<p>这是一个简单的 action 类 <code>OctalActions</code>。它不需要与 grammar 具有相同的名称，但方法名称与规则名称相同。每个方法都接收 [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) 对象参数。在此示例中，签名使用 <code>$/</code>，这是一个具有一些优势的变量，稍后你将看到：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class OctalActions {
    method digits ($/) { put &#34;Action class got $/&#34; }
    }

grammar OctalNumber {
    regex TOP          { &lt;.prefix&gt;? &lt;digits&gt;  }
    regex prefix       {  [ 0o? ]  }
    regex digits       { &lt;[0..7]&gt;+ }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tell <code>.parse</code> which class to use with the <code>:actions</code> named parameter. The name does not need to correspond to the grammar:</p>
</div>
<div class="paragraph">
<p>使用 <code>:actions</code> 命名参数告诉 <code>.parse</code> 使用哪个类。该名称不需要与 grammar 对应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $number = &#39;0o177&#39;;
my $result = OctalNumber.parse(
    $number, :actions(OctalActions)
    );
say $result // &#34;failed&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This action class doesn’t do much. When the <code>digits</code> rule successfully matches it triggers the rule of the same name in the action class. That method merely outputs the argument:</p>
</div>
<div class="paragraph">
<p>这个 action 类做的不多。当 <code>digits</code> 规则成功匹配时，它会触发 action 类中相同名称的规则。该方法仅输出参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Action class got 177
｢0o177｣
 digits =&gt; ｢177｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 17.3Implement your own action class for the <code>OctalNumber</code> grammar. When the <code>digits</code> method matches, output the decimal version of the number. The <code>parse-base</code> routine from [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) may be useful. For extra credit, take one number per line from standard input and turn them into decimal numbers.</p>
</div>
<div class="paragraph">
<p>练习17.3 为 <code>OctalNumber</code> grammar 实现自己的 action 类。当 <code>digits</code> 方法匹配时，输出数字的十进制版本。 [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) 的 <code>parse-base</code> 例程可能很有用。如需额外学分，请从标准输入中每行获取一个数字并将其转换为十进制数字。</p>
</div>
<div class="sect3">
<h4 id="_creating_an_abstract_syntax_tree">5.11.1. Creating an Abstract Syntax Tree</h4>
<div class="paragraph">
<p>Actions shouldn’t output information directly. Instead, they can add values to the [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) object. Calling <code>make`in the action method sets a value in the abstract syntax tree (or `.ast</code>) slot of the [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>). You can access that with <code>.made</code>:</p>
</div>
<div class="paragraph">
<p>Action 不应直接输出信息。相反，他们可以向 [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) 对象添加值。在 action 方法中调用 <code>make</code> 会在 [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) 的抽象语法树（或 <code>.ast</code> ）槽中设置一个值。你可以使用 <code>.made</code> 访问它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class OctalActions {
    method digits ($/) {
        make parse-base( ~$/, 8 ) # must stringify $/
        }
    }

grammar OctalNumber {
    regex TOP          { &lt;.prefix&gt;? &lt;digits&gt;  }
    regex prefix       {  [ 0o? ]  }
    regex digits       { &lt;[0..7]&gt;+ }
    }

my $number = &#39;0o177&#39;;
my $result = OctalNumber.parse(
    $number, :actions(OctalActions)
    );
put $result ??
    &#34;Turned ｢{$result&lt;digits&gt;}｣ into ｢{$result&lt;digits&gt;.made}｣&#34;
    !! &#39;Failed!&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>make</code> puts something into the <code>.ast</code> slot of the [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) and <code>.made</code> gets it back out. You can <code>make</code> any value that you like, including containers, objects, and most other things you can imagine. You still get the original, literal match.</p>
</div>
<div class="paragraph">
<p>In the previous example, the <code>digits</code> action method handled the value. A <code>TOP</code> action method could do it, but it has to reach one level below the [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) object:</p>
</div>
<div class="paragraph">
<p><code>make</code> 将一些内容放入[<code>Match</code>](<a href="https://docs.raku.org/type/Match.html)的" class="bare">https://docs.raku.org/type/Match.html)的</a> <code>.ast</code> 插槽中，然后 <code>.made</code> 将其恢复原状。你可以`make` 任何你喜欢的值，包括容器，对象和你可以想象的大多数其他内容。你仍然得到原始的，字面上的匹配。</p>
</div>
<div class="paragraph">
<p>在前面的示例中，<code>digits</code> action 方法处理了该值。 <code>TOP</code> action 方法可以做到，但它必须到达  [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) 对象下面的一个级别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class OctalActions {
    method digits ($/) {
        make parse-base( ~$/, 8 ) # must stringify $/
        }
    }

grammar OctalNumber {
    regex TOP          { &lt;.prefix&gt;? &lt;digits&gt;  }
    regex prefix       {  [ 0o? ]  }
    regex digits       { &lt;[0..7]&gt;+ }
    }

my $number = &#39;0o177&#39;;
my $result = OctalNumber.parse(
    $number, :actions(OctalActions)
    );
put $result.so ??
    &#34;Turned ｢{$number}｣ into ｢{$result.made}｣&#34;
    !! &#39;Failed!&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You don’t have to use <code>$/</code> in the signature; it’s a convenience. There’s nothing particularly magical about it. You could use some other variable if you are paid by the character:</p>
</div>
<div class="paragraph">
<p>你不必在签名中使用 <code>$/</code>; 这是一个方便写法。它没什么特别神奇的。如果你有其它字符，你可以使用其他变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class OctalActions {
    method TOP ($match) { make parse-base( ~$match&lt;digits&gt;, 8 ) }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 17.4Create a grammar to parse a four-part, dotted-decimal IP address, such as <code>192.168.1.137</code>. Create an action class that turns the parse results into a 32-bit number. Output that 32-bit number in hexadecimal.</p>
</div>
<div class="paragraph">
<p>练习17.4 创建一个 grammar 来解析一个由四部分组成的点分十进制 IP 地址，例如 <code>192.168.1.137</code>。创建一个 action 类，将解析结果转换为32位数。以十六进制输出那个32位数。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ratcheting">5.12. Ratcheting</h3>
<div class="paragraph">
<p>The <code>rule</code> and <code>token</code> declarators have a feature that <code>regex</code> doesn’t; they both prevent backtracking by implicitly setting the <code>:ratchet</code> adverb. Once one of those rules matches they don’t backtrack to try again if there’s a failure later in the grammar.</p>
</div>
<div class="paragraph">
<p>Here’s a nonsense grammar that includes a rule <code>&lt;some-stuff&gt;</code> that matches one or more of any character. The <code>TOP</code> token wants to match digits surrounded by unspecified stuff:</p>
</div>
<div class="paragraph">
<p><code>rule</code> 和 <code>token</code> 声明符具有 <code>regex</code> 不具有的功能;他们都通过隐式设置 <code>:ratchet</code> 副词来阻止回溯。一旦这些规则中的一个匹配，如果在 grammar 中稍后出现失败，则它们不会回溯以再次尝试。</p>
</div>
<div class="paragraph">
<p>这是一个无意义的 grammar，其中包含能匹配一个或多个字符的 <code>&lt;some-stuff&gt;</code> 规则。 <code>TOP</code> token 想要匹配由未指定的东西包围的数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Stuff {
    token TOP { &lt;some-stuff&gt; &lt;digits&gt; &lt;some-stuff&gt; }
    token digits       { \d+ }
    token some-stuff   { .+  }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) could satisfy that pattern. It has stuff, some digits, and more stuff:</p>
</div>
<div class="paragraph">
<p>这个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)可以满足这种模式。它有东西，一些数字和更多的东西：" class="bare">https://docs.raku.org/type/Str.html)可以满足这种模式。它有东西，一些数字和更多的东西：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = &#39;abcdef123xyx456&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>But, <code>Stuff</code> fails to parse it:</p>
</div>
<div class="paragraph">
<p>但是，<code>Stuff</code> 无法解析它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result = Stuff.parse( $string );
put &#34;｢$string｣ &#34;, $result ?? &#39;Parsed!&#39; !! &#39;Failed!&#39;; # Failed!</code></pre>
</div>
</div>
<div class="paragraph">
<p>It’s the <code>:ratchet</code> that makes it fail. Work out its path to see why. <code>TOP</code> has to first match <code>&lt;some-stuff&gt;</code>. That matches any character one or more times, greedily—it matches the entire text. <code>TOP</code> next needs to match`&lt;digits&gt;`, but there is nothing left to match because of that greediness. Without <code>:ratchet</code> the pattern might roll back some of the characters it already consumed. With <code>:ratchet</code> it doesn’t do that. The grammar can’t match the rest of <code>TOP</code> and it fails.</p>
</div>
<div class="paragraph">
<p>Without <code>:ratchet</code> the situation is different. If you use <code>regex</code> instead of <code>token</code>, you allow the grammar to give back characters it has already matched:</p>
</div>
<div class="paragraph">
<p>是 <code>:ratchet</code> 使它失败的。找出原因，看看为什么。 <code>TOP</code> 必须首先匹配 <code>&lt;some-stuff&gt;</code>。这匹配任何一个字符一次或多次，贪婪地 - 它匹配整个文本。 <code>TOP</code>  接着需要匹配 <code>&lt;digits&gt;</code>，但由于这种贪婪，没有什么可以匹配的了。如果没有 <code>:ratchet</code> 模式可能会回滚它已经消耗的一些字符。使用 <code>:ratchet</code> 它不会那样做。Grammar 不能匹配 <code>TOP</code> 的其余部分，所以失败了。</p>
</div>
<div class="paragraph">
<p>没有 <code>:ratchet</code> 的情况是不同的。如果使用 <code>regex</code> 而不是 <code>token</code>，则允许 grammar 归还已匹配的字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Stuff {
    # regex does not turn on ratcheting
    regex TOP { &lt;some-stuff&gt; &lt;digits&gt; &lt;some-stuff&gt; }
    token digits       { \d+ }
    regex some-stuff   { .+  }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>That could match. The <code>TOP</code> matches <code>&lt;some-stuff&gt;</code> but realizes it’s run out of text and starts backtracking. All parts of the grammar that want to allow backtracking have to use <code>regex</code>. It’s not good enough for <code>TOP</code> to backtrack but not <code>&lt;some-stuff&gt;</code>.</p>
</div>
<div class="paragraph">
<p>那可能会匹配。 <code>TOP</code> 匹配 <code>&lt;some-stuff&gt;</code>，但意识到它已用完文本并开始回溯。想要允许回溯的 grammar 的所有部分都必须使用 <code>regex</code>。对于 <code>TOP</code> 来说，回溯并不是足够好，除了 <code>&lt;some-stuff&gt;</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_parsing_json">5.13. Parsing JSON</h3>
<div class="paragraph">
<p>In <strong>Mastering Perl</strong> I presented a JSON parser that Randal Schwartz created using some advanced features of Perl 5 regular expressions. In many ways his implementation was a grammar, but he was forced to inseparably combine the parsing and the actions. That made the regular expression almost impenetrable. It’s much cleaner and more accessible to write it as a Raku grammar.</p>
</div>
<div class="paragraph">
<p>JSON is actually quite simple with only a few weird things to handle, but it gives you the opportunity to see how <code>proto</code> rules can simplify actions:</p>
</div>
<div class="paragraph">
<p>在 Mastering Perl 中，我提到了一个 Randal Schwartz 使用 Perl 5 正则表达式的一些高级功能创建的 JSON 解析器。在许多方面，他的实现是一种 grammar，但他被迫不可分割地将解析和 action 组合在一块。这使得正则表达式几乎无法穿透。用 Raku grammar 编写它会更清晰，更容易访问。</p>
</div>
<div class="paragraph">
<p>JSON 实际上非常简单，只需处理几个奇怪的事情，但它让你有机会了解 <code>proto</code> 规则如何简化 action：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Grammar::JSON {
    rule TOP                { &lt;.ws&gt; &lt;value&gt; &lt;.ws&gt; }

    rule object             { &#39;{&#39; ~ &#39;}&#39; &lt;string-value-list&gt; }
    rule string-value-list  { &lt;string-value&gt; * % &#39;,&#39; }
    token string-value      { &lt;string&gt; &lt;.ws&gt; &#39;:&#39; &lt;.ws&gt; &lt;value&gt; }

    rule array              { &#39;[&#39; ~ &#39;]&#39; &lt;list&gt; }
    rule list               { &lt;value&gt; * % &#39;,&#39; }

    token value             {
        &lt;string&gt; | &lt;number&gt; | &lt;object&gt; | &lt;array&gt; |
        &lt;true&gt; | &lt;false&gt; | &lt;null&gt;
        }

    token true  { &#39;true&#39;  }
    token false { &#39;false&#39; }
    token null  { &#39;null&#39;  }

    token string {
        (:ignoremark \&#34; ) ~ \&#34;
        [
            &lt;u_char&gt;              |
            [ &#39;\\&#39; &lt;[\\/bfnrt&#34;]&gt; ] |
            &lt;-[\\\&#34;\n\t]&gt;+
        ]*
        }

    token u_char {
        &#39;\\u&#39; &lt;code_point&gt;
        }

    token code_point { &lt;[0..9a..fA..F]&gt;**4 }

    token number {
        &#39;-&#39; ?
        [ 0 | &lt;[1..9]&gt;&lt;[0..9]&gt;* ]
        [ &#39;.&#39; &lt;[0..9]&gt;+ ]?
        [ &lt;[eE]&gt; &lt;[+-]&gt;? &lt;[0..9]&gt;+ ]?
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may be surprised at how easy and short that grammar is. It’s almost a straight translation of the grammar from [RFC 8259](<a href="https://trac.tools.ietf.org/html/rfc8259" class="bare">https://trac.tools.ietf.org/html/rfc8259</a>). Now, create an action class for that:</p>
</div>
<div class="paragraph">
<p>你可能会对这个 grammar 的简单和简短感到惊讶。它几乎是  [RFC 8259](<a href="https://trac.tools.ietf.org/html/rfc8259" class="bare">https://trac.tools.ietf.org/html/rfc8259</a>) grammar 的直接翻译。现在，为此创建一个 action 类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class JSON::Actions {
    method TOP ($/) { make $&lt;value&gt;.made }
    method object ($/) {
        make $&lt;string-value-list&gt;.made.hash.item;
        }
    method array ($/) {
        make $&lt;list&gt;.made.item;
        }

    method true       ($/) { make True }
    method False      ($/) { make False }
    method null       ($/) { make Nil }

    method value      ($/) { make (
        $&lt;true&gt; || $&lt;false&gt; || $&lt;null&gt; || $&lt;object&gt; ||
        $&lt;array&gt; || $&lt;string&gt; || $&lt;number&gt; ).made
        }

    method string-value-list ($/) {
        make $&lt;string-value&gt;&gt;&gt;.made.flat;
        }

    method string-value ($/) {
        make $&lt;string&gt; =&gt; $&lt;value&gt;
        }

    method list       ($/) { make ~$/ }
    method string     ($/) { make $&lt;uchar&gt;.made || ~$/ }

    method u_char     ($/) { make $&lt;code_point&gt;.made }
    method code_point ($/) { make chr( (~$/).parse-base(16) ) }
    method number     ($/) { make +$/ }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Look at the clunky handling of <code>value</code>. Almost anything can be a value, so the action method does some ham-handed work to figure out which thing just matched. It looks into the possible submatches to find one with a defined value. Well, that’s pretty stupid even if it’s a quick way to get started (although there is some value in the immediate stupid versus the far-off smart).</p>
</div>
<div class="paragraph">
<p>A <code>proto</code> rule gets around this by making it easy for you to give different subrules the same name but different patterns. Instead of an alternation you have one token for each:</p>
</div>
<div class="paragraph">
<p>看看笨重的 <code>value</code> 处理。几乎任何东西都可以是一个值，所以 action 方法会做一些简单的工作来弄清楚哪个东西匹配。它查找可能的子匹配以找到具有定义值的子匹配。好吧，即使这是一个快速入门的方式，这也是非常愚蠢的（虽然在愚蠢的直接智能中存在一些价值）。</p>
</div>
<div class="paragraph">
<p><code>proto</code> 规则可以让你轻松地为不同的子规则赋予相同的名称但不同的模式。不是备选分支，而是每个都有一个 <code>token</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto token value { * }
token value:sym&lt;string&gt; { &lt;string&gt; }
token value:sym&lt;number&gt; { &lt;number&gt; }
token value:sym&lt;object&gt; { &lt;object&gt; }
token value:sym&lt;array&gt;  { &lt;array&gt;  }
token value:sym&lt;true&gt;   { &lt;sym&gt;    }
token value:sym&lt;false&gt;  { &lt;sym&gt;    }
token value:sym&lt;null&gt;   { &lt;sym&gt;    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first <code>proto</code> rule matches <code>*</code>, which really means it dispatches to another rule in that group. It can dispatch to all of them and find the one that works.</p>
</div>
<div class="paragraph">
<p>Some of these use the special <code>&lt;sym&gt;</code> subrule in their pattern. This means that the name of the rule is the literal text to match. The <code>proto</code> rule <code>&lt;true&gt;</code> matches the literal text <code>true</code>. You don’t have to type that out in the name and the pattern.</p>
</div>
<div class="paragraph">
<p>It doesn’t matter which of those matches; the grammar calls each of them <code>$&lt;value&gt;</code>. The superrule only knows that something that is a value matched and that the subrule handled it appropriately. The action class <code>make`s the right value and stores it in the [`Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>):</p>
</div>
<div class="paragraph">
<p>第一个 <code>proto</code> 规则匹配 <code>*</code>，这实际上意味着它将分派给该组中的另一个规则。它可以发送给所有人并找到有效的。</p>
</div>
<div class="paragraph">
<p>其中一些在其模式中使用特殊的 <code>&lt;sym&gt;</code> 子规则。这意味着规则的名称是要匹配的文字文本。 <code>proto</code> 规则 <code>&lt;true&gt;</code> 匹配文字文本 <code>true</code>。你不必在名称和模式中输入该内容。</p>
</div>
<div class="paragraph">
<p>哪些匹配无关紧要; grammar 调用每个 <code>$&lt;value&gt;</code>。超级规则只知道值匹配的东西，并且子规则适当地处理它。 action 类生成正确的值并将其存储在 [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class JSON::Actions {
    method TOP    ($/) { make $&lt;value&gt;.made }
    method object ($/) { make $&lt;string-value-list&gt;.made.hash.item }

    method string-value-list ($/) { make $&lt;string-value&gt;&gt;&gt;.made.flat }
    method string-value      ($/) {
        make $&lt;string&gt;.made =&gt; $&lt;value&gt;.made
        }

    method array  ($/) { make $&lt;list&gt;.made.item }
    method list   ($/) { make [ $&lt;value&gt;.map: *.made ] }

    method string     ($/) { make $&lt;uchar&gt;.made || ~$/ }

    method value:sym&lt;number&gt; ($/) { make +$/.Str }
    method value:sym&lt;string&gt; ($/) { make $&lt;string&gt;.made }
    method value:sym&lt;true&gt;   ($/) { make Bool::True  }
    method value:sym&lt;false&gt;  ($/) { make Bool::False }
    method value:sym&lt;null&gt;   ($/) { make Any }
    method value:sym&lt;object&gt; ($/) { make $&lt;object&gt;.made }
    method value:sym&lt;array&gt;  ($/) { make $&lt;array&gt;.made }

    method u_char     ($/) { make $&lt;code_point&gt;.made }
    method code_point ($/) { make chr( (~$/).parse-base(16) ) }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>EXERCISE 17.5Implement your own JSON parser (steal all the code you like). Test it against some JSON files to see how well it works. You might like to try the JSON files at [<strong><a href="https://github.com/briandfoy/json-acceptance-tests" class="bare">https://github.com/briandfoy/json-acceptance-tests</a></strong></p>
</div>
<div class="paragraph">
<p>练习17.5实现自己的 JSON 解析器（窃取你喜欢的所有代码）。针对某些 JSON 文件进行测试，看看它的工作情况。你可能想在 [https//github.com/briandfoy/json-acceptance-tests](https//github.com/briandfoy/json-acceptance-tests) 上尝试 JSON文件。</p>
</div>
</div>
<div class="sect2">
<h3 id="_parsing_csv">5.14. Parsing CSV</h3>
<div class="paragraph">
<p>Let’s parse some comma-separated values (CSV) files. These are tricky because there’s no actual standard (despite [RFC 4180](<a href="https://tools.ietf.org/html/rfc4180)" class="bare">https://tools.ietf.org/html/rfc4180)</a>). Microsoft Excel does it one way but some other producers do it slightly differently.</p>
</div>
<div class="paragraph">
<p>People often initially go wrong thinking they can merely split the data on a comma character—but that might be part of the literal data in a quoted field. The quote character may also be part of the literal data, but one producer might escape internal quote marks by doubling them, <code>&#34;&#34;</code>, while another might use the backslash, <code>\&#34;</code>. People often assume they are line-oriented, but some producers allow unescaped (but quoted!) vertical whitespace. If all of that wasn’t bad enough, what do you do if one line has fewer (or more) fields than the other lines?</p>
</div>
<div class="paragraph">
<p>让我们解析一些逗号分隔值（CSV）文件。这些都很棘手，因为没有实际的标准（尽管有despite [RFC 4180](<a href="https://tools.ietf.org/html/rfc4180" class="bare">https://tools.ietf.org/html/rfc4180</a>) ）。 Microsoft Excel 以一种方式实现，但其他一些生产商则略有不同。</p>
</div>
<div class="paragraph">
<p>最初人们通常认为他们只能按照逗号字符拆分数据 - 但逗号可能是引用字段中字面量数据的一部分。引号字符也可能是字面量数据的一部分，但是有些制作人可能会通过两个双引号 <code>&#34;&#34;</code> 来避免内部引号，而另一个可能会使用反斜杠，<code>\&#34;</code>。人们通常认为它们是面向行的，但是一些制作人允许未转义的（但引起来！）垂直空白。如果所有这些都不够糟糕，如果一行的字段少于（或多于）其他行，你会怎么做？</p>
</div>
<div class="paragraph">
<p>Don’t parse CSV files like this. The <code>Text::CSV</code> module not only parses the format but also tries to correct problems as it goes.</p>
</div>
<div class="paragraph">
<p>不要像这样解析 CSV 文件。 <code>Text::CSV</code> 模块不仅可以解析格式，还可以尝试纠正问题。</p>
</div>
<div class="paragraph">
<p>Still willing to give it a try? You should find that grammars make most of these concerns tractable:</p>
</div>
<div class="paragraph">
<p>仍然愿意尝试一下？你应该发现 grammar 使大多数这样的问题易于处理：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The ratcheting behavior keeps things simple.</p>
</li>
<li>
<p>You can easily handle balanced openers and closers (i.e., the quoting stuff).</p>
</li>
<li>
<p>A grammar can inherit other grammars, so you can adjust a grammar based on the data instead of writing one grammar that handles all the data.</p>
</li>
<li>
<p>You’ve seen action classes, but you can also have action instances that remember extra non-[<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) data.</p>
</li>
<li>
<p>There’s a <code>.subparse</code> method that lets you parse chunks so you can handle one record at a time.</p>
</li>
<li>
<p>棘轮行为使事情变得简单。</p>
</li>
<li>
<p>你可以轻松地处理平衡的开口和闭合（即引用的东西）。</p>
</li>
<li>
<p>grammar 可以继承其他 grammar，因此你可以根据数据调整 grammar，而不是编写一个处理所有数据的 grammar。</p>
</li>
<li>
<p>你已经看过 action 类，但你也可以拥有记住额外非[<code>匹配</code>](<a href="https://docs.raku.org/type/Match.html)数据的" class="bare">https://docs.raku.org/type/Match.html)数据的</a> action 实例。</p>
</li>
<li>
<p>有一个 <code>.subparse</code> 方法，可以让你解析块，这样你就可以一次处理一条记录。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here’s a simple CSV grammar based off the rules in [RFC 4180](<a href="https://tools.ietf.org/html/rfc4180" class="bare">https://tools.ietf.org/html/rfc4180</a>). It allows for quoted fields and uses <code>&#34;&#34;</code> to escape a literal quote. If a comma, quote, or vertical whitespace appears in the literal data, it must be quoted:</p>
</div>
<div class="paragraph">
<p>这是一个简单的 CSV grammar，基于 [RFC 4180](<a href="https://tools.ietf.org/html/rfc4180" class="bare">https://tools.ietf.org/html/rfc4180</a>) 中的规则。它允许引用的字段并使用 <code>&#34;&#34;</code> 来避免字面量引号。如果字面量数据中出现逗号，引号或垂直空格，则必须引起它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Grammar::CSV {
    token TOP       { &lt;record&gt;+ }
    token record    { &lt;value&gt;+ % &lt;.separator&gt; \R }
    token separator { &lt;.ws&gt; &#39;,&#39; &lt;.ws&gt; }
    token value     {
        &#39;&#34;&#39;             # quoted
            &lt;( [ &lt;-[&#34;]&gt; | &lt;.escaped-quote&gt; ]* )&gt;
        &#39;&#34;&#39;
            |
        &lt;-[&#34;,\n\f\r]&gt;+  # non-quoted (no vertical ws)
            |
            &#39;&#39;          # empty
        }

    token escaped-quote { &#39;&#34;&#34;&#39; }
    }

class CSV::Actions {
    method record ($/) { make $&lt;value&gt;».made.flat }
    method value ($/)  {
        # undo the double double quote
        make $/.subst( rx/ &#39;&#34;&#34;&#39; /, &#39;&#34;&#39;, :g )
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Try this on entire files. The entire file either satisfies this grammar or doesn’t:</p>
</div>
<div class="paragraph">
<p>在整个文件上试试这个。整个文件要么满足这个 grammar，要么不满足：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $data = $filename.IO.slurp;
my $result = Grammar::CSV.parse( $data );</code></pre>
</div>
</div>
<div class="paragraph">
<p>You typically don’t want to parse entire files, though. Let’s fix the first part of that problem. You want to process records as you run into them. Instead of using <code>.parse</code>, which anchors to the end of the text, you can use <code>.subparse</code>, which doesn’t. This means you can parse part of the text then stop.</p>
</div>
<div class="paragraph">
<p>You can deal with one record at a time. Using <code>.subparse</code> with the <code>record</code> rule gets you the first record and only the first record. The <code>.subparse</code> method always returns a [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>), unlike <code>.parse</code>, which only returns a [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) when it succeeds. You can’t rely on the type of the object as an indication of success:</p>
</div>
<div class="paragraph">
<p>但是，你通常不希望解析整个文件。让我们解决这个问题的第一部分。你希望在遇到记录时处理记录。你可以使用 <code>.subparse</code>，而不是使用锚定到文本末尾的 <code>.parse</code>，  <code>.subparse</code> 不会锚定到文本末尾。这意味着你可以解析部分文本然后停止。</p>
</div>
<div class="paragraph">
<p>你可以一次处理一条记录。将 <code>.subparse</code> 与 <code>record</code> 规则一起使用可以获得第一条记录，并且只获得第一条记录。与 <code>.parse</code> 不同，<code>.subparse</code> 方法总是返回一个 [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html)，" class="bare">https://docs.raku.org/type/Match.html)，</a><code>.parse</code> 方法只在成功时返回一个 [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html)。你不能依赖对象的类型作为成功的指示：" class="bare">https://docs.raku.org/type/Match.html)。你不能依赖对象的类型作为成功的指示：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $data = $filename.IO.slurp;
my $first_result = Grammar::CSV.subparse(
    $data, :rule(&#39;record&#39;), :action(CSV::Actions)
    );
if $first-result { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>That works for the first line. Use <code>:c(N)</code> to tell these methods where to start in the [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>). You have to know where you want to start. The [<code>Match</code>](<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) knows how far it got; look in the <code>.from</code> slot:</p>
</div>
<div class="paragraph">
<p>这适用于第一行。使用 <code>:c(N)</code> 告诉这些方法在 [<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)中从哪里开始。你必须知道你想要从哪里开始。"><code>Match</code></a>(<a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>) 知道它进行了多远;看看 <code>.from</code> 插槽：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $data  = $filename.IO.slurp;

loop {
    state $from = 0;
    my $match = Grammar::CSV.subparse(
        $data,
        :rule(&#39;record&#39;),
        :actions(CSV::Actions),
        :c($from)
        );
    last unless $match;

    put &#34;Matched from {$match.from} to {$match.to}&#34;;
    $from = $match.to;
    say $match;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is most of the way to a solution—it fails to go through the entire file if <code>.subparse</code> fails on one record. With some boring monkey work you could fix this to find the start of the next record and restart the parsing, but that’s more than I want to fit in this book.</p>
</div>
<div class="paragraph">
<p>这是解决方案的大部分方法 - 如果 <code>.subparse</code> 在一条记录上失败，则无法遍历整个文件。使用一些无聊的猴子工作，你可以修复这个问题，找到下一条记录的开始并重新开始解析，但这比我想要适应本书更多。</p>
</div>
<div class="sect3">
<h4 id="_adjusting_the_grammar">5.14.1. Adjusting the Grammar</h4>
<div class="paragraph">
<p>You thought the problem was solved. Then, someone sent you a file with a slightly different format. Instead of escaping a <code>&#34;</code> by doubling it, the new format uses the backslash.</p>
</div>
<div class="paragraph">
<p>Now your existing grammar fails to parse. You don’t have a rule that satisfies that type of escape because you didn’t need it for your grammar. As a matter of practice in both patterns and grammars, only match what you should match. Be liberal in what you accept in other ways, such as making a subgrammar to handle the new case:</p>
</div>
<div class="paragraph">
<p>你以为问题已经解决了。然后，有人给你发送了一个格式略有不同的文件。新格式使用反斜杠，而不是使用两个引号转义 <code>&#34;</code>。</p>
</div>
<div class="paragraph">
<p>现在你现有的 grammar 解析失败。你没有满足该类型的转义的规则，因为你的 grammar 不需要它。作为模式和 grammar 的练习，只匹配你应该匹配的内容。在其他方面随心所欲，例如制作一个子 grammar 来处理新案例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Grammar::CSV::Backslashed is Grammar::CSV {
    token escaped-quote { &#39;\\&#34;&#39; }
    }

class CSV::Actions::Backslashed is CSV::Actions {
    method value ($/)  { make $/.subst( rx/ &#39;\\&#34;&#39; /, &#39;&#34;&#39;, :g ) }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>With two grammars, how do you get the one that you need to use? The name interpolation <code>::($</code><strong>name</strong><code>)</code> comes in handy here:</p>
</div>
<div class="paragraph">
<p>有两个 grammar，你如何得到你需要使用的那个？<code>::($</code><strong>name</strong><code>)</code> 在这里派上用场：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %formats;
%formats&lt;doubled&gt; = {
    &#39;file&#39;    =&gt; $*SPEC.catfile( &lt;corpus test.csv&gt; ),
    &#39;grammar&#39; =&gt; &#39;Grammar::CSV&#39;,
    };
%formats&lt;backslashed&gt; = {
    &#39;file&#39; =&gt; $*SPEC.catfile( &lt;corpus test-backslash.csv&gt; ),
    &#39;grammar&#39; =&gt; &#39;Grammar::CSV::Backslashed&#39;,
    };

for %formats.values -&gt; $hash {
    $hash&lt;data&gt; = $hash&lt;file&gt;.IO.slurp;
    my $class = (require ::( $hash&lt;grammar&gt; ) );
    my $match = $class.parse( $hash&lt;data&gt; );
    say &#34;{$hash&lt;file&gt;} with {$hash&lt;grammar&gt;} &#34;,
        $match ?? &#39;parsed&#39; !! &#39;failed&#39;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>%formats</code> [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>) of [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html)es" class="bare">https://docs.raku.org/type/Hash.html)es</a> stores the filenames and the grammars for them. You can load a grammar and use it to parse the data without the explicit grammar name:</p>
</div>
<div class="paragraph">
<p><code>%formats</code> [<code>散列</code>](<a href="https://docs.raku.org/type/Hash.html)的"><code>散列</code></a>(<a href="https://docs.raku.org/type/Hash.html)存储文件名和" class="bare">https://docs.raku.org/type/Hash.html)存储文件名和</a> grammar。你可以加载 grammar 并使用它来解析数据而不使用显式的 grammar 名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">corpus/test.csv with Grammar::CSV parsed
corpus/test-backslash.csv with Grammar::CSV::Backslashed parsed</code></pre>
</div>
</div>
<div class="paragraph">
<p>That mostly solves the problem, although there are plenty of special cases that this doesn’t cover.</p>
</div>
<div class="paragraph">
<p>这主要解决了这个问题，尽管有很多特殊情况并没有涵盖。</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_roles_in_grammars">5.14.2. Using Roles in Grammars</h4>
<div class="paragraph">
<p>Roles can supply rules and methods that grammars can use. In the previous section you handled different sorts of double-quote escaping through inheritance, where you overrode the rule. You can do the same thing with roles.</p>
</div>
<div class="paragraph">
<p>A grammar can have methods and subroutines. The way you declare a name with <code>sub</code>, <code>method</code>, or <code>rule</code> tells the language parser (not your grammar!) how to parse the stuff in the [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>).</p>
</div>
<div class="paragraph">
<p>First, adjust the main grammar to have a stub method for <code>&lt;escaped-quote&gt;</code>. This forces something else to define it:</p>
</div>
<div class="paragraph">
<p>角色可以提供 grammar 可以使用的规则和方法。在上一节中，你通过继承处理了不同类型的双引号转义，其中你重写了规则。你可以用角色做同样的事情。</p>
</div>
<div class="paragraph">
<p>Grammar 可以有方法和子程序。使用 <code>sub</code>，<code>method`或 `rule</code> 声明名称的方式告诉语言解析器（而不是 grammar！）如何解析[<code>块</code>](<a href="https://docs.raku.org/type/Block.html)中的东西。" class="bare">https://docs.raku.org/type/Block.html)中的东西。</a></p>
</div>
<div class="paragraph">
<p>首先，调整主 grammar，使其具有 <code>&lt;escaped-quote&gt;</code> 的存根方法。这迫使别人定义它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Grammar::CSV {
     token TOP       { &lt;record&gt;+ }
     token record    { &lt;value&gt;+ % &lt;.separator&gt; \R }
     token separator { &lt;.ws&gt; &#39;,&#39; &lt;.ws&gt; }
     token value     {
         &#39;&#34;&#39;             # quoted
             &lt;( [ &lt;-[&#34;]&gt; | &lt;.escaped-quote&gt; ]* )&gt;
         &#39;&#34;&#39;
             |
         &lt;-[&#34;,\n\f\r]&gt;+  # non-quoted (no vertical ws)
             |
             &#39;&#39;          # empty
         }

     # stub that you must define in a role
     method escaped-quote { !!! }
     }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A role will fill in that stub method. There’s one role for each way to escape the double quote:</p>
</div>
<div class="paragraph">
<p>角色将填充该存根方法。每种方式都有一个角色来转义双引号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role DoubledQuote     { token escaped-quote { &#39;&#34;&#34;&#39;  } }
role BackslashedQuote { token escaped-quote { &#39;\\&#34;&#39; } }</code></pre>
</div>
</div>
<div class="paragraph">
<p>When it’s time to parse a file you can choose which role you want to use. You can create a new object for <code>Grammar::CSV</code> and apply the appropriate role to it:</p>
</div>
<div class="paragraph">
<p>在解析文件时，你可以选择要使用的角色。你可以为 <code>Grammar::CSV</code> 创建一个新对象并将适当的角色应用于它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $filename   = ...;
my $csv-data   = $filename.IO.slurp;
my $csv-parser = Grammar::CSV.new but DoubledQuote;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use that object to parse your data:</p>
</div>
<div class="paragraph">
<p>使用该对象解析数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $match = $csv-parser.parse: $csv-data;
say $match // &#39;Failed!&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Doing this doesn’t fix the double quotes in the data—a <code>&#34;&#34;</code> stays as a <code>&#34;&#34;</code>—but you can fix that in an action class.</p>
</div>
<div class="paragraph">
<p>EXERCISE 17.6Adjust the CSV example to use roles instead of inheritance. Create an action class to adjust the escaped double quotes as you run into them. You can start with <strong>Grammars/test.csv</strong> from the downloads section of [the book’s website](<a href="https://www.learningraku.com/" class="bare">https://www.learningraku.com/</a>) if you like.</p>
</div>
<div class="paragraph">
<p>这样做不会修复数据中的双引号 -  <code>&#34;&#34;</code> 保留为 <code>&#34;&#34;</code> - 但你可以在 action 类中修复它。</p>
</div>
<div class="paragraph">
<p>练习17.6 调整 CSV 示例以使用角色而不是继承。创建一个 action 类，以便在遇到它们时调整转义的双引号。如果你愿意，可以从本书网站的下载部分 Grammars/ test.csv 开始。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_summary_11">5.15. Summary</h3>
<div class="paragraph">
<p>Grammars are one of the killer features of the language. You can define complex relationships between patterns and use action classes to run arbitrarily complex code when something matches. You might find that your entire program ends up being one big grammar.</p>
</div>
<div class="paragraph">
<p>Grammars 是 Raku 语言的杀手级特性之一。你可以定义模式之间的复杂关系，并在匹配时使用 action 类来运行任意复杂的代码。你可能会发现整个程序最终变成一个大的 grammar。
== 供应、通道和承诺</p>
</div>
<div class="paragraph">
<p>供应(Supply)和通道(Channel)提供了将数据从程序的一部分发送到另一部分的方法。<a href="https://docs.raku.org/type/Supply.html">Supply</a> 是一条从数据源到可能是许多消费者的直接通信线路。<a href="https://docs.raku.org/type/Channel.html">Channel</a> 允许你的程序的任何部分将数据添加到你的程序的任何部分可以读取的队列中。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Promise.html">Promise</a> 允许代码异步地(并发)运行 - 不同的小片代码可以在重叠的时间帧中运行。这在使用 <a href="https://docs.raku.org/type/Supply.html">Supply</a> 或 <a href="https://docs.raku.org/type/Channel.html">Channel</a>(或两者)时非常方便。</p>
</div>
</div>
<div class="sect2">
<h3 id="_supplier">5.16. Supplier</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Supplier.html">Supplier</a> 向每一个要求接收其消息的 <a href="https://docs.raku.org/type/Supply.html">Supply</a> 发出消息。这是异步发生的。当你的程序在做其它的事情时, 它们也在做它们的工作。你可以在后台处理事情, 并在结果到来时进行处理, 而不是停止整个程序来等待所有的数据。其他语言可能称之为“发布 - 订阅”(或“PubSub”)。</p>
</div>
<div class="paragraph">
<p>这里有一个没什么用的例子。设置一个 <a href="https://docs.raku.org/type/Supplier.html">Supplier</a> 然后调用 <code>.emit</code> 来发送一条消息。由于你没有定义任何 <a href="https://docs.raku.org/type/Supply.html">Supply</a> , 该消息无处可去, 它永远消失了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supplier = Supplier.new;
$supplier.emit: 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要想收到这条消息, 可以通过调用带有 <a href="https://docs.raku.org/type/Block">Block</a> 的 <code>.tap</code> 向 <a href="https://docs.raku.org/type/Supplier.html">Supplier</a> 索取 <a href="https://docs.raku.org/type/Supply.html">Supply</a>(是的, 术语有点多):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supplier = Supplier.new;
my $supply   = $supplier.Supply;
my $tap      = $supply.tap: { put &#34;$^a * $^a = &#34;, $^a**2 };
$supplier.emit: 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Supply.html">Supply</a> 接收数字 <code>3</code> 并将其作为参数传递给 <a href="https://docs.raku.org/type/Block.html">Block</a>, 然后 Block 输出消息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">3 * 3 = 9</code></pre>
</div>
</div>
<div class="paragraph">
<p>有一些有用的内置 <a href="https://docs.raku.org/type/Supply.html">Supply</a> 可用。<code>.interval</code> <a href="https://docs.raku.org/type/Supply.html">Supply</a> 工厂会在你指定的秒数(可能是小数)自动发出下一个序数。你不需要指定 <a href="https://docs.raku.org/type/Supplier.html">Supplier</a>, 因为已经为你处理好了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fifth-second = Supply.interval: 0.2;
$fifth-second.tap: { say &#34;First: $^a&#34; };

sleep 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出显示五行。为什么只有五行？<code>sleep</code> 结束后, 距离程序结束还有五分之一秒的时间:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">First: 0
First: 1
First: 2
First: 3
First: 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦你启动了 tap, 它就会持续以异步的方式处理值, 直到程序结束(或你关闭 tap)。当你的程序到达 <code>sleep</code> 语句时, 会发生两件事。首先, 程序会等待你指定的时间量。第二, <a href="https://docs.raku.org/type/Supplier.html">Supplier</a> 会发出 tap 处理的值。这两件事是同时发生的。当你休眠时, <a href="https://docs.raku.org/type/Supplier.html">Supplier</a> 仍在工作。所有这些都在几行代码中完成！</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
并发不是并行。并发允许在重叠时间帧期间处理两个不同的事情。并行意味着两个不同的事情在同一时间发生。不过, 人们往往对其定义模糊不清。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果你拿走 <code>sleep</code> 语句, 你将无法获得任何输出 - 程序会立即结束。<a href="https://docs.raku.org/type/Supplier.html">Supplier</a> 不会让程序持续运行。如果增加 <code>sleep</code> 时间以使程序运行更长时间, 则可获得更多的输出。</p>
</div>
<div class="paragraph">
<p>下面是一个永远循环但只产生一行的计数器。回车会回到行的开头但不推进行(虽然终端缓冲可能会干扰):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fifth-second = Supply.interval: 0.2;
$fifth-second.tap: { print &#34;\x[D]$^a&#34; };

loop { }</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_多个_tap">5.16.1. 多个 tap</h4>
<div class="paragraph">
<p>这不仅仅只限于一个 tap。你可以在同一个 <a href="https://docs.raku.org/type/Supply.html">Supply</a> 上拥有任意数量的 tap。下面这个程序将需要两秒钟才能完成。第一个 tap 会运行两秒钟, 第二个 tap 会在最后一秒运行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval: 0.5;

$supply.tap: { say &#34;First: $^a&#34; };
sleep 1;

$supply.tap: { say &#34;Second: $^a&#34; };
sleep 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个 tap 标记其输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">First: 0
First: 1
Second: 0
First: 2
First: 3
Second: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意这里有什么奇怪的东西吗？第二个 tap 再次从 0 开始, 而不是同时获得与第一个 tap 相同的数字。<code>.interval</code> 方法创建一个按需供应(on-demand supply)。当 tap 要求它们时它开始产生值, 并且它为每个新 tap 产生新的间隔。每次 tap 想要一个值时, 它就会获得下一个值, 并且与任何其他 tap 无关。</p>
</div>
<div class="paragraph">
<p>在该代码再次使用其他值运行之前, <code>tap</code> 中的代码必须完全完成。这可确保你的代码在具有持久变量时不会混淆。如果此 <a href="https://docs.raku.org/type/Block.html">Block</a> 在第一次运行完成之前再次运行, 则 <code>$n</code> 的值将在第一次运行输出其消息之前自增几次:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$supply.tap: {
    state $n = 0; $n++;
    sleep 1;  # misses a couple of emitted values!
    say &#34;$n: $^a&#34;
    };</code></pre>
</div>
</div>
<div class="paragraph">
<p>练习 18.1 创建一个发射输入行的 <a href="https://docs.raku.org/type/Supplier.html">Supplier</a>。tap 它, 这样你只输出以前没有见过的名字。你可以使用 <a href="https://www.learningraku.com/">website</a> 下载部分蝴蝶人口普查文件。</p>
</div>
</div>
<div class="sect3">
<h4 id="_现场供应">5.16.2. 现场供应</h4>
<div class="paragraph">
<p>现场供应(live supply)与你目前遇到的按需供应(on-demand supply)不同。它会发出所有分流器(taps)共享的单个值流。当有新值时, 即使没有 tap 读取旧值, 也会丢弃旧值。每个新 tap 都以该单个流的当前值开始。使用 <code>.share</code> 将按需供应(on-demand supply)转变为现场供应(live supply):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply   = Supply.interval(0.5).share;

$supply.tap: { say &#34;First: $^a&#34; };
sleep 1;

$supply.tap: { say &#34;Second: $^a&#34; };
sleep 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出在两个方面有所不同。首先, <code>0</code> 值没有了。在第一次 tap 有机会看到它之前, <a href="https://docs.raku.org/type/Supply.html">Supply</a> 就发出了它。一秒钟后, 第二个 tap 开始, <a href="https://docs.raku.org/type/Supply.html">Supply</a> 发出数字 <code>2</code>; 两个 tap 都看到数字 <code>2</code>。之后, 这两个 tap 在程序结束前持续看到相同的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">First: 1
First: 2
Second: 2
First: 3
Second: 3
First: 4
Second: 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你不再需要 tap 时, 你可以关闭它; 它将不再接收值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval(0.4).share;

my $tap1 = $supply.tap: { say &#34;1. $^a&#34; };
sleep 1;

my $tap2 = $supply.tap: { say &#34;2. $^a&#34; };
sleep 1;

$tap1.close;

sleep 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在开始时, 第一个 tap 处理一切。第一次 <code>sleep</code> 结束后, 第二个 tap 启动。然后两个 tap 都处理了一秒钟, 然后第一个 tap 关闭, 只有第二个 tap 仍在工作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">First: 1
First: 2
First: 3
Second: 3
First: 4
Second: 4
Second: 5
Second: 6
Second: 7</code></pre>
</div>
</div>
<div class="paragraph">
<p>到目前为止, 本节仅涉及你创建的 <a href="https://docs.raku.org/type/Supply.html">Supply</a>。还有很多其他对象可以提供 <a href="https://docs.raku.org/type/Supply.html">Supply</a>。<code>.lines</code> 方法返回一个可以转变成 <a href="https://docs.raku.org/type/Supply.html">Supply</a> 的 <a href="https://docs.raku.org/type/Seq.html">Seq</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = $*ARGFILES.lines.Supply;  # IO::ArgFiles
$supply.tap: { put $++ ~ &#34;: $^a&#34; };

$supply.tap: {
    state %Seen;
    END { put &#34;{%Seen.keys.elems} unique lines&#34; }
    %Seen{$^a}++;
    };</code></pre>
</div>
</div>
<div class="paragraph">
<p>大多数<a href="https://docs.raku.org/type/List.html">列表</a>(或可以转变成列表的结构)可以做到这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list = List.new: 1, 4, 9, 16;
my $supply = $list.Supply;
$supply.tap: { put &#34;Got $^a&#34; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>甚至无限序列也可以:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $seq := 1, 2, * + 1 ... *;
my $supply2 = $seq.Supply;
$supply2.tap: { put &#34;Got $^a&#34; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, 这些示例不需要 <code>sleep</code> 来延迟程序结束。它们不像 <code>.interval</code> 那样&#34;耗费剩余的时间&#34;; 他们遍历每一个值。</p>
</div>
<div class="paragraph">
<p>练习 18.2 创建一个每秒发射一个数字的实时供应(<a href="https://docs.raku.org/type/Supply.html">Supply</a>)。三秒钟后, tap 它并输出它射发出的数字。再过三秒钟, 再次 tap 它输出相同的东西。再等三秒钟, 然后关闭第二个 tap。最后, 再过三秒后关闭第一个 tap。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_channel">5.17. Channel</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Channel.html">Channel</a> 是先到先得的队列。他们确保东西只被准确地处理一次。可以将任何东西放到 Channel 中, 也可以从 Channel 中将拿走任何东西。<a href="https://docs.raku.org/type/Channel.html">Channel</a> 两侧的代码无需了解另一方。几个线程可以共享一个 <a href="https://docs.raku.org/type/Channel.html">Channel</a>, 但是一旦下一个请求的东西从 <a href="https://docs.raku.org/type/Channel.html">Channel</a> 中消失了, 那么就不能被其他代码处理了。</p>
</div>
<div class="paragraph">
<p>创建一个  <a href="https://docs.raku.org/type/Channel.html">Channel</a>。使用 <code>.send</code> 将东西添加到 channel 中并使用 <code>.receive</code> 接收东西。处理完 <a href="https://docs.raku.org/type/Channel.html">Channel</a> 后, 关闭（<code>close</code>）它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new;
$channel.send: &#39;Hamadryas&#39;;
put &#39;Received: &#39;, $channel.receive;
$channel.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出显示的是你刚刚添加的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Received: Hamadryas</code></pre>
</div>
</div>
<div class="paragraph">
<p>在关闭（<code>.close</code>） Channel 之后, 你无法向 <a href="https://docs.raku.org/type/Channel.html">Channel</a> 发送更多值。你已添加的任何东西仍在 <a href="https://docs.raku.org/type/Channel.html">Channel</a> 中, 可供处理。你可以从 Channel 中接收(<code>.receive</code>) 东西, 直到 <a href="https://docs.raku.org/type/Channel.html">Channel</a> 为空:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new;
$channel.send: $_ for &lt;Hamadryas Rhamma Melanis&gt;;
put &#39;Received: &#39;, $channel.receive;
$channel.close;  # no more sending

while $channel.poll -&gt; $thingy {
    put &#34;while received $thingy&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>while</code> 循环使用 <code>.poll</code> 而不是 <code>.receive</code>。如果 Channel 中还有东西, <code>.poll</code> 会返回它。如果当前没有更多东西可用, 则返回 <code>Nil</code>（结束循环）:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Received: Hamadryas
while received Rhamma
while received Melanis</code></pre>
</div>
</div>
<div class="paragraph">
<p>当 <code>.poll</code> 返回 <code>Nil</code> 时, 你不知道是否还有更多东西。如果 <a href="https://docs.raku.org/type/Channel.html">Channel</a> 仍处于打开状态, 可以添加更多东西; 如果 <a href="https://docs.raku.org/type/Channel.html">Channel</a> 关闭, 将永远不会有更多的东西可以接收（<code>.receive</code>）。调用 <code>.fail</code> 会关闭 <a href="https://docs.raku.org/type/Channel.html">Channel</a>, 如果再次调用, 则 <code>.receive</code> 会抛出错误。你可以捕获<a href="https://docs.raku.org/type/Exception.html">异常</a>以结束循环:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new;
$channel.send: $_ for &lt;Hamadryas Rhamma Melanis&gt;;
put &#39;Received: &#39;, $channel.receive;
$channel.fail(&#39;End of items&#39;);   # X::AdHoc

loop {
    CATCH {
        default { put &#34;Channel is closed&#34;; last }
    }
    put &#34;loop received: &#34;, $channel.receive;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以 <code>tap</code> <a href="https://docs.raku.org/type/Channel.html">Channel</a> 代替 loop 循环。它为你调用 <code>.receive</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new;
$channel.send: $_ for &lt;Hamadryas Rhamma Melanis&gt;;
put &#39;Received: &#39;, $channel.receive;
$channel.fail(&#39;End of items&#39;);

$channel.Supply.tap: { put &#34;Received $_&#34; }
CATCH { default { put &#34;Channel is closed&#34; } }</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出相同:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Received: Hamadryas
loop received: Rhamma
loop received: Melanis
Channel is closed</code></pre>
</div>
</div>
<div class="paragraph">
<p>练习 18.3: 创建一个 <a href="https://docs.raku.org/type/Channel.html">Channel</a> 并 tap 它。将输入行发送到 <a href="https://docs.raku.org/type/Channel.html">Channel</a> 中, 但仅打印素数行号的输入。</p>
</div>
</div>
<div class="sect2">
<h3 id="_promise">5.18. Promise</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Promise.html">Promise</a> 是一小片会在稍后产生结果的代码, 所说的&#34;稍后&#34;可能不会很快。它把工作安排到另一个线程中, 而程序的其余部分继续。这些是 Raku 并发性的基础, 它们为你完成了大部分艰苦的工作。</p>
</div>
<div class="paragraph">
<p>每个 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 都有一个状态。它可能正在等待运行, 当前正在运行或已完成运行。它如何完成取决于它的状态:<a href="https://docs.raku.org/type/Promise.html">Promise</a> 在成功时是 <code>Kept</code>, 在失败时是 <code>Broken</code>。当它正在运行时是 <code>Planned</code>。</p>
</div>
<div class="paragraph">
<p>一个简单的 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 是一个计时器。<code>.in</code> 方法生成一个 <a href="https://docs.raku.org/type/Promise.html">Promise</a>, 它将在指定的秒数后变成 kept 状态:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $five-seconds-from-now = Promise.in: 5;

loop {
    sleep 1;
    put &#34;Promise status is: &#34;, $five-seconds-from-now.status;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>起初 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 是 <code>Planned</code> 状态。五秒钟后（大致）, <a href="https://docs.raku.org/type/Promise.html">Promise</a> 变为 <code>Kept</code> 状态。那时你知道已经过了五秒钟:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Promise status is: Planned
Promise status is: Planned
Promise status is: Planned
Promise status is: Planned
Promise status is: Kept
Promise status is: Kept
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>你没必要不断检查  <a href="https://docs.raku.org/type/Promise.html">Promise</a>。使用 <code>.then</code> 设置代码在 Promise 变为 <code>kept</code> 状态时运行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $five-seconds-from-now = Promise.in: 5;
$five-seconds-from-now.then: { put &#34;It&#39;s been 5 seconds&#34; };</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行此程序时没有任何反应; 在程序结束之前 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 不是 Kept 状态。<a href="https://docs.raku.org/type/Promise.html">Promise</a> 的 Planned 状态不会阻止程序结束。</p>
</div>
<div class="paragraph">
<p>你可以给程序足够的时间去消耗五秒钟。<code>sleep</code> 延长了程序时间:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $five-seconds-from-now = Promise.in: 5;
$five-seconds-from-now.then: { put &#34;It&#39;s been 5 seconds&#34; };

sleep 7;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在你看到 <code>.then</code> 代码中的输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">It&#39;s been 5 seconds</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_等待承诺">5.18.1. 等待承诺</h4>
<div class="paragraph">
<p>你可以使用 <code>await</code> 而不是 <code>sleep</code> （并猜测你需要空闲的时间）来阻塞你的程序, 直到 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 的状态变为 Kept 或 Broken:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $five-seconds-from-now = Promise.in: 5;
$five-seconds-from-now.then: { put &#34;It&#39;s been 5 seconds&#34; };

await $five-seconds-from-now;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些示例使用 <code>await</code>, 因为你需要程序保持运行。更有趣的是, 你的程序很可能会做很多其他的工作, 所以你可能不需要让程序持续作用。</p>
</div>
<div class="paragraph">
<p>你可以使用绝对时间 <code>.at</code> 而不是相对时间。这可以是 <a href="https://docs.raku.org/type/Instant.html">Instant</a> 值或者你可以强制转换为 <a href="https://docs.raku.org/type/Instant.html">Instant</a>（或表示 <a href="https://docs.raku.org/type/Instant.html">Instant</a> 的 <a href="https://docs.raku.org/type/Numeric.html">Numeric</a> 值）的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $later = Promise.at: now + 7;
$later.then: { put &#34;It&#39;s now $datetime&#34; };

await $later;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>start</code> 关键字创建一个 <a href="https://docs.raku.org/type/Promise.html">Promise</a>。代码完成后, <a href="https://docs.raku.org/type/Promise.html">Promise</a> 完成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pause = start {
    put &#34;Promise starting at &#34;, now;
    sleep 5;
    put &#34;Promise ending at &#34;, now;
    };
await $pause;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出显示 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 的开始和结束:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Promise starting at Instant:1507924913.012565
Promise ending at Instant:1507924918.018444</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 抛出<a href="https://docs.raku.org/type/Exception.html">异常</a>, 承诺就被破坏了。你可以返回所有你喜欢的 <code>False</code> 值, 但是直到你失败或抛出一个带有错误的 <a href="https://docs.raku.org/type/Exception.html">Exception</a>, 你的 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 将被兑现。即使它返回 <code>False</code>, 这也会成功:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $return-false = start {
    put &#34;Promise starting at &#34;, now;
    sleep 5;
    put &#34;Promise ending at &#34;, now;
    return False;  # still kept
};
await $return-false;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面这个例子打破了 <a href="https://docs.raku.org/type/Promise.html">Promise</a>, 因为你显式地调用了 <code>fail</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $five-seconds-from-now = start {
    put &#34;Promise starting at &#34;, now;
    sleep 5;
    fail;
    put &#34;Promise ending at &#34;, now;
    };
await $five-seconds-from-now;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你得到了一部分输出, 但在你获得其余的输出之前, <code>fail</code> 就停止这个 <a href="https://docs.raku.org/type/Block.html">Block</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Promise starting at Instant:1522698239.054087
An operation first awaited:
  in block &lt;unit&gt; at ...

Died with the exception:
    Failed
      in block  at ...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_等待多个承诺">5.18.2. 等待多个承诺</h4>
<div class="paragraph">
<p><code>await</code> 可以接受一个 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;Starting at {now}&#34;;
my @promises =
    Promise.in( 5 ).then( { put &#39;5 finished&#39; } ),
    Promise.in( 3 ).then( { put &#39;3 finished&#39; } ),
    Promise.in( 7 ).then( { put &#39;7 finished&#39; } ),
    ;

await @promises;

put &#34;Ending at {now}&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在所有的<a href="https://docs.raku.org/type/Promise.html">承诺</a>没有兑现(Kept)之前, 这个程序不会结束:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Starting at Instant:1524856233.733533
3 finished
5 finished
7 finished
Ending at Instant:1524856240.745510</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果任何一个<a href="https://docs.raku.org/type/Promise.html">承诺</a>被破坏, 那么整个 <code>await</code> 就会完成, 计划中的<a href="https://docs.raku.org/type/Promise.html">承诺</a>也会被放弃:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;Starting at {now}&#34;;
my @promises =
    start { sleep 5; fail &#34;5 failed&#34; },
    Promise.in( 3 ).then( { put &#39;3 finished&#39; } ),
    Promise.in( 7 ).then( { put &#39;7 finished&#39; } ),
    ;

await @promises;

put &#34;Ending at {now}&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <code>.in( 3 )</code> <a href="https://docs.raku.org/type/Promise.html">承诺</a>被兑现(Kept)了 , 那么带  <code>start</code> 的那个承诺就会失败:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Starting at Instant:1524856385.367019
3 finished
An operation first awaited:
  in block &lt;unit&gt; at await-list.p6 line 9

Died with the exception:
    5 failed
      in block  at await-list.p6 line 4</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_管理自己的承诺">5.18.3. 管理自己的承诺</h4>
<div class="paragraph">
<p>在前面的例子中, 有别的东西为你管理<a href="https://docs.raku.org/type/Promise.html">承诺</a>。你可以自己管理。从制作一个裸的 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 开始:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过智能匹配 <a href="https://docs.raku.org/type/PromiseStatus.html">PromiseStatus</a> 中的常量(你可以免费获得)来检查其状态:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put do given $promise.status {
    when Planned { &#34;Still working on it&#34; }
    when Kept    { &#34;Everything worked out&#34; }
    when Broken  { &#34;Oh no! Something didn&#39;t work&#34; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此时, <code>$promise</code> 已经计划好了, 并将保持这种方式。这将永远循环下去:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop {
    put do given $promise.status {
        when Planned { &#34;Still working on it&#34; }
        when Kept    { &#34;Everything worked out&#34; }
        when Broken  { &#34;Oh no! Something didn&#39;t work&#34; }
    }

    last unless $promise.status ~~ Planned;
    sleep 1;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以用 <code>now</code> 记下开始的时间, 并检查是否在五秒后制作你自己的 <code>.at</code> 或 <code>.in</code>。五秒后的一段时间, 你可以调用 <code>.keep</code> 来改变状态:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.new;

my $start = now;
loop {
    $promise.keep if now &gt; $start + 5;
    given $promise.status {
        when Planned { put &#34;Still working on it&#34; }
        when Kept    { put &#34;Everything worked out&#34; }
        when Broken  { put &#34;Oh no! Something didn&#39;t work&#34; }
    }

    last unless $promise.status ~~ Planned;
    sleep 1;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 循环在五秒后停止:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Still working on it
Still working on it
Still working on it
Still working on it
Still working on it
Everything worked out</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 仍然可以调用带有 <code>.then</code> 的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.new;
$promise.then: { put &#34;Huzzah! I&#39;m kept&#34; }

my $start = now;
loop { ... } # same as before</code></pre>
</div>
</div>
<div class="paragraph">
<p>该输出显示了 <code>.then</code> 代码的输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Still working on it
Still working on it
Still working on it
Still working on it
Still working on it
Everything worked out
Huzzah! I&#39;m kept</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者你可能会破坏<a href="https://docs.raku.org/type/Promise.html">承诺</a>。无论哪种情况, 你的 <code>.then</code> 代码都会运行, 你需要区分这些情况。<code>.then</code> 代码有一个参数, 那就是 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 本身。如果你不给参数命名, 那它就在 <code>$_</code> 里面:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.new;
$promise.then: {
    put do given .status {
        when Kept { &#39;Huzzah!&#39; }
        when Broken { &#39;Darn!&#39; }
    }
}

my $start = now;
loop {
    $promise.break if now &gt; $start + 5;
    last unless $promise.status ~~ Planned;
    sleep 1;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_promise_junctions">5.18.4. Promise Junctions</h4>
<div class="paragraph">
<p>你可以使用 <a href="https://docs.raku.org/type/Junction">Junction</a> 来创建一个超级 <a href="https://docs.raku.org/type/Promise.html">Promise</a>。<code>.allof</code> 方法创建一个 <a href="https://docs.raku.org/type/Promise.html">Promise</a>, 如果它包含的所有 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 都被兑现了(Kept), 那么这个 Promise 就会被兑现:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $all-must-pass = await Promise.allof:
    Promise.in(5).then( { put &#39;Five seconds later&#39; } ),
    start { sleep 3; put &#39;Three seconds later&#39;; },
    Promise.at( now + 1 ).then( { put &#39;One second later&#39; } );
put $all-must-pass;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <code>.anyof</code> <a href="https://docs.raku.org/type/Promise.html">Promise</a> 所包含的任何一个承诺被兑现了, 那么这个 Promise 就会得到兑现。除了其中一个承诺之外, 所有部分都可以被打破, 而更大的 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 仍然得到兑现:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $any-can-pass = await Promise.anyof:
    Promise.in(5).then( { put &#39;Five seconds later&#39; } ),
    start { sleep 3; put &#39;Three seconds later&#39;; fail },
    Promise.at( now + 1 ).then( { put &#39;One second later&#39; } );
put $any-can-pass;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这两种情况都成功了。在 <code>.allof</code> 情况下, 你看到的是所有三个 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 的输出。然后, 你看到的是 <code>.anyof</code> 中的一个  <a href="https://docs.raku.org/type/Promise.html">Promise</a> 的输出。并非所有这些 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 都需要完成, 因为整体的 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 已经知道它可以成功:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">One second later
Three seconds later
Five seconds later
True
One second later
True</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_响应式编程">5.19. 响应式编程</h3>
<div class="paragraph">
<p><code>react</code> <a href="https://docs.raku.org/type/Block.html">Block</a> 允许你在有新的值时运行一些代码。它一直运行, 直到它用完要处理的值。它类似于事件循环。下面是一个非常简单的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    whenever True { put &#39;Got something that was true&#39; }
}

END put &#34;End of the program&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你使用 <code>whenever</code> 为 <a href="https://docs.raku.org/type/Block.html">Block</a> 块提供值。在这个例子中, 你有一个单一的值 <code>True</code>。这不是一个条件表达式或测试, 如 <code>if</code> 或 <code>while</code>。<a href="https://docs.raku.org/type/Block.html">Block</a> 会对这个单一的值作出反应, 并运行 <code>whenever</code> 代码。之后就没有更多的值了, <a href="https://docs.raku.org/type/Block.html">Block</a> 就退出了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Got something that was true
End of the program</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可能会认为这是一个循环结构, 但这不是一回事。它并不是在 <code>react</code> <a href="https://docs.raku.org/type/Block.html">Block</a> 中做完所有的事情, 然后再重新启动 <a href="https://docs.raku.org/type/Block.html">Block</a>。<code>True</code> 的 <code>whenever</code> 只运行一次, 而不是像你期望的 <code>loop</code> 那样永远运行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop {
    if True { put &#39;Got something that was true&#39;  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>把 <code>whenever</code> 从 <code>True</code> 改为 <code>Supply.interval</code>, 就再也看不到程序结束的消息了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval: 1;

react {
    whenever $supply { put &#34;Got $^a&#34; }
}

END put &#34;End of the program&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要 <a href="https://docs.raku.org/type/Supply.html">Supply</a> 具有 <code>whenever</code> 可用的值, <code>react</code> <a href="https://docs.raku.org/type/Block.html">Block</a> 就会持续下去:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Got 0
Got 1
Got 2
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以同时拥有 <a href="https://docs.raku.org/type/Supply.html">Supply</a>  和 <code>True</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval: 1;

react {
    whenever $supply { put &#34;Got $^a&#34; }
    whenever True { put &#39;Got something that was true&#39; }
}

END put &#34;End of the program&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>带有 <a href="https://docs.raku.org/type/Supply.html">Supply</a> 的 <code>whenever</code> 立即作出反应, 并输出 <a href="https://docs.raku.org/type/Supply.html">Supply</a> 中的第一个值。带有 <code>True</code> 的 <code>whenever</code> 则立即作出反应, 并耗尽其值(单个 <code>True</code>)。之后, <a href="https://docs.raku.org/type/Supply.html">Supply</a> 会继续运行, 直到你放弃并中断程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Got 0
Got something that was true
Got 1
Got 2
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你把两个 <code>whenever</code> 的顺序对调, 那么 <code>True</code> 可能会先作出反应:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval: 1;

react {
    whenever True { put &#39;Got something that was true&#39; }
    whenever $supply { put &#34;Got $^a&#34; }
}

END put &#34;End of the program&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出略有不同, 但并没有说一定要这样。也许未来的实现会有不同的选择。这就是并发, 你不能依赖严格的发生顺序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Got something that was true
Got 0
Got 1
Got 2
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>与其中断程序让 <code>react</code> 停止, 不如在 <a href="https://docs.raku.org/type/Block.html">Block</a> 中用 <code>done</code> 来完成。你可以使用带有 <code>.in</code> 的 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 来提供某个时间间隔后的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval: 1;

react {
    whenever $supply { put &#34;Got $^a&#34; }
    whenever True { put &#39;Got something that was true&#39; }
    whenever Promise.in(5) { put &#39;Timeout!&#39;; done }
    }

END put &#34;End of the program&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>5 秒后, <a href="https://docs.raku.org/type/Promise.html">Promise</a> 被兑现, 然后 <code>whenever</code> 被启动。它输出超时消息, 并使用 <code>done</code> 结束 <code>react</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Got 0
Got something that was true
Got 1
Got 2
Got 3
Got 4
Got 5
Timeout!
End of the program</code></pre>
</div>
</div>
<div class="paragraph">
<p>添加另一个 <code>react</code>, 然后用新的 <a href="https://docs.raku.org/type/Supply.html">Supply</a> 重新开始这个过程:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval: 1;

react {
    whenever $supply { put &#34;Got $^a&#34; }
    whenever True { put &#39;Got something that was true&#39; }
    whenever Promise.in(5) { put &#39;Timeout!&#39;; done }
}

put &#34;React again&#34;;

react {
    whenever $supply { put &#34;Got $^a&#34; }
}

END put &#34;End of the program&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Supply.html">Supply</a> 的输出又开始了, 但在间隔的开始:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Got 0
Got something that was true
Got 1
Got 2
Got 3
Got 4
Timeout!
React again
Got 0
Got 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>练习 18.4: 修改双 <code>react</code> 示例, 使用现场供应(live <a href="https://docs.raku.org/type/Supply.html">Supply</a>)而不是按需供应。输出是如何变化的？</p>
</div>
<div class="sect3">
<h4 id="_在后台响应">5.19.1. 在后台响应</h4>
<div class="paragraph">
<p><code>react</code> 是一种当有值时, 你可以对其进行响应的方式。到目前为止, 你已经看到 <code>react</code> 是一个顶层的 <a href="https://docs.raku.org/type/Block.html">Block</a>。它一直在运行 - 支撑着程序的其余部分 - 直到它完成。</p>
</div>
<div class="paragraph">
<p>相反, 你很有可能希望你的 <code>react</code> 在你的程序做其他事情的时候在后台做它的工作。你可以用一个带有 <code>start</code> 的 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 包裹 <code>react</code>。这样就可以让 <code>react</code> 在一个线程中工作, 而程序的其他部分则继续工作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval: 1;

my $promise = start {
    react {
        whenever $supply { put &#34;Got $^a&#34; }
        whenever True { put &#39;Got something that was true&#39; }
        whenever Promise.in(5) { put &#39;Timeout!&#39;; done }
    }
}

put &#39;After the react loop&#39;;

await $promise;
put &#39;After the await&#39;;

END put &#34;End of the program&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出的第一行是来自 <code>start</code> 块之后的 <code>put</code>。<code>react</code> 开始工作, 但没有阻塞程序的其他部分:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">After the react loop
Got 0
Got something that was true
Got 1
Got 2
Got 3
Got 4
Timeout!
After the await
End of the program</code></pre>
</div>
</div>
<div class="paragraph">
<p>把它提升一个档次。加一个 <a href="https://docs.raku.org/type/Channel.html">Channel</a> 进去。把 <a href="https://docs.raku.org/type/Supply.html">Supply</a> 移到 <code>whenever</code> 里面。当这个 <a href="https://docs.raku.org/type/Supply.html">Supply</a> 有一个值的时侯, 它就会执行 <a href="https://docs.raku.org/type/Block.html">Block</a> 以输出和之前一样的东西。如果该值是 2 的倍数, 它还会将其发送到 <a href="https://docs.raku.org/type/Channel.html">Channel</a> 中。</p>
</div>
<div class="paragraph">
<p>添加第二个 <code>whenever</code> 来读取 <a href="https://docs.raku.org/type/Channel.html">Channel</a> 上可用值。你需要将 <a href="https://docs.raku.org/type/Channel.html">Channel</a> 转换为 <a href="https://docs.raku.org/type/Supply.html">Supply</a>。这很容易, 因为有一个 <code>.Supply</code> 方法。<code>whenever</code> 分接那个 <a href="https://docs.raku.org/type/Supply.html">Supply</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new;

my $promise = start {
    react {
        whenever Supply.interval: 1
            { put &#34;Got $^a&#34;; $channel.send: $^a if $^a %% 2 }
        whenever $channel.Supply
            { put &#34;Channel got $^a&#34; }
        whenever True
            { put &#39;Got something that was true&#39; }
        whenever Promise.in(5)
            { put &#39;Timeout!&#39;; done }
        }
    }

put &#39;After the react loop&#39;;

await $promise;
put &#39;After the await&#39;;

END put &#34;End of the program&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在插入 <a href="https://docs.raku.org/type/Channel.html">Channel</a> 输出的情况下, 输出的效果与之前大致相同:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">After the react loop
Got 0
Got something that was true
Channel got 0
Got 1
Got 2
Channel got 2
Got 3
Got 4
Channel got 4
Timeout!
After the await
End of the program</code></pre>
</div>
</div>
<div class="paragraph">
<p>练习 18.5: 使用 <a href="https://docs.raku.org/type/IO::Notification.html"><code>IO::Notification</code></a> 在命令行指定的文件发生变化时输出一条消息。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_7">5.20. 总结</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Promise.html">Promise</a> 是并发的基础, 有多种方法可以创建它们来获取你所需要的东西。将你的问题分解成独立的部分, 并以 <a href="https://docs.raku.org/type/Promise.html">Promise</a> 的形式运行, 它可以在不同的线程中运行(甚至可能在不同的核心上运行)。有了这些, <a href="https://docs.raku.org/type/Supply.html">Supply</a> 和 <a href="https://docs.raku.org/type/Channel.html">Channel</a> 提供了一种在你的程序的不相连的部分之间传递数据的方法。要想从所有这些东西中获得最大的好处, 你需要用不同于你目前所看到的程序性的东西来思考。通过实践, 你会得到这些。
== 控制其它程序</p>
</div>
<div class="paragraph">
<p>有时你需要让其他程序为你做一些工作。 Perl 系列语言被称为“互联网的胶水”。开始一个著名的，稳定的，现有的程序比自己重新实现它更容易，更快。本章介绍了许多启动和控制外部程序的方法，以便根据你的意愿对其进行控制。</p>
</div>
</div>
<div class="sect2">
<h3 id="_快速和容易">5.21. 快速和容易</h3>
<div class="paragraph">
<p><code>shell</code> 例程是运行外部命令或程序的快捷方式。它接受参数并在 shell 中运行它，就像你自己输入它一样。此示例使用类 Unix 的 shell 命令列出所有文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">shell( &#39;ls -l&#39; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you were on Windows you’d use a different command. There’s an implicit <code>cmd /c</code> in front of your command:</p>
</div>
<div class="paragraph">
<p>如果你在 Windows 上，你会使用不同的命令。命令前面有一个隐式的 <code>cmd /c</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">shell( &#39;dir&#39; );   # actually cmd /c dir</code></pre>
</div>
</div>
<div class="paragraph">
<p>此命令的输出将转到程序输出所在的位置（只要你没有将标准输出或错误重定向到其他内容）。</p>
</div>
<div class="paragraph">
<p>你可以通过检查 <code>$*DISTRO</code> 变量来选择命令。 <code>Distro</code> 对象有一个 <code>.is-win</code> 方法，如果它认为你的程序在该平台上运行，则返回 <code>True</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $command = $*DISTRO.is-win ?? &#39;dir&#39; !! &#39;ls -l&#39;;
shell( $command );</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
注意变量作为 <code>shell</code> 的参数！一定要知道它们里面有什么。如果 shell 中的字符是特殊的，那么它在该值中也是特殊的。稍后详细介绍。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><code>shell</code> 返回一个 [<code>Proc</code>](<a href="https://docs.raku.org/type/Proc.html" class="bare">https://docs.raku.org/type/Proc.html</a>) 对象。当你在 sink 上下文中使用它（对结果不执行任何操作）并且命令失败时，[<code>Proc</code>](<a href="https://docs.raku.org/type/Proc.html" class="bare">https://docs.raku.org/type/Proc.html</a>) 对象会抛出异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">shell( &#39;/usr/bin/false&#39; );  # throws X::Proc::Unsuccessful</code></pre>
</div>
</div>
<div class="paragraph">
<p>当命令以 <code>0</code> 以外的值退出时，命令“失败”。这是一种 Unix 惯例，其中非零数字表示各种错误条件。并非所有程序都遵循该惯例，如果不遵循，你将不得不做更多的工作。</p>
</div>
<div class="paragraph">
<p>你可以保存结果以避免异常。你可以检查 [<code>Proc</code>](<a href="https://docs.raku.org/type/Proc.html" class="bare">https://docs.raku.org/type/Proc.html</a>) 对象以查看发生的情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $proc = shell( &#39;/usr/bin/false&#39; );
unless $proc.so {
    put &#34;{$proc.command} failed with exit code: {$proc.exitcode}&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这仍然可能不是你想要的。如果你希望它返回非零值，你可能必须自己处理部分过程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $proc = shell( &#39;/usr/bin/true&#39; );
given $proc {
    unless .exitcode == 1 {
        put &#34;{.command} returned: {.exitcode}&#34;;
        X::Proc::Unsuccessful.new.throw;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你不关心命令是否失败，则可以在返回的对象上调用 <code>.so</code>。这“处理”对象并阻止 [<code>Proc</code>](<a href="https://docs.raku.org/type/Proc.html" class="bare">https://docs.raku.org/type/Proc.html</a>) 抛出异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">shell( &#39;/usr/bin/false&#39; ).so</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_引起来的命令">5.21.1. 引起来的命令</h4>
<div class="paragraph">
<p>有时你想捕获命令的输出或将其保存在变量中。你可以使用带 <code>:x</code> 副词的引用从命令的输出创建一个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)：" class="bare">https://docs.raku.org/type/Str.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $output = Q:x{ls -1};
my $output = q:x{ls -1};
my $output = qq:x{$command};</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些是它们的稍短版本，可以做同样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $output = Qx{dir};
my $output = qx{dir};
my $output = qqx{$command};</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些仅捕获标准输出。如果要合并标准错误，则需要在 shell 中处理。这适用于 Unix 和 Windows，使用 <code>2&gt;＆1</code> 。这会在句柄到达你的程序之前合并它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $output = qq:x{$command 2&gt;&amp;1};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_更安全的命令">5.21.2. 更安全的命令</h4>
<div class="paragraph">
<p><code>run</code> 例程允许你将命令表示为列表。列表中的第一项是命令名，Raku 直接执行而没有 shell 交互。这个命令并不像它看起来那样令人讨厌，因为没有一个字符对 shell 来说是特殊的。那些分号不会结束命令并启动另一个命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># don&#39;t do this, just in case
run( &#39;/bin/echo&#39;, &#39;-n&#39;, &#39;;;;; rm -rf /&#39; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你在 shell 中将其作为单个[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)输入，则可以启动递归操作以删除所有文件。即使在开玩笑中也不要尝试这个（或者使用带有保存快照的虚拟机！）。" class="bare">https://docs.raku.org/type/Str.html)输入，则可以启动递归操作以删除所有文件。即使在开玩笑中也不要尝试这个（或者使用带有保存快照的虚拟机！）。</a></p>
</div>
<div class="paragraph">
<p><code>run</code> 返回一个 [<code>Proc</code>](<a href="https://docs.raku.org/type/Proc.html" class="bare">https://docs.raku.org/type/Proc.html</a>) 对象; 以与 <code>shell</code> 相同的方式处理它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unless run( ... ) {
    put &#34;Command failed&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可能想要使用没有路径信息的裸命令名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">run( &#39;echo&#39;, &#39;-n&#39;, &#39;Hello&#39; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也不是特别安全。 <code>run</code> 将在 <code>PATH</code> 环境变量中查找匹配的文件。这是人们可以在你的程序之外设置的东西。有人可能会欺骗你的程序运行一些叫做 <strong>echo</strong> 的东西。</p>
</div>
<div class="paragraph">
<p>你可以清除 <code>PATH</code>，强制程序始终指定命令的完整路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">%*ENV{PATH} = &#39;&#39;;  # won&#39;t find anything
run( &#39;/bin/echo&#39;, &#39;-n&#39;, &#39;Hello&#39; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>将 <code>PATH</code> 设置为你信任且允许的目录可能更容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">%*ENV{PATH} = &#39;/bin:/sbin:/usr/bin:/usr/sbin&#39;
run( &#39;echo&#39;, &#39;-n&#39;, &#39;Hello&#39; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>这并不意味着你找到的命令是正确的;有人可能已经篡改过。没有办法提供完美的安全性 - 但你不必太担心。每当你与程序之外的事物进行交互时，请考虑这一点。</p>
</div>
<div class="paragraph">
<p>像 <code>shell</code> 一样，<code>run</code> 返回一个 [<code>Proc</code>](<a href="https://docs.raku.org/type/Proc.html" class="bare">https://docs.raku.org/type/Proc.html</a>) 对象。 <code>:out</code> 参数捕获标准输出并通过 [<code>Proc</code>](<a href="https://docs.raku.org/type/Proc.html" class="bare">https://docs.raku.org/type/Proc.html</a>) 对象使其可用。使用 <code>.slurp</code> 来提取它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $proc = run(
    &#39;/bin/some_command&#39;, &#39;-n&#39;, &#39;-t&#39;, $filename
    :out,
    );
put &#34;Output is ｢{ $proc.out.slurp }｣&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:err</code> 参数对错误输出执行相同的操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $proc = run(
    &#39;/bin/some_command&#39;, &#39;-n&#39;, &#39;-t&#39;, $filename
    :out, :err,
    );
put &#34;Output is ｢{ $proc.out.slurp }｣&#34;;
put &#34;Error is ｢{ $proc.err.slurp }｣&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你不希望它们作为单独的流，你可以合并它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $proc = run(
    &#39;/bin/some_command&#39;, &#39;-n&#39;, &#39;-t&#39;, $filename
    :out, :err, :merge
    );
put &#34;Output is ｢{ $proc.out.slurp }｣&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以给它其命名参数以控制编码，环境和当前工作目录（以及其他内容）。</p>
</div>
<div class="paragraph">
<p>练习19.1 使用 <code>run</code> 来获取当前目录的按文件大小排序的文件列表。输出那个长文件列表。 Unix 命令是 <code>ls -lrS</code>，Windows 命令是 <code>cmd /c dir /OS</code>。一旦你开始工作，过滤行只输出那些带有 <code>7</code> 的行。最后，你能让一个程序在两个平台上都能运行吗？</p>
</div>
</div>
<div class="sect3">
<h4 id="_写入到_proc">5.21.3. 写入到 Proc</h4>
<div class="paragraph">
<p>进程可以从你的程序中接收数据。包括 <code>:in</code> 允许你写入到进程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = &#39;Hamadryas perlicus&#39;;

my $hex = run &#39;hexdump&#39;, &#39;-C&#39;, :in, :out;

$hex.in.print: $string;
$hex.in.close;

$hex.out.slurp.put;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，你将调用一次  <code>.print</code>，然后关闭输出。这对于 <strong>hexdump</strong> 来说很好，但其他程序可能表现不同。有些人可能会期待一些输入，给你一些输出，然后在你读取之后期望更多的输入。这如何工作取决于具体的程序，有时可能令人发狂：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = &#39;Hamadryas perlicus&#39;;

my $hex = run &#39;fictional-program&#39;, :in, :out;
$hex.in.print: $string;
$hex.out.slurp;
$hex.in.print: $string;
...;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以将一个外部程序的输出重定向到另一个外部程序的输入。此示例获取 <code>raku -v</code> 的输出并使其成为下一个[<code>Proc</code>](<a href="https://docs.raku.org/type/Proc.html" class="bare">https://docs.raku.org/type/Proc.html</a>) 的输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $proc1 = run( &#39;raku&#39;, &#39;-v&#39;, :out );
my $proc2 = run(
    &#39;tr&#39;, &#39;-s&#39;, Q/[:lower:]/,  Q/[:upper:]/,
    :in($proc1.out)
    );</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二个 <code>run</code> 使用外部的 <code>tr</code> 命令将所有小写字母转换为大写字母：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">THIS IS RAKUDO STAR VERSION 2018.04 BUILT ON MOARVM VERSION 2018.04
IMPLEMENTING PERL 6.C.</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_procs">5.22. Procs</h3>
<div class="paragraph">
<p>[<code>Proc</code>](<a href="https://docs.raku.org/type/Proc.html" class="bare">https://docs.raku.org/type/Proc.html</a>) 对象处理 <code>shell</code> 和 <code>run</code>。自己构造对象以获得更多控制。这分两步进行; [<code>Proc</code>](<a href="https://docs.raku.org/type/Proc.html" class="bare">https://docs.raku.org/type/Proc.html</a>) 设置了稍后运行命令的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $proc = Proc.new: ...;</code></pre>
</div>
</div>
<div class="paragraph">
<p>设置捕获并合并标准输出和错误流的通用 [<code>Proc</code>](<a href="https://docs.raku.org/type/Proc.html)：" class="bare">https://docs.raku.org/type/Proc.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $proc =  Proc.new: :err, :out, :merge;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你准备好运行命令时，<code>.spawn</code> 它。你生成的进程使用你已经建立的设置。结果是基于程序退出状态的布尔值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unless $proc.spawn: &#39;echo&#39;, &#39;-n&#39;, &#39;Hello&#39; {
    ... # handle the error
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要不同的设置，请在调用 <code>.spawn</code> 时指定当前工作目录和环境：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $worked = $proc.spawn: :cwd($some-dir), :env(%hash);
unless $worked {
    ... # handle the error
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>练习19.2 创建捕获标准输出和错误的 [<code>Proc</code>](<a href="https://docs.raku.org/type/Proc.html)。生成命令以获取目录列表。" class="bare">https://docs.raku.org/type/Proc.html)。生成命令以获取目录列表。</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_异步控制">5.23. 异步控制</h3>
<div class="paragraph">
<p>通过 [<code>Proc</code>](<a href="https://docs.raku.org/type/Proc.html)（以及" class="bare">https://docs.raku.org/type/Proc.html)（以及</a> <code>shell</code> 和 <code>run</code>）执行命令会使程序等待，直到外部程序完成其工作。使用 [<code>Proc::Async</code>](<a href="https://docs.raku.org/type/Proc::Async.html" class="bare">https://docs.raku.org/type/Proc::Async.html</a>) 允许这些程序在自己的 [<code>Promise</code>](<a href="https://docs.raku.org/type/Promise.html" class="bare">https://docs.raku.org/type/Promise.html</a>) 中运行，而程序的其余部分继续运行。</p>
</div>
<div class="paragraph">
<p>运行外部 <code>find</code> 并等待它遍历所有文件系统可能几乎永远等不到（至少感觉像）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $proc = Proc.new: :out;
$proc.spawn: &#39;find&#39;, &#39;/&#39;, &#39;-name&#39;, &#39;*.txt&#39;;

for $proc.out.lines -&gt; $line {
    put $++, &#39;: &#39;, $line;
}

put &#39;Finished&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行此程序时，你会看到 <strong>find</strong> 的所有输出行。完成后，可能需要很长时间，然后你将看到 <code>Finished</code> 消息。你可以异步地执行此操作。</p>
</div>
<div class="paragraph">
<p>你可以在这些示例中看到 Unix <strong>find</strong>，但你还在第8章中创建了一个类似的目录列表程序，你可以将其用作外部程序来练习使用 [<code>Proc</code>](<a href="https://docs.raku.org/type/Proc.html)：" class="bare">https://docs.raku.org/type/Proc.html)：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $proc = Proc.new: :out;
$proc.spawn: &#39;raku&#39;, &#39;dir-listing.p6&#39;;

for $proc.out.lines -&gt; $line {
    put $++, &#39;: &#39;, $line;
}

put &#39;Finished&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>[<code>Proc::Async</code>](<a href="https://docs.raku.org/type/Proc::Async.html" class="bare">https://docs.raku.org/type/Proc::Async.html</a>) 的接口与 [<code>Proc</code>](<a href="https://docs.raku.org/type/Proc.html" class="bare">https://docs.raku.org/type/Proc.html</a>) 的有点不同。一旦有了对象，就可以使用第18章中看到的 [<code>Supply</code>](<a href="https://docs.raku.org/type/Supply.html" class="bare">https://docs.raku.org/type/Supply.html</a>) 和 [<code>Promise</code>](<a href="https://docs.raku.org/type/Promise.html" class="bare">https://docs.raku.org/type/Promise.html</a>) 功能。这个例子使用 <code>.lines</code> 将输出分解为行（而不是缓冲区的块），然后轻敲该 [<code>Supply</code>](<a href="https://docs.raku.org/type/Supply.html" class="bare">https://docs.raku.org/type/Supply.html</a>) 以处理进来的行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $proc = Proc::Async.new: &#39;find&#39;, &#39;/&#39;, &#39;-name&#39;, &#39;*.txt&#39;;

$proc.stdout.lines.Supply.tap: { put $++, &#39;: &lt;&#39;, $^line, &#39;&gt;&#39; };
my $promise = $proc.start;

put &#39;Moving on&#39;;

await $promise;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是 [<code>Proc::Async</code>](<a href="https://docs.raku.org/type/Proc::Async.html" class="bare">https://docs.raku.org/type/Proc::Async.html</a>) 的简单使用，但你可以将它与你已经看到的并发功能结合使用。调用 <code>.stdout</code> 可以获得输出行，但只能在调用 <code>.start</code> 之后。在[<code>块</code>](<a href="https://docs.raku.org/type/Block.html)中执行这两个操作：" class="bare">https://docs.raku.org/type/Block.html)中执行这两个操作：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $proc = Proc::Async.new: &#39;find&#39;, &#39;/&#39;, &#39;-name&#39;, &#39;*.txt&#39;;

react {
    whenever $proc.stdout.lines { put $_;  }
    whenever $proc.start        { put &#34;Finished&#34;; done }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.start</code> 返回一个在外部程序完成之前不会保留的 [<code>Promise</code>](<a href="https://docs.raku.org/type/Promise.html)。即使" class="bare">https://docs.raku.org/type/Promise.html)。即使</a> <code>whenever</code> 在程序开始时运行，[<code>Promise</code>](<a href="https://docs.raku.org/type/Promise.html" class="bare">https://docs.raku.org/type/Promise.html</a>) 都不会保留到最后，然后 [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) 就会完成它的工作。</p>
</div>
<div class="paragraph">
<p>练习19.3 实现异步 <strong>find</strong> 程序。修改它，使其在找到你在命令行上指定的文件数后停止。报告找到的文件数。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_8">5.24. 总结</h3>
<div class="paragraph">
<p>你可以运行程序并等待它们的输出或在后台触发它们并在它进入时处理它们的输出。扩展它以处理多个程序，你的程序成为外部资源的精细处理程序。你已经看到了它如何工作的机制，但你可以用它来设计更大更好的东西。
== 高级话题
In such a short book I don’t have enough pages to show you everything that you can do. This chapter is a brief survey of some of the features I would have liked to explain in more detail. You now know these exist and you can investigate them further on your own.</p>
</div>
<div class="paragraph">
<p>在这么短的书中，我没有足够的页面向你展示你可以做的一切。本章简要介绍了一些我希望更详细解释的功能。你现在知道这些存在，你可以自己进一步研究它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="_单行">5.25. 单行</h3>
<div class="paragraph">
<p>You can run <strong>raku</strong> one-liners. These are programs that you compose completely on the command line. The `-e`switch takes an argument that is the program:</p>
</div>
<div class="paragraph">
<p>你可以运行 raku 单行。这些完全是你在命令行上编写的程序。 <code>-e</code> 开关接受一个参数，即程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku -e &#39;put &#34;Hello Raku&#34;&#39;
Hello Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>-n</code> switch runs the program once for each line of input. The current line is in <code>$_</code>. This one uppercases and outputs the line:</p>
</div>
<div class="paragraph">
<p><code>-n</code> 开关为每行输入运行一次程序。当前行是 <code>$_</code>。这个单行大写一行并输出该行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku -n -e &#39;.uc.put&#39; *.pod</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can load a module with <code>-M</code>:</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>-M</code> 加载模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">% raku -MMath::Constants -e &#39;put α&#39;
0.0072973525664</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_declarator_block_comments">5.26. Declarator Block Comments</h3>
<div class="paragraph">
<p>The parser doesn’t discard all comments. It remembers special comments and attaches them to the subroutine. <code><mark>|</mark></code> comments attach themselves to the subroutine after them and <code>=</code> comments attach themselves to the subroutine before them. These comments are available through the <code>.WHY</code> meta-method:</p>
</div>
<div class="paragraph">
<p>解析器不会丢弃所有的注释。它会记住特殊注释并将它们附加到子例程中。 <code><mark>|</mark></code> 注释将它们附加到它们之后的子例程中，并且 <code>=</code> 注释将它们自身附加到它们之前的子例程中。这些注释可通过 <code>.WHY</code> 元方法获得：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| Hamadryas is a sort of butterfly
class Hamadryas {

    #| Flap makes the butterfly go
    method flap () {

        }
    }

Hamadryas.WHY.put;
Hamadryas.^find_method(&#39;flap&#39;).WHY.put;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output is the combination of all the comments attached to that subroutine:</p>
</div>
<div class="paragraph">
<p>输出是附加到该子例程的所有注释的组合：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Hamadryas is a sort of butterfly
Flap makes the butterfly go</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the sort of thing that’s handy in an integrated development environment to grab a description of the thing you are trying to use. It’s also useful when you are debugging something—that is, it’s useful if the developer documented their code.</p>
</div>
<div class="paragraph">
<p>在集成开发环境中，这种方法很方便，可以获取你尝试使用的内容的描述。当你调试某些内容时，它也很有用 - 也就是说，如果开发人员记录了他们的代码，那么它很有用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_feed_operators">5.27. Feed Operators</h3>
<div class="paragraph">
<p>The feed operators decide which way information flows. Here’s a list-processing pipeline that has a <code>.grep</code>, a <code>.sort</code>, and finally a <code>.map</code>. What they do doesn’t matter as much as their order:</p>
</div>
<div class="paragraph">
<p>feed 操作符决定信息的流向。这是一个列表处理管道，它有一个 <code>.grep</code>，一个 <code>.sort</code>，最后一个 <code>.map</code>。他们所做的事与顺序无关紧要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array = @some-array
    .grep( *.chars &gt; 5 )
    .sort( *.fc )
    .map( *.uc )
    ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The final step is farthest away from the assignment. You might not like that. The leftward feed operator allows you to write this in a way where the data flows in one direction. This flows bottom to top into the new variable:</p>
</div>
<div class="paragraph">
<p>最后一步是离赋值最远的。你可能不喜欢那样。向左的 feed 操作符允许你以数据在一个方向上流动的方式编写代码。下面这个从底部到顶部流入新到变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array &lt;==
    map(  *.uc         ) &lt;==
    sort( *.fc         ) &lt;==
    grep( *.chars &gt; 5  ) &lt;==
    @some-array
    ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the assignment operator disappeared because the feed operator took care of that.</p>
</div>
<div class="paragraph">
<p>请注意，赋值运算符已消失，因为 feed 运算符负责处理了。</p>
</div>
<div class="paragraph">
<p>The rightward feed operator goes the other way. The new variable is at the end this time. This is the same thing in the other direction:</p>
</div>
<div class="paragraph">
<p>向右的 feed 操作符走另一条路。这次这个新变量在最后。在另一方向上也是如此：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@some-array
    ==&gt; grep( *.chars &gt; 5  )
    ==&gt; sort( *.fc         )
    ==&gt; map(  *.uc         )
    ==&gt; my @array;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_destructuring_signatures">5.28. Destructuring Signatures</h3>
<div class="paragraph">
<p>You can group parameters with square brackets to create a subsignature. Inside the <code>[]</code> you can break down the aggregate into a smaller signature:</p>
</div>
<div class="paragraph">
<p>你可以使用方括号对参数进行分组以创建子签名。在 `[]`内部，你可以将总体分解为较小的签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub show-the-arguments ( $i, [$j, *@args] ) {  # slurpy
    put &#34;The arguments are i: $i j: $j and @args[]&#34;;
    }

my @a = ( 3, 7, 5 );
show-the-arguments( 1, @a );</code></pre>
</div>
</div>
<div class="paragraph">
<p>With that, <code>$i</code> gets the first parameter and the <code>[]</code> gets the rest. The <code>[]</code> destructures the remaining arguments into <code>$j</code> and <code>@args</code>.</p>
</div>
<div class="paragraph">
<p>有了它，<code>$i</code> 获得第一个参数，<code>[]</code> 获得其余参数。 <code>[]</code> 将剩余的参数解构为 <code>$j</code> 和 <code>@args</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_defining_your_own_operators">5.29. Defining Your Own Operators</h3>
<div class="paragraph">
<p>You can create new operators. Almost all of the things that we call “operators” are methods.</p>
</div>
<div class="paragraph">
<p>The <code>↑</code> and <code>↑↑</code> represent Knuth arrows. These are higher levels of exponentiation:</p>
</div>
<div class="paragraph">
<p>你可以创建新的运算符。几乎所有我们称之为“运算符”的东西都是方法。</p>
</div>
<div class="paragraph">
<p><code>↑</code> 和 <code>↑↑</code> 代表高德纳箭头。这些是更高的取幂水平：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi infix:&lt;↑&gt; ( Int:D \n, Int:D \m  --&gt; Int:D )
    is equiv(&amp;infix:&lt;**&gt;)
    is assoc&lt;right&gt;
    { n ** m }

proto infix:&lt;↑↑&gt; ( Int:D \n, Int:D \m --&gt; Int:D )
    is tighter(&amp;infix:&lt;↑&gt;)
    is assoc&lt;right&gt;
    { * }
multi infix:&lt;↑↑&gt; ( \n,  0 ) { 1 }
multi infix:&lt;↑↑&gt; ( \n,  1 ) { n }
multi infix:&lt;↑↑&gt; ( \n, \m ) { [↑] n xx m }

put 2↑3;  # 2 ** 3 = 8
put 2↑↑3; # 2 ** 2 ** 2 = 2 ** 4 = 16</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the definitions allow you to set traits for precedence and associativity. As with other subroutines these are lexically scoped, so they won’t affect other parts of your program.</p>
</div>
<div class="paragraph">
<p>请注意，这些定义允许你设置优先级和关联性的特征。与其他子例程一样，它们是词法作用域的，因此它们不会影响程序的其他部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="_perl_5_patterns">5.30. Perl 5 Patterns</h3>
<div class="paragraph">
<p>If you like Perl 5 patterns better, or already have some good ones that you’d like to reuse, you can do that. The <code>:Perl5</code> adverb tells the match operator to interpret the pattern as a Perl 5 regular expression:</p>
</div>
<div class="paragraph">
<p>如果你更喜欢 Perl 5 模式，或者已经有一些你想要重用的好模式，你可以这样做。 <code>:Perl5</code> 副词告诉匹配操作符将模式解释为 Perl 5 正则表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $file = ...;
for $file.IO.lines {
    next unless m:Perl5/\A\s+#/;  # no quoting the # in Perl 5
    .put;
    }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_shaped_arrays">5.31. Shaped Arrays</h3>
<div class="paragraph">
<p>Want a multidimensional matrix? You can create a shaped array that knows how wide it is in any dimension. Use the <code>;</code> to separate the dimensions:</p>
</div>
<div class="paragraph">
<p>想要一个多维矩阵？你可以创建一个定形数组，知道它在任何维度上的宽度。使用  <code>;</code> 分开维度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array[2;2];
say @array; # [[(Any) (Any)] [(Any) (Any)]]

@array[1;0] = &#39;Hamadryas&#39;;
say @array; # [[(Any) (Any)] [Hamadryas (Any)]]

my $n = 0;
my $m = 1;

@array[$n;$m] = &#39;Borbo&#39;;
say @array; # [[(Any) Borbo] [Hamadryas (Any)]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can extend this to higher dimensions:</p>
</div>
<div class="paragraph">
<p>你可以将此扩展到更高的维度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array[2;2;3];</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>:shape</code> adverb can describe the size in each dimension:</p>
</div>
<div class="paragraph">
<p><code>:shape</code> 副词可以描述每个维度的大小：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array = Array.new: :shape(3,3);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you set the limits in each dimension the size is fixed. This means that you can create fixed-size one-dimensional arrays. You won’t be able to use operaters that increase or decrease the number of elements:</p>
</div>
<div class="paragraph">
<p>在每个维度中设置限制后，大小就固定了。这意味着你可以创建固定大小的一维数组。你将无法使用增加或减少元素数量的操作符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array[5];</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_typed_containers">5.32. Typed Containers</h3>
<div class="paragraph">
<p>The container types ([<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>), [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>), [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html" class="bare">https://docs.raku.org/type/Hash.html</a>), and so on) can limit their elements to a particular type. There are a few ways that you can constrain these. Consider this example:</p>
</div>
<div class="paragraph">
<p>容器类型（[<code>List</code>](<a href="https://docs.raku.org/type/List.html" class="bare">https://docs.raku.org/type/List.html</a>), [<code>Array</code>](<a href="https://docs.raku.org/type/Array.html" class="bare">https://docs.raku.org/type/Array.html</a>), [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html)等）可以将其元素限制为特定类型。有几种方法可以约束这些。考虑这个例子：" class="bare">https://docs.raku.org/type/Hash.html)等）可以将其元素限制为特定类型。有几种方法可以约束这些。考虑这个例子：</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int @array = 1, 2, 3;
@array.push: &#39;Hamadryas&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since a [<code>Str</code>](<a href="https://docs.raku.org/type/Str.html" class="bare">https://docs.raku.org/type/Str.html</a>) is not an [<code>Int</code>](<a href="https://docs.raku.org/type/Int.html" class="bare">https://docs.raku.org/type/Int.html</a>) the <code>.push</code> fails:</p>
</div>
<div class="paragraph">
<p>由于[<code>字符串</code>](<a href="https://docs.raku.org/type/Str.html)不是"><code>Int</code></a>(<a href="https://docs.raku.org/type/Int.html)，因此" class="bare">https://docs.raku.org/type/Int.html)，因此</a> <code>.push</code> 失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Type check failed in assignment to @array</code></pre>
</div>
</div>
<div class="paragraph">
<p>That form types the <code>@array</code> variable. The type is actually <code>Array[Int]</code>. You can also bind to the object you construct directly:</p>
</div>
<div class="paragraph">
<p>该形式键入 <code>@array</code> 变量。该类型实际上是 <code>Array [Int]</code>。你还可以绑定到直接构造的对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array := Array[Int].new: 1, 3, 7;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can create [<code>Hash</code>](<a href="https://docs.raku.org/type/Hash.html)es" class="bare">https://docs.raku.org/type/Hash.html)es</a> with objects for keys and many other interesting constraints.</p>
</div>
<div class="paragraph">
<p>你可以使用对象创建[<code>散列</code>](<a href="https://docs.raku.org/type/Hash.html)以及许多其他有趣的约束。" class="bare">https://docs.raku.org/type/Hash.html)以及许多其他有趣的约束。</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_nativecall">5.33. NativeCall</h3>
<div class="paragraph">
<p>There’s a builtin foreign function interface named <code>NativeCall</code>. You use the <code>is native</code> trait to specify the external library. This one connects your program to the argumentless <code>flap</code> routine in <strong>libbutterfly</strong>:</p>
</div>
<div class="paragraph">
<p>有一个名为 <code>NativeCall</code> 的内置外部函数接口。你使用 <code>is native</code>  trait 指定外部库。这个程序将你的程序连接到 <code>libbutterfly</code> 中的无参数 <code>flap</code> 例程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;
sub flap() is native(&#39;butterfly&#39;) { * }</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are ways to tell <code>NativeCall</code> how to translate data structures to “native” types and the other way around.</p>
</div>
<div class="paragraph">
<p>有办法告诉 <code>NativeCall</code> 如何将数据结构转换为“原生”类型，反之亦然。</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_with_topicalizer">5.34. The with Topicalizer</h3>
<div class="paragraph">
<p>The <code>with</code> keyword sets the topic. In the postfix form you can use it so you don’t have to repeat a long variable name:</p>
</div>
<div class="paragraph">
<p><code>with</code> 关键字设置主题。你可以在后缀形式中使用它，以使你不必重复长变量名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put &#34;$_ has {.chars}&#34; with $some-very-long-name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s a [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) form that’s similar to <code>if-elsif-else</code> but sets the topic to the result of the condition. Instead of looking for <code>True</code> or <code>False</code> it tests for definedness. In each of these the topic inside the [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) is the result of the respective <code>.index</code>:</p>
</div>
<div class="paragraph">
<p>有一个与 <code>if-elsif-else</code> 类似的 [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) 形式，但将主题设置为条件的结果。它不是寻找 <code>True</code> 或 <code>False</code>，而是测试定义。 [<code>Block</code>](<a href="https://docs.raku.org/type/Block.html" class="bare">https://docs.raku.org/type/Block.html</a>) 里的每个这样的主题是相应的 <code>.index</code> 的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = &#39;Hamadryas&#39;;

  with $s.index: &#39;a&#39; { $s.substr( $_, 2 ).put }
orwith $s.index: &#39;m&#39; { put &#39;Found m&#39; }
orwith $s.index: &#39;H&#39; { fail &#34;Why is there an H at $_?&#34;  }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_结论">6. 结论</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Congratulations. You’ve made it to the end of the book. Some people estimate that only one-third of the readers of a technical book accomplish that feat. This book was only supposed to be 300 pages long, but I couldn’t decide how to leave out anything still included. Sorry about that. The 80 pages of exercise answers really sent me over the limit. If you’re reading this, send me an email noting your rarified status as a completist reader!</p>
</div>
<div class="paragraph">
<p>恭喜。你已经读到了这本书的最后。有些人估计，只有三分之一的技术书籍的读者才能完成这一壮举。这本书应该只有 300 页，但我无法决定如何遗漏任何仍然包含的内容。对于那个很抱歉。 80 页的练习题答案真的让我超过极限。如果你正在读这篇文章，请给我发一封电子邮件，注明你作为一个完整的读者的稀有地位！</p>
</div>
<div class="paragraph">
<p>I wasn’t able to teach you how to be a programmer. I only had the one book. I’ve been at it for several decades and I’m still learning. This book specifically avoided that goal, and I think I’ve succeeded there. Remember that what you’ve seen here to demonstrate and isolate concepts and syntax is not a prescription for good programming practices.</p>
</div>
<div class="paragraph">
<p>我无法教你如何成为一名程序员。我只有一本书。几十年来我一直在这里，我还在学习。这本书专门避免了这个目标，我想我已经成功了。请记住，你在此处所展示的用于演示和隔离概念和语法的内容并不是良好编程实践的处方。</p>
</div>
<div class="paragraph">
<p>I hope you learned the basics of the language and that you can get simple programs to run. If you’re at the start of your programming career, don’t feel bad if you think you are taking longer than you should to get programs working. Writing programs is always the easy part. It’s the debugging work that’s hard. That takes practice. Every time you encounter a new problem you’re adding to the list of things you’ve encountered. Eventually you encounter a problem often enough that you start to subconsciously avoid it. That merely makes space for new sorts of mistakes.</p>
</div>
<div class="paragraph">
<p>我希望你学习了语言的基础知识，并且可以运行简单的程序。如果你正处于编程生涯的开始阶段，如果你认为自己花费的时间超过应该使程序运行的时间，请不要感到难过。编写程序总是很容易的。这是调试工作很难。这需要练习。每次遇到新问题时，你都会添加到你遇到的事物列表中。最终你经常遇到一个问题，你开始下意识地避免它。这只会为新的错误提供空间。</p>
</div>
<div class="paragraph">
<p>You aren’t done learning the language. There’s much more in the documentation. I noted some favorite excluded topics in [Chapter 20](<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch20.html#camelia-advanced" class="bare">https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch20.html#camelia-advanced</a>), but even that was limited. I really wanted to talk more about those, but I couldn’t go past that 500-page barrier. That list isn’t nearly complete. There are so many other things I don’t even mention. Explore those new topics as you become comfortable with what you’ve seen here.</p>
</div>
<div class="paragraph">
<p>你还没有学过这门语言。文档中还有更多内容。我在第20章中注意到了一些最受欢迎的主题，但即使这样也是有限的。我真的想更多地谈论这些，但我无法超越这500页的障碍。该清单并不完整。还有很多其他事我甚至都没提到。当你对这里看到的内容感到满意时，请探索这些新主题。</p>
</div>
<div class="paragraph">
<p>Consider going back to the beginning and reading through the book again. Some of the things will make more sense now that you have a better overview of the major topics. You have more context for the design decisions you dealt with in the first few chapters.</p>
</div>
<div class="paragraph">
<p>考虑回到开头并再次阅读本书。由于你对主要主题有了更好的概述，因此有些事情会更有意义。在前几章中，你有更多关于设计决策的背景信息。</p>
</div>
<div class="paragraph">
<p>Finally, read other books. Don’t limit yourself to one author. I have a particular opinion about some things, and other people have their opinions. Sometimes those are at odds. You don’t have to choose sides. As I write more extensively in <strong>Mastering Perl</strong>, your role is to take the best and most useful ideas from as many people as you can. Synthesize those into something that works in your world and for your tasks. Tell the world what decisions you made and what influenced them. Feed your ideas back into the milieu.</p>
</div>
<div class="paragraph">
<p>最后，阅读其他书籍。不要仅限于一位作者。我对某些事情有一个特别的看法，而其他人有他们的意见。有时这些是不一致的。你不必选择边。正如我在 Mastering Perl 中更广泛地撰写的那样，你的角色是尽可能多地采用最好和最有用的想法。将这些合成为适合你的世界和任务的东西。告诉全世界你做出的决定以及影响他们的因素。把你的想法反馈到环境中。</p>
</div>
</div>
</div>

</article>


    

  </main><section class="site__search">
    <label class="site__form">
        <p class="form__label">Search around the site</p> 
        <input class="site__search-bar form__input" type="text">
    </label>
    <div class="site__search-bar-results"></div>
</section>
  
  <footer class="site__footer">
    
    
    <p class="footer__sign">© 2021 ohmyraku</p></footer>





<script defer type="text/javascript" src="https://ohmyraku.github.io/js/script.14164ab553b19613ce98aadb54b1ed9a89ae5b056c72b99a4c672e37954f33d67bebe1452b0279025ba889964b51bdf8ec69683933cf427ae67c08ac2cdda7b1.js" integrity="sha512-FBZKtVOxlhPOmKrbVLHtmomuWwVscrmaTGcuN5VPM9Z76&#43;FFKwJ5AluoiZZLUb347GloOTPPQnrmfAisLN2nsQ=="></script>



</body>
</html>