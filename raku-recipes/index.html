<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Raku Recipes :: 山川异域, 风月同天</title>

<meta name="author" content="ohmyraku">
<meta name="application-name" content="山川异域, 风月同天">
<meta name="description" content="Table of Contents 1. 输入和输出 1.1. 配方2-1. 读取作为参数处理的文件问题 1.2. 食谱 2-2. 异步读取和处理文件问题 1.3. 配方2-3 连接外部实用程序和文件的输入和输出 1.4. 食谱 2-4. 读取和处理二进制文件问题 1.5. 食谱 2-5. 观看文件的变化问题   2. 数据科学和数据分析 2.1. 配方 3-1. 从多个文件中提取唯一的电子邮件地址/用户名 2.2. 配方 3-2 创建一个加权随机数生成器 2.3. 配方3-3 用电子表格工作、过滤、排序和转换数据 2.4. 配方 3-4. 应用一系列的变换并从中提取数据。 2.5. 配方 3-5. 创建一个随机数据生成器 2.6. 配方 3-6. 处理大的、结构化的文件问题   3. 数学 3.1. 食谱 4-1. 生成数学序列并从中提取随机元素。 3.2. 食谱 4-2. 编程一个分而治之的算法 3.3. 食谱 4-3. 使用矩阵 3.4. 食谱 4-4. 计算 Mandelbrot 集 3.">
<meta name="robots" content="noodp"/>
<meta name="generator" content="Hugo 0.63.2" />
<meta name="referrer" content="no-referrer" />
<meta name="format-detection" content="telephone=no">

<link rel="canonical" href="https://ohmyraku.github.io/raku-recipes/" />


<link rel="icon" href="https://ohmyraku.github.io/logo.png" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Raku Recipes" />
<meta name="twitter:description" content="Table of Contents 1. 输入和输出 1.1. 配方2-1. 读取作为参数处理的文件问题 1.2. 食谱 2-2. 异步读取和处理文件问题 1.3. 配方2-3 连接外部实用程序和文件的输入和输出 1.4. 食谱 2-4. 读取和处理二进制文件问题 1.5. 食谱 2-5. 观看文件的变化问题   2. 数据科学和数据分析 2.1. 配方 3-1. 从多个文件中提取唯一的电子邮件地址/用户名 2.2. 配方 3-2 创建一个加权随机数生成器 2.3. 配方3-3 用电子表格工作、过滤、排序和转换数据 2.4. 配方 3-4. 应用一系列的变换并从中提取数据。 2.5. 配方 3-5. 创建一个随机数据生成器 2.6. 配方 3-6. 处理大的、结构化的文件问题   3. 数学 3.1. 食谱 4-1. 生成数学序列并从中提取随机元素。 3.2. 食谱 4-2. 编程一个分而治之的算法 3.3. 食谱 4-3. 使用矩阵 3.4. 食谱 4-4. 计算 Mandelbrot 集 3." />
<meta name="twitter:site" content="https://ohmyraku.github.io" />
<meta name="twitter:creator" content="ohmyraku" />
<meta name="twitter:image" content="https://ohmyraku.github.io/logo.png">
<meta property="og:type" content="article" />
<meta property="og:locale" content="en" />
<meta property="og:name" content="ohmyraku" />
<meta property="og:title" content="Raku Recipes" />
<meta property="og:url" content="https://ohmyraku.github.io" />
<meta property="og:site_name" content="山川异域, 风月同天" />
<meta property="og:description" content="Table of Contents 1. 输入和输出 1.1. 配方2-1. 读取作为参数处理的文件问题 1.2. 食谱 2-2. 异步读取和处理文件问题 1.3. 配方2-3 连接外部实用程序和文件的输入和输出 1.4. 食谱 2-4. 读取和处理二进制文件问题 1.5. 食谱 2-5. 观看文件的变化问题   2. 数据科学和数据分析 2.1. 配方 3-1. 从多个文件中提取唯一的电子邮件地址/用户名 2.2. 配方 3-2 创建一个加权随机数生成器 2.3. 配方3-3 用电子表格工作、过滤、排序和转换数据 2.4. 配方 3-4. 应用一系列的变换并从中提取数据。 2.5. 配方 3-5. 创建一个随机数据生成器 2.6. 配方 3-6. 处理大的、结构化的文件问题   3. 数学 3.1. 食谱 4-1. 生成数学序列并从中提取随机元素。 3.2. 食谱 4-2. 编程一个分而治之的算法 3.3. 食谱 4-3. 使用矩阵 3.4. 食谱 4-4. 计算 Mandelbrot 集 3." />
<script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "Article",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https:\/\/ohmyraku.github.io\/raku-recipes\/"
      },
      "headline": "Raku Recipes",
      
      "datePublished": "2020-10-16",
      "dateModified": "2020-10-16 22:51:52 \x2b0800 CST",
      "author": {
        "@type": "Person",
        "name": "ohmyraku"
      },
      "description": "Table of Contents 1. 输入和输出 1.1. 配方2-1. 读取作为参数处理的文件问题 1.2. 食谱 2-2. 异步读取和处理文件问题 1.3. 配方2-3 连接外部实用程序和文件的输入和输出 1.4. 食谱 2-4. 读取和处理二进制文件问题 1.5. 食谱 2-5. 观看文件的变化问题   2. 数据科学和数据分析 2.1. 配方 3-1. 从多个文件中提取唯一的电子邮件地址\/用户名 2.2. 配方 3-2 创建一个加权随机数生成器 2.3. 配方3-3 用电子表格工作、过滤、排序和转换数据 2.4. 配方 3-4. 应用一系列的变换并从中提取数据。 2.5. 配方 3-5. 创建一个随机数据生成器 2.6. 配方 3-6. 处理大的、结构化的文件问题   3. 数学 3.1. 食谱 4-1. 生成数学序列并从中提取随机元素。 3.2. 食谱 4-2. 编程一个分而治之的算法 3.3. 食谱 4-3. 使用矩阵 3.4. 食谱 4-4. 计算 Mandelbrot 集 3.",
      "publisher": {
        "@type": "Organization",
        "name": "https:\/\/ohmyraku.github.io",
        "logo": {
          "@type": "ImageObject",
          "url": "https:\/\/ohmyraku.github.io\/logo.png"
        }
      }
    }
</script><link rel="stylesheet" href="https://ohmyraku.github.io/scss/main.min.84f71d25d375c522a861bb4719728ce6839cf3635b15ca0c7a1b4d799c2dc3399a1d6cb46058a9d8fdbebe9156a8857279cfdeb70aa3862e629de234b5a41fa1.css" integrity="sha512-hPcdJdN1xSKoYbtHGXKM5oOc82NbFcoMehtNeZwtwzmaHWy0YFip2P2&#43;vpFWqIVyec/etwqjhi5ineI0taQfoQ==">
<script>

const theme = window.localStorage.getItem('theme'); 
if (theme && theme !== "1") {
    document.documentElement.classList.add('theme-' + theme);
}
</script>


</head>
<body>
  <main class="site__content">
    <div class="site__page">
  <nav class="site__breadcrumbs">
    <a class="site__breadcrumb" href="https://ohmyraku.github.io/">山川异域, 风月同天</a><a class="site__breadcrumb--active" href="https://ohmyraku.github.io/raku-recipes/">Raku Recipes</a>
</nav>

<h1 class="page__title">Raku Recipes</h1>
  <div class="page__meta">
    <p>
    
    <span class="page__date">
    on <time datetime="2020-10-16T22:51:52&#43;08:00">2020-10-16</time>
    
    </span>
    </p>

    

    
    </div>
</div>


</div>

<article class="page__content" ><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_输入和输出">1. 输入和输出</a>
<ul class="sectlevel2">
<li><a href="#_配方2_1_读取作为参数处理的文件问题">1.1. 配方2-1. 读取作为参数处理的文件问题</a></li>
<li><a href="#_食谱_2_2_异步读取和处理文件问题">1.2. 食谱 2-2. 异步读取和处理文件问题</a></li>
<li><a href="#_配方2_3_连接外部实用程序和文件的输入和输出">1.3. 配方2-3 连接外部实用程序和文件的输入和输出</a></li>
<li><a href="#_食谱_2_4_读取和处理二进制文件问题">1.4. 食谱 2-4. 读取和处理二进制文件问题</a></li>
<li><a href="#_食谱_2_5_观看文件的变化问题">1.5. 食谱 2-5. 观看文件的变化问题</a></li>
</ul>
</li>
<li><a href="#_数据科学和数据分析">2. 数据科学和数据分析</a>
<ul class="sectlevel2">
<li><a href="#_配方_3_1_从多个文件中提取唯一的电子邮件地址用户名">2.1. 配方 3-1. 从多个文件中提取唯一的电子邮件地址/用户名</a></li>
<li><a href="#_配方_3_2_创建一个加权随机数生成器">2.2. 配方 3-2 创建一个加权随机数生成器</a></li>
<li><a href="#_配方3_3_用电子表格工作过滤排序和转换数据">2.3. 配方3-3 用电子表格工作、过滤、排序和转换数据</a></li>
<li><a href="#_配方_3_4_应用一系列的变换并从中提取数据">2.4. 配方 3-4. 应用一系列的变换并从中提取数据。</a></li>
<li><a href="#_配方_3_5_创建一个随机数据生成器">2.5. 配方 3-5. 创建一个随机数据生成器</a></li>
<li><a href="#_配方_3_6_处理大的结构化的文件问题">2.6. 配方 3-6. 处理大的、结构化的文件问题</a></li>
</ul>
</li>
<li><a href="#_数学">3. 数学</a>
<ul class="sectlevel2">
<li><a href="#_食谱_4_1_生成数学序列并从中提取随机元素">3.1. 食谱 4-1. 生成数学序列并从中提取随机元素。</a></li>
<li><a href="#_食谱_4_2_编程一个分而治之的算法">3.2. 食谱 4-2. 编程一个分而治之的算法</a></li>
<li><a href="#_食谱_4_3_使用矩阵">3.3. 食谱 4-3. 使用矩阵</a></li>
<li><a href="#_食谱_4_4_计算_mandelbrot_集">3.4. 食谱 4-4. 计算 Mandelbrot 集</a></li>
<li><a href="#_食谱_4_5_充分利用整数的无限精确性">3.5. 食谱 4-5. 充分利用整数的无限精确性</a></li>
</ul>
</li>
<li><a href="#_配置和执行程序">4. 配置和执行程序</a>
<ul class="sectlevel2">
<li><a href="#_食谱_5_1_使用_jsonyaml_ini_文件配置程序">4.1. 食谱 5-1. 使用 JSON/YAML/.ini 文件配置程序</a></li>
<li><a href="#_食谱_5_3_在程序中使用_shell_环境变量">4.2. 食谱 5-3. 在程序中使用 Shell 环境变量</a></li>
<li><a href="#_食谱_5_4_为应用程序创建一个_docker_容器以便轻松地分发它">4.3. 食谱 5-4. 为应用程序创建一个 Docker 容器，以便轻松地分发它</a></li>
<li><a href="#_食谱_5_5_使用_etcd_进行高级分布式配置">4.4. 食谱 5-5. 使用 etcd 进行高级/分布式配置</a></li>
</ul>
</li>
<li><a href="#_自动化系统任务">5. 自动化系统任务</a>
<ul class="sectlevel2">
<li><a href="#_食谱_6_1_检查某些事件的日志">5.1. 食谱 6-1. 检查某些事件的日志</a></li>
<li><a href="#_食谱_6_2_在控制台上交互式检查日志">5.2. 食谱 6-2. 在控制台上交互式检查日志</a></li>
<li><a href="#_食谱_6_3_检查_git_提交的模式和元数据或将它们存储起来">5.3. 食谱 6-3. 检查 Git 提交的模式和元数据，或将它们存储起来</a></li>
<li><a href="#_食谱6_4_清理你的_docker_镜像商店问题">5.4. 食谱6-4. 清理你的 Docker 镜像商店问题</a></li>
<li><a href="#_食谱_6_5_处理最后一个登录你系统的人">5.5. 食谱 6-5. 处理最后一个登录你系统的人</a></li>
</ul>
</li>
<li><a href="#_处理错误">6. 处理错误</a>
<ul class="sectlevel2">
<li><a href="#_食谱_8_1_设计一个异常层次结构">6.1. 食谱 8-1. 设计一个异常层次结构</a></li>
<li><a href="#_食谱_8_2_向用户传递有意义的错误信息">6.2. 食谱 8-2. 向用户传递有意义的错误信息</a></li>
<li><a href="#_食谱_8_4_在_comma_ide_中调试你的应用程序">6.3. 食谱 8-4 在 Comma IDE 中调试你的应用程序</a></li>
<li><a href="#_食谱_8_5_用漂亮的错误让它们大方地失败从而调试_grammar">6.4. 食谱 8-5. 用漂亮的错误让它们大方地失败，从而调试 Grammar</a></li>
</ul>
</li>
<li><a href="#_客户端_web_和_api">7. 客户端 Web 和 API</a>
<ul class="sectlevel2">
<li><a href="#_食谱_9_1_查询_geoip_数据库">7.1. 食谱 9-1. 查询 GeoIP 数据库</a></li>
<li><a href="#_食谱_9_2_从网站下载和提取信息">7.2. 食谱 9-2. 从网站下载和提取信息</a></li>
<li><a href="#_食谱_9_3_使用_web_api_从网站获取信息">7.3. 食谱 9-3. 使用 Web API 从网站获取信息</a></li>
<li><a href="#_食谱_9_4_通过查询互联网服务来检查ip和地址">7.4. 食谱 9-4. 通过查询互联网服务来检查IP和地址。</a></li>
</ul>
</li>
<li><a href="#_文本处理">8. 文本处理</a>
<ul class="sectlevel2">
<li><a href="#_食谱_10_1_scrape_markdown_文档">8.1. 食谱 10-1. Scrape Markdown 文档</a></li>
<li><a href="#_食谱_10_2_生成一组静态网页">8.2. 食谱 10-2. 生成一组静态网页</a></li>
<li><a href="#_食谱_10_3_创建一个词典并在上面进行快速搜索">8.3. 食谱 10-3. 创建一个词典并在上面进行快速搜索</a></li>
<li><a href="#_食谱_10_4_计算纯文本文档的差异">8.4. 食谱 10-4 计算纯文本文档的差异</a></li>
</ul>
</li>
<li><a href="#_微服务">9. 微服务</a>
<ul class="sectlevel2">
<li><a href="#_菜谱_11_1_创建一个微服务问题">9.1. 菜谱 11-1. 创建一个微服务问题</a></li>
<li><a href="#_食谱_11_2_使用_web_套接字连接到客户端">9.2. 食谱 11-2. 使用 Web 套接字连接到客户端。</a></li>
<li><a href="#_食谱_11_3_为诸如_telegram_这样的消息应用程序创建一个迷你机器人">9.3. 食谱 11-3. 为诸如 Telegram 这样的消息应用程序创建一个迷你机器人</a></li>
<li><a href="#_问题_33">9.4. 问题</a></li>
<li><a href="#_食谱_11_4_测试你的微服务问题">9.5. 食谱 11-4. 测试你的微服务问题</a></li>
<li><a href="#_食谱_11_5_应对_web_hooks_问题">9.6. 食谱 11-5. 应对 Web Hooks 问题</a></li>
</ul>
</li>
<li><a href="#_创建桌面应用">10. 创建桌面应用</a>
<ul class="sectlevel2">
<li><a href="#_食谱_13_1_使用全控制台_ui">10.1. 食谱 13-1. 使用全控制台 UI</a></li>
<li><a href="#_食谱_13_2_创建一个使用系统_windows_的应用程序">10.2. 食谱 13-2 创建一个使用系统 Windows 的应用程序</a></li>
<li><a href="#_食谱_13_3_创建一个小游戏">10.3. 食谱 13-3. 创建一个小游戏</a></li>
</ul>
</li>
<li><a href="#_加快处理速度">11. 加快处理速度</a>
<ul class="sectlevel2">
<li><a href="#_配方_15_1_使用带_hyperrace_的数据并行">11.1. 配方 15-1. 使用带 Hyper/Race 的数据并行</a></li>
<li><a href="#_配方15_2_使用异步输入输出">11.2. 配方15-2. 使用异步输入/输出</a></li>
<li><a href="#_食谱_15_3_使用通道和线程使你的程序并发执行">11.3. 食谱 15-3. 使用通道和线程使你的程序并发执行</a></li>
<li><a href="#_使用_comma_ide_监控并发">11.4. 使用 Comma IDE 监控并发</a></li>
<li><a href="#_配方15_5_创建强大的并发程序问题">11.5. 配方15-5. 创建强大的并发程序问题</a></li>
</ul>
</li>
<li><a href="#_有趣的单行程序">12. 有趣的单行程序</a>
<ul class="sectlevel2">
<li><a href="#_食谱_17_1_用单行代码写一个猜谜游戏">12.1. 食谱 17-1. 用单行代码写一个猜谜游戏</a></li>
<li><a href="#_食谱_17_2_使用单行计算序列中的第n个元素">12.2. 食谱 17-2. 使用单行计算序列中的第n个元素。</a></li>
<li><a href="#_食谱_17_3_使用单行代码重复执行系统管理任务">12.3. 食谱 17-3. 使用单行代码重复执行系统管理任务</a></li>
</ul>
</li>
<li><a href="#_术语">13. 术语</a>
<ul class="sectlevel2">
<li><a href="#_dator">13.1. Dator</a></li>
<li><a href="#_distrodistribution">13.2. Distro/Distribution</a></li>
<li><a href="#_grammarole">13.3. Grammarole</a></li>
<li><a href="#_hyperrace">13.4. Hyper/Race</a></li>
<li><a href="#_punning">13.5. Punning</a></li>
<li><a href="#_rakuish">13.6. Rakuish</a></li>
<li><a href="#_rocket_operator">13.7. Rocket Operator</a></li>
<li><a href="#_routingine">13.8. Routingine</a></li>
<li><a href="#_token">13.9. Token</a></li>
<li><a href="#_websocker">13.10. Websocker</a></li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_输入和输出">1. 输入和输出</h2>
<div class="sectionbody">
<div class="paragraph">
<p>大多数程序需要与文件系统和网络交互，以获取数据并产生结果。输入/输出例程和类，或简称I/O，将这些功能分组。在本章中，我们包括几个配方，它们将帮助你以不同的方式处理不同种类的文件。</p>
</div>
<div class="sect2">
<h3 id="_配方2_1_读取作为参数处理的文件问题">1.1. 配方2-1. 读取作为参数处理的文件问题</h3>
<div class="paragraph">
<p>你需要处理一系列的文件，但你事先并不知道你要处理哪些文件，所以最好是脚本能处理你提供的作为参数的文件。</p>
</div>
<div class="sect3">
<h4 id="_解决办法">1.1.1. 解决办法</h4>
<div class="paragraph">
<p>动态变量 <code>$*ARGFILES</code> 是一个伪文件的别名，其中包括所有在命令行中提供的文件。在你的脚本中使用它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的">1.1.2. 它是如何工作的</h4>
<div class="paragraph">
<p>你需要计算你的菜谱网站的权重，也就是那里的总句数。或者，你需要按目录来计算这个数字。无论哪种方式，都是你需要对一组文件进行的操作，它会对文件的内容进行统一处理。因此，让我们创建一个脚本，打印句子的数量（用句号隔开，或者双行分隔符，就像标题一样）。</p>
</div>
<div class="paragraph">
<p>事实上，只需一行代码就可以完成。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "Sentences → ", $*ARGFILES.lines.join("\n") .split( / [ '.' | \v**2 ] / ).elems;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$<strong>ARGFILES</code> 的行为是一个单一的文件句柄，其中的文件已经打开。你不需要担心依次打开或关闭每一个文件句柄；只要你用一个文件列表来调用脚本，Raku 就会整理它们，并使它们在这个单一变量下可用。你可以对这个文件进行不同的操作，比如逐行读取。这允许你使用任何你想要的东西来整理行，例如，回车。<code>split</code> 使用的正则表达式会用一个句号('.')或两个垂直的空格(<code>\v *</strong> 2</code>)来分割结果的字符串。</p>
</div>
<div class="paragraph">
<p>例如，你可以这样运行这个脚本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">perl6 Chapter-2/count-sentences.p6 recipes/desserts/*.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>而且它会返回5作为目前版本库中的版本。</p>
</div>
<div class="paragraph">
<p>注意: 我也鼓励你从 Comma 运行这个脚本，至少要习惯它。在这种情况下，它是一个单一的文件，没有太多的调试，但多行脚本和更复杂的模块将真正受益于 Comma 提供的工具和提示。如果你想这样做，你必须包含一个配置，并附上脚本名称和工作目录（例如仓库的顶部）。唯一需要考虑的是，Comma 不理解 globs。所以，作为脚本参数，你将不得不充实文件的名称，这样：<code>recipes/desserts/buckwheat-pudding.md recipes/desserts/guacustard.md</code>。</p>
</div>
<div class="paragraph">
<p>其实，这相当于这样做。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "Sentences → ", $*ARGFILES.slurp.split( / [ '.' | \v**2 ] / ).elems;</code></pre>
</div>
</div>
<div class="paragraph">
<p>文件集被简单地吞噬，也就是说，整个吞噬成一个单一的字符串，包括回车。通过行分离，然后使用你喜欢的任何方式连接，可以让你有更多的灵活性；例如，你可能想消除作为标题的行。上面的分割表达式可能会产生空的"句子"（例如，如果句号后面有两个垂直空格），此外，我们还想消除标题（以#开头）。这个版本可以解决这个问题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "Sentences → ", $*ARGFILES.lines.grep( /^&lt;:L&gt;/ ) .join("\n").split( / [ '.' | \v**2 ] / ).elems;</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过使用 grep 只选择那些以字母 (<code>&lt;:L&gt;</code>) 开头的行，我们将删除以哈希标记开头的标题、空行 (前提是没有以空格开头的行和后面跟着任何其他字母的行，我们将注意不使用这些字母) 和标题。剩下的就是以字母开头的行了。但是，可能有一些情况下，在一个章节或文件的结尾处有空行，我们可能忘了在那里加一个句号来结束一个句子。我们会将其也标记为句子的结尾，这也就解释了分割中的双垂直空格。最后，我们计算创建的数组的元素数量，这将表示句子的数量。</p>
</div>
<div class="paragraph">
<p>该脚本在处理单个文件而不是多个文件时的效果是一样的。如果你想单独查找和处理文件，当然可以这样做。在接下来的配方中，我们将看到如何异步处理它们。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_2_2_异步读取和处理文件问题">1.2. 食谱 2-2. 异步读取和处理文件问题</h3>
<div class="paragraph">
<p>您需要在不阻止程序的情况下读取未知大小的文件。</p>
</div>
<div class="sect3">
<h4 id="_解决办法_2">1.2.1. 解决办法</h4>
<div class="paragraph">
<p>Raku 包含了许多异步操作的设施，您既可以使用异步输入/输出，也可以使用 <code>tap</code> 进行事件驱动的操作。您既可以使用异步输入/输出，也可以使用 <code>tap</code> 进行事件驱动操作。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_2">1.2.2. 它是如何工作的</h4>
<div class="paragraph">
<p>异步编程是一种强大的，即使不完全是流行的，也是一种处理任务的方式，其持续时间是事先不知道的。同步程序启动任务，而程序的其他部分则等待该任务的完成。当需要及时给出响应时，这种行为是相当不方便的，比如在网络上。</p>
</div>
<div class="paragraph">
<p>异步编程从 JavaScript 开始流行起来。JavaScript 最初是为 Web 界面设计的，它的工作原理是按顺序处理事件，但不会阻塞 UI。当基于服务器的版本 Node 被创建时，这种行为扩展到所有类型的事件。解释器运行一个事件循环，一些任务创建事件和回调，当事件被激活时就会被调用。</p>
</div>
<div class="paragraph">
<p>这在输入/输出中是相当方便的。不需要同步等待整个文件被读取，而是启动一个读取任务，当该任务完成后，调用一个回调函数。读取工作在后台进行，而程序的其他部分则由自己处理其他事情，或者创建其他事件，这些事件将被依次处理。</p>
</div>
<div class="paragraph">
<p>假设你需要检查菜谱数据库中的所有文件，然后对它们进行一些操作，比如像我们在上一章所做的那样提取它们的标题。这些文件可能有不同的大小，或者在文件系统中的不同深度，这意味着如果其中一个文件的时间比平常长，所有的操作都会被延迟。</p>
</div>
<div class="paragraph">
<p>使用这个脚本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Text::Markdown;
sub MAIN( $dir = '.' ) {
    my @promises = do for tree( $dir ).List.flat -&gt; $f {
        start extract-titles( $f )
    }
    my @results = await @promises;
    say "Recipes ⇒\n\t", @results.map( *.chomp).join: "\t";
}

sub tree( $dir ) {
    my @files = gather for dir($dir) -&gt; $f {
        if ( $f.IO.f ) {
            take $f
        } else {
            take tree($f);
        }
    }
    return @files;
}

sub extract-titles ( $f ) {
    my @titles;
    if $f.IO.e {
        my $md = parse-markdown($f[0].slurp);
        @titles = $md.document.items
            .grep( Text::Markdown::Heading )
            .grep( { $_.level == 1 } );
    }
    @titles;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>树形例程，也就是我们之前使用的那个，以递归方式在目录上运行，以收集所有文件，这应该不会花费太多时间，尽管我们也可以异步运行这部分，甚至并行运行。这应该不会花很长时间，尽管我们也可以异步运行这部分，甚至是并行运行。我们将以异步方式做的是打开，然后处理文件的内容。</p>
</div>
<div class="paragraph">
<p>程序的主要部分运行在文件列表上，并为每个文件创建一个承诺。<code>start</code> 命令正是这样做的。它从作为参数的块中创建一个承诺。在 Raku 中，<code>for</code> 循环会返回每一次迭代的最后一句话的结果列表。这里的单句 <code>start</code> 将返回一个承诺；我们将这个承诺数组分配给一个变量，有效地称为 <code>@promises</code>。</p>
</div>
<div class="paragraph">
<p>在每个承诺中，都有一个普通的 vanilla 代码块，用来检查文件的存在（谁知道呢，它可能在从树例程出来的路上消失了，安全起见总是好的）。块不能使用 <code>return</code> 关键字，但它们会返回最后一条语句产生的任何内容。所以那个承诺，完成后会被保留，会返回那个值。</p>
</div>
<div class="paragraph">
<p>但是，这个值暂时没有分配给任何东西。它存储在承诺中，但在承诺真正被保留之前，你不会知道它的价值。<code>await</code> 语句正是这样做的：它等到其参数中的所有承诺都被履行，并返回它们的值；<code>@results</code> 将包含这些值，然后在下一步中以同步的方式打印出来。</p>
</div>
<div class="paragraph">
<p>这样读取文件的速度会比同步读取文件的速度略快到明显。增加的速度将取决于文件的大小和每个文件需要处理的数量。但是脚本中还有一部分不是异步的。我们不妨使用供应品一路异步。</p>
</div>
<div class="paragraph">
<p><code>supply</code> 是一个可以异步填充和选取的对象序列，总是按照填充的顺序来。你向一个 <code>supply</code> 发射来填充它，并从它那里敲击来使用它的值。这些敲击的好处是它们可以异步发生，而且一个 supply 可以有任意多的 <code>tap</code>。看看这个脚本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN( $dir = '.' ) {
    my $supply = supply tree-emit( $dir );
    my @titles = gather {
        $supply.tap( -&gt; $f { take $f.IO.lines.head } )
    };
    say "Recipes ⇒\n", @titles.join("\n");
}

sub tree-emit( $dir ) {
    for dir($dir) -&gt; $f {
        if ( $f.IO.f ) {
            emit $f
        } else {
            tree-emit($f);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它递归地深入到目录中，每找到一个文件就发出一个文件名。由于树状发射例程是在供应中调用的，所以供应将收集所有的文件名，而用 <code>$supply.tap</code> 调用的 <code>tap</code> 将获得每个文件的第一行，并将其收集在数组中。但供应块内的代码不会被运行，直到它被真正的 <code>tap</code>。把 <code>supply</code> 不看作是缓冲区，而是看作是一个任务列表，在绝对需要之前不会运行。如果我们对脚本进行这样的改动。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN( $dir = '.' ) {
    my $supply = supply tree-emit( $dir );
    say "Now let's rock";
    my @titles = gather {
        $supply.tap( -&gt; $f { take $f.IO.slurp.lines.head } )
    };
    say "Recipes ⇒\n", @titles.join("\n");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果将按此顺序打印。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Now let's rock
Let's emit recipes/main/rice/tuna-risotto.md
(and the rest of the files)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种操作风格也被称为反应式编程；抽头依次对供应中的每个对象做出反应。这是一种高效的I/O工作方式，因为它将减少循环产生的开销。许多现代语言 - 从 Node.js 到 Dart 再到最新 3.x 版本的 Python - 都使用这种反应式操作来处理从简单的文件I/O到服务于 Web 页面和其他服务的一切。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配方2_3_连接外部实用程序和文件的输入和输出">1.3. 配方2-3 连接外部实用程序和文件的输入和输出</h3>
<div class="sect3">
<h4 id="_问题">1.3.1. 问题</h4>
<div class="paragraph">
<p>你需要运行一个外部程序并处理它的输出，或者反过来说，你需要向一个外部程序提供文本以处理它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方法">1.3.2. 解决方法</h4>
<div class="paragraph">
<p><code>Proc::Async</code> 类提供了各种与外部交互式命令行程序接口的设施。</p>
</div>
</div>
<div class="sect3">
<h4 id="_如何工作">1.3.3. 如何工作</h4>
<div class="paragraph">
<p>一旦奠定了异步工作的基础，你就可以用它来做各种事情。你可以与文件和其他程序进行交互，这些程序以未知的时间间隔发出文本。想一想系统日志或其他类型的程序，它们会不时地附加到文件中。例如，这个脚本会对整个系统中运行的进程进行快照，并将它们追加到一个文件中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">watch "ps -e | tail --lines=+2 &gt;&gt; /tmp/ps.log"</code></pre>
</div>
</div>
<div class="paragraph">
<p>文件会是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">28485 ?       00:00:03 kworker/u8:0
28821 ?       00:00:19 gimp-2.8
28829 ?       00:00:01 script-fu
30976 ?       00:00:00 docker
31001 ?       00:00:00 containerd-shim
31029 pts/0   00:00:00 sh
31189 pts/4   00:00:02 zsh</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个基本结构，包括每行的最后两个元素，命令运行的时间和实际语句的缩写。</p>
</div>
<div class="paragraph">
<p>这个程序将监控这个文件并对其采取行动。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $proc = Proc::Async.new: 'tail', '-f', '/tmp/ps.log';
$proc.stdout.tap(-&gt; $v {
    $v ~~ m:g/([\d+] ** 3 % ':') \s+ (\S+)/;
    with $/ {
        for $_.list -&gt; $match {
            my $command = $match[1];
            my $time = $match[0];
            given $command {
                when .contains("sh") {
                    say "Running shell $command for $time"
                }
                when none( "watch", "ps", "tail" ) { say "Seen $command" }
            }
        }
    }
});

say "Listening to /tmp/ps.log";
await $proc.start;
say "Finished";</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然有点长，但其结构很简单。首先，创建异步连接，然后设置监视器，最后运行实际的进程，也是异步的。</p>
</div>
<div class="paragraph">
<p>正如解决方案中所指出的，Proc::Async 是驱动所有这些交互的类；它的文档在 <a href="https://docs.raku.org/type/Proc::Async。我们在第一行中使用它，创建一个要运行" class="bare">https://docs.raku.org/type/Proc::Async。我们在第一行中使用它，创建一个要运行</a> <code>tail -f /tmp/ps.log</code> 的进程。我们需要以这种方式分割它，以保护它不被 shell 逃逸。继续到脚本的最后一部分，我们通过启动进程创建一个承诺，并使用 <code>await</code> 等待承诺的完成。实际上，这永远不会发生，因为 <code>tail -f</code> 会一直运行，直到它被打断。</p>
</div>
<div class="paragraph">
<p>但是异步处理是在中间完成的。就像我们在前面的配方中所做的那样，我们使用 taps。<code>Proc::Async</code> 会从每个进程句柄中创建供应：标准输入或 <code>stdin</code>，标准输出或 <code>stdout</code>，以及标准错误。我们只对 <code>stdout</code> 感兴趣，所以这就是我们敲击的供应。我们通过一个正则表达式来运行每一行。<code>([dd+] ** 3 % ':'</code> 部分是三组一到多个数字的集合。这就是它的运行时间。第二部分只是命令的开头。圆括号捕捉内容，只有当有实际捕捉到的内容时，我们才运行循环（用 <code>$/</code>）。<code>$<em></code> 将等于 <code>$/</code>（因为用 topicalizes，使得 <code>$</em></code> 等于其表达式）。</p>
</div>
<div class="paragraph">
<p>正如你可以想象的那样，把这个连接到另一个程序的输入上，也会以同样的方式工作。例如，你可以运行一个程序，并将其输出连接到另一个程序的输入。例如，要计算资源库中的食谱（是 Markdown 文件）的数量，我们使用这个。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $find-proc = Proc::Async.new: 'find', @*ARGS[0] // "recipes", "-name", "*.md";
my $wc-proc = Proc::Async.new: 'wc';

$wc-proc.bind-stdin: $find-proc.stdout;
$wc-proc.stdout.tap( { $_.print } );

my $wc = $wc-proc.start;
my $find = $find-proc.start;
await $wc, $find;
say "✓ Finished"</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序使用两个异步进程。我们将从 <code>find</code> 进程中读取信息，它使用UNIX命令行实用程序来查找文件系统中的文件。它把起始目录作为第一个参数，并从那里开始深入，直到检查完所有的子目录。我们将使用一个命令行参数，但默认情况下，它将使用 <code>recipes</code> 作为顶级目录。</p>
</div>
<div class="paragraph">
<p>第二个过程是另一个计算字数的命令行工具。它产生的行是这样的。</p>
</div>
<div class="paragraph">
<p>6 6 209</p>
</div>
<div class="paragraph">
<p>它显示的是字数(6)、行数(6)和总字符数(209)。由于第一个程序每行会产生一个文件，所以前两个数字是一样的。</p>
</div>
<div class="paragraph">
<p>下一行使用 <code>bind-stdin</code> 来连接 <code>wc</code> 工具的输入和 <code>find</code> 工具的输出，就像你做了以下的操作（在 UNIX/Linux 中）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">find recipes -name "*.md" -print | wc</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能知道，管道符号|连接左边的输出和右边的输入。Raku 会通过编程来完成，而且效率很高。一旦这样做了，你就可以点击 wc 进程的供给，它将打印输出。</p>
</div>
<div class="paragraph">
<p>由于我们现在有两个进程，你必须等待，直到两个承诺都实现，你在程序的下一行到最后一行做。</p>
</div>
<div class="paragraph">
<p>这些管道可以随你的需要而复杂化；例如，你可以将输出绑定到几个输入，并创建连接不同的、现成的实用程序的胶水脚本。</p>
</div>
<div class="paragraph">
<p>这些脚本也可以在 MacOS 和 Windows 的 Linux 子系统中工作，以及在 Windows 的不同 bash 命令行中工作。然而，在这种情况下，我们使用 PowerShell 命令。在任何情况下，Raku 将使用任何可用的操作系统设施来运行您启动的命令。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_2_4_读取和处理二进制文件问题">1.4. 食谱 2-4. 读取和处理二进制文件问题</h3>
<div class="paragraph">
<p>您需要处理二进制文件，如图像或视频。</p>
</div>
<div class="sect3">
<h4 id="_解决办法_3">1.4.1. 解决办法</h4>
<div class="paragraph">
<p>用任何文件读取命令都可以读取二进制文件。然而，它的内容需要存储在被称为 blobs 的特殊数据结构中，根据格式的不同，也会有 Raku 模块可以处理它们；例如，图像或声音文件的模块。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_3">1.4.2. 它是如何工作的</h4>
<div class="paragraph">
<p>假设你在你的菜谱网站上存储了一系列的图片，你需要在提供这些图片之前检查它们的大小，以便缩小它们的尺寸，使其适应特定的屏幕，或者其他什么。无论如何，你需要知道图片的宽度和高度。</p>
</div>
<div class="paragraph">
<p>这是存储在文件中的两块数据，它们是文件头的一部分。它们是文件头的一部分。被称为 EXIF 读取器的专业工具能够收集这些数据，以及与相机设置相关的所有其他数据，甚至在某些情况下收集GPS数据。让我们保持简单，只用 Raku 获得宽度和高度。这个程序就可以做到这一点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Blob $image = slurp( @*ARGS[0] // "../recipes-images/rice.jpg", :bin);
# From here https://stackoverflow.com/a/43313299/891440 by user6096479
my $index = 0;
until $image[$index] == 255 and $image[$index+1] == any( 0xC0, 0xC2 ) {
    $index++;
    last if $index &gt; $image.elems;
}

if ( $index &lt; $image.elems ) {
   say "Height ", $image[$index+5]*256 + $image[$index+6];
   say "Width ", $image[$index+7]*256 + $image[$index+8];
} else {
    die "JPG metadata not found, damaged file or wrong file format";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管它有很多数字，但它归结为这些步骤：获取数据（二进制形式），寻找一个标记（表示数据开始的文件块），然后获取数据并打印出来。让我们把这个过程分解一下。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先，我们用一个 blob 来存储文件的二进制内容；<code>slurp</code> 会返回一个 <code>blob</code>，如果它的选项是 <code>:bin</code>，就像二进制一样。一个 <code>blob</code> 基本上是一个字节列表（实际上是 <code>uint8</code>，用8位表示的无符号整数）。<code>until</code> 循环探索直到找到该段的标记：一个价值为 FF 的十六进制字节，或 255，然后是另一个价值为 <code>C0</code> 或 <code>C2</code> 的十六进制字节。</p>
</li>
<li>
<p>当找到该标记时，高度存储在第五和第六个字节的两个字节中，我们将第一个字节乘以256转换成十进制。宽度存储在接下来的两个字节中，我们以完全相同的方式将其转换为十进制。</p>
</li>
<li>
<p>如果在命令行中发出一个已经损坏或具有任何其他格式的文件，这些标记将不会被发现。循环将结束，脚本将以错误信息退出。
如果你需要从这些图像中获取更多的信息，或者只是将它们以自相同的形式存储在其他地方，那么 <code>blobs</code> 就是最好的方式。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_2_5_观看文件的变化问题">1.5. 食谱 2-5. 观看文件的变化问题</h3>
<div class="paragraph">
<p>你需要检查一个文件或目录是否有任何变化。</p>
</div>
<div class="sect3">
<h4 id="_解决办法_4">1.5.1. 解决办法</h4>
<div class="paragraph">
<p>使用 <code>IO::Notification.watch-path</code>，它将返回一个你可以点击检查或以其他方式行动的供应，它将具有 <code>IO::Notification::Change</code> 对象的形状。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_4">1.5.2. 它是如何工作的</h4>
<div class="paragraph">
<p>你已经看到了异步代码在 Raku 中的工作方式。一般来说，它观察一系列事件，并在事件发生时运行一些代码。</p>
</div>
<div class="paragraph">
<p>在本章之前的配方中，其他代码都会生成事件。然而，系统本身也会一直在低水平上生成事件，我们只要接入这个流，就可以对它们进行处理。我说的是 <code>tap</code> 吗？好吧，我们在 Raku 里有 <code>tap</code>，不是吗？所以，你可以直接写一个程序，挖掘相应文件或目录中的变化所产生的事件流（或供应）。</p>
</div>
<div class="paragraph">
<p>例如，假设我们需要检查是否有新的配方被添加到文件系统中的配方集合中，或者是否对它们做了什么。我们可以在添加了新的菜谱之后，运行一些检查，或者在没有包含西兰花的菜谱被删除的时候发出警报（如果包含西兰花的话，完全是合理的）。让我们用这个脚本来实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $dir = @*ARGS[0] // 'recipes';
my $dir-watch-supply= IO::Notification.watch-path($dir);

$dir-watch-supply.tap: -&gt; $change {
    given $change.event {
        when FileChanged { say "{$change.path} has changed"}
        when FileRenamed {
            say "{$change.path} has been renamed, deleted or created"
        }
    }
};
await Promise.in(30).then: { say "Finished watch"; };</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如配方的解决方案中所指出的，我们使用方便的 <code>IO::Notification</code> Raku 类来检查配方目录。这个类包括一个单一的方法， <code>watch-path</code>，它以一个代表要监视的路径的字符串作为参数。这个方法会产生一个供应，我们可以有效地对其进行敲击。</p>
</div>
<div class="paragraph">
<p>敲击将产生变化事件，这些变化事件是 <code>IO::Notification::Change</code> 类的对象，它有两个属性：事件的类型，即是否被 FileChanged（例如，改变了大小）或 FileRenamed（包括创建或删除，以及实际的重命名），以及路径。这就是为什么我们要检查 <code>$change.event</code> 的值，根据类型来调整涉及路径的消息。</p>
</div>
<div class="paragraph">
<p>然而，供应只是创建了一个事件流，当其中一个事件产生时，一个 <code>tap</code> 就会异步运行。不过，我们需要一些东西来等待事件的发生。我们需要一个事件循环，允许脚本继续执行，直到满足某个条件。这就是最后一条语句的作用。它创建了一个承诺，在30秒后保留；实际上，这是一个等待循环，它将存在30秒，之后脚本将结束。</p>
</div>
<div class="paragraph">
<p>注意: 很有可能 <code>tap</code> 产生的消息会被保存在一个缓冲区中，并在程序结束时全部打印出来。这也是为什么这类事件循环必须优雅地退出的原因，这样所有的缓冲区都会被刷新，事件和它们产生的消息也不会丢失。</p>
</div>
<div class="paragraph">
<p>这样做的问题是，事件循环不可能永远进行下去。它将观察30秒；然后，它将不得不再次重新启动以捕捉新的变化。这最终可能会变得很烦人；一个手表应该一直在观察。下一个脚本将做到这一点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $dir = @*ARGS[0] // 'recipes';
my $dir-watch-supply= $dir.IO.watch;
my $ctrl-c = Promise.new;
$dir-watch-supply.tap: -&gt; $change {
    given $change.event {
        when FileChanged { say "{$change.path} has changed"}
        when FileRenamed {
            say "{$change.path} has been renamed, deleted or created"
        }
    }
};
signal(SIGINT).tap( { say "Exiting"; $ctrl-c.keep } );
await $ctrl-c;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个脚本为文件监视使用了另一种形式，从字符串中创建了一个 <code>IO::Path</code>，并将监视放在它上面。然而，这并不是主要的变化。接下来创建了一个新的、实际上是空的许诺；我们称它为 <code>$ctrl-c</code>，因为这就是它要做的事情。检查tap是完全一样的，但它在这之后就发生了变化。</p>
</div>
<div class="paragraph">
<p>首先，我们设置了一个关于 SIGINT 信号供应的 <code>tap</code>。SIGINT 是按 <code>Ctrl+C</code> 时调用的系统信号。我们可以捕获该信号并对其采取行动，在这种情况下，我们将打印一条消息，表明我们正在优雅地退出应用程序，然后我们遵守承诺，到目前为止还没有实现。由于程序将一直等待，直到该承诺被遵守，这就是下一条语句所做的事情，它将有效地退出，冲洗输出缓冲区，一般做正确的事情退出程序。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_数据科学和数据分析">2. 数据科学和数据分析</h2>
<div class="sectionbody">
<div class="paragraph">
<p>脚本(和其他)语言是很好的资源，可以将数据从一种格式获取到另一种格式，或者对已经被捣毁的数据进行操作。数据科学指的是数据收集、数据混杂，并执行操作以产生结果；数据分析不太面向数学，指的是对数据进行简单的聚合或执行单个操作。</p>
</div>
<div class="paragraph">
<p>一些编程范式，如函数式编程，用于处理这类任务。由于 Raku 的多范式性质及其广泛的原生函数集，它独特地适用于这类任务，我们将在本章中看到。</p>
</div>
<div class="sect2">
<h3 id="_配方_3_1_从多个文件中提取唯一的电子邮件地址用户名">2.1. 配方 3-1. 从多个文件中提取唯一的电子邮件地址/用户名</h3>
<div class="sect3">
<h4 id="_问题_2">2.1.1. 问题</h4>
<div class="paragraph">
<p>对于一组存在于三个文件中的电子邮件地址，您需要确定哪些邮件地址在三个文件中重复，反之，哪些邮件只在其中一个文件中唯一出现。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方法_2">2.1.2. 解决方法</h4>
<div class="paragraph">
<p>使用集合运算来确定所有文件之间的交集，或两个文件之间的差集。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_5">2.1.3. 它是如何工作的</h4>
<div class="paragraph">
<p>您决定在您的菜谱网站上建立一个每月新菜谱的通讯。系统以文件的形式收集新的地址，一行一个地址。不幸的是，只是临时使用文件，而不是一个适当的通讯应用程序，可以很容易地管理这一切。办公室里的每个人都会保存他们在前几周收到的电子邮件地址。随着新的登录驱动器的出现，你最终会收到许多不同的电子邮件。这些人往往对不同版本的通讯感兴趣（只发甜点，只发素食，等等）。你决定创建一个核心的电子邮件地址列表，以接收所有的新闻邮件。你可以通过所有不同的文件创建者来确定哪些人注册了所有不同的版本。</p>
</div>
<div class="paragraph">
<p>这些文件将被这样列出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">one@ema.il
another@electron.ic
yetan@oth.er</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;等等。一行一个。这个脚本可以帮你做到这一点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [∩] do for dir( @*ARGS[0] // "emails", test =&gt; /txt$/ ) -&gt; $f {
    $f.lines;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这基本上是一行的工作，所以让我们把它分开。本质上，这个脚本只是从一个目录中读取名字以 .txt 结尾的文件，将它们按行划分，创建一个 list-of-lists，并对这个 list-of-lists 应用一个还原运算符。这个还原运算符依次抽取每一个成员，计算交集，并将结果与列表中的下一个列表相交。</p>
</div>
<div class="paragraph">
<p>让我们从下到上，从右到左来分解这个表达式。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>$f.lines</code> 会创建一个邮件地址的列表，这些邮件地址被放在不同的行上。<code>slurp</code> 方法将读取一整个文件。其结果将被返回。</p>
</li>
<li>
<p><code>$f</code> 将包含一个 <code>IO::Path</code>，它将被用作循环变量。</p>
</li>
<li>
<p>循环将在 <code>dir</code> 返回的列表上运行；这个命令将检查命令行中作为第一个参数传递的目录(<code>@*ARGS[0]`</code>)，如果没有定义(<code>//</code>)，则检查 "emails"。目录中可能还有其他文件，所以我们只得到那些名字以txt结尾的文件（<code>/txt$/</code>）。这是一个正则表达式，原则上你可以使用任何表达式来过滤文件。事实上，test可以是任何类型的测试，包括文件权限或类型测试。我们将在一个以该名称命名的目录上使用它，该目录包括几个文件 <code>--email-(1,2,3).txt--</code> 这就是为什么我们使用该模式进行过滤。</p>
</li>
<li>
<p>我们在 <code>for</code> 前面使用 <code>do</code>，它将 <code>for</code> 放在一个创建列表的上下文中。这将用每次迭代的结果创建一个列表，在我们的例子中，这也是一个列表（每个文件中的电子邮件）。</p>
</li>
<li>
<p>在前面，列表换算超运算符 <code>[]</code>，应用到交集运算符 <code>[∩]</code>；这些之所以被称为 hyper，是因为它们需要一个底层运算符来工作，结合它们的语义。在这种情况下，它结合了交集运算符的语义和 <code>[]</code> 超运算符的应用在序列到列表的语义。Raku 支持许多 Unicode 数学运算符及其隐含的语义，但要确定如何在特定的编辑器或操作系统中键入它们并不容易。每一个运算符都有一个 ASCII 码(读：容易输入)对应的符号，通常是一些用括号包围的符号。在这种情况下，它是 <code>(&amp;)</code> (记忆法则：<code>&amp;</code> 表示和;交集选择那些在一个集合和另一个集合中的元素)。还原是一种常见的列表操作，对列表中的前两个项目依次应用一个运算符，然后对第三个元素进行运算，以此类推。所以在本例中，对于三个文件，它要做的是 <code>(@list[0] ∩ @list[1]) ∩ @list[2]</code>。使用换算超运算符意味着我们不需要事先知道一个列表中有多少项。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这最终导致了一个非常紧凑的脚本，可以从命令行运行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku -e 'say [∩] do .slurp.lines for dir( @*ARGS[0] // "emails", test =&gt; /txt$/ );'</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将循环体移到 <code>for</code> 前面，并取消循环占位符变量，从而进一步减少循环体。我们要做一个简单的改变，将出现在一个文件中的邮件提取出来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku -e 'say [(-)] do .slurp.lines for dir( @*ARGS[0] // "emails", test =&gt; /txt$/ );'</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>(-)</code>(ASCII 等价物)或 <code>⊖</code> 是差集运算符。Raku 的一个优点是它能够在集合上使用这些类型的运算符。集合不仅适用于数学计算，它们也有很好的商业用途，如这两个例子所示。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配方_3_2_创建一个加权随机数生成器">2.2. 配方 3-2 创建一个加权随机数生成器</h3>
<div class="sect3">
<h4 id="_问题_3">2.2.1. 问题</h4>
<div class="paragraph">
<p>我们需要创造一个作弊的轮盘赌或装模作样的骰子，以产生比别人更大的概率的中奖号码。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方法_3">2.2.2. 解决方法</h4>
<div class="paragraph">
<p>使用 <code>Mixes</code>。这个数据结构是一个带有权重的集合，集合中元素的权重可以用来"加载"结果，相对于其他元素。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_6">2.2.3. 它是如何工作的</h4>
<div class="paragraph">
<p>混合料是不同元素的集合，每一个元素都有一个权重分配给它。例如，我们想通过投掷一个模子来生成新的食谱，模子中的元素和原料一样多，但我们也想考虑到我们对一些原料的偏好。比如我们可以加载洋葱，卸载大蒜，用这个小程序来创建一个我们要使用的食材列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $ingredients = ( rice =&gt; 1, chickpeas =&gt; 1,
                    onion =&gt; 2, tomatoes =&gt; 1,
                    garlic =&gt; 0.5, pasta =&gt; 1,
                    chestnut =&gt; 0.25, bellpeppers =&gt; 1).Mix;

for ^10 {
    say "New recipe ⇒ ", $ingredients.roll( 5 ).unique.join(", ");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mixs 本质上是具有实值的哈希或关联数组，这就是为什么我们通过创建那种哈希并对其调用 <code>.Mix</code> 来声明它们。</p>
</div>
<div class="paragraph">
<p>这个配方没有更多的内容。Mixs 正是为这种事情而创建的。我们是把洋葱装上，把大蒜和栗子卸下（如果不是当季的栗子很贵，也不怎么好）。我们实际上是把那个装好的骰子掷了五次，它将以（相对）概率产生我们需要的食材。那次掷骰子会创建一个五种元素的列表，我们提取其中独特的成分（这会使一些配方变得更短）。最后，我们打印整个事情，结果是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">New recipe ⇒ chickpeas, onion
New recipe ⇒ pasta, bellpeppers, tomatoes, onion
New recipe ⇒ onion, rice, pasta
New recipe ⇒ bellpeppers, onion
New recipe ⇒ bellpeppers, onion, chickpeas, pasta, garlic
New recipe ⇒ onion, chestnut, tomatoes, garlic
New recipe ⇒ tomatoes, onion, rice
New recipe ⇒ tomatoes, onion, garlic, pasta
New recipe ⇒ onion, rice, tomatoes
New recipe ⇒ onion, pasta, rice, bellpeppers</code></pre>
</div>
</div>
<div class="paragraph">
<p>洋葱多，这应该是意料之中的事，栗子不多。这显然是随机的，有些时候它要从出现两次的食谱中剔除，但装模作样的地方还是很明显的。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配方3_3_用电子表格工作过滤排序和转换数据">2.3. 配方3-3 用电子表格工作、过滤、排序和转换数据</h3>
<div class="sect3">
<h4 id="_问题_4">2.3.1. 问题</h4>
<div class="paragraph">
<p>我们需要访问 Excel 电子表格中包含的数据。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_5">2.3.2. 解决办法</h4>
<div class="paragraph">
<p>生态系统中有一个工作模块 Parser::FreeXL::Native，可以直接读取电子表格。如果电子表格已经以基于文本的 CSV 格式保存，则可以直接或通过 Text::CSV 模块进行读取和解析。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_7">2.3.3. 它是如何工作的</h4>
<div class="paragraph">
<p>企业将结构化数据保存在电子表格中是很正常的，Excel 格式很广泛，可以由微软 Office 产品以及 LibreOffice 等开源应用和 Google Suite 等在线应用制作和读取。这些电子表格中的数据是以行和列的形式分布的，所以很容易输入，也很容易在上面制作图表或应用操作。</p>
</div>
<div class="paragraph">
<p>你已经收到了一个电子表格，里面有你将要使用的食材的卡路里数据。</p>
</div>
<div class="paragraph">
<p>请注意，事实上，像 FDa 这样的政府组织一直在制作含有有用营养信息的电子表格。然而，我们将在这里使用的电子表格是专门为此目的而创建的。</p>
</div>
<div class="paragraph">
<p>我们将使用的电子表格如图3-1所示。它将有三栏，分别是成分的名称（我们将用它作为键）、显示卡路里的单位和卡路里。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Ingredient Unit    Calories
Rice       100g    130
Chickpeas  100g    364
Lentils    100g    116
Egg        Unit    78
Apple      Unit    52
Beer       ⅓ liter 216
Tuna       100g    130</code></pre>
</div>
</div>
<div class="paragraph">
<p>图3-1. 成分数据库样本</p>
</div>
<div class="paragraph">
<p>你需要读取这些信息，包含在一个 <code>calories.xls</code> 文件中，并计算出一道美味的金枪鱼烩饭的热量。这个脚本可以做到这一点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use Parser::FreeXL::Native;

my %ingredients = %( Rice =&gt; g =&gt; 350,
                     Tuna =&gt;  g =&gt; 400 ,
                     Cheese =&gt; g =&gt; 200 );

my Parser::FreeXL::Native $xl-er .= new;

$xl-er.open("data/calories.xls");
$xl-er.select_sheet(0);

my $total-calories = 0;
for 1..^$xl-er.sheet_dimensions[0] -&gt; $r {
    my $ingredient = $xl-er.get_cell($r,0).value;
    if %ingredients{$ingredient} {
       my ($q, $unit )= extract-measure($xl-er.get_cell($r,1).value);
       if %ingredients{$ingredient}.key eq $unit  {
	   $total-calories += $xl-er.get_cell($r,2).value
	                   * %ingredients{$ingredient}.value / $q;
       }
   }
}

say "Total calories ⇒ $total-calories";

sub extract-measure( $str ) {
    $str ~~ /^^ $&lt;q&gt; = ( &lt;:N&gt;* ) \s* $&lt;unit&gt;=(\w+)/;
    my $value = val( ~$&lt;q&gt; ) // unival( $&lt;q&gt; );
    return ($value,~$&lt;unit&gt;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了运行这个程序，你需要安装它所使用的模块，通过以下方式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install Parser::FreeXL::Native</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个本地模块。这意味着它为一个编译的共享库提供了一个 Raku 前台，在这种情况下，它被称为 FreeXL。这个库可以通过通常的安装命令（在 Ubuntu 的情况下）安装在 Linux 或 Windows 的 Linux 子系统中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">sudo apt install libfreexl-dev</code></pre>
</div>
</div>
<div class="paragraph">
<p>你应该按照通常的程序在 MacOS 或 Windows 中安装它。</p>
</div>
<div class="paragraph">
<p>这是 Raku 的一个很好的功能；NativeCall 接口提供了一个简单的方法来包装本地库，这样你就可以通过一个自然的 Raku 接口在你的程序中利用它们。</p>
</div>
<div class="paragraph">
<p>这个脚本有两个不同的部分：第一个部分读取电子表格中的数值，第二个部分将使用这些数值来计算菜品中的卡路里，其成分、用于衡量它们的单位和数量都包含在 <code>%ingredients</code> 变量中。这个变量用一对来表示数量，这对变量的键将是单位（本例中是克），值将是单位数。在本例中，350个大米，400个金枪鱼，200个奶酪。这对你来说可能有点多，但我的家人喜欢吃奶酪。</p>
</div>
<div class="paragraph">
<p>第一部分从电子表格中读取数值：它读取文件，选择其中唯一的一张表（索引=0），然后开始运行行。它从第二行开始（索引=1），因为第0行只包含页眉。</p>
</div>
<div class="paragraph">
<p>第二部分是一个循环，在电子表格的行上运行，其索引将进入 <code>$r</code> 变量。</p>
</div>
<div class="paragraph">
<p>regex，也就是从第二列（索引1）中提取计量单位和数量的正则表达式（有时复数写成 regexen）有点棘手，这就是为什么我们把它们放在一个单独的 <code>extract-measures</code> 例程中。但我们需要知道卡路里是如何计算的，这是一种方便的确定方式。正则表达式的名声很不好，但是一旦你了解了它们的要领，它们对于那种任务&#8212;&#8203;从有一点结构的文本中获取数据&#8212;&#8203;是非常好的。</p>
</div>
<div class="paragraph">
<p>让我们试着理解一下正则表达式。对于这些成分，它说的是100克这样的东西，这意味着我们测量每100克的卡路里（这是通常的方式）。但我们需要将其分解为度量单位（100）和单位（g）。首先，我们通过 <code>^^</code> 将 regex 固定在字符串的开头。紧接着，一个数字，如果存在，将表示度量单位。我们通过 <code>(&lt;:N&gt;*)</code> 来表达，星号意味着，在某些情况下，比如当它简单地表示 Unit 时，它将不存在。括号用于 捕获结果。请注意，我们在这里使用的是 <code>&lt;:N&gt;</code>，而不是更熟悉的 <code>\d</code>: Unicode 属性。在我们的测量集合中，我们有一个 ⅓（对于啤酒来说，这接近于半品脱，这也是我们在西班牙测量啤酒的方式之一，un tercio），这将不匹配 <code>\d</code>，所以我们使用一个字符类描述来覆盖它。然后，单位将被一些空格隔开（或不隔开）（因此又是*），并将是一个或多个"字"（<code>\w</code>）字符的集合。</p>
</div>
<div class="paragraph">
<p>对于我们感兴趣的三个成分，该 regex 将得到100这个数字进入 <code>$&lt;q&gt;</code> 变量，g 进入 <code>$&lt;unit&gt;</code> 变量。使用角括号的变量可以在正则表达式内定义和分配，也可以在正则表达式外使用，就像我们在定义的例程中做的那样。然而，<code>$&lt;q&gt;</code> 需要额外的处理，再次感谢 el tercio。通常将字符串转换为数字的例程不能直接处理它们，它们只能处理数字字面，如 3、2.3e7，或 ASCII 版本的分数 1/3。事实上，这个脚本中的任何成分都不会发生这种情况，但这并不意味着我们不应该考虑到这种情况。</p>
</div>
<div class="paragraph">
<p>注意: 我们本可以使用这种形状，比如 1/3，来表达我们表格中的小数.然而，这将在正则表达式中产生一系列其他问题。所以，我们还是不要这样做了。</p>
</div>
<div class="paragraph">
<p>如果我们在一个只包含 "⅓" 的字符串上使用 <code>val</code>，就会返回失败。但失败是 nils 的伪装，所以我们利用这个事实给 <code>$value</code> 赋值。如果用 <code>val</code> 转换失败，将对其应用 <code>unival</code>，返回数值，这就是我们返回的内容。</p>
</div>
<div class="paragraph">
<p>该例程将返回两个值的列表：用于测量卡路里的数量和单位。第一个可以是一个空字符串。</p>
</div>
<div class="paragraph">
<p>一旦数据从电子表格中提取出来，我们就需要添加它。循环的行是这样做的：首先我们获取原料的名称，这是电子表格中的第一列。只有当该原料在我们的菜品中时，我们才会继续进行；只有这样，我们才会使用正则表达式来提取计量和单位。然后，如果单位与我们的食材列表中的单位相同，我们就根据食材的重量（在本例中）进行操作，计算卡路里的数量。</p>
</div>
<div class="paragraph">
<p>这里的结果将是高达1231卡路里。不过不用担心，因为这是为四个人准备的食谱。如果你想的话，你甚至可以在奶酪上大做文章，只是会增加一些卡路里。</p>
</div>
<div class="paragraph">
<p>正如解决方案中所评论的那样，我们也可以使用另一种模块读取CSV文件。具有相同信息的CSV文件是一个文本文件，看起来像这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Ingredient;Unit;Calories
Rice;100g;130
Chickpeas;100g;364
Lentils;100g;116
Egg;Unit;78
Apple;Unit;52
Beer;⅓ liter;216
Tuna;100g;130
Cheese;100g;128</code></pre>
</div>
</div>
<div class="paragraph">
<p>分号作为分隔符，每行有一行。这个脚本将读取并打印文件的内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Text::CSV;
say csv(in =&gt; "data/calories.csv",  sep =&gt; ';', headers =&gt; "auto" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>你需要先安装 Text::CSV，但正如你所看到的，这只是一条语句。除了文件名之外，我们还指定了要使用的分隔符（如果不是默认的逗号的话），并且通过自动标题选项，我们让它自动为每一行创建一个哈希，使用标题作为键。例如，第一行将变成。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">{Calories =&gt; 130, Ingredient =&gt; Rice, Unit =&gt; 100g}</code></pre>
</div>
</div>
<div class="paragraph">
<p>CSV 是一种格式，与 JSON 和其他数据序列化方法一样，在数据科学中被广泛使用。我们将在下一个配方中再来讨论它。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配方_3_4_应用一系列的变换并从中提取数据">2.4. 配方 3-4. 应用一系列的变换并从中提取数据。</h3>
<div class="sect3">
<h4 id="_问题_5">2.4.1. 问题</h4>
<div class="paragraph">
<p>你有数据存储在一个数组列表中，你想对该数据应用一个或几个变换，包括处理或过滤，然后提取一个数量。例如，假设您想计算一组菜品的总卡路里数，然后排除那些卡路里数超过1000的菜品。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方法_4">2.4.2. 解决方法</h4>
<div class="paragraph">
<p>这种操作称为 <code>map</code>/<code>reduce</code>。在 Raku 中，有几个 map 操作符，包括 <code>map</code> 本身，和 <code>reduce</code> 操作符，可以使用超运算符从二元（<code>infix</code>）操作符建立。此外，feed 操作符允许您创建一个单一的操作链，可以很容易地被视觉识别。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_8">2.4.3. 它是如何工作的</h4>
<div class="paragraph">
<p>映射/还原是一种功能操作，即首先将一个列表中的元素映射到另一个列表中（通过任何形式的操作和/或过滤），然后对结果进行操作，给出一个单一的、还原的结果。</p>
</div>
<div class="paragraph">
<p>也就是说，我们最初有这样的东西。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">a1,a2,...,an ==&gt; b1,b2,...,bn ==&gt; c1,c2,...,cm</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，在不同的 map 阶段后，通过这样的方式换算。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">((c1 op c2) op c3).... op cm) ==&gt; X</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku-map 和 grep 中，主要有两个函数做 map 部分。我们之前已经遇到过它们。由于它们会产生另一个列表，所以可以简单地将它们作为一个方法应用到前一个操作的结果上，从而进行链式连接。这在视觉上可能会让人感到困惑，所以 Raku 也使用 feed 操作符 <code>=&#8658;</code>（也叫火箭）作为这种（链式）map 操作的语法糖。</p>
</div>
<div class="paragraph">
<p>例如，我们要处理带有卡路里数据的 CSV 文件，并产生一个只包含非奶制品成分的单一 map。然后我们稍后会参考该 map 来计算菜品中的卡路里。你可以这样做。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use Text::CSV;

my %calories = csv(in =&gt; "data/calories.csv",  sep =&gt; ';', headers =&gt; "auto", key =&gt; "Ingredient" );

%calories.keys
    ==&gt; map( { %calories{$_}&lt;Ingredient&gt;:delete } )
    ==&gt; grep( { %calories{$_}&lt;Dairy&gt; eq 'No'} )
    ==&gt; my @non-dairy-ingredients;

%calories.keys
    ==&gt; map( { %calories{$_}&lt;Dairy&gt;:delete } );

say %calories{ @non-dairy-ingredients}.map: { parse-measure( $_&lt;Unit&gt; ) };

sub parse-measure ( $description ) {
    $description ~~ / $&lt;unit&gt;=(&lt;:N&gt;*) \s* $&lt;measure&gt;=(\S+) /;
    my $unit = $&lt;unit&gt; // 1;
    return ($unit,$&lt;measure&gt;);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，读取 CSV 文件的方式是，我们没有一个哈希数组，而是有一个哈希数列，列用 key 表示。
在这个脚本中，我们有两个 map 链。第一个 map 链工作在卡路里表的键上，卡路里表是一个数组，所以它最终会返回一个数组。它将首先删除 Ingredient 键，我们已经知道它是哈希的键。它其实并不影响输出，但会改变卡路里表的方面。然后用 grep 只选择那些非奶制品的成分。在下一步，我们也从卡路里表中删除 Dairy 键，因为我们知道那些被选中的是非奶制品。</p>
</div>
<div class="paragraph">
<p>最终，我们产生一个卡路里表中使用的单位和度量单位的列表。我们稍稍改变了之前使用的 regex，它只能够捕捉数字。由于我们用 ⅓ 升来衡量啤酒，所以我们需要一些具有 Unicode 属性 "N" 的东西也来捕捉它。我们稍后将在下一个脚本中使用这个子程序。</p>
</div>
<div class="paragraph">
<p>这个脚本的目的是作为一个热身，并作为下一个脚本的介绍，它实际上解决了这个问题。它将从文件中读取菜谱成分明细，添加每道菜的热量，只过滤那些热量低于1600卡路里的菜（即每人400卡路里，这是合理的），并添加该数量。这个程序会做到这一切。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use Text::CSV;

csv(in =&gt; "data/calories.csv",  sep =&gt; ';', headers =&gt; "auto", key =&gt; "Ingredient" ).pairs
    ==&gt; map( {
       $_.value&lt;Ingredient&gt;:delete;
       $_.value&lt;parsed-measures&gt; = parse-measure( $_.value&lt;Unit&gt; );
       $_ } )
    ==&gt; my %calories;

my @recipes;
for dir("data/recipes/", test =&gt; /\.csv$/) -&gt; $r {
    my %data = csv(in =&gt; $r.path, headers =&gt; "auto", key =&gt; "Ingredient").pairs
      ==&gt; map( { $_.value&lt;Ingredient&gt;:delete; $_; } );
    push @recipes: %data;

}

say qq:to/END/;
Your non-caloric recipes add up to
{[+] (@recipes ==&gt; map( { get-calories( $_ ) } ) ==&gt; grep( * &lt; 1600 ) )}
calories
END

sub parse-measure ( $description ) {
    $description ~~ / $&lt;unit&gt;=(&lt;:N&gt;*) \s* $&lt;measure&gt;=(\S+) /;
    my $unit = +$&lt;unit&gt;??+$&lt;unit&gt;!!1;
    return ($unit,~$&lt;measure&gt;);
}

sub get-calories( %recipe ) {
    my $total-calories = 0;
    for %recipe.keys -&gt; $i {
        if %recipe{$i}&lt;Unit&gt; eq %calories{$i}&lt;parsed-measures&gt;[1] {
            $total-calories +=
            %calories{$i}&lt;Calories&gt; * %recipe{$i}&lt;Quantity&gt; / %calories{$i}&lt;parsed-measures&gt;[0]
        }
    }
    $total-calories;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是迄今为止最长的脚本，即使我们去掉解析子，也是如此。但它在概念上很简单：它读取卡路里表并将其放入一个名为 <code>%calories</code> 的关联数组中，读取食谱并将其放入一个名为 <code>@recipes</code> 的数组中，然后用一句话将食谱映射到它们的卡路里，选择那些少于1600卡路里的食谱，并将它们统计成一个单一的数字。</p>
</div>
<div class="paragraph">
<p>计算卡路里的子也和我们之前见过的子非常相似，所以我们只关注脚本中段的map/reduce操作。先说地图部分。<code>@recipes =&#8658; map( { get-calories( $_ ) } )</code> 将包含配方成分（和数量）的关联数组映射（或转换）为一个数字列表。这个数字列表将在下一阶段通过 grep 进行过滤： <code>=&#8658; grep( * &lt; 1600 ) )</code>。只有几个食谱，我们现在对其名称不感兴趣，有这个数量。这些食谱的卡路里将在 reduce 阶段加入，也就是图链开头的 <code>[+]</code>。这是用大括号包裹起来的，以便在插入输出字符串之前对其进行评估，它使用了 heredocs 语法，以避免一点混乱。<code>qq:to/END/</code> 是一个引号结构，双 q 保证里面的任何表达式都会被评估，END 表示将在字符串的最后发布的标记。</p>
</div>
<div class="paragraph">
<p>一般来说，使用 map/reduce 可以为你省去很多嵌套循环，可以让你以函数的方式处理数据。如果你的数据很多，甚至可以使用 <code>hyper</code> 或 <code>race</code> 进行并行化。所以用这种方式来思考数据流是一个双赢的命题。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配方_3_5_创建一个随机数据生成器">2.5. 配方 3-5. 创建一个随机数据生成器</h3>
<div class="sect3">
<h4 id="_问题_6">2.5.1. 问题</h4>
<div class="paragraph">
<p>为了测试和其他目的，我们需要一个随机数据生成器来生成合适的数据结构。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_6">2.5.2. 解决办法</h4>
<div class="paragraph">
<p>使用 <code>pick</code>，它是特定于类的，并适用于许多不同的数据结构。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_9">2.5.3. 它是如何工作的</h4>
<div class="paragraph">
<p>在处理有标签的数据时，有时需要创建可以作为建议的组合，例如用于测试算法或仅仅作为最终结果。这种数据需要具有某种结构；例如，遵循某种正则表达式的字符串或一组项目，每一个项目都具有某种质量。</p>
</div>
<div class="paragraph">
<p>例如，你可能需要为你的菜谱随机生成菜品。大多数菜品都会有一个主料（比如说，米饭）和一个额外的副料（比如说，鹰嘴豆）。什么？鹰嘴豆和米饭是一道美味的地中海菜肴，和加勒比海各地的豆子和米饭一样。在餐桌上的所有食材中，我们可以将它们混合搭配，生成新的菜肴。让我们把食材表改成这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Ingredient;Unit;Calories;Dairy;Vegan;Main;Side
Rice;100g;130;No;Yes;Yes;Yes
Chickpeas;100g;364;No;Yes;Yes;Yes
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们在保存数据的CSV中添加了两列： 主列和副列表示该原料是否可以作为主原料使用，或者添加到主原料中，以生成一个完整的菜品。</p>
</div>
<div class="paragraph">
<p>现在你要做的是生成一个有主料和副料的菜。这个脚本可以帮助你完成这个任务。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use Raku::Recipes;

my %calories-table = calories-table;

my @main-course = %calories-table.keys.grep: { %calories-table{$_}&lt;Main&gt; eq 'Yes' };
my @side-dish = %calories-table.keys.grep: { %calories-table{$_}&lt;Side&gt; eq 'Yes' };

say "Your recipe ⇒ ", @main-course.pick, " with ", @side-dish.pick, " on the side";</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们创建了 <code>Raku::Recipes</code>，用于我们在几个食谱中不断使用的所有实用例程；在这种情况下，我们将使用 <code>calories-table</code>（我们之前已经使用过几次），这个例程读取CSV，解析每个成分的措施描述，并将所有内容放入哈希中。</p>
</div>
<div class="paragraph">
<p>注意：这个模块在本书的 Github 网站和 apress 网站上都有，用 Git 下载后（git pull JJ/raku-recipes-apress），或者从 apress 提供的 Url 下载后，改到下载的目录下，写上 <code>zef install .</code>。</p>
</div>
<div class="paragraph">
<p>我们只用食材的名称：作为主菜的就放到 <code>@main-course</code>，副菜就放到 <code>@side-dish</code>。我们在表的键上使用一个过滤器，只选择那些相应字段（主菜或副菜）标记为 Yes 的键（食材）。</p>
</div>
<div class="paragraph">
<p>随机生成，之后就直接了当了：我们在两个数组上使用 <code>pick</code>，从每个数组中随机选择一个成分。这样就会打印出这样的结果。</p>
</div>
<div class="paragraph">
<p>Your recipe ⇒ Pasta with Chickpeas on the side</p>
</div>
<div class="paragraph">
<p>这都是好的，但面食在这两个阵列中。一盘面食配上面条，就有点不伦不类了。接下来我们就尽量避免这种情况吧。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given (@main-course X @side-dish).grep( { @_[0] ne @_[1] } ).pick {
    say "Your recipe → @_[0] with ", lc( @_[1] ), " on the side"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这两个数组的定义方式完全相同。然而，我们使用 <code>grep</code> 过滤器只得到具有不同配料的配料对。<code>@main-course X @side-dish</code> 将创建一个构成菜品的配料对的列表，grep检查第一种和第二种配料是否不同，所以得到的列表将只有合适的配料对。通过使用 <code>given</code>，我们将这对食材放入话题变量 <code>@_</code> 中。最后，我们在生成的（保证的）配料对数组中进行挑选；我们使用 <code>lc</code> 将第二个配料对小写，以避免在句子中间出现大写字母。</p>
</div>
<div class="paragraph">
<p>我们使用 <code>given</code> 是因为它是一个 topicalizing 语句，也就是说，它把它的参数放到一个合适的主题变量中，<code>$<em></code>、<code>%</em></code> 或 <code>@<em></code>，取决于它的类型。一般来说，<code>given</code> 的使用方式将与 <code>switch</code> 在其他语言中的使用方式相同：它将对主题进行检查，并在有匹配的情况下运行不同的代码块。然而，在这种情况下，它将简单地运行该代码块，而不进行任何进一步的检查。另外，这个主题变量是一个数组，所以这个区块会有 <code>@</em></code> 定义了两个成分。这个变量是用来直接打印菜品的。</p>
</div>
<div class="paragraph">
<p>此外，你还可以使用本章前面学到的加载模子技术。可以为此使用一个额外的带有偏好的列，你必须将配料存储在 <code>Mix</code> 中，而不是数组中，并使用 <code>roll</code>。原理是完全一样的。有了这些不同的选择，您可以看到"有许多方法可以做"的原则在行动，这一点贯穿了 Raku 中的每一个设计决策。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配方_3_6_处理大的结构化的文件问题">2.6. 配方 3-6. 处理大的、结构化的文件问题</h3>
<div class="paragraph">
<p>大文件中包含的信息需要有效处理，可能会有一些内存限制。</p>
</div>
<div class="sect3">
<h4 id="_解决办法_7">2.6.1. 解决办法</h4>
<div class="paragraph">
<p>你可以在文件句柄上使用 <code>.line</code>，这将会从文件的行中创建一个懒惰序列，或者在文件不容易分成行的情况下，使用 <code>.Supply</code> 对其进行分块读取。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_10">2.6.2. 它是如何工作的</h4>
<div class="paragraph">
<p>目前的电脑有很好的内存。但自然规律是，你的电脑需要处理的文件大小总是会增长到两倍的大小 的可用内存。因此，尽管在大多数情况下，在内存中吞吐一整个文件就可以了，但在某些情况下，这可能太慢了，或者在可用内存的情况下根本不可能。例如，开源的电子表格 LibreOffice Calc 在试图读取一个几百兆的文件时就会窒息。Raku 能够跟上它吗？剧透一下：是的，它会。</p>
</div>
<div class="paragraph">
<p>我们先来谈谈懒惰的概念。懒惰的数据结构简单来说就是一个</p>
</div>
<div class="paragraph">
<p>只有在请求时才会计算其元素。一个使用函数生成的懒惰序列，只有当它被请求时，才会重构它的元素号 n。同时，它将处于空白状态，但更重要的是，它不会在内存中，吞噬空间，计算它所需的资源将可供操作系统的其他部分使用。</p>
</div>
<div class="paragraph">
<p>在 Raku 中负责输入/输出的 <code>IO::Handle</code> 对象相当强大，其中，它们可以变成懒惰的数据结构，只在需要时才返回文本文件的行。</p>
</div>
<div class="paragraph">
<p>例如，你需要将美国农业部公布的每个产品的营养素数据库加载为一个179MB的CSV文件。因此，原则上，你可以使用 <code>Text::CSV</code> 来处理它。但是，这将会吞噬掉 179MB 以上的数据，而且，更糟糕的是，你需要很长时间才能在控制台中看到结果。</p>
</div>
<div class="paragraph">
<p>(在这种情况下，你可以使用一个面向行的 API，但你已经在另一个食谱中看到了如何使用它，所以让我们尝试一个不同的方法，没有依赖性。) 让我们这样使用 <code>IO::Handle.line</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for "/home/jmerelo/Documentos/Nutrients.csv".IO.lines.grep: {
    my @data = $_.split('","');
    $_ if @data[2] eq "Protein" and @data[4] &gt; 70 and @data[5] ~~ /^g/
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个脚本将只打印那些蛋白质含量超过70克的产品（一个任意选择的数字）。这个脚本将立即开始打印控制台中的行，就像这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">"45332602","203","Protein","LCCS","70.59","g"
"45333759","203","Protein","LCCS","77.42","g"
"45333760","203","Protein","LCCS","72.73","g"
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>在我的台式电脑上，处理整个文件的时间不会很长-28秒。更重要的是，进程监视器显示，程序使用的内存从来没有超过大约 100MB 的常驻内存，大大小于文件大小。</p>
</div>
<div class="paragraph">
<p>立即获得这些结果的好处是，例如，我们可以创建一个供应，并将它们发射到该供应。一个 tap 将拾取这些行，例如，异步地查找产品代码（它在另一个文件中被交叉引用）。</p>
</div>
<div class="paragraph">
<p>如果文件是以其他方式组织的，例如，作为文本或 JSON 文件，也可以使用供应。<code>IO::Handle.Supply</code> 将从中读取特定大小的块，然后以字符串的形式发出。反正文本文件是可以按行处理的，而且，如前面的配方所示，这种分块处理是一种最好留给二进制文件的技术。反正知道有不止一种方法就好。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_数学">3. 数学</h2>
<div class="sectionbody">
<div class="paragraph">
<p>编程语言是数学的后代，但它们有不同的能力将数学语言和表达式翻译成代码。通过使用它们的 Unicode 字形来实现运算符，你会发现 Raku 代码比其他语言更接近数学。根据其函数性质，Raku 函数也可以作为纯函数（应用，用数学术语来说）工作，因此在 Raku 代码中可以更清晰地看到数据流。</p>
</div>
<div class="paragraph">
<p>在本章中，我们将通过几个处理数学对象的配方，合理地应用数学运算。</p>
</div>
<div class="sect2">
<h3 id="_食谱_4_1_生成数学序列并从中提取随机元素">3.1. 食谱 4-1. 生成数学序列并从中提取随机元素。</h3>
<div class="sect3">
<h4 id="_问题_7">3.1.1. 问题</h4>
<div class="paragraph">
<p>一个数学序列有一个初始值和一个生成器，生成器从之前的值计算出序列中的下一个项。你需要一种直接的方法来处理这些潜在的无限数据结构，并从中提取任意元素。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方法_5">3.1.2. 解决方法</h4>
<div class="paragraph">
<p>将 Seq 与序列运算符一起使用。此外，您还可以使用生态系统中 <code>Math::Sequences</code> 模块中的现成序列。</p>
</div>
</div>
<div class="sect3">
<h4 id="_如何工作_2">3.1.3. 如何工作</h4>
<div class="paragraph">
<p>Raku 包括内置的（或核心）数据结构 Seq。Seq 数据结构用来表示一个懒惰的序列，它可以表示无限的序列，并计算每个项的需求。它还更进一步，因为它可以从第一项中推断出序列的其余部分，尤其是简单的几何或算术进展。</p>
</div>
<div class="paragraph">
<p>你可能听说过关于国际象棋发明者的故事。国王要求他为这样一个伟大的游戏报出价格。他想用麦粒来支付，在棋盘上的第一个格子里放一粒，而在每一个连续的格子里放双倍数量的麦粒。"成交。"国王回答。不过，如果他手头有 Raku，他可以打出下面的内容，马上就能意识到这个数字有多大。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [+] (1,2,4...*)[^64]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>(1,2,4&#8230;&#8203;*)</code> 是实际的 Seq。我们需要至少打出前三个元素，这样 Raku 就能知道足以将其标记为一个算术进阶，然后可以计算其余的元素。<code>&#8230;&#8203;</code> 是序列运算符，这是一个智能运算符，能够生成任何类型元素的序列，包括这些无限序列。方括号取一个片断，从第1个元素到第64个元素(排除)，最后我们用超前和来求和一切。结果，正如预期的那样，是 18446744073709551615。顺便说一下，你也可以在 Raku 中用以下方法计算。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 2⁶⁴ -1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>注: 国王被逗乐了或者不被逗乐了，这取决于你问谁，要么笑得很开心，要么剪了那哥们儿的脖子上的头发。</p>
</div>
<div class="paragraph">
<p>序列也可以从应用于前项的操作中递归计算。例如，后面的那个，将序列中前面的两个元素结合起来，并取模9。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub digits( $_1, $_2 ) {
    return $_1, $_2, { ($^a ~ $^b) % 9 } ... *;
}

for 1..5 X 1..5 -&gt; @_ {
    say digits( | @_ )[^10];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$^a</code> 和 <code>$^b</code> 是占位变量，将按字母顺序取上一个和下一个变量的值。它们所在的块将计算前两个变量中的第n个元素。我们没有使用单一的数字对开始，而是创建了一个返回 Seq 的 sub。该子在接下来创建的循环中被调用。</p>
</div>
<div class="paragraph">
<p>它创建了一个由25对数字组成的数组，并将它们扁平化后交给子。|将从一个数组中创建两个参数。我们最终会打印每个序列的前十个元素，得到类似这样的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">(1 1 2 3 5 8 4 3 7 1)
(1 2 3 5 8 4 3 7 1 8)
(1 3 4 7 2 0 2 2 4 6)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在很多情况下，使用Seq可以省去你在构建复杂的循环或递归函数时的大量工作，而且它在Raku中的语法将更容易理解。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_4_2_编程一个分而治之的算法">3.2. 食谱 4-2. 编程一个分而治之的算法</h3>
<div class="sect3">
<h4 id="_问题_8">3.2.1. 问题</h4>
<div class="paragraph">
<p>你需要解决一个数学问题，把它分成可以解决的小问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解题方法">3.2.2. 解题方法</h4>
<div class="paragraph">
<p>使用递归，使基本情况，也就是最小的情况得到解决，你可以从那里建立起来。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_11">3.2.3. 它是如何工作的</h4>
<div class="paragraph">
<p>分而治之是一种在许多问题领域中使用的技术，它将困难的问题转化为可以相对容易解决的问题。一个经典的例子是排序。对一个长的列表进行排序是通过使用枢轴来解决的。它包括将所有小于一定大小的元素放在一个列表中，而将大于一定大小的元素放在另一个列表中。因此，你把排序问题分成了两个问题，即对那两个较小的列表进行排序的问题。这种算法叫做 <code>quicksort</code>，它在时间和内存上都非常高效。</p>
</div>
<div class="paragraph">
<p>同样类型的问题在烹饪中也会出现。我们如何才能在不超过一定卡路里的情况下，烹饪出蛋白质含量最高的一餐？或者烹饪出一份纤维含量最高，又不超过一定量的蛋白质？</p>
</div>
<div class="paragraph">
<p>注意你可能已经注意到，这是一个背包问题的例子。</p>
</div>
<div class="paragraph">
<p>让我们利用卡路里表，找到一个与表中用量相同的，能优化蛋白质含量的食材组合。这次我们不需要关注量，也不需要关注如何创造一餐好饭的规则，就能做到这一点。这个程序会做到这一点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Raku::Recipes;
# We're using this code from Raku::Recipes:
sub calories-table( $dir = "." ) is export {
    csv(in =&gt; "$dir/data/calories.csv",  sep =&gt; ';', headers =&gt; "auto",
    key =&gt; "Ingredient" ).pairs
    ==&gt; map( {
       $_.value&lt;Ingredient&gt;:delete;
       $_.value&lt;parsed-measures&gt; = parse-measure( $_.value&lt;Unit&gt; );
       $_ } );
}

my %calories-table = calories-table;
multi sub recipes( -1, $ ) { return [] };
multi sub recipes( $index,
                   $weight  where
                   %calories-table{@products[$index]}&lt;Calories&gt; &gt; $weight ) {
                       return recipes( $index - 1, $weight );
}

multi sub recipes( $index, $weight ) {
    my $lhs = proteins(recipes( $index - 1, $weight ));
    my @recipes = recipes( $index - 1,
                           $weight -  %calories-table{
                           @products[$index]}&lt;Calories&gt; );

    my $rhs = %calories-table{@products[$index]}&lt;Protein&gt; +  proteins( @recipes );
    if $rhs &gt; $lhs {
        return @recipes.append: @products[$index];
    } else {
        return @recipes;
    }
}

my $max-calories = 1000;
my @products = %calories-table.keys;
my @ingredients = recipes( @products.elems -1 , $max-calories );
say @ingredients, " with ", proteins( @ingredients ), "g protein";

sub proteins( @items ) {
    return [+] %calories-table{@items}.map: *&lt;Protein&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序使用了我们之前使用过的帮助模块来加载配料表，它在前两行就完成了。我们还是把例程 <code>calories-table</code> 包含在内，以供参考。你可能还记得，这是在上一章的配方中使用的代码，它对数据集应用了一系列的变换。此外，这个例程还使用了 <code>parse-measure</code>，也在那一章中讨论过。</p>
</div>
<div class="paragraph">
<p>这是一个分而治之的算法，所以我们必须从最大的问题开始，解决较小的问题。这就是我们在最后几行所做的事情，它设置了算法，建立了卡路里数和产品数组（简单来说就是卡路里表的键，其中包含产品的名称），并调用了食谱子程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub recipes( -1, $ ) { return [] };
multi sub recipes( $index,
                   $weight  where
                   %calories-table{@products[$index]}&lt;Calories&gt; &gt; $weight ) {
    return recipes( $index - 1, $weight );
}

multi sub recipes( $index, $weight ) {
    my $lhs = proteins(recipes( $index - 1, $weight ));
    my @recipes = recipes( $index - 1,
                           $weight -  %calories-table{
                           @products[$index]}&lt;Calories&gt; );
    my $rhs = %calories-table{@products[$index]}&lt;Protein&gt; +  proteins( @recipes );
    if $rhs &gt; $lhs {
        return @recipes.append: @products[$index];
    } else {
        return @recipes;
    }
}

my $max-calories = 1000;
my @products = %calories-table.keys;
my @ingredients = recipes( @products.elems -1 , $max-calories );</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个子程序是所有乐趣所在。我们用 Raku 的 <code>multi</code> 来处理我们的不同选择。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果 <code>index</code> 变成负数，我们就没有产品了。它只是返回一个空的成分数组。这将是基本情况。另外，其实权重是什么并不重要，所以我们用虚变量$来表示权重。</p>
</li>
<li>
<p>用一个非负的索引，但是当数组中那个位置的产品的卡路里比我们想要的多时，我们就跳过一个，往下走一步，"消除 "这个产品（简单的跳过）。在这种情况下不会出现这种情况，除非我们把卡路里削减到400卡路里，而不把辣条剔除。</p>
</li>
<li>
<p>接下来的多是真正的主力军。我们比较两件事：不使用当前产品的食谱中的蛋白质，以及不使用当前产品计算出的最佳蛋白质的产品。这就进入了 <code>@recipes</code> 数组。如果这个产品中的蛋白质含量比没有这个产品的好，我们就选择当前产品，将其追加到列表中。如果没有，我们就简单地返回没有它的产品列表。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你可以玩弄总的卡路里数，得到不同的高蛋白组合。你会发现，每次运行它，你都会获得一组不同的成分。类似这样的。</p>
</div>
<div class="paragraph">
<p>[Kale Tomato Olive Oil Kidney beans Lentils Chicken breast Rice] with 53.6g protein
[Lentils Egg Tuna] with 43.9g protein</p>
</div>
<div class="paragraph">
<p>这有几个原因。首先，这种分而治之的方法是一种贪婪的算法：产品在数组中的排序顺序会有影响，因为当循环算法到达产品时，会根据当前的卡路里数来放弃或添加。其次，这个数组只是一个哈希表中的键列表，为什么是随机的呢？哈希表中的元素列表是以随机顺序返回的，为了防御拒绝服务攻击，也保证了这种方式的发生。</p>
</div>
<div class="paragraph">
<p>我们需要多次运行该算法，以获得热量含量最大的组合。鸡肉、扁豆和豆子炖肉，有人愿意吗？</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_4_3_使用矩阵">3.3. 食谱 4-3. 使用矩阵</h3>
<div class="sect3">
<h4 id="_问题_9">3.3.1. 问题</h4>
<div class="paragraph">
<p>从图像处理到机器学习，矩阵在各种问题上的应用最多。处理事先已知尺寸的数据结构相当方便。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方法_6">3.3.2. 解决方法</h4>
<div class="paragraph">
<p>Raku 对二维矩阵的数据支持有限，但有一些运算符。使用生态系统模块 Math::Matrix 来处理矩阵。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_12">3.3.3. 它是如何工作的</h4>
<div class="paragraph">
<p>Math::Matrix 是一个生态系统模块，所以你需要先下载它。它在 GitHub 仓库里有很好的文档，https://github.com/pierre-vigier/Perl6-Math-Matrix。它使你能够使用矩阵，也就是简单的二维数组或表格。</p>
</div>
<div class="paragraph">
<p>当你想对一系列的数量进行计算时，矩阵运算是很好的，它们可以用在我们的菜谱计算环境中。例如，我们可能有一张表，上面有不同配方中不同原料的数量，还有一张表，上面有几个用户实际消耗的一道菜的百分比。假设我们想计算不同食材被消耗的数量，这样我们就可以，计算出卡路里或蛋白质的数量。</p>
</div>
<div class="paragraph">
<p>下表列出了三种不同食材&#8212;&#8203;大米、鹰嘴豆和西红柿在三种不同食谱中的用量，以克为单位。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recipe 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recipe 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recipe 3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rice</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">150</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">50</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">50</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Chickpeas</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">50</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">150</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">50</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tomatoes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">150</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>现在我们有三个不同的人，因为挑食或者干脆吃饱了，只吃了三个食谱中的一部分。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Person 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Person 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Person 3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recipe 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recipe 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recipe 3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.7</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>我们需要知道每个人消耗了多少克的每种原料。这个程序将计算出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use Math::Matrix;

# Recipe x ingredient
# Columns = Recipes
# Rows = Amount of rice, chickpeas and tomato
my $food-matrix = Math::Matrix.new( [[ 150, 50, 50 ],
				                     [ 50, 150, 50 ],
				                     [ 100, 150, 100 ]] );

# Columns = People
# Rows = percentage of dish eaten
my $person-recipes = Math::Matrix.new( [[ 0.5, 0.8, 0.3 ],
				                        [ 0.9, 1, 1 ],
				                        [ 0.2, 0.8, 0.7 ]] );

say $food-matrix dot $person-recipes;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将打印以下内容:</p>
</div>
<div class="paragraph">
<p>130  210  130
170  230  200
205  310  250</p>
</div>
<div class="paragraph">
<p>与数学中的许多问题一样，一旦你有了正确的表示方法，就只是选择正确的运算符的问题。在这种情况下，点积（恰当地称为点）将行乘以等量列，然后将结果相加。良多人1消耗了130克大米，而人3消耗了310克鹰嘴豆。这几乎是1000卡路里的热量。</p>
</div>
<div class="paragraph">
<p>该模块包含了大量的运算，包括分解和大多数矩阵运算，你可以用于任何这一点是必不可少的，比如神经网络。而且它使用了预期的运算符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Math::Matrix;
my $first = Math::Matrix.new( [[1,2],[3,4]] );
my $second = $first * 2;
say $second + $first;</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二个数组是第一个数组的两倍；也就是说，每个元素都要乘以二。然后，我们将第二个数组与第一个数组相加，得出总和，在每一种情况下都使用通常的算术运算符。这种表现力，以及用新的操作（在这种情况下是矩阵）来重载各种运算符的能力，是使 Raku 有用和强大的两点。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_4_4_计算_mandelbrot_集">3.4. 食谱 4-4. 计算 Mandelbrot 集</h3>
<div class="sect3">
<h4 id="_问题_10">3.4.1. 问题</h4>
<div class="paragraph">
<p>为了好玩，你需要计算 Mandelbrot 集。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_8">3.4.2. 解决办法</h4>
<div class="paragraph">
<p>Mandelbrot 集是一组数字，当数字被迭代时，函数不会改变（即它们保持绝对值的边界）。当您将迭代次数（通常称为逸出时间）后的值映射为颜色时，它们会产生视觉上令人惊叹的图形。基本上，你可以在 Raku 中使用复杂的数字来对这些集合进行编程。Julia 集和 Fatou 集是两个为特定函数定义的互补集，通常是二次多项式。它们由复数平面元素组成，其序列值由一定的数字限定。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_13">3.4.3. 它是如何工作的</h4>
<div class="paragraph">
<p>对于 Mandelbrot 集和 Julia 集，就是要创建一个递归定义的序列，并在一定次数的迭代后计算其值。我们将计算出 Mandelbrot 集，并将 Julia 集作为一个练习。</p>
</div>
<div class="paragraph">
<p>这个脚本将计算 Mandelbrot 集合的一部分，并使用填充方块将其打印到控制台。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use Array::Shaped::Console;

sub mandelbrot( Complex $c --&gt; Seq ) {
    0, *²+$c ... *.abs &gt; 2;
}

my $min-x = -40;
my $max-x = 40;
my $min-y = -60;
my $max-y = 20;
my $scale = 1/40;
my $limit = 100;
my @mandelbrot[$max-y - $min-y + 1; $max-x - $min-x + 1];
for $min-y..$max-y X $min-x..$max-x -&gt; ( $re, $im ) {
    my $mandel-seq := mandelbrot( Complex.new( $re*$scale, $im*$scale) );
    @mandelbrot[$re-$min-y;$im-$min-x] = $mandel-seq[$limit].defined??
          ∞ !! $mandel-seq.elems;
}
say printed(@mandelbrot);</code></pre>
</div>
</div>
<div class="paragraph">
<p>看上去有点长，但事实上，它的要点只有不到半打的行文。首先，我们来看一下 Mandelbrot 序列本身。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">0, *²+$c ... *.abs &gt; 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了确定某个复数 <code>$c</code> 是否属于 Mandelbrot 集合，我们从0开始计算一个序列，并通过平方计算之后的每一个数字，然后将 <code>$c</code> 相加。如果序列中的数值没有达到无穷大，也就是说，如果序列永远持续下去，那么这个数将属于 Mandelbrot 集合。我们从启发式的角度也知道，如果在某一点上，序列中的数的绝对值大于2，那么它最终将走向无穷大，从而不属于 Mandelbrot 集。所以，如果 <code>$c</code> 属于 Mandelbrot 集，这个序列将是一个无限（但懒惰）序列，如果不属于 Mandelbrot 集，它将是有限的。</p>
</div>
<div class="paragraph">
<p>我们用数字创建一个（粗）网格。它的边界是x轴的-40,40和y轴的-60,20，我们选择了这两个范围，这样就能真正显示出熟悉的 Mandelbrot 集的画面。我们用100作为极限：如果在100次迭代内，它还没有停止，那很可能它永远不会停止（当然，我们可能是错的，但如果你的资源有限，而且没有办法证明关于每一个复数的定理，那就是你需要做的）。另外，我们把那个网格缩小，以便更好地观察集合，我们用1/40作为这个比例。网格实际上会从x轴的-1,1，y轴的-0.5到1.5。这个序列是为每一个数字生成的，然后我们检查序列中的元素100（第一个0之后）会发生什么。它存在，所以它属于 Mandelbrot 集合。让我们给它分配一个 <code>∞</code>，因为它将走向无穷大。如果它不存在，让我们记下逃逸时间，这将是我们所表示的。</p>
</div>
<div class="paragraph">
<p>我们将其存储在一个异形数组中，这是 Raku 的一个精巧的功能。它们是数组，而不是一维（本质上是向量），而是不同维度的数组。由于我们正在计算一个网格的元素，并为每一个元素获取一个值，所以我们将它们存储在一个二维数组中，并根据我们将在每个维度中的点的数量调整维度。我们使用分号 <code>;</code> 来分隔每个维度的索引: <code>@mandelbrot[$re-$min-y;$im-$min-x]</code>。它能记住自己的形状这一事实将在后面使用。</p>
</div>
<div class="paragraph">
<p>这将被处理到打印例程，它属于 Array::Shaped::Console 模块。这个例程使用符号来表示值，并根据数组的形状和可用值的范围自动调整自己。它最终会打印出类似这样的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢■▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢■▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▢■▢▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▣▢□▢▤■▤▢□▢▣▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▣▢▣■▣▢▣▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▥■■■■■▥▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□▣▤■■■■■▤▣□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▣■■■■■▣▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□▢□□□□□▢▢▢▢▢▢■■■■■▢▢▢▢▢▢□□□□□▢□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□▢▢▢▢□□□□□▣▢▢▣▤▥■■■▥▤▣▢▢▣□□□□□▢▢▢▢□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▢□▢▢▢▥▦▥■■■■■■■■■▥▦▥▢▢▢□▢▢□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▢▢▢▢▢▣■■■■■■■■■■■■■▣▢▢▢▢▢▢□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□▣▢▤▦▣■■■■■■■■■■■■■■■▣▦▤▢▣□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▢■■■■■■■■■■■■■■■■■■■■■■■▢▢□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▤■■■■■■■■■■■■■■■■■■■■■▤▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▢▣■■■■■■■■■■■■■■■■■■■▣▢▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□▤▥■■■■■■■■■■■■■■■■■■■▥▤□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□▢▢▢▢■■■■■■■■■■■■■■■■■■■■■▢▢▢▢□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□▢▢▢▢▣■■■■■■■■■■■■■■■■■■■■■▣▢▢▢▢□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▤■■■■■■■■■■■■■■■■■■■■■■■▤▢□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▤■■■■■■■■■■■■■■■■■■■■■▤▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▢■■■■■■■■■■■■■■■■■■■■■▢▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▦■■■■■■■■■■■■■■■■■■■■■▦▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▣■■■■■■■■■■■■■■■■■■■▣▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▣■■■■■■■■■■■■■■■■■■■▣▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▣■■■■■■■■■■■■■■■■■▣▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▣■■■■■■■■■■■■■■■▣▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▢▧■■■■■■■■■■■■■▧▢▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▢▢▢▢▧■■■■■■■■■▧▢▢▢▢▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□▢▢▢▢▢▣▣▤▥▧■■■▧▥▤▣▣▢▢▢▢▢□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□▤▢▢■■▣▥■■■■■■■■■■■■■■■▥▣■■▢▢▤□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□▢▣□□▣■▢▣■■■■■■■■■■■■■■■■■■■■■■■▣▢■▣□□▣▢□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□▢▤▢▢▢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▢▢▢▤▢□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□▢▤■▨▢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▢▨■▤▢□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□▢▢▦■▤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▤■▦▢▢□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□▢▢▢▢□□□▢▢▣▧■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▧▣▢▢□□□▢▢▢▢□□□□□□□□□□□□□
□□□□□□□□□□□□□□▤▣▢▧▤▢▥■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▥▢▤▧▢▣▤□□□□□□□□□□□□□□
□□□□□□□□□□□□□▢▦▧▥▦■▢▧■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▧▢■▦▥▧▦▢□□□□□□□□□□□□□
□□□□□□□□□□□□▣▣▢▦■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▦▢▣▣□□□□□□□□□□□□
□□□□□□□□□□□□□□▢▢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▢▢□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□▨▤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▤▨□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□▢▢▣■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▣▢▢□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□▢▤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▤▢□□□□□□□□□□□□□□□
□□□□□□□□□□□□□▢▨▢▣■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▣▢▨▢□□□□□□□□□□□□□
□□□□□□□□□□□□□▣▤■▤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▤■▤▣□□□□□□□□□□□□□
□□□□□□□□□□□□□▢▢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▢▢□□□□□□□□□□□□□
□□□□□□□□□□□□□□▢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▢□□□□□□□□□□□□□□
□□□□□□□□□□□□□▢■▧■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▧■▢□□□□□□□□□□□□□
□□□□□□▢▢□□▢□□▢▣■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▣▢□□▢□□▢▢□□□□□□
□□□□□▢▥▢▢■▣▢▢▢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▢▢▢▣■▢▢▥▢□□□□□
□□□□□▢▢▣▦▤■▧■▢▨■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▨▢■▧■▤▦▣▢▢□□□□□
□□□□□□▢▣■■■■■■▧■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▧■■■■■■▣▢□□□□□□
□□□□▣▢▣■■■■■■■▩■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▩■■■■■■■▣▢▣□□□□
□□□□▤▣▣■■■■■■■▨■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▨■■■■■■■▣▣▤□□□□
▢▢▢▢▣■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▣▢▢▢▢
□▢▣▤▣■■■■■■■■■▨■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▨■■■■■■■■■▣▤▣▢□
□▣▢□▢▣▢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▢▣▢□▢▣□
□▢□□□▢▢▨■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▨▢▢□□□▢□
▢□□□□□□▢■▣▥▧▣▢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▢▣▧▥▣■▢□□□□□□▢
▥□□□□□▢▣▢▢▤▢▢▢▣■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▣▢▢▢▤▢▢▣▢□□□□□▥
□□□□□□▢▢□□□□□▢▥■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▥▢□□□□□▢▢□□□□□□
□□□□□□□□□□□□□▩▤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▤▩□□□□□□□□□□□□□
□□□□□□□□□□□□□□▧▦■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▦▧□□□□□□□□□□□□□□
□□□□□□□□□□□□□□▢▧■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▧▢□□□□□□□□□□□□□□
□□□□□□□□□□□□□▢▣■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▣▢□□□□□□□□□□□□□
□□□□□□□□□□□□□□▥▣▢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▢▣▥□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□▢▢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▢▢□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□▢▢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▢▢□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□▢▢■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▢▢□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□▢▢▤■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■▤▢▢□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□▢▥■■■■▨■■■■■■■■■■■■■■■■■■▢■■■■■■■■■■■■■■■■■■▨■■■■▥▢□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□▢▥■■■▢▤■■■■■■■■■■■■■■■■■▢■■■■■■■■■■■■■■■■■▤▢■■■▥▢□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□▢■▥■▣▢▢▤■■■■■■■■■■■■■■■□□□■■■■■■■■■■■■■■■▤▢▢▣■▥■▢□□□□□□□□□□□□□□□□
□□□□□□□□□□□□▢□▢▢▢▣▣▣▢□▢▥▢▣■■■■■■■■■■■▩□□□□□▩■■■■■■■■■■■▣▢▥▢□▢▣▣▣▢▢▢□▢□□□□□□□□□□□□
□□□□□□□□□□□□□▣□□▢▣□□□□□□□▢■■▣▤■■■■■▢▣□□□□□□□▣▢■■■■■▤▣■■▢□□□□□□□▣▢□□▣□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□▢□□□□□□□□▥■■▢▢▢■▤▢▣▢□□□□□□□□□▢▣▢▤■▢▢▢■■▥□□□□□□□□▢□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□▢▢▢□□□▢▣□□□□□□□□□□□□□□□▣▢□□□▢▢▢□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□▢▢▢▢□□□□□□□□□□□□□□□□□□□□□□□□□▢▢▢▢□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□
□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□</code></pre>
</div>
</div>
<div class="paragraph">
<p>这张图有着大家熟悉的、心形的 Mandelbrot 集合。在这种情况下，黑色的方块将是属于它的元素，白色的方块显示了那些逃逸时间很短的元素，小于10。</p>
</div>
<div class="paragraph">
<p>无论如何，这表明使用 Raku 进行序列计算是多么容易，即使是复杂的数字。计算的关键部分是在单行中定义的序列。其余的部分主要用于视觉上的渲染。使用更适合数学的数据结构，比如异形数组，也让程序员的生活更轻松。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_4_5_充分利用整数的无限精确性">3.5. 食谱 4-5. 充分利用整数的无限精确性</h3>
<div class="sect3">
<h4 id="_问题_11">3.5.1. 问题</h4>
<div class="paragraph">
<p>你需要检查整个整数集的一些属性，这意味着要在无限集上工作，并且要处理可能具有无限精度的数字。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方法_7">3.5.2. 解决方法</h4>
<div class="paragraph">
<p>只需在 Raku 中使用普通的 Ints，默认情况下，Ints 具有任意精度。您也可以使用无限序列或它们的组合，因此您可以对无限序列应用任何类型的操作，并且只在需要时才产生结果。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_14">3.5.3. 它是如何工作的</h4>
<div class="paragraph">
<p>让我们从计算相邻质数开始；这些质数被两个分开。它们也被称为孪生质数，它们合在一起被称为孪生质数对。事实证明，孪生质数对的数量是无限的，这就是为什么我们需要无限的精度来计算它们。随着我们位数的增加，显然要花很长的时间来处理它们。但是由于 Raku 可以使用惰性序列，我们可以使用这个简短的脚本来计算连续数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env perl6

my Int @primes = (1,2,3…∞).grep: *.is-prime;

my $prev = 0;
my @contiguous = lazy gather {
    for @primes -&gt; $prime {
	take [$prime, $prev] if ($prime - $prev) == 2;
	$prev=$prime;
    }
}

say @contiguous[300..310];</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中最重要的部分是在第一行中定义一个（可能的）所有质数的列表。这个序列将包含一个所有可能的质数的生成器，并将根据需求计算它们。这就是我们在下一个循环中要做的事情。同样，这其中最重要的部分是我们需要懒惰地处理懒惰序列。<code>gather</code> 语句会在循环内拾取所有由 <code>take</code> 发送的数据，但使其变得懒惰，会使产生的数据结构 <code>@contiguous</code> 变得懒惰，从而不会在停止之前超过（无限）<code>for</code> 循环。如果我们要计算第300个到310个连续的质数，就不会走到无穷大再回来，而是在计算完第310对连续的质数后才停止。对了，是 [17791 17789]。另外，在我的笔记本上，这需要大约两秒钟的时间。计算第3000对，也就是 [300499 300497] 和第10000对，也就是 [1260991 1260989]，需要很长时间（在这种情况下，大约5分钟）。我们可以继续使用任何序列，不需要指定大整数什么的，只要我们准备好等待就可以了。但很明显，这些数字与这里和那里使用的其他整数是差不多的，唯一的好处是不需要为它们使用一些特殊的数据结构。</p>
</div>
<div class="paragraph">
<p>让我们试着用真正的大数来工作。我们只需要在其他地方开始序列。例如，在这里。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int @primes = (264...∞).grep: *.is-prime;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，第一个质数是 18446744073709551629。如果我们想知道前三对，前一个程序将打印如下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">([18446744073709552423 18446744073709552421]
[18446744073709554151 18446744073709554149]
[18446744073709558603 18446744073709558601])</code></pre>
</div>
</div>
<div class="paragraph">
<p>这发生在不到 1/20 秒的时间里。显然，有很多连续的质数。这些数确实有很多位数，显示出我们需要的任意精度。</p>
</div>
<div class="paragraph">
<p>没有那么多的和睦数，也就是那些被除数（不包括它本身和一）加起来后，产生第二个数的数对。在这种情况下，它涉及到轻松地索引一个数字的除数列表，以便它们可以被相加并与其他数字进行比较。这是 Perl 每周挑战中的一个挑战，Laurent Rosenfeld 提出了这个解决方案（稍作修改，因为最初它只返回第一对）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub sum-divisors (Int $num) {
    my @divisors = grep { $num %% $_ }, 2..($num / 2).Int;
    return [+] 1, | @divisors;
}

for 2..Inf -&gt; $i {
    my $sum_div = sum-divisors $i;
    if $sum_div &gt; $i and $i == sum-divisors $sum_div {
        say "$i and $sum_div are amicable numbers";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，它使用了一个懒惰，所以可以处理整个整数集；但是，需要使用 Control+C 来停止它，因为它一找到这些数字就会继续打印友好的数字。另外，它并没有存储 <code>sum-divisors</code> 的结果，所以当 <code>$sum_div</code> 再次达到 <code>$i</code> 的值时，就会重新计算一遍。让我们做两个小改动来处理这些问题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use experimental :cached;

sub sum-divisors (Int $num) is cached {
    my @divisors = grep { $num %% $_ }, 2..($num / 2).Int;
    return [+] 1, | @divisors;
}

my @amicable = lazy gather {
    for 2..Inf -&gt; $i {
	my $sum_div = sum-divisors $i;
	take [$i, $sum_div] if $sum_div &gt; $i and $i == sum-divisors $sum_div;
    }
}

say @amicable[^3];</code></pre>
</div>
</div>
<div class="paragraph">
<p>(还在实验中)缓存功能存储了一个带有 <code>is cached</code> 特征的例程的结果。有了这个功能，我们就会有一个数字的除数的值，如果以前见过，就会有这个值，这样可以节省不少时间。然后我们将循环的结果分配给一个懒惰序列，这样我们就可以根据需求计算第n个元素。我们直接获得了三对经典已知的和睦数，在六秒钟内，我们计算出了前四对。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">([220 284] [1184 1210] [2620 2924] [5020 5564])</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_配置和执行程序">4. 配置和执行程序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>到目前为止，我们一直在与小型脚本和模块合作，一般来说，这些脚本和模块已经具备了完成工作所需的一切。然而，大多数真正的程序需要用户提供一些信息才能正常运行，即使它们使用默认值工作。这些信息将以环境信息、命令行标志或某种标准格式的配置文件的形式出现。在本章中，我们将看到这些在 Raku 中是如何工作的。</p>
</div>
<div class="sect2">
<h3 id="_食谱_5_1_使用_jsonyaml_ini_文件配置程序">4.1. 食谱 5-1. 使用 JSON/YAML/.ini 文件配置程序</h3>
<div class="sect3">
<h4 id="_问题_12">4.1.1. 问题</h4>
<div class="paragraph">
<p>你需要运行一个程序，在设计程序的时候，一系列的值是不知道的，或者说对于不同的实例来说，这些值根本就是不同的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_9">4.1.2. 解决办法</h4>
<div class="paragraph">
<p>现在，JSON 可能是最广泛使用的配置格式，以及数据结构的序列化。你可以使用生态系统中的模块 JSON::Fast（可从 <a href="https://modules.raku.org/dist/JSON::Fast:cpan:TIMOTIMO" class="bare">https://modules.raku.org/dist/JSON::Fast:cpan:TIMOTIMO</a> 获取，一样平常使用 zef），将存储在 JSON 格式的数据转换为相应的 Raku 数据结构。</p>
</div>
<div class="paragraph">
<p>YAML、.ini 以及 TOML 等格式也比较流行，它们都可以被生态系统中的模块解析。选择你觉得最舒服的格式或者最流行的格式。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_15">4.1.3. 它是如何工作的</h4>
<div class="paragraph">
<p>程序有许多不同的方法来接收变量的值，如文件名、端口值、或任何其他它们可能需要的字符串或数字。在 MAIN 子上使用位置参数和命名参数是一种方法 (我们将在下一步看到如何做)， 但配置文件的优点是可读、可编辑， 而且可以放在源控制文件下 (如果它们包含敏感信息， 则可以加密)。无论如何，留下一些值让用户决定是有意义的，因此配置文件在这种事情上很方便。</p>
</div>
<div class="paragraph">
<p>让我们重写一个我们以前用过的程序，就是计算某个卡路里的最大蛋白质量的程序。我们将使用三个配置项：存放卡路里计数的文件，最大卡路里计数，以及重复次数，以得到n的最佳值，由于结果将取决于乘积矩阵中乘积的顺序，因此使用多次迭代将帮助我们获得一个更好的值。</p>
</div>
<div class="paragraph">
<p>下面是 JSON 配置文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
    "calories" : 1000,
    "repetitions" : 3,
    "dir" : "."
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们对变量使用不形象的名称，并将其存储在 JSON 哈希表中，变量为键值对。程序如下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Raku::Recipes;
use JSON::Fast;

my %conf = from-json(  slurp(@*ARGS[0] // "config.json" ) );
%calories-table = calories-table( %conf&lt;dir&gt; );
@products = %calories-table.keys;

my $max-calories = %conf&lt;calories&gt;;

my @results = gather for ^%conf&lt;repetitions&gt; {
    @products = @products.pick(*);
    my @ingredients = optimal-ingredients( @products.end , $max-calories );
    my $proteins = proteins( @ingredients );
    say @ingredients, " with $proteins g protein";
    take @ingredients =&gt; $proteins;
}
say "Best ", @results.Hash.maxpairs;</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，我们将用于最大化蛋白质最优成分的例程重新命名，并将其放在 Raku::Recipes 模块中，该模块包含了其他不同的子例程，我们从以前的食谱中重用。这个例程将在同一个 <code>%calories-table</code> 变量中使用卡路里表；这个和 <code>@products</code> 将是具有模块范围的变量，但它们在这个主程序中得到的值。这只是附带的，这个配方的主旨是使用 JSON 配置。</p>
</div>
<div class="paragraph">
<p>从这个意义上说，主要的操作是在 <code>%conf</code> 变量中。该变量将是从一个文件中读取的哈希值，该文件将作为命令行中的第一个参数(<code>@*ARGS[0]</code>)被接收，或者在自已同一目录中具有默认值 <code>config.json</code>。该哈希值用于加载卡路里表（使用 <code>%conf&lt;dir&gt;</code> 中包含的目录），以获得允许的最大卡路里（在 <code>%conf&lt;calories&gt;</code> 中）和我们要洗牌产品数组的次数，以获得具有最佳蛋白质含量的新产品组合。</p>
</div>
<div class="paragraph">
<p>洗牌是通过 <code>@products = @products.pick(<strong>)</code> 来完成的。<code>pick</code> 将从数组中随机返回一个元素，而使用 Whatever(<code></strong></code>) 将从数组中挑选出尽可能多的元素。实际上，这将对数组进行洗牌，由于 <code>optimal-ingredients</code> 使用了该变量，我们将其赋值回同一个变量。</p>
</div>
<div class="paragraph">
<p>每重复一次就会生成一个[配料数组]、[蛋白质含量]形式的对。我们使用 <code>gather</code> 和 <code>take</code> 从循环中生成这个结果。这很方便地安排使用 <code>maxpairs</code>，它将打印第二个元素具有最大值的对。</p>
</div>
<div class="paragraph">
<p>我们从示例代码仓库的主目录中运行这个配方，像这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku -Ilib Chapter-5/max-proteins-with-conf.p6 Chapter-5/config.json</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们就会得到与此类似的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">[Chicken breast Kale Rice Chickpeas Kidney beans Cheese] with 77.7 g protein
[Potatoes Chorizo Beer Pasta Chicken breast] with 64.9 g protein
[Chicken breast Potatoes Cheese Chorizo Tomato Sardines] with 109.3 g protein Best (Chicken breast Potatoes Cheese Chorizo Tomato Sardines =&gt; 109.3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了让 <code>maxpairs</code> 正确工作，我们需要将它变成一个哈希;最佳行显示了一个成分-蛋白质对，看起来相当不错，蛋白质含量为100克。不过我不建议将辣味鱼和沙丁鱼混合在一起，所以你可能要运行几次（或者重新配置另一个重复次数），这样你最终会得到一些可口的东西。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用_ini_文件进行配置">4.1.4. 使用 INI 文件进行配置</h4>
<div class="paragraph">
<p>INI 格式最初是在 Windows 中使用的，但现在在任何地方都可以找到，它比较简单，在许多情况下，当你需要的只是几个变量/值对时，就会用到它。它也被分为若干部分，其名称用方括号包围。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-INI" data-lang="INI">[food]
calories = 500
[algorithm]
repetitions =  5
[meta] dir = .</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个可靠的处理模块是 Config::INI，可以在 <a href="https://github.com/tadzik/perl6-Config-INI" class="bare">https://github.com/tadzik/perl6-Config-INI</a> 中找到，你可以用通常的方法安装它。前面的程序可以改编成这种方式使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Raku::Recipes;
use Config::INI;

my %conf = Config::INI::parse_file( @*ARGS[0].IO.e ?? @*ARGS[0] !! "config.ini" );
say %conf;
%calories-table = calories-table( %conf&lt;meta&gt;&lt;dir&gt; );
@products = %calories-table.keys;
my $max-calories = %conf&lt;food&gt;&lt;calories&gt;;

my @results = gather for ^%conf&lt;algorithm&gt;&lt;repetitions&gt; {
    @products = @products.pick(*);
    my @ingredients = optimal-ingredients( @products.elems -1 , $max-calories );
    my $proteins = proteins( @ingredients );
    say @ingredients, " with $proteins g protein";
    take @ingredients =&gt; $proteins;
}
say "Best ", @results.Hash.maxpairs;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个模块直接用 Config::INI::parse_file 读取文件，现在的哈希对变量进行了分层组织，第一个键是部分，第二个键是变量本身的名称。除此之外，除了重复次数和卡路里数有变化，我们减少了卡路里数外，其他的结果都没有明显的变化。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用_yaml_文件进行配置">4.1.5. 使用 YAML 文件进行配置</h4>
<div class="paragraph">
<p>YAML 最近在云配置中的使用比较流行，但它的生命力很长，因此在很多语言中都有很好的支持。这其中就包括 Raku，它有一个名为 YAMLish 的库，经常更新，支持度很高。</p>
</div>
<div class="paragraph">
<p>我们将尝试解决另一个问题，类似于背包问题，但更简单：我们将尝试使用两种材料创建一个具有一定卡路里的食谱。这些食材必须包括一个副料和一个主料，我们可以另外施加限制，比如让它们成为素食或非奶制品。在进行工作之前，代码会对配置进行检查，如果配置不正确或者不符合限制条件，就会发出一个错误。</p>
</div>
<div class="paragraph">
<p>下面是一个 YAML 的配置文件的例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">---
main: Cod
side: Potatoes
calories: 500</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 YAML 中，三个破折号表示一个文档的开头，其余的是键值对。YAML 允许任何类型的数据结构的序列化，但对于这个问题，这将是足够的。指定一个主菜和一个配菜，以及你想要的菜的卡路里量。为了简化，我们就把它平均分摊到副菜和菜中。</p>
</div>
<div class="paragraph">
<p>我们需要对这个配置文件进行处理，这样，如果出现问题，就可以告知用户我们所期望的是什么，出了什么问题。这也将确保错误不会进一步传播到库中，产生一个用户无法解释的更隐晦的错误。我们需要检查任何可能出错的地方，并产生一个异常，可以引导用户修复任何错误。</p>
</div>
<div class="paragraph">
<p>请注意，我们将使用自定义异常，这将在第8章中更广泛地介绍。异常，而且是类型化的异常，可以被设计到应用程序中，并通过给它们一个参数来唤起它们，使其自定义异常以适应特定的情况。</p>
</div>
<div class="paragraph">
<p>这个程序必须读取 YAML 文件，然后进行一系列的检查，如果缺少了一些必要的东西，或者仅仅是有一些错误，就会发出异常（并结束程序）。当一切检查完毕后，它将生成配方。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use YAMLish;
use Raku::Recipes::Roly;
use X::Raku::Recipes;

my $conf = slurp( @*ARGS[0] // "Chapter-5/recipe.yaml" );
my $recipes = Raku::Recipes::Roly.new;

my %conf = load-yaml( $conf );
%conf&lt;calories&gt; //= 500;

constant @conf-keys = &lt;main side calories&gt;;

die "There are unknown keys in the configuration file"
        if %conf.keys ⊖ @conf-keys ≠ ∅;

my @recipe;
for &lt;main side&gt; -&gt; $part {
    without %conf{$part} { X::Raku::Recipes::MissingPart.new( :$part ).throw() };
    given %conf{$part} {
        when %conf{$part} ∉ $recipes.products {
            X::Raku::Recipes::ProductMissing.new( :product(%conf{$part}) ).throw()
        }
        when not $recipes.check-type( %conf{$part}, $part.tc ) {
            X::Raku::Recipes::WrongType.new( :desired-type( $part )).throw() ;
        }
    }
    my %this-product = $recipes.calories-table{%conf{$part}};
    my $portion = %conf&lt;calories&gt;/( 2 * %this-product&lt;Calories&gt;);
    @recipe.push: $portion *  %this-product&lt;parsed-measures&gt;[0] ~ " " ~
            %this-product&lt;parsed-measures&gt;[1] ~ " of " ~  %conf{$part}.lc;
}

say "Use ", @recipe.join(" and ");</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序看起来比实际时间要长，只是因为正在执行的所有检查。但这是必不可少的，在生产环境中更是如此，因为在生产环境中，配置必须恰到好处。</p>
</div>
<div class="paragraph">
<p>程序的前言包括了我们已经谈过的模块。X::Raku::Recipes 是一个定义了所有异常的文件，所有的文件都会使用这个文件作为它们的命名空间。</p>
</div>
<div class="paragraph">
<p>之后，我们读取配置文件（无论是从命令行还是从默认值），并为卡路里的数量分配一个合理的默认值，以防缺失。我们初始化（双关语）角色，它也会读取卡路里表，并将配置加载到一个 Raku 哈希中。那个变量应该只有三个键，而且那里的每个值都必须是正确的。从而进行多项检查。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>是否只有我们理解的键？如果有任何其他的键，程序就会死掉，并且会通知用户。</p>
</li>
<li>
<p>是否包括菜的两个部分？如果缺少任何一个，就会抛出一个 MissingPart 异常。在这种情况下，我们可能希望将土豆作为一个合理的默认值。然而，在西班牙，默认的食物只是面包，所以在没有合理的默认值的情况下，如果缺少了面包，我们就抛出一个异常。我们会得到类似 Object does not seem to be side 这样的结果，如果我们使用 side: Cod.</p>
</li>
<li>
<p>我们是否对所提到的成分有所了解？如果表中缺少它，抛出一个 ProductMissing 异常。</p>
</li>
<li>
<p>那个食材真的是那种菜吗？例如，我们是否要求猕猴桃配土豆？如果它们不匹配，应该抛出另一个异常。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当所有这些检查都通过后，就只需将该食材用来测量卡路里的措施除以它需要填充的卡路里数量（本例中为250）。我们将其阐述为一个字符串，包括将配料的小写字母，而配料总是大写字母。最终，这可能会打印出如下的内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Use 236.111111 g of cod and 304.878049 g of potatoes</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一块好鳕鱼和一个中等大小的土豆。似乎是合理的。</p>
</div>
<div class="paragraph">
<p>对配置的正确处理总是应该与对可能的错误的精确处理相配合。我们将在第8章学到更多的知识。</p>
</div>
<div class="paragraph">
<p>Recipe 5-2. Configure a Command-Line Command with Flags and Arguments</p>
</div>
<div class="paragraph">
<p>Problem</p>
</div>
<div class="paragraph">
<p>You need to invoke a script with different values from the command line.</p>
</div>
<div class="paragraph">
<p>Solution</p>
</div>
<div class="paragraph">
<p>Use the MAIN subroutine to determine how the program is going to be invoked. Multiple instances can be defined, permitting more efficiency in the invocation. Besides, it’s auto- documented, with a -h or -? generated automatically and an explanation of every one of the parameters and their values. MAIN is a normal subroutine, so it will also perform type checks for you and convert them from strings in the command line to the adequate format required by the program.</p>
</div>
<div class="paragraph">
<p>How It Works</p>
</div>
<div class="paragraph">
<p>At this point, we have a nice table of ingredients in a CSV file, and we might need some tool to consult it from the command line. For instance, how many vegan ingredients do we have? How many vegan side dishes? A command-line tool that used these as flags and gave us a list of ingredients would be really useful. We could use it to get a list that we could look up on the web to cook a recipe. We already have the ingredients on a CSV table in this form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csv" data-lang="csv">Ingredient;Unit;Calories;Dairy;Vegan;Main;Side;Protein;Dessert
Rice;100g;130;No;Yes;Yes;Yes;2.7;No
Chickpeas;100g;364;No;Yes;Yes;Yes;7;No</code></pre>
</div>
</div>
<div class="paragraph">
<p>So there are five different characteristics we can filter by: Dairy, Vegan, Main, Side, and Dessert. That will make five flags in all for our command-line program. This small program will do the trick:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Raku::Recipes::Classy;
sub MAIN( Bool :$Dairy, Bool :$Vegan, Bool :$Main, Bool :$Side, Bool :$Dessert ) {
    my %ingredients = Raku::Recipes::Classy.new().calories-table;
    my @flags;
    for &lt;Dairy Vegan Main Side Dessert&gt; -&gt; $f {
        @flags.push($f) with ::{"\$$f"};
    }
    my @filtered = %ingredients.keys.grep: -&gt; $i {
        my @checks =  @flags.map: -&gt; $k {
            %ingredients{$i}{$k} eq ::{"\$$k"}
        }
        so @checks.all;
    }
    say @filtered;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，我们使用一个面向对象的版本的卡路里表（现在包括了更多的东西），并将其加载到我们的程序中；我们将把它包含在 <code>%ingredients</code> 变量中。</p>
</div>
<div class="paragraph">
<p>让我们看看我们如何使用命令行标志。对于我们要检查的每一个，在专门命名的 <code>Main</code> 子例程的签名中都会有一个命名变量。因此，我们将为我们定义的五个过滤器中的每一个都有一个变量，并且我们强制它们为 Bool。标志的存在会将变量设置为 True；我们也可以通过使用 <code>--/</code>，如 <code>--/Dairy</code>，将标志设置为 False。例如，不属于副原料的主原料将用以下方式列出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku Chapter-5/filter-ingredients.p6 --Main --/Side</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果依次检查每一个变量会很麻烦，所以我们使用一个很好的 Raku 技巧来访问一个名字在变量中的变量的值: <code>::{"\$$f"}</code>。这就建立了一个变量的名称，其中会有美元（<code>/$</code>），然后是它的标识符，也就是变量 <code>$f</code> 的值。如果这个变量存在，我们就把它和过滤器一起添加到数组中。这个循环和声明其实可以缩短为这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @flags = &lt;Dairy Vegan Main Side Dessert&gt;.grep: { defined ::{"\$$_"} };</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样就有效地只过滤了那些被定义的变量。然后，我们通过对其键值运行 grep 来再次过滤成分列表：<code>@checks</code> 变量将包含一个将该成分的值与所需值进行比较的结果列表。这最终将是一个 <code>[True False True]</code> 形式的列表。但是我们需要该成分满足所有定义的条件，所以我们在其中创建一个 juncton: <code>@checks. all</code>。 Junction 对于比较来说是非常有用的；通过一个操作符，我们可以对一个列表中的所有元素进行操作（也可能同时使用自动线程），但在这种情况下，我们要做的是通过 <code>so</code> 将该值转换为一个 Bool 值返回。只有当列表中的所有元素都为真时，这个值才会为 True；<code>@filtered</code> 将包含所有条件为真的所有元素。例如，上一条命令的结果如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">[Tomato Kale Potatoes]</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些只是那些不能同时作为主菜的配菜。其他的，比如鹰嘴豆，可以是主料（炖鹰嘴豆或沙拉），也可以是配菜，所以它们不会被列入这个列表。一旦明确了这些命令的作用，我们还可以缩短它们，消除任何中间变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %ingredients.keys.grep: -&gt; $i {
        so all @flags.map:  { %ingredients{$i}{$_} eq ::{"\$$_"} };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>留下的程序，总之不到10行。</p>
</div>
<div class="paragraph">
<p>注意，这也会返回一个列表而不是数组，但这个细节不是那么重要。</p>
</div>
<div class="paragraph">
<p>作为一个附加值，使用 <code>MAIN</code> 会自动添加一个 <code>-h</code> 标志，所以当你运行这个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku -Ilib Chapter-5/filter-ingredients.p6 -h</code></pre>
</div>
</div>
<div class="paragraph">
<p>你得到的是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Usage:
  Chapter-5/filter-ingredients.p6 [--Dairy] [--Vegan] [--Main] [--Side]
[--Dessert]</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你在没有过滤的情况下运行会怎样？它将返回所有的成分。但它仍然会运行同样的代码；它的设计方式是，在没有过滤器的情况下，它可以做到这一点，但它仍然需要运行大量的代码来实现一些可以很容易实现的东西。为了解决这个问题，我们可以简单的定义多个 <code>MAIN</code>，使用 <code>multi</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Raku::Recipes::Classy;

multi sub MAIN() {
    say Raku::Recipes::Classy.new.products;
}

multi sub MAIN( Bool :$Dairy, Bool :$Vegan, Bool :$Main, Bool :$Side, Bool :$Dessert ) {
    say Raku::Recipes::Classy.new.filter-ingredients( :$Dairy, :$Vegan, :$Main, :$Side, :$Dessert );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We also added filter-ingredients to the Raku::Recipes::Classy class, containing the same code as before. This new version uses the multiple schedule mechanism: Raku will simply call the method or sub whose signature matches the call. In the case of the MAIN sub, it will call one or the other depending on the flags that are used. No flags?
It will call the first, which simply calls the method that returns the list of products or ingredients. Any flag? It will call the second. This is going to be marginally faster in this case, but conceptually it’s going to show the intent more easily.</p>
</div>
<div class="paragraph">
<p>What happens if we want to use additional filters, for instance, by minimum quantity of proteins or max number of calories? Let’s use this multiple schedule mechanism to add a new MAIN that will filter by minimum protein content. That’s an integer number, so we add that to the new MAIN’s signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># This is added to the previous example
multi sub MAIN(Bool :$Dairy, Bool :$Vegan, Bool :$Main,
           Bool :$Side, Bool :$Dessert,
           Int :$min-proteins) {
    my $rr = Raku::Recipes::Classy.new;
    my @filtered = $rr.filter-ingredients( :$Dairy, :$Vegan, :$Main, :$Side, :$Dessert );
    my %ingredients = $rr.calories-table;
    say @filtered.grep: { %ingredients{$_}&lt;Protein&gt; &gt; $min-proteins };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Actually, the only thing we added is a new statement that filters ingredients by the minimum amount of proteins; that’s the last one before the closing brace. Using the already known grep, we take the filtered list of ingredients (which is in @filtered) and check that the amount of proteins is higher than the amount requested. This will eliminate from the original list, filtered by characteristics, those with less protein content and produce something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku -Ilib Chapter-5/filter-ingredients-proteins.p6 --min-proteins=5 --Vegan
(Chickpeas Lentils Kidney beans)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This result shows that chickpeas, lentils, and kidney beans are not only delicious, but also nutritious. At home, we eat dishes based on those three ingredients at least twice a week.</p>
</div>
<div class="paragraph">
<p>In the same way we used a configuration file to get the data for generating a recipe
in this chapter, we can do this from the command line. The fact that we can add types to the arguments makes it much easier to catch errors in arguments before they get into the program, making it all much faster. Let’s repeat the recipe on reading configuration files with YAML using the command line this time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Raku::Recipes::Roly;
my $recipes = Raku::Recipes::Roly.new;

subset Main of Str where {
    $_ ∈ $recipes.products &amp;&amp; $recipes.check-type($_, "Main" )
};

subset Side of Str where {
    $_ ∈ $recipes.products &amp;&amp; $recipes.check-type($_, "Side" )
};

sub MAIN( Int :$calories = 500,
            Main :$main!,
            Side :$side! ) {
    my @recipe;
    for &lt;main side&gt; -&gt; $part {
        my $this-value = ::{"\$$part"};
        my %this-product = $recipes.calories-table{$this-value};
        my $portion = $calories/( 2 * %this-product&lt;Calories&gt;);
        @recipe.push: $portion *  %this-product&lt;parsed-measures&gt;[0] ~ " " ~
                %this-product&lt;parsed-measures&gt;[1] ~ " of " ~ $this-value.lc;
    }

    say "Use ", @recipe.join(" and ");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行程序的部分，最后八行，实质上是一样的。不同的是设置。我们不需要处理异常，因为 Raku 本身就会通过几种机制为我们处理。
- 我们创建了两个子集，Main 和 Side，只允许输入正确类型的值，并且包含在产品表中可用的产品集合中。除了这些值以外的任何值都会产生一个调用错误。
- 我们将两个变量 <code>$main</code> 和 <code>$side</code> 作为强制性变量。如果没有使用它们，程序将以相应的错误死掉。
- 如果添加了额外的键，我们不会产生错误，但用法字符串澄清了什么是强制性的，什么是可选的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Usage:
  Chapter-5/generate-recipe-cli.p6 --main=&lt;Main&gt; --side=&lt;Side&gt;
[--calories=&lt;Int&gt;]</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了获得其名称在另一个变量 <code>$part</code> 中的变量的值，我们使用与之前相同的技巧，查阅符号表：<code>::{"$/$part"};</code>。</p>
</div>
<div class="paragraph">
<p>如果这个变量在运行时缺失了 <code>main</code> 或 <code>side</code>，它将产生用法字符串。如果类型不正确，比如这里，它将产生同样的信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku -Ilib Chapter-5/generate-recipe-cli.p6 -Ilib --main=Sardines --side="Green kiwi"</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意 如果你想传递一个带有空格的产品作为参数，你必须使用引号。</p>
</div>
<div class="paragraph">
<p>这并不理想，因为并不清楚为什么这个参数没有通过。然而，你可以用更多的文档来补充简洁的信息。如果事实证明这对你的用例来说是不够的，只需转到使用配置文件的配方。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_5_3_在程序中使用_shell_环境变量">4.2. 食谱 5-3. 在程序中使用 Shell 环境变量</h3>
<div class="sect3">
<h4 id="_问题_13">4.2.1. 问题</h4>
<div class="paragraph">
<p>在云环境中，最好的做法是使用环境变量将所有信息传递给程序。它们在整个程序中也是可用的，所以在需要时可以读取它们。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_10">4.2.2. 解决办法</h4>
<div class="paragraph">
<p>所有的环境变量都可以通过 <code>%*ENV</code> 默认动态变量来读取，并以 <code>key</code> 作为变量名。</p>
</div>
</div>
<div class="sect3">
<h4 id="_如何工作_3">4.2.3. 如何工作</h4>
<div class="paragraph">
<p>最佳实践告诉你，一些信息应该被保存在环境变量中。这些变量是从 shell 中定义的，shell 让每个运行的程序都能使用。根据我们使用的 shell （或操作系统），我们会使用类似这样的变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">export CALORIE_TABLE_FILE=../data/calories.csv</code></pre>
</div>
</div>
<div class="paragraph">
<p>在=周围没有空格是很重要的；另外，传统上，它们的名称使用 ALL CAPS。在这种情况下，我们将告诉我们正在运行的程序，或者任何程序，在这个问题上，该文件将被放置在哪里。每个程序都会收到一份所有环境变量及其值的副本。每种语言都使用不同的调用或数据结构来使它们可用。在 Raku 的情况下，它是 <code>%<strong>ENV</code> 变量。<code>%</code> 符号表示它是一个关联变量，twigil <code></strong></code> 表示它是一个动态变量。动态变量的值类似于全局变量，但不是用全局范围定义，而是用调用者的范围定义。例程中的动态变量可以由调用者设置，也可以由调用者在子内部更改时有不同的值。</p>
</div>
<div class="paragraph">
<p>这个概念被延续到了自动变量上，当程序被实例化时，这些变量会得到一个值，比如这个程序，只是该变量的变化不会被输出到程序之外。它们只能在程序的其他地方使用。使用 <code>run</code> 启动的程序就会得到这个（可能是修改过的）实验的副本。</p>
</div>
<div class="paragraph">
<p>我们将在 <code>Raku/Recipes/Roly.pm6</code> 文件中这样使用变量的内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method new( $dir = "." ) {
    my $calorie-table-file = %*ENV&lt;CALORIE_TABLE_FILE&gt; // "$dir/data/
    calories.csv";
    my %calories-table = csv(in =&gt; $calorie-table-file,
                             sep =&gt; ';',
                             headers =&gt; "auto",
                             key =&gt; "Ingredient" ).pairs
    ==&gt; map( {
       $_.value&lt;Ingredient&gt;:delete;
       $_.value&lt;parsed-measures&gt; = parse-measure( $_.value&lt;Unit&gt; );
       $_ } );

for %calories-table.values -&gt; %ingredient {
    for %ingredient.keys -&gt; $k {
        given  %ingredient{$k} {
            when "Yes" { %ingredient{$k} = True }
            when "No"  { %ingredient{$k} = False };
        }
    }
};
@products = %calories-table.keys;
self.bless( :%calories-table, :@products );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个方法创建对象，对应的是第三章和第四章的配方。变化在前几行。我们检查那个环境变量是否被定义了，如果定义了，就设置我们要读到的文件名。如果没有定义，则使用实例化变量时定义的目录。实际上，这个值覆盖了我们在创建 Raku::Recipes::Roly 实例时用于目录的任何值。</p>
</div>
<div class="paragraph">
<p>有一点很好，那就是你不需要改变任何其他文件，改变的只是内部的实现。之前的食谱中使用的脚本仍然会以完全相同的方式工作。</p>
</div>
<div class="paragraph">
<p>我们会经常使用这种方法，主要是在将我们的应用程序部署到云端和定义 API 密钥时，例如。或者任何我们想要的时候，真的。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_5_4_为应用程序创建一个_docker_容器以便轻松地分发它">4.3. 食谱 5-4. 为应用程序创建一个 Docker 容器，以便轻松地分发它</h3>
<div class="sect3">
<h4 id="_问题_14">4.3.1. 问题</h4>
<div class="paragraph">
<p>您需要一种在任何云提供商中轻松部署应用程序的方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_11">4.3.2. 解决办法</h4>
<div class="paragraph">
<p>基于任何已发布的 Raku 映像，创建一个自足的 Docker 映像，可以在安装 Docker 的任何地方使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_16">4.3.3. 它是如何工作的</h4>
<div class="paragraph">
<p>Docker 容器是部署云应用的最佳方式，但也可以作为方便容器，在安装 Docker 客户端和服务器的任何地方部署命令，现在几乎无处不在。</p>
</div>
<div class="paragraph">
<p>Docker 可以创建映像，这些映像是与文件系统一起的应用程序，可以被修改并用于存储数据或结果，或者直接扔掉。这些 Docker 镜像最好的比喻就是下一个版本的可执行文件：你可以直接下载并运行它们，而不用担心安装任何东西，比如它们的依赖关系或它们所使用的语言。因此，你可以用它们来包装一个应用程序，以便在任何地方使用它。</p>
</div>
<div class="paragraph">
<p>我们将使用一个 Docker 容器来包装我们刚刚创建的脚本，这个脚本可以按类型过滤成分，也可以过滤最小量的蛋白质。假设你需要在其他任何地方得到你的命令行实用程序，它可以创建一个成分列表，并通过特征和蛋白质进行过滤。通常这将是云，但 Docker 容器可以在任何地方使用，事实上也是如此。</p>
</div>
<div class="paragraph">
<p>创建这些镜像的方法有很多，你可以简单地用基础镜像启动一个容器，安装所有需要的东西，然后推送镜像。你也可以把它上传到 Docker Hub 上，让大家都能使用。</p>
</div>
<div class="paragraph">
<p>但如果你使用 Dockerfile 会更好，它是一个配方，描述了如何将所有东西放入容器中，并包括运行它所需要做的事情。下面是你将使用的内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">FROM jjmerelo/alpine-raku:latest
LABEL version="0.0.2" maintainer="JJ Merelo &lt;jjmerelo@GMail.com&gt;"

ADD META6.json Chapter-5/filter-ingredients-proteins.p6 ./
RUN mkdir lib &amp;&amp; mkdir data
ADD lib/ lib
ADD data/calories.csv data

RUN apk update &amp;&amp; apk upgrade &amp;&amp; zef install . \
    &amp;&amp; chmod +x filter-ingredients-proteins.p6
ENTRYPOINT ["./filter-ingredients-proteins.p6"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>它依赖于一个已经包含 Raku、jjmerelo/alpine-perl6 的基础映像。你可以使用几乎任何一个，只要它的执行路径中有 raku 和 zef 作为可执行文件。我维护着那个镜像，并在它被生产出来后立即将其升级到最新的 Raku 版本（在写文章的时候是 2020.01）。如果因为任何原因不方便，你可以使用 Docker Hub 搜索其他的。这个镜像基于 Alpine Linux，这是一个极简主义的发行版，在 Docker 世界之外鲜为人知，但在那里相当流行。这个镜像的主要意图是创建一个结构紧凑、下载时间短的镜像。</p>
</div>
<div class="paragraph">
<p>Dockerfile 的命令都是大写的；接下来的 label，是给镜像添加元数据，可以用 Docker image 或者其他实用工具来检查。虽然不是很需要，但是很方便。</p>
</div>
<div class="paragraph">
<p>其余的真的非常简短。它创建了目录，这样就能在预期的地方找到文件。<code>zef install .</code> 将安装 Raku::Recipes 模块，以便它们在任何地方都可以使用，apk update 和 upgrade 是用于升级操作系统的 Alpine 命令，因为自从镜像创建以来，它可能已经改变了。</p>
</div>
<div class="paragraph">
<p>最后一个命令建立了一个入口点：如果 Docker 镜像被自己调用，这就是要运行的内容，这也是添加标志的地方。我们使用我们想要封装的程序，很明显，在运行之前，把它放在方括号里，表示标志将被附加到它上面。</p>
</div>
<div class="paragraph">
<p>我们要用 buildah 来构建这个镜像，buildah 是红帽的一个实用工具，可以构建 Docker 镜像。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-docker" data-lang="docker">buildah bud -f Dockerfile -t jjmerelo/raku-recipes:latest</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者也可以这样，如果你使用标准的 Docker 安装。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-docker" data-lang="docker">docker build -t jjmerelo/raku-recipes:latest .</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们就可以运行它了。Docker 镜像可以用几个实用程序来运行，当然包括这里使用的 Docker 客户端本身。我偏爱 podman，因为它是 OCI（Open Container Initiative）标准的实现。它不需要守护进程运行，而且速度略快。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-docker" data-lang="docker">podman run  -it --rm sh jjmerelo/raku-recipes:latest</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将打印整个成分列表，或者只打印</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-docker" data-lang="docker">podman run  -it --rm sh jjmerelo/raku-recipes:latest --Vegan</code></pre>
</div>
</div>
<div class="paragraph">
<p>只用于素食成分。这个标志将被传递给 ENTRYPOINT 定义的命令，它将以直接从命令行运行程序的方式运行。</p>
</div>
<div class="paragraph">
<p>使用 Docker 镜像是一种极其方便的方式，可以创建特定模块的测试容器，或者将 Web 服务运送到云端。我们稍后再来讨论这个问题。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_5_5_使用_etcd_进行高级分布式配置">4.4. 食谱 5-5. 使用 etcd 进行高级/分布式配置</h3>
<div class="sect3">
<h4 id="_问题_15">4.4.1. 问题</h4>
<div class="paragraph">
<p>您需要在云部署中获取配置值或任何其他相关信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方案">4.4.2. 解决方案</h4>
<div class="paragraph">
<p>使用 etcd，它是众多分布式键值存储中的一种。它允许我们设置将要在本地使用的值，并通过查询本地的联合 etcd 守护进程，在任何云实例中检索，它将与所有其他守护进程联系。如果需要的话，这可以安全地完成。这样一来，任何节点都可以发布只有在部署后才知道的本地值，如 IP、端口，或者仅仅是他们希望分布在分布式应用的所有部分和副本上的信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_17">4.4.3. 它是如何工作的</h4>
<div class="paragraph">
<p>只要你在单个节点中部署应用，使用命令行选项或环境变量是可以的。如果你想在云中的一个或几个节点中部署应用，设置环境变量可能会很麻烦，而且使用部署脚本来做也会带来一系列的问题，主要是任何东西都会被一劳永逸地设置。</p>
</div>
<div class="paragraph">
<p>使用分布式配置服务，比如 etcd，是一种简单、高效、安全的方式，可以将信息分布在部署的所有实例中。为了做到这一点，需要在每一个要部署的节点中安装 etcd，这些节点之间都要相互意识到。解释如何做到这一点超出了本书的范围，但你可以在网站 etcd.io 上查看安装选项。按照那里的说明安装 etcd 服务器和命令行客户端 etcdctl，这将在本食谱中使用。</p>
</div>
<div class="paragraph">
<p>我们将使用与之前使用环境变量相同的方式来使用 etcdctl：设置我们感兴趣的值（例如文件名）。我们可以使用下面的脚本来实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $can-haz-etcdctl = shell "etcdctl --version", :out;

my $output = $can-haz-etcdctl.out.slurp;
die "Can't find etcdctl" unless $output ~~ /"etcdctl version"/;

my $version = ($output ~~ / "API version: " (\d+) /);
my $setter = $version[0] ~~ /2/ ?? "set" !! "put";

sub MAIN( $key, $value ) {
    my $output = shell "etcdctl $setter $key $value", :out;
    my $set-value = $output.out.slurp.trim;
    if $value eq $set-value {
        say "🔑 $key has been set to $value";
    } else {
        die "Couldn't set $key to $value";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个脚本主要是对 etcdctl 命令行的一个包装，但是它有一个附加值，就是你不需要记住确切的语法，如果 etcdctl 没有安装，它就会失败，如果我们没有在命令行中使用键值对，它就会抱怨，因为我们在 MAIN 子的签名中使用了键值对。如果没有安装 etcdctl，它就会失败，如果我们没有在命令行中使用键值对，它就会抱怨，因为我们在 MAIN 子的签名中使用了键值对。如果我们做这样的事情:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku etc-set.p6 hey</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将写出以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Usage:
  etc-set.p6 &lt;key&gt; &lt;value&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序的关键功能是通过使用 shell 来实现的，这一点我们已经在专门介绍系统交互的章节中看到了。这个程序将按原样运行命令行参数，不试图检查或清理它们，这意味着如果它们只是包含一个 <code>&amp;&amp;</code> 或一个 <code>;</code>，就有可能运行其他程序。在这种情况下，这并不是问题，因为所产生的命令行将以与给它们赋值的用户相同的权限运行。然而，用户最好使用同样的方法在互联网暴露的后台运行程序。</p>
</div>
<div class="paragraph">
<p>使用 shell 例程并捕获输出，我们可以做几件事。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确定 etcdctl 是否在工作，是否在路径中可用。</p>
</li>
<li>
<p>由于我们捕获了这个命令的输出，我们用它来检查 API 的版本。当从版本2换到版本3时，值设置命令从 set 改为 put。版本2在一些发行库中仍然可以使用，所以我们需要照顾到这一点。</p>
</li>
<li>
<p>我们再用它来捕捉设置键的输出，etcdctl 如果正确地完成了设置，就会返回所设置的值，所以我们要检查它是否被正确设置了。由于 etcdctl 返回的值是带回车的，所以我们对它进行修剪，也就是说，我们把周围的空格都去掉，这样我们就只剩下值了。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后我们可以用这个脚本来运行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku etc-set.p6 filename data/calories.csv</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果一切正常，这将打印出以下内容（应该是这样，只要我们正确安装了 etcd）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">🔑 filename has been set to data/calories.csv</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们需要从我们的脚本中获取值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $can-haz-etcdctl = shell "etcdctl --version", :out;

my $output = $can-haz-etcdctl.out.slurp;
die "Can't find etcdctl" unless $output ~~ /"etcdctl version"/;

for @*ARGS -&gt; $key {
    my $output = shell "etcdctl get $key", :out;
    my $value = $output.out.slurp.trim;
    say "🔑 $key -&gt; $value";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在(必须的)检查了我们有一个 etcdctl 的工作副本之后，我们对命令行中设置的每一个键启动 etcdctl，捕获输出，然后打印一行键值对。</p>
</div>
<div class="paragraph">
<p>我们可以运行它并获得结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku etc-get.p6 innie foo filename
🔑 foo -&gt; bar
🔑 filename -&gt; data/calories.csv</code></pre>
</div>
</div>
<div class="paragraph">
<p>shell 命令是相当强大和灵活的，我们可以用它来连接任何可以从命令行运行的程序或 API，而大多数程序和 API 都可以。在许多情况下，这将是其他更有表现力的 API 的替代品，比如 gRPC，它在 Raku 中的支持现在还不是很完善。另外，NativeCall 接口可以用来将一个共享库绑定到 Raku，或者 REST API，如果有的话。然而，所有这些都需要更多的编程努力，所以在大多数情况下，从 Raku 中调用这些程序的 CLI 就足够了。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_自动化系统任务">5. 自动化系统任务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>为了在同一页面上，我们将使用一个基于 Debian 的 Docker 镜像来测试本章的配方。在大多数情况下，所有的 Linux 系统的工作原理都是完全一样的，但是如果你还没有使用一个系统，你可以为你的操作系统使用一个 Docker 安装，并从该镜像中检查配方。可以使用以下方式下载该镜像。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">docker pull jjmerelo/raku-recipes:Chapter-6</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以用以下方法运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">docker -it –rm --entrypoint bash jjmerelo/raku-recipes:Chapter-6</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将会给你一个 bash 提示，从这个提示中可以得到 Raku（和其他应用程序）。</p>
</div>
<div class="sect2">
<h3 id="_食谱_6_1_检查某些事件的日志">5.1. 食谱 6-1. 检查某些事件的日志</h3>
<div class="sect3">
<h4 id="_问题_16">5.1.1. 问题</h4>
<div class="paragraph">
<p>你需要检查系统日志，或任何其他类型的日志，检查某些事件，如反复尝试登录或任何类型的错误。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方法_8">5.1.2. 解决方法</h4>
<div class="paragraph">
<p>你可以对一些系统文件设置监视，并过滤你想知道的事件，你已经在第2章看到了如何做。你还可以使用生态系统中的 Sys::Lastlog 模块来识别最后登录的人（我们将在本章后面学习）。我们将使用第2章中的食谱 2-5 "观察文件的变化"和一组正则表达式（也许是用户定义的）组合来定义我们感兴趣的事件，然后将它们记录下来或打印到控制台。另外，我们还可以使用 Syslog::Parse，这是本书作者发布的一个模块，它将系统日志转换为一个供给，并包含一个解析 syslog 条目的语法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_18">5.1.3. 它是如何工作的</h4>
<div class="paragraph">
<p>Linux 系统日志中的每个条目都是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Feb 17 12:06:45 penny org.gtk.vfs.Daemon[5244]: ** (process:8299): WARNING
**: send_done_cb: No such interface 'org.gtk.vfs.Enumerator' on object at
path /org/gtk/vfs/client/enumerator/2 (g-dbus-error-quark, 19)</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先是发生某事的日期和时间。接下来是机器名称、引起输入的进程和方括号内的进程号。</p>
</div>
<div class="paragraph">
<p>在某些情况下，还有其他信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Feb 17 12:06:45 penny dbus[1450]: [system] Successfully activated service 'org.freedesktop.hostname1'</code></pre>
</div>
</div>
<div class="paragraph">
<p>方括号内的名称是指这是一条系统信息信息。而 <code>**</code> 则表示有比较严重的事情发生。syslog 格式在 RFC 5424 中是规范化的，它包括了整个远程日志的协议，所以可以从任何应用程序中读取和产生。</p>
</div>
<div class="paragraph">
<p>标准化的格式是一个很好的格式。我们可以对其进行处理。然后我们可以寻找我们感兴趣的东西。比如说，我们只看警告。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "/var/log/syslog".IO.lines.grep: /"-WARNING **"/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不过，这也太多了吧。很多台词，而且都是同时出现的。这就违背了警告的全部目的，那就是，嗯，警告你可能发生了一些不正常的事情。此外，这些实际上是 gnome 的警告；其他应用程序产生的警告可能会被忽略。例如，这些是 Docker 警告。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Feb 19 09:17:36 penny dockerd[2408]: time="2020-02-
19T09:17:36.865094510+01:00" level=warning msg="failed to rename /var/lib/
docker/tmp for background deletion: %!s(&lt;nil&gt;). Deleting synchronously"</code></pre>
</div>
</div>
<div class="paragraph">
<p>它们是小写的，在某些情况下，它们只是说&lt;警告&gt;。让我们试着考虑到所有这些情况。这段代码将做到这一点，并告诉你是谁发出的消息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @warnings = "/var/log/syslog".IO.lines.grep: /warn/;
for @warnings -&gt; $w {
    my ($metadata, $message) = $w.split( ": ", 2 );
    say "→ ", $metadata.split(/\s+/)[*-1],
        " has produced this message\n\t$message\n\n";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它会产生像这样的行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">→ gnome-session[5475] has produced this message
             Window manager warning: Window 0x4800022 (win0) sets an MWM hint indicating it isn't resizable, but sets min size 1 x 1 and max size 2147483647 x 2147483647; this doesn't make much sense.</code></pre>
</div>
</div>
<div class="paragraph">
<p>至少我们知道是谁干的。不过，剩下的信息还是让我们摸不着头脑，尽管我们可以用正则表达式来提取。或者更好的是，我们可以使用 Syslog::Parse 中包含的语法来理解这一切。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Syslog::Grammar;
use Syslog::Grammar::Actions;

"/var/log/syslog".IO.lines
    ==&gt; map( { Syslog::Grammar.parse( $_,
                                      actions =&gt; Syslog::Grammar::Actions.
                                      new ).made; } )
    ==&gt; grep( { $_&lt;message&gt; ~~ m:i/warn/ }  )
    ==&gt; my @lines;

for @lines -&gt; %w {
    say "⇒ %w&lt;actor&gt; has warned about\n\t%w&lt;message&gt;\n\tby $%w&lt;hour&gt;";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Syslog::Parse 中的语法可以理解行中的不同组件：有元数据和一个由冒号和空格分隔的消息（可能是空的）。但这些元数据是有结构的，比如日期或产生它的应用程序。我们可以使用该应用程序应用特定的过滤器来解读消息，或者只通过消息内容来过滤，而不是使用整行。</p>
</div>
<div class="paragraph">
<p>注意可能会有一个叫做 awarnia 的应用，会在警告过滤器中触发假阳性。</p>
</div>
<div class="paragraph">
<p>在语法解析的同时，语法动作会将解析后的内容转换成可用的东西，或者在事情发生时采取行动。在这种情况下，我们使用了默认的 Syslog::Grammar::Action，它创建了一个哈希，使用我们感兴趣的信息作为键。例如，它可以产生一个数据结构，比如这个。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">{
:actor("firefox.desktop"),
:day(19),
:hostname("penny"),
:hour("12:29:14"),
:message("... long message with warning ..."), :month("Feb"),
:pid(Any),
:user("∅")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然解析只会产生一个 Match 对象，其中包含了匹配中获得的原始字符串，但观察一下，例如，如果在消息中没有检测到用户，就会显示一个空集。脚本本身会产生一组结构化的警告，比如这个。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">⇒ firefox.desktop has warned about
    message repeated 2 times: [ [Child 11536, MediaDecoderStateMachine #1] WARNING: (some stuff)]
    by 12:29:14</code></pre>
</div>
</div>
<div class="paragraph">
<p>许多其他的过滤器是可能的，我们可以以许多不同的方式显示预处理的数据。我们将在下一个配方中深入研究这个问题。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_6_2_在控制台上交互式检查日志">5.2. 食谱 6-2. 在控制台上交互式检查日志</h3>
<div class="sect3">
<h4 id="_问题_17">5.2.1. 问题</h4>
<div class="paragraph">
<p>您希望在控制台中对某些日志进行警告，或许还可以对它们进行过滤。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_12">5.2.2. 解决办法</h4>
<div class="paragraph">
<p>生态系统模块如 Term::TablePrint 允许你在控制台上静态地检查数据表；你可以在调用它之前生成数据，并通过异步更新添加交互性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_19">5.2.3. 它是如何工作的</h4>
<div class="paragraph">
<p>一般来说，TUI（Terminal User Interface，终端用户界面）就是我们所说的面向整个控制台的应用界面，至少要设置成能与控制台全方位合作的界面。这样的界面并不是把东西打印到控制台，然后在上面消失。</p>
</div>
<div class="paragraph">
<p>虽然面向命令行的界面速度很快，会被存储在 CLI 历史记录中，并且可以重新编辑和使用，但有时你需要浏览一组项目，并根据上下文选择一个。比如说，你需要在检查系统中所有日志的同时，检查某个日志。而这一切都需要一个控制台，而不是面向行的用户界面。Term::TablePrint 在下面的脚本中救了我们一命。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Term::Choose :choose;
use Term::TablePrint;
use Libarchive::Filter;

my @files = dir( "/var/log", test =&gt; { "/var/log/$_".IO.f } );

while @files {
    my $file = choose( @files.map( *.Str ),
      :prompt("Choose file or 'q' to exit") );
    last unless $file;
    my $i;
    my $content;
    if $file ~~ /\.gz$/ {
        $content = archive-decode($file, filter=&gt;'gzip');
    } else {
       $content = $file.IO;
    }
    my @lined-file= $content.lines.map: { [ ++$i, $_ ] };
    print-table([ ['⇒',$file], |@lined-file ]);
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>再一次，这显示了 Raku 如何在没有大量指令的情况下做很多事情，但在这种情况下，这是由于我们使用了上述模块以及另外两个模块-- Term::Choose (由同一个作者 Matthäus Kiem 编写)和 Libarchive::Filter。</p>
</div>
<div class="paragraph">
<p>这个脚本是一个循环，它呈现了 <code>/var/log</code> 目录的内容（过滤后只包括文件，也就是不包括目录），并帮助我们通过游标键移动来选择一个文件。我们通过选择例程来实现。见图6-1。只有在有文件的情况下才会进入 <code>while</code> 循环（应该有），它将一直运行到用户按q键退出。当这种情况发生时， <code>$file</code> 变成空值，最后一条退出循环的命令被激活。</p>
</div>
<div class="paragraph">
<p>图6-1. 在所有的日志中选择一个文件</p>
</div>
<div class="paragraph">
<p>这个例程在 <code>$file</code> 变量中返回一个文件名，为了在屏幕上逐行显示文件，我们需要检查它是压缩文件还是简单文件。为了在屏幕上逐行显示文件，我们需要检查它是压缩文件还是简单文件。前者的类型会通过档案解码过滤器（来自 Libarchive::Filter），然后转换成一个有两列的表格 - 行数和行内容。如图 6-2 所示，在顶部添加一个带箭头的页眉和文件名。</p>
</div>
<div class="paragraph">
<p>图6-2. 以表格形式显示一个压缩文件</p>
</div>
<div class="paragraph">
<p>你可以用上下箭头逐行浏览，包括分页，完成后用 <code>q</code> 退出。这只需通过打印-表格顺序（来自 Term::TablePrint）来实现；<code>q</code> 是退出当前屏幕的默认键。</p>
</div>
<div class="paragraph">
<p>脚本的要点是来自三个不同模块的三个函数，都存在于生态系统中。将它们以不同的方式组合起来，你可以用一个简单的、面向屏幕的界面创建强大的系统管理脚本。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_6_3_检查_git_提交的模式和元数据或将它们存储起来">5.3. 食谱 6-3. 检查 Git 提交的模式和元数据，或将它们存储起来</h3>
<div class="sect3">
<h4 id="_问题_18">5.3.1. 问题</h4>
<div class="paragraph">
<p>源码控制是 Git 的代名词，有时你需要通过日志来衡量生产力，记录他们工作的问题，或者简单地绘制工作图表。访问文本日志很容易，但你需要解析它以获得可行的数据。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_13">5.3.2. 解决办法</h4>
<div class="paragraph">
<p>生态系统中有许多模块可以与 Git 合作。我们将检查它们，并使用最适合每个任务的模块。例如，Git::Log 可能是处理提交的最佳模块。</p>
</div>
</div>
<div class="sect3">
<h4 id="_如何工作_4">5.3.3. 如何工作</h4>
<div class="paragraph">
<p>比如你想知道，你在书中的实例库中的工作效率。你每天提交了多少次？</p>
</div>
<div class="paragraph">
<p>Git::Log 可以帮你解决这个问题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Git::Log;

git-log()&lt;&gt;
    ==&gt; map( { DateTime.new( $_&lt;AuthorDate&gt; ).Date } )
    ==&gt; classify( { $_ } )
    ==&gt; map( { $_.key ~ ", " ~ $_.value.elems } )
    ==&gt; sort()
    ==&gt; my @dates;
say @dates.join( "\n" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个很好的例子，使用 feed 操作符（我更喜欢叫它火箭，因为它把结果发射到下一个处理阶段）来创建一个操作管道，在尾端，得到你想要的东西。</p>
</div>
<div class="paragraph">
<p>让我们看看不同的阶段。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>git-log()</code> 进行了检查当前目录的 Git 日志的调用，默认情况下(这也是为什么应该从仓库的顶部目录调用的原因，如 <code>raku Chapter-6/commits-per-day.p6</code>)。这将返回一个标量，我们通过 <code>&lt;&gt;</code> 对其进行去容器化，从而得到它里面的哈希数组。经过这个阶段，我们就有了一个哈希数组，每一个哈希数组都包含了一个提交的信息，包括日期，也就是我们感兴趣的日期。</p>
</li>
<li>
<p>我们通过将 UTC 格式的时间转换为 DateTime 对象，将哈希数组映射为日期，然后进入 Date 部分。之后，我们就会得到一个 <code>20xx-yy-zz</code> 形式的对象数组。</p>
</li>
<li>
<p>我们通过简单地使用对象的字符串形式将数组对象分类成对。这些对子将以日期作为键，以相同日期的副本作为值的数组。我们需要更进一步，因为我们对每天的提交次数感兴趣。</p>
</li>
<li>
<p>我们将这些对映射成一个字符串，这个字符串的键（日期），与值之间用逗号隔开，逗号是该日期在日志中出现的次数。它是无序的，因为哈希是有保证的。</p>
</li>
<li>
<p>我们对结果进行排序，使较早的日期先出现。然后我们将它们发送到一个数组中。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>我们可以对这个数组做任何我们想做的事情，但是我们选择把它打印成一个单一的字符串，每一个元素都用回车(<code>\n</code>)隔开。就是这样。我们可以用稍微不同的方法来确定每个作者的提交次数 (本例中没有，因为这里只有一个作者)，甚至可以检查每个月或每周一天的生产率。比如说，我们来检查一下。</p>
</div>
<div class="paragraph">
<p>注意，它只是引起了我的好奇心。</p>
</div>
<div class="paragraph">
<p>我们需要修改前面脚本中的几项内容，以便按一周中的某一天来检查生产率。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @dow = &lt;Nope Mon Tue Wed Thu Fri Sat Sun&gt;;
git-log()&lt;&gt;
    ==&gt; map( { DateTime.new( $_&lt;AuthorDate&gt; ).day-of-week } )
    ==&gt; classify( { $_ } )
    ==&gt; sort()
    ==&gt; map( { @dow[$_.key] ~ ", " ~ $_.value.elems } )
    ==&gt; my @dates;
say @dates.join( "\n" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于一周的日子是从1开始编号的，所以我们在 <code>@dow</code> 数组的0索引中插入一个虚元素，这样我们在使用它们时就不用对它进行操作了。排序和最后一个映射的位置已经被颠倒了（反正我们在前面的例子中也是这样做的，也没有什么关系），所以我们是按照天数来分类的，而不是按照名字的字母顺序来分类的（这也没有什么关系）。我们没有直接使用键来生成数组，而是将其作为周名的索引。这就是结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Mon, 15
Tue, 15
Wed, 20
Thu, 36
Fri, 15
Sat, 25
Sun, 39</code></pre>
</div>
</div>
<div class="paragraph">
<p>有去我的周末&#8230;&#8203;</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱6_4_清理你的_docker_镜像商店问题">5.4. 食谱6-4. 清理你的 Docker 镜像商店问题</h3>
<div class="paragraph">
<p>当使用 Docker 容器时，你最终会有许多未完成的构建，你只用过一次的镜像，以及其他你根本不需要的镜像。</p>
</div>
<div class="sect3">
<h4 id="_解决办法_14">5.4.1. 解决办法</h4>
<div class="paragraph">
<p>使用 Docker::API（生态系统中的一个模块）来执行此任务和其他 Docker 相关任务。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_20">5.4.2. 它是如何工作的</h4>
<div class="paragraph">
<p>首先，您需要从生态系统中下载此模块。按照说明安装它，包括额外的外部库。注意，这个配方不需要从 Docker 容器内运行。
安装模块的提示说明包含在本书仓库中的 <code>Chapter-6/README.md</code> 中。在每个章节目录中，都有一个特定章节的 META6.json 将让你使用 <code>zef install -deps-only</code> 安装所需的模块。</p>
</div>
<div class="paragraph">
<p>如果你已经使用了一段时间的 Docker，你会有很多你可能不需要的镜像。有一系列的脚本定期运行（例如从 cron 作业中）为你做清理工作是很方便的。你显然可以使用 Raku 来清理 Docker 镜像。</p>
</div>
<div class="paragraph">
<p>考虑所谓的 dangling images，这是构建图像的部分结果的图像或图层，并不是任何已标记的图像的一部分。这意味着再往后的构建失败了。你仍然可以使用这些图像，事实上，有些东西可能已经建立在它们上面。例如，如果你创建了一个通过ID调用这样一个图像的容器，你可能会使用它们。</p>
</div>
<div class="paragraph">
<p>让我们使用这个 Raku 脚本来摆脱任何挂起的镜像。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Docker::API;
my Docker::API $docker-api .= new;
my @images = $docker-api.images( dangling =&gt; True )[];

for @images -&gt; %i {
    say "Trying to delete %i&lt;Id&gt;";
    $docker-api.image-remove( name =&gt; %i&lt;Id&gt; );
    CATCH {
        default {
            if .message ~~ /"being used"/ {
                say "Image %i&lt;Id&gt; not deleted, since it's being used";
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>和往常一样，这是一个非常短的脚本，它能很好地完成工作。它基本上是三行代码，加上定义、消息和赋值。</p>
</div>
<div class="paragraph">
<p>前两行创建了一个 <code>$docker-api</code> 对象，它是 Docker API 的面向对象接口。它不能做任何 Docker 命令行不能做的事情，但它可以方便地处理图像，获取它们的信息，或者删除它们，这就是我们将要做的事情。</p>
</div>
<div class="paragraph">
<p>我们将只获取悬空的镜像：<code>$docker-api.images( dangling &#8658; True )[]</code>。所有 API 命令都可以包含一个过滤器，这将使它只返回那些具有特定属性的图像。<code>@images</code> 数组将只有这些图片，以及所有的属性，尤其是ID，这是我们用来删除它们的句柄。</p>
</div>
<div class="paragraph">
<p>在这些镜像的循环里面，我们发出相应的命令，通过ID来删除这些图片。但是，有时候会失败，而且会出现异常。这就是为什么我们有 CATCH 块的原因：如果命令失败了，模块会捕捉到这个异常，并打印一个有用的信息，继续进行下一个删除（而不是以错误的方式停止程序）。</p>
</div>
<div class="paragraph">
<p>在我的系统中，它打印的内容是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Trying to delete sha256:d20dfd5d508913ce0516b16f16f05cef5a9eac541372284db080f634d2e77b94
Image sha256:d20dfd5d508913ce0516b16f16f05cef5a9eac541372284db080f634d2e77b94 not deleted, since it's being used
Trying to delete sha256:47306096984d543f8c6fcfbedabbfb49debc9eb81fbd8605fe7a1ca517a0d593
Image sha256:47306096984d543f8c6fcfbedabbfb49debc9eb81fbd8605fe7a1ca517a0d593 not deleted, since it's being used
Trying to delete sha256:ab6c614ae59e2a640662179ad1e311f0c542f8404b9cb92935cc2e4f31cc9eae
Trying to delete sha256:22c0389a61f83e2f1d9a4ad16b7d2f9790dfd0458defbc2b687e8acfa75c590b
Trying to delete sha256:bf9a0c98b8a3dd48a313642dd014759dfe36625e0b2a2c0b35ed3c8d095b6e6c</code></pre>
</div>
</div>
<div class="paragraph">
<p>这表明，大部分的悬空图像都被删除了；但是，有些图像无法删除，我们已经被告知了。</p>
</div>
<div class="paragraph">
<p>事实上，Docker::API 是一段不错的代码，但由于我们也知道如何与命令行程序交互，所以我们可以直接用命令行工作。这个 API 简化了交互，给 Docker 提供了一个类似于 Raku 的接口，这样我们就不用担心命令行语法及其标志的复杂性，我们也可以处理来自我们程序的错误。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_6_5_处理最后一个登录你系统的人">5.5. 食谱 6-5. 处理最后一个登录你系统的人</h3>
<div class="sect3">
<h4 id="_问题_19">5.5.1. 问题</h4>
<div class="paragraph">
<p>作为系统管理员，您需要知道最后连接到系统的人，以防止入侵或检查系统的使用情况。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方法_9">5.5.2. 解决方法</h4>
<div class="paragraph">
<p>使用 Sys::Lastlog，生态系统中的一个模块。它是如何工作的</p>
</div>
<div class="paragraph">
<p>作为一个 Linux 系统的系统管理员，你可以随时发出 lastlog 命令，它将告诉你用户表中的每个用户最后一次登录的时间。然而，你可能无法访问控制台，或者可能希望有程序访问权，这样它就会被记录下来，它就会发出警报，或者其他什么。</p>
</div>
<div class="paragraph">
<p>Sys::Lastlog 来救你了。这是一个基于 UNIX 系统（包括 OSX）的接口，可以帮助你处理日志。</p>
</div>
<div class="paragraph">
<p>首先，你必须做一些事情让它在 Docker 容器内工作，因为用户实际上不会在容器内登录。让我们用下面的方法来运行它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">docker run -itu root -v 'pwd':/home/raku --entrypoint sh jjmerelo/raku-recipes:Chapter6</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样，你就可以用超级用户的权限（就是 <code>-itu root</code> 的 <code>u root</code> 部分）来运行。你需要为一个用户创建一个密码，这样你就可以用它来登录。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">passwd rakurecipes</code></pre>
</div>
</div>
<div class="paragraph">
<p>(在这个容器中定义的用户是 raku，你可能不想为这个用户设置密码。另外，你也可以使用一些其他的空闲用户，比如 uucp 或 www-data。) 你可以给它任何你想要的密码并重复它。然后你可以从命令行登录。</p>
</div>
<div class="paragraph">
<p>login rakurecipes 然后做任何事情或注销，这并不重要。</p>
</div>
<div class="paragraph">
<p>如果你使用的是像 Ubuntu 这样的 UNIX 系统，你不需要这样做，但是如果你使用的是 Cygwin 或者 Windows Linux 子系统，你可能需要做类似的事情。</p>
</div>
<div class="paragraph">
<p>例如，让我们尝试获取一个登录用户的列表以及他们登录的时间。这个脚本可以做到这一点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Sys::Lastlog;
say .user.username, ", ", .entry.timestamp
    for Sys::Lastlog.new().list.grep: *.entry.time &gt; 0;</code></pre>
</div>
</div>
<div class="paragraph">
<p>其实这只是一行代码，但我们先来研究一下循环。Sys::Lastlog 是一个面向对象的接口，所以我们需要创建一个对象来使用它。一旦我们有了这个对象，我们就通过 <code>.list</code> 方法获得系统中最后一次登录的列表。这些元素中的大部分将是从未登录过的用户（例如 daemon 或 backup 等系统用户），所以我们需要只过滤那些至少登录过一次的用户。通过使用 grep，我们只得到列表中最后一次登录时间大于0的元素。<code>*.entry</code> 将是一个类型为 Sys::Lastlog::Entry 的对象，它代表 lastlog 文件中的每一个元素。其中一个元素是时间，如果该用户从未登录过，则时间为0。</p>
</div>
<div class="paragraph">
<p>在循环里面，我们隐式地使用隐式变量 <code>$_</code>；即 <code>.user</code>。</p>
</div>
<div class="paragraph">
<p>username 相当于 <code>$<em>.user.username</code>，而 <code>$</em>.user</code> 将是一个类型为 Sys::Lastlog::UserEntry 的对象，它将包含该条目所涉及的用户信息，从系统用户表中收集。<code>.entry.timestamp</code> 将以标准格式打印最后的登录时间。在我们的容器中，我们可能会看到这样的内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">rakurecipes, 2020-02-15T17:19:12Z</code></pre>
</div>
</div>
<div class="paragraph">
<p>而在我自己的系统中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">jmerelo, 2019-05-20T21:43:46Z</code></pre>
</div>
</div>
<div class="paragraph">
<p>一般来说，在 Raku 生态系统中寻找能够完成常规系统管理任务的脚本是个好主意。如果这样的脚本不存在，您可以创建自己的脚本。您将在下一章中看到如何做到这一点。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_处理错误">6. 处理错误</h2>
<div class="sectionbody">
<div class="paragraph">
<p>错误得到了不好的名声，只是因为他们使它看起来像什么是错的，这是你的错。不应该是这样的。错误通常是应用程序和与之交互的人&#8212;&#8203;程序员或最终用户&#8212;&#8203;之间的误解。</p>
</div>
<div class="paragraph">
<p>那么我们的责任就是确定误解是什么，并在一定程度上找出应用程序所期望的东西。设计错误（为了简洁起见，我们称它们为错误，当我们指的是误解时）和它们所传递的信息是让应用程序或模块恰到好处的一个重要部分。在这一章中，我们正是关注这个问题。</p>
</div>
<div class="sect2">
<h3 id="_食谱_8_1_设计一个异常层次结构">6.1. 食谱 8-1. 设计一个异常层次结构</h3>
<div class="sect3">
<h4 id="_问题_20">6.1.1. 问题</h4>
<div class="paragraph">
<p>防御性的代码设计方法要求对异常进行优雅和类型安全的处理。每一段代码都必须有自己的异常集，因为系统提供的异常不足以完全解释为什么会发生意外事件。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方案_2">6.1.2. 解决方案</h4>
<div class="paragraph">
<p>加上你设计的类层次结构，Raku 应用程序常规地添加了一个 <code>X::</code> 类集，并传递精确而有意义的消息。这些错误类是 <code>Exception</code> 类的子类，但它们可以被定制，至少可以通过消息来定制。在您的模块或库中使用它们与传统的异常一起使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_21">6.1.3. 它是如何工作的</h4>
<div class="paragraph">
<p>我们已经在第六章中使用了一组异常来描述配置文件可能出现的问题。但是，我们没有展示代码，所以在这里。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Raku::Recipes::Roly;

class X::Raku::Recipes::WrongType:api&lt;1&gt; is Exception {
    has $.desired-type is required;
    has $.product;
    has $.actual-types;
    submethod BUILD(:$!desired-type,
                    :$!product = "Object") {
        my $rrr = Raku::Recipes::Roly.new();
        if $!product ne "Object" {
            $!actual-types = $rrr.calories-table{$!product}&lt;types&gt;
        }
    }

    multi method message( X::Raku::Recipes::WrongType $x where $x.product eq "Object": ) {
        return "The product if not of the required type $!desired-type";
    }
    multi method message() {
        return "$!product is not of the required type
                    «$!desired-type», only types $!actual-types";
    }
}

class X::Raku::Recipes::WrongUnit:api&lt;1&gt; is Exception {
    has $!desired-unit is required;
    has $!unit;

    submethod BUILD(:$!desired-unit,
                    :$!unit) {}
    method message() {
        return "$!unit does not match the unit type, should be $!desired-unit";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这两个异常在同一个文件中: <code>X/Raku/Recipes.pm6</code>。它们所传达的信息不同，它们的命名也是为了清楚地传达这一信息。<code>WrongType</code> 明确表示这不是代码所期望的那种东西，而 <code>WrongUnit</code> 则表示计量单位不正确。所有这些都发生在食谱的上下文中，所以很清楚我们在说什么。如果我们抛出一个异常，比如第一个异常，使用默认值，也就是 <code>Object</code>，如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">The product is not of the required type Main  in block &lt;unit&gt; at
/home/jmerelo/progs/perl6/raku-recipes-apress/t/00-exceptions.t line 9</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，该消息指出了抛出异常的位置。<code>&lt;unit&gt;</code> 表示这是测试文件第9行声明的一个块。在该上下文中，我们可能没有更多关于所需对象的信息，这就是为什么我们使用默认值。</p>
</div>
<div class="paragraph">
<p>然而，我们使用多个调度来根据我们所拥有的信息抛出不同的信息。如果我们知道产品，我们可以找出产品有哪些类型。在这种情况下，异常将看起来像这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Apple is not of the required type «Main», only types Dessert Vegan</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些类型是从我们在异常 <code>BUILD</code> 阶段创建的 <code>Raku::Recipes::Roly</code> 对象中获得的，也可以作为对象的属性。</p>
</div>
<div class="paragraph">
<p>我们正在使用的多重调度有一个有趣的方面：它是根据对象本身的值来完成的。关于 Raku 签名的一个有趣的地方是，你可以使用调用者作为该签名的一部分，除此之外，这允许你约束值并根据它进行调度。</p>
</div>
<div class="paragraph">
<p>除此以外，这两个异常有相同的结构：它们是 <code>Exception</code> 的子类，是 Raku 提供的这类东西的基类。你可以顺着它，不提供其他任何东西，让异常的类型通过它的名字强行沉淀下来。你也可以重写消息方法来提供特定的消息。你还可以提供属性，允许对消息进行某种个性化处理。</p>
</div>
<div class="paragraph">
<p>好吧，这是错误的类型，但什么才是正确的类型呢？对于 <code>WrongType</code>，<code>$!wired-type</code> 将提供该信息，它还将指示所提供产品的类型。一般来说，任何类型的异常都应该明确上下文，并为程序员以及用户提供一条出路，用户可能需要告知开发团队出了什么问题，或者尝试用不同的输入或操作序列来克服错误。</p>
</div>
<div class="paragraph">
<p>我们还注意到哪个产品缺失了，哪个部分是需要的。在每一种情况下，这些属性都是必需的，因此，除非提供信息，否则不能实例化对象。在这三种情况下，<code>BUILD</code> 子方法提供了一种方法来将 <code>new</code> 中提供的参数绑定到属性上。在第五章，我们学习了如何使用它们。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Check out the whole program in Chapter 5 when %conf{$part} ∉ $recipes.products {
    X::Raku::Recipes::ProductMissing.new( :product(%conf{$part}) ).throw()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而，我们可以做得更好。在大多数情况下，我们处理的是缺少的东西。我们只需要指定缺少的东西的类型和缺少的东西的名称。我们可以分拆一个层次结构来处理这个问题，或者是一个可组成的层次结构。接下来我们就来做这个事情。首先，角色。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role X::Raku::Recipes::Missing:api&lt;1&gt; is Exception {
    has $!part is required;
    has $!name is required;
    submethod BUILD( :$!part, :$!name ) {}
    method message() {
        return "the $!part $!name seems to be missing. Please provide it";
    }
    method gist(X::Raku::Recipes::Missing:D: ) {
        self.message()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，请注意我们在声明类的时候指定了 <code>api</code> 属性。Raku 允许类和模块的版本化（也允许作者）。这块元数据主要可以用来在你试图使用一个已经被取代的类时发出警告。一个说明"这个类没有正确的 API 版本"的错误比"找不到类"的信息量大得多。由于我们已经重构了这个模块，我们给了它一个 API 编号，以说明我们将使用这个 API 版本。没有 API 版本也等同于 API 0 版本。</p>
</div>
<div class="paragraph">
<p>所有这些异常都是面向用户的，并不是真正针对其他程序员的。这也是为什么我们重载了 <code>gist</code> 的原因；这样做的主要作用是避免打印异常抛出的行的信息。<code>gist</code> 方法是当你在一个对象上调用 <code>say</code> 的时候，所以当异常被抛出并打印出来的时候，才会被调用。</p>
</div>
<div class="paragraph">
<p>每当你想重用属性的时候，最好使用角色而不是类。也就是组成而不是子类（或继承），因为 Raku 中的类属性是私有的。子类将无法访问类的属性，除非你声明它们是公开的，而你可能不想这么做。然而，组成的属性仍然是私有的，你仍然可以访问它们。这些属性都将是强制性的。而当没有更多具体的类的时候，我们可以直接把这个角色作为一个异常，通过惩罚来抛出。不过，上面的类可以通过这样组成这个角色来重新制定。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class X::Raku::Recipes::Missing::Part does X::Raku::Recipes::Missing {
    submethod BUILD( :$!part="part of meal", :$!name) {}
}

class X::Raku::Recipes::Missing::File does X::Raku::Recipes::Missing {
    submethod BUILD($!part = "file", :$!name) {}
}

class X::Raku::Recipes::Missing::Product does X::Raku::Recipes::Missing {
    submethod BUILD($!part = "product", :$!name) {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建一个表现型的基类角色确实简化了其余层次结构的创建。新的类将组成基类，但它们要做的就是给一个属性分配一个默认值，在这种情况下是 <code>$!part.message()</code> 方法将从基础角色中重用，我们将能够在程序中直接使用它们。</p>
</div>
<div class="paragraph">
<p>以前，我们在应用程序中只使用异常。由于我们添加了一个新的异常，抱怨文件丢失，我们可以重写 <code>Raku::Recipes::Roly</code> 角色的一部分来包含它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method new( $dir = "." ) {
    my $calorie-table-file = %*ENV&lt;CALORIE_TABLE_FILE&gt; // "$dir/data/calories.csv";
    X::Raku::Recipes::Missing::File.new(:name($calorie-table-file)).throw
            unless $calorie-table-file.IO.e;
    # Rest remains the same as in the previous chapters
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以前，如果找不到文件，下一条语句就会失败。现在我们检查它是否存在，如果不存在，就会抛出一个异常，说找不到它。</p>
</div>
<div class="paragraph">
<p>添加一个异常类层次结构会给你的应用程序增加价值：它允许程序员立即将异常归零，并有选择地捕获和处理它们。它允许他们忽略非关键的异常（或者简单地发出警告），并在应用程序的上下文中，为那些不能被忽略的异常提供有意义的消息，特别是当默认消息在上下文中无法理解时。接下来我们就来看看如何做到这一点。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_8_2_向用户传递有意义的错误信息">6.2. 食谱 8-2. 向用户传递有意义的错误信息</h3>
<div class="sect3">
<h4 id="_问题_21">6.2.1. 问题</h4>
<div class="paragraph">
<p>使用你的代码的开发人员应该能够了解由于描述性异常或错误抛出而导致的失败或不能按预期工作时发生了什么。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_15">6.2.2. 解决办法</h4>
<div class="paragraph">
<p>提供一个全面的异常层次结构，使用代码的回溯来进一步帮助用户，并在信息中清楚地表达你在代码中期待的东西和你得到的东西。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_22">6.2.3. 它是如何工作的</h4>
<div class="paragraph">
<p>如果不勾选，一个异常就会炸毁你的程序。它将在用户可能并不完全清楚的情况下这样做，因为它不需要任何关于问题所在的信息。然而，异常携带了大量的信息，你可以利用它们来为最终用户&#8212;&#8203;正在运行程序的人或者我们班上那个程序在她面前失灵的客户提供尽可能多的信息。我们将在下一节中看到如何捕捉这些错误。这个配方将相当实用，并将提供一系列的成分，使你提供的例外情况从错误命名的肩膀上摘下一点坏名声。</p>
</div>
<div class="paragraph">
<p>即使你没有设计过类层次结构，你也可以使用标准库中的一个异常。它们真的有上百个，但它们主要是为了涵盖代码解释和执行过程中发生的异常而设计的。有几个你可以用在自己的代码中。<code>X::TypeCheck</code> (<a href="https://docs.raku.org/type/X::TypeCheck" class="bare">https://docs.raku.org/type/X::TypeCheck</a>) 和 <code>X::Obsolete</code> (<a href="https://docs.raku.org/type/X::Obsolete)。" class="bare">https://docs.raku.org/type/X::Obsolete)。</a> 你可能也会发现 <code>X::NYI</code>，也就是"尚未实现"的意思，很有用。</p>
</div>
<div class="paragraph">
<p>例如，在本章中，我们创建了一个新版本的 X::Raku::Recipes 类，包括一个新版本的 X::Raku::Recipes::WrongType。我们可以这样重新编写它的代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class X::Raku::Recipes::WrongType:api&lt;0&gt; {
    submethod BUILD() {
        X::Obsolete.new(old =&gt; "X::Raku::Recipes::WrongType:api&lt;0&gt;",
            replacement =&gt; "X::Raku::Recipes::WrongType:api&lt;1&gt; in Raku::Recipes",
            when =&gt; "using Raku::Recipes"
        ).throw;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你尝试使用它时，它将打印以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Unsupported use of X::Raku::Recipes::WrongType:api&lt;0&gt;; using Raku::Recipes
please use X::Raku::Recipes::WrongType:api&lt;1&gt; in
Raku::Recipes
  in submethod BUILD at /home/jmerelo/progs/perl6/raku-recipes-apress/
  lib/X/Raku/Chapter5/Recipes.pm6 (X::Raku::Chapter5::Recipes) line 6
  in block &lt;unit&gt; at /home/jmerelo/progs/perl6/raku-recipes-apress/t/00-
  exceptions-chapter-5.t line 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>这条信息内容相当丰富。它把皮毛放在了前面。使用新版本的 API 1，而不是这个旧版本。然后它显示了所谓的回溯，也就是一切发生的地方。底部是在 X::Raku::Chapter5::Recipes 文件的第6行，我们从测试脚本的第4行调用了这个文件。回溯其实是一个可以从 <code>Exception</code> 基类中使用的对象，它包含了一个帧的列表，这些帧是显示异常冒泡经过的栈帧部分的对象。通过 <code>gist</code> 方法完成的渲染异常的默认方式是将这些帧从下到上排列出来</p>
</div>
<div class="paragraph">
<p>我们已经看到了如何通过完全消除背框来覆盖这种行为。你也可以做完全相反的事情：把它打印得更漂亮，使信息突出。我们接下来会这么做。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Raku::Recipes;
use Colorizable;

class X::Raku::Recipes::Obsolete is Exception {
    has $!old-stuff is required;
    has $!new-stuff is required;

    submethod BUILD( :$!old-stuff, :$!new-stuff) {}
    method message() {
        return "You seem to be using $!old-stuff, which is deprecated. Please switch to $!new-stuff";
    }
    multi method gist(X::Raku::Recipes::Obsolete:D: ) {
        my @nice-bts = self.backtrace.list.grep( ! *.is-setting() );
        @nice-bts.shift;

        my $output = ("Hey! " but Colorizable).colorize: :mo(bold);
        $output ~= ( self.message but Colorizable).colorize: :mo(underline);
        $output ~= "\nThis happened on ⇒\n";

        for @nice-bts -&gt; $bt {
            $output ~= (("\t» Line " ~ $bt.line()) but Colorizable).colorize: blue;
            my $subname = ($bt.subname eq "&lt;unit&gt;") ?? "an anonymous routine"
                                                    !! $bt.subname;
            $output ~= " in " ~ ($subname but Colorizable).colorize: cyan;
        }
        return $output;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们已经创建了我们自己的，蓬松的，Obsolete 异常的版本，我们通过重写 <code>gist</code> 方法来实现。请记住，当你想说一个对象时，这个方法就会被调用，而当一个 Exception 被抛出时，它就会被大声说出来（除非它被捕获，我们接下来会做）。作为一个口诀，它就是 "口诀中的异常"（但它是为每个对象定义的）。总之，这个新的异常子类为 exception，这意味着它自动得到一个回溯。异常中有一些无趣的部分，我们把它们去掉。我们的做法是消除那些属于设置的部分，也就是说基本上如果有一部分是发生在系统库里面的，我们就不想知道。在这种情况下，我们消除了异常本身内部发生的部分回溯，因为我们使用的是基类的 throw。</p>
</div>
<div class="paragraph">
<p>我们是用 shift 来消除第一帧。在这个特殊的情况下，这并不有趣，因为我们感兴趣的是你在哪里试图使用过时的类。而这些是唯一剩下的东西。</p>
</div>
<div class="paragraph">
<p>对于这些，我们使用 Colorizable，这是一个由 Luis Uceta 在2020年3月发布的模块，它是一种很好的创建彩色信息的方法。为了给一个字符串着色，首先你必须混入 Colorizable 角色，就像这样: (<code>"Hey! " but Colorizable</code>)。一旦完成，你就可以在字符串上调用 <code>Colorize</code>，然后给它赋予模式（如粗体或下划线）和颜色（我们稍后会用到）。因此，我们打印一条友好的信息，然后为每一条回溯打印一行，解释这是它发生的地方。我们还把 <code>&lt;unit&gt;</code> 变成"匿名例程"。这就是我们在这个例子中调用它的地方。在程序中，它将显示例程的名称和文件中它发生的行。图8-1显示了一个将被打印的例子。</p>
</div>
<div class="paragraph">
<p>图8-1. 友好的错误信息，解释了回溯和信息的内容</p>
</div>
<div class="paragraph">
<p>循环线比看起来更啰嗦，但本质上它们所做的是提取那些信息位，比如 <code>$bt.line</code> 和 <code>$bt.subname</code>，以那种特殊的方式打印出来。</p>
</div>
<div class="paragraph">
<p>这一节的主要内容，反正不是什么技术性的东西。设计错误信息很难，但它是你对外的窗口。设计得好的消息会让你在项目中的问题形态上节省技术支持。一个设计良好的异常信息，只有让用户确定发生了什么，在哪里发生的，如果可能的话，在哪里修复它的信息，是一个防御性的编程，将在未来为你节省很多麻烦。所以要努力创建和传递最好的异常信息。</p>
</div>
<div class="paragraph">
<p>Recipe 8-3. Catch and Deal with Errors in Your Program</p>
</div>
<div class="paragraph">
<p>Problem</p>
</div>
<div class="paragraph">
<p>Errors can’t simply go unchecked. You should capture them and provide a way out if possible, or simply go ahead with them.</p>
</div>
<div class="paragraph">
<p>Solution</p>
</div>
<div class="paragraph">
<p>Raku uses block-scoped catch statements to capture errors. Use them, along with Raku control structures, to provide solutions to exceptions that often depend on the type of exception thrown.</p>
</div>
<div class="paragraph">
<p>How It Works</p>
</div>
<div class="paragraph">
<p>Exceptions would not be as useful if there was no way to overcome them. The terminology talks about throwing or raising exceptions, so it’s only fair that dealing with them is called catching them. Since we have class-y exceptions, the blocks that catch them will have to deal with every class in a different way.</p>
</div>
<div class="paragraph">
<p>Let’s try to put this to use in a seemingly simple, but underlyingly complex, script. It generates a recipe by assigning some amount of food to the main disk and to a side dish and returns how many calories the meal has. The main and side dishes will be entered at the command line. But what if there’s an error? Let’s deal with it this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use Raku::Recipes::Calorie-Computer;
use X::Raku::Recipes;
use X::Raku::Recipes::Missing;

my $rrr = Raku::Recipes::Calorie-Computer.new();
my $main = @*ARGS[0] // "Chickpeas";
my $side = @*ARGS[1] // "Rice";
my $calories = $rrr.calories-for( main =&gt; $main =&gt; 200,
                                  side =&gt; $side =&gt; 250 );

say "Calories for a main dish of $main and side of $side are $calories";

CATCH {
    default {
        given .message {
            when /Main/ || /$main/ { $main = "Chickpeas" }
            when /Side/ || /$side/ { $side = "Rice" }
        }
        $calories = $rrr.calories-for( main =&gt; $main =&gt; 200,
                side =&gt; $side =&gt; 250 );
        .resume;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先你需要注意的是，这段代码广泛使用了 Raku::Recipes::Calorie-Computer 的方法，这个类混在 Roly 角色中，包括从食材列表中计算热量的方法。在使用的两个模块中定义了例外，主要使用的方法是 <code>calories-for</code>。</p>
</div>
<div class="paragraph">
<p>这个方法会接受两个命名参数 - <code>main</code> 和 <code>side</code>，每个参数都是一个 <code>Pair</code>，它的 <code>key</code> 是原料的名称，它的值是我们要用它的量，不管用什么度量。我们设定主菜200克，副菜250克，这几乎是我做饭时的做法。</p>
</div>
<div class="paragraph">
<p>这个功能的复杂性在这个脚本中看不出来。如果提到的产品不存在（比如说你想要一个主菜鱼尾和一个副食米饭），或者如果你分别用一些不是主菜或副食的东西作为主菜或副食，它就会产生异常情况</p>
</div>
<div class="paragraph">
<p>(我想要苹果加金枪鱼)。我们可以用这个做几件事（包括在调用那个方法之前处理它们），但为什么要这样做呢？它已经处理了所有可能的异常。我们需要做的就是捕获异常以处理它们。</p>
</div>
<div class="paragraph">
<p>这就是为什么我们要使用 <code>try-catch</code> 组合，或者可以说，<code>try</code> 的主服务，边上还有一个 <code>catch</code>。<code>try</code> 块包含了任何发生在其中的异常，并创建了一个范围来捕获异常。异常可能会让某个变量处于不好的状态，所以 <code>CATCH</code> 块，也就是前面标有 <code>CATCH</code> 关键字的块（全大写，记住），分析出了什么问题，并去修复它，如果这也是可能的话。这些 <code>CATCH</code> 块是在正常流程之外的，它们会捕获发生在同一范围内的任何异常。这就是为什么我们在最后设置它们的原因。</p>
</div>
<div class="paragraph">
<p>如果某些部分缺失，我们会用一个合理的默认值来代替它。鹰嘴豆配米饭，有人知道吗？(它们和一点番茄、大蒜、也许还有一点洋葱，当然还有橄榄油一起吃，非常美味)。<code>CATCH</code> 块类似于给定块：它把异常作为一个局部变量，然后我们可以使用 <code>when/default</code> 来处理它。最后一个关键字是一个全局性的关键字：当其他一切都失败时，它将发射。在这种情况下，它是唯一的一个，它体现了我们如何在最通用的情况下创建这种类型的块。</p>
</div>
<div class="paragraph">
<p>我们需要知道是主菜还是副菜产生了错误，以便为其中之一或另一个提供默认值。消息（它将是一个 X::Raku::Recipes::WrongType 或一个 X::Raku::Recipes::Missing::Product）将包含产品或部件的名称。为什么会是这样呢？因为我们在前面的配方中承诺，会产生有意义的错误。我们将对错误进行解析，以确定如何修复它。我们会添加一些提示产生错误的值的东西，并解释如何处理它，并在可能的情况下从中恢复。</p>
</div>
<div class="paragraph">
<p>一旦变量被分配，我们知道 <code>$main</code> 和 <code>$side</code> 都有一个有效的值（提供或默认）。所以我们再次计算卡路里，这次没有任何问题，并调用 <code>.resume</code> 在抛出异常的地方恢复执行。这将产生类似下面的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Calories for a main dish of Tuna and side of Rice are 585</code></pre>
</div>
</div>
<div class="paragraph">
<p>嗯，金枪鱼和米饭。我希望配菜是锯木屑，但我会满足于此。</p>
</div>
<div class="paragraph">
<p>不过，我们可以做得更好。如果有另一个未知的错误呢？它将包含在 <code>try</code> 块中，但由于 <code>catch</code> 块不会处理它，所以它对 <code>$calories</code> 没有价值，也不会打印出任何合理的内容。另外，你可能想为不同种类的错误提供不同的默认值。或者干脆举手示意"我做不到"。</p>
</div>
<div class="paragraph">
<p>这里是，只包括代码的主要部分。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    $calories = $rrr.calories-for( main =&gt; $main =&gt; 200,
                                   side =&gt; $side =&gt; 250 );
    CATCH {
       when X::Raku::Recipes::Missing::Product {
            given .message {
                when /$main/ { $main = "Pasta" }
                when /$side/ { $side = "Potatoes" }
            }
            $calories = $rrr.calories-for( main =&gt; $main =&gt; 200,
                                           side =&gt; $side =&gt; 250 );
        }
        when X::Raku::Recipes::WrongType {
            given .desired-type {
                when "Main" { $main = "Chickpeas" }
                when "Side" { $side = "Rice" }
            }
            $calories = $rrr.calories-for( main =&gt; $main =&gt; 200,
                                           side =&gt; $side =&gt; 250 );
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果问题出在产品上（我们用意大利面作为主食，土豆作为副食），或者出在产品的类型上（主食或副食），就会使用不同的默认值。<code>CATCH</code> 块作为给定块，局部变量是例外。<code>when</code> 子句将智能匹配异常，并将其保留在 <code>topic</code> 变量中。我们会像之前一样，在给定子句中对 <code>topic</code> 变量进行充值。如果异常是一个不同的异常，我们不知道该怎么处理它，所以可能最好只把它传播给用户，用户会看到程序停止（并希望采取行动）。</p>
</div>
<div class="paragraph">
<p>匹配异常，在 WrongType 的情况下，使用 <code>desired-type</code> 属性来完成。使用这个而不是消息更具体，因为你需要知道类型的具体属性，但在消息内容可能比属性（或 API）更经常变化的意义上，它不那么脆弱。总之，总有很多方法可以做到。</p>
</div>
<div class="paragraph">
<p>然而，重复计算卡路里量的代码并不聪明。让我们试着重新表述一遍，避免这种重复。这里只显示 <code>catch</code> 块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">CATCH {
       when X::Raku::Recipes::Missing::Product {
            given .message {
                when /$main/ { $main = "Pasta" }
                when /$side/ { $side = "Potatoes" }
            }
            proceed;
        }
       when X::Raku::Recipes::WrongType {
            given .message {
                when /Main/ { $main = "Chickpeas" }
                when /Side/ { $side = "Rice" }
            }
            proceed;
        }
       when none(X::Raku::Recipes::Missing::Product,
                 X::Raku::Recipes::WrongType) {
           die "There's something wrong with ingredients, I can't generate that";
        }
       default {
            $calories = $rrr.calories-for( main =&gt; $main =&gt; 200,
                                           side =&gt; $side =&gt; 250 );
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的主要变化是使用了 <code>proceed</code>，也就是 <code>given</code> 说 "先别走，还有很多"的方式。<code>given</code> 中的 <code>when</code> 子句可能会匹配好几次； <code>proceed</code> 是一种说 "好的，我很好，但可能还有其他子句也会匹配"的方式。在这种情况下不会是这样的：它是一个 <code>Missing::Product</code>，一个 <code>WrongType</code>，或者都不是。我们在第三个子句中进行处理，这将再次使脚本死掉。但它的要点是在默认子句中：它总是会匹配，并且总是在匹配之后运行，一旦我们有了 <code>$main</code> 和 <code>$side</code> 变量的值，就会计算卡路里。这样就避免了可怕的代码重复，程序流程也更加清晰。</p>
</div>
<div class="paragraph">
<p>最后，这表明了一个好的错误层次结构设计，加上信息量大的信息，如何让你更容易设计出可靠的程序，几乎可以应对用户会扔给他们的所有东西。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_8_4_在_comma_ide_中调试你的应用程序">6.3. 食谱 8-4 在 Comma IDE 中调试你的应用程序</h3>
<div class="sect3">
<h4 id="_问题_22">6.3.1. 问题</h4>
<div class="paragraph">
<p>你的程序失败了，而且很难确定发生了什么。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_16">6.3.2. 解决办法</h4>
<div class="paragraph">
<p>Comma IDE 有一个集成的调试器，你可以用它来设置断点和检查变量值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_23">6.3.3. 它是如何工作的</h4>
<div class="paragraph">
<p>Comma 是一个集成的开发环境，拥有所有需要的东西，可以看到你的模块和应用程序中发生了什么。在本书中，我经常使用 Community 版本，以查看正在发生的事情，或者在某件事情失败时进行调查。</p>
</div>
<div class="paragraph">
<p>你在第1章中学习了如何选择一个脚本来运行，所以现在你将使用同样的选择来调试一个程序。这可以是你在那里使用的程序，也可以是本章中的一个程序，或者是你想要的任何程序。点击"播放"图标旁边的小虫子就可以进入调试模式，如图8-2所示。</p>
</div>
<div class="paragraph">
<p>图8-2.Comma IDE 中的 Debug 图标（小虫）。</p>
</div>
<div class="paragraph">
<p>然而，默认情况下，它启动了一个后台调试器，允许你停止它并检查断点。如果它完成得太快，你将无法检查所有的断点。你需要插入一个断点，通过点击行号和你想停止的行的文本之间的文字。见图8-3。</p>
</div>
<div class="paragraph">
<p>图8-3.在第16行插入断点 在第16行中插入断点，只要在该行数字和窗口之间的那一总列中单击即可</p>
</div>
<div class="paragraph">
<p>断点将显示为一条紫色的线，以及一个红色的圆盘。程序现在会在到达断点时停止，将线的颜色改为蓝色（在我使用的主题中；在其他主题中会是另一种浅色）。一旦程序暂停，你可以通过点击底部面板中的调试器选项卡（这是默认的布局，它可能在你屏幕的其他地方）来访问其余的好东西。你会看到类似图8-4的东西。</p>
</div>
<div class="paragraph">
<p>在这个块中有三个词法变量，但有趣的是 topical 变量：<code>$_</code>，这表明它包含一个类型为 <code>X::Raku::Recipes::WrongType</code> 的异常。我们可以点击"播放"符号，它将显示属性的值。显示 <code>$!product</code> 是 Apple（这是错误的），<code>$!wired-type</code> 是 Side。苹果是一种甜点（虽然苹果酱是一种不错的配菜），这就是为什么提出异常的原因。</p>
</div>
<div class="paragraph">
<p>你可以点击其余的调用框架，这些框架会对应之前被调用的内容，例如，可以看到 <code>calories-for</code> 是如何被调用的，以及它收到的值。</p>
</div>
<div class="paragraph">
<p>但是我们很高兴，这个值是我们要找的，我们可以继续执行。我们可以一步一步的走，也可以点击任何一行，运行到那一行为止。我们将点击"默认"块，看看那里发生了什么。或者你也可以点击 F8，一步步走过去。你可能不想"踏入"，因为那里的事情会很快变得很毛躁。当你进入 Rakudo 自己的代码时，如果你想进入一个块，你可能会使用"步入"。</p>
</div>
<div class="paragraph">
<p>如果你想设置固定的断点，就这样做，然后点击左侧的图标，有点像侧边的"弹出"按钮（如果你是十岁以下的孩子，可能不会明白这个参考）。这样就会恢复并运行到下一个断点。我们可以浏览到框架中包含所有的词汇变量，<code>$main</code> 和 <code>$side</code>，以及其他许多变量，如图8-5所示。</p>
</div>
<div class="paragraph">
<p>图8-5.检查"全局"变量</p>
</div>
<div class="paragraph">
<p>那个被标记为 <code>&lt;unit&gt;</code> 的框架显示了我们所有的"全局"变量，或者说在最外层的范围内实际上是全局的。我们可以看到一些在其他章节中提到的变量，比如我们为了方便而创建的 <code>$=pod</code> 和 <code>$pod</code>，以及 <code>$main</code>、<code>$side</code> 和 <code>$rrr</code>。只要呆在那个框架里，踩着"过来"，你就会准确地运行那一行，而不是其他。</p>
</div>
<div class="paragraph">
<p>当有些东西不符合你的要求时，这个调试器将帮助你指出并点击你的程序的内部工作方式。它比 "say $this" 和 "say @that" 这里和那里更胜一筹，对吧？</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_8_5_用漂亮的错误让它们大方地失败从而调试_grammar">6.4. 食谱 8-5. 用漂亮的错误让它们大方地失败，从而调试 Grammar</h3>
<div class="sect3">
<h4 id="_问题_23">6.4.1. 问题</h4>
<div class="paragraph">
<p>当一个 Grammar 失败时，很难钻研到解析到底失败在哪里。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方法_10">6.4.2. 解决方法</h4>
<div class="paragraph">
<p>使用 Grammar::Tracer 来确定 Grammar 在做什么，在哪里停止。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_24">6.4.3. 它是如何工作的</h4>
<div class="paragraph">
<p>语法要么失败了，却没有任何提示，要么你需要使用 Grammar::Tracer，并且很啰嗦地发现一些需要触发的规则没有被触发。幸运的是，我们可以安装 Grammar::ErrorReporting，它不仅可以报告错误，还可以让你以程序化的方式处理这些错误。</p>
</div>
<div class="paragraph">
<p>语法是你不知道你需要的最强大的东西，也是 Raku 最突出的功能之一，暂时没有其他语言共享。语法是一种程序化的方式来表达一组文本中的结构，它们给你提供了一种方法来轻松提取你感兴趣的结构部分。正如例程之于类，方法之于语法。语法是正则表达式的分层集合，这些正则表达式相互调用，以建立一个复杂的数据结构，忠实地表达你要分析的文本的结构。</p>
</div>
<div class="paragraph">
<p>请注意，我们用一整章的时间来介绍 Grammar，在本书的后面。</p>
</div>
<div class="paragraph">
<p>我们将创建一个简单的语法来分析一个用 markdown 写的菜谱中的成分列表。我们可以从这个开始。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit grammar Raku::Recipes::Grammar::Ingredients;

token TOP { &lt;row&gt; }
token row { "*" | "-" | "✅" \h+ &lt;ingredient&gt; }
token ingredient { &lt;quantity&gt; \h* &lt;unit&gt;? }
token quantity { &lt;:N&gt;+ }
token unit     { "g" | "tbsp" | "clove" | "tbsps" | "cloves" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>其结构与类的结构类似。我们把它作为单位，和类一样，以避免缩进。Grammar 由 rule、token 或 regex 组成。token 和 rule 是 regex，但有一点不同：token 是棘轮式的，也就是不回溯。rule 是指 whitespace 很重要的 token。这意味着，默认情况下，token 和 regex 可以使用空白作为装饰，并使其更加清晰。棘轮使 grammar 中的 token 速度更快，这就是为什么默认使用 token 的原因。当然，如果你愿意的话，你仍然可以使用 rule 或 regex。</p>
</div>
<div class="paragraph">
<p>Grammar 有一个 TOP token，在这种情况下，它只是委托给下一个 token，<code>row</code>。<code>row</code> 有一个丁字符号（通过|，是三个选项之一），加上一个成分的描述，其中包括一个数量和一个单位。在包含数量后面的成分之前，我们只用这个，因为我们已经卡住了。当试图解析 <code>* 2 tbsps</code> 时，应该是完全 OK 的，它匹配了 <code>*</code>，然后就停止了。</p>
</div>
<div class="paragraph">
<p><code>Grammar::Tracer</code> 来救场了。我们把它插入到 grammar 文件的顶部。在不做任何其他改动的情况下，它将把图8-6所示的结果打印到控制台。</p>
</div>
<div class="paragraph">
<p>图 8-6. Grammar::Tracer 的工作</p>
</div>
<div class="paragraph">
<p>匹配还可以，但无缘无故停在第一个匹配上。这就不好了。但这说明，某种程度上，token 中的第一个 <code>*</code> 确实符合 grammar。嗯，我们回到文档中去。</p>
</div>
<div class="paragraph">
<p>我们回到文档中去。去那里看看总是好的，因为你可能无法正确记住正则表达式的工作原理。而 <code>|</code> 恰好是"最长备选"。嗯，不是我们要找的东西。Grammar 匹配 <code>*</code> 或 <code>"✅" \h+ &lt;ingredient&gt;</code>，所以它只是对第一个选项满意，然后退出。我们需要使用 <code>||</code> 来代替。替换。另外，<code>||</code> 的优先级比 whitespace 高，所以我们需要把这三个东西分组，而不需要捕捉，因为我们对丁字符并不感兴趣。所以用这个代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token row { ["*" || "-" || "✅"] \h+ &lt;ingredient&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样就可以了。如果我们保留 Grammar::Tracer，我们将看到图8-7中的结果。</p>
</div>
<div class="paragraph">
<p>图 8-7. 匹配整个句子</p>
</div>
<div class="paragraph">
<p>图 8-7 显示，它到了第一条规则，尝试匹配成分，它由一个数量（那里匹配了 2）和一个单位（tbsps，汤匙）组成。然后，它回溯表示它匹配了层次结构中较高的 token，我们就可以得到好的结果了。这个程序会产生 "We need to use 2 tbsps of whatever"。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Raku::Recipes::Grammar::Ingredients;

my $row = Raku::Recipes::Grammar::Ingredients.parse("* 2 tbsps");
say "We need to use $row&lt;row&gt;&lt;ingredient&gt;&lt;quantity&gt; $row&lt;row&gt;&lt;ingredient&gt;&lt;unit&gt; of whatever"</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果匹配的结构与 Grammar::Tracer 打印的结构相同，它是一组嵌套的哈希，最上面的哈希使用最上面的 token 的名称作为键，从那里向下，到其余的  token。每一个关卡都会有很多键，因为里面提到了 token。</p>
</div>
<div class="paragraph">
<p>不过，事情还是会出错的。让我们试着解析 <code>*2 tbsps</code>，同时留下 Grammar::Tracer。见图8-8。</p>
</div>
<div class="paragraph">
<p>图8-8. 现在解析失败</p>
</div>
<div class="paragraph">
<p>图8-8显示，它失败了，而且是在第一个 token 中就失败了。好吧，这有帮助，但不是真的。让我们试着找出到底发生了什么。调试不会帮助我们，因为它只会显示 Match 变量 <code>$/</code> 的值，而这个值是空的，因为，匹配失败了。同理，"say $this or $that" 也是如此。但你的工具箱里有一个强大的工具：重构。</p>
</div>
<div class="paragraph">
<p>事实上，那个失败的规则有三个不同的部分。我们可能对所有的部分都不感兴趣，但目前我们需要知道它失败的地方，所以我们来分解一下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token row { &lt;dingbat&gt; &lt;whitespace&gt; &lt;ingredient&gt; }
token dingbat { ["*" || "-" || "✅"] }
token whitespace { \h+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>一行现在是三个不同的 token；Tracer 将帮助我们确切地知道它失败的地方。见图8-9。</p>
</div>
<div class="paragraph">
<p>啊哈！原来是那个偷偷摸摸的空格（或没有空格）导致了失败。让我们解决这个问题，它就会工作。下面的代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Raku::Recipes::Grammar::ErrorReporting;

my $measure = Raku::Recipes::Grammar::ErrorReporting.parse("* 2 tbsp");
say ~$measure&lt;row&gt;&lt;ingredient&gt;&lt;quantity&gt;, " of ",
        ~$measure&lt;row&gt;&lt;ingredient&gt;&lt;unit&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>会产生这个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">2 of tbsp</code></pre>
</div>
</div>
<div class="paragraph">
<p>不过，我们还是对空白处不感兴趣，而且，对丁字符也不感兴趣。结果的匹配将包括它们。通过在 rule 的名称前使用点，我们将使用它，但不存储它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token row {  &lt;.dingbat&gt; &lt;.whitespace&gt; &lt;ingredient&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将产生相同的结果，但噪音较小。</p>
</div>
<div class="paragraph">
<p>请记住，并不是所有标有 FAIL 的东西最终都会产生匹配失败；语法可能正在探索一个替代分支中的一个分支在那里失败，但随后在其他分支中成功并最终返回匹配。但通过这些，我们看到 Raku 不仅提供了强大的 Grammar，而且在生态系统中还提供了强大的工具，帮助你在某些东西不能以它应该的方式工作时使用和调试它们。这一点，以及一点编程手艺，将帮助你创建伟大的文本解析和分析工具，但我们将在本书的后面讨论这个问题。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_客户端_web_和_api">7. 客户端 Web 和 API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>网络是信息的无限来源，它就在那里供你挖掘。很多服务可以直接使用，在其他情况下，你必须做一些按摩，然而在其他情况下，你需要适当的授权。在所有这些情况下，Raku 都会帮助你。</p>
</div>
<div class="sect2">
<h3 id="_食谱_9_1_查询_geoip_数据库">7.1. 食谱 9-1. 查询 GeoIP 数据库</h3>
<div class="sect3">
<h4 id="_问题_24">7.1.1. 问题</h4>
<div class="paragraph">
<p>在您的日志文件中，您有一堆互联网地址，您需要知道它们来自哪里，以检查哪些国家对您的内容感兴趣。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方法_11">7.1.2. 解决方法</h4>
<div class="paragraph">
<p>使用 Raku 生态系统中的一个模块 GeoIP2 来查询 MaxMind 数据库，这个数据库包含了关于 IP 组的地理位置信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_25">7.1.3. 它是如何工作的</h4>
<div class="paragraph">
<p>你手里有一整套的文件，里面有你的菜谱网络服务器的日志，你想知道这些 IP 都来自哪里。这样一来，你就可以创造更多关于地方美食的内容。或者你只是出于好奇心想知道。专有的解决方案会给你提供这些信息，但同时也会让你的用户失去一些隐私，所以最好是自己开发。</p>
</div>
<div class="paragraph">
<p>幸运的是，有一家叫 MaxMind 的公司，生产了一系列的数据库。这些数据库是开放的格式，你可以用它们来查询 IP 的情况。你可以通过 GeoIP2 下载模块访问它们。</p>
</div>
<div class="paragraph">
<p>然而，这些数据库是专有的。有几种方法可以获得其中的一个数据库。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>你的公司可能会对其中的一个数据库非常感兴趣，它就会帮你买一个。</p>
</li>
<li>
<p>有一些用几种语言编写的开源工具，比如 Perl，可以生成这种格式的数据，而且它们是开源的。见 <a href="https://github.com/maxmind/MaxMind-DB-Writer-perl。" class="bare">https://github.com/maxmind/MaxMind-DB-Writer-perl。</a> 你可能想创建自己的、有限的、数据库，比如使用你们公司 VPN 内的 IP（如果是跨国的）。</p>
</li>
<li>
<p>最后，你可以免费下载 GeoLite 数据库。这些数据库的精度有限，但我们只对国家和大陆感兴趣，所以这就可以了。
我们将创建一个简单的脚本，检查你用来连接互联网的机器的 IP，并告诉你你来自哪个国家和大陆。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use GeoIP2;
my $ip = qx{curl -s ifconfig.me};
my $geo = GeoIP2.new( path =&gt; 'Chapter-9/GeoLite2-Country.mmdb' );
my $location = $geo.locate( ip =&gt; $ip );

say "The IP is in $location&lt;country&gt;&lt;names&gt;&lt;en&gt;, $location&lt;continent&gt;&lt;names&gt;&lt;en&gt;";</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于在本地，我们只能知道你的系统连接到的本地 IP（或 IP），通常是由路由器发出的本地 IP，所以我们通过 curl 使用 ifconfig.me 互联网服务来获取我们自己的 IP。我们需要安装并访问 curl，而 <code>-s</code> 将使它返回 IP，而不在屏幕上打印任何其他内容（s=无声）。<code>qx</code> 引号构造是运行外部程序的另一种方式，类似于我们在第1章和第2章中使用 <code>shell</code> 和 <code>run</code> 的做法。</p>
</div>
<div class="paragraph">
<p>然后我们用数据库文件的路径来初始化数据库对象（之前我已经注册下载了，你也可以在 <a href="https://dev.maxmind.com/geoip/geoip2/geolite2/" class="bare">https://dev.maxmind.com/geoip/geoip2/geolite2/</a> 进行注册）。我们调用 locate 方法来获取位置，它将以数据结构的形式返回，其中包括多种格式的国家和大陆名称，以及一些地理编码信息。我们只需要访问国家和大洲的英文名称（存储在 <code>&lt;names&gt;</code> 键中）（存储在代表语言编码的 <code>&lt;en&gt;</code> 键中）。这将为我打印以下内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">IP 在西班牙，欧洲</code></pre>
</div>
</div>
<div class="paragraph">
<p>说的对！</p>
</div>
<div class="paragraph">
<p>如果你想解析日志，你需要使用到目前为止看到的任何一个文本处理配方来处理这个日志。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_9_2_从网站下载和提取信息">7.2. 食谱 9-2. 从网站下载和提取信息</h3>
<div class="sect3">
<h4 id="_问题_25">7.2.1. 问题</h4>
<div class="paragraph">
<p>你需要得到一些网站上包含的信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_17">7.2.2. 解决办法</h4>
<div class="paragraph">
<p>使用外部 CLI 工具或使用可用的库之一下载页面，如 HTTP::UserAgent、Cro::HTTP 或 LWP::Simple。正如它们的名字一样，LWP::Simple 更简单，HTTP::UserAgent 能让你更灵活地创建特定的头文件，而 Cro::HTTP 是设计和维护最好的。你可能不会需要 Cro::HTTP 的所有功能。一旦内容被下载，使用正则表达式来捕获你感兴趣的信息，或者，如果这不容易或不可能，在 HTML 文档对象模型解析器中捕获信息，如 DOM::Tiny。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_26">7.2.3. 它是如何工作的</h4>
<div class="paragraph">
<p>网络上有很多信息。如果有一种方法来获取和处理它&#8230;&#8203; 但现在有了！从一开始，搜刮就是一种收集半结构化信息和数据的方法。从古至今，搜刮是一种收集信息和数据的方法，这些信息和数据是半结构化的，并公布在网络上。然而，搜刮仍是一门玄妙的艺术，有许多不同程度的自由度：从信息如何结构化，到更深奥的挑战，如节流（当有来自IP的重复请求时，使请求响应速度变慢）或服务条款（如果你从一个网站下载信息，你可能会被禁止，即使你实际上没有在其他地方发布这些信息）。</p>
</div>
<div class="paragraph">
<p>此外，还有一些技术上的挑战。从本质上讲，当你在搜刮时，你需要下载用 HTML 编写的页面，然后解析该 HTML 以获得你所需要的信息。在许多情况下（例如，如果该信息有一个明确的前缀，或以某种方式结构），解析是直接的。在其他一些情况下，你需要将整个页面解析到 DOM，然后寻找挂在某个分支上的特定树叶。</p>
</div>
<div class="paragraph">
<p>注意，在另外一些情况下，你可能会很幸运，从一个数据 <code>div</code> 或用户访问的 <code>JSON</code> 文件中获得信息。</p>
</div>
<div class="paragraph">
<p>配方也是如此。有无数的网站每天都会发布食谱，或者是食谱被摆放在那里，通常是以一种有一定结构的格式。</p>
</div>
<div class="paragraph">
<p>注意 不幸的是，一种叫做 hRecipes 的微格式用于在 HTML 中包含菜谱已经不再流行，我怀疑它是否曾经流行过。</p>
</div>
<div class="paragraph">
<p>然而，出于种种原因，我们最好还是坚持使用像 Wikipedia 这样的开放许可网站。Wikibooks 在 <a href="https://en.wikibooks.org/wiki/Category:Recipes" class="bare">https://en.wikibooks.org/wiki/Category:Recipes</a> 中包含了大量的菜谱，这些菜谱几乎遵循了相同的格式。这个脚本将下载其中一个食谱并提取其中的成分。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use HTTP::UserAgent;

my $URL = @*ARGS[0] // "https://en.wikibooks.org/wiki/Cookbook:Apple_Pie_I";
my $recipr = HTTP::UserAgent.new;
my $response = $recipr.get($URL);

die $response.status-line unless $response.is-success;
my $ingredients = ( $response.content.split(/"&lt;h2&gt;"/))[1];
my @ingredients = ($ingredients ~~ m:g/"\/Cookbook:"(\w+)/);
say @ingredients.map( ~*[0] ).unique;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在使用 <code>HTTP::UserAgent</code> 模块之前，你需要下载它，它是生态系统中经常更新的模块。</p>
</div>
<div class="paragraph">
<p>注意和这个快速发展的生态系统中的其他模块一样，你使用的 raku 版本在安装时可能会有一些怪癖，如果你不想活在边缘，可以使用 rakudo Star 发行版，其中包括许多其他有用的模块。</p>
</div>
<div class="paragraph">
<p>脚本将采取一个食谱的 URL，或者使用苹果派的 URL，因为有什么比苹果派更好，对吗？它将实例化一个版本的 HTTP 用户代理，并将在下一句中获取 URL。如果出现错误，它会用一条消息保释出来。</p>
</div>
<div class="paragraph">
<p>注意为了进入正题，我们将跳过检查和对错误的优雅处理。例如，我们不会检查 Url，使它有效地具有正确的模式.这留给读者.提示：一个简单的 regex 就可以了。</p>
</div>
<div class="paragraph">
<p>如果一切正常，我们就可以继续提取信息了。我们知道，会有一个 H2 段，叫做成分，这确实是第一个 H2 段。所以理所当然的，我们使用简单的 <code>&lt;h2&gt;</code> 进行拆分，取第二个，数组中的索引1。</p>
</div>
<div class="paragraph">
<p>请注意，这就是维基百科的一个好处：干净的标记.如果用其他一点标记和 CSS 类来标记的话，可能会更难分割部分。</p>
</div>
<div class="paragraph">
<p>在这一节中，我们意识到，每一种食材都有一个链接到描述使用该食材的不同食谱的部分。它们都遵循相同的模式：https://en.wikibooks.org/wiki/Cookbook: ingredient (而且它总是一组类似于单词的字符)。因此，我们使用的模式是 `m:g/"/Cookbook:"(\w)/);:g` 将匹配所有的菜谱，而括号将只捕获单词，因此我们在一个数组中得到一组 Match 对象。我们需要提取被匹配的精确字符串：<code>.map( ~*[0] )</code> 将得到 Match 中的第一个匹配对象，并将其字符串化。我们从这个数组中提取出唯一的元素，以防其中任何元素重复。这将会打印出类似这样的结果。</p>
</div>
<div class="paragraph">
<p>(Flour Margarine Lard Salt Water Apple Lemon_Juice Butter Sugar Cornstarch Cinnamon Nutmeg Milk)</p>
</div>
<div class="paragraph">
<p>注 是的，好像有一个栏目专门介绍带水的食谱，嗯，好喝! "这汤真好喝！"你的秘方是什么？" "水"</p>
</div>
<div class="paragraph">
<p>请注意，由两个独立的单词组成的成分，比如 Lemon Juice，用下划线隔开；下划线也与 <code>\w</code> 匹配，所以这里没有问题。</p>
</div>
<div class="paragraph">
<p>这样做还算成功，但我们还是需要有点技巧，通过从具有一定形状的 URL 中提取信息，来获取我们想要的信息。</p>
</div>
<div class="paragraph">
<p>提示 搜刮是一门玄妙的艺术，你需要时刻保持手艺。你也可以从 apress 出版的《用 Python 进行网站抓取》和《数据科学的实用网络抓取》这两本优秀的书中学习抓取的艺术和技巧，虽然语言不同，但技术和方法论并没有太大的区别。</p>
</div>
<div class="paragraph">
<p>让我们试着使用 DOM。虽然一般来说，这将会让你得到更精确的数据，但应该考虑到现代的 DOM，一般来说是动态的，所以你不能从源头得到它们（你需要一个无头的浏览器，目前，Raku 还没有）。另外，你需要的 DOM 结构是静态的，而很多网站会经常性地改变这个结构。让我们坚持使用这个同样的 Wikibooks 源码，它在这方面更干净和可刮擦。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use WWW;
use DOM::Tiny;

my $URL = @*ARGS[0] // "https://en.wikibooks.org/wiki/Cookbook:Apple_Pie_I";
my $content = get($URL);

die "That $URL didn't work" unless $content;

my @all-lis = DOM::Tiny.parse( $content.split(/"&lt;h2&gt;"/)[1]).find('li').map: ~*;
my @my-lis = @all-lis.grep( /title..Cookbook ":"/)
        .map( { DOM::Tiny.parse( $_ ) } );

say @my-lis.map( "→ " ~ *.all-text).unique.join("\n");</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们已经换了一个不同的带有 HTTP 命令的库，简单而贴切地命名为 WWW，它给我们提供了一个简单的从网上下载的 get 命令（它也可以在飞行中解析 JSON）。DOM::Tiny 将提供 DOM 解析能力。</p>
</div>
<div class="paragraph">
<p>虽然 HTML 是一种文档结构描述语言，但并没有什么好的方法为它提供一个自上而下的结构。例如，在结构中不能显示分段的划分（可以通过使用 section 标签来显示，但是这里没有使用）。这就是为什么，要提取成分部分，我们仍然要做与上一版本中基于标签的分割一样的工作。这样一来，我们就可以确保我们解析的内容真的包含了我们感兴趣的内容。这个页面的 HTML 相当干净，这意味着在任何地方都看不到语义类属性。如果包含我们列表项的 ul 标签有一个 <code>class='ingredients'</code> 标签，那就简单多了。尽管如此，从源码来看，我们看到每个成分都在 <code>&lt;li&gt;</code> 标签中，所以 <code>find("li")</code> 将在一个 Raku Seq（即你可以迭代的项目序列）中得到所有的成分。关于序列的所有信息，请访问 <a href="https://docs.raku.org/type/Seq" class="bare">https://docs.raku.org/type/Seq</a> 或从《Perl 6 快速语法参考》第 5 章了解。我们需要做额外的检查，所以我们通过 <code>~*</code> 将它们串联起来，将它们渲染成 HTML。</p>
</div>
<div class="paragraph">
<p>我们需要做的是下一个 grep：如果没有链接到配料页面，那就不是一个配料。在苹果派页面上，它们都是这样的，但我们要保持安全边际，实际检查一下这个。可能有一些额外的说明，我不知道，使用一些特殊的平底锅或预热烤箱（你总是需要预热烤箱）。我们再次解析它们，只是因为这是摆脱标记并获得所有文本的最简单的方法，接下来我们使用 <code>.all-text</code>，另一个 DOM::Tiny 方法来做。</p>
</div>
<div class="paragraph">
<p>结果将如下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">→ 8 oz (225 g) plain flour → 4 oz (110 g) margarine → 2 oz (55 g) lard
→ pinch of salt
→ 2 tablespoons cold water
→ 1 lb (500 g) apples, sliced
→ 2 tbsp lemon juice
→ 1 oz (28 g) salted butter
→ 2½ c sugar, and additional for sprinkling
→ ¼ c flour
→ 2½ tbsp cornstarch
→ cinnamon
→ nutmeg
→ 1 oz (28 g) milk
→ sugar</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，我们使用独特的，因为肉桂是重复的（也许有点被高估了），因为它用在馅饼的两个部分。这样一来，我们就把所有的原料都集中在一起了，我们可以对它们进行额外的处理（比如使用语法，这一点我们后面会讲到）。</p>
</div>
<div class="paragraph">
<p>如果完全没有办法的话，你就会废掉。如果你能使用一个API，事情就会简单很多。我们接下来会讲到这一点。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_9_3_使用_web_api_从网站获取信息">7.3. 食谱 9-3. 使用 Web API 从网站获取信息</h3>
<div class="sect3">
<h4 id="_问题_26">7.3.1. 问题</h4>
<div class="paragraph">
<p>您需要从一个通过 REST API 提供数据的网站下载信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_18">7.3.2. 解决办法</h4>
<div class="paragraph">
<p>在 Raku 中使用 Web 客户端，如 WWW 或 Cro::HTTP，或者如果生态系统中存在 API 的特定模块。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_27">7.3.3. 它是如何工作的</h4>
<div class="paragraph">
<p>食谱和食物，在网络上一般都是蓬勃发展的领域。</p>
</div>
<div class="paragraph">
<p>注意在冠状病毒大流行的时候更是如此，当时世界上很大一部分人都被关在家里，有更多的时间。</p>
</div>
<div class="paragraph">
<p>有一个星座的网站，每天都可以查询，但这也创造了一个完整的服务行业，为这些网站提供内容，以及从撰写食谱到检查各种食材信息的附加值。还有 Yummly，它提供了一个按次付费的 API，还有很多其他的服务。我们还是选择 Edamam 吧。如果你以开发者身份注册，它确实提供了一个免费层，限制在5个请求/分钟。因此，请为这个配方做 <a href="https://developer.edamam.com/edamam-recipe-api，" class="bare">https://developer.edamam.com/edamam-recipe-api，</a> 并获得一个应用ID和一个API密钥。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::HTTP::Client;
use URI::Encode;

my $appID = %*ENV{'EDAMAM_APP_ID'};
my $api-key = %*ENV{'EDAMAM_API_KEY'};
my $api-req = "\&amp;app_id=$appID\&amp;app_key=$api-key";
my $ingredient = @*ARGS[0] // "water";

my $cro = Cro::HTTP::Client.new(base-uri =&gt; "https://api.edamam.com/" );
my $response = await $cro.get( "search?q="
                               ~ uri_encode($ingredient) ~ $api-req);
my %data = await $response.body;
say %data&lt;hits&gt;.map( *&lt;recipe&gt;&lt;label&gt; ).join: "\n";</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cro 是一个了不起的作品，它是一个分布式应用的框架，它包含了各种不同协议的好东西，当然也包括我们这里使用的这个 HTTP 客户端。与我们之前一直使用的客户端不同，它是异步的。我们以前也用过异步，但在这种情况下，它是完全合适的。你并不知道一个请求的响应什么时候会到达，让程序的其他部分一直挂在那里等待会导致性能低下。在你将做一个单一请求并串行处理的情况下，也许可以（就像我们在前面的配方中所做的那样）直接启动请求并等待结果；事实上，我们在这里就是这样做的。但以后会有。</p>
</div>
<div class="paragraph">
<p>第一块语句将设置必要的变量，像往常一样从命令行中获取查询字符串，如果它存在的话。你需要从Edam账户中复制并粘贴它们来定义环境变量。如果这些变量没有有效的值，它将无法工作。由于所有的请求都会精确地使用这两个值，所以我们设置了 <code>$api-req</code> 变量，以便以后重复使用。</p>
</div>
<div class="paragraph">
<p>Cro::HTTP::Client 设置了一个带有基本 URL 的客户端。如果协议版本允许的话，它会重用连接，这也是与我们之前使用的其他两个模块的区别。从产量和功能上看，Cro 比其他同类型的模块要领先很多。</p>
</div>
<div class="paragraph">
<p>因为它是异步的，一个请求会返回一个承诺。我们在这个承诺上等待，才能得到响应。但响应本身也是一个承诺：它是一个连接，我们需要再次在它上等待，才能得到响应的主体。这就解释了两个等待的顺序。API 使用 GET 来访问搜索函数，它使用 <code>q</code> 作为查询字符串的参数。我们建立一个 URL，在这种情况下，这很方便（也是给方法一个哈希的替代方法），因为 API 会明确地要求按这个顺序提供认证参数（否则你无法确定哈希的密钥将如何排序）。</p>
</div>
<div class="paragraph">
<p>Cro::HTTP::Client 甚至会为你解码响应的主体，并给你一个 Raku 数据结构。默认情况下，Edamam API 会返回10个点击，免费层最多返回100个。我们将满足于第一页，事实上，这个特殊的查询字符串会返回几千次点击。"点击率"是结果数据结构返回的键之一。但我们只是对返回的配方感兴趣。数据结构将是一个哈希，它将把 hit 存储为 <code>hits</code> 键下的一个数组。其中，每个命中都会有一个配方键，而这个配方会有一个标签键，这将是它的描述。所以最后一条语句在这些命中上运行一个映射，并提取这些配方的名称。它将像这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Summer water
Pineapple Coconut Water
Water Toast
Water Kefir from 'Mastering Fermentation'
Grapefruit Sparkling Water
Coconut-Water Gelatin
Cucumber-Orange Water Recipe
Tomato Water Pasta
Rose Water Marshmallows recipes
Rose Water Syrup</code></pre>
</div>
</div>
<div class="paragraph">
<p>嗯，夏天的水。迫不及待的想做这个。我可以在当地超市买到脱水水吗？</p>
</div>
<div class="paragraph">
<p>一般来说，大多数 API 将使用 REST，你将能够使用 Cro::HTTP::Client 来处理它。认证将以不同的方式进行，在大多数情况下，将它们作为元数据添加到请求中。处理 API 的本质就在那里。把你的参数放在一起，构建请求（包括头元数据，如果你需要的话），然后发射它，解码响应。</p>
</div>
<div class="paragraph">
<p>在一些有限的情况下，你会有一个为特定 API 定制的 Raku 模块。API::Discord 将处理该对话系统，还有 Twitter 的社交网络，Glot.io 的 GlotIO，甚至还有一个 Wikidata 的薄包装器，叫做 Wikidata::API，是由你们自己发布的。</p>
</div>
<div class="paragraph">
<p>维基数据是维基百科中较少有人涉足的部分，专门用于，嗯，数据。它存储数据和数据项之间的关系。它包括用什么成分来做什么配方。作为 WikiRealm 的其余部分，它是众包的，所以你的里程数可能会有所不同。好在它有一个无需认证的 API，基于一种名为 SPARQL 的查询语言。例如，这个查询将返回所有包含大蒜的食谱。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT ?recipe ?recipeLabel
WHERE
{
  ?recipe wdt:P31?/wdt:P279* wd:Q219239;
            wdt:P527 wd:Q21546392.
  SERVICE wikibase:label { bd:serviceParam wikibase:language "en", "fr". }
}
ORDER BY UCASE(STR(?recipeLabel))</code></pre>
</div>
</div>
<div class="paragraph">
<p>前缀wdt是用来表示关系，wd是表示数据。我们拥有的两个固定的数据是 Q219239，它是，食谱（查看它的URI <a href="https://www.wikidata.org/wiki/Q219239，" class="bare">https://www.wikidata.org/wiki/Q219239，</a> 或者直接在 www.wikidata.org 上搜索"食谱"）。这两个关系是一个实例或一个子类。carbonara 酱的配方是配方的一个实例。P527 的意思是"是由"组成的，Q21546392 是大蒜。查看 Q 前缀表示实体，P 表示它们之间的关系。所以本质上我们是在说"给我所有看起来是配方的东西，并且包括大蒜"。扰流器。在写这篇文章的时候，只有两个。我们需要这个脚本来获取它们。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Wikidata::API;
my $query = "Chapter-9/ingredients.sparql".IO.slurp;
my $recipes-with-garlic= query($query);
say "Recipes with garlic:\n",
        $recipes-with-garlic&lt;results&gt;&lt;bindings&gt;
            .map: { utf8y( $_&lt;recipeLabel&gt;&lt;value&gt;) };

sub utf8y ( $str ) {
    Buf.new( $str.ords ).decode("utf8")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其实也没什么好说的。读取 SPARQL 查询，发起查询，显示结果。结果是在一个相对复杂的数据结构中，但唯一有趣的部分是 recipeLabel 键，正如你之前看到的，它是由查询创建的。其余的都是模板（results 将是存储结果的键，bindings 将显示绑定到 results 的不同变量，包括 recipeLabel）。</p>
</div>
<div class="paragraph">
<p>我们必须创建一个小的子例程，utf8y，来处理结果，因为使用的 JSON 模块不能。该例程将一个字符串分解为其字符，重新构造，并返回以 utf8 编码的字符串。这将打印出以下内容。</p>
</div>
<div class="paragraph">
<p>有大蒜的食谱</p>
</div>
<div class="paragraph">
<p>(Anchoïade ratatouille)</p>
</div>
<div class="paragraph">
<p>这第一个字就是造成那个套路存在的原因。这是仅有的两个似乎使用大蒜的食谱。当然，他们必须是法国人。</p>
</div>
<div class="paragraph">
<p>如果你懂 SQL 或其他查询语言，SPARQL 并不难学，它真的可以帮助你处理很多平凡的事情。在乐乐降临日历的这篇文章中，圣诞老人用它来检查男孩和女孩们在信中要求的东西是否真的是一个对象 <a href="https://perl6advent.wordpress.com/2017/12/03/letterops-with-perl6/。" class="bare">https://perl6advent.wordpress.com/2017/12/03/letterops-with-perl6/。</a></p>
</div>
<div class="paragraph">
<p>总的来说，API 会帮助你丰富你的应用，使用 Raku 可以轻松地与它们合作。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_9_4_通过查询互联网服务来检查ip和地址">7.4. 食谱 9-4. 通过查询互联网服务来检查IP和地址。</h3>
<div class="sect3">
<h4 id="_问题_27">7.4.1. 问题</h4>
<div class="paragraph">
<p>你有一个IP，你需要检查它是否开启或是否有服务。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方法_12">7.4.2. 解决方法</h4>
<div class="paragraph">
<p>你可以使用 Net::IP 来操作地址，或者使用 Net::IP::Parse 来检查地址，还可以使用 IP::Random 来生成随机的 IP 地址。Sys::IP 会给你本地 IP 地址。你也可以使用 whois 来映射域名到名字。在许多情况下，会有一个 Raku 模块可用来检查某个服务，在其他情况下，你将不得不使用本章讨论的一个配方来创建你自己的 API 查询服务。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_28">7.4.3. 它是如何工作的</h4>
<div class="paragraph">
<p>使用IP地址工作涉及到查询系统服务，以及使用 TCP 等协议进行调用，并检查返回的内容。例如，很多时候我们需要检查一个服务是否在运行，如果没有运行，就要做一些事情，比如记录一个故障事件，或者采取其他措施，比如发送邮件。一般来说，做系统调用，而且是以一种与系统无关的方式进行，并不容易。</p>
</div>
<div class="paragraph">
<p>服务一般会被映射到"端口"上，端口是系统内的地址，通常有一个约定俗成的编号。这些编号是公布的，你通常会确保如果你需要运行一些东西，你会避开它们，创建你自己的。</p>
</div>
<div class="paragraph">
<p>总之，把这些放在一起意味着，如果你想检查某些服务是否在你的系统上运行，你需要检查该端口中是否有任何东西响应某个协议，通常是 TCP。你可以用这个简单的脚本来完成</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Sys::IP;
use Services::PortMapping;
use CheckSocket;

my $this-ip = Sys::IP.new.get_default_ip();

for &lt;www-http ssh&gt; -&gt; $service {
    if check-socket(%TCPPorts{$service},$this-ip) {
        say "Your service $service is running in port %TCPPorts{$service}";
    } else {
        say "Apparently, your service $service is not running";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>脚本很简单，因为有三个模块，把所有复杂的东西都藏起来了。Sys::IP 找到本地系统拥有的 IP 或IP，可以用来检查的 IP（当然，总有 127.0.0.1）。Services::PortMapping 导出四个哈希，将标准服务名映射到端口，反之亦然。最后，CheckSocket 检查是否有一个 TCP 服务在某个地址的端口中运行。</p>
</div>
<div class="paragraph">
<p>所以我们按顺序进行：首先通过 <code>get-default_ip</code> 找到本地IP，然后通过在它们上面运行 <code>check-socket</code> 来检查两个常见的服务，ssh 和 http（根据"服务名称和传输协议端口号注册表"，它们的标准名称是 http、www 或 www-http）。如果它们正在运行或没有运行，将打印不同的信息。在我的例子中，它将打印以下信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Your service www-http is running in port 80
Your service ssh is running in port 22</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是我发现我一直安装并运行 Apache httpd 的原因。</p>
</div>
<div class="paragraph">
<p>Raku 是一门通用语言，它和下一门语言一样，足以胜任系统级任务。生态系统中的模块确实不如其他语言（如 Perl 或 Python）那么多，但在生态系统的 <code>Net::</code> 命名空间中，对 DNS 或 BGP 等协议有广泛的支持。不幸的是，其他协议，如 ICMP，都没有。然而，Raku 生态系统每周都会增加几个模块，所以当你读到这篇文章的时候，这可能不是真的。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_文本处理">8. 文本处理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>脚本语言是制作脚本的好帮手，这些脚本可以对文本进行处理，提取信息，以某种格式呈现，或者以其他有用的方式进行操作。在本章中，我们将看到如何提取信息、识别文件之间的差异以及将静态页面渲染为 HTML。我们将看到许多基本的Raku技术，以及被介绍到生态系统中的有用模块。</p>
</div>
<div class="sect2">
<h3 id="_食谱_10_1_scrape_markdown_文档">8.1. 食谱 10-1. Scrape Markdown 文档</h3>
<div class="sect3">
<h4 id="_问题_28">8.1.1. 问题</h4>
<div class="paragraph">
<p>您需要从 markdown 文档中提取信息，例如只提取标题，或者通过位置或内容识别某些信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方案_3">8.1.2. 解决方案</h4>
<div class="paragraph">
<p>正则表达式是一种强大的特定领域的方法，可以从半结构化文本中提取信息，例如 markdown 文本，这总是一个选项。如果信息在结构中，你可以使用生态系统中的 Text::Markdown 模块。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_29">8.1.3. 它是如何工作的</h4>
<div class="paragraph">
<p>Scraping 是从带有某种标记的文本中提取信息的过程，无论是在网络上还是在具有已知格式的文档上，如 PDF 或文字处理文档。Scraping 用于处理遗留的文档，从网络上的信息中创建 API，或者准备向公众开放的数据。</p>
</div>
<div class="paragraph">
<p>我们在本书的食谱中使用了 markdown。在任何配方中，你需要提取的东西之一，就是它的成分。比方说，你需要确定某个食谱的成分，这样你就可以把它们添加到你的购物清单中，或者计算其中的卡路里量（就像我们在第二章中做的那样）。</p>
</div>
<div class="paragraph">
<p>例如，这可能是一个制作胡萝卜卷的食谱的标记。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-markdown" data-lang="markdown"># Carrot wraps

A healthy way to start a meal, or to munch between them.

## Ingredients
* 200g carrots
* 200g cottage cheese or cheese spread
* 4 wheat tortillas

## Preparation
    1.    Cut the carrots in long sticks or slices
    2.    Spread cheese over tortillas, cut them in half
    3.    Put carrot sticks on tortillas, wrap them around
    4.    Add fresh parsley, mint or coriander to taste.</code></pre>
</div>
</div>
<div class="paragraph">
<p>标题和章节都有明确的标示。首先是一级标题（用 <code>#</code> 表示），然后我们把原料作为二级标题，再把准备工作作为另一个二级标题。我们和以前一样，只对成分及其措施感兴趣。由于这些标记语言只标记段落，而不是段落集，所以没有任何东西能包裹住 ingredients。我们必须找到另一种策略来获取它们。但请注意，它们是文档结构中唯一的列表项。准备工作使用的是编号项。所以，这可能是提取它们的一个好方法。我们在这里这样做。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Text::Markdown;

sub MAIN( $filename = "recipes/appetizers/carrot-wraps.md") {
    my $md = parse-markdown-from-file($filename);
    my @ingredients = $md.document.items
            .grep( Text::Markdown::List )
            .grep( !*.numbered );
    for @ingredients[0].items -&gt; $i {
        say "Ingredient → {(~$i).trim}";
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，这里提到的 markdown 文件将和其他代码一起被包含在本书的 github 仓库中。</p>
</div>
<div class="paragraph">
<p>我们将使用生态系统中的一个模块，Text::Markdown。它并不完美，但对于像本篇这样的简单文档，它的工作做得相当好。Text::Markdown::Discount 是另一种选择，它使用一个 C 库来做解析。如果需要的话，这两个模块还可以从数据结构中生成 markdown。</p>
</div>
<div class="paragraph">
<p>总之，parse-markdown-from-file 直接从文件中创建一个数据结构；这个数据结构将是一个 Text::Markdown::Document 对象，有一系列的项目。Text::Markdown 对每一种可能的标记都有不同的类型；它们被称为 Text::Markdown::Whatever。例如，一个文本段落将是 Text::Markdown::Paragraph，并且，实际上，Text::Markdown::List 将是一个列表。然而，编号或常规列表没有特定的类型，那是通过对象中的一个属性来区分的。</p>
</div>
<div class="paragraph">
<p>我们需要做的是提取文档对象中的项目，文档对象将是一个数组，过滤所有的列表（将有一个常规列表用于成分，一个编号的用于说明），然后只取那些编号的列表。</p>
</div>
<div class="paragraph">
<p>会有一个，那将是数组中的第一个元素。同样，列表数据结构中的项目将包含所有不同的列表项目，我们在循环中有效地列出这些项目。不过，我们需要做一些额外的处理。每一个项目都将是一个 Text::Markdown 数据结构，我们需要对其进行字符串化处理；即使如此，文本也将包含回车和可能的其他空白，我们对其进行修剪。最终，结果将是这样的。</p>
</div>
<div class="paragraph">
<p>Ingredient → 250g carrots
Ingredient → 200g cottage cheese or cheese spread
Ingredient → 4 wheat tortillas</p>
</div>
<div class="paragraph">
<p>这些成分可以通过提取措施和实际使用的成分进一步加工。这将留待以后我们处理迷你语言时再讨论。</p>
</div>
<div class="paragraph">
<p>但是，请注意，对于那些注定要被自动处理的文档，总是赋予一个固定的结构是很重要的。在本例中，列表的类型是一个显著的特征。如果我们也使用一个编号列表，我们就需要进行额外的处理，例如，将文档按章节分割（就像我们在上一章处理网页时所做的那样），然后提取第二部分的项目。然而，在这种情况下，我们对信息的呈现方式没有任何形式的控制。在 markdown 文档的情况下，我们通常会这样做。一些简单的准则就足以使带有一点结构的文本像任何一种（序列化的）数据结构一样规则。</p>
</div>
<div class="paragraph">
<p>注意 你需要在文本本身中进行结构化。例如，第二项有一个"或"，这将使它难以自动处理。当我们以这种方式处理成分时，我们就需要一种方法来有原则地、但又不笨拙地表达这些替代方案。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_10_2_生成一组静态网页">8.2. 食谱 10-2. 生成一组静态网页</h3>
<div class="sect3">
<h4 id="_问题_29">8.2.1. 问题</h4>
<div class="paragraph">
<p>你需要为一个静态网站生成一些页面，以廉价（安全）的方式发布。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_19">8.2.2. 解决办法</h4>
<div class="paragraph">
<p>使用静态网站生成器从 markdown 文档生成 HTML 页面，或者使用模板和脚本推出自己的网站。最简单的方法是从你已有的 markdown 文档中生成 HTML。例如，Markit 会解析 markdown 并将其转换为 HTML。</p>
</div>
<div class="paragraph">
<p>除了这些系统，还有三个其他的系统&#8212;&#8203;Uzu、Pekyll 和 BreakDancer。后者可能已经过时了，Uzu 最近更新了。但是，Markit 也许可以代替它们中的任何一个，从它的 markdown 源中生成一组页面，这就是我们要找的东西。</p>
</div>
<div class="paragraph">
<p>此外，我们还可以使用模板系统，比如 Template::Classic，用程序中的值来填充 boilerplate。这就是我们将在这里使用的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_30">8.2.3. 它是如何工作的</h4>
<div class="paragraph">
<p>首先我们能想到的是使用一个工具，直接使用 markdown 中的源码，然后用 HTML 生成一个静态网站。最接近的是 Pekyll，但我真的不能建议你使用它，因为它的文档不是最新的（或完整的），而且它已经三年没有更新了。不过，它可能完全没问题，因为 Raku 是一种（大部分）稳定的语言。但我们还是试试另一条路吧。</p>
</div>
<div class="paragraph">
<p>Uzu 最近一直在更新，而且它的使用频率很高。但是，它使用 HTML 而不是 markdown 源码来生成网站。这意味着我们需要退一步，想办法直接生成 HTML。</p>
</div>
<div class="paragraph">
<p>Markit 就是解决方案。事实上，如果你想要的只是一个普通的 markdown-to-HTML 处理器，这个处理器是相当不错的，而且会做得很好，虽然很朴素。我们将用它来为我们所有的食谱生成 HTML文件（这些不是真正的页面，因为它们没有完整的 HTML 头/体结构，尽管它们可以使用）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Raku::Recipes;
use Markit;

my $md = Markdown.new;

for recipes() -&gt; $recipe {
    my $html-path-name = ~$recipe;
    $html-path-name ~~ s/\.md/\.html/;
    $html-path-name ~~ s/recipes/build/;
    my $html-path = IO::Path.new($html-path-name);
    my $html-dir = $html-path.dirname.IO;
    $html-dir.mkdir unless $html-dir.d;
    say $html-dir;
    spurt $html-path-name,  $md.markdown( $recipe.slurp );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将使用 Raku::Recipes 中的食谱例程，它对应于我们在第一章中创建的计数文件食谱。我们已经将它整合到我们的 Raku Recipes 实用程序模块中。它将返回一个列表，其中包含默认的 recipes 文件夹中的所有文件的路径（或另一个绝对或相对的路径，在那里可以存储 markdown recipes）。该循环将在这些文件上运行。它分两步生成 HTML 文件的路径：它改变扩展名，然后将目录从原来的（包括食谱）改为最后的，即 build。然后我们需要创建目录，如果它不存在，因为否则文件的创建将失败。我们创建一个 IO::Path 对象，检查它是否存在，除非它存在，否则我们就将该目录 mkdir。</p>
</div>
<div class="paragraph">
<p>spurt 例程将直接把从 markdown 生成 HTML 的结果写到文件中，只需一步。例如，这将是 carrot-wraps.html 文件的内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;h1&gt;Carrot wraps&lt;/h1&gt;
&lt;p&gt;A healthy way to start a meal, or to munch between them.&lt;/p&gt;
&lt;h2&gt;Ingredients&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;250g carrots&lt;/li&gt;
&lt;li&gt;200g cottage cheese or cheese spread&lt;/li&gt;
&lt;li&gt;4 wheat tortillas&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Preparation&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Cut the carrots in long sticks or slices&lt;/li&gt;
&lt;li&gt;Spread cheese over tortillas, cut them in half&lt;/li&gt;
&lt;li&gt;Put carrot sticks on tortillas, wrap them around&lt;/li&gt;
&lt;li&gt;Add fresh parsley, mint or coriander to taste.&lt;/li&gt;
&lt;/ol&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而，一个 HTML 文件并不意味着一个网站，甚至不是一个页面，所以我们需要将整个文档结构包裹在我们生成的片段中。为了做到这一点，我们应该避免只在 HTML 字符串周围游走，这对于网站设计师来说是很难编辑的。最好的选择是使用模板，我们将选择 Chloe Kekoa 最近发布的 Template::Classic。它非常简单，只有一个函数 template，可以创建一个例程，将变量的值渲染到模板中。如果你想学习用 Raku 的方式（或者至少是 Raku 的一种方式）来做事，它也是一段非常优秀的代码，它很好地利用了许多 Raku 独有的特性，包括语法。</p>
</div>
<div class="paragraph">
<p>很显然，模板是要模板的，所以我们需要用这种方式来创建页面的基本骨架。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Test page&lt;/title&gt;
&lt;link rel='stylesheet' id='style-css'  href='raku-recipes.css' type='text/css' media='all' /&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- This is a Template::Classic template --&gt;
&lt;% take $content %&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个模板的关键部分就在这里: <code>&lt;% take $content %&gt;</code>。在 Template::Classic 中，<code>&lt;% %&gt;</code> 运行 Raku 代码，它将返回变量 <code>$content</code> 中的任何内容，并将其精确地包含在 HTML 文件的那部分。我们将需要使用该变量来生成文件。我们在这个程序中就是这样做的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Raku::Recipes;
use Markit;
use Template::Classic;

my $template-name="templates/recipe.html";
my $template-file = "resources/$template-name".IO.e
                ??"resources/$template-name".IO.slurp
                !!%?RESOURCES{$template-name}.slurp;

my $md = Markdown.new;
my &amp;generate-page := template :($content), $template-file;

for recipes() -&gt; $recipe {
    my $html-fragment = recipe($md,$recipe);
    my @page = generate-page( $html-fragment );
    spurt-with-dir($recipe, @page.eager.join );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>generate-page</code> 例程与前面的配方完全一样。它将从 markdown 生成 HTML 片段；<code>spurt-with-dir</code> 将像前一个配方一样，写入一个文件并创建目录（如果存在）。为了简洁起见，它们已经被省略了。剩下的就直接进入正题了。</p>
</div>
<div class="paragraph">
<p>首先我们从文件系统中获取模板。这个模板会像大多数模块使用的资源一样，在资源/目录下。传统上，这个目录的所有内容都会在 META6.json 中声明，随后安装到一个不可更改的地方。你不需要去找这个地方在哪里。<code>%*RESOURCES</code> 动态哈希将为每个资源提供一个条目。我们事先并不知道我们是在同一个目录下使用这个模板，还是在安装了 Raku::Recipes 模块之后才使用，所以第一条语句就解决了这个问题。</p>
</div>
<div class="paragraph">
<p>和我们之前做的一样，我们生成一个 markdown 渲染器对象，但现在我们另外创建一个 templater 函数。我们使用模板，即 Template::Classic 导出的唯一例程来完成。它接收一个签名和一个模板作为参数，并返回一个将模板应用到其参数的函数。我们使用绑定 <code>:=</code> 而不是赋值；这是模块文档告诉我们的方式，而且这是有意义的，因为绑定创建了一种别名。我们所做的只是简单的说，该函数将指向调用模板的结果，而不是一个副本。这可能也会给它带来一点速度上的优势。</p>
</div>
<div class="paragraph">
<p>那么，这就是一个高阶函数。一个返回函数，接受一个模板，并返回一个应用该模板的函数。这就是我们所说的 templater。templater 是一个函数，它将把这个模板应用到提交给它的变量上，把它们的值嵌入到它定义的地方。</p>
</div>
<div class="paragraph">
<p>这是一种我们通常在函数式语言中找到的模式，比如 Haskell 和 Scala。但是 Raku 也是一种函数式语言，函数是一级对象（和类型或语法一样）。我们可以在任何可以使用其他类型数据的地方使用它们。这也是我们选择这个模块作为配方的原因之一；即使它很新，但它确实突出了 Raku 的能力和特性。想一想如何以一种面向对象的方式来完成这个任务：我们将创建一个模板对象，将模板作为一个属性，然后我们将调用该对象的一个方法来应用模板（并可能改变状态的对象）。该方法必须使用一个通用签名（例如，哈希）来接收变量。这就是函数式编程的全面扩展：创建的 templater 是一个无状态函数&#8212;&#8203;它接收经过类型检查的变量，并返回填好的内容。</p>
</div>
<div class="paragraph">
<p>不过，请注意，有很多方法可以做到，如果你对对象，或者对纯程序接口很满意，raku 也会为你提供使用它的工具。</p>
</div>
<div class="paragraph">
<p>签名只是一个例程使用的参数组合。它是一种声明它接受什么样的参数的方式，不仅可以用来在调用函数时对参数进行类型检查，还可以用来检查函数本身，函数的类型包括签名和返回类型。签名机制在大多数现代语言中都可以使用。Raku，此外，还包括签名作为一级对象。万一你想说，嘿，创建这个函数，我想以这种精确的方式被调用，你可以使用像这样的签名文: <code>($content)</code>。</p>
</div>
<div class="paragraph">
<p>请注意，raku 中的签名机制是相当广泛的，包括运行时检查、子签名、命名和位置参数、slurpies 等。你可以在 《Perl 6 快速语法参考》书中找到所有关于它的内容，作者是同一个人。</p>
</div>
<div class="paragraph">
<p>基线是，我们要把 templater 作为一个函数来调用。有了这个签名，我们告诉这个签名我们将如何调用它，使用哪些参数，它的类型，以何种顺序调用，等等。</p>
</div>
<div class="paragraph">
<p>就像我们在前面的配方中所做的那样，我们生成 HTML 片段，将这个 templater 应用于它，并生成一个 Seq。在模板中，<code>$html-fragment</code> 的内容将成为 <code>$content</code>，并返回结果。它返回的是一个序列，每个元素都是结果的一个片段，你可以分别处理，甚至可以用它们创建一个供应。使用 <code>Seq</code> 可以使它更加灵活，但在这种情况下，我们只是对整个事情感兴趣。由于它是一个懒惰的序列，我们让它变得急切，这样它的所有组件都会被活用，然后我们简单地将它加入到一个单一的字符串中。然后这个字符串会被写入文件系统，保留原始路径。</p>
</div>
<div class="paragraph">
<p>结果（一旦你把CSS文件放在正确的地方）会像图10-1一样。</p>
</div>
<div class="paragraph">
<p>图10-1. 通过 templater 渲染的食谱</p>
</div>
<div class="paragraph">
<p>不过，我们还是可以做得更好一些。例如，标题是通用的，每一页都是一样的。如果我们能在那里使用食谱的标题会更好。另外，如果能有一个索引页，里面有每个页面的链接，那就更好了。现在我们还没有这样的功能。但我们可以利用 Template::Classic，以及本章的第一个配方来实现这种效果。有两种模板解决方案：无代码和另一种，有代码。像 Mustache 这样的无代码解决方案，创建了自己对模板语言的适应性，从而可以用隐式的方式处理某些数据结构。例如，你可以创建一种方式来表达如何呈现一个数组或哈希。另一方面，Template::Classic 允许你包含所有种类的 Raku 代码。我们将在索引模板中使用它，如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
&lt;title&gt;Raku Recipes: index&lt;/title&gt;
&lt;link rel='stylesheet' id='style-css' href='raku-recipes.css' type='text/css'
      media='all' /&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- This is a Template::Classic template --&gt;
&lt;h1&gt;Recipes: index&lt;/h1&gt;
&lt;ul&gt;
    &lt;% for %links.kv -&gt; $file, $title { %&gt;
    &lt;li&gt;&lt;a href="&lt;%= $file %&gt;"&gt;&lt;%= $title %&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;% } %&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的主要区别是 HTML 文档正文中的 <code>for</code> 循环。<code>&lt;% %&gt;</code> 包括 Raku 语句，<code>&lt;%= %&gt;</code> 片段只是包括变量的值。所以在这里，我们是把一个以文件路径为键、以标题为值的哈希，并从每一个文件中创建一个列表项。但这个模板必须从程序本身使用，就像这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Raku::Recipes;
use Markit;
use Template::Classic;
use Text::Markdown;

my $md = Markdown.new;
my &amp;generate-page := template :($title,$content),
                        template-file( "templates/recipe-with-title.html" );

my %links;
for recipes() -&gt; $recipe {
    my $this-md = parse-markdown-from-file($recipe.path);
    my $html-fragment = recipe($md,$recipe);
    my $title = $this-md.document.items[0].text;
    note "Can't find title for $recipe" unless $title;
    my @page = generate-page( $title, $html-fragment );
    my $path = spurt-with-dir($recipe, @page.eager.join );
    $path .= subst( "build/", '' )
    %links{$path} = $title;
}

my &amp;generate-index:= template :( %links ),
                        template-file( "templates/recipes-index.html" );
spurt("build/index.html", generate-index( %links ).eager.join);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个程序中，为了清晰起见，再次取消了例程。前一个脚本的第一行已经被转换为模板文件例程，找到文件的存储位置并加载它。</p>
</div>
<div class="paragraph">
<p>这个程序与第一个版本非常相似。第一个变化是页面模板现在包含了食谱的标题，我们使用 <code>Text::Markdown: my $title = $this-md.document.items[0].text</code> 来提取。</p>
</div>
<div class="paragraph">
<p>请注意，尽管是 markdown 解析器，但我们不能使用 Markit，因为它没有提供实际获取文档解析版本的接口。因此，我们对 <code>.md</code> 文档进行了两次解析。</p>
</div>
<div class="paragraph">
<p>您还会发现，<code>spurt-with-dir</code> 现在会返回用于 HTML 文件的路径名。我们将需要它来创建链接哈希。使用 <code>subst</code>，我们去掉了使用的构建目录的前缀，并将其存储在哈希中。</p>
</div>
<div class="paragraph">
<p>索引生成语句由几句话组成：一个是为这个模板构建 <code>templater</code>（和之前看到的一样），另一个是把它保存到标准位置，<code>build/index.html</code>。其结果将如图10-2所示。</p>
</div>
<div class="paragraph">
<p>图10-2.菜谱网页索引 食谱网页索引</p>
</div>
<div class="paragraph">
<p>其余页面的生成将如图10-2所示，只是它们的名称将在 HTML 文件的标题标签中。</p>
</div>
<div class="paragraph">
<p>使用这些简单的模板和一个小的 Raku 脚本，静态网站的生成是快速和相当灵活的，因为你可以自定义脚本（和模板的脚本部分）来创建你喜欢的东西。如果你需要的是更完整的东西，比如生成一个博客，每个新文件都会再生不同的文件，从索引到 RSS 订阅，可能你需要的是 Uzu。Uzu 是高度可编程的，可配置的，而且速度也相当快。不过，对于一个由一组网页和一个索引组成的简单网站来说，只需要两个模板和一个脚本就可以了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_10_3_创建一个词典并在上面进行快速搜索">8.3. 食谱 10-3. 创建一个词典并在上面进行快速搜索</h3>
<div class="sect3">
<h4 id="_问题_30">8.3.1. 问题</h4>
<div class="paragraph">
<p>有一组单词及其定义，你需要通过单词或内容进行快速搜索。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方案_4">8.3.2. 解决方案</h4>
<div class="paragraph">
<p>使用 Data::StaticTable，一个具有快速索引功能的内存数据库。它是如何工作的</p>
</div>
<div class="paragraph">
<p>当你知道键，并且需要访问对应的值时，哈希值是很好的。然而，做逆向搜索，也就是找到与值相对应的键，就不是那么容易了，尤其是当你需要在几列上扩展搜索时。当然，数据库是很好的选择，但如果可能的话，数据库的速度并不比在内存中做快，除了你的脚本外，你还需要额外的工具。使用类似于数据库的东西，但在内存中，正是我们要找的。</p>
</div>
<div class="paragraph">
<p>就像我们需要以特定的方式安排数据将其放入数据库一样，我们需要安排数据将其输入到静态表中。我们接下来会做这个工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Data::StaticTable;
use Raku::Recipes::Texts;


my %recipes = Raku::Recipes::Texts.new().recipes;

my @recipes-table;
for %recipes.kv -&gt; $title, %content {
    @recipes-table.append: [ $title,
                             %content&lt;description&gt;,
                             %content&lt;ingredients&gt;.join ];
}

my $recipes = Data::StaticTable.new(
        &lt;Name Description Ingredients&gt;,
        ( @recipes-table)
        );

my $recipe-query =  Data::StaticTable::Query.new($recipes); # Query object

$recipe-query.add-index( "Ingredients" );

my Data::StaticTable::Position @rice = $recipe-query.grep(rx/rice/,
        'Ingredients',n =&gt; True);
say $recipes.take( @rice ).display;</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先要观察的是，我们正在使用一个新的模块。Raku::Recipes::Texts. 这个模块使用我们在之前的食谱中使用的例程来创建一个单一的对象：一个包含（暂时是一部分）食谱文本-标题、描述和成分的哈希。哈希将使用食谱标题作为键，对于每个食谱，其值将包含两个附加键。描述和配料</p>
</div>
<div class="paragraph">
<p>请注意，当我们开始使用配方的其他部分时，我们会丰富这个模块。目前，它只是包含了新的方法和一个对属性配方的访问器，其中包含了刮取的数据。</p>
</div>
<div class="paragraph">
<p>我们在 %recipes hash 中得到从 markdown recipes 中抓取的文本，然后我们在上面运行一个循环，在每次迭代中提取标题（这是hash中使用的键）和值（另一个hash）。由于 Data::StaticTable 取一个数组，所以每一次迭代，我们都会增加一行，包含三列：食谱名称、描述和成分。</p>
</div>
<div class="paragraph">
<p>Data::StaticTable 需要列名和数据。我们用它创建 $recipes。它将包含我们的数据，并将用于搜索。但我们需要一个额外的 Query 对象来实现这一点。Data::StaticTable::Query 对象需要一个 Data::StaticTable 对象。此外，根据文档，你还可以添加一个索引，这将使搜索更快。</p>
</div>
<div class="paragraph">
<p>Data::StaticTable 查询使用已知的方法 grep；它们不是只取一个表达式，而是同时取一个表达式和你要搜索的列。我们想搜索含有大米的食谱，这就是我们在这个查询中要做的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Data::StaticTable::Position @rice =
        $recipe-query.grep(rx/rice/, 'Ingredients'):n;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它返回一个 Data::StaticTable::Position 类型的对象。这些对象就像索引一样，只是它们可能包含附加信息。我们可以像使用定位一样使用它们来获取包含该术语的表行。我们使用显示方法，使结果类似于数据库查询。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Name   Description  Ingredients
............   .................................  .........................
["Tuna risotto"]   ["A relatively simple version of this rich, creamy dish of Italian origin."]   ["500g tuna\n\n 250g rice\n\n 1⁄2 onion\n\n 250g cheese (parmegiano reggiano or granapadano, or manchego)\n\n 1 tbsp extra virgin olive oil\n\n 4 cloves garlic\n\n"]
(This might look better on a bigger screen.)</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可能会发现在查询结果后面有一个 <code>:n</code>。冒号后缀的字词被称为副词；它们相当于设置为 True 的标志（如果冒号后面是感叹号，也就是 bang）。为静态表查询定义的 grep 方法需要几个命名的参数，其中一个是 <code>:$n</code> 在这种情况下，它将返回行号而不是内容，或者其他格式。但是你可能已经注意到我说的是命名参数，而不是副词。这是因为子程序和方法中的命名参数也可以作为副词应用。该调用相当于下面的内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Data::StaticTable::Position @rice =
        $recipe-query.grep(rx/rice/, 'Ingredients', :n );</code></pre>
</div>
</div>
<div class="paragraph">
<p>或:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Data::StaticTable::Position @rice =
        $recipe-query.grep(rx/rice/, 'Ingredients', n =&gt; True);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里使用 <code>:n</code> 的方式比较特殊，但在乐乐中完全允许。请记住，总是有不止一种方式。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_10_4_计算纯文本文档的差异">8.4. 食谱 10-4 计算纯文本文档的差异</h3>
<div class="sect3">
<h4 id="_问题_31">8.4.1. 问题</h4>
<div class="paragraph">
<p>你需要确定一个文档的两个版本之间是否有任何变化，并确定这些变化是什么。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_20">8.4.2. 解决办法</h4>
<div class="paragraph">
<p>如果文档是 Git（或其他源码控制）仓库中同一文档的版本，如果你知道这两个版本所在的提交，你可以直接用 Git 计算这个差异。如果不知道，生态系统中的不同模块会给你这个差异。Algorithm::Diff 是最老牌的，File::Compare 功能更全，Text::Diff::Sift4 是最新的，可能也是最快的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_31">8.4.3. 它是如何工作的</h4>
<div class="paragraph">
<p>假设你需要检查传入配方的新版本，并确定它们到底有什么不同，这样你就可以创建一个单页，在点击时呈现两个版本。你正在比较文本文件，你需要知道哪些行是不同的。</p>
</div>
<div class="paragraph">
<p>我们将创建一个我们之前使用的食谱的新版本，一个金枪鱼烩饭。新版本将使用金枪鱼罐头和人造黄油代替橄榄油。为了测试 Raku 的这些功能，我们来测试一下。</p>
</div>
<div class="paragraph">
<p>我们先来试试 File::Compare。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant $prefix = "recipes/main/rice/";
say "Different"
    if files_are_different( "$prefix/tuna-risotto.md",
                                     "$prefix/tuna-risotto-low-cost.md");</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个只会告诉我们文件是否不同，所以如果我们想快速检查，或者我们使用的是非文本文件，它可能是好的。然而，它在这里并不符合我们的目的。让我们用这个脚本试试 Text::Diff::Sift4。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant $prefix = "recipes/main/rice/";
say sift4( "$prefix/tuna-risotto.md".IO.slurp,
               "$prefix/tuna-risotto-low-cost.md".IO.slurp, 100, 400);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个模块只有一个函数，而且它的编程速度很快。然而，这只是返回43作为两个"字符串"中不同字符的数量（这是在我们啜饮整个文件进行检查时）。同样，它不仅可以作为快速检查是否存在差异，而且可以检查差异有多大。我们在这里寻找更具体的东西。</p>
</div>
<div class="paragraph">
<p>让我们尝试下一个建议的模块，Algorithm::Diff。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Algorithm::Diff;

constant $prefix = "recipes/main/rice/";
for sdiff( "$prefix/tuna-risotto.md".IO.lines, "$prefix/tuna-risotto-low-cost.md".IO.lines).rotor(3)
    -&gt; ($mode, $deleted, $added ) {
    say qq:to/EO/ unless $mode eq 'u';
# $mode
    ← $deleted
    → $added
EO

};</code></pre>
</div>
</div>
<div class="paragraph">
<p>这正是我们想要的。输出将是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">#c
    ← * 500g tuna
    → * 500g canned tuna

#c
    ← * 250g cheese (parmegiano reggiano or granapadano, or manchego)
    → * 250g whatever cheese is in your fridge

#c
    ← * Extra virgin olive oil
    → * 2 tablespoons olive oil

#+
    ←
    → * 1 tablespoon butter or margarine.</code></pre>
</div>
</div>
<div class="paragraph">
<p>c表示 "改变"，"+" 表示新的行。这个模块的 API 非常简单：sdiff 比较两个文件的行数（这就是为什么我们要读取文件并提取它们），然后输出变化。我们需要把它们分成三组（因此有了 <code>.rotor(3)</code>）来理解这一切。第一个是变化的类型，第二个和第三个是第一和第二个文件中的行。我们使用签名来解构数组中的每一次迭代，在循环内部使用的三个变量中，有三个由 <code>rotor</code> 产生的元素：<code>$mode</code>、<code>$deleted</code> 和 <code>added</code>。</p>
</div>
<div class="paragraph">
<p>我们使用 heredoc 格式（你在第3章中看到的）以一种漂亮的格式来呈现。<code>unless</code> 语句会过滤掉用 u 标记的行，即"未更改"，以便只显示更改。</p>
</div>
<div class="paragraph">
<p>它也足够快，而且它可能适合大文件。所以这就解决了这个问题。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_微服务">9. 微服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>网站的世界让位于网络服务的世界，这最终催生了微服务的世界，微服务是一种小型的反应式应用，具有 REST API，使用 JSON 或其他序列化语言响应 HTTP 命令。自从引入 Cro 微框架后，与微服务相关的大部分需求都被覆盖了。在本章中，我们将看到如何以几种不同的方式使用这个微框架。</p>
</div>
<div class="sect2">
<h3 id="_菜谱_11_1_创建一个微服务问题">9.1. 菜谱 11-1. 创建一个微服务问题</h3>
<div class="paragraph">
<p>你需要创建一个微服务，作为你提供的服务的 API。</p>
</div>
<div class="sect3">
<h4 id="_解决方案_5">9.1.1. 解决方案</h4>
<div class="paragraph">
<p>使用 Cro - Raku 首屈一指的微服务框架，在您的业务逻辑上创建一个层。它可以同时工作，并且可以使用 Raku习 语轻松编程。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_32">9.1.2. 它是如何工作的</h4>
<div class="paragraph">
<p>现在的应用架构是由不同的微服务组成的复杂网状结构，这些微服务被服务总线绑在一起并部署到云端。这种复杂性使得创建能够有效服务于许多不同前端的后端变得更加容易。他们通过创建小型服务来实现这一目标&#8212;&#8203;事实上，这些服务小到可以独立于应用程序的其他部分进行设计、实现、部署和测试，只要尊重接口即可。这使得整个应用程序更加可靠，并通过独立扩展组成应用程序的微服务来保持服务时间的统一。这也使得应用对云资源的使用效率更高，因为云资源通常是按使用付费的。</p>
</div>
<div class="paragraph">
<p>不管怎么说，微服务的整个要点是提供一个可替代的、独立于语言的、可以从不同前端消费的 API，所以它通常是围绕现有的类或模块设计的。从架构的角度来看，将业务逻辑和API分开总是很重要的，这样它们就可以独立开发和测试。</p>
</div>
<div class="paragraph">
<p>这个 API 是围绕 HTTP 动词 - GET、POST、PUT 和 DELETE - 和状态码建立的，200 表示 "一切正常"，当出现某种客户端错误时，返回 4xx。然后，API 是围绕路由创建的，路由的功能相当于对象或模块。这些路由与 URI 一起工作，对象的生命周期重复使用同一个 URI。</p>
</div>
<div class="paragraph">
<p>在本例中，我们将为我们的成分数据库创建一个微服务。我们将使用 <code>/Ingredient</code> 路由，URI 将把原料的（大写）名称添加到这个片段中。我们的第一个微服务将返回我们所拥有的关于一个原料的信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::HTTP::Server;
use Cro::HTTP::Router;
use Raku::Recipes::Roly;

my $rrr = Raku::Recipes::Roly.new();
my $recipes = route {
    get -&gt; "Ingredient", Str $ingredient {
        content 'application/json', $rrr.calories-table{$ingredient};
    }
}
my Cro::Service $μservice = Cro::HTTP::Server.new(
    :host('localhost'),
    :port(31415),
    application =&gt; $recipes
);
$μservice.start;

react whenever signal(SIGINT) {
    $μservice.stop;
    exit;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用两个 Cro 模块，Cro::HTTP::Server 和 Cro::HTTP::Router。第一个包含多线程服务器，另一个用于创建路由。Cro 是一个模块化的框架，它有不同的下载模块来实现不同的功能。这些模块可以通过发出 <code>zef install Cro::HTTP</code> 来安装。</p>
</div>
<div class="paragraph">
<p>提示记住，这些代码都在书的 repo 里，每一章都有自己的 META6.json，主要是你进入目录后，只要写 <code>zef install -deps-only .</code> 就可以安装所有具体的模块。</p>
</div>
<div class="paragraph">
<p>路由命令用于创建我们的应用程序将拥有的所有路由，首先是命令（本例中是 get），然后是一个 Raku 块，我们为其提供位置参数，其序列创建路由。在本例中，这两个参数是 <code>Ingredient</code>，然后是将用于食材名称的变量 <code>$ingredient</code>。这两个参数一起构成了用于检索原料数据的 URI。例如，一个 URI 可以是 <code>/Ingredient/Rice</code> 或 <code>/Ingredient/Olive+Oil</code>。由于 URI 需要用 MIME 编码，所以空格会被转换为 <code>+</code>。如果你决定使用浏览器来测试，浏览器会帮你做这件事。</p>
</div>
<div class="paragraph">
<p>请注意，"试水"是可以的，但不是测试微服务的正确方式。你需要一个适当的集成测试，这就是我们将在本章下一个到最后一个配方中看到的。</p>
</div>
<div class="paragraph">
<p>同一模块还提供了内容顺序，取两个参数。MIME 类型和实际内容。这个顺序是很聪明的，因为只要它知道如何转换数据结构，它就能将数据结构转换为足以满足 MIME 类型的东西。在这种情况下，它只是 JSON，所以它知道如何做。我们返回描述每一个成分的哈希值，结果就像图11-1所示，从浏览器上看。</p>
</div>
<div class="paragraph">
<p>图11-1.从浏览器访问微服务</p>
</div>
<div class="paragraph">
<p>这部分定义了路由，但我们需要定义微服务，设置它要使用的地址（这将决定它要监听的接口），它要使用的端口（我喜欢 pi 端口，31415），以及要被服务的应用程序的名称。很明显，我们把这个变量称为 <code>$μservice</code>，使用希腊字母 mu。</p>
</div>
<div class="paragraph">
<p>最后，我们需要启动微服务，并设置一种方法来实际停止它。它将一直运行，直到进程收到停止信号，也就是大多数操作系统中的 Ctrl+C 或命令行中的 kill 命令。我们可以从命令行启动它，如果那个端口是空闲的（为什么不空闲呢），我们就可以使用它。事实上，我们可以使用 Cro 创建一个小型客户端，就像我们在第9章所做的那样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::HTTP::Client;
my $ingredient = @*ARGS[0] // "water";
my $cro = Cro::HTTP::Client.new( base-uri =&gt; "http://localhost:31415/Ingredient/" );
my $response = await $cro.get( $ingredient );
say await $response.body;</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于我们使用的是标准接口，我们不需要包含我们要提取信息的类。我们只需要知道如何构建访问资源的 URL。这将把 JSON 表示打印到控制台，因为它只是对微服务的访问通道。但只要我们不需要担心微服务的实现，我们也可以用不同的语言创建一个客户端。比如说 Python。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">import requests
import sys

if len(sys.argv) &gt; 1:
    ingredient = sys.argv[1]
else:
    ingredient = "Rice"

with requests.get('http://localhost:31415/Ingredient/'+ingredient) as r:
    if (r.status_code == 200):
        print(r.text)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的主要区别是，我们不对产生的 JSON 进行解码。另外，我们检查状态码是否正确，但本质上是一样的。在一天结束的时候，REST API 是访问任何一种微服务的标准方式。
我们可以使用另一种访问内容的方式，使用 web 下载器，如 curl（或 wget）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">curl http://localhost:31415/Type/Vegan
["Olive Oil","Green kiwi","Sundried tomatoes","Apple","Orange","Kale","Kidney beans","Lentils","Rice","Tomato","Potatoes","Cashews","Chickpeas","Beer"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>但事情可能会出错，而且会出错，第8章给你上了一课（或两课）如何处理这个问题。当我们试图访问一个不存在的成分时，我们至少需要以某种合理的方式做出反应。处理错误的最好方法是完全避免它，我们可以使用乐的签名来做到这一点（再次）。这只是路径定义，脚本的其他部分和之前一样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $recipes = route {
    get -&gt; "Ingredient", Str $ingredient where $rrr.is-ingredient($ingredient) {
        content 'application/json', $rrr.calories-table{$ingredient};
    }

    get -&gt; "Ingredient",
           Str $ingredient where !$rrr.is-ingredient($ingredient) {
        not-found;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们已经说过，Cro 路由得到的区块不同，调用约定也就相当于区块签名。我们可以在签名中进行类型检查：<code>$ingredient</code> 是一个真实的，所以它是可以的。它得到一个块，它用我们掌握的关于它的数据来回答。但是，我们可以抓住它不也在签名中的事实：当它不是成分时，第二个路由会开火，它只是使用 not-found 命令，这将使 Raku 生成正确的响应。如图11-2所示，这是从 Postman API 测试应用中看到的。</p>
</div>
<div class="paragraph">
<p>图11-2. 从 Postman 应用中看到的微服务404响应，在图像的底部</p>
</div>
<div class="paragraph">
<p>这种机制是相当灵活的，它也能更清晰地显示出应用所遵循的执行路径。但即便如此，把所有的路径都归纳在一个地方也不方便。另外，我们希望我们的微服务，只要包含一个高效的 Web 服务器，就可以兼任我们在上一章生成的静态网页的服务器。我们还将增加一些路由&#8212;&#8203;例如，一个返回所有具有特征的食材的路由，例如属于素食菜肴。这就是结果。再一次，只是显示了路由。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub static-routes {
    route {
        get -&gt; *@path {
            static 'build/', @path, :indexes&lt;index.html index.htm&gt;;
        }
    }
}

sub type-routes {
    route {
        get -&gt; Str $type where $type ∈ @food-types {
            my %ingredients-table = $rrr.calories-table;
            my @result = %ingredients-table.keys.grep: {
                %ingredients-table{$_}{$type}
            };
            content 'application/json', @result;
        }
        get -&gt; Str $type where $type ∉ @food-types {
            not-found;
        }
    }
}

sub ingredient-routes {
    route {
        get -&gt; Str $ingredient where $rrr.is-ingredient($ingredient) {
            content 'application/json', $rrr.calories-table{$ingredient};
        }
        get -&gt; Str $ingredient where !$rrr.is-ingredient($ingredient) {
            not-found;
        }
    }
}

my $recipes = route {
    include "content" =&gt; static-routes,
    "Type"            =&gt; type-routes,
    "Ingredient"      =&gt; ingredient-routes;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>从程序结构和总体架构的角度来看，这里有几个改进。路由已经被划分为块，然后被包含在一组单一的路由中，将由微服务提供服务。</p>
</div>
<div class="paragraph">
<p>我们定义了一个新的静态路由，它将负责静态内容。静态命令将返回文件，在同一个命令中，我们还定义了该索引。</p>
</div>
<div class="paragraph">
<p>htm 或 index.html 将是默认的索引。这些文件是在 <code>build</code> 子目录中创建的，所以那是用来构建路由的。URL 将被碎片化为一个 <code>@path</code>，这个路径将被重构为一个文件路径，并被返回。</p>
</div>
<div class="paragraph">
<p>我们创建的路由是为了响应某种类型的成分，它的模式与我们之前使用的相同。如果该类型确实存在（<code>@food-types</code> 是从 <code>Raku::Recipes</code> 导入的），它将返回一个配料列表，如果不存在，则返回 404。另一个路由块， <code>ingredient-routes</code>，和上一个版本一样，除了一个小细节：路由本身。</p>
</div>
<div class="paragraph">
<p>这种表达路由的方式可以将逻辑和它要挂到的路由解耦，这让设计者在修复路由的时候更加灵活。那么路由名称在哪里定义呢？我们在一个 <code>include</code> 语句中定义：它是一个哈希，以路由 URI 片段为键，以它要被路由到的子为值。因此， <code>Ingredient</code> 将会被路由到与之前相同的代码，只是现在这个路径没有被嵌入到代码中，而是完全独立的。</p>
</div>
<div class="paragraph">
<p>在这些例子中，我们只使用了 GET 路由，因为它们足够简单，而且不会改变内容。最初，我们并不打算让我们的一套配方从任何地方改变，而是从文件中改变。然而在更一般的环境下，可以从 Cro 使用 PUT 和 POST 来创建新的资源，也可以使用 DELETE 来删除它们。只需将路径中的 <code>get</code> 语句改为 post、put 或 delete 即可。这是一个简短的"茶水间 " web 服务的例子，它介绍了茶水间中的食材，显示了存储的食材，还可以删除其中的一种。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub keep-routes is export {
    route {
        put -&gt; Str $ingredient where $rrr.is-ingredient($ingredient) {
            $pantry ∪= $ingredient;
            say $pantry;
            content "application/json", $pantry.list;
        }

        get -&gt;  {
            content "application/json", $pantry.list;
        }

        delete -&gt; Str $ingredient where $rrr.is-ingredient($ingredient) {
            if $ingredient ∈ $pantry {
                $pantry ∖= $ingredient;
            }
            content "application/json", $pantry.list;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请求的内容是以完全相同的方式检索的。它将作为一个参数被处理到路由中，我们可以用之前的方式为它添加签名检查。  <code>$pantry</code> 变量已经被定义为一个集合，我们对它使用集合操作，以便添加一个新的成分，或者使用\集差操作符删除它。在每一种情况下，请求都会返回 pantry 的当前状态，将其转换为 list，因为 content 只接受可以实际转换为 json 的数据结构。我们也可以使用 curl 进行请求。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">% curl -X PUT http://localhost:31415/pantry/Rice
[{"Rice":true}]
% curl -X PUT http://localhost:31415/pantry/Tuna
[{"Tuna":true},{"Rice":true}]
% curl http://localhost:31415/pantry
[{"Tuna":true},{"Rice":true}]
% curl -X DELETE http://localhost:31415/pantry/Tuna
[{"Rice":true}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>当一个集合被转换为一个列表时，它被转换为一个对的列表（"Element" &#8658; True），这就是为什么在这里这样显示。如果我们想只显示元素，我们可以简单地只提取对的键。</p>
</div>
<div class="paragraph">
<p>这个配方给你提示了 Cro 的可能性。我们将在接下来的配方中看到更多的可能性。但在这些配方之前，你可能想跳转到本章的最后一个配方，关于测试这个非常微服务。因为测试很重要。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_11_2_使用_web_套接字连接到客户端">9.2. 食谱 11-2. 使用 Web 套接字连接到客户端。</h3>
<div class="sect3">
<h4 id="_问题_32">9.2.1. 问题</h4>
<div class="paragraph">
<p>您想在您的网站上创建一个交互式服务，例如，通过提供一个 websocket 接口，创建一个机器人。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_21">9.2.2. 解决办法</h4>
<div class="paragraph">
<p>Cro 是一个通用的网络计算框架。它可以路由你的 websocket 调用，并创建一个你可以反应的供应。一个特定的模块，Cro::WebSocket，是用来处理 websocket 的，从客户端或从服务器端。我们将更多地关注服务器端。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_33">9.2.3. 它是如何工作的</h4>
<div class="paragraph">
<p>Websockets 是一种相对较新的技术，可以用来使网站更加动态和响应。由于它们打开了一个永久的连接，而不是普通的 vanilla HTTP 使用的无状态连接，它们可以用来实现迭代服务，如聊天或小机器人。</p>
</div>
<div class="paragraph">
<p>我们要创建一个迭代服务，一个小小的卡路里计算机，它可以获取一种食材的数量，并返回其中的卡路里数量。例如，用户可能会输入一个250克的苹果，会得到该量的苹果的卡路里。</p>
</div>
<div class="paragraph">
<p>我们将为此创建一个 websocket 服务器。我们将使用 cro 命令行工具为实现生成一个存根。这个工具是独立于 Cro 所拥有的其他模块，从 Raku 生态系统中安装的，一旦完成，就可以从命令行中使用它。将自己放置在你想要模块所在的目录中后，写下类似下面的内容。</p>
</div>
<div class="paragraph">
<p>cro stub http calories calories ':!secure :websocket'</p>
</div>
<div class="paragraph">
<p>我们将在一个名为 calories 的子目录中生成一个名为 calories 的 HTTP 服务，该服务将使用 HTTP（而不是HTTPS，也就是 <code>!security</code>，意思是"不安全"），并且它将成为一个 websocket 服务器（因此，副词形状的标志）。所有选项都用单引号写。</p>
</div>
<div class="paragraph">
<p>这将生成一大堆文件，包括一个 Dockerfile 和一个 META6.json 文件，以及一个启动服务器的脚本，并包含一个名为 Routes 的模块，其中将包含服务。我们将按原样使用服务器，我们将在 Routes 模块上下功夫，该模块还包括一个用于响应请求和服务结果的锅炉板。这将是 lib 子目录下的一个模块。它还将生成一个像这样的 Cro 配置文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">---
name: calories
env:  []
entrypoint: service.p6
links:  []
endpoints:
-
id: http
    port-env: CALORIES_PORT
    name: HTTP
    host-env: CALORIES_HOST
    protocol: http
id: calories
cro: 1
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的要点是，它使用了一系列环境变量，专门与这个服务一起定义。这是微服务的标准最佳实践。它还为这个服务定义了 Cro 版本（1）（在 "cro" 键中）和一个 ID，也是卡路里。原则上，我们不需要进一步担心这个文件，尽管我们可能要改变环境变量的名称或入口点的名称。这个文件也会被 Cro 命令行用来启动服务。</p>
</div>
<div class="paragraph">
<p>总之，这就是命令行要为我们做的工作范围。我们还得编写路由。首先，我们要负责解析将通过套接字向我们发送的"命令"。在上一章中，我们解析了一部分配方文件的配料行。然而，我们在实际处理完整的配料描述本身时却停了下来。我们现在就需要这样做，这样我们就可以制作一个新的语法来处理这个问题。</p>
</div>
<div class="paragraph">
<p>让我们先重用我们能重用的东西。语法已经由元对象协议创建，与 Raku 中的其他类型对象一样。它们在很多方面都类似于类。它们也类似于角色吗？嗯，是的，它们是。所以，让我们把两个标记分拆成它们自己的角色，可以说是一个 grammarole，这样我们就可以重复使用它们。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit role Raku::Recipes::Grammar::Measures;
token quantity { &lt;:N&gt;+ }
token unit     { "g" | "tbsp" | "clove" | "tbsps" | "cloves" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>好吧，去过，做过。这看起来像一个语法，行为也像一个语法，但实际上是定义为一个角色。作为一个角色，我们可以像这样把它混入 grammar 中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Raku::Recipes::Roly;
use Raku::Recipes::Grammar::Measures;

my @products;
BEGIN {
    @products = Raku::Recipes::Roly.new.products;
}

unit grammar Raku::Recipes::Grammar::Measured-Ingredients does Raku::Recipes::Grammar::Measures;
token TOP      { &lt;quantity&gt; [\h* &lt;unit&gt; \h+ &lt;ingredient&gt; | \h+ &lt;ingredient&gt;] }
token ingredient {:i @products }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个新的语法中，除了组成一个角色之外，还有几个有趣的地方。我们使用 <code>BEGIN</code> 块来初始化一个变量，这个变量将在里面使用。我们需要知道类中哪些产品是可用的，才能正确地进行解析。<code>BEGIN</code> 就是所谓的相位器，也就是保证在编译过程的某个阶段运行的块。这将在编译时运行，并且只运行一次，给 <code>@products</code> 分配一个值，这个值将被烘焙到存储的预编译二进制中。</p>
</div>
<div class="paragraph">
<p>但是，这两个 token 也很有意思。一个使用这个变量，实际上相当于 <code>"product1" | "product2"</code>&#8230;&#8203;&#8230;&#8203;以此类推，对数组中的每一个产品都是如此。数组可以在 regex 中进行插值（token 只是 regex，记住），达到这个效果。我们还在开头加了一个副词，表示它将不区分大小写。我们不在乎人们是写 pasta 还是 Pasta 或者 PaStA。它仍然会被选中。</p>
</div>
<div class="paragraph">
<p>TOP token 还使用了交替：要么我们有1个鸡蛋这样的东西（数量+原料），要么我们有100克苹果这样的东西（数量+单位+原料）。这个交替就解决了这个问题，能够同时匹配这两种情况。</p>
</div>
<div class="paragraph">
<p>注意: 我们在 Raku::Recipes 模块中也用稍微不同的方式解决了这个问题，使用了正则表达式和多个schedule。记住，在 Raku 中做事总是不止一种方式。</p>
</div>
<div class="paragraph">
<p>让我们进入 websocket 服务器本身。首先，我们需要建立一个客户端，否则我们将没有任何东西来检查它。一种选择是 websocat (<code><a href="https://github.com/vi/websocat/releases" class="bare">https://github.com/vi/websocat/releases</a></code>)，但是，为了再次说明这种服务器与各种客户端的互操作性，我们将使用以下脚本。它改编自 ws 的例子，用 JavaScript 编写，使用 deno 运行时运行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">import {
  connectWebSocket,
  isWebSocketCloseEvent,
  isWebSocketPingEvent,
  isWebSocketPongEvent,
} from "https://deno.land/std/ws/mod.ts";
import { encode } from "https://deno.land/std/encoding/utf8.ts";
import { BufReader } from "https://deno.land/std/io/bufio.ts";
import { TextProtoReader } from "https://deno.land/std/textproto/mod.ts";
import { blue, green, red, yellow } from "https://deno.land/std/fmt/colors.ts";
const endpoint = Deno.args[0] || "ws://127.0.0.1:31415/calories";
/** simple websocket cli */
try {
  const sock = await connectWebSocket(endpoint);
  console.log(green("«Calories» webservice connected! (type 'close' to quit)"));
  const messages = async (): Promise&lt;void&gt; =&gt; {
    for await (const msg of sock) {
      if (typeof msg === "string") {
        console.log(yellow(`&lt; ${msg}`));
      } else if (isWebSocketCloseEvent(msg)) {
        console.log(red(`closed: code=${msg.code}, reason=${msg.reason}`));
      }
    }
  };
  const cli = async (): Promise&lt;void&gt; =&gt; {
    const tpr = new TextProtoReader(new BufReader(Deno.stdin));
    while (true) {
      await Deno.stdout.write(encode("&gt; "));
      const line = await tpr.readLine();
      if (line === null || line === "close") {
        break;
      } else {
        await sock.send(line);
      }
    }
  };
  await Promise.race([messages(), cli()]).catch(console.error);
  if (!sock.isClosed) {
    await sock.close(1000).catch(console.error);
  }
} catch (err) {
  console.error(red(`Could not connect to WebSocket: '${err}'`));
}
Deno.exit(0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个脚本会出现一个提示，会通过 websocket 发送你输入的内容，如果你写的是 close 或空行，就会关闭连接。默认情况下，它使用的是 websocket 的 URL，即 <code>ws://127.0.0.1:31415/calories</code>（但你可以在命令行中使用一个参数来更改）。Web 套接字使用 ws（或 wss，对于安全的）协议，地址、端口和片段与 HTTP URL 差不多。我们要等到我们的 Webservice 设置好后再运行它。</p>
</div>
<div class="paragraph">
<p>下面是为 calories websocket 定义的路由，由之前生成的模板扩展而来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::HTTP::Router;
use Cro::HTTP::Router::WebSocket;
use Raku::Recipes::Grammar::Measured-Ingredients;
use Raku::Recipes::Roly;
my $rrr = Raku::Recipes::Roly.new;

sub routes() is export {
    route {
        my $chat = Supplier.new;
        get -&gt; 'calories' {
            web-socket -&gt; $incoming {
                supply {
                    whenever $incoming -&gt; $message {
                        $chat.emit(await $message.body-text);
                    }
                    whenever $chat -&gt; $text {
                        # Compute calories here
                        my $item =
                                Raku::Recipes::Grammar::Measured-
                                Ingredients
                                .parse( $text );
                        my $calories = $rrr.calories( ~$item&lt;ingredient&gt;, +$item&lt;quantity&gt;);
                        emit "Calories: for $text ⇒ $calories";
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然这里有一定的大括号超载，但其要点在最后的非闭括号行。我们得到文本，使用语法对其进行解析，然后从解析对象中提取成分和数量。</p>
</div>
<div class="paragraph">
<p>注意 我们可以，事实上也应该，验证单位是否相同。这个脚本会把 100tbsp 的意大利面，33g的鸡蛋，以及类似的东西传递给我们。我们可以尝试在语法层面，或者在这个语法层面来捕捉这些错误，但是我们暂时对正确的字符串被正确解析的事实感到满意。</p>
</div>
<div class="paragraph">
<p>这些都被输入到计算卡路里的例程中，然后返回一个带有结果的字符串。服务的名称，或者说通往它的路径，是作为一个参数给出的，以获取，这就是为什么我们使用上面的 <code>/calories</code> URL来访问这个服务。</p>
</div>
<div class="paragraph">
<p>从大的方面来看，它比这更复杂一些，涉及到几个耗材。但从本质上讲，从 Raku 的角度来看，websocket 服务器路由是一个供应品，其排放将到达客户端。我们发出结果字符串，该字符串将通过 websocket 被客户端接收。但实际发生的情况是，套接字通过 websocket 接收到一个传入的消息，该 websocket 解析消息，并通过我们为 websocket 创建的一个特定的供应，重新发出正文，这就允许对传入的请求进行异步处理。实际的处理是由第二个供应的接收端完成的，我们仍然像在模板代码中那样调用 <code>$chat</code>。总而言之，比 REST API 的处理方式略微复杂一些，但本质上和其他语言的处理方式类似，只是使用了 Raku 标准的数据结构和功能。</p>
</div>
<div class="paragraph">
<p>我们没有改变服务器脚本，所以我们直接从那里运行它。Comma IDE 包含了一个运行 Web 服务的特殊设施；我们将在这个场合使用它。我们创建一个执行配置，如图11-3所示。</p>
</div>
<div class="paragraph">
<p>图11-3. 从 Comma IDE 运行 websocket</p>
</div>
<div class="paragraph">
<p>注意，我们在图11-3中定义了我们要运行的两个环境变量。我们将使用 localhost 和常用的端口来运行。Raku 参数显示了我们需要包含的库的路径，Raku::Recipes，在 lib 处，还有路由，在所示路径中。</p>
</div>
<div class="paragraph">
<p>现在我们可以启动我们的客户端，并输入请求，得到的答案如图11-4所示。</p>
</div>
<div class="paragraph">
<p>图11-4. 从 deno 客户端消耗 websocket</p>
</div>
<div class="paragraph">
<p>我们使用命令行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">deno  run --allow-net ws-client.ts</code></pre>
</div>
</div>
<div class="paragraph">
<p>deno 需要明确允许使用网络，因为它运行在类似浏览器的沙盒中。正如你所看到的，它返回计算出的卡路里，以不同的颜色显示，并再次打开提示。关闭一词将有效地关闭连接。</p>
</div>
<div class="paragraph">
<p>对于 websockets，你也可以使用浏览器开发者控制台中的纯 JavaScript，通常按 Shift+Ctrl+C 就可以进入。在 Firefox 中的结果如图11-5所示。</p>
</div>
<div class="paragraph">
<p>图11-5. 从 Firefox 开发者控制台使用 websocket 进行工作</p>
</div>
<div class="paragraph">
<p>我们打开连接，然后设置一个事件，每次收到消息都会触发。我们记录消息所附带的数据，然后手动向套接字发送消息，在控制台中得到响应。</p>
</div>
<div class="paragraph">
<p>一般来说，这些 websocket 服务会作为一个小部件在网站内实现，或者作为一个微服务来为其他微服务服务。无论如何，这个配方已经向您展示了如何从头开始创建一个 websocket 微服务，如何从 Comma IDE 中运行它，以及如何使用不同的客户端服务来验证它的工作。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_11_3_为诸如_telegram_这样的消息应用程序创建一个迷你机器人">9.3. 食谱 11-3. 为诸如 Telegram 这样的消息应用程序创建一个迷你机器人</h3>

</div>
<div class="sect2">
<h3 id="_问题_33">9.4. 问题</h3>
<div class="paragraph">
<p>Telegram 和 Slack 等消息应用程序提供了另一种用户界面，即对话式界面，可以用来回答简单的询问，存储信息，甚至创建小游戏。这些请求可以在任何时候到达，对它们的响应必须是即时的，不会阻塞程序，而且还要尽可能快。我们需要一个敏捷的程序来快速响应这些请求。</p>
</div>
<div class="sect3">
<h4 id="_解决方案_6">9.4.1. 解决方案</h4>
<div class="paragraph">
<p>有了我们在配方11-2中创建的微服务，我们可以再创建一个层，通过这种方式挖掘它来服务信息。如果需要，我们也可以直接使用类中的业务逻辑。无论如何，Telegram 和 Slack 都有一个开源的 API。Slack 在 Raku 生态系统中的覆盖率没有那么高，只有一个模块可用于发送消息。至少有两个 Telegram 模块我们可以使用，所以我们将用其中一个模块创建一个 Telegram 机器人。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_34">9.4.2. 它是如何工作的</h4>
<div class="paragraph">
<p>我们将创建一个 Telegram 机器人，它可以计算卡路里的数量，给定一种原料的数量和单位。这意味着的第一件事是解析字符串，以便我们获得原料的单位、数量和名称。但我们之前已经做过了，对吗？对，虽然它允许错误的单位。让我们给这个配方来个转折。毕竟，我们对机器人的标准还挺高的，比其他类型的服务要高，对吧？</p>
</div>
<div class="paragraph">
<p>实现这个修复的方法有很多，例如，我们可以简单地从语法中发出一个语法错误，拒绝解析错误的字符串。然而，这说起来容易做起来难。在语法的构造方式中，当我们到达成分时，我们已经解析了单位和数量。在那一刻，我们可以尝试将原料与单位匹配，如果没有匹配，就拒绝解析，但错误不会在原料本身，而是在单位，所以我们需要回溯。我们将不得不重新组织整个语法，并通过回溯使整个过程变得更慢。</p>
</div>
<div class="paragraph">
<p>小贴士 顺便说一下，各个层次的语法在同一家出版社出版的一本书《Parsing with Perl 6 Regexes and Grammars》(Moritz Lenz) 中都有很棒的解释，如果你对它们很好奇，或者想更广泛地使用它们，不妨一试。</p>
</div>
<div class="paragraph">
<p>幸运的是，我们可以使用 Raku 机制在不同的层次上捕捉到这个错误，那就是通过一个动作。语法会给你一个抽象的语法树（AST），而附加在语法上的动作则会把这个 AST 编译成一个你可以随时使用的对象。到目前为止，我们一直在提取AST的部分内容来获取成分，或者其他什么。现在我们将一举解决两个问题：得到一个不需要知道解析结构的解析对象，以及检查是否在某个层次上有什么不正确的地方。我们将为这两步过程创建这个动作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Raku::Recipes::Roly;
use X::Raku::Recipes;
my $rrr = Raku::Recipes::Roly.new();
unit module Raku::Recipes::Grammar::Actions;

class Measured-Ingredients {
    method TOP($/) {
        my $unit = $/&lt;unit&gt;.made // "Unit";
        my $ingredient = $/&lt;ingredient&gt;.made;
        if ( $rrr.check-unit( $ingredient, $unit ) ) {
            make $ingredient =&gt;  $unit =&gt; $/&lt;quantity&gt;.made;
        } else {
            X::Raku::Recipes::WrongUnit.new( desired-unit =&gt; 'Other',
                    unit =&gt; $unit ).throw;
        }
    }
    method ingredient($/) {
        make tc ~$/;
    }
    method quantity($/) {
        make +val( ~$/  ) // unival( ~$/ )
    }
    method unit($/){
        make ~$/;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个 grammar action，在一个层面上，只是一个类。该类的实例将被嵌入到相应的语法中并产生结果。它的命名需要以某种方式与它们所服务的语法耦合，这就是为什么在这种情况下，它被称为Raku::Recipes::Grammar::Actions::Measured-Ingredients。通过将这个类放在一个模块中，我们已经将所有我们将在这里创建的动作放到了同一个 Raku::Recipes::Grammar::Actions 命名空间中，而且我们也可以通过使用一个单一的使用子句将它们一起加载。</p>
</div>
<div class="paragraph">
<p>类本身为语法中的每一个 token 都有方法；这些方法获得匹配对象 <code>$/</code> 作为参数，在该点进行匹配。方法获取该对象并生成另一个对象，该对象在该点被附加到抽象语法树上。<code>make</code> 命令在该点将其参数附加到 <code>$/</code> 上；<code>make</code> 相当于 <code>$/.make</code>。如果我们在单元标记处将某物附加到 <code>$/</code>，那么该结果将在该标记之上的任何地方可用，即 <code>$/&lt;unit&gt;.made</code>。</p>
</div>
<div class="paragraph">
<p>记住，<code>$/</code> 是一个匹配对象。我们需要把它强制转换成其他的东西，这就是为什么我们在 unit 中把匹配对象转换为字符串，而在 ingredient 中，我们使用 <code>tc</code>（标题大小写）命令转换并大写它（记住 ingredients 总是大写）。对于测量，我们做的事情和之前解析 CSV 时做的事情类似：根据 val 工作（ASCII数字）与否（对于 ⅔ 这样的东西），我们使用不同的方法将其转换为数字。</p>
</div>
<div class="paragraph">
<p>但是这个动作的关键是在 <code>TOP</code> 方法中；这是我们检查单位是否正确的地方，使用 Raku::Recipes::Roly 中适当调用的 <code>check-unit</code> 方法。如果它是正确的，我们返回一个对，其键是原料，其值是另一个对&#8212;&#8203;单位和数量。当没有单位时，我们也很方便地使用了 Unit，例如，在字符串 "3 Apple" 中。</p>
</div>
<div class="paragraph">
<p>注意，只要我们挑剔，我们也可以尝试在语法中哄骗复数。然而，我们需要在原始数据中添加更多的信息，以避免像3汤匙橄榄油或300克金枪鱼(tunae?)这样的东西表现为假阳性。如果需要的话，我们会去做，但目前我们对这类错误要宽容一些。</p>
</div>
<div class="paragraph">
<p>我们可以这样使用这个动作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $item = Raku::Recipes::Grammar::Measured-Ingredients.parse("2 egg",
        actions =&gt; Raku::Recipes::Grammar::Actions::Measured-Ingredients.new);</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将产生一个这样的对象。<code>Egg &#8658; Unit &#8658; 2</code>。这是相当方便的，我们可以将它用于我们的 Telegram 机器人。</p>
</div>
<div class="paragraph">
<p>如果你还没有使用它，Telegram 是一个消息应用程序，最初是由一个俄罗斯程序员创建的，它已经变得非常流行，这要归功于 的安全功能，灵活性，以及创建机器人的能力，这是其他商业聊天应用程序，如 WhatsApp 缺乏的。与 WhatsApp 不同的是，它还可以在手机关机的情况下工作，而且它有一个不错的、开源的、适用于所有平台的桌面应用。创建一个机器人是相当简单的，通过与一个叫 BotFather 的机器人对话来完成（还能怎么做？图11-6显示了我们如何创建这个。</p>
</div>
<div class="paragraph">
<p>图11-6. 通过与 BotFather 对话创建 RakuRecipesBot。</p>
</div>
<div class="paragraph">
<p>这个对话会给你一个密钥，我在这里把它模糊了。这是一个长长的字符串，将是你启动机器人微服务的令牌。</p>
</div>
<div class="paragraph">
<p>机器人的工作方式与微服务类似：它收到一条消息，并对其进行回复。它需要解析该消息以寻找特定的命令，或者理解该消息以给出答案。在这种情况下，我们会让我们的机器人以成分的措施来回应卡路里含量，比如我们在 websocket 服务器（或 websocker）中使用的那些。所以本质上，它将会攻克一个消息供应，并使用 API 来响应它们。这就是我们在这个程序中所做的事情。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env perl6

use Telegram;
use Raku::Recipes::Grammar::Measured-Ingredients;
use Raku::Recipes::Grammar::Actions;
use Raku::Recipes::Roly;

my $bot = Telegram::Bot.new(%*ENV&lt;RAKU_RECIPES_BOT_TOKEN&gt;);
my $rrr = Raku::Recipes::Roly.new;

$bot.start(1);

react {
    whenever $bot.messagesTap -&gt; $msg {
        say $msg.raku;
        my $item =  Raku::Recipes::Grammar::Measured-Ingredients.parse(
                $msg.text,
                actions =&gt;
                    Raku::Recipes::Grammar::Actions::Measured-Ingredients
                            .new).made;

        if $item {
            my $calories = $rrr.calories( $item );
            $bot.sendMessage($msg.chat.id,
            "{$item.value.value} {$item.value.key} of {$item.key} has $calories calories");
            say "{ $msg.sender.username }: { $msg.text } in { $msg.chat.id } → $item";
        } else {
            say "There's something wrong with the input string; can't compute calories";
            $bot.sendMessage( $msg.chat.id,
                    "Sorry, can't compute '{$msg.text}'");
        }
    }
    whenever signal(SIGINT) {
        $bot.stop;
        exit;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们通过创建一个使用我们获得的 API token 的对象来启动程序。像往常一样，API token 和各种安全信息必须从环境变量中读取。我们需要创建一个 Roly 对象来计算卡路里，然后我们启动机器人，告诉它每秒钟进行一次轮询。我们可以随意改变这个时间间隔。</p>
</div>
<div class="paragraph">
<p>当一个事件发生时，反应块将被运行。当收到消息并放入 <code>$msg</code> 变量时，它会通过 action和 <code>.made</code> 方法解析成一个对象。如果没有创建对象，就说明出了问题，就会激活 else 子句。我们发送一条消息说，我们不能用它工作；<code>$msg.text</code> 返回消息中的实际文本。</p>
</div>
<div class="paragraph">
<p>小贴士永远记得要对你的消息有所帮助，包括解释误解的起源。</p>
</div>
<div class="paragraph">
<p>然而，如果我们有一个解析过的成分对象，我们可以从中计算出卡路里。我们可以直接把它交给 Roly 中的 <code>calorie</code> 方法，它有一个新的 <code>multi</code>，直接取这种东西，一个 Pair，其值也是一个 Pair。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method calories( Pair $ingredient ) {
    return self.calories( $ingredient.key, $ingredient.value.value );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>既然我们已经知道这个单位没问题，我们就不需要给出这些信息来计算卡路里。它将返回一个数字，我们将把它作为消息发送，回应发出命令的特定用户；<code>sendMessage</code> 将聊天 ID 作为参数，以确保消息路由正确。在这两种情况下，我们也会向控制台打印一些信息来检查是否一切正常。这些信息不会被用户接收。</p>
</div>
<div class="paragraph">
<p>脚本从控制台或其他任何地方运行。它需要运行，它才能响应消息。有些人使用 el cheapo Raspberry Pis 在家里有一个机器人农场，一直在运行，但你也可以使用免费层级的云服务让它永久运行，例如在一个容器内运行。它的工作原理将如图11-7所示。</p>
</div>
<div class="paragraph">
<p>图11-7. 获取不同菜肴的热量</p>
</div>
<div class="paragraph">
<p>原则上，一个机器人可以做的事情是无限的。比如说，你可以添加认证功能。所有的配置都是通过 BotFather 来完成的。你也可以做繁重的任务，在这种情况下，你要增加并发性，以便在后台做其他任务。</p>
</div>
<div class="paragraph">
<p>Telegram 可以做的事情之一是响应命令。这些都是前面带 <code>/</code> 的"斜线"命令，通过在消息框中键入来发出。这些命令没有什么特别的，除了你可以用 BotFather 定义它们，当你输入斜杠时，UI 会列出它们。无论如何你都要对它们进行解析。然而，这很方便，因为它给你提供了一个简单的方法来解释机器人是什么以及它是如何工作的。让我们用三个命令 <code>--about</code>、<code>/products</code> 和 <code>/calories</code> --在这个脚本的第二个版本中工作（只包括反应块，因为它是唯一改变的东西）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">whenever $bot.messagesTap -&gt; $msg {
        $msg.text ~~ /\/$&lt;command&gt; = (\w+) \h* $&lt;args&gt; = (.*)/;
        say "$msg $&lt;command&gt;";
        given $&lt;command&gt; {
            when "calories" {
                gimme-calories($msg,$&lt;args&gt;)
            }
            when "products" {
                $bot.sendMessage($msg.chat.id, @products.join("-"));
            }
            when "about" {
                $bot.sendMessage($msg.chat.id, q:to/EOM/);
To query, use /calories Quantity [Unit] Ingredient or /products for the list of products
EOM
            }
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们需要对命令进行解析，我们使用正则表达式进行解析。一个命令永远是一个由字符组成的字符串，然后它可能有也可能没有一些更多的文本。如果有更多的文本，它将被捕获在 <code>$&lt;args&gt;</code> 中。</p>
</div>
<div class="paragraph">
<p>根据命令的不同，我们会发回不同的信息。前面计算卡路里的代码已经被分拆成自己的例程，叫做 <code>gimme-calories</code>。对于 <code>about</code> 命令将返回的消息，我们使用所谓的 <code>here-to</code> 语法，我们在第三章中第一次使用了这种语法。结果如图11-8所示。</p>
</div>
<div class="paragraph">
<p>图11-8. 使用斜杠命令与机器人对话</p>
</div>
<div class="paragraph">
<p>当我在这时，我给了机器人一个有趣的脸。它现在看起来更友好了 而且效率很高。</p>
</div>
<div class="paragraph">
<p>通过 Telegram 提供服务可以是一种很好的、方便的方式来提升你的业务，也可以做各种家庭自动化任务，甚至可以作为只基于网络的服务的补充。有了足够的后端，你就可以为它们提供服务，鉴于你可以使用 Cro 创建并发后端，如果需要的话，你可以将其与共享同一云实例的 websockers 或 web 服务以及数据服务一起嵌入。你将在接下来的章节中了解更多关于这些选项的信息。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_11_4_测试你的微服务问题">9.5. 食谱 11-4. 测试你的微服务问题</h3>
<div class="paragraph">
<p>如果没有经过测试，它就坏了。这也适用于微服务。归根结底，它们是另一种类型的函数，你需要检查其结果。因此，必须对它们的每一个方面进行测试，就像测试其他模块中的其他函数一样。</p>
</div>
<div class="sect3">
<h4 id="_解决办法_22">9.5.1. 解决办法</h4>
<div class="paragraph">
<p>Cro 包含一个测试框架，叫做 Cro::HTTP::Test。它可以很好地完成这项工作。</p>
</div>
<div class="paragraph">
<p>此图将以黑白打印</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_35">9.5.2. 它是如何工作的</h4>
<div class="paragraph">
<p>请注意，如果你是刚从第一个配方（食谱 11-1）中获得这个配方，那是极好的选择。如果不是，那个配方包含了我们要测试的微服务，所以你可能想先把它做完。</p>
</div>
<div class="paragraph">
<p>首先，你需要和本章的第一个配方一起进行。API 和它的测试需要同时开发，在本书中只是为了处理每个配方中的一个概念而将其分开。</p>
</div>
<div class="paragraph">
<p>理论上，路由只是简单的函数，所以应该有一种方法可以简单地通过调用它们并观察结果来测试它们。然而，实际上它们比这更复杂一些，因为它们是通过 HTTP 请求调用并返回 HTTP 响应的。那么理论上，我们可以直接启动服务，并为它们创建一系列的测试，黑盒式的。我们之前使用过的 Postman 也可以进行编程，有了它，我们可以用几种不同的语言创建一个黑盒测试套件。</p>
</div>
<div class="paragraph">
<p>我们对白盒测试比较感兴趣，因为我们可能想知道哪些代码路径是被占用的，而且不需要实际启动服务器、占用端口等。所以我们将使用一个本地的测试库。Cro::HTTP::Test。和其他 API 测试库的工作方式一样，它只需要访问需要测试的路由。在内部，它产生请求和响应，但不实际运行服务器。下面是一个使用它的简单测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::HTTP::Test;

require "ingredients-microservice-v3.p6" &lt;&amp;static-routes&gt;;
test-service static-routes, {
    test get('/'),
            status =&gt; 200,
            content-type =&gt; 'text/html',
            body =&gt; /recipes/;
}
done-testing;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在加入测试库后，我们需要 "require" 实现微服务的程序，并提供其正确的路径。与 <code>use</code> 不同的是，<code>require</code> 不会自动导入符号，所以我们需要在编译时声明它们。我们暂时只测试静态路由，所以我们需要导入这个。像我们一样将路由块声明为独立的例程，在这里也有好处。<code>Cro::HTTP::Test</code> 通过调用路由块来测试路由。如果直接把它们写进一个单独的变量中，我们就无法做到这一点。或者，我们可以吗？事实上，我们可以，因为在第二个版本中，我们将路由分配给的变量实际上是一个子程序。</p>
</div>
<div class="paragraph">
<p>但是，等等。<code>require</code> 是做什么的？还有，如果我不记得真正导出它，它怎么能导入例程呢？好吧，我们是有点作弊了。我们必须这样修改之前的程序（为了可读性，部分不变的部分被抑制）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub static-routes is export { ... }
sub type-routes is export { ... }
sub ingredient-routes is export { ... }
# Route block definition here
if ( $*PROGRAM eq $?FILE ) {...} # Fire up service</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以我们必须明确声明例程是可以导出的，这样才能导入测试。但更重要的是，<code>require</code> 会编译并运行它所加载的内容。</p>
</div>
<div class="paragraph">
<p>请注意，当你通过使用加载一个模块时也会发生同样的事情；定义之间的任何代码都将被运行，以及在该阶段运行的块&#8212;&#8203;例如，<code>BEGIN</code> 块。这是每一次加载的副作用，而且在这种情况下我们并不真正需要，因为它将启动服务页面的事件循环，并阻止在脚本中运行任何其他内容。</p>
</div>
<div class="paragraph">
<p>所以，像其他语言一样，我们检查文件是直接运行还是作为模块加载。<code>$*PROGRAM</code> 和 <code>$?FILE</code> 是系统定义的变量，取当前脚本使用的路径的值，以及当前文件的句柄。如果它们是一样的，那么，我们实际上是在同一个文件中运行。在字符串上下文中，<code>$?FILE</code> 会自动转换为字符串。如果我们正在测试，<code>$*PROGRAM</code> 将是测试程序的名称，而 <code>$?FILE</code> 将不会改变。在这种情况下，它们将是不同的，它将不会运行。</p>
</div>
<div class="paragraph">
<p>那么，回到测试本身。该模块引入了 <code>test-service</code> 命令，它的参数是路由例程的名称，或者，等等，<code>routingine</code>，以及有效启动测试的块。在它里面，我们需要为每一个测试提供一个测试命令，而这个命令首先使用 HTTP 命令和路由。由于该路由没有附加到任何 URL 片段，所以这里使用的路径将从根目录开始，<code>/</code>。</p>
</div>
<div class="paragraph">
<p>在这种情况下，我们测试的是路由的静态部分，即应该返回静态页面的部分；<code>/</code> 应该返回索引。在响应中，我们检查状态码是否正确(200)，类型是否正确(text/html)，以及正文中的内容是否正确。它应该包括 <code>regex/recipes/</code>，它包含在 css 文件的名称中，<code>raku-recipes.css</code>。</p>
</div>
<div class="paragraph">
<p>程序打印的结果如下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">ok 1 - Status is acceptable
    ok 2 - Content type is acceptable
    ok 3 - Body is acceptable
    1..3
ok 1 - GET /
1..1</code></pre>
</div>
</div>
<div class="paragraph">
<p>测试是保证软件质量的过程，好的测试不仅仅是告诉你一切正常，而是指出一些可以修复的怪癖。在这个案例中，虽然我们通过修改脚本展现了乐乐的灵活性，但还有更多的方法，其中之一就是简单的为路由创建一个模块。这第一次测试就产生了重构，这是好事。</p>
</div>
<div class="paragraph">
<p>这是我们为路由创建的模块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::HTTP::Router;
use Raku::Recipes::Roly;
use Raku::Recipes;

unit module My::Routes;

our $rrr = Raku::Recipes::Roly.new();
my Set $pantry;

sub static-routes is export {
    route {
        get -&gt; *@path {
            static 'build/', @path, :indexes&lt;index.html&gt;;
        }
    }

}

sub type-routes is export {
    route {
        get -&gt; Str $type where $type ∈ @food-types {
            my %ingredients-table = $rrr.calories-table;
            my @result =  %ingredients-table.keys.grep: {
                %ingredients-table{$_}{$type} };
            content 'application/json', @result;
        }
    }
}

sub ingredient-routes is export {
    route {
        get -&gt; Str $ingredient where $rrr.is-ingredient($ingredient) {
            content 'application/json', $rrr.calories-table{$ingredient};
        }
    }
}

sub keep-routes is export {
    route {
        put -&gt; Str $ingredient where $rrr.is-ingredient($ingredient) {
            $pantry ∪= $ingredient;
            say $pantry;
            content "application/json", $pantry.list;
        }

        get -&gt;  {
            content "application/json", $pantry.list;
        }

        delete -&gt; Str $ingredient where $rrr.is-ingredient($ingredient) {
            if $ingredient ∈ $pantry {
                $pantry ∖= $ingredient;
            }
            content "application/json", $pantry.list;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上，我们取消了 <code>not-found</code> 命令，这些命令是为了说明问题，因为如果没有找到该名称的路由，就会返回同样的内容。这是重构的一部分，当然，我们要对它进行测试。我们将其命名为 <code>My::Routes</code>，并将其放入 Chapter-11 文件夹的 <code>lib/</code> 子文件夹中。</p>
</div>
<div class="paragraph">
<p>这就是新的测试脚本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env perl6

use Cro::HTTP::Test;
use My::Routes;

test-service static-routes, {
    test get('/'),
            status =&gt; 200,
            content-type =&gt; 'text/html',
            body =&gt; /recipes/;
    test get('/index.html'),
            status =&gt; 200,
            content-type =&gt; 'text/html',
            body =&gt; /"Recipes: index"/;
    test get("/foo"),
        status =&gt; 404;
}

test-service type-routes, {

        test get("Dessert"),
            status =&gt; 200,
            json =&gt; /Apple/;

    test get("foo"),
            status =&gt; 404;
}

test-service ingredient-routes, {
    test get("Apple"),
            status =&gt; 200,
            content-type =&gt; "application/json",
            body =&gt; *&lt;Vegan&gt; == True;
    test get("Olive%20Oil"),
            status =&gt; 200,
            content-type =&gt; "application/json",
            body =&gt; *&lt;Vegan&gt; == True;
    test get("Fishtails"),
        status =&gt; 404;
}

done-testing;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们为每一个 <code>routingine</code> 都有一个测试块，在每一个测试块中，我们都会测试一些应该有的东西，但也会测试一些不应该有的东西。在微服务中，当事情没有问题的时候，总是要返回正确的状态，但当事情没有问题的时候，也要返回正确的状态。测试命令使用了一个位置参数，也就是我们要测试的路由。由于这些路由是独立的，所以它们都将以/为起点，就像我们在这个配方的上一次迭代中测试的静态路由那样。其余的命名参数将检查状态和返回的 MIME 类型，然后对 body 进行检查。由于得到 JSON 响应是很常见的，所以可以像这样同时测试是该类型和 body。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">test get("Dessert"),
    status =&gt; 200,
    json =&gt; /Apple/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>成功的测试和我们之前看到的类似。它们会检查状态、类型（在两个动态路由的情况下，类型将是 <code>application/json</code>）和一些应该在 body 中的东西。在 JSON 响应的情况下，它将作为默认变量可用，因此我们可以对它运行其他检查，例如，如果它们是素食主义者；这就是我们为苹果做的事情。</p>
</div>
<div class="paragraph">
<p>404测试就简单多了：你只需要检查它们是否返回该代码。状态码在头部，所以没有必要检查正文。这也是一种防御性编程。"未找到"应该总是以这种明确的方式返回，而不是通过200个成功响应的正文中的错误代码。</p>
</div>
<div class="paragraph">
<p>这些白盒测试覆盖了所有可能的代码路径。它们可能不会覆盖所有可能的数据路径，尽管在这种情况下，没有可能的角案例需要担心。一个问题可能是如何处理带有两个单词的成分（因此，一个空格），但只需将空格的 URI 编码为 <code>%20</code> 就可以了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">test get("Olive%20Oil"),
        status =&gt; 200,
        content-type =&gt; "application/json",
        body =&gt; *&lt;Vegan&gt; == True;</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过该模块，您可以轻松地将这些测试插入到持续集成服务中，并确保您将部署的所有软件的质量。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_11_5_应对_web_hooks_问题">9.6. 食谱 11-5. 应对 Web Hooks 问题</h3>
<div class="paragraph">
<p>网络钩子简单的说就是监听网络上其他地方发生的事件的程序，它们正在监听这些事件，当这些事件发生时对它们做出反应。当一些内部事件发生时，外部程序如源代码管理站点或持续集成站点会激活一个钩子，并期望从这些事件中得到响应。与消息应用一样，我们需要以这样的方式来响应每一个事件，这样做不会阻塞应用，同时也要及时有效地响应。</p>
</div>
<div class="sect3">
<h4 id="_解决方案_7">9.6.1. 解决方案</h4>
<div class="paragraph">
<p>本质上，一个响应 web 钩子的应用就是一个 web 服务，只不过它有一些特定的格式，需要遵循特定的准则进行响应。同样，用 Cro 制作的 web 服务也可以这样工作。由于我们需要实时的，或者至少是足够快的响应，一个好的解决方案将是创建并发的程序，在独立的线程中响应钩子。这样一来，对进一步传入的钩子的响应就不会被阻断，而且可以利用计算能力来提供对事件的快速响应。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_36">9.6.2. 它是如何工作的</h4>
<div class="paragraph">
<p>本质上，我们需要的是一个通过一些 API 请求触发的动作。例如，由于我们有一个从文件中重建网站的脚本，如果它所依赖的任何文件发生变化，我们可以触发重建。我们需要创建一个路由来分析该请求，并对其进行充分的响应。</p>
</div>
<div class="paragraph">
<p>重要的是，这些 web 钩子是异步工作的。这些操作可能需要很长的时间，所以它们不能挂起服务器并阻止它响应任何其他请求，所以我们将创建一个任务，等待信号开始重建网站。</p>
</div>
<div class="paragraph">
<p>并发是一个很好的概念：它允许你用并行的方式工作，但水平很高。包含这些设施的语言并不多。Go 是其中之一，还有 Scala 和 Erlang。Raku 的并发设施与我们在 Go 中看到的设施类似：它是 Hoare 的并发顺序进程的实现，不同的进程通过通道进行状态通信，没有直接通信或（理想情况下）访问共享内存。</p>
</div>
<div class="paragraph">
<p>在上一章，我们使用模板生成了网站。在这一章中，整个站点生成例程已经使用 Raku::Recipes::Texts 类中的一个方法纳入，我们只需从这个程序中调用它。这将通过频道中的消息触发构建。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env perl6

use Raku::Recipes::Texts;

my $builder = Channel.new;

my $p = start {
    react {
        whenever $builder {
            say "Building…";
            my $recipes-text = Raku::Recipes::Texts.new();
            $recipes-text.generate-site()
        }
    }
}

await (^3).map: -&gt; $r {
    start {
        sleep $r;
        $builder.send($r);
    }
}

$builder.close;
await $p;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序在很大程度上受到了文档中例子的启发，试图说明并发操作是如何工作的。</p>
</div>
<div class="paragraph">
<p>首先，我们有通道；我们调用 <code>$builder</code> 的通道将被用来触发构建。实际的消息其实并不重要，我们将利用消息的存在来触发构建。我们启动一个线程来做这件事，这个线程包括一个反应块，每当 <code>$builder</code> 通道收到消息时，这个线程就会 "唤醒"并构建网站。</p>
</div>
<div class="paragraph">
<p>与文件系统的任何交互可能都必须伴随着锁定，以避免竞赛条件。在这种情况下，两个线程可能要同时修改一个文件。我们稍后再来讨论这个问题。目前，我们的重点是基本的并发机制。</p>
</div>
<div class="paragraph">
<p>当然，我们需要生成这些消息。我们创建一个循环，启动三个线程，每一个线程都以越来越多的秒数发出一条消息（感谢睡眠延迟）。由于 <code>await</code> 在循环的前面，所以直到三个承诺都完成，也就是三秒后才会结束。然后，程序流将进入下一条指令，关闭通道，这条指令将传播到看该通道启动的线程，并将其也关闭，实现该承诺。我们再一次等待最后一条指令中的那个承诺，这样程序最终会退出。</p>
</div>
<div class="paragraph">
<p>基本的想法是，对消息的响应不会像在异步系统中那样，占用单个顺序程序，甚至等待事件循环的到来。如果其中一个线程还没有完成，线程会并行唤醒。它们还需要避免同时在同一个文件系统片段上工作。</p>
</div>
<div class="paragraph">
<p>但是一旦我们有了概念上的脚手架，我们就可以在真正的路线中设置这个，比如这个。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::HTTP::Router;
use Raku::Recipes::Texts;

my $lock = Lock::Async.new;
my $builder = Channel.new;
my $p = start {
    react {
            whenever $builder {
                say "Waiting for lock…";
                $lock.protect: {
                    say "Rebuilding";
                    my $recipes-text = Raku::Recipes::Texts.new();
                    $recipes-text.generate-site();
                    say "Rebuilt";
                };

            }
    }
}

unit module My::Rebuild;

sub rebuild-route is export {
    route {
        get -&gt; {
            $builder.send(True);
            content 'application/json', my %result = %( :building("Started") );
        }
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们增加的是一个锁。一个锁可以确保不会有两个线程同时运行那段代码，所以在它的监视下不会发生竞赛条件。我们使用的是异步锁，它会等到被释放后才会工作。所以这个 <code>routingine</code> 将设置锁、通道和响应重建命令的线程。</p>
</div>
<div class="paragraph">
<p>注意，我错过了在这里使用锁、枪托和枪管的机会，好吧，没关系。</p>
</div>
<div class="paragraph">
<p>这些命令将从路由发出，也就是下面的。网络钩子 将会是类似 <a href="http://localhost:31415/rebuild" class="bare">http://localhost:31415/rebuild</a> 的东西，并且会发送一条消息，任何消息，给这个频道&#8212;&#8203;比如说可以是 "Be kind, rebuild"。然后频道会立即返回一条消息，表示它正在重建。重建将发生在幕后，服务器将立即准备好响应其他请求。</p>
</div>
<div class="paragraph">
<p>整个微服务，整合了所有的路由，如图所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env perl6

use Cro::HTTP::Server;
use Cro::HTTP::Router;
use My::Routes;
use My::Rebuild;


my $recipes = route {
    include "content"    =&gt; static-routes,
            "rebuild"    =&gt; rebuild-route,
            "Type"       =&gt; type-routes,
            "Ingredient" =&gt; ingredient-routes;

}

if ( $*PROGRAM eq $?FILE ) {
    my Cro::Service $μservice = Cro::HTTP::Server.new(
            :host('localhost'), :port(31415), application =&gt; $recipes
            );

    say "Starting service";
    $μservice.start;

    react whenever signal(SIGINT) {
        $μservice.stop;
        exit;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这包括了所有的分拆路由，以及这个路由，在一个单一的展示了这个 web 钩子如何与微服务的其他部分无缝集成。我们在运行服务器的控制台中的日志将显示这样的内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Starting service
Waiting for lock...
Rebuilding
Rebuilt
Waiting for lock...
Rebuilding
Rebuilt
Waiting for lock...
Rebuilding
Rebuilt</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过这种方式，我们在微服务架构中集成了一个 web 钩子。这个 web 钩子可以集成到一个工作流中，例如，每次从 Git 服务器接收到推送时都可以调用它。一旦代码被拉取，就可以调用这个钩子来重建服务器。例如，这可能是在这样的情况下，你有这个带有文本的食谱网站，但也有其他前端的服务（甚至是web本身），或者你可能想有一个微服务，为一系列 web 钩子服务。最基本的一点是，web 钩子一般都是执行重任的 <code>fire-and-forget</code> 事件，这也是为什么如果可能的话，它们必须并发完成，并且必须学会通过使用锁来与自己良好的合作。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_创建桌面应用">10. 创建桌面应用</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当你的应用程序是针对非技术性的受众时，你需要设计出让用户可以移动的应用程序，并且只需要一个键盘，也许还有鼠标就可以完成他们的工作。有很多方法可以实现这一点，从使用一个简单的控制台 UI 到一个更复杂的，如果可能的话，基于窗口的应用程序。这些功能在 Raku 中默认是不可用的，所以在大多数情况下，你需要使用生态系统中的发行版，这些发行版可能会使用本地库，所以本章也会重点介绍它们。</p>
</div>
<div class="sect2">
<h3 id="_食谱_13_1_使用全控制台_ui">10.1. 食谱 13-1. 使用全控制台 UI</h3>
<div class="sect3">
<h4 id="_问题_34">10.1.1. 问题</h4>
<div class="paragraph">
<p>创建一个能够自适应控制台的前端，这样它就可以在任何地方运行，而不必担心本地窗口系统的复杂性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_23">10.1.2. 解决办法</h4>
<div class="paragraph">
<p>我们可以使用 Terminal::Choose，它更简单，但我们在第6章中已经这样做了。或者我们可以使用 Terminal::Print，这是一个 CUI（控制台用户界面）的模块，有一个直接的 API。然而，Termbox 是最近发布的，它有一个简单的 API，我们将用它来创建一个 CUI（控制台用户界面）模块。我们将使用它来创建一个完整的控制台应用程序。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_37">10.1.3. 它是如何工作的</h4>
<div class="paragraph">
<p>一般来说，用户界面比命令行界面更适合终端用户。对于面向用户的应用，甚至对于那些不需要大量复制的应用，比如游戏或小程序，控制台的优势在于它们始终存在，非常轻巧，而且相对简单。控制台由一系列可以被单个字符占据的单元格组成，这些单元格有一个背景和前景色（以及一个位置）。</p>
</div>
<div class="paragraph">
<p>这些用户界面会产生事件；一般是按键点击事件。我们已经知道如何在 Raku 中处理事件流，所以一个 UI 应用程序将包括绘制初始屏幕和处理事件，对它们作出反应，并可能移动东西。</p>
</div>
<div class="paragraph">
<p>例如，让我们创建一个选择一系列食材的应用程序。然后，我们可以尝试确定使用它们的菜肴中的卡路里（就像我们在第11章中做的那样），或者通过 Wikidata 查找使用它们的食谱（按照第12章中的食谱）。这将只是一个选择这些成分的屏幕。这可以通过以下程序来完成。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env perl6

use Termbox :ALL;
use Raku::Recipes::SQLator;

my %data = Raku::Recipes::SQLator.new.get-ingredients;
my Set $selected;

if tb-init() -&gt; $ret {
    note "tb-init() failed with error code $ret";
    exit 1;
}

END tb-shutdown;

my $row = 0;
my $ingredient-index = 0;
my @ingredients = %data.keys.sort;
my $max-len = @ingredients.map: { .codes };
my $split = @ingredients.elems / 2;
print-string("Select with ENTER, move with space or cursors",1,1,
        TB_WHITE, TB_BLACK);
for @ingredients -&gt; $k {
    my ($this-column,$this-row )  = ingredient-to-coords( $row );
    uncheck-mark( $row );
    print-string( $k , $this-column + 5, $this-row, TB_BLACK, TB_WHITE );
    $row++;
}
draw-cursor($ingredient-index);
tb-present;

my $events = Supplier.new;
start {
    while tb-poll-event( my $ev = Termbox::Event.new ) { $events.emit: $ev }
}

react whenever $events.Supply -&gt; $ev {
    given $ev.type {
        when TB_EVENT_KEY {
            given $ev.key {
                when TB_KEY_SPACE | TB_KEY_ARROW_DOWN {
                    undraw-cursor($ingredient-index);
                    $ingredient-index =
                            ($ingredient-index+1) % @ingredients.elems;
                    my ( $this_column, $this_row ) = ingredient-to-coords
                            ($ingredient-index);
                    draw-cursor( $ingredient-index );
                    tb-present;
                }
                when TB_KEY_ARROW_UP {
                    undraw-cursor($ingredient-index);
                    if $ingredient-index {
                        $ingredient-index--
                    } else {
                        $ingredient-index = @ingredients.elems - 1;
                    }
                    my ( $this_column, $this_row ) = ingredient-to-coords
                            ($ingredient-index);
                    draw-cursor( $ingredient-index );
                    tb-present;
                }
                when TB_KEY_ENTER {
                    if @ingredients[$ingredient-index] ∈ $selected {
                        uncheck-mark($ingredient-index);
                        $selected ⊖= @ingredients[$ingredient-index];
                    } else {
                        check-mark($ingredient-index);
                        $selected ∪= @ingredients[$ingredient-index];
                    }
                    tb-present;
                }
                when TB_KEY_ESC {
                    print-string("Selected " ~
                            $selected.map( *.key ).join("-" ),
                            1,2,
                            TB_BLUE, TB_YELLOW);
                    tb-present;
                    sleep(5);
                    done
                }

            }
        }
    }
}

subset RowOrColumn of Int where * &gt;= 1;

sub uncheck-mark( $ingredient-index ) {
    my ($this-column,$this-row )  = ingredient-to-coords( $ingredient-index );
    print-string( "[ ]", $this-column + 1 , $this-row, TB_BLACK, TB_BLUE );
}

sub check-mark( $ingredient-index ) {
    my ($this-column,$this-row )  = ingredient-to-coords( $ingredient-index );
    print-string( "[X]", $this-column + 1 , $this-row, TB_BLACK, TB_BLUE );
}

sub draw-cursor( $ingredient-index ) {
    my ($cursor_c, $cursor_r) = ingredient-to-coords( $ingredient-index);
    tb-change-cell( $cursor_c, $cursor_r, "&gt;".ord, TB_YELLOW, TB_RED );

}

sub undraw-cursor( $ingredient-index ) {
    my ($cursor_c, $cursor_r) = ingredient-to-coords( $ingredient-index);
    tb-change-cell( $cursor_c, $cursor_r, " ".ord, 0, 0 );

}

sub print-string( Str $str, RowOrColumn $column,
                  RowOrColumn $row,
                  $fgcolor,
                  $bgcolor  ) {
    for $str.encode.list -&gt; $c  {
        state $x;
        tb-change-cell( $column + $x++,
                $row,
                $c,
                $bgcolor, $fgcolor );
    }
}

sub ingredient-to-coords( UInt $ingredient-index) {
    return 1 + ($ingredient-index / $split).Int * ($max-len + 5),
            (3 + $ingredient-index % $split).Int;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序使用了 Termbox，正如已经指出的那样。Termbox 发行版是围绕着一个同名的库的 NativeCall 包装器（查看下一章如何创建这些包装器）。这个库可以从 <a href="https://github.com/nsf/termbox" class="bare">https://github.com/nsf/termbox</a> 下载，它有一个免费的许可证。它有许多流行语言的绑定，当然包括这个。当你用 zef 安装 Termbox 时，你不需要安装任何额外的包。它将在飞行中为你构建它所需要的东西。</p>
</div>
<div class="paragraph">
<p>这个程序相当长，因为每一件小事都需要写代码。但它有几个块。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>初始化不同的数据结构和控制台 UI。<code>tb-init</code> 命令将初始化它，并创建一个我们可以在上面画画的空白画布。</p>
</li>
<li>
<p>绘制初始画面。</p>
</li>
<li>
<p>设置一个事件流。termbox 事件流会被轮询，每轮询一次，就会向流中发出另一个事件。当用户需要时，这个事件流将被关闭。</p>
</li>
<li>
<p>一个区块设置了不同的关键事件发生时的处理方式，每一个事件都必须单独处理。</p>
</li>
<li>
<p>一个 END 相位器，在程序退出时（比如说因为程序用完了指令）会发射，它负责在程序结束时关闭画布。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在低层次上，这个 CUI/TUI（控制台或终端用户界面）的主力是 <code>tb-change-cell</code>。它需要五个参数：列和行，按这个顺序，一个字符代码，然后是前景和背景颜色。这些参数也被 Termbox 预定义为 Raku 常量。</p>
</div>
<div class="paragraph">
<p>由于打印字符串这个简单的行为涉及到一些代码，我们将我们自己的 <code>print-string</code> 子程序包裹在其中。它所需要的参数基本相同，但行和列将是初始参数，而且它需要一个完整的字符串。在其中，我们通过 <code>encode.list</code> 来提取字符代码。第一条命令将一个字符串转换为一个 blob，第二条命令将 blob 转换为一个字符列表。每个字符我们都会递增列号。我们使用了一个状态变量 <code>$x</code>，这样它的值在迭代块的一次调用到下一次调用时都会被保存。</p>
</div>
<div class="paragraph">
<p>另一个重要的变量是 <code>ingredient-index</code>。光标将被放置在 <code>ingredient-index</code> 所指示的值中，它只是 <code>ingredients</code> 数组中的一个位置，是一个使用 SQLator 提取的按字母顺序排列的成分列表。其他所有的位置都围绕着它。从成分-索引中，我们计算出游标、复选框和成分的行和列。<code>ingredient-index</code> 将是一个全局变量，尽管为了照顾到何时何地改变它，大多数例程不会改变它。如果我们需要勾选或取消勾选一个复选框，或者绘制或取消绘制光标，这是我们需要知道的唯一值。图 13-1显示了 UI 在屏幕上的样子。</p>
</div>
<div class="paragraph">
<p>图13-1. 选择原料的 CUI。奶酪已经被标记，光标在 Chorizo 的前面。</p>
</div>
<div class="paragraph">
<p>构件到坐标的例程可以将构件索引（或初始绘图中的行）转换为坐标，将构件整齐地放置在两行中。它考虑到了原料名称的最大长度，这个长度存储在全局变量 <code>$max-len</code> 中。</p>
</div>
<div class="paragraph">
<p>包装还包括类型检查。我们定义了一个 <code>RowOrColumn</code> 子集，以注意数值必须超过1。Termbox 是一个非常实用的库，但它的操作很脆，任何错误都会简单地使程序退出，因为它是在 C 代码中发生的，并没有传播到 Raku 中产生一个适当的异常。我们需要在代码中捕捉这些错误，以避免用户的挫败感。</p>
</div>
<div class="paragraph">
<p>反应块会对按键事件做出响应。我们首先过滤按键事件，然后区分不同的按键。空格键和向下键将以同样的方式表现。我们使用一个 junction(<code>|</code>)。所以 <code>TB_KEY_SPACE | TB_KEY_ARROW_DOWN</code> 将在其中任何一个键被按下时触发。这样就会通过取消绘制然后再绘制的方式一步步移动光标。在每次改变之后，我们需要调用 <code>TB-Present</code> 来更新 UI。这个和箭头向上会绕过食材指数，如果超过食材数量，则回到0，如果低于0，则上升到食材数量的最终指数，回车键会切换勾选，最后，Escape 会打印所选食材，然后，等待5秒后，退出。此界面如图13-2所示。</p>
</div>
<div class="paragraph">
<p>图13-2. 打印所选原料</p>
</div>
<div class="paragraph">
<p><code>sleep</code> 后的命令，<code>done</code>，会关闭 supply，然后将程序结束，触发 END 相位器，关闭画布。</p>
</div>
<div class="paragraph">
<p>这个程序做到了该做的事情，没有太多花哨的东西。当你必须连接到云系统，或者通过有限的带宽连接到系统时（这种情况还是有的），它相当方便。对于系统管理任务来说，控制台用户界面仍然比基于窗口的用户界面更受欢迎。事实上，这种界面也可以在浏览器内部的控制台中运行。然而，在某些情况下，你会希望创建一个成熟的基于窗口的应用程序。接下来我们将看到如何做到这一点。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_13_2_创建一个使用系统_windows_的应用程序">10.2. 食谱 13-2 创建一个使用系统 Windows 的应用程序</h3>
<div class="sect3">
<h4 id="_问题_35">10.2.1. 问题</h4>
<div class="paragraph">
<p>你需要创建一个使用鼠标和窗口的桌面应用程序，并且可以移植到不同的操作系统。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_24">10.2.2. 解决办法</h4>
<div class="paragraph">
<p>GTK3 是一个可移植的库，在整个开源世界中，它被用来创建桌面界面；GTK::Simple 是该库的 Raku 绑定，你可以用它来构建界面。它的社区维护和更新频率很高，就像它的底层库一样，所以它可以为你的桌面应用程序提供一个稳定的基础。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_38">10.2.3. 它是如何工作的</h4>
<div class="paragraph">
<p>设计图形用户界面不仅仅是把按钮和其他小部件放在一个矩形表面上，然后在事情发生时做出反应。GUI 需要关注用户（也就是"用户界面"中的"用户"），让他们尽可能容易地知道什么是可用的，什么可以做，什么不能做。</p>
</div>
<div class="paragraph">
<p>我甚至不会假装我对这个主题有所了解，但 GUI 的艺术是一个非常有趣的话题，你应该了解情况（或者在你的团队中有一些专家）。我将尽量尊重简单的原则(比如告知用户可以做什么)，并通过 Raku 展示如何在 GTK3 中实现。</p>
</div>
<div class="paragraph">
<p>GTK3 是一个很流行的 GUI 库，已经是 3.xx 后期的版本，它最初是作为 GIMP 图像处理程序的基础而开发的（事实上，GTK 的意思是 Gimp ToolKit）。最近，它已经蔓延到了各种多平台桌面应用中，包括 Gnome。很多应用程序，包括我正在使用的 LibreOffice 都使用它。它的原始语言是 C 语言，所以它需要一些脚手架才能在 Raku 等语言中使用。在安装我们将要使用的发行版 Gtk::Simple 之前，我们必须使用 https:// github.com/raku-community-modules/gtk-simple (在 Ubuntu 或 Debian 的情况下，sudo apt install libgtk-3-dev)中的说明安装该库的开发版。在 Windows 的情况下，共享库是随着 Raku 模块的安装而下载和安装的。</p>
</div>
<div class="paragraph">
<p>GTK3 的基本概念是盒子。你把 widget 水平堆放在 Hboxes 中，垂直堆放在 Vboxes 中，而这些 widget 又相互嵌入，直到最终的窗口矩形被创建。例如，如果你想在另一个 widget 上创建两个 widget，你需要将这两个 widget 嵌入一个水平框中，然后这个水平框和新的 widget 一起插入一个垂直框中。</p>
</div>
<div class="paragraph">
<p>和前面的食谱一样，一个 UI 应用将基本上由两部分组成：设计 UI 的布局和对其中的事件创建反应。我们将创建一个应用程序，列出三种类型的食材&#8212;&#8203;主食、副食或甜点&#8212;&#8203;以及素食和乳制品按钮，让我们可以切换该类型的食材。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env perl6

use GTK::Simple;
use GTK::Simple::App;
use GTK::Simple::RadioButton;
use Raku::Recipes::SQLator;

my $app = GTK::Simple::App.new( title =&gt; "Select ingredients" );

my $dator = Raku::Recipes::SQLator.new();
my @all-radio;

my @panels = do for &lt;Main Side Dessert&gt; {
    create-type-panel( $dator, $_)
};

for @all-radio -&gt; $b {
    $b.toggled.tap: &amp;grayout-same-name;
}

$app.set-content(
            GTK::Simple::VBox.new(
                create-type-buttons( @panels ),
                GTK::Simple::HBox.new( |@panels )
            )
        );

$app.border-width = 15;
$app.run;

END {
    say "Selected ingredients →";
    say @all-radio.grep(  *.status ).map( *.label ).join(" | ");
}

sub create-type-buttons( @panels ) {
    my $button-set = GTK::Simple::HBox.new(
            my $vegan = GTK::Simple::Button.new(label =&gt; "Vegan"),
            my $dairy = GTK::Simple::Button.new(label =&gt; "Non-Dairy"),
            my $exit = GTK::Simple::Button.new(label =&gt; "Exit"),
            );
    $vegan.clicked.tap: { toggle-buttons( $_, "Vegan" )};
    $dairy.clicked.tap: { toggle-buttons( $_, "Dairy" )};
    $exit.clicked.tap({ $app.exit; });
    return $button-set;
}

sub create-radio-buttons ( $dator, @labels is copy ) {
    my $label = shift @labels;
    my $first-radio-button =
            GTK::Simple::RadioButton.new(:$label )
            but $dator.get-ingredient($label);
    my @radio-buttons = ( $first-radio-button ) ;
    while @labels {
        $label = shift @labels;
        my $this-radio-button =
                GTK::Simple::RadioButton.new(:$label)
                but $dator.get-ingredient($label);
        @radio-buttons.append: $this-radio-button;
        $this-radio-button.add( $first-radio-button );
    }
    @all-radio.append: |@radio-buttons;
    @radio-buttons;
}

sub create-button-set( $dator, $title, @labels ) {
    my $label = GTK::Simple::TextView.new;
    $label.text = "→ $title";
    my @radio-buttons = create-radio-buttons( $dator, @labels );
    GTK::Simple::VBox.new( $label, |@radio-buttons);
}

sub create-type-panel( Raku::Recipes::Dator $dator,
                       $type where $type ∈ &lt;Main Side Dessert&gt; ) {
    my @ingredients = $dator.search-ingredients( { $type =&gt; "Yes" });
    create-button-set( $dator, $type, @ingredients );
}

sub toggle-buttons( $button, $type ) {
    state $clicked = False;
    if $clicked {
        $button.label = "Non-$type";
        for @all-radio -&gt; $b {
            if $b.Hash{$type} eq "Yes" {
                $b.sensitive = False;
            } else {
                $b.sensitive = True;
            }
        }
        $clicked = False;
    } else {
        $button.label = $type;
        for @all-radio -&gt; $b {
            $b.sensitive = $b.Hash{$type} eq "No";
        }
        $clicked = True;
    }

}

sub grayout-same-name( $b ) {
    state $toggled = False;
    if $toggled {
        for @all-radio -&gt; $other {
            if $b !=== $other and $b.label eq $other.label {
                $other.sensitive = False;
            }
        }
        $toggled = False;
    } else {
        for @all-radio -&gt; $other {
            if $b.WHICH ne $other.WHICH and $b.label eq $other.label {
                $other.sensitive = True;
            }
        }
        $toggled = True;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们看看这个程序的不同部分是如何工作的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_创建布局">10.2.4. 创建布局</h4>
<div class="paragraph">
<p>窗口有如下内容。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>最上面一排有三个按钮： 素食和乳制品按钮，以及&#8230;&#8203;
作为退出按钮。我们把这些类型的按钮叫做"类型按钮"。</p>
</li>
<li>
<p>一个有三列的面板，每一列都有一个标签表示它们的类型。它们包含一个成分列表，这些成分的工作方式就像单选按钮一样，你只能选择其中的一个。这些就是类型面板。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>布局是用这个命令来构架的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$app.set-content(
            GTK::Simple::VBox.new(
                create-type-buttons( @panels ),
                GTK::Simple::HBox.new( |@panels )
            )
        );
$app.border-width = 15;</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以它是一个垂直的盒子，上面是类型按钮，下面是水平的盒子，下面是类型面板。图13-3显示了这个样子。</p>
</div>
<div class="paragraph">
<p>图13-3. 初始应用程序窗口</p>
</div>
<div class="paragraph">
<p>每一个组件的长度都是自动设置的，尽管我们给整个窗口周围15个像素。</p>
</div>
<div class="paragraph">
<p>我们还需要为每个单选按钮提供一些信息。一个按钮小组件只需要包含显示它所需的信息。但是我们需要检查一个按钮是否包含素食或乳制品成分的信息，我们需要给按钮添加一个有效载荷。我们使用 mixins 来完成这个工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $first-radio-button =
        GTK::Simple::RadioButton.new(:$label )
        but $dator.get-ingredient($label);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$first-radio-button</code> (和其他按钮)变量包含了一个 GTK RadioButton，但也包含了我们对成分的数据。<code>$first-radio-button</code> 是一个混合体。当我们在 "first" 对象上调用方法时，它将表现为这样。然而，如果我们把这个对象（只是在其他对象更有意义的上下文中使用它）转换为混合类的类型，在本例中是Hash，我们将能够访问混合类的那部分。<code>$first-radio-button</code> 将表现为一个 RadioButton，但 <code>$first-radio-button.Hash</code> 将包含该部分的信息。这是一种非常聪明的方式，可以将有效载荷添加到变量中，而不需要用另一个哈希值或数组或其他什么东西来交叉引用它们。而且我们可以在创建时或之后混合有效载荷。你以后会发现这个相当有用。</p>
</div>
<div class="paragraph">
<p>所有的窗口都包含在一个 App 变量中。我们通过 set-content 设置这个变量的内容，然后使用 <code>$app.run</code> 启动事件循环。<code>$app.exit</code> 将退出应用程序，我们将其绑定到 Exit 按钮上。</p>
</div>
<div class="paragraph">
<p>我们会更详细地看到动作是如何工作的。每一个 widget 都会创建一个点击流，用 Raku 的术语来说就是一个你可以点击的供应。点击是对该点击流的订阅；每次收到事件时，点击块都会被执行。我们在第二章中广泛使用了它们。我们需要显式地设置这些轻敲，以便每次点击按钮时都能做一些事情。默认情况下，小组件的状态会发生变化，但我们可能需要对它做一些其他的事情。例如，如果我们点击素食者，我们需要取消选择所有非素食者的成分，但我们也需要切换它的状态来显示它们的位置。在 GUI 中，显示状态总是很重要的，而且应该清楚地说明。如果我们点击素食，图13-4说明了窗口中会显示什么。</p>
</div>
<div class="paragraph">
<p>图13-4. 选择素食选项</p>
</div>
<div class="paragraph">
<p>通过将那些不符合所选标准的选项灰化，我们展示了哪些可以做，哪些不可以做。<code>toggle-buttons</code> 例程就可以解决这个问题。但是为了切换这些按钮，我们需要知道它们是什么样的类型。这就是上面提到的 <code>mixin</code> 的用武之地。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @all-radio -&gt; $b {
    $b.sensitive = $b.Hash{$type} eq "No";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们把所有的按钮都存储在一个全局变量中，<code>@all-radio</code>，以便能够做这种事情。<code>$b.Hash&lt;Vegan&gt;</code> 会告诉我们这个按钮是否指的是素食成分，同理，乳制品也是如此。</p>
</div>
<div class="paragraph">
<p>这些单选按钮也有自己的 <code>tap</code>，但这些按钮只会将其他同名按钮灰化。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @all-radio -&gt; $other {
    if $b.WHICH ne $other.WHICH and $b.label eq $other.label {
        $other.sensitive = False;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每当我们切换一个单选按钮时，我们就会检查是否有其他的单选按钮与之同名。首先我们检查它们是否不同：. <code>WHICH</code> 是每个对象的唯一 ID，如果是同一个按钮，它将是相同的。然后，我们需要检查标签是否完全相同；在这种情况下，我们通过将敏感属性切换为 False（如果相反，则为 True）将其灰色化。这样一来，如果我们在任何一列中选择了大米，其他两列就会被灰化，如图13-5所示。</p>
</div>
<div class="paragraph">
<p>图13-5. 在另一列中选择大米后，大米被灰化了</p>
</div>
<div class="paragraph">
<p>实际上，你如何处理所选的成分已经超出了这个配方的范围，但无论如何，我们使用 END 块打印它们。再一次，将所有按钮放在一个变量中是很方便的：我们简单地过滤那些状态为 True 的按钮，意思是点击，然后使用 <code>.map( *.label)</code> 提取标签。当我们退出时，类似这样的内容将被打印出来（到控制台）。</p>
</div>
<div class="paragraph">
<p>Selected ingredients →
Lentils | Rice | Apple</p>
</div>
<div class="paragraph">
<p>我们可以用它做一些不同的事情，交互式地显示信息。文本是在 TextView 小组件中显示的，我们这里用它来显示列标题。然而，这将遵循同样的原则：设置小组件，将其存储在某个地方，以便你可以使用它，当你需要时，在点击中改变小组件的状态。</p>
</div>
<div class="paragraph">
<p>在此基础上还可以创建更复杂的应用程序：最近更新的生态系统中有一系列 <code>Gnome::*</code> 发行版，你可以用它们创建带有绘图面板的应用程序，甚至是小型编辑器。Gnome::Gtk3 是一个 fork，经常更新，并且有一个非常自由的 Apache 许可证。</p>
</div>
<div class="paragraph">
<p>一般来说，如果你需要创建一个成熟的、窗口化的、多平台的应用程序，在 Raku 中有很多不同的方法。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_13_3_创建一个小游戏">10.3. 食谱 13-3. 创建一个小游戏</h3>
<div class="sect3">
<h4 id="_问题_36">10.3.1. 问题</h4>
<div class="paragraph">
<p>你需要制作一个动画或桌面小游戏。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方案_8">10.3.2. 解决方案</h4>
<div class="paragraph">
<p>使用 SDL2::Raw 和 SDL2，SDL2 是围绕 SDL2 库的低级面向对象的封装器，SDL2 库是一个用于创建视频游戏的多平台、优化框架。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_39">10.3.3. 它是如何工作的</h4>
<div class="paragraph">
<p>游戏可能看起来很复杂，留给电子游戏开发者去创造。</p>
</div>
<div class="paragraph">
<p>但归根结底，游戏是一种叙事性的媒体，可以用来传递信息，鼓励行为，或者仅仅是用动画的方式，当然也是娱乐的方式来展示一些东西。</p>
</div>
<div class="paragraph">
<p>在一个游戏中，你必须考虑到很多东西，但作为一个从 Pong 上切入游戏的人，基本上是两行和拇指指甲厚的像素，我可以告诉你，最重要的是叙事和机制，而不是图形方面。</p>
</div>
<div class="paragraph">
<p>SDL，即 Simple DirectMedia Layer，是一个多平台的库，可以帮助你完成这些事情。它包含多个基元，用于绘制形状、点、从窗口获取点击流，以及创建游戏时需要的任何东西。事实上，许多专业游戏都是使用 SDL 创建的。它有助于与许多语言的绑定，包括 Raku。无论如何，请按照 <a href="http://www.libsdl.org/download-2.0.php" class="bare">http://www.libsdl.org/download-2.0.php</a> 的说明下载该库的开发版本，如果您使用的是 Ubuntu，则只需从命令行发出这个命令即可。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sudo apt install libsdl2-dev</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以让我们用它来做我们的程序。我们的游戏将被称为 DIVCO，它的目的是展示感染如何在平地传播。如果这些方块是连续的（甚至是一个角一个角的），那么它们有 0.5 的可能性会互相传染。如果一个健康的方块旁边有两个生病的方块，感染就会一直发生。我们可以在任何时候感染任何一个方块，每一秒钟我们都会检查是否有新的感染发生。用户可以感染任意数量的初始方块，只需点击一个方块即可。</p>
</div>
<div class="paragraph">
<p>我们需要定义方块，我们将使用一个独立的类来完成。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use SDL2::Raw;

enum unit-state &lt;HEALTHY INFECTED&gt;;
constant OPAQUE = 255;

constant @infected = (255,0,0,OPAQUE);
constant @healthy = (0,255,0,OPAQUE);
constant GRID_X = 25;
constant GRID_Y = 25;

unit class My::Unit;

has $!renderer;
has $!x;
has $!y;
has unit-state $.state = HEALTHY;
has $!rect;

submethod BUILD( :$!renderer, :$!x, :$!y ) {}

submethod TWEAK {
    $!rect = SDL_Rect.new:
        x =&gt; $!x*GRID_X,
        y =&gt; $!y*GRID_Y,
        w =&gt; GRID_X,
        h =&gt; GRID_Y;
}

submethod flip() {
    $!state = $!state == HEALTHY ?? INFECTED !! HEALTHY;
    self.render;
}

method render {
    if $!state == HEALTHY {
        $!renderer.draw-color(|@healthy);
    } else {
        $!renderer.draw-color(|@infected);
    }
    $!renderer.fill-rect($!rect);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每一个方块都有网格中的坐标，它出生时传递的渲染器对象，状态，以及一个定义为 SDL_Rect 的矩形。既然它的位置不会改变，我们也可以在这里生成基元，当我们需要时再使用它。唯一的公共属性是状态，这将防止任何客户端在对象的初始化后改变其余的属性。</p>
</div>
<div class="paragraph">
<p>Unit 可以从感染到健康再到健康，它使用 SDL2::Raw 基元把自己画到网格上。我们使用 <code>draw-color</code> 将它们绘制成不同的颜色&#8212;&#8203;绿色代表健康，红色代表感染。我们使用 <code>fill-rect</code> 基元来绘制精确的形状。正如你所看到的，它是通过三个步骤完成的：我们设置颜色，我们创建形状，我们填充形状。这具有很大的灵活性（例如，我们可以使用纹理），但当你需要绘制一个简单的矩形时，它肯定很啰嗦。它并不是真正的渲染，而是在一个"阴影画布"中，只有当我们需要它时才会呈现。</p>
</div>
<div class="paragraph">
<p>好了，这将是我们的基本单元，但我们需要在主程序中定义游戏的其他部分。在这里，它是。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env perl6

use SDL2::Raw;
use lib &lt;lib Chapter-13/lib&gt;;
use SDL2;
use My::Unit;


LEAVE SDL_Quit;

my $occupied =  @*ARGS[0] // 0.5;

my int ($w, $h) = 800, 600;
my $window = init-window( $w, $h );
LEAVE $window.destroy;

my $renderer = SDL2::Renderer.new( $window, :flags(ACCELERATED) );
SDL_ClearError;

my @grid[$w/GRID_X;$h/GRID_Y];
say "Generating grid...";
for ^@grid.shape[0] -&gt; $x {
    for ^@grid.shape[1] -&gt; $y {
        if ( 1.rand &lt; $occupied ) {
            @grid[$x;$y] = My::Unit.new( :$renderer, :$x, :$y );
            @grid[$x;$y].render;
        }
    }
}
sdl-loop($renderer);

#-------------------- routines -----------------------------------------

#| Init window
sub init-window( int $w, int $h ) {
    die "couldn't initialize SDL2: { SDL_GetError }" if SDL_Init(VIDEO) != 0;
    SDL2::Window.new(
            :title("DIVCO"),
            :width($w),
            :height($h),
            :flags(SHOWN)
            );
}

#| Rendering loop
sub sdl-loop ( $renderer ) {
    my SDL_Event $event .= new;
    loop {
        state $last-update = now;
        while SDL_PollEvent($event) {
            handle-event( $renderer, SDL_CastEvent($event) );
        }
        if now - $last-update  &gt; 1 {
            infection-loop($renderer);
            $last-update = now;
        }
    }
}

#| Handle events
proto sub handle-event( | ) {*}

multi sub handle-event( $, SDL2::Raw::SDL_MouseButtonEvent $mouse ) {
    my ( $grid-x, $grid-y ) = gridify( $mouse.x, $mouse.y );
    given $mouse {
        when (*.type == MOUSEBUTTONUP ) {
            with @grid[$grid-x; $grid-y] {
                .flip;
            }
        }
    }
}

sub gridify ( $x, $y) {
    return ($x / GRID_X).Int, ($y/GRID_Y).Int;
}

multi sub handle-event( $, SDL2::Raw::SDL_KeyboardEvent $key ) {
    given $key {
        when (*.type == KEYDOWN )
        {
            if $key.sym == 27 {
                exit;
            }
        }
    }
}

multi sub handle-event( $, $event ) {
    given $event {
        when ( *.type == QUIT )
        {
            exit;
        }
    }
}

sub infection-loop( $renderer ) {
    say "Infection loop…";
    for ^@grid.shape[0] -&gt; $x {
        for ^@grid.shape[1] -&gt; $y {
            with @grid[$x; $y] {
                if .state == HEALTHY {
                    my $prob=0;
                    for max($x - 1, 0) .. min($x + 1, @grid.shape[0] - 1) -&gt;
                    $xx {
                        for max($y - 1, 0) .. min($y + 1,
                                @grid.shape[1] - 1) -&gt;
                        $yy {
                            if @grid[$xx;$yy] &amp;&amp; @grid[$xx;$yy].state ==
                            INFECTED {
                                $prob += 0.5
                            }
                        }
                    }
                    if 1.rand &lt; $prob {
                        @grid[$x;$y].flip;
                    }
                }
            }
        }
    }
    $renderer.present;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，有点啰嗦，这也是GUI应用程序的惯例。它是这样继续构建应用程序的。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>它创建了游戏所需的低级基元&#8212;&#8203;窗口(800 x 600)和渲染器，渲染器是处理阴影画布并将其绘制在屏幕上的对象。事实上，这些都使用了两个 SDL2 高级类。其中一个是用来创建渲染器对象的，因为它是用来在屏幕上绘画的，所以会传递给很多其他方法。SDL2 并不太完整，在其他大多数情况下，我们将使用 SDL2::Raw 程序等价物。</p>
</li>
<li>
<p>然后它创建平地网格。概率默认为0.5（50%的方格将被占用），但可以通过命令行更改，使用0到1之间的数字，密度越高，感染的概率越高。每个单位或方块，都会得到一个渲染器的副本，它需要定义矩形并绘制到阴影画布上。单元被存储在一个形状数组中。异形数组是n维数组，可以记住每个维度的大小。它们足以代表一个网格。作为一个额外的优势，在它们上面运行循环是相当容易的，这要归功于 <code>.shape</code> 方法，它返回一个包含每个维度中元素数量的数组。</p>
</li>
<li>
<p>然后进入主循环。这个循环永远运行，或者直到按下正确的键，它做两件事&#8212;&#8203;它检查点击流中的任何东西并进行处理，它每隔一秒就运行一次感染循环。这个感染循环会移动，一个方块一个方块地检查它的邻居，并根据规定的概率将它们从健康状态翻转到感染状态。这个概率在这行中是硬编码的，如果 <code>@grid[$xx;$yy] &amp;&amp; @grid[$xx;$yy].state == INFECTED { $prob += 0.5 }</code>，但要你使用不同的概率，看看它们如何影响感染概率。</p>
</li>
<li>
<p>LEAVE 块将以一种有序的方式从 SDL 引擎中退出。这将在程序关闭前被调用。它如何工作的一个例子显示在 <a href="https://youtu.be/zzw9XSOX5-Q" class="bare">https://youtu.be/zzw9XSOX5-Q</a>, 以及图13-6中。屏幕上没有显示任何说明，但点击某个地方感觉很自然，并鼓励用户探索游戏。也没有显示分数：它想传递的是如何让亲近感更快地传播。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>图13-6. 初始屏幕，感染前</p>
</div>
<div class="paragraph">
<p>主循环是排他性的，也就是说，它阻止了其他事件循环的发生，包括异步循环。这在 Raku 中并不是最好的工作方式，但我们仍然可以通过其他方式来模拟异步事件。有些语言使用事件循环集成器，但在我们的情况下，我们必须使用现有的手段。循环订阅点击流，在 <code>$event</code> 变量中捕获点击。我们创建一个 <code>multi</code> 来处理这个事件，这样我们就可以解除程序的混乱，以不同的方式处理不同类型的点击。通用的 <code>multi</code> 将处理 <code>quit</code> 事件，基本上是当我们关闭窗口的时候。例如，我们可以在这种情况发生时打印一条关闭消息。下一个是处理键盘事件，但它只是监听值为27的键，也就是 Escape 键，而且它也会在该键被按下时做出反应，而不是在我们停止按该键时。SDL 中的点击流可以捕获各种事件，这样我们就可以对使用按键、鼠标、甚至操纵杆等输入设备的不同手势做出反应。</p>
</div>
<div class="paragraph">
<p>最后，接下来的多起来处理鼠标事件，但我们只对鼠标被点击时感兴趣。事实上，只有当我们停止点击它的时候，我们才会感兴趣。MOUSEBUTTONUP. 每当我们点击一次，就会捕捉到两个事件，DOWN 和 UP。我们可以选择其中一个来应对。当发生这种情况时，我们要做的是将光标的x和y位置转换为网格（使用 <code>gridify</code> 子例程），这样我们就可以直接使用它们作为数组索引。有了这些计算结果，我们将感染相应的方块，这将是简单的占据 <code>@grid</code> 数组中相应位置的方块。感染会自动扩散，直到出现类似图13-7的情况，感染无法再扩散。</p>
</div>
<div class="paragraph">
<p>图13-7. 感染的最后阶段，初始密度为0.4，有两个种子方块。</p>
</div>
<div class="paragraph">
<p>我们可以试验不同的密度，看看感染会如何进行。在密度等于0.5（这是默认值）的情况下，很有可能从一次传染开始，除了可能是几个孤立的方块外，其他的方块都会传播。只要将密度降低到0.4，就已经有了不相干的岛屿，单个传染就不会扩散到其他区块，这说明社会疏远是阻止传播的一种方法。</p>
</div>
<div class="paragraph">
<p>归根结底，编程游戏机制涉及到两种类型的动作：一种是周期性的动作（移动、新对象的出现什么的），另一种是反应性的动作（对按键做出反应，让敌方对象对你的动作做出反应）。在 Raku 和使用 SDL 中，这就是一个结合基本事件循环的问题，并对点击流中的事件做出不同的反应。这些可以创造性地与评分方法、不同的游戏玩法相结合，甚至可以创建客户端-服务器组合，让人们一起工作。</p>
</div>
<div class="paragraph">
<p>不过在目前的状态下，它的可玩性和已经传达的信息，只用了几十行 Raku。要有创意，创造自己的游戏，哪怕是只给你的朋友和家人。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_加快处理速度">11. 加快处理速度</h2>
<div class="sectionbody">
<div class="paragraph">
<p>现代计算机已经远远不止一个处理器，在那里指令一条一条的运行，多核多线程可以帮助你把东西做得更快，通过简单的程序同时做几件事情。但是你需要一种语言，给你提供一个很好的抽象层，才能真正加快编程速度。Raku 是在21世纪设计的，它包含了一系列的功能，以利用硬件的并行处理能力。我们将在本章中研究几种方法。</p>
</div>
<div class="sect2">
<h3 id="_配方_15_1_使用带_hyperrace_的数据并行">11.1. 配方 15-1. 使用带 Hyper/Race 的数据并行</h3>
<div class="sect3">
<h4 id="_问题_37">11.1.1. 问题</h4>
<div class="paragraph">
<p>您需要以最快的速度处理海量数据。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_25">11.1.2. 解决办法</h4>
<div class="paragraph">
<p>数据并行是一种技术，通过这种技术，可以同时处理串行数据结构的各个部分。Raku 通过 <code>hyper</code> 和 <code>race</code> 方法使用显式线程，或者使用 junction 使用隐式自动线程。<code>hyper</code> 和 <code>race</code> 命令可以让你更精细地控制数据结构的划分和处理方式。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_40">11.1.3. 它是如何工作的</h4>
<div class="paragraph">
<p>现代台式电脑拥有很大的功率，多核架构是常态，即使是低端的笔记本电脑也是如此。使用显式并发，我们可以在没有大量开销的情况下使用这些能力，但如果你想做的是在几个核心或处理器线程中同时处理几个大数据结构的碎片，还是显得有些矫枉过正。</p>
</div>
<div class="paragraph">
<p>这就是所谓的数据并行：不是一个一个地处理串行数据，而是同时处理该结构的几个项目。Raku 主要通过两种机制来实现数据并行：<code>hyper</code>/<code>race</code> 和 junction。我们暂且不说后者，重点说说前者。</p>
</div>
<div class="paragraph">
<p><code>hyper</code> 和 <code>race</code> 这两个命令可以像串行数据结构（哈希和数组）的方法一样使用，也可以作为 <code>for</code> 等循环结构的前缀。主要的区别在于处理的顺序，因此也就是输出的顺序。另一方面，<code>hyper</code> 保证结果将以与原始数据结构相同的顺序显示。</p>
</div>
<div class="paragraph">
<p>除此之外，它们的工作方式是一样的。它们分批收集数据结构的元素，提交给不同的线程，并根据需要多次收集结果。在 <code>hyper</code> 的情况下，结果是有序的。这显然涉及到一些开销，这意味着默认情况下不应该使用数据并行。你需要使用大数据结构，所以我们将重新审视我们在第三章中处理的140MB营养素文件，为这个新版本重新安排一下代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Grab Nutrients.csv from https://data.nal.usda.gov/dataset/usda-branded-food-products-database/resource/c929dc84-1516-4ac7-bbb8-c0c191ca8cec
my @nutrients = "/home/jmerelo/Documentos/Nutrients.csv".IO.lines;
my $time = now;
my @selected = @nutrients.grep: {
    my @data = $_.split('","');
    @data[2] eq "Protein" and @data[3] eq "LCCS" and @data[4] &gt; 70 and
    @data[5] ~~ /^g/;
};
say now - $time;
say @selected.join: "\n";</code></pre>
</div>
</div>
<div class="paragraph">
<p>和前一个案例一样，这个代码基本上是选择其推导模式使用 LCCS 的营养素（通过代码），并且每克（可能是毫克，但这并不重要）含有超过70个单位的蛋白质。如果你回到第三章，你会注意到几个变化。首先，我们分离了所有的输入和输出操作。文件在开始时被读取，结果在最后被打印。中间的循环是唯一有时间限制的事情；它在数据结构上进行 greps（过滤），产生一个新的结构。在我的台式电脑上，处理整个数据结构需要32秒左右，总共需要38秒左右。</p>
</div>
<div class="paragraph">
<p>由于这需要很长的时间，让我们尝试简单地通过添加 <code>race</code> 来使用并行化。这样默认情况下，会以64个批次划分，使用4个线程。我们将改变这一行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @selected = @nutrients.race.grep: {</code></pre>
</div>
</div>
<div class="paragraph">
<p>循环的时间会减少到30秒。好吧，不是很大，到是根据情况，差不多是在同一个范围内。这证明了没有自动数据并行这回事，你真的要考虑到硬件的问题。由于我的电脑有8个核心，每个核心有两个物理线程，我们把它提升到11个，看看有没有增加（我们给其他程序留一点汁液）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @selected = @nutrients.race( :11degree ).grep: {</code></pre>
</div>
</div>
<div class="paragraph">
<p>其实，并没有实现大的增加。不过，每批程序的大小64还是很关键的。所以我们要改变一下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @selected = @nutrients.race( :batch(@nutrients/4), :4degree ).grep: {</code></pre>
</div>
</div>
<div class="paragraph">
<p>既然我们事先知道了数组的大小，那么我们就简单的除以我们要使用的线程数，然后使用这么多线程。这样就得到了，哒哒，8.71，所以我们已经把初始时间缩短了4倍左右。我们可以或许把它调大一点吗？让我们用总大小除以6的批处理量和6个线程，在代码中把4改成6。我们是不是有什么收获呢？没有，最多9秒左右。4似乎是一个甜蜜点，因为用3也能达到十秒。</p>
</div>
<div class="paragraph">
<p>到最后，这能给我们买到什么吗？如果你回过头来看看最初的版本，将从文件中读取操作、处理、输出穿插在一起，其时间与最快的数据并行版本的并行度为4，这是为什么呢？简单来说，从磁盘读取是最慢的操作，I/O和语言所利用的处理器之间有一定程度的并行性。输出操作也是如此：输出到控制台是串行操作，这就阻碍了并行性。</p>
</div>
<div class="paragraph">
<p>这意味着数据并行可以给你带来性能的提升，只要所有的操作都能以流水线的方式进行，把数据作为输入，产生更多的数据作为输出，没有副作用。所有的数据都需要在内存中，不需要进行任何输入输出操作，而且，你需要自己调整并行度和批次大小，以达到最大的速度提升。但最重要的是对每一个数据都要做大量的处理，这个问题我们以后再谈。</p>
</div>
<div class="paragraph">
<p>这个配方只做了几个对比，而且我们已经看到了，它几乎已经到了受益于 <code>race</code>/<code>hyper</code> 的边缘。无论如何，主要的一点是，这些命令有自动并行的潜力，但你需要考虑你的实际生产机器和你的问题，看看它们是否能帮助你。当你这样做的时候，微调并行度和批次会给你带来最大的性能提升。</p>
</div>
<div class="paragraph">
<p>最终的版本会是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $degree = @*ARGS[0] // 4;
my $time = now;
my @selected = @nutrients
    .race( :batch(@nutrients/$degree),:degree($degree)  )
    .grep: { /...</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以根据机器和操作系统来调整并行度，默认使用对我来说效果最好的并行度（对你来说可能不是这样）。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配方15_2_使用异步输入输出">11.2. 配方15-2. 使用异步输入/输出</h3>
<div class="sect3">
<h4 id="_问题_38">11.2.1. 问题</h4>
<div class="paragraph">
<p>您需要创建能够立即响应输入的程序，而不会在输入或输出操作发生时挂起。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_26">11.2.2. 解决办法</h4>
<div class="paragraph">
<p>通过通道和线程将数据并行与异步输入或输出结合起来，或者仅仅依靠 Raku 固有的事件循环来快速高效地处理输入。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_41">11.2.3. 它是如何工作的</h4>
<div class="paragraph">
<p>在第11章中，我们设置了一个 web 钩子，通过使用多个线程工作在重负载上，例如建立一个网站，立即响应变化消息。我们可以更普遍地应用这种技术来使 I/O 绑定的操作变得更快。例如，网络操作是出了名的慢。请求一个外部 API 需要时间，在等待响应时阻塞程序的其他部分会花费很长时间。并行发出请求会使整个操作变得和最慢的那个一样慢，这时我们就可以收集所有的操作。</p>
</div>
<div class="paragraph">
<p>但是，你需要小心。试图并行化我们在第11章中使用的 Wikidata 查询示例将导致失败。在像这样的开放 API 的情况下，基本上同时发出两个请求是不礼貌的，并行请求将返回以下内容。</p>
</div>
<div class="paragraph">
<p>There&#8217;s an error in the API request: Error response 429: Rate limit exceeded.</p>
</div>
<div class="paragraph">
<p>然后，让我们尝试一个不同的例子。你可能还记得在第9章中使用 Edamam API。单个 API 请求大约需要三秒钟。为什么不把这些请求异步地汇集起来，这样我们就可以异步地发出尽可能多的请求，然后在结果到达时进行处理呢？</p>
</div>
<div class="paragraph">
<p>首先要考虑的是"尽可能多"的部分。大多数 API 都有一个限制，Edamam 也不例外。在免费层中，它允许，每分钟5个请求（如果你超过这个数量，你会收到一封邮件，如果你超过了，它将返回429状态）。所以，这个池子最多只能是五个，然后我们就得等一段时间。在等待请求上限补充的时候，任何可能的速度提升都会失去。无论如何，尽快获得早期的结果有其价值，这就是我们在这里做的事情。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env perl6

use Cro::HTTP::Client;
use URI::Encode;
use Raku::Recipes::SQLator;

my $appID = %*ENV{'EDAMAM_APP_ID'};
my $api-key = %*ENV{'EDAMAM_API_KEY'};
my $api-req = "\&amp;app_id=$appID\&amp;app_key=$api-key";

my $dator = Raku::Recipes::SQLator.new;
my $cro = Cro::HTTP::Client.new(base-uri =&gt; "https://api.edamam.com/");

my @responses = do for $dator.get-ingredients.keys[^5] -&gt; $ingredient {
    $cro.get("search?q=" ~ uri_encode(lc($ingredient)) ~ $api-req) ;
}

for await @responses -&gt; $response {
    my %data = await $response.body;
    say "⇒Ingredient %data&lt;q&gt;\n\t→", %data&lt;hits&gt;.map(*&lt;recipe&gt;&lt;label&gt;).join:
            "\n\t→";

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>脚本的大部分内容与之前的版本相同。归根结底，就是提出请求和获取响应。</p>
</div>
<div class="paragraph">
<p>主要的区别是在请求循环中。通过使用 <code>do for</code> 结构，返回循环中最后一条指令的结果。<code>$cro.get</code> 返回的是一个承诺；事实上，我们之前所做的是在这个承诺上等待获得结果。我们现在要做的，不是单独等待每个响应，而是创建一个响应承诺数组。</p>
</div>
<div class="paragraph">
<p>承诺需要被遵守，我们无论如何都需要等待响应来获得它们。但是，我们不是停止程序流来等待第一个承诺，然后再进行第二个承诺，而是用 <code>await @responses</code> 来等待所有五个承诺。在这种形式下，当每一个承诺都被满足后， <code>await</code> 将返回所有承诺的结果。这将和最慢的响应一样，五个请求都会在差不多的时间内发射。现在，处理响应的方式是一样的，除了我们循环处理包含在变量 <code>$response</code> 中的承诺结果。</p>
</div>
<div class="paragraph">
<p>这将会打印出类似这样的结果。</p>
</div>
<div class="paragraph">
<p>⇒Ingredient chicken breast
         →Sous Vide Chicken Breast Recipe
         →Roasted Chicken Breast
         →Chicken Breast with Salsa</p>
</div>
<div class="paragraph">
<p>就是说，在 Edamam 数据库中，第一行中的每一种食材都有一些配方，但重要的是，这些配方有多长？但重要的是，这需要多长时间？在我的系统中大约需要5秒钟，这比单次请求所需的时间勉强多一点，而这个程序实际上做得更多，因为它从数据库中获取信息，并打印更多行的输出。</p>
</div>
<div class="paragraph">
<p>这里的关键是 <code>Cro::HTTP::Request</code> 是异步工作的，很好地集成到异步程序中。你可以简单地通过包裹一个同步请求的承诺来获得同样的结果（比如从 <code>LWP::Simple</code> 获取）。然而，使用 Cro，代码更加清晰和简单。</p>
</div>
<div class="paragraph">
<p>异步编程允许你通过在一个快速的系列中汇集尽可能多的请求来利用带宽。这在面向用户的应用程序中是必不可少的，并将帮助您创建响应式程序。Raku 很好地集成了各种设施，提供了承诺的工业标准数据结构。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_15_3_使用通道和线程使你的程序并发执行">11.3. 食谱 15-3. 使用通道和线程使你的程序并发执行</h3>
<div class="sect3">
<h4 id="_问题_39">11.3.1. 问题</h4>
<div class="paragraph">
<p>单线程程序运行时间较长。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方法_13">11.3.2. 解决方法</h4>
<div class="paragraph">
<p>重塑你的问题，使之成为一个任务序列，这些任务可以交换消息，或者当它们收到一个带有有效载荷的消息时开始工作，该消息表明任务将是什么。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_42">11.3.3. 它是如何工作的</h4>
<div class="paragraph">
<p>并发编程是让不同的进程同时工作并协调获得结果的艺术。当然，问题在于协调的部分。一般来说，你需要将数据传递给进程和/或从进程中获取数据，而你这样做的方式基本上是问题的一部分。处理这个问题的方法有很多，其中最糟糕的一种是使用共享的一部分内存（比如说，通过全局变量），让每个人都在里面读，甚至更糟糕的是，在里面写。如果有一种方法可以锁定该共享内存，使一次只有一个进程在读/写，就会变得简单一些，但仍然存在让每个进程管理自己的锁并按时释放它们的问题。</p>
</div>
<div class="paragraph">
<p>另一种管理方式是通过一种叫做 Communicating Sequential Processes（CSP）的方法，由伟大的计算机科学家 C.A.R.Hoare 提出。CSP 的基本思想很简单。在使用通信总线交换信息的进程之间，不会有共享内存。这种通信总线通常被称为通道，正如我们在第11章中所看到的那样，它在 Raku（以及其他语言如 Go 和 Julia）中被实现为一种基本的数据结构。</p>
</div>
<div class="paragraph">
<p>Raku 中的进程将使用通道来接收它们需要工作的数据结构，以及在需要时与其他通道进行结果通信。具体来说，我们可以使用它以半自动的方式将数据分配给任务。</p>
</div>
<div class="paragraph">
<p>让我们在接下来的程序中实现这个功能，它取了一个大文件，其中包含了 MealMaster 格式的食谱，这个文件是由几个在 <a href="http://ffts.com/recipes.htm" class="bare">http://ffts.com/recipes.htm</a> 上找到的食谱处理而成的。这些食谱中的一些是从80年代的 Usenet 上获取的。长话短说，这些菜谱似乎没有版权，我把它们合并成一个文件，转换成UTF8编码。每一个菜谱，我们都会这样处理:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>提取标题、成分和类别</p>
</li>
<li>
<p>扫描食材，并将其链接到我们为其创建的页面上（就像我们在第11章中做过的那样）</p>
</li>
<li>
<p>在 markdown 中转储结果，然后将其转换为 HTML</p>
</li>
<li>
<p>使用模板创建一个网页（与我们在第10章中的做法相同）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们将创建这个脚本来说明并发和通信到通道的主要原理。</p>
</div>
<div class="paragraph">
<p>警告：虽然这个程序在大多数时间都是并行运行的，但它可以得到很大的改进，我们将在下一个配方中看到。下一个配方将扩展并发程序中使用的方法论，并将解释如何调试它们以获得最大的好处。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env perl6

use Inline::Perl5;
use MealMaster:from&lt;Perl5&gt;;
use Raku::Recipes::Recipe;
use Raku::Recipes::SQLator;
use URI::Encode;
use Template::Classic;
use cmark::Simple;

my $threads = @*ARGS[0] // 4;

my Channel $queue .= new;

my $parser = MealMaster.new();
my @recipes = $parser.parse("Chapter-15/allrecip.mmf");

my %ingredients = Raku::Recipes::SQLator.new.get-ingredients;
my @known = %ingredients.keys.map: *.lc;

my &amp;generate-page = template :($title,$content),
        template-file( "templates/recipe-with-title.html" );

my atomicint $serial = 1;

my @promises = do for ^$threads {
    start react whenever $queue -&gt; $recipe is copy {
        $recipe.ingredients = process-ingredients( $recipe );
        "/tmp/recipe-$serial.html".IO.spurt(generate-page($recipe.title,
                commonmark-to-html($recipe.gist)).eager.join);
        say "Writing /tmp/recipe-$serial.html";
        $serial⚛++;
    }
}

for @recipes -&gt; $r {
    my $description = "Categories: " ~ $r.categories().join( " - ");
    my $title;
    if $r.title ~~ Str {
        $title = $r.title
    } else {
        $title = $r.title.decode
    }
    my $recipe = Raku::Recipes::Recipe.new(
        :$title,
        :$description,
        ingredients =&gt; $r.ingredients().map: {.product }
            );
    $queue.send: $recipe;
}

$queue.close;

await @promises;

sub template-file( $template-file-name ) {
    "resources/$template-file-name".IO.e
            ??"resources/$template-file-name".IO.slurp
            !!%?RESOURCES{$template-file-name}.slurp;
}

sub process-ingredients( $recipe ) {
    my @real-ingredients = $recipe.ingredients.grep: /^^\w+/;
    gather for @real-ingredients -&gt; $i is copy {
        $i = $i ~~ Blob ?? $i.encode !! $i;
        if $i ~~ m:i/ &lt;|w&gt; $&lt;ingredient&gt; = (@known) &lt;|w&gt;/ {
            my $ing = ~$&lt;ingredient&gt;;
            my $subst = "[$ing](/ingredient/" ~ uri_encode($ing.lc) ~ ")";
            $i ~~ s:i!&lt;|w&gt; $ing &lt;|w&gt; ! $subst !;
        }
        take $i;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序有点长，但除了对通道的新颖使用外，大部分都是结合了其他配方中看到的技术。程序的关键部分之一是需要生成一个单一的序列号，这样我们就可以给每一个我们创建的 HTML 文件一个唯一的名字。只要我们不使用随机的文件名，无论如何我们都会需要这个。例如，如果我们使用标题，我们仍然需要检查它是否是唯一的，并且我们不会用新的文件滥竽充数。所以我们将使用一个独特的 Raku 功能，原子数。<code>atomicint</code> 数据类型提供了一系列在线程下安全的操作。我们只需要对它进行增量，但原子数不是普通的 ints，所以我们还可以这样对它进行原子增量：$serial⚛++。这虽然是共享内存，但是保证了在线程下的工作，所以我们就可以了。</p>
</div>
<div class="paragraph">
<p>我们还使用了一个通道，简单的说就是 <code>$queue</code>，因为它是一个任务队列，会接收哪些操作的数据。</p>
</div>
<div class="paragraph">
<p>程序包括两个主要部分：一部分从文件中提取食谱，并将它们转换为 <code>Raku::Recipes::Recipe</code> 数据结构。这个数据结构被发送，用 <code>$queue.send：$recipe;</code> 发送到队列中。队列可以处理 Raku 中的任何类型的数据结构，不需要对它们进行序列化/反序列化。它只是在工作。</p>
</div>
<div class="paragraph">
<p>执行任务的线程确实是在这个发射发生之前创建的，只是因为它们是反应式的代码，在需要的时候会被唤醒。而当 <code>$queue</code> 中接收到消息时，这种需要就会出现。我们首先在我们将工作的线程数量上建立一个循环。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @promises = do for ^$threads { start ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是用 <code>do</code> 语句前缀建立的，它收集了循环中每次迭代的结果。这就是其中最后一条语句的结果。在这种情况下，它是一个启动语句，它返回一个承诺；然后 <code>@promises</code> 将包含为每个线程创建的承诺，默认为四个（对于中端笔记本电脑和台式机来说是一个合理的数字）。</p>
</div>
<div class="paragraph">
<p>承诺实际上是反应式代码：<code>react whenever $queue → $recipe</code> 将在队列中收到东西时唤醒。每一个承诺都会以同样的方式行事，它们会在队列可用时立即尝试从队列中读取。它们是否在不同的线程上运行将取决于有多少个可用的线程，但从高级别的角度来看，并且在合适的情况下，每个承诺都将在不同的线程中实现。</p>
</div>
<div class="paragraph">
<p>在队列中，操作并不是非常繁重，但它包括一系列的依赖性传递。首先，我们过滤掉 "---- xxx ----- " 形式的"成分"，这些成分实际上是配方中解析不好的部分。然后我们对这些剩余的成分进行检查，使用正则表达式来查找我们要链接的已知成分。这个 <code>regex &lt;|w&gt; $&lt;ingredient&gt; = (@known) &lt;|w&gt;</code> 不仅会尝试查找该菜谱中的配料，只返回那些由单词边界标记 <code>&lt;|w&gt;</code> 说明的整词的配料（这样我们只链接大米(rice)，而不链接甘草(licorice)），而且还会存储配料的名称，我们将用它来创建链接，并将其存储在 <code>$subst</code> 变量中。</p>
</div>
<div class="paragraph">
<p>如果有任何这些成分，我们还需要替换它们，我们在这里这样做。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$i ~~ s:i!&lt;|w&gt; $ing &lt;|w&gt; ! $subst !</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>s</code> 是替代操作符，工作在 <code>$i</code> 上，它已经被声明为"原样"副本，所以我们可以改变它的值。<code>:i</code> 副词表示它将不区分大小写，因为配方有各种大写，从全大写到首字母大写。这个 <code>s</code> 操作符可以使用任何类型的引号。我们选择用 <code>!!!</code> 而不是 <code>///</code>，只是为了让 regex 更加明显。这样就会增加 markdown 式的链接。</p>
</div>
<div class="paragraph">
<p>这些成分在一个收集/获取循环中；<code>$i</code> 被"获取"，根据我们找到的成分，进行收集、处理或不处理。</p>
</div>
<div class="paragraph">
<p>其余的循环则是将这些原料重新分配到配方中。这个 <code>Raku::Recipes::Recipe</code> 有将整个配方打印成 markdown 的机制，所以我们利用这一点，在接下来的一句话中，对配方做一系列的事情。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$recipe.gist 会将菜谱（包括新铸成的 markdown 链接）渲染成 markdown。</p>
</li>
<li>
<p>结果通过我们在上一章创建的 cmark::Simple 模块的 commonmark-to-html 转换为 HTML。</p>
</li>
<li>
<p>这要经过 generate-page，一个 Template::Simple 子程序，它将把生成的 HTML 片段和食谱的标题一起放到一个页面中。这个例程会生成一个惰性的数组，我们"急切地"将其呈现出来，然后连接成一个单一的字符串。</p>
</li>
<li>
<p>该字符串通过 <code>spurt</code> 写入一个文件，在本例中，该文件将在 <code>temporal</code> 文件夹中。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>序列是原子增量的，在它被唤醒之前，那段代码会进入睡眠状态，时间确实很短，可能在另一个线程中。那读取原始文件需要几分钟，生成4000多个文件，默认的线程数，一次运行需要十分钟左右。</p>
</div>
<div class="paragraph">
<p>这对于一个10MB的文件来说，确实是一个不错的标志。如果每一个的处理量大一点，而且不是那么I/O绑定的话，可能会更好。如果能从文件中混入惰性读取，那就更好了。增加更多的线程并不是真正的改进。为什么会这样，这是留给下一个配方的任务。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用_comma_ide_监控并发">11.4. 使用 Comma IDE 监控并发</h3>
<div class="sect3">
<h4 id="_问题_40">11.4.1. 问题</h4>
<div class="paragraph">
<p>调试并发程序是特别困难的。除了 grokking 程序做了什么，你还需要知道它是否同时发生，也就是说，并发是否真的发生了，发生了多少。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方法_14">11.4.2. 解决方法</h4>
<div class="paragraph">
<p>Raku 的 IDE，Comma，包括可视化并发事件和任务的设施。为了使用它，您必须在您的代码中添加一个特定的日志库，称为 Log::Timeline。Comma 检查这些日志，以便在 IDE 中可视化地显示事件和任务。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_43">11.4.3. 它是如何工作的</h4>
<div class="paragraph">
<p>在并行程序中，你必须考虑的最重要的事情之一是通信和计算之间的平衡。通信（往返于通道）与顺序版本会产生一定的开销。如果你在不同线程中进行的同步计算量能够克服这个开销，那就是赢了。如果没有，你就输了。所以，你需要把尽可能多的计算放在线程中，但同时也要验证，这些线程是否有效地以并行的方式运行，是否存在一个处理器空闲而其他处理器做所有工作的空隙。</p>
</div>
<div class="paragraph">
<p>执行这个任务的主要工具是 Comma，我们已经讨论过多次的 IDE。Comma 本身并不能监控并发执行，它需要在程序中做一些小的修改才能做到这一点。我们需要在 Log::Timeline 模块中添加混合的模块。这就是我们要用来监控前面程序的那个模块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module Recipr::Log::Timeline;
use Log::Timeline;
class Processing does Log::Timeline::Task['Recipr', 'Backend', 'Processing'] is export { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将把所有的 logger 类放在一个模块中，叫做 Recipr::Log::Timeline。有两种类型的角色可以混合在一起。Log::Timeline::Task 和 Log::Timeline::Event。目前，我们就用前者。它们用来记录它们的 last name 所表示的内容，要么是扩展任务，要么是单个事件。任务记录器的主要目的是环绕我们需要监控的代码，以便检查它的运行时间和程度。事件记录器是传统的记录器：可以将任何种类的数据记录成通用格式。两者都会在监控器中呈现。</p>
</div>
<div class="paragraph">
<p>Log::Timeline::Task 是一个参数化的角色。它的设计是为了让参数作为一种实例化。不同的要记录的任务会有不同的三个参数组合，这三个参数分别对应模块名称、任务类别和任务名称。任务将按照类别进行分组，然后按照名称进行分组。我们将使用同一个类来记录所有将做同一任务的线程。这个类本身是空的，因为我们不需要任何额外的处理。我们也把它从模块中导出，这样从外面就可以看到它。</p>
</div>
<div class="paragraph">
<p>在我们的程序中，我们不需要做太多的事情来添加这个。你只需要用 <code>Recipr::Log::Timeline::Processing.log: &#8594; { }.</code> 包住你想要监控的任务的代码。 就是说:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @promises = do for ^$threads {
    start react whenever $queue -&gt; $recipe is copy {
        Recipr::Log::Timeline::Processing.log: -&gt; {
            #...same code here
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常情况下, 所有在一个线程中完成的工作都会被这样包装. 但是你可以用这种方式来封装任何你想要表示的代码；每个片段都会在代码监视器中得到一个表示。</p>
</div>
<div class="paragraph">
<p>我们将对代码进行一个额外的改变。我们使用的是一个原子变量，它保证了它不会被两个线程同时修改。但是，这并不能保证它不会被两个线程同时使用，因为它是在写完文件后才被修改的，而写一个文件可能需要几分之一秒的时间。在第一个文件之后，这种情况极不可能发生，但在最开始的时候，当线程同时启动的时候，可能会造成竞赛条件。所以最好使用一个局部变量，而不是全局变量，并把这个变量放到启动任务的消息中。我们把它改成这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$queue.send: ($i++, $recipe);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这需要对接收代码进行修改。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">start react whenever $queue -&gt; ($serial, $recipe) is copy {</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将把接收到的列表分解成序列号和配方对象。代码的其余部分将只取消原子增量操作符，保持文件名不变。</p>
</div>
<div class="paragraph">
<p>那我们就尝试着用监控来让它工作吧。我们需要点击 buggy 旁边的图标，看起来像&#8230;&#8203;&#8230;&#8203;真的，我不知道它看起来像什么。两条绿色的线和蓝色、黄色的点和线。猜测它有点像时间线。总之，我们需要这样运行。我们会看到像图15-1这样的东西。不用说，这并不是我们要找的东西。</p>
</div>
<div class="paragraph">
<p>至少，我们看到它是并行的。问题是，并行在经过了几秒钟的比较长的停顿之后，线程根本没有并行运行，就开始了。第二，只有两个线程。</p>
</div>
<div class="paragraph">
<p>图15-1. 程序的第一次迭代，用 Comma 监控。并行监控图标在红色方块"停止"图标的左边。</p>
</div>
<div class="paragraph">
<p>一旦它们开始运行，两个线程并行运行正常，如两个线程中交替创建的带子所示。</p>
</div>
<div class="paragraph">
<p>那么问题到底出在哪里呢？序列部分，也就是给通道供电的循环，是有问题的。整个程序并不是以并行的方式运行的，因为线程在启动几秒钟后才开始执行任务，这时调度器才会想办法让它们进来。这绝对不理想，这也解释了为什么使用更多的线程对整体性能没有帮助，正如我们之前看到的那样。</p>
</div>
<div class="paragraph">
<p>我们能做什么呢？我们可以让供给通道的代码也变得并发，通过启动一个运行它的线程。我们通过使用这段代码来添加。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">await start for @recipes -&gt; $r { # Rest of the loop is the same.</code></pre>
</div>
</div>
<div class="paragraph">
<p>也就是说，<code>start for</code> 启动一个线程，而 <code>await</code> 只有在全部完成后才会进行。</p>
</div>
<div class="paragraph">
<p>监视器将显示这种截然不同的全景图，如图 15-2 所示。</p>
</div>
<div class="paragraph">
<p>图 15-2. 在 6 个不同的线程中运行 Recipr</p>
</div>
<div class="paragraph">
<p>我们换成 4 个线程。我们可以通过编辑配置中的命令行参数来改变 Comma 中的命令行。结果如图 15-3 所示。</p>
</div>
<div class="paragraph">
<p>图 15-3. 用 4 个线程运行</p>
</div>
<div class="paragraph">
<p>这里有几件事我们可以欣赏。首先，在每次运行中都会出现相当明显的差距（当你知道比例时，就是1/5秒）。第二，任务最初非常快的事实。如果我们将鼠标悬停在条纹上，我们会看到它们需要0.06秒左右。后来，本应花费差不多时间的事情，却花费了长达半秒的时间。结果和最初的版本一样，四个线程大约需要十分钟。增加更多的线程并不是真正的提升，至少在我的笔记本上是这样。</p>
</div>
<div class="paragraph">
<p>问题还是在于通信和计算之间的平衡。有一个单线程在预处理配方和创建对象。这个线程一直在运行。我们要监控它，检查它是否在其他线程处理时有效地运行。我们在程序的总线程数中也增加了一个线程，所以剩下的空间不大。</p>
</div>
<div class="paragraph">
<p>我们再添加一个任务监视器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Emitting does Log::Timeline::Task['Recipr', 'Backend', 'Emitting']
                 is export { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们把 <code>loop</code> 迭代包在里面:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">await start for @recipes -&gt; $r {
    Recipr::Log::Timeline::Emitting.log: -&gt; {
        # same code as before.
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将导致图 15-4。</p>
</div>
<div class="paragraph">
<p>图 15-4. 监视发射线程</p>
</div>
<div class="paragraph">
<p>那额外的监测让我们看到，排放需要的时间非常少，有很多排放不能实时处理。还有一个小的差距，问题是处理每一个文件都需要几十分之一秒的时间。我们可以试着深入研究一下，看看这个时间在哪里。我们再加一个显示器。由于我们要在同一组中有两个监视器，我们将尝试把它们分成两组，这样重命名:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module Recipr::Log::Timeline;
use Log::Timeline;

class Processing does Log::Timeline::Task['Recipr', 'Processing', 'Processing']
                is export { }
class Emitting does Log::Timeline::Task['Recipr', 'Backend', 'Emitting']
                is export { }
class Saving does Log::Timeline::Task['Recipr', 'Processing', 'Saving']
                is export { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以凡是进入处理线程的东西都会以 Processing 作为名称，而 Emitting 则是后台类的单任务记录器。结果如图15-5所示。</p>
</div>
<div class="paragraph">
<p>图15-5. 任务内的监控</p>
</div>
<div class="paragraph">
<p>"保存"的小条纹表明，它并没有花很长时间：是任务的其他部分花了这么长时间。顺便说一下，我们还可以看到，发射器发送消息的速度比处理消息的速度快得多；无论如何，这是很自然的，但处理每条消息似乎还是要花很长时间。</p>
</div>
<div class="paragraph">
<p>我们现在需要做的是对这些较慢的部分进行剖析。这不属于并行处理的范畴，但本章是关于性能的。让我们试着把这件事做到极致。我不打算用另一张显示器的截图来烦扰你，显示循环的不同部分的表现，但在代码片段而不是整个循环上工作会发现几个问题。那个在成分上的循环有效地耗费了很长的时间，在某些情况下，是单个的迭代耗费了几百分之一秒的时间。我们可以通过从循环中取出 URL 的创建来加快一点速度。你失去了一些东西（它们将以与最初相同的大写字母出现），但你节省了一些速度。</p>
</div>
<div class="paragraph">
<p>我们需要让它更快一些。也许是出了名的慢的 regexes 的缘故。让我们用 <code>subst</code> 来代替。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @promises = do for ^$threads {
    start react whenever $queue -&gt; $recipe is copy {
        Recipr::Log::Timeline::Processing.log: -&gt; {
            my @real-ingredients = $recipe.ingredients.grep( /^^\w+/)
            .map( {  $_ ~~ Blob ?? $_.decode !! $_ } );
            $recipe.ingredients = @real-ingredients;
            my $recipe-md = $recipe.gist;
            for @known -&gt; $k {
                $recipe-md .= subst( /:i &lt;|w&gt; $k &lt;|w&gt;/, %urls-for-known{$k} )
            }
            Recipr::Log::Timeline::Saving.log: -&gt; {
                "/tmp/recipe-$serial.html".IO.spurt(generate-page($recipe.title,
                        commonmark-to-html($recipe-md)).eager.join);
                say "Writing /tmp/recipe-$serial.html";
            }
            $serial⚛++;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们已经取消了对成分的循环，用一个过滤成分的 <code>map</code> 来代替。该映射会对原始文件中发现的 blobs 进行解码（主要来自于使用一些非英文字母，如 é）。事实上，我们可以取消使用临时变量 <code>@real-ingredients</code>。</p>
</div>
<div class="paragraph">
<p>我们不需要对每个成分进行替换，另外，由于它只替换了第一个找到的单词，所以可能容易出错，而是循环所有产品并进行替换。我们在 regex 里面使用副词 <code>:i</code> 来使搜索不区分大小写。我们现在在渲染中使用的不是使用 <code>gist</code> 转换配方，而是这个新的标记文档，其中包含所有的替换。</p>
</div>
<div class="paragraph">
<p>这是否带来了真正的改进？不出所料（或不出所料），确实如此。它消除了一个循环，并引入了另一个循环，其结果可能会更快，因为它将在所有的实例上替换一个产品名称，而且会快得多。最后一个版本的程序需要5分钟左右。然而，主要的提升可能来自于这样一个事实：我们只检查一次正则表达式，而不是在结果为正匹配的情况下检查两次。</p>
</div>
<div class="paragraph">
<p>无论如何，这显示了应该使用的方法论来调试和获得并发程序的最大性能。首先，你必须找出是什么拖慢了它的速度。你的程序可能已经够快了，也可能大部分时间都花在一个很小的部分。那个慢的部分也需要用某种方式来并行。然后，你必须最大限度地提高并发性：把程序中尽可能多的串行部分放在自己的独立线程中，通过检查性能来尽量消除瓶颈，最终优化每线程性能，使每个部分都尽可能快。始终保持线程数量的灵活性，并测试运行几个数字，直到你得到适合你的特定平台的最佳组合。这将取决于你拥有的物理线程数量、正在运行的其他程序和服务以及输入/输出性能。最大化线程数量可能不是最好的主意；使用能给你带来最大提升的数字。</p>
</div>
<div class="paragraph">
<p>一定要考虑到下一个配方中讨论的最佳实践。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配方15_5_创建强大的并发程序问题">11.5. 配方15-5. 创建强大的并发程序问题</h3>
<div class="paragraph">
<p>您需要创建一个尽可能快的程序，给定您的规格、输入和输出。</p>
</div>
<div class="sect3">
<h4 id="_解决办法_27">11.5.1. 解决办法</h4>
<div class="paragraph">
<p>嗯，这里没有一个解决方案。并发性能取决于很多东西，而且没有什么灵丹妙药。在计算和通信之间取得平衡，找到正确的数据和控制结构，是一个系统测试和深入了解你的程序所运行的硬件和软件的问题。由于缺乏一个放之四海而皆准的方法，您所拥有的只是一系列的最佳实践，您可以使用 Raku 工具（如 Comma 并行监视器和日志）来逐步改进您的程序。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_44">11.5.2. 它是如何工作的</h4>
<div class="paragraph">
<p>并行编程是一门艺术，它能让许多CPU一起用大量的通信做很多工作，而一开始可能只需要一个顺序程序。让我们回到之前的程序，尝试一个顺序版本。这里展示了整个程序，虽然大部分代码是重复使用的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env perl6

use Inline::Perl5;

use MealMaster:from&lt;Perl5&gt;;

use Raku::Recipes::Recipe;
use Raku::Recipes::SQLator;

use Template::Classic;
use cmark::Simple;

my $threads = @*ARGS[0] // 3;

my $parser = MealMaster.new();
my @recipes = $parser.parse("Chapter-15/allrecip.mmf");

my %ingredients = Raku::Recipes::SQLator.new.get-ingredients;
my @known = %ingredients.keys.map: *.lc;

my &amp;generate-page = template :($title,$content),
        template-file( "templates/recipe-with-title.html" );

my %urls-for-known = | @known.map: { $_ =&gt; "[$_](/ingredient/$_)"};

@recipes.kv.rotor(2).map( { process-recipe(@_[0], @_[1]) } );

# Subs
sub template-file( $template-file-name ) {
    "resources/$template-file-name".IO.e
            ??"resources/$template-file-name".IO.slurp
            !!%?RESOURCES{$template-file-name}.slurp;
}

sub process-recipe( $serial, $recipe ) {
    my $description = "Categories: " ~ $recipe.categories().join(" - ");
    my $title;
    if $recipe.title ~~ Str {
        $title = $recipe.title
    } else {
        $title = $recipe.title.decode
    }
    my $rrecipe = Raku::Recipes::Recipe.new(
            :$title,
            :$description,
            ingredients =&gt; $recipe.ingredients().map: { .product }
            );
    my @real-ingredients = $rrecipe.ingredients.grep(/^^\w+/)
            .map({ $_ ~~ Blob ?? $_.decode !! $_ });
    $rrecipe.ingredients = @real-ingredients;
    my $recipe-md = $rrecipe.gist;
    for @known -&gt; $k {
        $recipe-md .= subst(/:i &lt;|w&gt; $k &lt;|w&gt;/, %urls-for-known{$k})
    }
    "/tmp/recipe-$serial.html".IO.spurt(generate-page($rrecipe.title,
            commonmark-to-html($recipe-md)).eager.join);
    say "Writing /tmp/recipe-$serial.html";

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序做了两个比较小的改动。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每个菜谱都是在一个函数中处理的，这个函数接收封装的 Perl 5 MealMaster::Recipe 对象，进行所有的过滤，并最终保存到文件中。</p>
</li>
<li>
<p>它使用一个单一的映射，而不是线程和通道，来处理大约10000个菜谱的数组。这一行 <code>@recipes.kv.rotor(2).map( { process-recipe(@<em>[0], @</em>[1]) } );</code> 生成一个索引元素序列，通过 <code>.rotor</code> 将其分块成 <code>(index，recipe)</code> 数组。我们将像之前那样使用索引来创建文件名。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这里没有真正的并行性，只有高效的数据流。一般来说，将代码布局好，这样你就可以将其作为一个 map 来应用，这比使用循环的类似方法要快。我们现在有一个单一的 map，而不是两个循环。在同一台笔记本电脑上运行这个需要大约三分钟，而运行并行版本需要近五分钟。是什么原因呢？</p>
</div>
<div class="paragraph">
<p>嗯，通信就是这样。最新版本的程序效率比较高，但它无法克服每一个配方都要发送一条消息，总共约有10000条消息。而且每条消息都有自己的开销。虽然我们可以同时处理消息，但所增加的开销比将整个程序并行化所获得的还要多。</p>
</div>
<div class="paragraph">
<p>这并不意味着之前的程序就无效了。它有它的用处：当你不想让单个处理器过载，或者当你有效地想通过这种方式利用低负载处理器时。每一种并行化技术都有自己的定位。此外，通过改进单线程代码，我们也为这个，更高性能的版本铺平了道路。</p>
</div>
<div class="paragraph">
<p>我们还能做得更好吗？不，我们做不到。我们可以使用 <code>hyper</code>，或者 <code>race</code>，但结果会在同一个范围内。这里的问题是，每个配方所做的计算量并不多。这里的第二个启示是，为了达到良好的计算和通信平衡，你需要有相当数量的单项计算开始。大的数据结构和少量的计算量并不是一个好的组合，尽管你可能会想出一个并行处理的方案（例如，用手工批量计算数据结构的块）。在一个足够小的数据结构上进行相当数量的计算，更像是那种可以进行自动（通过 <code>hyper</code>/<code>race</code>）或手动（通过 <code>channel</code>/<code>start</code>）计算的问题。</p>
</div>
<div class="paragraph">
<p>所以如果问题本身不适合求解，我们可以随时改变问题。与其创建一个单一的文件，然后一次性以非常小的块数处理它，不如让我们将文件分成许多更小的文件，并尝试对这些文件进行并行处理。这个 Raku 脚本将把我们原来使用的大文件分割成包含400个食谱的小块（除了最后一个）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env perl6

use Inline::Perl5;
use MealMaster:from&lt;Perl5&gt;;

my $input-file-name = @*ARGS[0] // "allrecip.mmf";

my $all-recipes = $input-file-name.IO.slurp;

my @recipes = $all-recipes.split( /^^ ["-----" | "MMMMM"] \s+ /);
my $index = 1;

for @recipes.rotor(400) -&gt; @chunk {
    my $all-recipes = '';
    for @chunk -&gt; $r {
        my $this-mm;
        if $r ~~ /^"-"/ {
            $this-mm = "$r\n-----\n";
        } else {
            $this-mm = "$r\nMMMMM\n";
        }

        "/tmp/temp.mmf".IO.spurt($this-mm);
        if MealMaster.parse("/tmp/temp.mmf") {
            $all-recipes = "$all-recipes$this-mm\n";
        } else {
            say $all-recipes;
            die $this-mm;
        }
    }
    "/tmp/all-recipes-$index.mmf".IO.spurt( $all-recipes );
    $index++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它还在用 Raku 处理格式方面取得了小小的进展。事实上，它唯一能做的就是将整个文件以菜谱的形式分割开来，进行检查，然后再将它们连接在一起，形成一个400个菜谱的文件。</p>
</div>
<div class="paragraph">
<p>为了做到这一点，我们再回头看看格式。有点诡异的是，食谱包含在一个格式内，它的结尾要么是五个破折号，要么是五个 Ms，在第一种情况下，它会有一堆破折号，后面是一个语句，在第二种情况下，有五个</p>
</div>
<div class="paragraph">
<p>Ms 之后是破折号和相同的语句。因为我们要么通过这个正则表达式 <code>/^^ ["-----" | "MMMM"] \s+ /</code> 来分割，它匹配行首的五个破折号或五个 Ms 和一个或多个空格，这个精确的信息就会丢失。然而，Ms 和破折号是需要匹配的，所以我们把它们放回去，写到一个文件中（因为 MealMaster 模块只从文件中读取，所以这是个很好的候选拉请求），以便通过解析来检查，如果没问题（原来的要没问题，但拆分可能不行），就把它加到一个字符串中。最后，整个字符串被写入一个文件，索引会自增。我们最终有21个文件，其中20个文件包含400个菜谱，其中一个文件包含任何剩下的菜谱。所以现在我们有21个文件。我们可以并行处理它们吗？</p>
</div>
<div class="paragraph">
<p>嗯，恰好我们不能。因为底层代码是用 Perl 写的，所以它不是重入式的。任何从线程中调用的代码都必须是重入式的，否则你可能会发现竞赛条件，将来自两个不同线程的代码混合在一起。试图在一个线程中通过 MealMaster 处理一个文件会导致失败。所以我们必须使用 Raku 来处理它们。我们没有语法来解释这个问题（目前）。让我们尝试尽可能地处理它。这是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">      Title: Vegetable Casserole Supreme
 Categories: Casseroles, Vegetables
      Yield: 6 servings

      4 ea POTATOES, SLICED                    1 lb GROUND BEEF
      3 ea CARROTS, SLICED DIAGONALLY          1 cn MUSHROOM SOUP      *
      1 cn PEAS

  *       USE CREAM OF MUSHROOM OR TRY CHICKEN SOUP OR ?
  *----------------------------------------------------------------------*
  LAYER ALL VEGETABLES AND BEEF IN A 2 QUART CASSEROLE DISH. POUR THE SOUP
  (DILUTED WITH 1 CAN OF WATER) OVER THE TOP OF THE DISH.
  BAKE AT 350 DEG F. UNTIL ALL LAYERS ARE DONE.</code></pre>
</div>
</div>
<div class="paragraph">
<p>有三个部分，用双回车分隔。对它们进行处理已经超出了本书的范围，所以我们只需要将标题转换为标题，在类别和产量中贴上二级标题，然后将整个内容转换为HTML。这个程序就可以做到。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env perl6

use Inline::Perl5;

use MealMaster:from&lt;Perl5&gt;;

use Raku::Recipes::Recipe;
use Raku::Recipes::SQLator;
use Recipr::Log::Timeline;

use URI::Encode;
use Template::Classic;
use cmark::Simple;

my $threads = @*ARGS[0] // 3;
my Channel $queue .= new;

my $parser = MealMaster.new();
my @recipes = $parser.parse("Chapter-15/allrecip.mmf");

my %ingredients = Raku::Recipes::SQLator.new.get-ingredients;
my @known = %ingredients.keys.map: *.lc;

my &amp;generate-page = template :($title,$content),
        template-file( "templates/recipe-with-title.html" );

my %urls-for-known = | @known.map: { $_ =&gt; "[$_](/ingredient/$_)"};

my @promises = do for ^$threads {
    start react whenever $queue -&gt; $recipe-file  {
        Recipr::Log::Timeline::Processing.log: -&gt; {
            $recipe-file.path ~~ /$&lt;serial&gt; = (\d+)/;
            my $serial = +$&lt;serial&gt;;
            my @all-lines = $recipe-file.lines;
            my $recipes = @all-lines
                    .grep({ !$_.starts-with("MMMMM") })
                    .grep({ !$_.starts-with("-----") })
                    .join("\n");
            $recipes ~~ s:g/\h+ "Title:" /# /;
            for &lt;Categories Yield&gt; -&gt; $c {
                $recipes ~~ s:g/\h+$c/## $c/;
            }
            process-recipes($serial, $recipes);
        }
    }
}

await start for dir("/tmp", test =&gt; /"all-recipes"/ ) -&gt; $r-file {
    $queue.send: $r-file;
}

$queue.close;
await @promises;

# Subs
sub template-file( $template-file-name ) {
    "resources/$template-file-name".IO.e
            ??"resources/$template-file-name".IO.slurp
            !!%?RESOURCES{$template-file-name}.slurp;
}
sub process-recipes( $serial, $recipe ) {
    "/tmp/recipes-$serial.html".IO.spurt(generate-page("Recipes $serial",
            commonmark-to-html($recipe)).eager.join);
    say "Writing /tmp/recipes-$serial.html";

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>本质上，我们正在做的是已经表明的事情。检测以标记符开始的行并消除它们，为标题和类别添加一些标记，并将其转换为HTML。我们使用 <code>start-with</code> 作为搜索术语，我们使用正则表达式，包括 <code>\h</code>，水平空间，因此回车不会被转换，因此结果是正确的标记。</p>
</div>
<div class="paragraph">
<p>如果我们用一个线程来做这件事，大约需要50秒。如果使用两个线程，则会下降到27秒。更多的线程会给你带来边际收益。主要的问题是，处理每个文件都需要几秒钟的时间；除非一个线程把另一个线程的大量负载减掉，否则它可能会被卡住处理一些东西。更多的线程会增加从第一个完成的线程到最后一个线程之间的时间变化。我们用一个例子来说明。我们有四个任务，分别需要3秒、2秒、1秒和7秒。按顺序，我们需要15秒。两个线程至少需要7秒，但前提是我们很幸运，我们先运行那个较长的任务。额外的线程将永远需要7秒。虽然这种情况下数量不一样，但原理是一样的。对于那些耗时较长的任务，简单地在线程之间进行无优先级的划分，其收益会越来越少。见图15-6。</p>
</div>
<div class="paragraph">
<p>到最后，重要的是原始性能，最后这个版本（诚然，它做的事情略有不同）只需要初始版本的一小部分时间。但它显示了在设计一个强大的并发应用程序时的许多困境。即使你设法有一个非常好的通信/计算比例，你仍然需要在不同任务之间有一个很好的工作量平衡，你需要保持每个任务的总体工作量很低，因为它的最大值将是整个程序需要等待所有任务结束的时间。而在这一切之上，考虑到你的系统中有多少物理线程是很重要的。如果物理线程较少，每个线程在等待处理器可用时都会变慢。你需要用越来越多的线程来运行你的程序，当没有明显的收益时就停止。一般来说，操作系统会给自己保留两到三个线程。在所示的情况下（也是在我的笔记本上），从顺序线程到两个线程会有很大的提升。其他任何东西都将相当于最小的收益。</p>
</div>
<div class="paragraph">
<p>监控工具&#8212;&#8203;比如一个简单的命令行定时和更复杂的 Comma 监控器以及它的日志库&#8212;&#8203;将帮助你设计出你所需要的强大的并发程序。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_有趣的单行程序">12. 有趣的单行程序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 是一种具有功能特性的表达式语言。这使得在管道的一端捕捉用户和系统输入，并从另一端喷出处理过的数据或任何类型的动作变得相对容易。像Perl 和 Raku 挑战赛这样的比赛也强调短程序，这就产生了一大堆简单的脚本，尽管有时在其他语言中难以辨认，但它们的功能却很强大。不过，Raku 追求的是表现力，所以用 Raku 理解它们和创造它们要容易得多。</p>
</div>
<div class="paragraph">
<p>这些单行本也采用了非常有创意的编程模式。我们在本章的所有配方中都使用它们作为原料。</p>
</div>
<div class="sect2">
<h3 id="_食谱_17_1_用单行代码写一个猜谜游戏">12.1. 食谱 17-1. 用单行代码写一个猜谜游戏</h3>
<div class="sect3">
<h4 id="_问题_41">12.1.1. 问题</h4>
<div class="paragraph">
<p>作为一个挑战，你需要写一个游戏，为玩家提供一定的回合数来猜测一个数字，并且每回合都会给他们提示。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决方法_15">12.1.2. 解决方法</h4>
<div class="paragraph">
<p>Raku 使用 <code>;</code> 作为语句分隔符，所以你可以放任意多的语句。</p>
</div>
<div class="paragraph">
<p>在单行上。此外，你还可以使用一些技术来缩短程序，并尽可能地减少字符数：使用单字符变量(或不使用符号变量)，在第一次使用它们时定义它们(或使用隐式变量，不需要定义)，使用运算符代替控制结构( <code>??!!</code> 代替 <code>if</code>)，而且，一般来说，为了长度而牺牲可读性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_45">12.1.3. 它是如何工作的</h4>
<div class="paragraph">
<p>这个猜谜游戏会随机生成一个小数字，玩家尝试通过猜测来确定这个数字。当玩家猜中一个数字时，游戏会提示真正的答案是大数还是小数，从而让玩家缩小数字的猜测范围。当猜到正确的数字时，游戏就结束了。下面是一个非单行程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $number = 6.rand.Int;
my $prompt = "*";
say $number;
while ( my $guess = prompt("$prompt Your guess&gt;") ) ne "" {
    if $guess == $number { last }
    elsif $guess &lt; $number { $prompt = "&lt;" }
    else { $prompt = "&gt;" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>数字生成后，我们用部分提示来说明猜测的数字是比输入的数字大还是小。然后我们运行一个循环，如果猜测正确则退出（使用 <code>last</code>），如果不正确则更改提示。这个循环会一直运行，或者直到我们使用一个空字符串来回应它。用来写消息和收集所写内容的命令，实际上就是提示符。</p>
</div>
<div class="paragraph">
<p>让我们试着利用我们所拥有的一切，将这个程序缩短为一行代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my \n = (1..6).pick; ($_ &gt; n ?? "&gt;" !! "&lt;").print while ( $_ = prompt("Your guess&gt; ") ) != n</code></pre>
</div>
</div>
<div class="paragraph">
<p>注释 好吧，所以在本书中，由于本书的页边距，它不会装进一行。但是你可以在图17-1中看到它在 Raku 中的一行代码中。</p>
</div>
<div class="paragraph">
<p>这一行有93个字符（其中有些是空格），它有两条语句；我们需要一条来声明一个变量。我们使用默认变量 <code>$_</code> 来避免声明一个变量，以及无符号变量来避免输入 <code>$</code>，这是随机数生成的一个较短的版本（可能更快），但本质上是一样的。一字型变量甚至不需要有自己的文件&#8212;&#8203;你可以直接在命令行中使用 <code>-e</code> 运行它们，如图17-1所示。</p>
</div>
<div class="paragraph">
<p>图 17-1. 使用 <code>raku -e</code> 运行单行程序。</p>
</div>
<div class="paragraph">
<p>注意，脚本需要在引号内。由于我们已经使用了双引号，我们将在整个脚本周围使用单引号。</p>
</div>
<div class="paragraph">
<p>如果你需要在Windows中这样做，有很多选择。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>最新的 Windows 版本包含一个 Ubuntu 子系统；您可以使用 shell 来安装和运行 Raku，就像在 Linux 中那样。另一个选择是 CygWin，它可以帮助你安装许多 Linux 程序。最后，GitHub 客户端包括一个 shell，它是 CygWin 的一个版本，如果你想这样做，你可以在那里安装其他 Linux 命令行实用程序并运行它们。</p>
</li>
<li>
<p>这些最后的版本还包括 PowerShell，它具有与 Linux 命令行相同的引用惯例。使用 PowerShell 以同样的方式运行它。</p>
</li>
<li>
<p>最后，你可以简单地在外面使用双引号，如果你使用的是旧版本的 Windows，并且不能（或不愿意）安装 Linux 命令行工具，则可以将里面的双引号用"/"转义。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>请记住，Raku 在使用引号方面是相当自由的，所以如果你在脚本内部使用单引号，你可以用其他引号代替，或者干脆转义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku -e 'my \n = (1..6).pick; ($_ &gt; n ?? ⌈&gt;⌋ !! ⌈&lt;⌋).print while ( $_ = prompt(⌈ Your guess&gt; ⌋) ) != n'</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们能不能把这个再缩短一点？好吧，我们至少可以做一条逻辑线，让它也能发挥作用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{ $^b &gt; $^a
        ?? &amp;?BLOCK($^a, prompt("&gt; "))
        !! $^b &lt; $^a ?? &amp;?BLOCK($^a, prompt("&lt; ")) !! "✓".say
}((1..6).pick,0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是153个字符，再一次，去掉空格会使它更短，但无论如何会比以前长。但这是一个单一的逻辑行。它创建了一个块，并递归地调用它。这个块有两个参数，第一个参数是要猜的数字，第二个参数是猜测。如果猜测的数字比较大，它就会在提示中显示一个"大于"的符号，否则就会显示一个"小于"的符号。它用 <code>??!!</code> 进行三方比较，如果不小于或大于，就一定是解，所以它打印一个复选标记。</p>
</div>
<div class="paragraph">
<p>这里的诀窍是递归调用这个块：没有定义词法变量，要猜的数字以 <code>$^a</code>（一个隐式变量，只要参数的顺序也是变量名的字母顺序，就可以随意调用）的形式传递，猜的数字以 <code>$^b</code> 的形式传递。没有赋值，只有参数的绑定，这就使得这个纯粹的功能。</p>
</div>
<div class="paragraph">
<p>真正的神奇之处在于对隐式变量 <code>&amp;?BLOCK</code> 的使用。Raku 有很多方法来进行反省（这可能不一定是件好事，但在这里很方便）。例如，代码块有一种自称方式：这个 <code>&amp;?BLOCK</code> 并不关心它在哪个块中。它永远是这个块，你可以用它来递归，就像我们在这里做的那样。另一种可能使用更多行的选择是用一个简短的名字来调用例程，并以名字来引用它。这同样可以增加一个逻辑新行，因为子声明和代码可能被认为是驻留在不同的行上。</p>
</div>
<div class="paragraph">
<p>所以，你自己选吧。逻辑上或物理上更短。无论哪种情况，Raku 都有办法让你做到。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_17_2_使用单行计算序列中的第n个元素">12.2. 食谱 17-2. 使用单行计算序列中的第n个元素。</h3>
<div class="sect3">
<h4 id="_问题_42">12.2.1. 问题</h4>
<div class="paragraph">
<p>你需要计算一个递归定义的序列的第n个元素，给定它的第一个元素和一个给定前面元素的通项来计算n。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解答">12.2.2. 解答</h4>
<div class="paragraph">
<p>这个很简单，因为序列可以在 Raku 中以"自然"的方式定义。序列中的位置可以从命令行中读取。然而，单行道需要进行测试和评估，所以我们将提出几种解决方案来实现这一点。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是如何工作的_46">12.2.3. 它是如何工作的</h4>
<div class="paragraph">
<p>Raku 中的序列使用了一个名为 Seq 的类，它可以容纳懒惰定义的和可能是无限的序列，但它的主要操作方式是使用 <code>&#8230;&#8203;</code>（省略号）。(省略号)运算符。这个运算符可以:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>根据它的第一项生成算术或几何级数。</p>
</li>
<li>
<p>根据它的首项定义一个序列，以及一个从前面的项计算出来的一般项。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们从一个简单的开始。计算一个数的阶乘 也就是这个数和前面所有数的乘积。例如，4的阶乘是 4x3x2x1=24。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say  [*] 1..( @*ARGS[0]
                // %*ENV&lt;NUMBER&gt;
                // die "Use $*PROGRAM &lt;num&gt; or NUMBER=&lt;num&gt; $*PROGRAM" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然为了便于阅读，这个解决方案显示为几行，但从逻辑上讲，它是一行。脚本的大部分内容是检查输入：它使用命令行或环境变量，如果它们都不存在，它就会以一条使用信息结束。<code>//</code> 是定义或操作符。如果有的话，它使用左边，如果没有的话，则使用右边。所以我们可以通过输入以下内容来运行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">./factorial.p6 225</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者在 Linux 或 OSX 命令行中写入以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">NUMBER=225 ./factorial.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有任何参数可用，它将产生这样的消息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Use /home/jmerelo/progs/perl6/raku-recipes-apress/Chapter-17/factorial.p6
&lt;num&gt; or NUMBER=&lt;num&gt; /home/jmerelo/progs/perl6/raku-recipes-apress/
Chapter-17/factorial.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序的路径取自 <code>$*PROGRAM</code> 动态变量。这是在一个"die"消息中产生一个立即退出（而不是一个额外的错误），这是典型的单行 hack。</p>
</div>
<div class="paragraph">
<p>无论这个数字是如何得到的，它都会被用来生成一个范围，并使用 <code>*</code> 操作符上的 <code>reduce</code> 元操作符将其所有元素相乘。结果是一个快速的程序，当然还有其他方法。比如这个。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN( Int $number = %*ENV&lt;NUMBER&gt;) { say  [*] 1..$number }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这与之前的做法正好相反。从物理上看是一行（甚至比上一行还短），但从逻辑上看至少是三行。我们使用签名的默认值机制来使用环境变量（如果有的话）。在这种情况下，没有值的错误将由子 <code>main</code> 本身产生，它可能会减少信息量，尽管它使程序在逻辑上更简单。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Type check failed in binding to parameter '$number'; expected Int but got
Any (Any)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这并不是一个真正的使用信息，而且它显然忽略了你可以使用环境变量的事实。另一方面，如果我们使用 <code>-help</code> 运行它，我们会得到一个有用的使用信息，如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Usage:
  factorial-v2.p6 [&lt;number&gt;]</code></pre>
</div>
</div>
<div class="paragraph">
<p>这表明了参数的名称和它是可选的事实（方括号内）。甚至还有第三种选择。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN( Int $number =%*ENV&lt;NUMBER&gt; ) { my $c = 1; say (1,* * $c++...∞) [$number-1] }</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用一个辅助变量来考虑操作所处位置的索引，<code>$c</code> 将包含该索引，并将其与前一个值相乘，生成一个序列，其中 <code>$c</code> 元素是阶乘。但我们这样做实际上是在生成一个无限的（但懒惰的）序列。我们不需要这样做，所以让我们尝试一个简单的循环，如下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN( Int $n =%*ENV&lt;NUMBER&gt; ) { my $ფ = 1; $ფ *= $_ for 1..^$n; $ფ.say;}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用的是格鲁吉亚字母 phar，因为它听起来像 factorial，也像一个戴着眼镜的小鼻子。我们对程序进行了高尔夫化处理，以占用最少的字符数，事实上，如果我们给环境变量起另一个名字，可以让它更短。但这里还有一个问题。在我们试过的所有程序中，哪一个是最快的？如果我们用命令行上的时间对10000的阶乘如何计算进行计时，结果会是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">time raku ./factorial-v4.p6 10000
0,80s user 0,06s system 106% cpu 0,806 total</code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上，这正好是我机器上最快的。前一个是最慢的，0.95秒。这是一个使用最简单的数据结构，以及 <code>for</code> 循环，反正是优化了不少。它还是使用了一个范围，但这并不慢，事实上第一个版本是第二快的；因为 <code>sub MAIN</code> 增加了一点开销，所以这个版本可能，事实上是相当快的。使用 <code>hyperfine</code> 命令工具对这四个版本进行基准测试的结果如图17-2所示。</p>
</div>
<div class="paragraph">
<p>图17-2.用 hyperfine 命令工具对这四个版本进行基准测试的结果。四个版本的基准测试，最后一个版本比第一个版本快了2%。</p>
</div>
<div class="paragraph">
<p>不过，做事要快，会让你的速度不快。所以我们需要测试，我们也需要测试这些独角戏。在我们最不愿意看到的时候，一切都充满了乐趣和欢声笑语，直到那个单行本崩溃。</p>
</div>
<div class="paragraph">
<p>幸运的是，我们可以在 Raku 中进行白盒测试；也就是说，我们可以用与其他函数或模块相同的方式在 Raku 中编写的脚本上运行测试。我们使用 Test::Script 模块来实现这一功能，该模块是由你们最近向生态系统发布的。让我们测试这四个模块，并检查它们是否有效地工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Test::Script;
use lib &lt;.&gt;;

for &lt;factorial factorial-v2 factorial-v3 factorial-v4&gt; -&gt; $f {
    my $filename = "Chapter-17/$f.p6";
    output-is($filename, "3628800\n",
       "Output well computed for 10",
       args =&gt; [10]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Test::Script 提供了一系列函数，其中一个是 <code>output-is</code>。它验证脚本的输出，也就是函数的第二个参数是否正确。脚本的参数通过名为 <code>argument</code> 的 <code>args</code> 给出，作为一个数组。在本例中，我们将尝试计算10的阶乘，也就是指定的数量。一切都好吗？嗯，不是的。上一个脚本是错误的。这里是正确的版本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN( Int $n =%*ENV&lt;NUMBER&gt; ) { my $ფ = 1; $ფ *= $_ for 1..$n; $ფ.say;}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我不会让你在这个版本和上个版本之间来回走动：<code>$n</code> 前面的 <code>^</code> 是排除了计算中要考虑的最后一个元素，结果比预期少了一个零。测试发现了这个错误，现在已经修复了。你明白了吗？测试很重要。</p>
</div>
<div class="paragraph">
<p>注意，我重新运行了基准，看看这个错误是否对总的性能有影响，并没有。</p>
</div>
<div class="paragraph">
<p>我们可以用一条线计算更复杂的序列。例如，我们可以计算尼伯利亚对数基数e的近似值；这是对阶乘的倒数相加，直到一个数。也就是说，我们计算出一系列数的阶乘，直到一个点，我们取它们的倒数，然后把它们相加。例如，如果这个数是3，那么三个阶乘就是1，2，6，它们的反数是1，1⁄2，1⁄6，加起来就是12⁄3。数字越大，精度越大。这个脚本就可以做到。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [+] (1,| [\*] (1...∞))[^@*ARGS[0]].map: 1/*</code></pre>
</div>
</div>
<div class="paragraph">
<p>其基础是所有因子的无限连续。<code>[*]</code> 是一个累加换算运算符。它把每一个元素乘以之前所有元素的结果, 但它没有把结果扔掉, 而是用所有元素创建一个系列. 它没有使用 0，因为 0 是一种特殊的情况，阶乘是 1，但它会破坏这个系列，所以我们把它放在前面，并使用滑移运算符 <code>|</code> 来整理整个系列。</p>
</div>
<div class="paragraph">
<p>这样的结果将是所有阶乘的无限序列。但我们只需要先用n来计算e的近似值，所以我们使用命令行中给出的参数将其切到我们想要的地方。然而，为了得到e，我们需要对该序列进行反演。对于1000个元素，我们将得到 2.718281828459045，对于更大的值，它几乎停留在那里。我们还能再往前走吗？嗯，<code>20!</code> 已经是一个相当大的数字了，而 <code>1/20!</code> 是非常小的。它超出了系统中表示浮点数字的能力，为什么要把这些周期都浪费掉呢？我们就把不能再改进的序列剪掉吧。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [+] (1,| [\*] (1...^max(@*ARGS[0],20))).map: 1.0/*</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们不定义一个无限的序列，从理论的角度来看是可以的，但不是很实用，我们在参数处切割数字序列，如果它小于20或者干脆就是20。和上面一样，但是无论如何我们都会更快的得到结果，因为 20 项就是我们要计算的全部内容。但是，如果我们得到的只是蹩脚的精度，而我们可以用一个简单得多的公式来实现，那么我们为什么要这样做呢？我们需要提高精度 而且，Raku，在这个意义上，又是有帮助的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [+] (1,| [\*] (1..@*ARGS[0])).map: { FatRat.new(1,$_) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们取消了数值的上限，我们不需要了。但这里的关键是使用 FatRat，或者任意精度的大有理数来计算每一个新项。当 Rats（或有理数）超过一定大小时，就会变成 Nums（或浮点数），从而受到精度限制，而 FatRats 则不会。对于 FatRats，我们可以一直计算项，直到累为止。对于1000个项，将如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">2.718281828459045235360287471352662497757247093699959574966967627724076630
[...41 lines here...]
2010249505518816948032210025154264946398128736776589276881635983125</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你需要的时候，Raku 会给你提供精度，但是只有 Ints 和 FatRats 这两个数据结构具有无限的精度，所以如果你需要到数字的第十六位，你需要在你的单行本（或其他任何程序）中包含其中一个。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_食谱_17_3_使用单行代码重复执行系统管理任务">12.3. 食谱 17-3. 使用单行代码重复执行系统管理任务</h3>
<div class="sect3">
<h4 id="_问题_43">12.3.1. 问题</h4>
<div class="paragraph">
<p>你需要不时地检查日志，或者创建一个警报，或者监控一些变量，如果可能的话，只需要一行代码。你需要以既定的频率重复这些检查。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解决办法_28">12.3.2. 解决办法</h4>
<div class="paragraph">
<p>使用 supply 来创建周期性任务；如果你想把它们放在一行中，这些任务应该很短。如果您需要使用外部模块来执行系统任务，您可以在命令行中使用 <code>-M</code> 来提供它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_如何工作_5">12.3.3. 如何工作</h4>
<div class="paragraph">
<p>系统交互并不容易，我们专门用了整整一章的篇幅来介绍，第二章。一般来说，你需要使用一个外部库来正确解析日志，或者使用正确的命令与操作系统 API 交互，这通常会在一个外部模块中。</p>
</div>
<div class="paragraph">
<p>例如，比如说你需要知道文件系统的演变，并确定它是如何被填充的。你可以使用不同的命令，Linux 和 OSX 中的 df 和 du，Windows 中可能还有其他种类的命令。如果你不想处理所有不同的情况，你可以使用一个模块，比如 FileSystem::Capacity，它使用这些工具来返回目录和卷的容量。
现在你需要定期做一些事情。同样，你可以使用操作系统的服务来做这件事。然而，这高度依赖于操作系统，并且需要额外的功能。如果可能的话，我们就用一个脚本来实现同样的功能。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，有几种方法可以实现这一壮举。可以对承诺进行定时，并且你可以在每履行一个承诺的情况下，推出另一个承诺。然而，最简单的实现方式是使用 supply。一个 supply 创建一个数据流；一个实时 supply 会永远产生值，或者直到它被停止。有许多方法可以创建这类 supply，但我们将使用 <code>.interval</code>，它每给定一个参数的秒数就会生成一个递增的整数流。<code>Supply.interval(2)</code> 将产生每两秒递增的数字。我们并不关心数字，而是关心每两秒处理一个东西，这就是我们在这个单行程序中要做的事情。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react whenever Supply.interval(@*ARGS[0]) {
    with volumes-info()&lt;/&gt; {
        say "Free M ", (.&lt;free&gt;/2**20).Int,
        "- Used ", .&lt;used%&gt;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样是167个字符，间距什么的都有。这一行确实很长，但它是一个逻辑句，包裹在几个控制结构中。外部的那个 <code>react</code>，每当收到一个消息，就会激活。它所反应的消息包含在一个when子句中，该子句检查（周期性）供应何时发出什么。我们并不真正关心数字(这将在 <code>$_</code> 变量中)，但我们关心我们的东西：<code>volumes-info</code> 将返回一个以所有卷为键的哈希和以它们为哈希的信息，<code>&lt;/&gt;</code> 将是根卷(在 Linux 中；这是操作系统特有的，在 Windows 中不起作用)。我们可以改变斜线的方向(从 <code>/</code> 到 <code>\</code>)来检测操作系统，但这会增加长度，如果你把它安装到不同的操作系统上，可能更容易改变它。</p>
</div>
<div class="paragraph">
<p>使用 <code>with</code> 有助于缩短脚本，因为它把它的值放在隐式变量中。<code>.&lt;free&gt;</code> 将从哈希中返回该值，同理，<code>.&lt;used%&gt;</code> 也是如此。我们将值转换为兆字节，因为默认情况下它是以字节为单位的（至少在 Ubuntu 中是这样）。</p>
</div>
<div class="paragraph">
<p>我们还使用参数来指定间隔，并通过 <code>@*ARGS</code> 来获取。然后我们可以这样运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku -M FileSystem::Capacity::VolumesInfo -e 'react whenever Supply.interval(@*ARGS[0]) { with volumes-info()&lt;/&gt; { say "FreeM ", (.&lt;free&gt; / 2** 20).Int, "- Used ", .&lt;used%&gt; } }' 15
FreeM 193112- Used 57%
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>我真的很想把这段代码放在一行上，所以我把它缩减了很多。这里是正常字体，分几行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku -M FileSystem::Capacity::VolumesInfo
    -e 'react whenever Supply.interval(@*ARGS[0]) {
        with volumes-info()&lt;/&gt; {
            say "FreeM ", (.&lt;free&gt; / 2 ** 20).Int, "- Used ", .&lt;used%&gt;
        }
    }' 15</code></pre>
</div>
</div>
<div class="paragraph">
<p>FileSystem::Capacity::VolumesInfo 模块包含 volumes-info，是 FileSystem::Capacity 发行版的一部分。在命令行中使用 <code>-M</code> 相当于我们放在脚本前面的使用语句。通过将它卸载到命令行中，我们在程序中保存了一条语句，使其保持为单行。</p>
</div>
<div class="paragraph">
<p>为了使它有用，你可能会想在启动时运行它，并将它的输出重定向到系统日志目录下的某个日志文件，例如 <code>/var/log</code>。但这是额外的事情。这里的单行脚本将完美地解决你的问题。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_术语">13. 术语</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 将许多新的概念引入编程领域，其中一些概念有自己的词汇来描述它们。本词汇表包括了一系列在本书（和 Raku 文档）中常用的词汇，以及在这里首次引入的其他词汇。</p>
</div>
<div class="sect2">
<h3 id="_dator">13.1. Dator</h3>
<div class="paragraph">
<p>数据访问器的简称，据我所知在本书中也有介绍。它是一个数据访问类，或者是同一个类的实例化对象，或者是描述这些类必须采用的（可能是抽象的）接口的角色。Dators 被注入到其他类中，以一种独立于实际使用的数据存储的方式访问数据存储。</p>
</div>
</div>
<div class="sect2">
<h3 id="_distrodistribution">13.2. Distro/Distribution</h3>
<div class="paragraph">
<p>一组功能相关的 Raku 模块、类和语法，它们一起被发布到生态系统中或在一个动作中安装。相当于经典的"库"概念，除了发行版可能包括二进制脚本和其他工件，如文档。</p>
</div>
</div>
<div class="sect2">
<h3 id="_grammarole">13.3. Grammarole</h3>
<div class="paragraph">
<p>同时在本书中也介绍了，它是一个定义部分语法的角色，它可以在语法中混用，虽然它本身可以，也可以通过双关语来作为语法使用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_hyperrace">13.4. Hyper/Race</h3>
<div class="paragraph">
<p>自动线程运算符，用于将应用到的数据结构分成不同的批次（批次大小由程序员控制），然后提交给不同的线程进行计算，从而将顺序操作转化为并发操作。虽然 hyper 会按照与原始数据结构相同的顺序返回结果，但 race 可能不会尊重这个顺序。</p>
</div>
</div>
<div class="sect2">
<h3 id="_punning">13.5. Punning</h3>
<div class="paragraph">
<p>创建一个新的角色实例，就像它是一个完整的类一样。</p>
</div>
</div>
<div class="sect2">
<h3 id="_rakuish">13.6. Rakuish</h3>
<div class="paragraph">
<p>神话般的品质，会让一个模式或语句比其他模式或语句更足以解决 Raku 中的问题。一般来说，没有这样的事情，因为在 Raku 中，有不止一种方法可以做，而且 Raku 是一种以开发者为中心的语言。然而，不同的编程模式会带来更快的代码或更干净的外观。选择一种而不是另一种，不是语言说了算，而是真的取决于你。这也指的是利用 Raku 的特性（特别是那些区别于其他语言的特性）来简洁地表达自己和解决问题。TMTOWTDI 也适用于术语的定义。</p>
</div>
</div>
<div class="sect2">
<h3 id="_rocket_operator">13.7. Rocket Operator</h3>
<div class="paragraph">
<p>在本书和 《Perl 6 快速语法参考》中都有使用。这是一个 "feed" 操作符，它将一个阶段的结果"发射"到下一个阶段。它是 <code>=&#8658;</code> 操作符，它从左边接收一个 list、sequence 或数组，从右边接收一个映射/过滤操作，结果是一个数组，而这个数组又可以反过来被送入下一个阶段。例如，<code>^3 =&#8658; map( *2)</code> 将计算0到2的平方。</p>
</div>
</div>
<div class="sect2">
<h3 id="_routingine">13.8. Routingine</h3>
<div class="paragraph">
<p>本书介绍的是路由例程，也就是 Cro 微服务中具有例程形式的路由块。</p>
</div>
</div>
<div class="sect2">
<h3 id="_token">13.9. Token</h3>
<div class="paragraph">
<p>一个标记，作为 grammar 的一部分使用，其表达式与方法的表达式类似，它使用正则表达式的语言来提取字符串的一部分。
与声明的 regex 的主要区别是 token 不回溯（因此速度更快），并且忽略空白；规则不忽略空白。token、regexes 和 rule 在 grammar 中都有使用，尽管在本书中我们几乎只使用 token。</p>
</div>
</div>
<div class="sect2">
<h3 id="_websocker">13.10. Websocker</h3>
<div class="paragraph">
<p>这里介绍一下，它是一个 websocket 服务器。换句话说，就是一个通过 websocket 响应消息的应用程序。</p>
</div>
</div>
</div>
</div>

</article>


    

  </main><section class="site__search">
    <label class="site__form">
        <p class="form__label">Search around the site</p> 
        <input class="site__search-bar form__input" type="text">
    </label>
    <div class="site__search-bar-results"></div>
</section>
  
  <footer class="site__footer">
    
    
    <p class="footer__sign">© 2020 ohmyraku</p></footer>
    

    
    <script>
        window.addEventListener("load", function () {
            const script = document.createElement("script");
            script.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
            script.async = true

            document.head.appendChild(script);
        })
    </script>





<script defer type="text/javascript" src="https://ohmyraku.github.io/js/script.14164ab553b19613ce98aadb54b1ed9a89ae5b056c72b99a4c672e37954f33d67bebe1452b0279025ba889964b51bdf8ec69683933cf427ae67c08ac2cdda7b1.js" integrity="sha512-FBZKtVOxlhPOmKrbVLHtmomuWwVscrmaTGcuN5VPM9Z76&#43;FFKwJ5AluoiZZLUb347GloOTPPQnrmfAisLN2nsQ=="></script>



</body>
</html>