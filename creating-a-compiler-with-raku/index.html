<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>用 Raku 写编译器 :: 山川异域, 风月同天</title>

<meta name="author" content="ohmyraku">
<meta name="application-name" content="山川异域, 风月同天">
<meta name="description" content="Table of Contents 1. 第一章 创建一个简单的解释器 1.1. Grammar 1.2. Actions 1.3. 模块   2. 第二章 解析数字 2.1. 查找数字 2.2. 获取值 2.3. 使用 AST 2.4. 最后的笔记   3. 第三章 创建计算器 3.1. 汇总 3.2. 过早的优化 3.3. 更多操作数 3.4. 多样性测试 3.5. 增加更多数学 3.6. 测试代码 3.7. 添加更多能量 3.8. 允许括号     1. 第一章 创建一个简单的解释器 这是使用 Raku 创建编译器的一章。
 让我们从一个简单的解释器程序开始研究 Raku 强大的 Grammar 和正则表达式，该程序可以解析并执行以下微型程序。 我将这种语言称为 Lingua。
 my x; x = 42; say x;   在理解此代码的含义时，您不会遇到任何问题，因为故意选择了类似于 Raku 本身的语法的语法，只是在变量名前没有任何符号。">
<meta name="robots" content="noodp"/>
<meta name="generator" content="Hugo 0.63.2" />
<meta name="referrer" content="no-referrer" />
<meta name="format-detection" content="telephone=no">

<link rel="canonical" href="https://ohmyraku.github.io/creating-a-compiler-with-raku/" />


<link rel="icon" href="https://ohmyraku.github.io/logo.png" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="用 Raku 写编译器" />
<meta name="twitter:description" content="Table of Contents 1. 第一章 创建一个简单的解释器 1.1. Grammar 1.2. Actions 1.3. 模块   2. 第二章 解析数字 2.1. 查找数字 2.2. 获取值 2.3. 使用 AST 2.4. 最后的笔记   3. 第三章 创建计算器 3.1. 汇总 3.2. 过早的优化 3.3. 更多操作数 3.4. 多样性测试 3.5. 增加更多数学 3.6. 测试代码 3.7. 添加更多能量 3.8. 允许括号     1. 第一章 创建一个简单的解释器 这是使用 Raku 创建编译器的一章。
 让我们从一个简单的解释器程序开始研究 Raku 强大的 Grammar 和正则表达式，该程序可以解析并执行以下微型程序。 我将这种语言称为 Lingua。
 my x; x = 42; say x;   在理解此代码的含义时，您不会遇到任何问题，因为故意选择了类似于 Raku 本身的语法的语法，只是在变量名前没有任何符号。" />
<meta name="twitter:site" content="https://ohmyraku.github.io" />
<meta name="twitter:creator" content="ohmyraku" />
<meta name="twitter:image" content="https://ohmyraku.github.io/logo.png">
<meta property="og:type" content="article" />
<meta property="og:locale" content="en" />
<meta property="og:name" content="ohmyraku" />
<meta property="og:title" content="用 Raku 写编译器" />
<meta property="og:url" content="https://ohmyraku.github.io" />
<meta property="og:site_name" content="山川异域, 风月同天" />
<meta property="og:description" content="Table of Contents 1. 第一章 创建一个简单的解释器 1.1. Grammar 1.2. Actions 1.3. 模块   2. 第二章 解析数字 2.1. 查找数字 2.2. 获取值 2.3. 使用 AST 2.4. 最后的笔记   3. 第三章 创建计算器 3.1. 汇总 3.2. 过早的优化 3.3. 更多操作数 3.4. 多样性测试 3.5. 增加更多数学 3.6. 测试代码 3.7. 添加更多能量 3.8. 允许括号     1. 第一章 创建一个简单的解释器 这是使用 Raku 创建编译器的一章。
 让我们从一个简单的解释器程序开始研究 Raku 强大的 Grammar 和正则表达式，该程序可以解析并执行以下微型程序。 我将这种语言称为 Lingua。
 my x; x = 42; say x;   在理解此代码的含义时，您不会遇到任何问题，因为故意选择了类似于 Raku 本身的语法的语法，只是在变量名前没有任何符号。" />
<script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "Article",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https:\/\/ohmyraku.github.io\/creating-a-compiler-with-raku\/"
      },
      "headline": "用 Raku 写编译器",
      
      "datePublished": "2020-02-24",
      "dateModified": "2020-02-24 12:54:52 \x2b0800 CST",
      "author": {
        "@type": "Person",
        "name": "ohmyraku"
      },
      "description": "Table of Contents 1. 第一章 创建一个简单的解释器 1.1. Grammar 1.2. Actions 1.3. 模块   2. 第二章 解析数字 2.1. 查找数字 2.2. 获取值 2.3. 使用 AST 2.4. 最后的笔记   3. 第三章 创建计算器 3.1. 汇总 3.2. 过早的优化 3.3. 更多操作数 3.4. 多样性测试 3.5. 增加更多数学 3.6. 测试代码 3.7. 添加更多能量 3.8. 允许括号     1. 第一章 创建一个简单的解释器 这是使用 Raku 创建编译器的一章。\n 让我们从一个简单的解释器程序开始研究 Raku 强大的 Grammar 和正则表达式，该程序可以解析并执行以下微型程序。 我将这种语言称为 Lingua。\n my x; x = 42; say x;   在理解此代码的含义时，您不会遇到任何问题，因为故意选择了类似于 Raku 本身的语法的语法，只是在变量名前没有任何符号。",
      "publisher": {
        "@type": "Organization",
        "name": "https:\/\/ohmyraku.github.io",
        "logo": {
          "@type": "ImageObject",
          "url": "https:\/\/ohmyraku.github.io\/logo.png"
        }
      }
    }
</script><link rel="stylesheet" href="https://ohmyraku.github.io/scss/main.min.84f71d25d375c522a861bb4719728ce6839cf3635b15ca0c7a1b4d799c2dc3399a1d6cb46058a9d8fdbebe9156a8857279cfdeb70aa3862e629de234b5a41fa1.css" integrity="sha512-hPcdJdN1xSKoYbtHGXKM5oOc82NbFcoMehtNeZwtwzmaHWy0YFip2P2&#43;vpFWqIVyec/etwqjhi5ineI0taQfoQ==">
<script>

const theme = window.localStorage.getItem('theme'); 
if (theme && theme !== "1") {
    document.documentElement.classList.add('theme-' + theme);
}
</script>


</head>
<body>
  <main class="site__content">
    <div class="site__page">
  <nav class="site__breadcrumbs">
    <a class="site__breadcrumb" href="https://ohmyraku.github.io/">山川异域, 风月同天</a><a class="site__breadcrumb--active" href="https://ohmyraku.github.io/creating-a-compiler-with-raku/">用 Raku 写编译器</a>
</nav>

<h1 class="page__title">用 Raku 写编译器</h1>
  <div class="page__meta">
    <p>
    
    <span class="page__date">
    on <time datetime="2020-02-24T12:54:52&#43;08:00">2020-02-24</time>
    
    </span>
    </p>

    

    
    </div>
</div>


</div>

<article class="page__content" ><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_第一章_创建一个简单的解释器">1. 第一章 创建一个简单的解释器</a>
<ul class="sectlevel2">
<li><a href="#_grammar">1.1. Grammar</a></li>
<li><a href="#_actions">1.2. Actions</a></li>
<li><a href="#_模块">1.3. 模块</a></li>
</ul>
</li>
<li><a href="#_第二章_解析数字">2. 第二章 解析数字</a>
<ul class="sectlevel2">
<li><a href="#_查找数字">2.1. 查找数字</a></li>
<li><a href="#_获取值">2.2. 获取值</a></li>
<li><a href="#_使用_ast">2.3. 使用 AST</a></li>
<li><a href="#_最后的笔记">2.4. 最后的笔记</a></li>
</ul>
</li>
<li><a href="#_第三章_创建计算器">3. 第三章 创建计算器</a>
<ul class="sectlevel2">
<li><a href="#_汇总">3.1. 汇总</a></li>
<li><a href="#_过早的优化">3.2. 过早的优化</a></li>
<li><a href="#_更多操作数">3.3. 更多操作数</a></li>
<li><a href="#_多样性测试">3.4. 多样性测试</a></li>
<li><a href="#_增加更多数学">3.5. 增加更多数学</a></li>
<li><a href="#_测试代码">3.6. 测试代码</a></li>
<li><a href="#_添加更多能量">3.7. 添加更多能量</a></li>
<li><a href="#_允许括号">3.8. 允许括号</a></li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_第一章_创建一个简单的解释器">1. 第一章 创建一个简单的解释器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这是<a href="https://andrewshitov.com/creating-a-compiler-with-raku/">使用 Raku 创建编译器</a>的一章。</p>
</div>
<div class="paragraph">
<p>让我们从一个简单的解释器程序开始研究 Raku 强大的 Grammar 和正则表达式，该程序可以解析并执行以下微型程序。 我将这种语言称为 Lingua。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my x;
x = 42;
say x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在理解此代码的含义时，您不会遇到任何问题，因为故意选择了类似于 Raku 本身的语法的语法，只是在变量名前没有任何符号。</p>
</div>
<div class="paragraph">
<p>该程序声明一个名为 <code>x</code> 的变量，为其赋一个整数值，然后将该值输出到控制台。</p>
</div>
<div class="paragraph">
<p>假设您将代码保存在文件 <code>test.lng</code> 中。 现在让我们使用 Raku 读取它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $code = 'test.lng'.IO.slurp();
say $code;</code></pre>
</div>
</div>
<div class="paragraph">
<p>将此 Raku 程序保存在另一个文件 <code>lingua.raku</code> 中，然后运行它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku lingua.raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您安装了 Raku，则会打印出我们测试程序的内容。</p>
</div>
<div class="sect2">
<h3 id="_grammar">1.1. Grammar</h3>
<div class="paragraph">
<p>现在是时候使用 Raku grammar 解析程序了。 从语法上讲，grammar 是类，但是它们使用正则表达式描述其方法的行为，这些方法又称为 <strong>rule</strong> 和 <strong>token</strong>。 第一个应用的 <strong>rule</strong> 通常称为 <code>TOP</code>; Raku 选择它为默认开始规则。 语法用于解析某些文本，因此只需对已定义的语法调用 <code>parse</code> 方法并将文本传递给它即可。 所有这些都在我们的第一个程序中得到了证明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Lingua {
    rule TOP {
        .*
    }
}

my $code = 'test.lng'.IO.slurp();
my $result = Lingua.parse($code);
say $result;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，定义了语法 Lingua。 它会描述我们的目标语言，目前只有一条规则，这是应用于 <code>$code</code> 中包含的 Lingua 代码的第一个和最后一个规则。</p>
</div>
<div class="paragraph">
<p>TOP 规则的主体是与任意行匹配的正则表达式：点与任何字符都匹配，并且星号允许重复任意数量。 TOP 方法以静默方式将正则表达式锚定在字符串的开头和结尾，因此它实际上等效于 <code>^.*$</code>。</p>
</div>
<div class="paragraph">
<p>再次运行 lingua.raku，您会看到解析器设法读取了整个程序。 这是控制台中打印的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">｢my x;
x = 42;
say x;
｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些方括号表明这不是已打印的常规字符串。 在我们的例子中，<code>$result</code> 变量包含一个 Lingua 类的对象。</p>
</div>
<div class="paragraph">
<p>从 Lingua 程序中可以看到，其语句用分号分隔。 为了准确起见，您必须确定语句是用分号分隔还是应该以分号结尾。 区别在于，在第一种情况下，您不必在最后一条语句之后（例如，在程序末尾）加上分号。 Raku 语法允许实现这两种选择。</p>
</div>
<div class="paragraph">
<p>因此，该程序由许多用分号分隔的语句组成。 在 Raku 语法中，您可以通过以下方式表达这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    &lt;statement&gt;* %% ';'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，使用另一个实体语句描述 TOP 规则。 可以重复多次（包括不重复），并且如果有多个语句，则必须用 ';' 分隔。 字符。 如果您更改定义并输入 <code>%</code> 而不是 <code>%%</code>，则该规则将要求在每个语句之后使用分号。</p>
</div>
<div class="paragraph">
<p>语句本身是另一条规则，我们首先可以定义它是非常模糊的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule statement {
    &lt;-[;]&gt;*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它匹配除分号字符外的所有内容。 空语句也通过此过滤器。</p>
</div>
<div class="paragraph">
<p>通过此更改，解释器现在将拆分语句并发出以下输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢my x;
x = 42;
say x;
｣
 statement =&gt; ｢my x｣
 statement =&gt; ｢x = 42｣
 statement =&gt; ｢say x｣
 statement =&gt; ｢｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个块显示输入程序的整个文本（所有文本均已匹配并被使用），然后显示四个单独的语句。 最后一个语句为空，因为原始文件在最后一个非空字符之后包含换行符，并且语句规则允许空语句。</p>
</div>
<div class="paragraph">
<p>我们的代码中有三种不同类型的语句。 它们是变量声明，赋值和调用内置函数。 可以很容易地用语法表示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule statement {
    | &lt;variable-declaration&gt;
    | &lt;assignment&gt;
    | &lt;function-call&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>竖线界定规则的替代分支。 形式上，只需列出两个选项条即可列出三个选项，但是为了使代码美观，您可以再添加一个选项条，以使它们在代码轮廓中形成一条较长的垂直线。 如果这样做，则语法不会添加空匹配项作为第一种选择。 顺便说一句，Raku 的另一个优点是它允许在变量和方法的名称中使用连字符，并且我更喜欢 variable-declaration 而不是 variable_declaration。</p>
</div>
<div class="paragraph">
<p>查看驻留在 test.lng 中的测试程序，我们可以为语法定义新规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule variable-declaration {
    'my' &lt;variable-name&gt;
}

rule assignment {
    &lt;variable-name&gt; '=' &lt;value&gt;
}

rule function-call {
    &lt;function-name&gt; &lt;variable-name&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>带引号的字符串（例如"my"和"="）将文学与目标语言中的相应语法项进行匹配。 尖括号中的名称是对我们需要定义以完成语法的其他规则或标记的引用。 这是我们的第一个标记：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token variable-name {
    \w+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它与可以组成一个单词的一系列字符匹配（因此，至少包括字母，数字和下划线）。 另请注意，变量名称中至少应包含一个字符。</p>
</div>
<div class="paragraph">
<p><strong>rule</strong> 和 <strong>token</strong> 之间的主要区别是 Raku 处理空白的方式。 例如，看一下变量声明 <strong>rule</strong> 的主体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'my' &lt;variable-name&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它使以下两个文本均合法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my x
my    x</code></pre>
</div>
</div>
<div class="paragraph">
<p>您要创建令牌而不是规则，只能匹配 myx。 如您所见，语法中的标记非常适合诸如变量名或关键字之类的终端。</p>
</div>
<div class="paragraph">
<p>这是 <strong>token</strong> 的另一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token value {
    \d+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第一种方法中，我们仅将可能的值限制为非负整数。 稍后，我们将扩展令牌以包括其他类型的数字。</p>
</div>
<div class="paragraph">
<p>最后，是函数名称的标记。 到目前为止，只有一个内置函数，因此规则（在这种情况下可以是令牌）很简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule function-name {
    'say'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而已。 运行程序，如果找到了，这里是什么（让我省略重复该程序整个文本的输出的第一部分）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">statement =&gt; ｢my x｣
  variable-declaration =&gt; ｢my x｣
   variable-name =&gt; ｢x｣
 statement =&gt; ｢x = 42｣
  assignment =&gt; ｢x = 42｣
   variable-name =&gt; ｢x｣
   value =&gt; ｢42｣
 statement =&gt; ｢say x｣
  function-call =&gt; ｢say x｣
   function-name =&gt; ｢say ｣
   variable-name =&gt; ｢x｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出反映语法理解的解析程序的结构。 缩进有助于查看程序及其元素的嵌套结构。 每行的右侧显示了源代码的匹配部分。</p>
</div>
<div class="paragraph">
<p>例如，程序的第一行my x;是一条语句，其中包含变量声明 <code>my x</code> 和变量名称 <code>x</code>。 分号被 TOP 规则的分隔符所消耗，并且没有进入输出树。 类似地，第二条语句 <code>x = 42</code>，是将值 42 分配给变量名 <code>x</code>。</p>
</div>
<div class="paragraph">
<p>如果检查为第三行生成的输出，例如 <code>x</code> ;，您会看到函数名称在函数名称之后包含一个多余的空格：｢say｣。 通过使规则成为令牌可以轻松解决此问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token function-name {
    'say'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>进行此更改后，结果将更加清晰：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">statement =&gt; ｢say x｣
  function-call =&gt; ｢say x｣
   function-name =&gt; ｢say｣
   variable-name =&gt; ｢x｣</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_actions">1.2. Actions</h3>
<div class="paragraph">
<p>目标文件现已完全解析。 我们可以将其拆分为单独的语句，并且可以理解其中的所有部分。 唯一缺少的元素是使所有这些部分协同工作以产生结果。 这就是 Raku 中的动作。</p>
</div>
<div class="paragraph">
<p>返回Lingua的测试程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my x;
x = 42;
say x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要在控制台中看到 42，我们必须确保有一个存储该值的地方，并且可以通过其名称 x 进行引用。 换句话说，我们需要一个存储空间。 最明显的选择是使用哈希。 首先让我们将其设为全局变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %var;

grammar Lingua {
    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>成功匹配规则或令牌后，您可以要求 Raku 为您做点事情，即，您可以添加一个代码块（称为 action），该代码块将在匹配后执行。 在其中，您可以访问刚刚提取的数据。</p>
</div>
<div class="paragraph">
<p>我们的第一个动作是在看到变量声明时创建一个变量。 这是您的操作方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule variable-declaration {
    'my' &lt;variable-name&gt; {
        %var{$&lt;variable-name&gt;} = 0;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将动作放在一对大括号中的正则表达式之后。 我们知道，该规则通过匹配文字 "my"和变量名来找到子字符串 <code>my x</code>，变量名是命名令牌变量名。 我们可以使用该名称访问内容：<code>$&lt;variable-name&gt;</code>。 实际上，这是 Lingua 类的对象，但是我们将其用作哈希的键，因此将其转换为字符串，并使用新的对 x &#8658; 0 填充哈希。因此， 创建并用零初始化。</p>
</div>
<div class="paragraph">
<p>同样，让我们为变量分配创建一个动作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule assignment {
    &lt;variable-name&gt; '=' &lt;value&gt; {
        %var{~$&lt;variable-name&gt;} = +$&lt;value&gt;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，为了说明您也可以做到这一点，将 <code>$&lt;variable-name&gt;</code> 对象通过 <code>~</code> 前缀运算符显式转换为 Str 数据类型的值。 在等号的右侧，完成了另一种类型转换：+运算符将 <code>$&lt;value&gt;</code> 转换为数字。 这次，强制转换值非常重要，因为如果您不这样做，将保存一个 Lingua 对象而不是数字。</p>
</div>
<div class="paragraph">
<p>现在转到函数调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule function-call {
    &lt;function-name&gt; &lt;variable-name&gt; {
        say %var{$&lt;variable-name&gt;}
            if $&lt;function-name&gt; eq 'say';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>say</code> 函数的实现嵌入在语法操作中。 由于我们现在只有一个内置函数，因此实际上不需要 <code>if</code> 子句，但是让我们保留它可以使代码更透明。</p>
</div>
<div class="paragraph">
<p>到目前为止，这是如何完成的，这三个操作块是内联的。 它们是规则定义的一部分。 我们可以运行解释器并查看其作用。 将主代码更改为以下代码，以避免大量输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $code = 'test.lng'.IO.slurp();
my $result = Lingua.parse($code);
#say $result;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码打印出如下行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku lingua.raku
42</code></pre>
</div>
</div>
<div class="paragraph">
<p>恭喜你！ 该程序不仅被解析而且还被执行。 如您所见，它打印了变量 x 的内容，这正是我们放入变量 x 中的内容。 如果您转储 <code>%var</code> 容器（通过添加 <code>%var;</code>），则会得到 <code>{x &#8658; 42}</code>。</p>
</div>
<div class="paragraph">
<p>这是我们的第一个真正的成就。 我们设法为将来的林瓜语言的子集创建了一个口译员。 这里最令人兴奋的部分是它没有绑定到我们之前使用的单个测试程序。 您可以根据需要创建任意多个变量，可以将其分配给不同的值，然后再次重新分配它们。 变量的名称可以长于单个字母。 所有这些神奇地起作用！ 自己尝试一下，这是我所做的一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">my alpha;
my beta;
alpha = 100;
beta = 200;

say alpha;
say beta;

my gamma;
gamma = 33;
say gamma;

gamma = 44;
say gamma;</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行后，程序将打印正确的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">100
200
33
44</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以尝试多次分配值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my value;

value = 100;
say value;

value = 200;
say value;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这次，该程序两次使用相同的变量并在其中存储了不同的值，您可以通过运行该程序轻松确认：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">100
200</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_模块">1.3. 模块</h3>
<div class="paragraph">
<p>第一个简单的解释器已经准备就绪，但让我们花更多的时间使它的代码更结构化和更快。</p>
</div>
<div class="paragraph">
<p>首先，可以将内联操作收集在单独的类中。 在我们当前的实现中，所有动作都是单行的，但是在更高级的编译器中，情况并非如此。 在 Raku 中，表达动作和语法规则之间的关系非常容易：在创建动作类的方法时，只需使用相同的名称即可。 查看以下代码，您将立即理解。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class LinguaActions {
    method variable-declaration($/) {
        %var{$&lt;variable-name&gt;} = 0;
    }

    method assignment($/) {
        %var{~$&lt;variable-name&gt;} = +$&lt;value&gt;;
    }

    method function-call($/) {
        say %var{$&lt;variable-name&gt;}
            if $&lt;function-name&gt; eq 'say';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有这些方法都采用一个参数。 它的名称可以是您想要的任何名称，但为方便起见，最好将其命名为 <code>$/</code>，因为在这种情况下，可以使用 <code>$&lt;value&gt;</code> 之类的快捷方式代替 <code>$/&lt;value&gt;</code>。 如果您将其命名为 <code>$arg</code>，则必须输入更多字符才能访问其部分：<code>$arg&lt;value&gt;</code>。 另外，别忘了从语法类中删除代码块及其周围的花括号。</p>
</div>
<div class="paragraph">
<p>要将action类与语法一起使用，请将其作为命名参数传递给 <code>parse</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Lingua.parse($code, :actions(LinguaActions));</code></pre>
</div>
</div>
<div class="paragraph">
<p>提取类并将它们保存在单独的文件中也是一种好习惯。 例如，语法进入 Lingua.raku，动作（连同 <code>%var</code> 哈希，目前是模块的全局变量）一起进入 LinguaActions.raku。 整个解释器代码将缩短为以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Lingua;
use LinguaActions;

my $code = 'test.lng'.IO.slurp();
Lingua.parse($code, :actions(LinguaActions));</code></pre>
</div>
</div>
<div class="paragraph">
<p>此步骤不仅有助于逻辑上组织代码，而且可以提高解释速度。 如果 Raku 编译器能够缓存已编译的模块，则只需要编译一次即可。 每次下一次运行都更快，因为使用了模块的预编译版本。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二章_解析数字">2. 第二章 解析数字</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在接下来的两章中，我们将暂时保留上一章中创建的编译器，并将使用一个单独的帮助程序，即计算器。 它本身是一件有趣的事情，我们将在一个孤立的示例中对其进行探索。 在下一章中，它将集成到解释器中。</p>
</div>
<div class="sect2">
<h3 id="_查找数字">2.1. 查找数字</h3>
<div class="paragraph">
<p>计算器可以处理数字，因此我们要做的第一件事就是做一个用于解析数字的解析器。 在上一章中，我们仅使用非负整数，但是好的计算器必须理解更多的数字格式。 例如，它包括负数和浮点数，也可以用科学计数法表示。 我们还必须允许人们省略小数点前面的零并输入 <code>.5</code> 而不是 <code>0.5</code> 的情况。</p>
</div>
<div class="paragraph">
<p>让我们为不同类型的数字迭代创建解析器。 由于我们将对 grammar 进行大量更改，因此提供了一个测试套件来进行救援。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @cases = 7, 77, -84;
for @cases -&gt; $number {
    say "Test $number";
    say Number.parse($number);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@cases</code> 数组包含将针对 <code>Number</code> grammar 进行测试的数字列表。 这是它的第一个版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Number {
    rule TOP {
        &lt;number&gt;
    }

    token number {
        \d+
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>整个 grammar 需要一个数字，即一个数字序列。 它可以与我们当前的测试用例一起使用，并且程序的输出是可以预测的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Test 7
｢7｣
 number =&gt; ｢7｣
Test 77
｢77｣
 number =&gt; ｢77｣
Test -84
Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>前两个数字通过了测试，但第三个没有通过。 对于负数，<code>parse</code> 方法返回 <code>Nil</code>。</p>
</div>
<div class="paragraph">
<p>因此，我们需要扩展 <code>number</code> 标记并在数字前面添加可选的减号。 重要的是，它仍然必须是 token，因为您通常不希望符号和数字之间有空格。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    '-'? \d+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个很小的变化使另一半整数（负整数）有效。 以上测试现在将通过。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Test -84
｢-84｣
 number =&gt; ｢-84｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果您将正数拼写为 <code>+7</code> 会怎么样?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @cases = 7, 77, -84, '+7', 0;</code></pre>
</div>
</div>
<div class="paragraph">
<p>(Grammar 分析器始终使用字符串，但是我们可以让 Raku 转换正数，以避免在测试用例列表中加引号。)</p>
</div>
<div class="paragraph">
<p>根据 grammar，此数字不是有效数字。 因为它期望整个字符串是一个数字，所以我们不能期望加号会被简单地忽略。 解析器需要在开始时就知道可能的符号，因此，我们需要将其添加到 token 主体中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;[+-]&gt;? \d+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们也减少输出中的噪声，并且不打印解析树：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @cases -&gt; $number {
    my $test = Number.parse($number);
    say ($test ?? 'OK ' !! 'NOT OK ') ~ $number;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，输出与在测试 Perl 和 Raku 模块中广泛使用的 TAP（任何测试协议）部分兼容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OK 7
OK 77
OK -84
OK +7
OK 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>添加一个无效的数字，您会立即看到它失败，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">NOT OK 3.14</code></pre>
</div>
</div>
<div class="paragraph">
<p>实现流点号解析器的第一次尝试可以像这样简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;[+-]&gt;? \d+ ['.' \d+]?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们只是添加了一个可选的小数部分。 但是，如果遇到一个有点但没有整数部分的数字怎么办？ 它不会通过测试，但是可以通过将正则表达式左侧的 <code>\d+</code> 更改为 <code>\d*</code> 来轻松解决：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;[+-]&gt;? \d* ['.' \d+]?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>不幸的是，此更改破坏了令牌，因为它可以应用于单个符号，甚至可以应用于空字符串。 现在所有这些测试用例都可以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @cases =
    7, 77, -84, '+7', 0,
    3.14, -2.78, 5.0, '.5',
    '', '-', '+';</code></pre>
</div>
</div>
<div class="paragraph">
<p>尝试在单个正则表达式中表达所有选项有点棘手。 显式列出所有备选方案要容易得多。 我们知道符号可以出现在任何数字的前面，让我们将备选方案放在方括号中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;[+-]&gt;? [
        | \d+
        | \d* ['.' \d+]
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种方法使整个令牌更具可读性和可扩展性。 我们可以添加另一种选择来匹配科学计数法中的数字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;[+-]&gt;? [
        | \d+
        | \d* ['.' \d+]
        | \d+ &lt;[eE]&gt; &lt;[+-]&gt;? \d+
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在有更多测试用例通过了 Grammar：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'3E4', '-33E55', '3E-3', '-1E-2'</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们所缺少的是科学计数法中带有非整数尾数的数字，例如3.14E2或.5E-3。 另一种选择可以解决此问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;[+-]&gt;? [
        | \d+
        | \d* ['.' \d+]
        | \d+ &lt;[eE]&gt; &lt;[+-]&gt;? \d+
       | \d* ['.' \d+] &lt;[eE]&gt; &lt;[+-]&gt;? \d+
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种形式中，有些部分会重复，例如\ d +或\ d * ['。 \ d +]。 在这种紧凑的规则中可能会很好，但是也可以对其进行进一步分解，并引入负责此类重复部分的子令牌。 转换后的数字令牌及其家族如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;sign&gt;? [
        | &lt;integer&gt;
        | &lt;floating-point&gt;
        | &lt;integer&gt; &lt;exponent&gt;
        | &lt;floating-point&gt; &lt;exponent&gt;
    ]
}

token sign {
    &lt;[+-]&gt;
}

token exp {
    &lt;[eE]&gt;
}

token integer {
    \d+
}

token floating-point {
    \d* ['.' &lt;integer&gt;]
}

token exponent {
    &lt;exp&gt; &lt;sign&gt;? &lt;integer&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管与以前的版本相比有更多的代码，但每个单独的令牌都更易于理解。 例如，比较科学记数形式的数字的先前和当前正则表达式，其尾数具有浮点数。 之前是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">\d* ['.' \d+] &lt;[eE]&gt; &lt;[+-]&gt;? \d+</code></pre>
</div>
</div>
<div class="paragraph">
<p>转换后，它变成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;floating-point&gt; &lt;exponent&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>看一下主要代币的替代方案，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">| &lt;integer&gt;
| &lt;floating-point&gt;
| &lt;integer&gt; &lt;exponent&gt;
| &lt;floating-point&gt; &lt;exponent&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您会立即看到他们的描述。 甚至，我们可以进一步减少它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;sign&gt;? [
        | &lt;integer&gt;
        | &lt;floating-point&gt;
    ] &lt;exponent&gt;?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>换句话说，数字可以是整数，也可以是浮点值，其后跟一个可选的符号，然后可以跟一个可选的指数部分。 以这种形式，描述是如此简洁和紧凑。 所有细节（正则表达式“噪声”）都隐藏在辅助标记中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_获取值">2.2. 获取值</h3>
<div class="paragraph">
<p>该数字已解析，但是它的值是多少？ 对于编译器，我们不仅需要检查数字格式的有效性，还需要将其从字符串转换为数字，整数或浮点数。 在本节中，我们将在数字语法后面添加操作，以便我们可以构建数字并最终打印出来。</p>
</div>
<div class="paragraph">
<p>让我们以整数开头，并将数字保留在全局变量中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = 0;
class NumberActions {
    method integer($/) {
        $n = +$/;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的一切看起来都很简单。 通过使用+前缀运算符将字符串的匹配部分转换为数字值，可以直接得出整数值。 要查看其工作原理，让我们更改主测试循环，以使其输出已解析的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @cases -&gt; $number {
    my $test = Number.parse($number, :actions(NumberActions));

    if ($test) {
        say "OK $number = $n";
    }
    else {
        say "NOT OK $number";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用非负整数，效果很好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OK 7 = 7
OK 77 = 77
OK -84 = 84
OK +7 = 7
OK 0 = 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>负数无效。 看来+7字符串已正确处理，但实际上这并不完全正确，因为我们完全忽略了该符号。 这次，任务有点复杂。 第一个想法是，如果遇到减号，则翻转符号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method sign($/) {
    $n *= -1 if ~$/ eq '-';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这是行不通的，因为符号是在解析数字之前先解析的，而否定$ n意味着将符号应用于零。 我们可以使用一个单独的变量来保留有关标志的信息，但这并不是最好的选择。 但是，请这样做，因为这将揭示另一个问题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = 0;
my $sign = 1;

class NumberActions {
    method integer($/) {
        $n = $sign * +$/;
    }

    method sign($/) {
        $sign = -1 if ~$/ eq '-';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这有助于检测第一个负数，但会破坏所有其他负数。 当然，您可以检查符号是否为'+'，但问题是$ n和$ sign变量是全局变量，必须在解析下一个变量之前将其重置。 这是将它们移至动作类的好时机。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class NumberActions {
    has $.n = 0;
    has $!sign = 1;

    method integer($/) {
        $!n = $!sign * +$/;
    }

    method sign($/) {
        $!sign = -1 if ~$/ eq '-';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>$ n变量有意成为公共数据成员，因为我们必须以某种方式获得结果。 您还需要更改测试循环。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @cases -&gt; $number {
    my $actions = NumberActions.new();
    my $test = Number.parse($number, :actions($actions));

    if ($test) {
        say "OK $number = " ~ $actions.n;
    }
    else {
        say "NOT OK $number";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此处的主要更改是将NumberActions类的实例传递给语法的parse方法。 现在，在每次迭代中，解析器都会创建自己的变量以保留结果。</p>
</div>
<div class="paragraph">
<p>我们已经走了足够远的距离，以至于可以正确解析所有整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OK 7 = 7
OK 77 = 77
OK -84 = -84
OK +7 = 7
OK 0 = 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于浮点数，它的工作不那么顺畅：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OK 3.14 = 14
OK -2.78 = -78
OK 5.0 = 0
OK .5 = 5
OK -5.3 = -3
OK -.3 = -3
OK 3E4 = 4
OK -33E55 = -55
OK 3E-3 = -3
OK 3.14E2 = 2
OK .5E-3 = -3</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，小数部分或指数部分均获胜。 在两种情况下，这都是语法的最后一个整数部分。 确实，早些时候，我们对语法进行了转换，以排除重复部分。 当我们不得不引入$ sign变量时，钟声响了，但现在我们遭受的痛苦更大。 所有这些都需要以不同的方式处理。 这就是AST可以提供帮助的方式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_ast">2.3. 使用 AST</h3>
<div class="paragraph">
<p>AST，或抽象语法树，是一种允许在不同阶段收集和保持数据解析的机制。 如果在读取浮点数3.14时两次调用了整数令牌，或者对具有指数的数字（例如3.14E2）调用了三次，则所有这些整数都可以保留在AST中，并在以后用于构建整数。 对应于整个字符串的值。</p>
</div>
<div class="paragraph">
<p>在操作类的方法内，$ /变量有两种方法：make和made。 使用make可以存储一个值（将属性分配给解析树的当前节点）。 使用made时，您将读取先前存储的值。</p>
</div>
<div class="paragraph">
<p>将以下调用添加到令牌操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method integer($/) {
    $/.make(+$/);
}

method sign($/) {
    $/.make(~$/ eq '-' ?? -1 !! 1);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，即使多次调用该方法，也将保存这些值。 要了解它是如何工作的，让我们看一下语法对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $test = Number.parse($number, :actions($actions));
dd $test;</code></pre>
</div>
</div>
<div class="paragraph">
<p>dd例程是Rakudo专用的工具，可显示对象的内部结构。 对于输入数字-84，解析后将构建以下对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Number $test = Match.new(list =&gt; (), hash =&gt; Map.new((:number(Match.new(list =&gt; (), hash =&gt; Map.new((:integer(Match.new(list =&gt; (), hash =&gt; Map.new(()), made =&gt; 84, orig =&gt; -84, pos =&gt; 3, from =&gt; 1)),:sign(Match.new(list =&gt; (), hash =&gt; Map.new(()), made =&gt; -1, orig =&gt; -84, pos =&gt; 1, from =&gt; 0)))), made =&gt; Any, orig =&gt; -84, pos =&gt; 3, from =&gt; 0)))), made =&gt; Any, orig =&gt; -84, pos =&gt; 3, from =&gt; 0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>看起来很凌乱，但您应该可以发现我们最感兴趣的两个地方：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">made =&gt; 84, orig =&gt; -84, pos =&gt; 3, from =&gt; 1
made =&gt; -1, orig =&gt; -84, pos =&gt; 1, from =&gt; 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>将from和pos键设置为指向第一个字符以及与正则表达式匹配的最后一个字符之后的字符。 因此，这两个子哈希中的第一个是解析数字的结果（字符串“ -84”中从位置1到位置3，即84）。 第二个哈希对应减号字符（同一字符串中的位置0到1）。</p>
</div>
<div class="paragraph">
<p>made属性分别设置为84和-1，这确认语法能够正确解析数字及其符号。</p>
</div>
<div class="paragraph">
<p>现在可以使用这些值在父标记中生成结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method number($/) {
    my $n = $&lt;integer&gt;.made;
    $n *= $&lt;sign&gt;.made if $&lt;sign&gt;;
    $/.make($n);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它通过$ &lt;integer&gt;和$ &lt;sign&gt;对象的made属性访问整数值和符号乘数。 最后一行将结果传递到下一个级别，您可以从TOP规则中访问它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method TOP($/) {
    $/.make($&lt;number&gt;.made);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于当前的解析数字任务，可以将TOP规则和方法完全替换为数字令牌和操作方法的内容（请注意，TOP现在是令牌，而不是规则）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Number {
    token TOP {
        &lt;sign&gt;? [
            | &lt;integer&gt;
            | &lt;floating-point&gt;
        ] &lt;exponent&gt;?
    }

    . . .
}

class NumberActions {
    method TOP($/) {
        my $n = $&lt;integer&gt;.made;
        $n *= $&lt;sign&gt;.made if $&lt;sign&gt;;
        $/.make($n);
    }

    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果查看由parse方法返回的对象，您将看到它包含以下字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">from =&gt; 0, orig =&gt; -84, made =&gt; -84, pos =&gt; 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>成对的包含我们所需的负整数。 可以使用相同的属性从语法外部和操作外部进行访问：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $test = Number.parse($number, :actions($actions));

if ($test) {
    say "OK $number = " ~ $test.made;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>任务已完成，我们可以继续处理带有指数部分e的整数。 例如3E4。 使用这样的数字，整数令牌被触发两次，但这并不成问题，因为两个整数都位于不同对象的相应属性中。</p>
</div>
<div class="paragraph">
<p>创建一个操作以处理指数部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method exponent($/) {
    my $e = $&lt;integer&gt;;
    $e *= -1 if $&lt;sign&gt; &amp;&amp; ~$&lt;sign&gt; eq '-';
    $/.make($e);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并使用该值乘以数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method TOP($/) {
    my $n = $&lt;integer&gt;.made;
    $n *= $&lt;sign&gt;.made if $&lt;sign&gt;;
    $n *= 10 ** $&lt;exponent&gt;.made if $&lt;exponent&gt;;
    $/.make($n);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行测试套件，并检查它对于3E4或-1E-2这样的数字产生什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OK 3E4 = 30000
OK -33E55 =
-330000000000000000000000000000000000000000000000000000000
OK 3E-3 = 0.003
OK -1E-2 = -0.01</code></pre>
</div>
</div>
<div class="paragraph">
<p>目前，唯一没有关联动作的令牌是浮点数。 （exp令牌不需要任何令牌，因为它的唯一任务是与e或E匹配）。 让我们再来看一次：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token floating-point {
    \d* ['.' &lt;integer&gt;]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建令牌时，我们用&lt;integer&gt;替换了 <code>\d+</code> 部分。 实际上，一个可选序列 <code>\d*</code> 也可以替换为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token floating-point {
    &lt;integer&gt;? ['.' &lt;integer&gt;]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，同一令牌中有两个&lt;integer&gt;调用！ 在这种情况下，您在操作中写了什么？ 很简单：如果多次提到该名称，您将获得一个数组，因此可以将第一个匹配项引用为$ &lt;integer&gt; [0]，将$ &lt;integer&gt; [1]引用为第二个匹配项。</p>
</div>
<div class="paragraph">
<p>唯一的问题是，在我们的情况下，第一个整数部分是可选的。 如果您解析3.14，则会获得两个元素，但是如果您解析了.14，则14将到达索引为0的元素。可能的解决方案之一就是检查数组的长度。 评估价值是一项相对简单的任务。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method floating-point($/) {
    my $int = 0;
    my $frac = 0;

    if $&lt;integer&gt;.elems == 2 {
        ($int, $frac) = $&lt;integer&gt;;
    }
    else {
        $frac = $&lt;integer&gt;[0];
    }

    my $n = $int + $frac / 10 ** $frac.chars;

    $/.make($n);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果解析了TOP令牌，则还必须更新它以获取浮点数的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = $&lt;integer&gt; ??
        $&lt;integer&gt;.made !! $&lt;floating-point&gt;.made;</code></pre>
</div>
</div>
<div class="paragraph">
<p>任务似乎已经解决。 所有数字（包括带小数点和指数部分的数字）均已成功处理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OK 3.14 = 3.14
OK -2.78 = -2.78
OK 5.0 = 5
OK .5 = 0.5
OK -5.3 = -5.3
OK -.3 = -0.3
OK 3E-3 = 0.003
OK -1E-2 = -0.01
OK 3.14E2 = 314
OK .5E-3 = 0.0005</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_最后的笔记">2.4. 最后的笔记</h3>
<div class="paragraph">
<p>在本章中，我们设法将字符串转换为数字，但是它们是哪种数字？ 为了获得数字，我们使用了Raku中可用的运算符，例如二进制+，算术运算符和幂运算符**。 使用所有这些的计算结果是一个数字，该数字是Raku提供的一种数字类型的实例。</p>
</div>
<div class="paragraph">
<p>您可以通过在测试循环中显式打印类名称来看到它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "OK $number = " ~ $test.made ~
    ' (' ~ $test.made.^name ~ ')';</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有不包含小数点的数字均为Ints，其余均为Rats：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OK 7 = 7 (Int)
OK 77 = 77 (Int)
OK -84 = -84 (Int)
OK +7 = 7 (Int)
OK 0 = 0 (Int)
OK 3.14 = 3.14 (Rat)
OK -2.78 = -2.78 (Rat)
OK 5.0 = 5 (Rat)
OK .5 = 0.5 (Rat)
OK -5.3 = -5.3 (Rat)
OK -.3 = -0.3 (Rat)
OK 3E4 = 30000 (Int)
OK -33E55 = -330000000000000000000000000000000000000000000000000000000 (Int)
OK 3E-3 = 0.003 (Rat)
OK -1E-2 = -0.01 (Rat)
OK 3.14E2 = 314 (Rat)
OK .5E-3 = 0.0005 (Rat)</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，再次查看action类中的浮点方法。 尽管其算法简单明了，并且可以产生正确的结果，但是它比较罗word，需要几行代码。 另外，您可以将此任务传递给宿主语言本身！ 让Raku为您解析浮点数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = +"$int.$frac";
$/.make($n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>等待，什么是"$int.$frac"? 它是一个在解析过程中与浮点令牌匹配的字符串，这意味着与其重建字符串并将其转换为数字，我们还可以直接将$ /对象转换为数字，而无需访问它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method floating-point($/) {
    $/.make(+$/);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该代码是否类似于您已经看到的内容？ 此方法的主体与整数方法的主体完全相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method integer($/) {
    $/.make(+$/);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>确实，当Raku仅包含数字时，我们允许它为我们建立数字。 如果我们也遇到带小数点的数字，则可以再次委托它。</p>
</div>
<div class="paragraph">
<p>但这还不是全部。 我们的数字语法允许的数字都是有效的Raku数字，并且可以用一行代码替换我们所有的动作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class NumberActions {
    method TOP($/) {
        $/.make(+$/);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>更改之后，数字的类型略有不同。 Raku在科学计数法中将数字视为Num，而不是Rat。 您可以确认购买再次运行测试循环：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OK 7 = 7 (Int)
OK 77 = 77 (Int)
OK -84 = -84 (Int)
OK +7 = 7 (Int)
OK 0 = 0 (Int)
OK 3.14 = 3.14 (Rat)
OK -2.78 = -2.78 (Rat)
OK 5.0 = 5 (Rat)
OK .5 = 0.5 (Rat)
OK -5.3 = -5.3 (Rat)
OK -.3 = -0.3 (Rat)
OK 3E4 = 30000 (Num)
OK -33E55 = -3.3e+56 (Num)
OK 3E-3 = 0.003 (Num)
OK -1E-2 = -0.01 (Num)
OK 3.14E2 = 314 (Num)
OK .5E-3 = 0.0005 (Num)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的输出格式还取决于Raku如何打印不同数字类型的数字。</p>
</div>
<div class="paragraph">
<p>在此特定任务中，我们所有的体力劳动都由宿主语言中的编译器操作代替。 当然，这是有可能的，因为我们选择了许多编程语言都可以处理的标准数据格式。 一旦发现解决问题的简单方法，不要害怕删除自己的代码。 本章中介绍的使用AST的技术是本书未来冒险的基础。 敬请关注！</p>
</div>
<div class="paragraph">
<p><code>P. S</code>.细心的读者可能已经注意到，数字语法不包含数字（例如4.），其中有整数部分，小数点但没有小数部分。 这些数字在Raku本身中是不允许的，因此我没有将其包括在语法中。</p>
</div>
<div class="paragraph">
<p><a href="https://andrewshitov.com/2020/03/01/chapter-2-parsing-a-number/" class="bare">https://andrewshitov.com/2020/03/01/chapter-2-parsing-a-number/</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第三章_创建计算器">3. 第三章 创建计算器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本章中，我们将创建一个程序，该程序可以评估简单的算术表达式，例如 <code>3 + 4</code> 或 <code>3 - 3 * 7</code>。我们将从具有两个操作数的最简单方程式开始，一直工作到引入括号。</p>
</div>
<div class="sect2">
<h3 id="_汇总">3.1. 汇总</h3>
<div class="paragraph">
<p>让我们首先获取一个测试表达式 <code>3 + 4</code> 并为此创建一个可工作的计算器原型。 语法只需要解析整数和文字加号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Calculator {
    rule TOP {
        &lt;number&gt; '+' &lt;number&gt;
    }

    token number {
        \d+
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>动作也很简单。 我们正在使用 AST 属性来保留值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class CalculatorActions {
    method TOP($/) {
        $/.make($&lt;number&gt;[0].made + $&lt;number&gt;[1].made);
    }

    method number($/) {
        $/.make(+$/);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一切准备就绪，可以运行测试并确认它确实打印 7：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Calculator.parse('3 + 4',
                 :actions(CalculatorActions)).made.say;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一点都不困难。 该代码可与其他整数一起使用，而语法或动作没有变化，但是我们的下一个目标是教它处理-进行减法。</p>
</div>
<div class="paragraph">
<p>第一种方法可以在语法的最顶部引入不同类型的语句：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    | &lt;addition&gt;
    | &lt;subtraction&gt;
}

rule addition {
    &lt;number&gt; '+' &lt;number&gt;
}

rule subtraction {
    &lt;number&gt; '-' &lt;number&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，让我们为加法和减法创建单独的操作方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method TOP($/) {
    $/.make($&lt;addition&gt; ??
            $&lt;addition&gt;.made !! $&lt;subtraction&gt;.made);
}

method addition($/) {
    $/.make($&lt;number&gt;[0].made + $&lt;number&gt;[1].made);
}

method subtraction($/) {
    $/.make($&lt;number&gt;[0].made - $&lt;number&gt;[1].made);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，测试第二种情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @cases = '3 + 4', '3 - 4';
for @cases -&gt; $test {
    say "$test = " ~ Calculator.parse($test,
                     :actions(CalculatorActions)).made;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>好的，一切都按预期进行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">3 + 4 = 7
3 - 4 = -1</code></pre>
</div>
</div>
<div class="paragraph">
<p>一切正常，但是您不应该对解决方案感到满意。 最好将加法和减法合并为一个规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    &lt;number&gt; &lt;op&gt; &lt;number&gt;
}

token op {
    '+' | '-'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>语法变得更简单，并且运算符在其自己的与加号或减号匹配的标记中明确定义。</p>
</div>
<div class="paragraph">
<p>同样，加法和减法动作方法可以用通用解决方案代替：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method TOP($/) {
    if $&lt;op&gt; eq '+' {
        $/.make($&lt;number&gt;[0].made + $&lt;number&gt;[1].made);
    }
    else {
        $/.make($&lt;number&gt;[0].made - $&lt;number&gt;[1].made);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>就是这样。 更新后的语法将两个测试字符串都视为有效表达式，并根据$ &lt;op&gt;的内容进行正确的计算。 当检查 <code>$&lt;op&gt; eq '+'</code> 中的条件时，eq 字符串比较运算符将 <code>$&lt;op&gt;</code> 隐式转换为字符串，并且不需要单独的操作来处理 <code>op</code> 令牌。</p>
</div>
</div>
<div class="sect2">
<h3 id="_过早的优化">3.2. 过早的优化</h3>
<div class="paragraph">
<p>有什么方法可以使代码更具吸引力？ 有几个。 我们将尝试两种方法来统一通话。 目的是避免重复长的代码行，唯一的区别是操作的符号，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$/.make($&lt;number&gt;[0].made - $&lt;number&gt;[1].made);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下，运算符都被相同的两个操作数包围，这是编写几个双函数的好机会：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class CalculatorActions {
    sub addition($a, $b) {
        $a + $b
    }

    sub subtraction($a, $b) {
        $a - $b
    }

    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这两个函数都可以放置在 CalculatorActions 类内部，并且当调用它们时，Raku 不会将指向该类实例的其他参数传递给它。 为了为这两个函数建立共同的入口点，让我们创建一个保留对它们的引用的哈希：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class CalculatorActions {
    my %operation =
        '+' =&gt; &amp;addition,
        '-' =&gt; &amp;subtraction;

    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据运算符调用函数非常容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method TOP($/) {
    $/.make(%operation{~$&lt;op&gt;}(
        $&lt;number&gt;[0].made, $&lt;number&gt;[1].made));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>简化代码并摆脱显式检查（如果检查）的另一个有趣选择是使用多个分派。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class CalculatorActions {
    multi sub operation('+', $a, $b) {
        $a + $b
    }

    multi sub operation('-', $a, $b) {
        $a - $b
    }

    method TOP($/) {
        $/.make(operation(~$&lt;op&gt;,
                          $&lt;number&gt;[0].made,
                          $&lt;number&gt;[1].made));
    }

    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，运算符被传递给操作函数，编译器选择要调用的候选对象：用加号定义的操作或需要减号作为其第一个参数的操作。 Raku 编译器很高兴为我们完成了这项工作。</p>
</div>
</div>
<div class="sect2">
<h3 id="_更多操作数">3.3. 更多操作数</h3>
<div class="paragraph">
<p>语法和动作现在已经足够聪明，可以解析和评估其中具有两个值的表达式，但不适用于1 + 2 + 3等更复杂的示例。由于TOP级别受规则限制，因此无法使用 仅两个数字：<code>&lt;number&gt; &lt;op&gt; &lt;number&gt;</code>。</p>
</div>
<div class="paragraph">
<p>在语法中，链中新的可选项目可以用 * 量词表示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    &lt;number&gt; [&lt;op&gt; &lt;number&gt; &lt;ws&gt;]*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&lt;ws&gt;</code> 令牌是用于匹配可选空格的内置工具。 通过此更改，我们还允许包含单个数字的表达式。 因此，以下测试用例全部匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @cases =
    '3 + 4', '3 - 4',
    '7',
    '1 + 2 + 3', '1 + 3 + 5 + 7';</code></pre>
</div>
</div>
<div class="paragraph">
<p>进行真实计算的两个函数还必须适用于接受两个以上的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub operation('+', @values) {
    [+] @values
}

multi sub operation('-', @values) {
    [-] @values
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此时，使用归约运算可大大简化语法。 最后，准备一个值数组，以将其传递给以下多功能之一：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method TOP($/) {
    $/.make(operation(~$&lt;op&gt;[0], $&lt;number&gt;.map: *.made));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了从 AS T树中获取数字，此处使用 map 方法。 <code>*.made</code> 结构是对 <code>$&lt;number&gt;</code> 数组的每个元素执行的 WhateverCode 块。</p>
</div>
<div class="paragraph">
<p>正如我们已经预期的那样，计算器必须使用单个数字，因此需要一个小的扩展名。 只有一个数字，表达式中没有运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method TOP($/) {
    if $&lt;op&gt; {
        $/.make(operation(~$&lt;op&gt;[0], $&lt;number&gt;.map: *.made));
    }
    else {
        $/.make($&lt;number&gt;[0].made);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行测试并检查是否正确评估了所有测试用例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">3 + 4 = 7
3 - 4 = -1
7 = 7
1 + 2 + 3 = 6
1 + 3 + 5 + 7 = 16</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_多样性测试">3.4. 多样性测试</h3>
<div class="paragraph">
<p>运算符（例如[+]）的简化形式的优美和简单性使得可以用几个字符表示动作，但无法用 <code>7 + 8 - 3</code> 等不同的运算符来评估表达式。 为了处理这样的示例，可以组织一个遍历运算符和操作数的循环。</p>
</div>
<div class="paragraph">
<p>在顶层，您必须遍历所有数字，然后将运算符带到旁边。 这是一个如何遍历值的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method TOP($/) {
    my @numbers = $&lt;number&gt;.map: *.made;
    my $make = @numbers.shift;

    operation(~$&lt;op&gt;.shift, $make, @numbers.shift)
        while @numbers.elems;

    $/.make($make);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了简化 while 循环，让操作多功能更新其参数之一：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub operation('+', $a is rw, $b) {
    $a += $b
}

multi sub operation('-', $a is rw, $b) {
    $a -= $b
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，代码看起来紧凑，更重要的是，它可以正常工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">7 + 8 - 3 = 12
14 - 4 = 10
14 - 4 - 3 = 7
100 - 200 + 300 + 1 - 2 = 199</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_增加更多数学">3.5. 增加更多数学</h3>
<div class="paragraph">
<p>计算器现在仅能进行加减运算。 好处是它可以计算包含两个以上数字的长表达式。 现在是时候教它处理乘法和除法了。</p>
</div>
<div class="paragraph">
<p>仅扩展 op 令牌以创建更多的操作函数候选者是天真的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Calculator {
    . . .

    token op {
        '+' | '-' | '*' | '/'
    }

    . . .
}

class CalculatorActions {
    . . .

    multi sub operation('*', $a is rw, $b) {
        $a *= $b
    }

    multi sub operation('/', $a is rw, $b) {
        $a /= $b
    }

    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该语法使用全部四个算术运算来解析甚至评估所有可能的表达式，但是它不遵循标准的优先级规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">3 * 4 = 12
100 / 25 = 4
1 + 2 * 3 = 9</code></pre>
</div>
</div>
<div class="paragraph">
<p>可能的解决方案之一是使用堆栈来执行计算。 您从左到右扫描输入字符串，并继续将下一个运算符应用于数字，直到遇到优先级更高的运算符为止。 在这种情况下，您将当前结果放入堆栈，并继续进行一系列新的计算，直到找到优先级较低的运算符。 然后，从堆栈中弹出数字和运算符，并将其减少，直到完全消耗掉为止。 这是在家中进行的好练习，但是我们将选择一种简单的方法。</p>
</div>
<div class="paragraph">
<p>处理算术运算优先级的另一种方法是更改语法，以使其首先提取乘法和除法运算，然后将结果传递给其余的加法和减法。</p>
</div>
<div class="paragraph">
<p>在下一个片段中，显示新语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Calculator {
    rule TOP {
        &lt;term&gt;* %% &lt;op1&gt;
    }

    rule term {
        &lt;factor&gt;* %% &lt;op2&gt;
    }

    token op1 {
        '+' | '-'
    }

    token op2 {
        '*' | '/'
    }

    rule factor {
        &lt;number&gt;
    }

    token number {
        \d+
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们检查一下。 首先，请注意我们与之前的变体相比如何更改了TOP规则。 使用%%运算符可以更轻松地表达片段重复。 比较两个正则表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;number&gt; [&lt;op&gt; &lt;number&gt; &lt;ws&gt;]*</code></pre>
</div>
</div>
<div class="paragraph">
<p>和</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;number&gt;* %% &lt;op&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二个变化是引入了两个运算符集：+和-的op1以及*和/的op2。 op1中的运算符的优先级较低，它们出现在语法的顶级规则中。 换句话说，我们认为输入表达式的总和仅包含您要加或减的数字。</p>
</div>
<div class="paragraph">
<p>乘法和除法运算符具有更高的优先级，您应该将其结果总体上视为最高级别。 这就是为什么引入令牌而不是匹配数字的原因。 最后可以是数字，但首先是由*或/分隔的一系列因素。 在我们的案例中，一个因素基本上是一个数字。 我故意添加了一个单独的代理规则，factor，以保留名称的术语和因数，您经常可以在与编译器相关的文献中看到这些规则。</p>
</div>
<div class="paragraph">
<p>在动作类中，我们已经具有四个操作功能； 我们所需要做的只是为因子添加一个简单的方法并为术语创建操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class CalculatorActions {
    . . .

    method TOP($/) {
        $/.make(process($&lt;term&gt;, $&lt;op1&gt;));
    }

    method term($/) {
        $/.make(process($&lt;factor&gt;, $&lt;op2&gt;));
    }

    sub process(@data, @ops) {
        my @nums = @data.map: *.made;
        my $result = @nums.shift;

        operation(~@ops.shift, $result, @nums.shift)
            while @nums;

        return $result;
    }

    method factor($/) {
        $/.make($&lt;number&gt;.made);
    }

    method number($/) {
        $/.make(+$/);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，TOP和term都实现相同的算法； 他们只是处理语法的不同部分（和不同的运算符）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_测试代码">3.6. 测试代码</h3>
<div class="paragraph">
<p>到目前为止，我们已经有了一个可以对表达式中任意数量的数字执行四个算术运算的计算器。 您可以提出测试用例，但您可能不想在脑海中计算出正确的结果，并对照每个测试用例进行检查。</p>
</div>
<div class="paragraph">
<p>Raku发行版包括Test模块，该模块显着有助于简化测试用例循环。 该模块会导出一些功能，我们将使用其中一个名为is的功能。 由于计算器表达式的语法与Raku的语法一致，因此让我们要求它检查结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Test;

. . .

for @cases -&gt; $test {
    my $result = Calculator.parse(
        $test, :actions(CalculatorActions)).made;
    my $correct = EVAL($result);
    is($result, $correct, "$test = $correct");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>尝试不同的测试用例，包括那些混合使用运算符的测试用例。 例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">ok 10 - 3 * 4 = 12
ok 11 - 100 / 25 = 4
ok 12 - 1 + 2 * 3 = 7
ok 13 - 1 + 2 - 3 * 4 / 5 = 0.6</code></pre>
</div>
</div>
<div class="paragraph">
<p>实际上，每个测试都必须检查两件事：1）是否对示例进行了解析，以及2）评估是否正确。 我们可以拆分测试以满足这一观察要求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @cases -&gt; $test {
    my $parse = Calculator.parse($test, :actions(CalculatorActions));
    next unless isa-ok($parse, Match, "parsed $test");

    my $result = $parse.made;
    my $correct = EVAL($result);
    is($result, $correct, "computed $test = $correct");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出将相应地更新：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">ok 1 - parsed 3 + 4
ok 2 - computed 3 + 4 = 7
ok 3 - parsed 3 - 4
ok 4 - computed 3 - 4 = -1
. . .</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_添加更多能量">3.7. 添加更多能量</h3>
<div class="paragraph">
<p>在本节中，我们将使计算器更加通用，因为我们将要添加幂运算符**。 与以前的运算符集不同的是，幂运算符具有更高的优先级，必须在进行任何乘法或加法之前首先进行处理。</p>
</div>
<div class="paragraph">
<p>可以类似于我们之前对*和/进行的操作添加操作符。 让我们替换因子规则并为运算符本身定义令牌：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule factor {
    &lt;number&gt;* %% &lt;op3&gt;
}

token op3 {
    '**'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个需要做的细微变化是在数字令牌中添加空格。 您可以明确地做到这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;ws&gt; \d+ &lt;ws&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或通过将令牌转换为规则来隐式地：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule number {
    \d+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>更新操作类以支持新的运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub operation('**', $a is rw, $b) {
    $a **= $b
}

method factor($/) {
    $/.make(process($&lt;number&gt;, $&lt;op3&gt;));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有的辛苦工作都完成了（很简单，不是吗？）。 计算器现在处理五个运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">ok 26 - parsed 2 ** 3
ok 27 - computed 2 ** 3 = 8
ok 28 - parsed 2 + 3 ** 4
ok 29 - computed 2 + 3 ** 4 = 83
ok 30 - parsed 1 + 2 * 3 ** 4 - 5 * 6
ok 31 - computed 1 + 2 * 3 ** 4 - 5 * 6 = 133
ok 32 - parsed 2 ** 3 ** 4
ok 33 - computed 2 ** 3 ** 4 = 4096</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_允许括号">3.8. 允许括号</h3>
<div class="paragraph">
<p>计算器设计的最后一点是使其理解括号。 尽管看似艰巨的任务，但实际上实现起来非常简单。 这是因为括号内的任何内容都是遵循相同语法规则的另一种表达方式。 换句话说，如果看到括号，则可以从TOP递归开始。</p>
</div>
<div class="paragraph">
<p>计算括号内的值后，您将获得一个值，因此可以将其视为任何其他数字。 要扩展解析器，只需从数字中创建一个新值规则，然后在其中列出两个备选方案：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule factor {
    &lt;value&gt;* %% &lt;op3&gt;
}

rule value {
    | &lt;number&gt;
    | '(' &lt;TOP&gt; ')'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>value</code> 方法获取上一级的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method value($/) {
    $/.make($&lt;number&gt; ?? $&lt;number&gt;.made !! $&lt;TOP&gt;.made);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而已。 仅需进行三个简单的更改，我们就可以解析更多复杂的表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">ok 34 - parsed 10 * (20 - 30)
ok 35 - computed 10 * (20 - 30) = -100
ok 36 - parsed 10 * 20 - 30
ok 37 - computed 10 * 20 - 30 = 170
ok 38 - parsed (5 * 6)
ok 39 - computed (5 * 6) = 30
ok 40 - parsed (10)
ok 41 - computed (10) = 10
ok 42 - parsed 1 - (5 * (3 + 4)) / 2
ok 43 - computed 1 - (5 * (3 + 4)) / 2 = -16.5</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的计算器已经准备好了。 在下一章中，我们将其集成到解释器中，以便它可以解析涉及变量的算术表达式。</p>
</div>
<div class="paragraph">
<p><a href="https://andrewshitov.com/2020/03/08/chapter-3-creating-a-calculator/" class="bare">https://andrewshitov.com/2020/03/08/chapter-3-creating-a-calculator/</a></p>
</div>
</div>
</div>
</div>

</article>


    

  </main><section class="site__search">
    <label class="site__form">
        <p class="form__label">Search around the site</p> 
        <input class="site__search-bar form__input" type="text">
    </label>
    <div class="site__search-bar-results"></div>
</section>
  
  <footer class="site__footer">
    
    
    <p class="footer__sign">© 2020 ohmyraku</p></footer>
    

    
    <script>
        window.addEventListener("load", function () {
            const script = document.createElement("script");
            script.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
            script.async = true

            document.head.appendChild(script);
        })
    </script>





<script defer type="text/javascript" src="https://ohmyraku.github.io/js/script.14164ab553b19613ce98aadb54b1ed9a89ae5b056c72b99a4c672e37954f33d67bebe1452b0279025ba889964b51bdf8ec69683933cf427ae67c08ac2cdda7b1.js" integrity="sha512-FBZKtVOxlhPOmKrbVLHtmomuWwVscrmaTGcuN5VPM9Z76&#43;FFKwJ5AluoiZZLUb347GloOTPPQnrmfAisLN2nsQ=="></script>



</body>
</html>