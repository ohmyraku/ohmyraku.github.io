<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>用 Raku 写编译器 :: 山川异域, 风月同天</title>

<meta name="author" content="ohmyraku">
<meta name="application-name" content="山川异域, 风月同天">
<meta name="description" content="Table of Contents 1. 第一章 创建一个简单的解释器 1.1. Grammar 1.2. Actions 1.3. 模块   2. 第二章 解析数字 2.1. 查找数字 2.2. 获取值 2.3. 使用 AST 2.4. 最后的笔记   3. 第三章 创建计算器 3.1. 汇总 3.2. 过早的优化 3.3. 更多操作数 3.4. 多样性测试 3.5. 增加更多数学 3.6. 测试代码 3.7. 添加更多能量 3.8. 允许括号   4. 第四章 更好的解释器 4.1. 跳过注释 4.2. 复杂数字 4.3. 复杂表达式 4.4. 使用变量 4.5. 初始化声明   5. Grammar 学习 5.1. 可执行的 5.2. 组合和继承 Grammar 5.">
<meta name="robots" content="noodp"/>
<meta name="generator" content="Hugo 0.63.2" />
<meta name="referrer" content="no-referrer" />
<meta name="format-detection" content="telephone=no">

<link rel="canonical" href="https://ohmyraku.github.io/creating-a-compiler-with-raku/" />


<link rel="icon" href="https://ohmyraku.github.io/logo.png" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="用 Raku 写编译器" />
<meta name="twitter:description" content="Table of Contents 1. 第一章 创建一个简单的解释器 1.1. Grammar 1.2. Actions 1.3. 模块   2. 第二章 解析数字 2.1. 查找数字 2.2. 获取值 2.3. 使用 AST 2.4. 最后的笔记   3. 第三章 创建计算器 3.1. 汇总 3.2. 过早的优化 3.3. 更多操作数 3.4. 多样性测试 3.5. 增加更多数学 3.6. 测试代码 3.7. 添加更多能量 3.8. 允许括号   4. 第四章 更好的解释器 4.1. 跳过注释 4.2. 复杂数字 4.3. 复杂表达式 4.4. 使用变量 4.5. 初始化声明   5. Grammar 学习 5.1. 可执行的 5.2. 组合和继承 Grammar 5." />
<meta name="twitter:site" content="https://ohmyraku.github.io" />
<meta name="twitter:creator" content="ohmyraku" />
<meta name="twitter:image" content="https://ohmyraku.github.io/logo.png">
<meta property="og:type" content="article" />
<meta property="og:locale" content="en" />
<meta property="og:name" content="ohmyraku" />
<meta property="og:title" content="用 Raku 写编译器" />
<meta property="og:url" content="https://ohmyraku.github.io" />
<meta property="og:site_name" content="山川异域, 风月同天" />
<meta property="og:description" content="Table of Contents 1. 第一章 创建一个简单的解释器 1.1. Grammar 1.2. Actions 1.3. 模块   2. 第二章 解析数字 2.1. 查找数字 2.2. 获取值 2.3. 使用 AST 2.4. 最后的笔记   3. 第三章 创建计算器 3.1. 汇总 3.2. 过早的优化 3.3. 更多操作数 3.4. 多样性测试 3.5. 增加更多数学 3.6. 测试代码 3.7. 添加更多能量 3.8. 允许括号   4. 第四章 更好的解释器 4.1. 跳过注释 4.2. 复杂数字 4.3. 复杂表达式 4.4. 使用变量 4.5. 初始化声明   5. Grammar 学习 5.1. 可执行的 5.2. 组合和继承 Grammar 5." />
<script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "Article",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https:\/\/ohmyraku.github.io\/creating-a-compiler-with-raku\/"
      },
      "headline": "用 Raku 写编译器",
      
      "datePublished": "2020-02-24",
      "dateModified": "2020-02-24 12:54:52 \x2b0800 CST",
      "author": {
        "@type": "Person",
        "name": "ohmyraku"
      },
      "description": "Table of Contents 1. 第一章 创建一个简单的解释器 1.1. Grammar 1.2. Actions 1.3. 模块   2. 第二章 解析数字 2.1. 查找数字 2.2. 获取值 2.3. 使用 AST 2.4. 最后的笔记   3. 第三章 创建计算器 3.1. 汇总 3.2. 过早的优化 3.3. 更多操作数 3.4. 多样性测试 3.5. 增加更多数学 3.6. 测试代码 3.7. 添加更多能量 3.8. 允许括号   4. 第四章 更好的解释器 4.1. 跳过注释 4.2. 复杂数字 4.3. 复杂表达式 4.4. 使用变量 4.5. 初始化声明   5. Grammar 学习 5.1. 可执行的 5.2. 组合和继承 Grammar 5.",
      "publisher": {
        "@type": "Organization",
        "name": "https:\/\/ohmyraku.github.io",
        "logo": {
          "@type": "ImageObject",
          "url": "https:\/\/ohmyraku.github.io\/logo.png"
        }
      }
    }
</script><link rel="stylesheet" href="https://ohmyraku.github.io/scss/main.min.84f71d25d375c522a861bb4719728ce6839cf3635b15ca0c7a1b4d799c2dc3399a1d6cb46058a9d8fdbebe9156a8857279cfdeb70aa3862e629de234b5a41fa1.css" integrity="sha512-hPcdJdN1xSKoYbtHGXKM5oOc82NbFcoMehtNeZwtwzmaHWy0YFip2P2&#43;vpFWqIVyec/etwqjhi5ineI0taQfoQ==">
<script>

const theme = window.localStorage.getItem('theme'); 
if (theme && theme !== "1") {
    document.documentElement.classList.add('theme-' + theme);
}
</script>


</head>
<body>
  <main class="site__content">
    <div class="site__page">
  <nav class="site__breadcrumbs">
    <a class="site__breadcrumb" href="https://ohmyraku.github.io/">山川异域, 风月同天</a><a class="site__breadcrumb--active" href="https://ohmyraku.github.io/creating-a-compiler-with-raku/">用 Raku 写编译器</a>
</nav>

<h1 class="page__title">用 Raku 写编译器</h1>
  <div class="page__meta">
    <p>
    
    <span class="page__date">
    on <time datetime="2020-02-24T12:54:52&#43;08:00">2020-02-24</time>
    
    </span>
    </p>

    

    
    </div>
</div>


</div>

<article class="page__content" ><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_第一章_创建一个简单的解释器">1. 第一章 创建一个简单的解释器</a>
<ul class="sectlevel2">
<li><a href="#_grammar">1.1. Grammar</a></li>
<li><a href="#_actions">1.2. Actions</a></li>
<li><a href="#_模块">1.3. 模块</a></li>
</ul>
</li>
<li><a href="#_第二章_解析数字">2. 第二章 解析数字</a>
<ul class="sectlevel2">
<li><a href="#_查找数字">2.1. 查找数字</a></li>
<li><a href="#_获取值">2.2. 获取值</a></li>
<li><a href="#_使用_ast">2.3. 使用 AST</a></li>
<li><a href="#_最后的笔记">2.4. 最后的笔记</a></li>
</ul>
</li>
<li><a href="#_第三章_创建计算器">3. 第三章 创建计算器</a>
<ul class="sectlevel2">
<li><a href="#_汇总">3.1. 汇总</a></li>
<li><a href="#_过早的优化">3.2. 过早的优化</a></li>
<li><a href="#_更多操作数">3.3. 更多操作数</a></li>
<li><a href="#_多样性测试">3.4. 多样性测试</a></li>
<li><a href="#_增加更多数学">3.5. 增加更多数学</a></li>
<li><a href="#_测试代码">3.6. 测试代码</a></li>
<li><a href="#_添加更多能量">3.7. 添加更多能量</a></li>
<li><a href="#_允许括号">3.8. 允许括号</a></li>
</ul>
</li>
<li><a href="#_第四章_更好的解释器">4. 第四章 更好的解释器</a>
<ul class="sectlevel2">
<li><a href="#_跳过注释">4.1. 跳过注释</a></li>
<li><a href="#_复杂数字">4.2. 复杂数字</a></li>
<li><a href="#_复杂表达式">4.3. 复杂表达式</a></li>
<li><a href="#_使用变量">4.4. 使用变量</a></li>
<li><a href="#_初始化声明">4.5. 初始化声明</a></li>
</ul>
</li>
<li><a href="#_grammar_学习">5. Grammar 学习</a>
<ul class="sectlevel2">
<li><a href="#_可执行的">5.1. 可执行的</a></li>
<li><a href="#_组合和继承_grammar">5.2. 组合和继承 Grammar</a></li>
<li><a href="#_复习计算器">5.3. 复习计算器</a></li>
<li><a href="#_使用_multi_rules">5.4. 使用 MULTI-RULES</a></li>
<li><a href="#_摆脱全局变量">5.5. 摆脱全局变量</a></li>
<li><a href="#_更好的变量名">5.6. 更好的变量名</a></li>
<li><a href="#_函数接收表达式">5.7. 函数接收表达式</a></li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_第一章_创建一个简单的解释器">1. 第一章 创建一个简单的解释器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这是<a href="https://andrewshitov.com/creating-a-compiler-with-raku/">使用 Raku 创建编译器</a>的一章。</p>
</div>
<div class="paragraph">
<p>让我们从一个简单的解释器程序开始研究 Raku 强大的 Grammar 和正则表达式，该程序可以解析并执行以下微型程序。 我将这种语言称为 Lingua。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my x;
x = 42;
say x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在理解此代码的含义时，您不会遇到任何问题，因为故意选择了类似于 Raku 本身的语法的语法，只是在变量名前没有任何符号。</p>
</div>
<div class="paragraph">
<p>该程序声明一个名为 <code>x</code> 的变量，为其赋一个整数值，然后将该值输出到控制台。</p>
</div>
<div class="paragraph">
<p>假设您将代码保存在文件 <code>test.lng</code> 中。 现在让我们使用 Raku 读取它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $code = 'test.lng'.IO.slurp();
say $code;</code></pre>
</div>
</div>
<div class="paragraph">
<p>将此 Raku 程序保存在另一个文件 <code>lingua.raku</code> 中，然后运行它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku lingua.raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您安装了 Raku，则会打印出我们测试程序的内容。</p>
</div>
<div class="sect2">
<h3 id="_grammar">1.1. Grammar</h3>
<div class="paragraph">
<p>现在是时候使用 Raku grammar 解析程序了。 从语法上讲，grammar 是类，但是它们使用正则表达式描述其方法的行为，这些方法又称为 <strong>rule</strong> 和 <strong>token</strong>。 第一个应用的 <strong>rule</strong> 通常称为 <code>TOP</code>; Raku 选择它为默认开始规则。 语法用于解析某些文本，因此只需对已定义的语法调用 <code>parse</code> 方法并将文本传递给它即可。 所有这些都在我们的第一个程序中得到了证明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Lingua {
    rule TOP {
        .*
    }
}

my $code = 'test.lng'.IO.slurp();
my $result = Lingua.parse($code);
say $result;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，定义了语法 Lingua。 它会描述我们的目标语言，目前只有一条规则，这是应用于 <code>$code</code> 中包含的 Lingua 代码的第一个和最后一个规则。</p>
</div>
<div class="paragraph">
<p>TOP 规则的主体是与任意行匹配的正则表达式：点与任何字符都匹配，并且星号允许重复任意数量。 TOP 方法以静默方式将正则表达式锚定在字符串的开头和结尾，因此它实际上等效于 <code>^.*$</code>。</p>
</div>
<div class="paragraph">
<p>再次运行 lingua.raku，您会看到解析器设法读取了整个程序。 这是控制台中打印的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">｢my x;
x = 42;
say x;
｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些方括号表明这不是已打印的常规字符串。 在我们的例子中，<code>$result</code> 变量包含一个 Lingua 类的对象。</p>
</div>
<div class="paragraph">
<p>从 Lingua 程序中可以看到，其语句用分号分隔。 为了准确起见，您必须确定语句是用分号分隔还是应该以分号结尾。 区别在于，在第一种情况下，您不必在最后一条语句之后（例如，在程序末尾）加上分号。 Raku 语法允许实现这两种选择。</p>
</div>
<div class="paragraph">
<p>因此，该程序由许多用分号分隔的语句组成。 在 Raku 语法中，您可以通过以下方式表达这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    &lt;statement&gt;* %% ';'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，使用另一个实体语句描述 TOP 规则。 可以重复多次（包括不重复），并且如果有多个语句，则必须用 ';' 分隔。 字符。 如果您更改定义并输入 <code>%</code> 而不是 <code>%%</code>，则该规则将要求在每个语句之后使用分号。</p>
</div>
<div class="paragraph">
<p>语句本身是另一条规则，我们首先可以定义它是非常模糊的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule statement {
    &lt;-[;]&gt;*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它匹配除分号字符外的所有内容。 空语句也通过此过滤器。</p>
</div>
<div class="paragraph">
<p>通过此更改，解释器现在将拆分语句并发出以下输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢my x;
x = 42;
say x;
｣
 statement =&gt; ｢my x｣
 statement =&gt; ｢x = 42｣
 statement =&gt; ｢say x｣
 statement =&gt; ｢｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个块显示输入程序的整个文本（所有文本均已匹配并被使用），然后显示四个单独的语句。 最后一个语句为空，因为原始文件在最后一个非空字符之后包含换行符，并且语句规则允许空语句。</p>
</div>
<div class="paragraph">
<p>我们的代码中有三种不同类型的语句。 它们是变量声明，赋值和调用内置函数。 可以很容易地用语法表示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule statement {
    | &lt;variable-declaration&gt;
    | &lt;assignment&gt;
    | &lt;function-call&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>竖线界定规则的替代分支。 形式上，只需列出两个选项条即可列出三个选项，但是为了使代码美观，您可以再添加一个选项条，以使它们在代码轮廓中形成一条较长的垂直线。 如果这样做，则语法不会添加空匹配项作为第一种选择。 顺便说一句，Raku 的另一个优点是它允许在变量和方法的名称中使用连字符，并且我更喜欢 variable-declaration 而不是 variable_declaration。</p>
</div>
<div class="paragraph">
<p>查看驻留在 test.lng 中的测试程序，我们可以为语法定义新规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule variable-declaration {
    'my' &lt;variable-name&gt;
}

rule assignment {
    &lt;variable-name&gt; '=' &lt;value&gt;
}

rule function-call {
    &lt;function-name&gt; &lt;variable-name&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>带引号的字符串（例如"my"和"="）将文学与目标语言中的相应语法项进行匹配。 尖括号中的名称是对我们需要定义以完成语法的其他规则或标记的引用。 这是我们的第一个标记：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token variable-name {
    \w+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它与可以组成一个单词的一系列字符匹配（因此，至少包括字母，数字和下划线）。 另请注意，变量名称中至少应包含一个字符。</p>
</div>
<div class="paragraph">
<p><strong>rule</strong> 和 <strong>token</strong> 之间的主要区别是 Raku 处理空白的方式。 例如，看一下变量声明 <strong>rule</strong> 的主体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'my' &lt;variable-name&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它使以下两个文本均合法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my x
my    x</code></pre>
</div>
</div>
<div class="paragraph">
<p>您要创建令牌而不是规则，只能匹配 myx。 如您所见，语法中的标记非常适合诸如变量名或关键字之类的终端。</p>
</div>
<div class="paragraph">
<p>这是 <strong>token</strong> 的另一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token value {
    \d+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第一种方法中，我们仅将可能的值限制为非负整数。 稍后，我们将扩展令牌以包括其他类型的数字。</p>
</div>
<div class="paragraph">
<p>最后，是函数名称的标记。 到目前为止，只有一个内置函数，因此规则（在这种情况下可以是令牌）很简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule function-name {
    'say'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而已。 运行程序，如果找到了，这里是什么（让我省略重复该程序整个文本的输出的第一部分）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">statement =&gt; ｢my x｣
  variable-declaration =&gt; ｢my x｣
   variable-name =&gt; ｢x｣
 statement =&gt; ｢x = 42｣
  assignment =&gt; ｢x = 42｣
   variable-name =&gt; ｢x｣
   value =&gt; ｢42｣
 statement =&gt; ｢say x｣
  function-call =&gt; ｢say x｣
   function-name =&gt; ｢say ｣
   variable-name =&gt; ｢x｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出反映语法理解的解析程序的结构。 缩进有助于查看程序及其元素的嵌套结构。 每行的右侧显示了源代码的匹配部分。</p>
</div>
<div class="paragraph">
<p>例如，程序的第一行my x;是一条语句，其中包含变量声明 <code>my x</code> 和变量名称 <code>x</code>。 分号被 TOP 规则的分隔符所消耗，并且没有进入输出树。 类似地，第二条语句 <code>x = 42</code>，是将值 42 分配给变量名 <code>x</code>。</p>
</div>
<div class="paragraph">
<p>如果检查为第三行生成的输出，例如 <code>x</code> ;，您会看到函数名称在函数名称之后包含一个多余的空格：｢say｣。 通过使规则成为令牌可以轻松解决此问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token function-name {
    'say'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>进行此更改后，结果将更加清晰：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">statement =&gt; ｢say x｣
  function-call =&gt; ｢say x｣
   function-name =&gt; ｢say｣
   variable-name =&gt; ｢x｣</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_actions">1.2. Actions</h3>
<div class="paragraph">
<p>目标文件现已完全解析。 我们可以将其拆分为单独的语句，并且可以理解其中的所有部分。 唯一缺少的元素是使所有这些部分协同工作以产生结果。 这就是 Raku 中的动作。</p>
</div>
<div class="paragraph">
<p>返回Lingua的测试程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my x;
x = 42;
say x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要在控制台中看到 42，我们必须确保有一个存储该值的地方，并且可以通过其名称 x 进行引用。 换句话说，我们需要一个存储空间。 最明显的选择是使用哈希。 首先让我们将其设为全局变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %var;

grammar Lingua {
    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>成功匹配规则或令牌后，您可以要求 Raku 为您做点事情，即，您可以添加一个代码块（称为 action），该代码块将在匹配后执行。 在其中，您可以访问刚刚提取的数据。</p>
</div>
<div class="paragraph">
<p>我们的第一个动作是在看到变量声明时创建一个变量。 这是您的操作方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule variable-declaration {
    'my' &lt;variable-name&gt; {
        %var{$&lt;variable-name&gt;} = 0;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将动作放在一对大括号中的正则表达式之后。 我们知道，该规则通过匹配文字 "my"和变量名来找到子字符串 <code>my x</code>，变量名是命名令牌变量名。 我们可以使用该名称访问内容：<code>$&lt;variable-name&gt;</code>。 实际上，这是 Lingua 类的对象，但是我们将其用作哈希的键，因此将其转换为字符串，并使用新的对 x &#8658; 0 填充哈希。因此， 创建并用零初始化。</p>
</div>
<div class="paragraph">
<p>同样，让我们为变量分配创建一个动作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule assignment {
    &lt;variable-name&gt; '=' &lt;value&gt; {
        %var{~$&lt;variable-name&gt;} = +$&lt;value&gt;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，为了说明您也可以做到这一点，将 <code>$&lt;variable-name&gt;</code> 对象通过 <code>~</code> 前缀运算符显式转换为 Str 数据类型的值。 在等号的右侧，完成了另一种类型转换：+运算符将 <code>$&lt;value&gt;</code> 转换为数字。 这次，强制转换值非常重要，因为如果您不这样做，将保存一个 Lingua 对象而不是数字。</p>
</div>
<div class="paragraph">
<p>现在转到函数调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule function-call {
    &lt;function-name&gt; &lt;variable-name&gt; {
        say %var{$&lt;variable-name&gt;}
            if $&lt;function-name&gt; eq 'say';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>say</code> 函数的实现嵌入在语法操作中。 由于我们现在只有一个内置函数，因此实际上不需要 <code>if</code> 子句，但是让我们保留它可以使代码更透明。</p>
</div>
<div class="paragraph">
<p>到目前为止，这是如何完成的，这三个操作块是内联的。 它们是规则定义的一部分。 我们可以运行解释器并查看其作用。 将主代码更改为以下代码，以避免大量输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $code = 'test.lng'.IO.slurp();
my $result = Lingua.parse($code);
#say $result;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码打印出如下行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku lingua.raku
42</code></pre>
</div>
</div>
<div class="paragraph">
<p>恭喜你！ 该程序不仅被解析而且还被执行。 如您所见，它打印了变量 x 的内容，这正是我们放入变量 x 中的内容。 如果您转储 <code>%var</code> 容器（通过添加 <code>%var;</code>），则会得到 <code>{x &#8658; 42}</code>。</p>
</div>
<div class="paragraph">
<p>这是我们的第一个真正的成就。 我们设法为将来的林瓜语言的子集创建了一个口译员。 这里最令人兴奋的部分是它没有绑定到我们之前使用的单个测试程序。 您可以根据需要创建任意多个变量，可以将其分配给不同的值，然后再次重新分配它们。 变量的名称可以长于单个字母。 所有这些神奇地起作用！ 自己尝试一下，这是我所做的一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">my alpha;
my beta;
alpha = 100;
beta = 200;

say alpha;
say beta;

my gamma;
gamma = 33;
say gamma;

gamma = 44;
say gamma;</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行后，程序将打印正确的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">100
200
33
44</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以尝试多次分配值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my value;

value = 100;
say value;

value = 200;
say value;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这次，该程序两次使用相同的变量并在其中存储了不同的值，您可以通过运行该程序轻松确认：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">100
200</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_模块">1.3. 模块</h3>
<div class="paragraph">
<p>第一个简单的解释器已经准备就绪，但让我们花更多的时间使它的代码更结构化和更快。</p>
</div>
<div class="paragraph">
<p>首先，可以将内联操作收集在单独的类中。 在我们当前的实现中，所有动作都是单行的，但是在更高级的编译器中，情况并非如此。 在 Raku 中，表达动作和语法规则之间的关系非常容易：在创建动作类的方法时，只需使用相同的名称即可。 查看以下代码，您将立即理解。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class LinguaActions {
    method variable-declaration($/) {
        %var{$&lt;variable-name&gt;} = 0;
    }

    method assignment($/) {
        %var{~$&lt;variable-name&gt;} = +$&lt;value&gt;;
    }

    method function-call($/) {
        say %var{$&lt;variable-name&gt;}
            if $&lt;function-name&gt; eq 'say';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有这些方法都采用一个参数。 它的名称可以是您想要的任何名称，但为方便起见，最好将其命名为 <code>$/</code>，因为在这种情况下，可以使用 <code>$&lt;value&gt;</code> 之类的快捷方式代替 <code>$/&lt;value&gt;</code>。 如果您将其命名为 <code>$arg</code>，则必须输入更多字符才能访问其部分：<code>$arg&lt;value&gt;</code>。 另外，别忘了从语法类中删除代码块及其周围的花括号。</p>
</div>
<div class="paragraph">
<p>要将action类与语法一起使用，请将其作为命名参数传递给 <code>parse</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Lingua.parse($code, :actions(LinguaActions));</code></pre>
</div>
</div>
<div class="paragraph">
<p>提取类并将它们保存在单独的文件中也是一种好习惯。 例如，语法进入 Lingua.raku，动作（连同 <code>%var</code> 哈希，目前是模块的全局变量）一起进入 LinguaActions.raku。 整个解释器代码将缩短为以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Lingua;
use LinguaActions;

my $code = 'test.lng'.IO.slurp();
Lingua.parse($code, :actions(LinguaActions));</code></pre>
</div>
</div>
<div class="paragraph">
<p>此步骤不仅有助于逻辑上组织代码，而且可以提高解释速度。 如果 Raku 编译器能够缓存已编译的模块，则只需要编译一次即可。 每次下一次运行都更快，因为使用了模块的预编译版本。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二章_解析数字">2. 第二章 解析数字</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在接下来的两章中，我们将暂时保留上一章中创建的编译器，并将使用一个单独的帮助程序，即计算器。 它本身是一件有趣的事情，我们将在一个孤立的示例中对其进行探索。 在下一章中，它将集成到解释器中。</p>
</div>
<div class="sect2">
<h3 id="_查找数字">2.1. 查找数字</h3>
<div class="paragraph">
<p>计算器可以处理数字，因此我们要做的第一件事就是做一个用于解析数字的解析器。 在上一章中，我们仅使用非负整数，但是好的计算器必须理解更多的数字格式。 例如，它包括负数和浮点数，也可以用科学计数法表示。 我们还必须允许人们省略小数点前面的零并输入 <code>.5</code> 而不是 <code>0.5</code> 的情况。</p>
</div>
<div class="paragraph">
<p>让我们为不同类型的数字迭代创建解析器。 由于我们将对 grammar 进行大量更改，因此提供了一个测试套件来进行救援。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @cases = 7, 77, -84;
for @cases -&gt; $number {
    say "Test $number";
    say Number.parse($number);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@cases</code> 数组包含将针对 <code>Number</code> grammar 进行测试的数字列表。 这是它的第一个版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Number {
    rule TOP {
        &lt;number&gt;
    }

    token number {
        \d+
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>整个 grammar 需要一个数字，即一个数字序列。 它可以与我们当前的测试用例一起使用，并且程序的输出是可以预测的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Test 7
｢7｣
 number =&gt; ｢7｣
Test 77
｢77｣
 number =&gt; ｢77｣
Test -84
Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>前两个数字通过了测试，但第三个没有通过。 对于负数，<code>parse</code> 方法返回 <code>Nil</code>。</p>
</div>
<div class="paragraph">
<p>因此，我们需要扩展 <code>number</code> 标记并在数字前面添加可选的减号。 重要的是，它仍然必须是 token，因为您通常不希望符号和数字之间有空格。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    '-'? \d+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个很小的变化使另一半整数（负整数）有效。 以上测试现在将通过。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Test -84
｢-84｣
 number =&gt; ｢-84｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果您将正数拼写为 <code>+7</code> 会怎么样?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @cases = 7, 77, -84, '+7', 0;</code></pre>
</div>
</div>
<div class="paragraph">
<p>(Grammar 分析器始终使用字符串，但是我们可以让 Raku 转换正数，以避免在测试用例列表中加引号。)</p>
</div>
<div class="paragraph">
<p>根据 grammar，此数字不是有效数字。 因为它期望整个字符串是一个数字，所以我们不能期望加号会被简单地忽略。 解析器需要在开始时就知道可能的符号，因此，我们需要将其添加到 token 主体中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;[+-]&gt;? \d+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们也减少输出中的噪声，并且不打印解析树：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @cases -&gt; $number {
    my $test = Number.parse($number);
    say ($test ?? 'OK ' !! 'NOT OK ') ~ $number;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，输出与在测试 Perl 和 Raku 模块中广泛使用的 TAP（任何测试协议）部分兼容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OK 7
OK 77
OK -84
OK +7
OK 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>添加一个无效的数字，您会立即看到它失败，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">NOT OK 3.14</code></pre>
</div>
</div>
<div class="paragraph">
<p>实现流点号解析器的第一次尝试可以像这样简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;[+-]&gt;? \d+ ['.' \d+]?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们只是添加了一个可选的小数部分。 但是，如果遇到一个有点但没有整数部分的数字怎么办？ 它不会通过测试，但是可以通过将正则表达式左侧的 <code>\d+</code> 更改为 <code>\d*</code> 来轻松解决：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;[+-]&gt;? \d* ['.' \d+]?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>不幸的是，此更改破坏了令牌，因为它可以应用于单个符号，甚至可以应用于空字符串。 现在所有这些测试用例都可以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @cases =
    7, 77, -84, '+7', 0,
    3.14, -2.78, 5.0, '.5',
    '', '-', '+';</code></pre>
</div>
</div>
<div class="paragraph">
<p>尝试在单个正则表达式中表达所有选项有点棘手。 显式列出所有备选方案要容易得多。 我们知道符号可以出现在任何数字的前面，让我们将备选方案放在方括号中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;[+-]&gt;? [
        | \d+
        | \d* ['.' \d+]
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种方法使整个令牌更具可读性和可扩展性。 我们可以添加另一种选择来匹配科学计数法中的数字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;[+-]&gt;? [
        | \d+
        | \d* ['.' \d+]
        | \d+ &lt;[eE]&gt; &lt;[+-]&gt;? \d+
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在有更多测试用例通过了 Grammar：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'3E4', '-33E55', '3E-3', '-1E-2'</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们所缺少的是科学计数法中带有非整数尾数的数字，例如3.14E2或.5E-3。 另一种选择可以解决此问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;[+-]&gt;? [
        | \d+
        | \d* ['.' \d+]
        | \d+ &lt;[eE]&gt; &lt;[+-]&gt;? \d+
       | \d* ['.' \d+] &lt;[eE]&gt; &lt;[+-]&gt;? \d+
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种形式中，有些部分会重复，例如\ d +或\ d * ['。 \ d +]。 在这种紧凑的规则中可能会很好，但是也可以对其进行进一步分解，并引入负责此类重复部分的子令牌。 转换后的数字令牌及其家族如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;sign&gt;? [
        | &lt;integer&gt;
        | &lt;floating-point&gt;
        | &lt;integer&gt; &lt;exponent&gt;
        | &lt;floating-point&gt; &lt;exponent&gt;
    ]
}

token sign {
    &lt;[+-]&gt;
}

token exp {
    &lt;[eE]&gt;
}

token integer {
    \d+
}

token floating-point {
    \d* ['.' &lt;integer&gt;]
}

token exponent {
    &lt;exp&gt; &lt;sign&gt;? &lt;integer&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管与以前的版本相比有更多的代码，但每个单独的令牌都更易于理解。 例如，比较科学记数形式的数字的先前和当前正则表达式，其尾数具有浮点数。 之前是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">\d* ['.' \d+] &lt;[eE]&gt; &lt;[+-]&gt;? \d+</code></pre>
</div>
</div>
<div class="paragraph">
<p>转换后，它变成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;floating-point&gt; &lt;exponent&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>看一下主要代币的替代方案，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">| &lt;integer&gt;
| &lt;floating-point&gt;
| &lt;integer&gt; &lt;exponent&gt;
| &lt;floating-point&gt; &lt;exponent&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您会立即看到他们的描述。 甚至，我们可以进一步减少它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;sign&gt;? [
        | &lt;integer&gt;
        | &lt;floating-point&gt;
    ] &lt;exponent&gt;?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>换句话说，数字可以是整数，也可以是浮点值，其后跟一个可选的符号，然后可以跟一个可选的指数部分。 以这种形式，描述是如此简洁和紧凑。 所有细节（正则表达式“噪声”）都隐藏在辅助标记中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_获取值">2.2. 获取值</h3>
<div class="paragraph">
<p>该数字已解析，但是它的值是多少？ 对于编译器，我们不仅需要检查数字格式的有效性，还需要将其从字符串转换为数字，整数或浮点数。 在本节中，我们将在数字语法后面添加操作，以便我们可以构建数字并最终打印出来。</p>
</div>
<div class="paragraph">
<p>让我们以整数开头，并将数字保留在全局变量中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = 0;
class NumberActions {
    method integer($/) {
        $n = +$/;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的一切看起来都很简单。 通过使用+前缀运算符将字符串的匹配部分转换为数字值，可以直接得出整数值。 要查看其工作原理，让我们更改主测试循环，以使其输出已解析的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @cases -&gt; $number {
    my $test = Number.parse($number, :actions(NumberActions));

    if ($test) {
        say "OK $number = $n";
    }
    else {
        say "NOT OK $number";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用非负整数，效果很好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OK 7 = 7
OK 77 = 77
OK -84 = 84
OK +7 = 7
OK 0 = 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>负数无效。 看来+7字符串已正确处理，但实际上这并不完全正确，因为我们完全忽略了该符号。 这次，任务有点复杂。 第一个想法是，如果遇到减号，则翻转符号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method sign($/) {
    $n *= -1 if ~$/ eq '-';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这是行不通的，因为符号是在解析数字之前先解析的，而否定$ n意味着将符号应用于零。 我们可以使用一个单独的变量来保留有关标志的信息，但这并不是最好的选择。 但是，请这样做，因为这将揭示另一个问题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = 0;
my $sign = 1;

class NumberActions {
    method integer($/) {
        $n = $sign * +$/;
    }

    method sign($/) {
        $sign = -1 if ~$/ eq '-';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这有助于检测第一个负数，但会破坏所有其他负数。 当然，您可以检查符号是否为'+'，但问题是$ n和$ sign变量是全局变量，必须在解析下一个变量之前将其重置。 这是将它们移至动作类的好时机。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class NumberActions {
    has $.n = 0;
    has $!sign = 1;

    method integer($/) {
        $!n = $!sign * +$/;
    }

    method sign($/) {
        $!sign = -1 if ~$/ eq '-';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>$ n变量有意成为公共数据成员，因为我们必须以某种方式获得结果。 您还需要更改测试循环。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @cases -&gt; $number {
    my $actions = NumberActions.new();
    my $test = Number.parse($number, :actions($actions));

    if ($test) {
        say "OK $number = " ~ $actions.n;
    }
    else {
        say "NOT OK $number";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此处的主要更改是将NumberActions类的实例传递给语法的parse方法。 现在，在每次迭代中，解析器都会创建自己的变量以保留结果。</p>
</div>
<div class="paragraph">
<p>我们已经走了足够远的距离，以至于可以正确解析所有整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OK 7 = 7
OK 77 = 77
OK -84 = -84
OK +7 = 7
OK 0 = 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于浮点数，它的工作不那么顺畅：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OK 3.14 = 14
OK -2.78 = -78
OK 5.0 = 0
OK .5 = 5
OK -5.3 = -3
OK -.3 = -3
OK 3E4 = 4
OK -33E55 = -55
OK 3E-3 = -3
OK 3.14E2 = 2
OK .5E-3 = -3</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，小数部分或指数部分均获胜。 在两种情况下，这都是语法的最后一个整数部分。 确实，早些时候，我们对语法进行了转换，以排除重复部分。 当我们不得不引入$ sign变量时，钟声响了，但现在我们遭受的痛苦更大。 所有这些都需要以不同的方式处理。 这就是AST可以提供帮助的方式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_ast">2.3. 使用 AST</h3>
<div class="paragraph">
<p>AST，或抽象语法树，是一种允许在不同阶段收集和保持数据解析的机制。 如果在读取浮点数3.14时两次调用了整数令牌，或者对具有指数的数字（例如3.14E2）调用了三次，则所有这些整数都可以保留在AST中，并在以后用于构建整数。 对应于整个字符串的值。</p>
</div>
<div class="paragraph">
<p>在操作类的方法内，$ /变量有两种方法：make和made。 使用make可以存储一个值（将属性分配给解析树的当前节点）。 使用made时，您将读取先前存储的值。</p>
</div>
<div class="paragraph">
<p>将以下调用添加到令牌操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method integer($/) {
    $/.make(+$/);
}

method sign($/) {
    $/.make(~$/ eq '-' ?? -1 !! 1);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，即使多次调用该方法，也将保存这些值。 要了解它是如何工作的，让我们看一下语法对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $test = Number.parse($number, :actions($actions));
dd $test;</code></pre>
</div>
</div>
<div class="paragraph">
<p>dd例程是Rakudo专用的工具，可显示对象的内部结构。 对于输入数字-84，解析后将构建以下对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Number $test = Match.new(list =&gt; (), hash =&gt; Map.new((:number(Match.new(list =&gt; (), hash =&gt; Map.new((:integer(Match.new(list =&gt; (), hash =&gt; Map.new(()), made =&gt; 84, orig =&gt; -84, pos =&gt; 3, from =&gt; 1)),:sign(Match.new(list =&gt; (), hash =&gt; Map.new(()), made =&gt; -1, orig =&gt; -84, pos =&gt; 1, from =&gt; 0)))), made =&gt; Any, orig =&gt; -84, pos =&gt; 3, from =&gt; 0)))), made =&gt; Any, orig =&gt; -84, pos =&gt; 3, from =&gt; 0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>看起来很凌乱，但您应该可以发现我们最感兴趣的两个地方：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">made =&gt; 84, orig =&gt; -84, pos =&gt; 3, from =&gt; 1
made =&gt; -1, orig =&gt; -84, pos =&gt; 1, from =&gt; 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>将from和pos键设置为指向第一个字符以及与正则表达式匹配的最后一个字符之后的字符。 因此，这两个子哈希中的第一个是解析数字的结果（字符串“ -84”中从位置1到位置3，即84）。 第二个哈希对应减号字符（同一字符串中的位置0到1）。</p>
</div>
<div class="paragraph">
<p>made属性分别设置为84和-1，这确认语法能够正确解析数字及其符号。</p>
</div>
<div class="paragraph">
<p>现在可以使用这些值在父标记中生成结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method number($/) {
    my $n = $&lt;integer&gt;.made;
    $n *= $&lt;sign&gt;.made if $&lt;sign&gt;;
    $/.make($n);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它通过$ &lt;integer&gt;和$ &lt;sign&gt;对象的made属性访问整数值和符号乘数。 最后一行将结果传递到下一个级别，您可以从TOP规则中访问它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method TOP($/) {
    $/.make($&lt;number&gt;.made);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于当前的解析数字任务，可以将TOP规则和方法完全替换为数字令牌和操作方法的内容（请注意，TOP现在是令牌，而不是规则）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Number {
    token TOP {
        &lt;sign&gt;? [
            | &lt;integer&gt;
            | &lt;floating-point&gt;
        ] &lt;exponent&gt;?
    }

    . . .
}

class NumberActions {
    method TOP($/) {
        my $n = $&lt;integer&gt;.made;
        $n *= $&lt;sign&gt;.made if $&lt;sign&gt;;
        $/.make($n);
    }

    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果查看由parse方法返回的对象，您将看到它包含以下字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">from =&gt; 0, orig =&gt; -84, made =&gt; -84, pos =&gt; 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>成对的包含我们所需的负整数。 可以使用相同的属性从语法外部和操作外部进行访问：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $test = Number.parse($number, :actions($actions));

if ($test) {
    say "OK $number = " ~ $test.made;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>任务已完成，我们可以继续处理带有指数部分e的整数。 例如3E4。 使用这样的数字，整数令牌被触发两次，但这并不成问题，因为两个整数都位于不同对象的相应属性中。</p>
</div>
<div class="paragraph">
<p>创建一个操作以处理指数部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method exponent($/) {
    my $e = $&lt;integer&gt;;
    $e *= -1 if $&lt;sign&gt; &amp;&amp; ~$&lt;sign&gt; eq '-';
    $/.make($e);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并使用该值乘以数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method TOP($/) {
    my $n = $&lt;integer&gt;.made;
    $n *= $&lt;sign&gt;.made if $&lt;sign&gt;;
    $n *= 10 ** $&lt;exponent&gt;.made if $&lt;exponent&gt;;
    $/.make($n);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行测试套件，并检查它对于3E4或-1E-2这样的数字产生什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OK 3E4 = 30000
OK -33E55 =
-330000000000000000000000000000000000000000000000000000000
OK 3E-3 = 0.003
OK -1E-2 = -0.01</code></pre>
</div>
</div>
<div class="paragraph">
<p>目前，唯一没有关联动作的令牌是浮点数。 （exp令牌不需要任何令牌，因为它的唯一任务是与e或E匹配）。 让我们再来看一次：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token floating-point {
    \d* ['.' &lt;integer&gt;]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建令牌时，我们用&lt;integer&gt;替换了 <code>\d+</code> 部分。 实际上，一个可选序列 <code>\d*</code> 也可以替换为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token floating-point {
    &lt;integer&gt;? ['.' &lt;integer&gt;]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，同一令牌中有两个&lt;integer&gt;调用！ 在这种情况下，您在操作中写了什么？ 很简单：如果多次提到该名称，您将获得一个数组，因此可以将第一个匹配项引用为$ &lt;integer&gt; [0]，将$ &lt;integer&gt; [1]引用为第二个匹配项。</p>
</div>
<div class="paragraph">
<p>唯一的问题是，在我们的情况下，第一个整数部分是可选的。 如果您解析3.14，则会获得两个元素，但是如果您解析了.14，则14将到达索引为0的元素。可能的解决方案之一就是检查数组的长度。 评估价值是一项相对简单的任务。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method floating-point($/) {
    my $int = 0;
    my $frac = 0;

    if $&lt;integer&gt;.elems == 2 {
        ($int, $frac) = $&lt;integer&gt;;
    }
    else {
        $frac = $&lt;integer&gt;[0];
    }

    my $n = $int + $frac / 10 ** $frac.chars;

    $/.make($n);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果解析了TOP令牌，则还必须更新它以获取浮点数的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = $&lt;integer&gt; ??
        $&lt;integer&gt;.made !! $&lt;floating-point&gt;.made;</code></pre>
</div>
</div>
<div class="paragraph">
<p>任务似乎已经解决。 所有数字（包括带小数点和指数部分的数字）均已成功处理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OK 3.14 = 3.14
OK -2.78 = -2.78
OK 5.0 = 5
OK .5 = 0.5
OK -5.3 = -5.3
OK -.3 = -0.3
OK 3E-3 = 0.003
OK -1E-2 = -0.01
OK 3.14E2 = 314
OK .5E-3 = 0.0005</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_最后的笔记">2.4. 最后的笔记</h3>
<div class="paragraph">
<p>在本章中，我们设法将字符串转换为数字，但是它们是哪种数字？ 为了获得数字，我们使用了Raku中可用的运算符，例如二进制+，算术运算符和幂运算符**。 使用所有这些的计算结果是一个数字，该数字是Raku提供的一种数字类型的实例。</p>
</div>
<div class="paragraph">
<p>您可以通过在测试循环中显式打印类名称来看到它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "OK $number = " ~ $test.made ~
    ' (' ~ $test.made.^name ~ ')';</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有不包含小数点的数字均为Ints，其余均为Rats：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OK 7 = 7 (Int)
OK 77 = 77 (Int)
OK -84 = -84 (Int)
OK +7 = 7 (Int)
OK 0 = 0 (Int)
OK 3.14 = 3.14 (Rat)
OK -2.78 = -2.78 (Rat)
OK 5.0 = 5 (Rat)
OK .5 = 0.5 (Rat)
OK -5.3 = -5.3 (Rat)
OK -.3 = -0.3 (Rat)
OK 3E4 = 30000 (Int)
OK -33E55 = -330000000000000000000000000000000000000000000000000000000 (Int)
OK 3E-3 = 0.003 (Rat)
OK -1E-2 = -0.01 (Rat)
OK 3.14E2 = 314 (Rat)
OK .5E-3 = 0.0005 (Rat)</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，再次查看action类中的浮点方法。 尽管其算法简单明了，并且可以产生正确的结果，但是它比较罗word，需要几行代码。 另外，您可以将此任务传递给宿主语言本身！ 让Raku为您解析浮点数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = +"$int.$frac";
$/.make($n);</code></pre>
</div>
</div>
<div class="paragraph">
<p>等待，什么是"$int.$frac"? 它是一个在解析过程中与浮点令牌匹配的字符串，这意味着与其重建字符串并将其转换为数字，我们还可以直接将$ /对象转换为数字，而无需访问它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method floating-point($/) {
    $/.make(+$/);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该代码是否类似于您已经看到的内容？ 此方法的主体与整数方法的主体完全相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method integer($/) {
    $/.make(+$/);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>确实，当Raku仅包含数字时，我们允许它为我们建立数字。 如果我们也遇到带小数点的数字，则可以再次委托它。</p>
</div>
<div class="paragraph">
<p>但这还不是全部。 我们的数字语法允许的数字都是有效的Raku数字，并且可以用一行代码替换我们所有的动作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class NumberActions {
    method TOP($/) {
        $/.make(+$/);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>更改之后，数字的类型略有不同。 Raku在科学计数法中将数字视为Num，而不是Rat。 您可以确认购买再次运行测试循环：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OK 7 = 7 (Int)
OK 77 = 77 (Int)
OK -84 = -84 (Int)
OK +7 = 7 (Int)
OK 0 = 0 (Int)
OK 3.14 = 3.14 (Rat)
OK -2.78 = -2.78 (Rat)
OK 5.0 = 5 (Rat)
OK .5 = 0.5 (Rat)
OK -5.3 = -5.3 (Rat)
OK -.3 = -0.3 (Rat)
OK 3E4 = 30000 (Num)
OK -33E55 = -3.3e+56 (Num)
OK 3E-3 = 0.003 (Num)
OK -1E-2 = -0.01 (Num)
OK 3.14E2 = 314 (Num)
OK .5E-3 = 0.0005 (Num)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的输出格式还取决于Raku如何打印不同数字类型的数字。</p>
</div>
<div class="paragraph">
<p>在此特定任务中，我们所有的体力劳动都由宿主语言中的编译器操作代替。 当然，这是有可能的，因为我们选择了许多编程语言都可以处理的标准数据格式。 一旦发现解决问题的简单方法，不要害怕删除自己的代码。 本章中介绍的使用AST的技术是本书未来冒险的基础。 敬请关注！</p>
</div>
<div class="paragraph">
<p><code>P. S</code>.细心的读者可能已经注意到，数字语法不包含数字（例如4.），其中有整数部分，小数点但没有小数部分。 这些数字在Raku本身中是不允许的，因此我没有将其包括在语法中。</p>
</div>
<div class="paragraph">
<p><a href="https://andrewshitov.com/2020/03/01/chapter-2-parsing-a-number/" class="bare">https://andrewshitov.com/2020/03/01/chapter-2-parsing-a-number/</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第三章_创建计算器">3. 第三章 创建计算器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本章中，我们将创建一个程序，该程序可以评估简单的算术表达式，例如 <code>3 + 4</code> 或 <code>3 - 3 * 7</code>。我们将从具有两个操作数的最简单方程式开始，一直工作到引入括号。</p>
</div>
<div class="sect2">
<h3 id="_汇总">3.1. 汇总</h3>
<div class="paragraph">
<p>让我们首先获取一个测试表达式 <code>3 + 4</code> 并为此创建一个可工作的计算器原型。 语法只需要解析整数和文字加号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Calculator {
    rule TOP {
        &lt;number&gt; '+' &lt;number&gt;
    }

    token number {
        \d+
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>动作也很简单。 我们正在使用 AST 属性来保留值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class CalculatorActions {
    method TOP($/) {
        $/.make($&lt;number&gt;[0].made + $&lt;number&gt;[1].made);
    }

    method number($/) {
        $/.make(+$/);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一切准备就绪，可以运行测试并确认它确实打印 7：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Calculator.parse('3 + 4',
                 :actions(CalculatorActions)).made.say;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一点都不困难。 该代码可与其他整数一起使用，而语法或动作没有变化，但是我们的下一个目标是教它处理-进行减法。</p>
</div>
<div class="paragraph">
<p>第一种方法可以在语法的最顶部引入不同类型的语句：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    | &lt;addition&gt;
    | &lt;subtraction&gt;
}

rule addition {
    &lt;number&gt; '+' &lt;number&gt;
}

rule subtraction {
    &lt;number&gt; '-' &lt;number&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，让我们为加法和减法创建单独的操作方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method TOP($/) {
    $/.make($&lt;addition&gt; ??
            $&lt;addition&gt;.made !! $&lt;subtraction&gt;.made);
}

method addition($/) {
    $/.make($&lt;number&gt;[0].made + $&lt;number&gt;[1].made);
}

method subtraction($/) {
    $/.make($&lt;number&gt;[0].made - $&lt;number&gt;[1].made);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，测试第二种情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @cases = '3 + 4', '3 - 4';
for @cases -&gt; $test {
    say "$test = " ~ Calculator.parse($test,
                     :actions(CalculatorActions)).made;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>好的，一切都按预期进行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">3 + 4 = 7
3 - 4 = -1</code></pre>
</div>
</div>
<div class="paragraph">
<p>一切正常，但是您不应该对解决方案感到满意。 最好将加法和减法合并为一个规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    &lt;number&gt; &lt;op&gt; &lt;number&gt;
}

token op {
    '+' | '-'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>语法变得更简单，并且运算符在其自己的与加号或减号匹配的标记中明确定义。</p>
</div>
<div class="paragraph">
<p>同样，加法和减法动作方法可以用通用解决方案代替：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method TOP($/) {
    if $&lt;op&gt; eq '+' {
        $/.make($&lt;number&gt;[0].made + $&lt;number&gt;[1].made);
    }
    else {
        $/.make($&lt;number&gt;[0].made - $&lt;number&gt;[1].made);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>就是这样。 更新后的语法将两个测试字符串都视为有效表达式，并根据$ &lt;op&gt;的内容进行正确的计算。 当检查 <code>$&lt;op&gt; eq '+'</code> 中的条件时，eq 字符串比较运算符将 <code>$&lt;op&gt;</code> 隐式转换为字符串，并且不需要单独的操作来处理 <code>op</code> 令牌。</p>
</div>
</div>
<div class="sect2">
<h3 id="_过早的优化">3.2. 过早的优化</h3>
<div class="paragraph">
<p>有什么方法可以使代码更具吸引力？ 有几个。 我们将尝试两种方法来统一通话。 目的是避免重复长的代码行，唯一的区别是操作的符号，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$/.make($&lt;number&gt;[0].made - $&lt;number&gt;[1].made);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下，运算符都被相同的两个操作数包围，这是编写几个双函数的好机会：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class CalculatorActions {
    sub addition($a, $b) {
        $a + $b
    }

    sub subtraction($a, $b) {
        $a - $b
    }

    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这两个函数都可以放置在 CalculatorActions 类内部，并且当调用它们时，Raku 不会将指向该类实例的其他参数传递给它。 为了为这两个函数建立共同的入口点，让我们创建一个保留对它们的引用的哈希：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class CalculatorActions {
    my %operation =
        '+' =&gt; &amp;addition,
        '-' =&gt; &amp;subtraction;

    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据运算符调用函数非常容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method TOP($/) {
    $/.make(%operation{~$&lt;op&gt;}(
        $&lt;number&gt;[0].made, $&lt;number&gt;[1].made));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>简化代码并摆脱显式检查（如果检查）的另一个有趣选择是使用多个分派。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class CalculatorActions {
    multi sub operation('+', $a, $b) {
        $a + $b
    }

    multi sub operation('-', $a, $b) {
        $a - $b
    }

    method TOP($/) {
        $/.make(operation(~$&lt;op&gt;,
                          $&lt;number&gt;[0].made,
                          $&lt;number&gt;[1].made));
    }

    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，运算符被传递给操作函数，编译器选择要调用的候选对象：用加号定义的操作或需要减号作为其第一个参数的操作。 Raku 编译器很高兴为我们完成了这项工作。</p>
</div>
</div>
<div class="sect2">
<h3 id="_更多操作数">3.3. 更多操作数</h3>
<div class="paragraph">
<p>语法和动作现在已经足够聪明，可以解析和评估其中具有两个值的表达式，但不适用于1 + 2 + 3等更复杂的示例。由于TOP级别受规则限制，因此无法使用 仅两个数字：<code>&lt;number&gt; &lt;op&gt; &lt;number&gt;</code>。</p>
</div>
<div class="paragraph">
<p>在语法中，链中新的可选项目可以用 * 量词表示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    &lt;number&gt; [&lt;op&gt; &lt;number&gt; &lt;ws&gt;]*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&lt;ws&gt;</code> 令牌是用于匹配可选空格的内置工具。 通过此更改，我们还允许包含单个数字的表达式。 因此，以下测试用例全部匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @cases =
    '3 + 4', '3 - 4',
    '7',
    '1 + 2 + 3', '1 + 3 + 5 + 7';</code></pre>
</div>
</div>
<div class="paragraph">
<p>进行真实计算的两个函数还必须适用于接受两个以上的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub operation('+', @values) {
    [+] @values
}

multi sub operation('-', @values) {
    [-] @values
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此时，使用归约运算可大大简化语法。 最后，准备一个值数组，以将其传递给以下多功能之一：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method TOP($/) {
    $/.make(operation(~$&lt;op&gt;[0], $&lt;number&gt;.map: *.made));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了从 AS T树中获取数字，此处使用 map 方法。 <code>*.made</code> 结构是对 <code>$&lt;number&gt;</code> 数组的每个元素执行的 WhateverCode 块。</p>
</div>
<div class="paragraph">
<p>正如我们已经预期的那样，计算器必须使用单个数字，因此需要一个小的扩展名。 只有一个数字，表达式中没有运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method TOP($/) {
    if $&lt;op&gt; {
        $/.make(operation(~$&lt;op&gt;[0], $&lt;number&gt;.map: *.made));
    }
    else {
        $/.make($&lt;number&gt;[0].made);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行测试并检查是否正确评估了所有测试用例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">3 + 4 = 7
3 - 4 = -1
7 = 7
1 + 2 + 3 = 6
1 + 3 + 5 + 7 = 16</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_多样性测试">3.4. 多样性测试</h3>
<div class="paragraph">
<p>运算符（例如[+]）的简化形式的优美和简单性使得可以用几个字符表示动作，但无法用 <code>7 + 8 - 3</code> 等不同的运算符来评估表达式。 为了处理这样的示例，可以组织一个遍历运算符和操作数的循环。</p>
</div>
<div class="paragraph">
<p>在顶层，您必须遍历所有数字，然后将运算符带到旁边。 这是一个如何遍历值的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method TOP($/) {
    my @numbers = $&lt;number&gt;.map: *.made;
    my $make = @numbers.shift;

    operation(~$&lt;op&gt;.shift, $make, @numbers.shift)
        while @numbers.elems;

    $/.make($make);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了简化 while 循环，让操作多功能更新其参数之一：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub operation('+', $a is rw, $b) {
    $a += $b
}

multi sub operation('-', $a is rw, $b) {
    $a -= $b
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，代码看起来紧凑，更重要的是，它可以正常工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">7 + 8 - 3 = 12
14 - 4 = 10
14 - 4 - 3 = 7
100 - 200 + 300 + 1 - 2 = 199</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_增加更多数学">3.5. 增加更多数学</h3>
<div class="paragraph">
<p>计算器现在仅能进行加减运算。 好处是它可以计算包含两个以上数字的长表达式。 现在是时候教它处理乘法和除法了。</p>
</div>
<div class="paragraph">
<p>仅扩展 op 令牌以创建更多的操作函数候选者是天真的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Calculator {
    . . .

    token op {
        '+' | '-' | '*' | '/'
    }

    . . .
}

class CalculatorActions {
    . . .

    multi sub operation('*', $a is rw, $b) {
        $a *= $b
    }

    multi sub operation('/', $a is rw, $b) {
        $a /= $b
    }

    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该语法使用全部四个算术运算来解析甚至评估所有可能的表达式，但是它不遵循标准的优先级规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">3 * 4 = 12
100 / 25 = 4
1 + 2 * 3 = 9</code></pre>
</div>
</div>
<div class="paragraph">
<p>可能的解决方案之一是使用堆栈来执行计算。 您从左到右扫描输入字符串，并继续将下一个运算符应用于数字，直到遇到优先级更高的运算符为止。 在这种情况下，您将当前结果放入堆栈，并继续进行一系列新的计算，直到找到优先级较低的运算符。 然后，从堆栈中弹出数字和运算符，并将其减少，直到完全消耗掉为止。 这是在家中进行的好练习，但是我们将选择一种简单的方法。</p>
</div>
<div class="paragraph">
<p>处理算术运算优先级的另一种方法是更改语法，以使其首先提取乘法和除法运算，然后将结果传递给其余的加法和减法。</p>
</div>
<div class="paragraph">
<p>在下一个片段中，显示新语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Calculator {
    rule TOP {
        &lt;term&gt;* %% &lt;op1&gt;
    }

    rule term {
        &lt;factor&gt;* %% &lt;op2&gt;
    }

    token op1 {
        '+' | '-'
    }

    token op2 {
        '*' | '/'
    }

    rule factor {
        &lt;number&gt;
    }

    token number {
        \d+
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们检查一下。 首先，请注意我们与之前的变体相比如何更改了TOP规则。 使用%%运算符可以更轻松地表达片段重复。 比较两个正则表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;number&gt; [&lt;op&gt; &lt;number&gt; &lt;ws&gt;]*</code></pre>
</div>
</div>
<div class="paragraph">
<p>和</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;number&gt;* %% &lt;op&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二个变化是引入了两个运算符集：+和-的op1以及*和/的op2。 op1中的运算符的优先级较低，它们出现在语法的顶级规则中。 换句话说，我们认为输入表达式的总和仅包含您要加或减的数字。</p>
</div>
<div class="paragraph">
<p>乘法和除法运算符具有更高的优先级，您应该将其结果总体上视为最高级别。 这就是为什么引入令牌而不是匹配数字的原因。 最后可以是数字，但首先是由*或/分隔的一系列因素。 在我们的案例中，一个因素基本上是一个数字。 我故意添加了一个单独的代理规则，factor，以保留名称的术语和因数，您经常可以在与编译器相关的文献中看到这些规则。</p>
</div>
<div class="paragraph">
<p>在动作类中，我们已经具有四个操作功能； 我们所需要做的只是为因子添加一个简单的方法并为术语创建操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class CalculatorActions {
    . . .

    method TOP($/) {
        $/.make(process($&lt;term&gt;, $&lt;op1&gt;));
    }

    method term($/) {
        $/.make(process($&lt;factor&gt;, $&lt;op2&gt;));
    }

    sub process(@data, @ops) {
        my @nums = @data.map: *.made;
        my $result = @nums.shift;

        operation(~@ops.shift, $result, @nums.shift)
            while @nums;

        return $result;
    }

    method factor($/) {
        $/.make($&lt;number&gt;.made);
    }

    method number($/) {
        $/.make(+$/);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，TOP和term都实现相同的算法； 他们只是处理语法的不同部分（和不同的运算符）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_测试代码">3.6. 测试代码</h3>
<div class="paragraph">
<p>到目前为止，我们已经有了一个可以对表达式中任意数量的数字执行四个算术运算的计算器。 您可以提出测试用例，但您可能不想在脑海中计算出正确的结果，并对照每个测试用例进行检查。</p>
</div>
<div class="paragraph">
<p>Raku发行版包括Test模块，该模块显着有助于简化测试用例循环。 该模块会导出一些功能，我们将使用其中一个名为is的功能。 由于计算器表达式的语法与Raku的语法一致，因此让我们要求它检查结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Test;

. . .

for @cases -&gt; $test {
    my $result = Calculator.parse(
        $test, :actions(CalculatorActions)).made;
    my $correct = EVAL($result);
    is($result, $correct, "$test = $correct");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>尝试不同的测试用例，包括那些混合使用运算符的测试用例。 例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">ok 10 - 3 * 4 = 12
ok 11 - 100 / 25 = 4
ok 12 - 1 + 2 * 3 = 7
ok 13 - 1 + 2 - 3 * 4 / 5 = 0.6</code></pre>
</div>
</div>
<div class="paragraph">
<p>实际上，每个测试都必须检查两件事：1）是否对示例进行了解析，以及2）评估是否正确。 我们可以拆分测试以满足这一观察要求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @cases -&gt; $test {
    my $parse = Calculator.parse($test, :actions(CalculatorActions));
    next unless isa-ok($parse, Match, "parsed $test");

    my $result = $parse.made;
    my $correct = EVAL($result);
    is($result, $correct, "computed $test = $correct");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出将相应地更新：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">ok 1 - parsed 3 + 4
ok 2 - computed 3 + 4 = 7
ok 3 - parsed 3 - 4
ok 4 - computed 3 - 4 = -1
. . .</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_添加更多能量">3.7. 添加更多能量</h3>
<div class="paragraph">
<p>在本节中，我们将使计算器更加通用，因为我们将要添加幂运算符**。 与以前的运算符集不同的是，幂运算符具有更高的优先级，必须在进行任何乘法或加法之前首先进行处理。</p>
</div>
<div class="paragraph">
<p>可以类似于我们之前对*和/进行的操作添加操作符。 让我们替换因子规则并为运算符本身定义令牌：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule factor {
    &lt;number&gt;* %% &lt;op3&gt;
}

token op3 {
    '**'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个需要做的细微变化是在数字令牌中添加空格。 您可以明确地做到这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    &lt;ws&gt; \d+ &lt;ws&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或通过将令牌转换为规则来隐式地：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule number {
    \d+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>更新操作类以支持新的运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub operation('**', $a is rw, $b) {
    $a **= $b
}

method factor($/) {
    $/.make(process($&lt;number&gt;, $&lt;op3&gt;));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有的辛苦工作都完成了（很简单，不是吗？）。 计算器现在处理五个运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">ok 26 - parsed 2 ** 3
ok 27 - computed 2 ** 3 = 8
ok 28 - parsed 2 + 3 ** 4
ok 29 - computed 2 + 3 ** 4 = 83
ok 30 - parsed 1 + 2 * 3 ** 4 - 5 * 6
ok 31 - computed 1 + 2 * 3 ** 4 - 5 * 6 = 133
ok 32 - parsed 2 ** 3 ** 4
ok 33 - computed 2 ** 3 ** 4 = 4096</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_允许括号">3.8. 允许括号</h3>
<div class="paragraph">
<p>计算器设计的最后一点是使其理解括号。 尽管看似艰巨的任务，但实际上实现起来非常简单。 这是因为括号内的任何内容都是遵循相同语法规则的另一种表达方式。 换句话说，如果看到括号，则可以从TOP递归开始。</p>
</div>
<div class="paragraph">
<p>计算括号内的值后，您将获得一个值，因此可以将其视为任何其他数字。 要扩展解析器，只需从数字中创建一个新值规则，然后在其中列出两个备选方案：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule factor {
    &lt;value&gt;* %% &lt;op3&gt;
}

rule value {
    | &lt;number&gt;
    | '(' &lt;TOP&gt; ')'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>value</code> 方法获取上一级的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method value($/) {
    $/.make($&lt;number&gt; ?? $&lt;number&gt;.made !! $&lt;TOP&gt;.made);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而已。 仅需进行三个简单的更改，我们就可以解析更多复杂的表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">ok 34 - parsed 10 * (20 - 30)
ok 35 - computed 10 * (20 - 30) = -100
ok 36 - parsed 10 * 20 - 30
ok 37 - computed 10 * 20 - 30 = 170
ok 38 - parsed (5 * 6)
ok 39 - computed (5 * 6) = 30
ok 40 - parsed (10)
ok 41 - computed (10) = 10
ok 42 - parsed 1 - (5 * (3 + 4)) / 2
ok 43 - computed 1 - (5 * (3 + 4)) / 2 = -16.5</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的计算器已经准备好了。 在下一章中，我们将其集成到解释器中，以便它可以解析涉及变量的算术表达式。</p>
</div>
<div class="paragraph">
<p><a href="https://andrewshitov.com/2020/03/08/chapter-3-creating-a-calculator/" class="bare">https://andrewshitov.com/2020/03/08/chapter-3-creating-a-calculator/</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第四章_更好的解释器">4. 第四章 更好的解释器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章的目的是利用前三章的所有成果来构建更好的解释器。 新的解释器将能够处理不同类型的数字，并对变量执行不同的算术运算。 为了使它变得更好，我们将从一个非常有用的附加功能开始-注释。</p>
</div>
<div class="sect2">
<h3 id="_跳过注释">4.1. 跳过注释</h3>
<div class="paragraph">
<p>注释对于任何编程语言都是必不可少的，因此让我们扩展 Lingua 语法以允许在我们的程序中对人类进行注释。</p>
</div>
<div class="paragraph">
<p>首先，我们将实现一个单行注释，该注释以井号（<code>＃</code>）字符开头，并继续到该行的末尾，如下面的示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Declare a variable
my alpha;
alpha = 100; # Assign a value</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的语法规定程序是一组用分号分隔的语句。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    &lt;statement&gt;* %% ';'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>语句是以下之一：变量声明，赋值或函数调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule statement {
    | &lt;variable-declaration&gt;
    | &lt;assignment&gt;
    | &lt;function-call&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们如何在此处添加 <code>comment</code> 规则？ 注释本身可以由匹配井字符后跟任意数量的非换行符的规则表示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule comment {
    '#' \N*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>起初，您可能认为可以通过简单的方式将注释添加到 grammar 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule statement {
    | &lt;comment&gt;
    | &lt;variable-declaration&gt;
    | &lt;assignment&gt;
    | &lt;function-call&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>不幸的是，这行不通。 规则要求注释一直到行尾，而另一条规则则要求在其后加一个分号。 可能的解决方案是承认该程序不仅仅是语句列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    [
        | &lt;comment&gt;
        | &lt;statement&gt; ';'
    ]*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，该程序包含注释和语句。 后者以分号结尾。</p>
</div>
<div class="paragraph">
<p>进行此更改后，在程序末尾的最后一条语句之后必须使用分号。 这是一个棘手的时刻，让我们花一些时间正确地理解它。</p>
</div>
<div class="paragraph">
<p>编写一个包含以下三个语句的简单程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my a;
a = 10;
say a</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序的末尾没有分号，但是如果您运行它，您仍然会在输出中看到 10，就像最后一条指令也已执行一样。</p>
</div>
<div class="paragraph">
<p>实际上，grammar 无法完全解析输入文本。 您可以通过查看 <code>Calculator.parse</code> 方法的返回值轻松证明这一点，该方法对于该程序为 Nil。 因此，该语法不能确认程序的有效性，但是在解析程序时它仍然执行动作。 通过切换到实际的 AST 代，我们可以避免这种情况，我们将在以下各章中进行介绍。 同时，让我们更新解释器，以便它报告解析状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result = Lingua.parse($code, :actions(LinguaActions));
say $result ?? 'OK' !! 'Error';</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们愿意允许的第二种注释类型是一对字符序列 <code>/<strong></code> 和 <code></strong>/</code> 之间的注释。 它们既可以包含单行注释，也可以包含多行注释，并且可以出现在代码的任何允许空白的地方。 例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my /* inline comment */ a;
# one-line comment
a = 10;

/* multi-line
   comment */
say a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于您无法控制用户在何处写注释，因此该任务似乎很困难。 如前所述，在允许空白的任何地方都允许注释。 Raku 已经为我们处理了空格，因此我们也可以要求它跳过注释吗？</p>
</div>
<div class="paragraph">
<p>Grammar 中的任何规则都隐含包含用于匹配空格的正则表达式。 例如，采用 <code>assignment</code> 规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule assignment {
    &lt;variable-name&gt; '=' &lt;value&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该规则可以用带有几个嵌入式 <code>ws</code> 正则表达式的 <strong>token</strong> 替换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token assignment {
    &lt;variable-name&gt; &lt;ws&gt; '=' &lt;ws&gt; &lt;value&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有 <code>&lt;ws&gt;</code>，token 将要求您不要在等号周围使用空格。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a=10;
b=20;</code></pre>
</div>
</div>
<div class="paragraph">
<p>添加可选的空格使我们可以创建更多对人友好的程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a = 10;
b = 20;</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以重新定义 <code>ws</code> 正则表达式。 默认情况下，它匹配单词外的任意数量的空格（包括无）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">regex ws {
    &lt;!ww&gt; \s*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是定义 <code>/* */</code> 注释的理想位置。 正则表达式必须允许空格和注释定界符之间的任何文本序列：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">regex ws {
    &lt;!ww&gt; [
        | \s*
        | \s* '/*' \s* .*? \s* '*/' \s*
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于存在许多斜线和星号，因此看起来很丑陋，但是可以按预期完成工作。 注意，必须在 <code>/<strong></code> 和 <code></strong>/</code> 字面值之前和之后都留一些空格。 另请注意，此语法方法是 <strong>regex</strong>，而不是 <strong>rule</strong> 或 <strong>token</strong>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_复杂数字">4.2. 复杂数字</h3>
<div class="paragraph">
<p>解释器使用数字，我们已经可以很好地解析它。 让我们加入这两种语法，并让程序使用科学计数法处理所有数字，包括正数，负数，整数，浮点数和数字。</p>
</div>
<div class="paragraph">
<p>从第2章中获取数字语法的正文，并将其复制到 Lingua 的语法中。 Number 的 TOP 规则应成为 Lingua 中的 <strong>value</strong> 规则。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token value {
    &lt;sign&gt;? [
        | &lt;integer&gt;
        | &lt;floating-point&gt;
    ] &lt;exponent&gt;?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样不要忘记更新动作类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method value($/) {
    $/.make(+$/);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>立即尝试以下程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my alpha;
my beta;
my gamma;

alpha = 3.14;
beta = 42;
gamma = -4.5E-2;

say alpha;
say beta;
say gamma;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它应该解析数字并全部打印出来。 现在，此步骤已完全完成。</p>
</div>
</div>
<div class="sect2">
<h3 id="_复杂表达式">4.3. 复杂表达式</h3>
<div class="paragraph">
<p>我们可以轻松地采取的下一步是将计算器语法合并到语言定义中。 让我们将现有的 value 方法重命名为 number，然后语言语法将使用在 Calculator 中定义的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Lingua {
    . . .

    rule value {
        | &lt;number&gt;
        | '(' &lt;expression&gt; ')'
    }

    rule expression {
        &lt;term&gt;* %% &lt;op1&gt;
    }

    token number {
        &lt;sign&gt;? [
            | &lt;integer&gt;
            | &lt;floating-point&gt;
        ] &lt;exponent&gt;?
    }

   . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此处的表达规则是计算器语法的前 TOP 规则。 对称更新操作类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class LinguaActions {
    . . .

    method value($/) {
        $/.make($&lt;number&gt; ??
            $&lt;number&gt;.made !! $&lt;exression&gt;.made);
    }

    method expression($/) {
        $/.make(process($&lt;term&gt;, $&lt;op1&gt;));
    }

    method number($/) {
        $/.make(+$/);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此后，可以通过任意复杂度的表达式来表示程序中的任何数字。 当前语法中唯一使用数字的地方是赋值。 我们可以用表达式替换它的右侧。</p>
</div>
<div class="paragraph">
<p>在语法上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule assignment {
    &lt;variable-name&gt; '=' &lt;expression&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 action 类中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method assignment($/) {
    %var{~$&lt;variable-name&gt;} = $&lt;expression&gt;.made;
}

method value($/) {
    $/.make($&lt;number&gt; ??
        $&lt;number&gt;.made !! $&lt;expression&gt;.made);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>更改测试程序以在其中包含一些表达式。 这是我的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my pi;
pi = 22/7 - 0.001265; # very rough approximation
say pi;

my x;
x = 2 * (3 + 4);
say x; # prints 14</code></pre>
</div>
</div>
<div class="paragraph">
<p>别忘了我们也可以在代码中使用注释！</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用变量">4.4. 使用变量</h3>
<div class="paragraph">
<p>到目前为止，我们的表达式只能使用数字。 如果我们也可以在那里使用变量，那将更加方便。 为此，需要对语法进行少量更改。 就语法规则而言，在表达式中包含变量意味着允许在其中包含变量名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule value {
    | &lt;number&gt;
    | &lt;variable-name&gt;
    | '(' &lt;expression&gt; ')'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有与变量名标记关联的 made 属性，因此我们必须做一些简单的工作来访问存储：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method value($/) {
    if $&lt;number&gt; {
        $/.make($&lt;number&gt;.made);
    }
    elsif $&lt;variable-name&gt; {
        $/.make(%var{$&lt;variable-name&gt;});
    }
    else {
        $/.make($&lt;expression&gt;.made);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>值方法由三个分支组成，其任务是找到适当的数据以进一步传递。 对于变量，将进行哈希查找。</p>
</div>
<div class="paragraph">
<p>有了这些，解释器现在可以处理以下程序并计算地球赤道的长度（假设我们之前已经将值分配给pi）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my r;
r = 6371; # km

my d;
d = 2 * pi * r;
say d;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_初始化声明">4.5. 初始化声明</h3>
<div class="paragraph">
<p>希望您注意到与第一章中的内容相比，进行最新更改非常容易。 本节将带来另一个此类示例。</p>
</div>
<div class="paragraph">
<p>让我们简化变量的创建，并允许使用可选的赋值进行声明。 所以代替</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my x;
x = 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以在一行中表示两个步骤：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my x = 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>变量声明由变量声明规则处理，因此让我们使用可选的赋值子句对其进行更新：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule variable-declaration {
    'my' &lt;variable-name&gt; [ '=' &lt;expression&gt; ]?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在操作中，检查是否存在表达式，并使用其值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method variable-declaration($/) {
    %var{$&lt;variable-name&gt;} =
        $&lt;expression&gt; ?? $&lt;expression&gt;.made !! 0;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用以下附加功能重写测试程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my pi = 3.1415926;
my r = 6371; # km

my d = 2 * pi * r;
say d;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序将打印结果，而我们只有不到 200 行代码（包括空行和其中带有单个花括号的行）。 Raku 语法真的很棒！</p>
</div>
<div class="paragraph">
<p><a href="https://andrewshitov.com/2020/03/15/chapter-4-a-better-interpreter/">https://andrewshitov.com/2020/03/15/chapter-4-a-better-interpreter/</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_grammar_学习">5. Grammar 学习</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本章中，我们将回顾到目前为止已创建的语法，并将尝试进行一些更改以使语法和操作更紧凑，更易读且更加用户友好。 语言越大，保持其代码可维护性就越重要。</p>
</div>
<div class="sect2">
<h3 id="_可执行的">5.1. 可执行的</h3>
<div class="paragraph">
<p>本章要做的第一件事是使当前的解释器（成为编译器）成为适当的可执行程序，以便我们可以从命令行轻松调用它，并将包含Lingua程序的文件名传递给它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">./lingua my-prog.lng</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>lingua</code> 可执行文件必须检查您是否传递了文件名以及文件是否存在。 然后，它解析并执行输入程序。 这是完整的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use lib '.';
use Lingua;
use LinguaActions;

error('Usage: ./lingua &lt;filename&gt;') unless @*ARGS.elems;

my $filename = @*ARGS[0];
error("Error: File $filename not found") unless $filename.IO.f;

my $code = $filename.IO.slurp();
my $result = Lingua.parse($code, :actions(LinguaActions));
say $result ?? 'OK' !! error('Error: parse failed');

sub error($message) {
    note $message;
    exit;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>错误函数将显示错误消息并终止程序。 它使用 <code>note</code> 内置函数，其行为类似于 <code>say</code>，但是将输出发送到标准错误流。 这里不使用 <code>die</code> 例程，因为它会打印有关错误位置的其他信息，在这种情况下并不需要。 抑制裸片的额外输出所需的行数与引入新功能所需的行数大致相同。</p>
</div>
</div>
<div class="sect2">
<h3 id="_组合和继承_grammar">5.2. 组合和继承 Grammar</h3>
<div class="paragraph">
<p>在 Lingua 语言中，我们允许以＃字符开头的单行注释，以及 <code>/<strong></code> 和 <code></strong>/</code> 之间的内联和多行注释。 这样的注释也用在其他编程语言中，从语言语法中提取注释规则并将其放在单独的类中可能很有用。 这也使主要语言语法更小，更透明。</p>
</div>
<div class="paragraph">
<p>让我们回顾一下处理注释的现有 <code>Lingua</code> 语法的片段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Lingua {
    rule TOP {
        [
            | &lt;comment&gt;
            | &lt;statement&gt; ';'
        ]*
    }

    rule comment {
        '#' \N*
    }

    regex ws {
        &lt;!ww&gt; [
            | \s*
            | \s* '/*' \s* .*? \s* '*/' \s*
        ]
    }

    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中大多数可以放到单独的 grammar 类中。 明智地将两种类型的注释区分开来也是明智的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar CommentableLanguage {
    regex ws {
        &lt;!ww&gt; [
            | \s*
            | \s* &lt;inline-comment&gt; \s*
        ]
    }

    regex inline-comment {
        '/*' \s* .*? \s* '*/'
    }

    rule one-line-comment {
        '#' \N*
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>CommentableLanguage</code> 语法仅知道如何处理注释，但是由于它现在位于单独的类中，因此它可以作为另一种语言定义的基础。 在我们的例子中，Lingua 可以从中得出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use CommentableLanguage;

grammar Lingua is CommentableLanguage {
    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您将 <code>CommentableLanguage</code> 类放在单独的文件中，则 <code>use</code> 语句是必需的。</p>
</div>
<div class="paragraph">
<p>在 <code>Lingua</code> 中，现在唯一需要做的更改是在主代码中为单行注释使用专有名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    [
        | &lt;one-line-comment&gt;
        | &lt;statement&gt; ';'
    ]*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其余所有操作都是自动完成的。 例如，现在 Raku 的 Grammar 类的默认 <code>ws</code> 正则表达式已替换为 <code>CommentableLanguage</code> 中的 <code>ws</code>。</p>
</div>
<div class="paragraph">
<p>我们可以通过提取负责解析数字的部分来进一步简化主要语法。 与注释一样，该部分也可以放在单独的类中。 但是，在这种情况下，最好使其成为角色并将其保存在单独的文件中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Number {
    token number {
        &lt;sign&gt;? [
            | &lt;integer&gt;
            | &lt;floating-point&gt;
        ] &lt;exponent&gt;?
    }

    token sign {
        &lt;[+-]&gt;
    }

    token exp {
        &lt;[eE]&gt;
    }

    token integer {
        \d+
    }

    token floating-point {
        &lt;integer&gt;? ['.' &lt;integer&gt;]
    }

    token exponent {
        &lt;exp&gt; &lt;sign&gt;? &lt;integer&gt;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以后，如果需要，您可以轻松修改 <code>Number</code> 角色以允许程序中使用其他类型的数字。 要将其附加到 <code>Lingua</code> 语法，请使用 <code>does</code> 关键字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use CommentableLanguage;
use Number;

grammar Lingua is CommentableLanguage does Number {
    . . .
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_复习计算器">5.3. 复习计算器</h3>
<div class="paragraph">
<p>来自计算器的语法部分包括彼此相似的一些部分。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
    &lt;term&gt;* %% &lt;op1&gt;
}

rule term {
    &lt;factor&gt;* %% &lt;op2&gt;
}

rule factor {
    &lt;value&gt;* %% &lt;op3&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是首先，让我们考虑一下其中的量词。 星号允许任意多次重复的项，因数或值。 如果程序不包含任何内容，例如，如下所示，该怎么办：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my x;
x = ;
say x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这显然是错误的，但是 <code>Lingua</code> 语法不会返回 <code>Nil</code>。 它较早失败，从 Raku 产生了不希望的混乱输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Cannot shift from an empty Array
  in sub process at /Users/ash/lingua/LinguaActions.rakumod (LinguaActions) line 52
  in method factor at /Users/ash/lingua/LinguaActions.rakumod (LinguaActions) line 46
  in regex factor at /Users/ash/lingua/Lingua.rakumod (Lingua) line 48
  in regex term at /Users/ash/lingua/Lingua.rakumod (Lingua) line 44
  in regex expression at /Users/ash/lingua/Lingua.rakumod (Lingua) line 40
  in regex assignment at /Users/ash/lingua/Lingua.rakumod (Lingua) line 23
  in regex statement at /Users/ash/lingua/Lingua.rakumod (Lingua) line 13
  in regex TOP at /Users/ash/lingua/Lingua.rakumod (Lingua) line 6
  in block &lt;unit&gt; at ./lingua line 13

Actually thrown at:
  in method function-call at /Users/ash/lingua/LinguaActions.rakumod (LinguaActions) line 13
  in regex function-call at /Users/ash/lingua/Lingua.rakumod (Lingua) line 27
  in regex statement at /Users/ash/lingua/Lingua.rakumod (Lingua) line 13
  in regex TOP at /Users/ash/lingua/Lingua.rakumod (Lingua) line 6
  in block &lt;unit&gt; at ./lingua line 13</code></pre>
</div>
</div>
<div class="paragraph">
<p>这不是用户想要看到的。 编译器坏了，没有生成错误消息。 我们必须更改语法，并在期望表达的地方至少要求一个值。 最简单的修改是将 <code>*</code> 替换为 <code>+</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
    &lt;term&gt;+ %% &lt;op1&gt;
}

rule term {
    &lt;factor&gt;+ %% &lt;op2&gt;
}

rule factor {
    &lt;value&gt;+ %% &lt;op3&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们自己控制错误消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Error: parse failed</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用_multi_rules">5.4. 使用 MULTI-RULES</h3>
<div class="paragraph">
<p>表达式，项和因数这三个规则都具有相同的模式：一个规则重复两次，中间使用一个运算符。 我们可以使用Raku提供的用于类（因此用于语法）的多种方法来统一它们。 代替三个不同的标记 <code>op1</code>，<code>op2</code> 和 <code>op3</code>，让我们通过指定一个整数参数及其值来创建一个名称和三个选择。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi token op(1) {
    '+' | '-'
}

multi token op(2) {
    '*' | '/'
}

multi token op(3) {
    '**'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>值1到3对于语法本身并不重要； 对我们来说，它表示运营商的优先级：数字越大，优先级越高。</p>
</div>
<div class="paragraph">
<p>我们还必须使用这些运算符来更新上述规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
    &lt;term&gt;+ %% &lt;op(1)&gt;
}

rule term {
    &lt;factor&gt;+ %% &lt;op(2)&gt;
}

rule factor {
    &lt;value&gt;+ %% &lt;op(3)&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在操作中，我们将看不到参数值以及带有简单 <code>op</code> 的所有名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method expression($/) {
    $/.make(process($&lt;term&gt;, $&lt;op&gt;));
}

method term($/) {
    $/.make(process($&lt;factor&gt;, $&lt;op&gt;));
}

method factor($/) {
    $/.make(process($&lt;value&gt;, $&lt;op&gt;));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里可以清楚地看到动作方法是相同的，因此我们可以进一步减少代码，但首先，让我们尝试运行测试程序以确认转换的第一部分可以工作。</p>
</div>
<div class="paragraph">
<p>让我们继续并将这三个规则和这三种方法折叠为一条规则及其相应的通用方法。 再次，使用多方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
    &lt;expr(1)&gt;
}

multi rule expr(1) {
    &lt;expr(2)&gt;+ %% &lt;op(1)&gt;
}

multi rule expr(2) {
    &lt;expr(3)&gt;+ %% &lt;op(2)&gt;
}

multi rule expr(3) {
    &lt;expr(4)&gt;+ %% &lt;op(3)&gt;
}

multi rule expr(4) {
    | &lt;number&gt;
    | &lt;variable-name&gt;
    | '(' &lt;expression&gt; ')'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这次，变化更大了。 我们引入了新的多规则 <code>expr</code>，它取代了 <code>term</code> 和 <code>factor</code>。 为了使 <code>expr</code> 方法统一，将 <code>value</code> 方法替换为 <code>expr(4)</code>。 这样做是为了能够从成为 <code>expr(3)</code> 的前一个因素访问作为 <code>expr(4)</code> 的前一个值。</p>
</div>
<div class="paragraph">
<p>之后，可以将带有参数 1、2和3的前三个 <code>expr</code> 备选方案替换为具有 <code>$n + 1</code> 的简单数学运算的单个通用规则，从而使我们进入下一个层次。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi rule expr($n) {
    &lt;expr($n + 1)&gt;+ %% &lt;op($n)&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，语法包括两个选择：<code>expr($n)</code> 和 <code>expr(4)</code>。 当解析器达到第三级时，它接下来将选择一个更具体的 <code>expr(4)</code> 替代方案，从而停止递归。</p>
</div>
<div class="paragraph">
<p>在动作类中，保留以下两种方法； 它们替换了方法的表达式，项，因子和值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method expression($/) {
    $/.make($&lt;expr&gt;.made);
}

method expr($/) {
    if $&lt;number&gt; {
        $/.make($&lt;number&gt;.made);
    }
    elsif $&lt;variable-name&gt; {
        $/.make(%var{$&lt;variable-name&gt;});
    }
    elsif $&lt;expr&gt; {
        $/.make(process($&lt;expr&gt;, $&lt;op&gt;));
    }
    else {
        $/.make($&lt;expression&gt;.made);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>起初，似乎我们使语法和动作的透明度降低了，但是如果您需要引入更多的运算符，则只需在语法中添加新的 <code>op(n)</code> 规则，并将其添加到动作类中 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_摆脱全局变量">5.5. 摆脱全局变量</h3>
<div class="paragraph">
<p>为了存储变量值，我们使用了全局哈希 <code>%var</code>。 让我们使程序更加美观，然后将存储空间作为数据成员移至 <code>action</code> 类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class LinguaActions {
    has %!var;

    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，您应该立即将所有出现的 <code>%var</code> 替换为 <code>%!var</code>，例如，在赋值操作中(LinguaActions 类中还有三个此类位置)：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method assignment($/) {
    %!var{~$&lt;variable-name&gt;} = $&lt;expression&gt;.made;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，由于我们需要在内存中放置哈希值，因此您需要在调用parse方法之前实例化action类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result = Lingua.parse($code,
                          :actions(LinguaActions.new));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_更好的变量名">5.6. 更好的变量名</h3>
<div class="paragraph">
<p>在本章结束之前，让我们再进行一些小的但非常有效的补充。 之前，我们制作了一个临时令牌来解析变量名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token variable-name {
    \w+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该令牌与所谓的单词字符匹配，其中包括字母，数字和下划线字符。 这种简单解决方案的缺点是，它允许使用数字作为变量名称的第一个字符，并且以下代码在形式上在语法上是正确的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my 4 = 3;
say 4;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了解决这种情况，让我们使用与字母匹配的预定义令牌：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token variable-name {
    [&lt;:alpha&gt; | '_'] \w*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，变量名只能以字母或下划线字符开头，然后是由任何单词字符组成的可选部分。 例如，以前的错误程序可以这样转换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my var_4 = 3;
say var_4;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_函数接收表达式">5.7. 函数接收表达式</h3>
<div class="paragraph">
<p>仍然保留在语法中的另一个即席解决方案是函数调用。 它只能以变量名作为参数。 我们将为功能专门介绍一章，但现在，让我们允许以下调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 42;
say 100 + 300 / 3 ** (7 - 5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>将表达式而不是变量传递给函数。 因此，更新函数调用规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule function-call {
    &lt;function-name&gt; &lt;expression&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该操作还需要更新。 很棒的事情是，通过切换到表达式，我们使操作更加简单。 这是以前的样子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method function-call($/) {
    say %!var{$&lt;variable-name&gt;} if $&lt;function-name&gt; eq 'say';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是现在的样子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method function-call($/) {
    say $&lt;expression&gt;.made;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>函数仅使用在其他位置计算出的值，而不进行任何变量检查。</p>
</div>
<div class="paragraph">
<p>在本章中，对语法及其相关代码进行了许多转换。 这使语法变得更加透明，甚至允许我们添加一些不错的扩展。 请查阅<a href="https://github.com/ash/lingua/commits/master">仓库</a>以确保我们位于同一页面上。</p>
</div>
</div>
</div>
</div>

</article>


    

  </main><section class="site__search">
    <label class="site__form">
        <p class="form__label">Search around the site</p> 
        <input class="site__search-bar form__input" type="text">
    </label>
    <div class="site__search-bar-results"></div>
</section>
  
  <footer class="site__footer">
    
    
    <p class="footer__sign">© 2020 ohmyraku</p></footer>
    

    
    <script>
        window.addEventListener("load", function () {
            const script = document.createElement("script");
            script.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
            script.async = true

            document.head.appendChild(script);
        })
    </script>





<script defer type="text/javascript" src="https://ohmyraku.github.io/js/script.14164ab553b19613ce98aadb54b1ed9a89ae5b056c72b99a4c672e37954f33d67bebe1452b0279025ba889964b51bdf8ec69683933cf427ae67c08ac2cdda7b1.js" integrity="sha512-FBZKtVOxlhPOmKrbVLHtmomuWwVscrmaTGcuN5VPM9Z76&#43;FFKwJ5AluoiZZLUb347GloOTPPQnrmfAisLN2nsQ=="></script>



</body>
</html>