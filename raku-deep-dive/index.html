<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title> :: 山川异域, 风月同天</title>

<meta name="author" content="ohmyraku">
<meta name="application-name" content="山川异域, 风月同天">
<meta name="description" content="Table of Contents 1. 什么是 Raku 1.1. Raku 起源 1.2. 与 Perl 5 的区别 1.3. Raku 资源 1.4. 编译器 1.5. 使用 Rakudo Star 1.6. 写出我们的 Hello, World 程序 1.7. 总结   2. 写代码 2.1. 使用 Unicode 2.2. 空白和反空白 2.3. 注释 2.4. 移相器 2.5. 总结   3. 变量和内置数据类型 3.1. 使用变量 3.2. 使用简单的内置数据类型 3.3. 操作日期和时间的数据类型 3.4. 总结 3.5. 总结   4. 使用运算符 4.1. 运算符分类 4.2. Raku 中的运算符 4.3. Raku 中的元运算符 4.">
<meta name="robots" content="noodp"/>
<meta name="generator" content="Hugo 0.63.2" />
<meta name="referrer" content="no-referrer" />
<meta name="format-detection" content="telephone=no">

<link rel="canonical" href="https://ohmyraku.github.io/raku-deep-dive/" />


<link rel="icon" href="https://ohmyraku.github.io/logo.png" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="" />
<meta name="twitter:description" content="Table of Contents 1. 什么是 Raku 1.1. Raku 起源 1.2. 与 Perl 5 的区别 1.3. Raku 资源 1.4. 编译器 1.5. 使用 Rakudo Star 1.6. 写出我们的 Hello, World 程序 1.7. 总结   2. 写代码 2.1. 使用 Unicode 2.2. 空白和反空白 2.3. 注释 2.4. 移相器 2.5. 总结   3. 变量和内置数据类型 3.1. 使用变量 3.2. 使用简单的内置数据类型 3.3. 操作日期和时间的数据类型 3.4. 总结 3.5. 总结   4. 使用运算符 4.1. 运算符分类 4.2. Raku 中的运算符 4.3. Raku 中的元运算符 4." />
<meta name="twitter:site" content="https://ohmyraku.github.io" />
<meta name="twitter:creator" content="ohmyraku" />
<meta name="twitter:image" content="https://ohmyraku.github.io/logo.png">
<meta property="og:type" content="article" />
<meta property="og:locale" content="en" />
<meta property="og:name" content="ohmyraku" />
<meta property="og:title" content="" />
<meta property="og:url" content="https://ohmyraku.github.io" />
<meta property="og:site_name" content="山川异域, 风月同天" />
<meta property="og:description" content="Table of Contents 1. 什么是 Raku 1.1. Raku 起源 1.2. 与 Perl 5 的区别 1.3. Raku 资源 1.4. 编译器 1.5. 使用 Rakudo Star 1.6. 写出我们的 Hello, World 程序 1.7. 总结   2. 写代码 2.1. 使用 Unicode 2.2. 空白和反空白 2.3. 注释 2.4. 移相器 2.5. 总结   3. 变量和内置数据类型 3.1. 使用变量 3.2. 使用简单的内置数据类型 3.3. 操作日期和时间的数据类型 3.4. 总结 3.5. 总结   4. 使用运算符 4.1. 运算符分类 4.2. Raku 中的运算符 4.3. Raku 中的元运算符 4." />
<script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "Article",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https:\/\/ohmyraku.github.io\/raku-deep-dive\/"
      },
      "headline": "",
      
      "datePublished": "0001-01-01",
      "dateModified": "0001-01-01 00:00:00 \x2b0000 UTC",
      "author": {
        "@type": "Person",
        "name": "ohmyraku"
      },
      "description": "Table of Contents 1. 什么是 Raku 1.1. Raku 起源 1.2. 与 Perl 5 的区别 1.3. Raku 资源 1.4. 编译器 1.5. 使用 Rakudo Star 1.6. 写出我们的 Hello, World 程序 1.7. 总结   2. 写代码 2.1. 使用 Unicode 2.2. 空白和反空白 2.3. 注释 2.4. 移相器 2.5. 总结   3. 变量和内置数据类型 3.1. 使用变量 3.2. 使用简单的内置数据类型 3.3. 操作日期和时间的数据类型 3.4. 总结 3.5. 总结   4. 使用运算符 4.1. 运算符分类 4.2. Raku 中的运算符 4.3. Raku 中的元运算符 4.",
      "publisher": {
        "@type": "Organization",
        "name": "https:\/\/ohmyraku.github.io",
        "logo": {
          "@type": "ImageObject",
          "url": "https:\/\/ohmyraku.github.io\/logo.png"
        }
      }
    }
</script><link rel="stylesheet" href="https://ohmyraku.github.io/scss/main.min.84f71d25d375c522a861bb4719728ce6839cf3635b15ca0c7a1b4d799c2dc3399a1d6cb46058a9d8fdbebe9156a8857279cfdeb70aa3862e629de234b5a41fa1.css" integrity="sha512-hPcdJdN1xSKoYbtHGXKM5oOc82NbFcoMehtNeZwtwzmaHWy0YFip2P2&#43;vpFWqIVyec/etwqjhi5ineI0taQfoQ==">
<script>

const theme = window.localStorage.getItem('theme'); 
if (theme && theme !== "1") {
    document.documentElement.classList.add('theme-' + theme);
}
</script>


</head>
<body>
  <main class="site__content">
    <div class="site__page">
  <nav class="site__breadcrumbs">
    <a class="site__breadcrumb" href="https://ohmyraku.github.io/">山川异域, 风月同天</a><a class="site__breadcrumb--active" href="https://ohmyraku.github.io/raku-deep-dive/"></a>
</nav>

<h1 class="page__title"></h1>
  <div class="page__meta">
    <p>
    
    <span class="page__date">
    on <time datetime="0001-01-01T00:00:00Z">0001-01-01</time>
    
    </span>
    </p>

    

    
    </div>
</div>


</div>

<article class="page__content" ><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_什么是_raku">1. 什么是 Raku</a>
<ul class="sectlevel2">
<li><a href="#_raku_起源">1.1. Raku 起源</a></li>
<li><a href="#_与_perl_5_的区别">1.2. 与 Perl 5 的区别</a></li>
<li><a href="#_raku_资源">1.3. Raku 资源</a></li>
<li><a href="#_编译器">1.4. 编译器</a></li>
<li><a href="#_使用_rakudo_star">1.5. 使用 Rakudo Star</a></li>
<li><a href="#_写出我们的_hello_world_程序">1.6. 写出我们的 Hello, World 程序</a></li>
<li><a href="#_总结">1.7. 总结</a></li>
</ul>
</li>
<li><a href="#_写代码">2. 写代码</a>
<ul class="sectlevel2">
<li><a href="#_使用_unicode">2.1. 使用 Unicode</a></li>
<li><a href="#_空白和反空白">2.2. 空白和反空白</a></li>
<li><a href="#_注释">2.3. 注释</a></li>
<li><a href="#_移相器">2.4. 移相器</a></li>
<li><a href="#_总结_2">2.5. 总结</a></li>
</ul>
</li>
<li><a href="#_变量和内置数据类型">3. 变量和内置数据类型</a>
<ul class="sectlevel2">
<li><a href="#_使用变量">3.1. 使用变量</a></li>
<li><a href="#_使用简单的内置数据类型">3.2. 使用简单的内置数据类型</a></li>
<li><a href="#_操作日期和时间的数据类型">3.3. 操作日期和时间的数据类型</a></li>
<li><a href="#_总结_3">3.4. 总结</a></li>
<li><a href="#_总结_4">3.5. 总结</a></li>
</ul>
</li>
<li><a href="#_使用运算符">4. 使用运算符</a>
<ul class="sectlevel2">
<li><a href="#_运算符分类">4.1. 运算符分类</a></li>
<li><a href="#_raku_中的运算符_2">4.2. Raku 中的运算符</a></li>
<li><a href="#_raku_中的元运算符">4.3. Raku 中的元运算符</a></li>
<li><a href="#_用户定义的运算符">4.4. 用户定义的运算符</a></li>
<li><a href="#_总结_5">4.5. 总结</a></li>
</ul>
</li>
<li><a href="#_控制流">5. 控制流</a>
<ul class="sectlevel2">
<li><a href="#_理解代码块和变量作用域">5.1. 理解代码块和变量作用域</a></li>
<li><a href="#_条件检查">5.2. 条件检查</a></li>
<li><a href="#_使用循环">5.3. 使用循环</a></li>
<li><a href="#_只执行代码一次">5.4. 只执行代码一次</a></li>
<li><a href="#_用_gather_和_take_收集数据">5.5. 用 gather 和 take 收集数据</a></li>
<li><a href="#_用_given_设置主题">5.6. 用 given 设置主题</a></li>
<li><a href="#_总结_6">5.7. 总结</a></li>
</ul>
</li>
<li><a href="#_子例程">6. 子例程</a>
<ul class="sectlevel2">
<li><a href="#_默认值">6.1. 默认值</a></li>
<li><a href="#_可选参数">6.2. 可选参数</a></li>
<li><a href="#_命名参数">6.3. 命名参数</a></li>
<li><a href="#_参数特征">6.4. 参数特征</a></li>
<li><a href="#_吞噬参数">6.5. 吞噬参数</a></li>
<li><a href="#_参数占位符">6.6. 参数占位符</a></li>
<li><a href="#_类型约束">6.7. 类型约束</a></li>
<li><a href="#_返回类型">6.8. 返回类型</a></li>
<li><a href="#_multi_subs">6.9. Multi Subs</a></li>
<li><a href="#_一个例子">6.10. 一个例子</a></li>
<li><a href="#_嵌套的子程序">6.11. 嵌套的子程序</a></li>
<li><a href="#_总结_7">6.12. 总结</a></li>
<li><a href="#_创建和调用子例程">6.13. 创建和调用子例程</a></li>
<li><a href="#_类型约束_2">6.14. 类型约束</a></li>
<li><a href="#_multi_subs_2">6.15. Multi subs</a></li>
<li><a href="#_嵌套子例程">6.16. 嵌套子例程</a></li>
<li><a href="#_创建运算符">6.17. 创建运算符</a></li>
<li><a href="#_传递函数作为参数">6.18. 传递函数作为参数</a></li>
<li><a href="#_匿名子例程">6.19. 匿名子例程</a></li>
<li><a href="#_总结_8">6.20. 总结</a></li>
</ul>
</li>
<li><a href="#_模块">7. 模块</a>
<ul class="sectlevel2">
<li><a href="#_创建模块">7.1. 创建模块</a></li>
<li><a href="#_使用模块">7.2. 使用模块</a></li>
<li><a href="#_内省">7.3. 内省</a></li>
<li><a href="#_使用_zef">7.4. 使用 zef</a></li>
<li><a href="#_总结_9">7.5. 总结</a></li>
</ul>
</li>
<li><a href="#_面向对象编程">8. 面向对象编程</a>
<ul class="sectlevel2">
<li><a href="#_创建类">8.1. 创建类</a></li>
<li><a href="#_使用属性">8.2. 使用属性</a></li>
<li><a href="#_使用方法">8.3. 使用方法</a></li>
<li><a href="#_再谈属性">8.4. 再谈属性</a></li>
<li><a href="#_类方法">8.5. 类方法</a></li>
<li><a href="#_继承">8.6. 继承</a></li>
<li><a href="#_使用角色追加对象和类">8.7. 使用角色追加对象和类</a></li>
<li><a href="#_使用内省学习更多">8.8. 使用内省学习更多</a></li>
<li><a href="#_方法后缀运算符">8.9. 方法后缀运算符</a></li>
<li><a href="#_总结_10">8.10. 总结</a></li>
</ul>
</li>
<li><a href="#_输入和输出">9. 输入和输出</a>
<ul class="sectlevel2">
<li><a href="#_从流中读取">9.1. 从流中读取</a></li>
<li><a href="#_写出到流">9.2. 写出到流</a></li>
<li><a href="#_标准输入和输出">9.3. 标准输入和输出</a></li>
<li><a href="#_使用文件和目录">9.4. 使用文件和目录</a></li>
<li><a href="#_从流中读取_2">9.5. 从流中读取</a></li>
<li><a href="#_写入流">9.6. 写入流</a></li>
<li><a href="#_总结_11">9.7. 总结</a></li>
</ul>
</li>
<li><a href="#_异常">10. 异常</a>
<ul class="sectlevel2">
<li><a href="#_try_块">10.1. try 块</a></li>
<li><a href="#_catch_phaser">10.2. CATCH phaser</a></li>
<li><a href="#_exception_对象">10.3. Exception 对象</a></li>
<li><a href="#_failure_对象">10.4. Failure 对象</a></li>
<li><a href="#_创建自定义异常">10.5. 创建自定义异常</a></li>
<li><a href="#_总结_12">10.6. 总结</a></li>
<li><a href="#_总结_13">10.7. 总结</a></li>
</ul>
</li>
<li><a href="#_正则表达式">11. 正则表达式</a>
<ul class="sectlevel2">
<li><a href="#_与正则表达式匹配">11.1. 与正则表达式匹配</a></li>
<li><a href="#_字面量">11.2. 字面量</a></li>
<li><a href="#_字符类">11.3. 字符类</a></li>
<li><a href="#_使用量词创建可重复模式">11.4. 使用量词创建可重复模式</a></li>
<li><a href="#_使用捕获提取子字符串">11.5. 使用捕获提取子字符串</a></li>
<li><a href="#_在正则表达式中使用备选项">11.6. 在正则表达式中使用备选项</a></li>
<li><a href="#_用锚点定位正则表达式">11.7. 用锚点定位正则表达式</a></li>
<li><a href="#_使用断言进行向前查看和向后查看">11.8. 使用断言进行向前查看和向后查看</a></li>
<li><a href="#_使用副词修饰正则表达式">11.9. 使用副词修饰正则表达式</a></li>
<li><a href="#_使用正则表达式替换和修改字符串">11.10. 使用正则表达式替换和修改字符串</a></li>
<li><a href="#_总结_14">11.11. 总结</a></li>
</ul>
</li>
<li><a href="#_grammars">12. Grammars</a>
<ul class="sectlevel2">
<li><a href="#_创建_grammar">12.1. 创建 grammar</a></li>
<li><a href="#_使用_rules_和_tokens">12.2. 使用 rules 和 tokens</a></li>
<li><a href="#_使用_actions">12.3. 使用 actions</a></li>
<li><a href="#_使用抽象语法树">12.4. 使用抽象语法树</a></li>
<li><a href="#_使用_action_类">12.5. 使用 action 类</a></li>
<li><a href="#_完整的程序">12.6. 完整的程序</a></li>
<li><a href="#_总结_15">12.7. 总结</a></li>
</ul>
</li>
<li><a href="#_并发编程">13. 并发编程</a>
<ul class="sectlevel2">
<li><a href="#_junction">13.1. Junction</a></li>
<li><a href="#_线程">13.2. 线程</a></li>
<li><a href="#_终身线程">13.3. 终身线程</a></li>
<li><a href="#_promise">13.4. Promise</a></li>
<li><a href="#_通道">13.5. 通道</a></li>
<li><a href="#_总结_16">13.6. 总结</a></li>
</ul>
</li>
<li><a href="#_函数式编程">14. 函数式编程</a>
<ul class="sectlevel2">
<li><a href="#_什么是函数式编程">14.1. 什么是函数式编程</a></li>
<li><a href="#_使用递归">14.2. 使用递归</a></li>
<li><a href="#_使用化简">14.3. 使用化简</a></li>
<li><a href="#_高阶函数和_lambdas">14.4. 高阶函数和 lambdas</a></li>
<li><a href="#_管道数据和_feed_运算符">14.5. 管道数据和 feed 运算符</a></li>
<li><a href="#_操作作用域">14.6. 操作作用域</a></li>
<li><a href="#_创建并使用迭代器">14.7. 创建并使用迭代器</a></li>
<li><a href="#_惰性和无限列表">14.8. 惰性和无限列表</a></li>
<li><a href="#_总结_17">14.9. 总结</a></li>
</ul>
</li>
<li><a href="#_反应式编程">15. 反应式编程</a>
<ul class="sectlevel2">
<li><a href="#_什么是反应式编程">15.1. 什么是反应式编程</a></li>
<li><a href="#_按需供应">15.2. 按需供应</a></li>
<li><a href="#_现场供应">15.3. 现场供应</a></li>
<li><a href="#_总结_18">15.4. 总结</a></li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_什么是_raku">1. 什么是 Raku</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本章中，我们将研究 Raku 出现的原因并追寻语言发展的历史。您将看到一些从 Perl 5 开始具有变化的示例，你将学习如何下载和使用编译器，在哪里查找文档，以及如何在 Raku 中运行您的第一个程序。</p>
</div>
<div class="paragraph">
<p>在本章中，我们将介绍以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku 的起源</p>
</li>
<li>
<p>与 Perl 5 的不同之处</p>
</li>
<li>
<p>Raku 资源</p>
</li>
<li>
<p>编译器</p>
</li>
<li>
<p>使用 Rakudo Star</p>
</li>
<li>
<p>编写我们的 Hello World 程序</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_raku_起源">1.1. Raku 起源</h3>
<div class="paragraph">
<p>Raku 是 Perl 系列的编程语言。Perl 本身出现于 1987 年, 从那开始，它不断发展: 它目前的稳定版本是于 2017 年 5 月发布的 5.26，2000 年, Perl 的创建者 Larry Wall 提议开始研究语言的下一个版本 - 即 Raku。</p>
</div>
<div class="paragraph">
<p>这有几个原因。首先，语言应该继续发展以反映开发人员的新要求。其次，它可能会改变非 Perl 社区的人们对 Perl 的看法 。Perl 5.0 出现在 1993 年，尽管如此，该语言还在继续发展。Perl 的主版本号仍然是 5，在许多人的眼中，这意味着自 1993 年以来 Perl 一直处于停滞状态。新的主要版本更新将会刷新这个感知。</p>
</div>
<div class="paragraph">
<p>这个想法是让 Raku 成为"Perl 社区的重写"。拉里要求社区分享他们想要改变的 Perl 的部分。变更请求导致了 361 份 RFC (请求评论)文档，这些文档公布在 <a href="https://raku.org/archive/rfc" class="bare">https://raku.org/archive/rfc</a> 中。这些文件仅具有历史意义。</p>
</div>
<div class="paragraph">
<p>随后，系统地分析了各种提案，并通过将类似的主题组合在一起并作为一系列概要发布。这些文档背后的命名和编号原则是为了保留 Programming Perl 书籍章节的结构。</p>
</div>
<div class="paragraph">
<p>后来，在一组名为启示录和解释的文件中再次总结和解释了概要。所有这些论文今天都在 <a href="http://design.raku.org，但同样，它们不是语言的最终规范，只是一个历史文档的集合。" class="bare">http://design.raku.org，但同样，它们不是语言的最终规范，只是一个历史文档的集合。</a></p>
</div>
<div class="paragraph">
<p>关于 Raku 的另一个重要思想是关于编译器的创建方式。在 Perl 5 中， 语言规则由单个可用编译器间接定义。一些错误，或编译器的不明显行为，可能被视为语言标准的一部分。在 Raku 中，决定有一个清晰的语言规范，没有参考编译器。 可以有多个编译器。他们的主要要求是实现规范并通过一组测试。</p>
</div>
</div>
<div class="sect2">
<h3 id="_与_perl_5_的区别">1.2. 与 Perl 5 的区别</h3>
<div class="paragraph">
<p>让我们简单地看一下在 Raku 的路上发生的一些变化。在以下部分中，您将看到 Perl 5 和 Raku 中的一些代码示例。有关 Perl 5 如何转换为 Raku 的一般理解，但您并不期望了解它的每一点。关于 Raku 语法的所有细节将在本书的后面解释。</p>
</div>
<div class="sect3">
<h4 id="_符号">1.2.1. 符号</h4>
<div class="paragraph">
<p>Perl 新手最困难的事情之一就是符号。符号是 Perl 变量名前面的一个字符，表示变量的结构类型。例如，<code>$</code> 表示标量值，<code>@</code> 表示数组，<code>%</code> 表示哈希。</p>
</div>
<div class="paragraph">
<p>访问数组或散列的元素时会出现问题。让我们考虑一下以下 Perl 5代码, 数组的前几个数是波那契数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @fibonacci = (0, 1, 1, 2, 3, 5, 8, 13);
print $fibonacci[4];</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，创建一个 <code>@fibonacci</code> 数组。变量的名称包含 <code>@</code> 字符作为符号。在第二行中，我们访问该数组的一个元素, 这一次使用另一个符号 <code>$</code>。这是因为数组中的单个元素是标量，而标量使用 <code>$</code> 作为符号。 对于那些学习 Perl 的人来说，这个小小的变化是理解该语言基础知识的一个大问题。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，符号是统一的，是变量名的一部分。你不用单独改变它，无论是访问数组的元素还是整个数组。前面的例子在 Raku 中将如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @fibonacci = (0, 1, 1, 2, 3, 5, 8, 13);
print @fibonacci[4];</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两行中，<code>@fibonacci</code> 数组和它的 <code>@fibonacci[4]</code> 元素使用同一个符号。这种方法更加一致，对初学者更容易。</p>
</div>
</div>
<div class="sect3">
<h4 id="_签名">1.2.2. 签名</h4>
<div class="paragraph">
<p>在Perl 5中，您必须使用自己提取函数参数的值 内置移位功能，或默认的@_数组。
让我们在下面的例子中看到这个，用一个函数来计算它们的总和 参数。在Perl 5中，你必须做一些额外的工作来获得实际的传递 参数。
首先，在Perl 5中获取带有shift的参数值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，通过使用@_数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>与许多其他编程语言不同，无法声明列表 函数的形式参数直接。例如，这是你用C或C ++做的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在Perl 5中，可以限制参数的数量及其结构类型 原型的帮助。在那里使用Sigil来告诉Perl参数的类型。该 用于添加的前置函数在Perl 5中可能如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用函数原型将使编译器在使用函数时发出抱怨
不同数量的参数(比如，一个或三个而不是两个)，但你仍然必须这样做
自己获得他们的价值观
Perl 5.20引入了功能签名。所以，现在，你可以从声明中获益 争论一气呵成。以下代码给出了此类方法的示例。$ x和</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">使用特征qw(签名); 没有警告qw(experimental </dt>
<dd>
<p>signature);</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>您会注意到，您需要通过提及指示Perl使用Perl 5.20的功能 脚本中的最小版本号。您还会注意到必须激活</p>
</div>
<div class="paragraph">
<p>相是应一的个功实能验由性单功独能的，指您令必。须但手是动，禁更用多警，告因消为息签才名能获得 清洁输出。</p>
</div>
<div class="paragraph">
<p>在Raku中，从一开始就允许使用函数签名，因此您可以直接使用它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>实际上，Perl 5.20中的签名是从Raku到Perl的向后移植功能的一个示例 因此，尽管Raku本身就是Perl 5的下一个版本，但Perl 5仍然可以实现 Raku中设计的一些元素使Perl更好。
类
为了让用户体验更好，让我们来看看另一个重要的例子 Perl的语法在Raku中有所改变。
传统上，面向对象的编程是在Perl 5中借助所谓的 祝福哈希。对象的数据成员是哈希的元素，并且是有福的 对该哈希的引用可用于在类的实例上调用方法。该 下面的示例演示如何定义类并在Perl中创建它的实例</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>到目前为止，名为MyClass的类有两个方法 - new，用于创建新实例，以及inc， 增加计数器并返回新值。在处理Perl 5的课程时，请不要这样做 忘记在模块的末尾返回一个真值，这就是最后一个1的目标
文件的行。</p>
</div>
<div class="paragraph">
<p>在主程序中，您可以通过创建实例并调用方法来使用MyClass
变量如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在Perl 5中实现面向对象的东西是另一个障碍 可能有过使用其他语言课程的新人 但他们对Perl 5创建它们的方式感到困惑。
Raku中的类对于使用其他对象的开发人员来说更为熟悉 - 面向编程语言。
这是你在Raku中定义同一个类的方法，如上例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，整个类在一对大括号中定义。它的数据成员是 使用has关键字显式声明，并且不需要在结尾处返回1 文件。
现在，创建一个类的对象并增加内部计数器三次，就像我们一样 在之前的Perl 5例子中做过。这就是你在Raku中的表现:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>不要关注细节，因为它将在后面的章节中解释。 到目前为止，我们已经看到了三个需要改进Perl 5语法的例子。</p>
</div>
<div class="paragraph">
<p>要查看Perl 5和Raku之间更改的更多示例，您可以参考一些文章 在Raku的文档中，标题为“Perl 5 to Raku guide” HTTPS:/ /
文档。 raku。组织/语言。HTML，专门针对该特定主题:
5to6-nutshell Perl 5到Raku，简而言之 - 我如何做我以前做的事情?
5to6-perlfunc Perl 5到Raku指南功能 5to6-perlop得到 Perl 5到Raku指导操作员
      5to6-perlsyn 5to6-perlvar
Perl 5到Raku指南语法
Perl 5到Raku指南 - 特殊变量
  与Perl 5的兼容性
现有的Raku编译器无法在没有修改的情况下执行Perl 5程序 源代码。Perl 5和Raku有时被称为姐妹语言。两者都有相同之处 Perl的精神，在很多情况下，可以将程序从Perl 5转换为Raku。
Perl 5的最大优势之一是CPAN(Comprehensive Perl Archive 网络)。它包含大量无数模块，适用于众多领域。最 可能，你的任务已经由一些CPAN的作者解决了。使用这个有用的遗产 在你的Raku程序中，你可能想要使用Inline :: Perl5模块 允许使用现有的Perl 5模块而无需修改源代码。
例如，让我们采用Perl 5中最流行的模块之一，Text :: CSV，然后嵌入它 在我们的Raku程序中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">启用Inline </dt>
<dd>
<p>Perl5后，:from &lt;Perl5&gt;后缀将加载Text :: CSV模块 来自Perl 5模块目录。该模块必须作为常规Perl 5模块安装 来自CPAN。</p>
</dd>
<dt class="hdlist1">程序的其余部分使用$ csv对象，它是Text </dt>
<dd>
<p>CSV的一个实例。注意
你必须遵循Raku语法，所以，例如，而不是创建对象</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这同样适用于调用parse方法:in
Perl 5将是$ csv&#8594; parse()，而在Raku中你使用dot:$ csv.parse()。工作 第8章介绍了Raku中的对象，面向对象的编程。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">幸运的是，Raku已经有了一个模块Text </dt>
<dd>
<p>CSV。你可以找到它 <a href="http://modules.raku.org页面。使用Inline" class="bare">http://modules.raku.org页面。使用Inline</a> :: Perl5对那些非常有用 CPAN上的模块，它们还没有等效或替换，用Raku编写 例如，以下从模块文档中获取的示例显示了如何操作 连接到数据库(当然，您需要安装PostgreSQL来测试示例):</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_raku_资源">1.3. Raku 资源</h3>
<div class="paragraph">
<p>Raku历史悠久，在此期间创建了许多文档，例如
语言思想，草案规范和编译器文档。许多爱好者写道
有关Raku的文章和博客文章。其中一些已过时，并未反映当前的情况 语言的状态。在本章中，我将向您简要介绍最新的材料。 在您使用Raku的练习中应该使用的日期。
文档
文档Raku编程语言的主要入又点是
Raku网站的文档部分(HTTP:/ /文档raku组织。)。它包含几个部分 全面描述了类型，运算符和内置类
在Raku中可用。由于语言仍处于开发阶段，您有时可能会在其中找到位置 文档中它不反映语言的当前状态。在这种情况下， 您可以咨询语言开发人员社区或检查测试中的文件
套房。</p>
</div>
<div class="paragraph">
<p>什么是Raku? 测试套件
Raku的的测试套件，名为烤，可以在仓库中被发现在/:HTTPS。/ GitHub的COM / raku /烤。它包含数以千计的测试，涵盖了Raku的许多角落。测试套件是
如果你想看看在Raku中编写程序的方法，也是一个好看的地方。它可能会 有时是长时间阅读，但许多测试都是从所有可能的角度检查功能。
在Roast中，测试分组在名称为S32-io的目录中。这些名字 对应于概要的编号，并分成专题部分。对于 例如，对于概要11&#8217;编译单元'，存在三个目录 tests-S11-compunits，S11-modules和S11-repository。</p>
</div>
<div class="paragraph">
<p>STD.pm
STD.pm是一个描述正式Raku语法的巨大文件。Raku的语法是 用Raku本身编写。的存储库的https:/。/ GitHub的COM / raku / STD包含
语法和将语法翻译成Perl 5代码的viv实用程序。我们有 提到了STD.pm语法，因为对于那些想要的读者来说这可能很有意思 深入研究语法的内部结构。在本书的其余部分，我们将
基于Raku中的代码示例解释语法。
社区
Raku的开发人员传统上使用IRC进行通信。你也可以加入 #raku频道询问有关语言的问题或在线执行Raku。
要加入频道，请遵循列出的说明HTTPS:/。/ raku组织/社区/ 页。
如果要在IRC中运行代码，请参阅rakudo bot，如下所示: &lt;me&gt; rakudo:说“你好，世界!”
&lt;+ camelia&gt; rakudo-moar cb8fa0:OUTPUT:«Hello，World!␤» 在输出中，您可以看到Rakudo默认使用MoarVM后端。字符串
   程序打印的内容显示在OUTPUT关键字之后。</p>
</div>
<div class="paragraph">
<p>请谨慎使用此功能，因为整个房间都可以看到您的要求 也被记录。最好的用例是在找到时显示编译器的行为 错误或当您看到与文档中所述内容不同的结果时。Raku 开发人员总是出现在IRC频道中，并会就错误或意愿提出建议 旨在修复错误并使文档正确。
如果您在Facebook上，请访问Raku小组: HTTPS:/。。/ WWW Facebook的COM /组/ 1595443877388632 /
在离线状态下，您会看到很多在各种会议上都喜欢Raku的人。去吧 Perl Conference(以前称为YAPC，(又一个Perl会议))，其中 每年在欧洲和美国举办。您可能会发现更多关于他们的http:/ /
theperlconference，组织和HTTP:/。。/ WWW YAPC欧盟。多年来，Perl都有工作 OSCON和FOSDEM等大型开源会议的展位。还有很多
当地会议，研讨会和当地小组会议。找到离您最近的群组 位置在 HTTP:/ /下午组织。。</p>
</div>
</div>
<div class="sect2">
<h3 id="_编译器">1.4. 编译器</h3>
<div class="paragraph">
<p>在Raku开发过程中，创建了许多编译器。一些 他们只是一个测试一些想法的游乐场，而有些则更为成熟。其中 最重要的是，我们应该提到以下四个项目:
鹦鹉 哈巴狗
Perlito Rakudo
有更多的尝试来创建一个不太成功或更少的Raku编译器 完成。我们将通过前面的列表来查看每个项目的亮点 然后专注于Rakudo，这是你今天应该使用的编译器。</p>
</div>
<div class="paragraph">
<p>Parrot是第一个旨在成为Raku编译器基础的虚拟机。最初的 该语言的设计建议将源代码编译为字节码，即 由虚拟机执行。Parrot的目标是创建一个适合的虚拟机 处理Raku的所有需求，从简单的数据类型，如整数，到更多 复杂的结构，例如类，能够在对象上调用方法 遵循对象层次结构。
该项目可在parrot.org上获得。过了一段时间，Parrot开始支持其他人 编程语言，如Lua或Python，虚拟机变得越来越少
专注于Raku本身。例如，Ponie项目是尝试创建编译器 那将使用Parrot执行Perl 5程序。
Parrot成为另一个项目Rakudo中的虚拟机之一。但是，之前 我们去Rakudo，让我们沿着历史的道路谈谈Pugs。
哈巴狗
Pugs(Perl User&#8217;s Golfing System)是一个用Haskell编写的Raku编译器。它开始于 2005年由一名独立开发人员很快吸引了更多人加入该团队。哈巴狗是最多的 其时间的复杂编译器。编译它是困难且非常耗时的 项目，执行速度低，但编译的质量和覆盖范围
Raku规格非常出色。</p>
</div>
<div class="paragraph">
<p>帕格斯今天在Raku中的主要角色是庞大的测试套件。它是为了测试帕格斯本身而创建的， 但事实证明它是Raku的官方测试套件。一个声称自称为Perl的编译器 6编译器必须通过测试套件测试。
哈巴狗不发展了，但它的源代码可以在GitHub上的HTTPS:/ / github上。的COM / raku /哈巴狗。HS 。
Perlito
Perlito是构建Raku编译器项目的另一个非常有趣的例子。它是
旨在将Perl 5或Raku交叉编译为其中一种语言&#8212;&#8203;JavaScript，Java，Go， Python，Ruby或Lisp。您可以找到该项目的存储库/:HTTPS。/ GitHub的COM /
fglock / Perlito 。</p>
</div>
<div class="paragraph">
<p>Perlito提供了一个Web界面，用于在浏览器中编译Raku的子集。它汇编了
将Raku中的代码编写为JavaScript并立即执行。该网页的网址是HTTP:/ / fglock。 github上。IO / Perlito / perlito / perlito6。HTML。该项目涵盖了Raku
规范仅部分，但它仍可用于创建各种在线教育 Perl 5和6的系统。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_rakudo_star">1.5. 使用 Rakudo Star</h3>
<div class="paragraph">
<p>Rakudo是最初构建在Parrot虚拟机上的编译器。后来，它开始使用了 Java虚拟机(JVM)，但最终，Parrot的开发人员创建了自己的 虚拟机，MoarVM(上运行虚拟机元模型(www.moarvm.org))。 目前，JVM的支持有限，主虚拟机是MoarVM。
Rakudo本身就是一个Raku编译器。对我们来说，最有用的编译器是Rakudo Star，它是 包括编译器以及许多Raku模块和一些模块的发行版 命令行工具，例如模块安装程序。在本书中，我们将使用Rakudo Star
编译器在Raku中运行程序。
Rakudo的网站是 rakudo.org。
与Rakudo Star合作
Rakudo是目前最完整的编译器。它支持最大的子集
Raku语言，并且说Rakudo是你唯一的编译器并不是一个错误 应该用来学习Raku。下载并安装Rakudo Star</p>
</div>
<div class="paragraph">
<p>有几种方法可以在您的计算机上安装Rakudo Star。你可以下载 源代码并编译或下载适用于您的平台的安装程序。Rakudo Star是
适用于所有主要平台，即Windows(32位和64位版本)，Mac OS X和Linux。
Rakudo星的主下载页面是HTTP:/ / raku组织/下载。。在那页上， 你会找到最新版本的Rakudo Star发行版的链接 平台和如何安装它们的说明。
在Windows上，该过程非常简单。只需下载最新版本的 MSI安装程序，运行它，并按照说明进行操作。</p>
</div>
<div class="paragraph">
<p>什么是Raku?
在Mac OS X上，您可以下载.dmg安装程序，也可以使用brew管理器，如图所示
这里:
$ brew安装rakudo-star 在Linux上，您必须从源文件安装Rakudo Star。
安装Rakudo Star后，您会在其bin中找到raku可执行文件 目录。确保将该目录的路径添加到系统范围的PATH变量中
这样你就可以从任何位置输入raku。 在本书的其余部分，我们将假设已安装Rakudo Star，我们将使用
raku可执行文件来运行程序。 命令行选项
Rakudo Star的Raku编译器接受一些命令行选项。我们来看看吧 他们中有一些。
-c命令
-c命令行检查程序的语法并退出。它还运行BEGIN 和程序中的CHECK块，在Phasers of部分中讨论 第2章， 编写本书后面的代码。如果您只想这样，此命令行选项很有用 检查代码中是否存在语法错误，并且不想执行它 异常是BEGIN和CHECK代码块中的代码。
在正确编程的情况下，它打印以下输出:
语法OK 如果存在编译时错误，则编译将在第一个错误处停止并显示
它在控制台上，提到发现错误的行号。
错误消息包含错误的描述并指示错误的位置
代码借助弹出字符()。如果您的控制台支持颜色，则片段
弹出字符前的代码为绿色，其余部分为红色。</p>
</div>
<div class="paragraph">
<p>下面是一个错过字符串结束语的程序示例: 问好;
什么是Raku?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>程序没有编译，这就是编译器打印的内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>双引号 术语
--doc命令 --doc(注意双连字符)命令行从中提取文档
编程并打印出来。这里，所谓的Pod文档就是这个意思。我们将介绍 Pod语法 第 2 章，编写代码。
让我们看看包含内部文档的小程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>说“你好，世界!”; 使用&#8212;&#8203;doc命令行选项运行它，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>它只会打印部分文档。代码本身不会被执行:
你好，世界节目 *此程序打印“Hello，World!”
-e命令 -e选项允许您在命令行中传递整个程序。这很有用
执行一些操作的简短程序，或者例如，当您检查时如何进行小测试 事情在Raku中起作用。</p>
</div>
<div class="paragraph">
<p>使用引号括起来的程序运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这是您将看到的结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>例如，它可能是一个单行实用程序，用于打印字符串的第一个字母 STDIN输入:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>它将打印由file.txt中行的第一个字符组成的行。
-p命令 -p命令行选项的作用与前面介绍的-n选项相同，但它也会打印
每行末尾的默认变量$ _的值。我们将看到的意义 以下章节中的默认变量。
-I和-M命令 -I和-M选项用于将模块加载到程序中。该模块的名称是
传递给-M选项，如果需要，模块的路径应该传递给 - 我选择。</p>
</div>
<div class="paragraph">
<p>什么是Raku? -v和&#8212;&#8203;version命令
-v和&#8212;&#8203;version选项打印当前Raku编译器的版本，如下所示: $ raku -v
在撰写本文时，我正在使用Rakudo Star版本2017.01，这就是输出 好像:
这是基于MoarVM 2017.01版实施的Rakudo 2017.01版本 Raku.c.
除了版本本身之外，重要的是用于的虚拟机
执行Raku(MoarVM，如前所示)和Raku语言的版本 规范(在本例中为6.c)。
Rakudo Star版本控制方案使用了发布日期的年份和月份 分配。Rakudo正在迅速发展，所以检查一下rakudo.org网站定期获取 更新。
--stagestats命令 --stagestats是一个命令行选项，比其他选项更具有Rakudo特性
我们之前已经描述过。它打印编译器在不同阶段花费的时间
编译和执行程序。
输出因您运行程序还是检查其语法而异 使用-c命令行选项。让我们先来看看-c时打印的内容 选项用于:
$ raku --stagestats -c hello.pl
输出如下:
阶段开始:0.000 阶段解析:0.107 阶段语法检查:语法确定
如果没有-c选项，您将看到更多统计信息，因为该程序不仅仅是 编译但也执行，如下所示:
 $ raku --stagestats hello.pl</p>
</div>
<div class="paragraph">
<p>该程序的常规输出打印:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_写出我们的_hello_world_程序">1.6. 写出我们的 Hello, World 程序</h3>
<div class="paragraph">
<p>到目前为止，由于我们已经安装了Rakudo Star编译器，现在是时候创建第一个了
Raku中的程序。它将打印Hello，World!并退出。 该计划非常简单。你需要的只是一行，只有一个指令来调用
内置说功能。它接受字符串，将其打印到控制台，然后在其后面添加一个新行。
这是整个程序的外观:
说&#8217;你好，世界!' 将代码保存到文件中，比如hello.pl，并将其传递给编译器，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>它将编译程序并立即执行它。结果是所需的字符串
屏幕:
你好，世界!
请注意，输出以新行结束。这是内置说法的行为
功能。或者，我们可以使用另一种打印输出的方法
打印内置功能。不像说，它不会在输出的末尾添加新行，所以 你必须通过添加特殊符号来自己完成\ n:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，这次使用了一对双引号。双引号处理特殊字符 例如\ n与单引号不同。在双引号内，\ n转换为a 换行符。这不会发生在单引号中，在这种情况下，\ n将出现 在屏幕上显示为两个字符的序列，并且\ n。</p>
</div>
<div class="paragraph">
<p>因为程序只包含一行代码，所以不必以a结尾
分号。但是，您始终可以这样做:
说“你好，世界!”; 该程序产生与以前完全相同的输出。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结">1.7. 总结</h3>
<div class="paragraph">
<p>在本章中，我们简要介绍了Raku的编程语言是什么以及如何使用</p>
</div>
<div class="paragraph">
<p>它与其姐妹语言Perl 5不同。我们查看了Raku的历史和不同的历史
Raku编译器的项目。最后，我们安装了Rakudo Star，它是最好的编译工具 今天又创造了第一个&#8217;Hello，World!' 程序。
在下一章中，我们将介绍如何在程序中组织代码。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_写代码">2. 写代码</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章将为你编写 Raku 代码做好准备。在我们检查变量，数据类型，面向对象和其他重要主题之前，让我们多了解一下在 Raku 中是如何组织源代码的。有许多元素与其他编程语言不同，值得花时间习惯它。</p>
</div>
<div class="paragraph">
<p>在本章中，我们将介绍以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用 Unicode</p>
</li>
<li>
<p>空格和空格</p>
</li>
<li>
<p>注释</p>
</li>
<li>
<p>创建 Pod 文档</p>
</li>
<li>
<p>Phaser</p>
</li>
<li>
<p>简单的输入和输出</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_使用_unicode">2.1. 使用 Unicode</h3>
<div class="paragraph">
<p>默认假设是 Raku 程序的源代码使用 UTF-8。它给你了整个字符的力量，而不用担心它是否会起作用。在 Perl 5 中，例如，你必须在源代码中添加特殊说明才能通知解释器你正使用非 ASCII 字符。在 Raku 中，这更容易了。</p>
</div>
<div class="paragraph">
<p>首先，Unicode 字符可以在字符串中自由地使用。例如，让我们尝试一些希腊语和中文字素，如下面的代码行所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'C = 2πr';     # Circumference of a circle
say '日 + 月 = 明'; # 'Sun' and 'Moon' give 'bright'</code></pre>
</div>
</div>
<div class="paragraph">
<p>s
前两行代码将按预期打印相应的字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">C = 2πr
日 + 月 = 明</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，可以通过名字来引用 Unicode 代码点。例如， 考虑以下代码行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "Raku is c[FLEXED BICEPS]";</code></pre>
</div>
</div>
<div class="paragraph">
<p>上一行代码使用肌肉表情符号打印以下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Raku is</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中使用 Unicode 不仅限于字符串，仅限内容。ASCII 外面的字符可以用在变量和函数的名中。让我们回到第一章“Raku 是什么”中的 <code>add($x, $y)</code> 函数这个例子，并使用希腊字符重命名它和它的参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub Σ($α, $β) {
    return $α + $β;
}

say Σ(8, 9); # 17</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，一些 Unicode 字符可用于表示简单的操作而不是更传统的代码。例如，以下是具有有理分数的字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1⁄2;       # prints 0.5
say 1⁄2 + 1⁄4; # 0.75</code></pre>
</div>
</div>
<div class="paragraph">
<p>也允许使用非 ASCII Unicode 数字，但在没有特殊需求的常规代码中使用它们可能不是一个好主意:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ୪૨; # Prints 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用诸如 ² 或 ³ 的上标而不是调用函数来计算数字的幂，如下面的代码行所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 7²; # 49
say 2⁷; # 128</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 Unicode 字符的另一个例子是集合上的数学运算符，例如 ε 或 ∪。</p>
</div>
<div class="paragraph">
<p>在下一个示例中，将使用 Unicode 版本的简单算术运算符而不是传统使用的常规 <code>*</code> 和 <code>/</code> 字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 × 4;  # 40
say 100 ÷ 4; # 25</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 程序中，你可能经常会看到一些其他 Unicode 字符。我们来看看其中最常见的一些。</p>
</div>
<div class="paragraph">
<p>可以使用法语引号 <code>« »</code> 代替一对引号来创建列表。例如，在下面的代码中，<code>@array</code> 获取斐波纳契数的序列。我们已经在第一章中的 Raku 是什么的例子中看到了这一点。让我们首先更新它以使用引用语法来创建数组，如以下代码行所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @fibonacci = &lt;0 1 1 2 3 5 8 13&gt;;
say @fibonacci[4]; # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将在第三章中的使用变量和内置数据类型中详细介绍这种语法，但是，让我们现在看看如何使用法语引号括起值列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @fibonacci = «0 1 1 2 3 5 8 13»;
say @fibonacci[4]; # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于单行(主要在 <code>-e</code> 命令行选项中执行的短程序)，Unicode 引号可能非常有用，因为它们有助于避免嵌套的单引号问题。你可以在以下示例中查看它的工作原理:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku –e'say ‘Hello, World!’'</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里使用一对 Unicode 引号(‘ 和 ’)而不是单引号(')。</p>
</div>
<div class="paragraph">
<p>使用正则表达式和 grammar 时(我们将在第十一章的正则表达式和第十二章的 grammar 中讨论它们)，你经常会看到一对方形尖括号，你可以在代码中自由地使用它来引用字符串，如以下代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ⌈Hello, World!⌋;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中，语言的元素可以用 Unicode 字符表示，它和用 ASCII 形式编写的等价。ASCII 字符有时被称为德克萨斯字符。下表列出了 Unicode 和 ASCII 最常见结构版本之间的对应关系:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unicode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ASCII 等价物</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在 Raku 中的意思</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">« »</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;&lt; &gt;&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这些引起一组数组元素, 也用于超运算符中(参考第四章的使用运算符)。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">‘’ “„”</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">' ' " " "</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这些单引号和双引号用于引起字符串。诸如 n 这样的特殊字符在双引号中被插值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⌈ ⌋</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Q/ /</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这个语法用于创建不带插值的字符串</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">× ÷</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">* /</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这些是乘法和除法算数运算符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">−</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">减号, 用作运算符, 例如(注意 Unicode <code>0写212</code> 代码有一个单独的 <code>MINUS SIGN</code> 字符)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>对于数学计算有一些预定义的常数 - <code>π</code>，<code>e`和 `τ</code>。有一个单独的符号表示无穷大-<code>∞</code>。所有这些符号也有对应的 ASCII 表示:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">符号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ASCII 等价物</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注释</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">π</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">pi</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这是 π 的值(3.14159&#8230;&#8203;)。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">e</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">e</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这是 e 的值(2.71828)。注意它的 Unicode 表示是 0x1D452 字符, 不是 ASCII 字符 e。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">τ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tau</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">τ 的值是 2π(6.283185&#8230;&#8203;)。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∞</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inf</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无限大总是比任何数大</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>键入 Unicode 字符可能是一项单独的任务。当然，你可以随时复制来自 Google 或维基百科的字符，但在这种情况下你会失去生产力。参考 Raku 在线文档 link:docs.raku.org/language/unicode_entry 输入 Unicode 字符页面。它包含有关如何在不同的编辑器和 IDE 中输入 Unicode 字符的详细说明。</p>
</div>
</div>
<div class="sect2">
<h3 id="_空白和反空白">2.2. 空白和反空白</h3>
<div class="paragraph">
<p>正如我们刚刚看到的那样，Raku 程序可以在传统的 ASCII 集外部强烈地使用 Unicode 字符。这也适用于空白。空白就是那些程序元素之间的缝隙，传统上由空格表示(ASCII 代码 0x20)，制表符(0x09)和换行符(Unix 中的单行换行符 0x0A 和一系列两个字符，回车符 0x0D，以及 Windows 中的换行符 0x0A)。Raku 扩展了空白的概念，并在代码允许常规空白的每个地方接受 Unicode 空格。当你使用现有代码时要小心，原因是，填充了 Unicode 字符。</p>
</div>
<div class="paragraph">
<p>Raku 中的空白字符集包含具有如下 Unicode 属性之一的字符:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Zs: Separator, Space</p>
</li>
<li>
<p>Zl: Separator, Line</p>
</li>
<li>
<p>Zp: Separator, Paragraph</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你可以在 https:/​/​en. wikipedia.​org/​wiki/​Whitespace_​character 页面列出的类别中找到完整的字符列表。其中有一个常规空白，垂直和水平制表符，换行符，换行符，不间断空格和瘦空白。</p>
</div>
<div class="paragraph">
<p>在更大的范围内，Raku 允许程序按照程序员的需要进行格式化。 另一方面，关于空白可能出现的地方，有一些规则，在编写 Raku 程序时应该遵循这些规则。</p>
</div>
<div class="paragraph">
<p>如果语言禁止在代码中的特定位置有空格，但是你希望格式化程序以使其更宽敞，你可以添加所谓的 <strong>unspace</strong>。这是一个以一个反斜杠开始的序列，紧接在前一段代码之后后跟一个或多个空格字符。它类似于 Unix 命令行指令末尾用于继续下一行的反斜杠。</p>
</div>
<div class="paragraph">
<p>让我们来看看有关空白的语言规则的最重要的情况，可能与你的习惯发生冲突。</p>
</div>
<div class="paragraph">
<p>第一个例子是函数调用。在 Raku 中，函数的参数周围不需要圆括号，但只要你使用它们，函数名和左开口圆括号之间不能有空格 。检查以下三个调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say add 4, 5;   # OK, no parentheses
say add(4, 5);  # OK, no space
say add (6, 7); # Error</code></pre>
</div>
</div>
<div class="paragraph">
<p>前两行是正确的，而最后一行产生编译时错误，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Too few positionals passed; expected 2 arguments but got 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>错误消息可能听起来有误导性，但请记住，在 Raku 中，你可以传递数组给函数。在这种情况下，编译器不能保证它理解程序员的正确意图。<code>add (6, 7)</code> 结构可以解释为使用单个参数的函数是一个双元素数组 - (6,7) 来调用函数。</p>
</div>
<div class="paragraph">
<p>如果你仍然希望在视觉上分割参数列表和函数名，请在它们之间放置一个空格:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say add\ (6, 7);</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在它正在编译，没有任何抱怨。还允许在反空格内部使用换行符; 考虑以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say add\
(6, 7);</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以不同地格式化代码，让开口圆括号与函数名保持在同一行上，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say add(
    6, 7
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你需要传递许多参数时，这种方法可能很方便，例如，给每个参数添加注释:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say add(
    6, # first argument
    7  # second argument
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将在第六章的子例程中更多地讨论函数。但是，现在，让我们回到组织源代码的方法中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_注释">2.3. 注释</h3>
<div class="paragraph">
<p>在第一章 Raku是什么中我们已经看到了两种编写程序的方法 - 通过把它传递给 <code>-e</code> 命令行选项或将其保存在文件中。当然，所有大型程序都存储起来在文件中。在本节中，我们将看到 Perl 如何通过添加注释帮助程序员更好地组织代码。</p>
</div>
<div class="paragraph">
<p>注释是源代码的一部分，编译器会忽略它们。注释旨在提供有关该程序本身的其他信息。好的注释的例子是对所用算法，或变量的目的，或函数输入参数的描述的解释。</p>
</div>
<div class="paragraph">
<p>Raku 通过使用注释和所谓的 Pod 提供了两种在源代码中保存额外的面向人类信息的方法。首先，我们将检查注释。</p>
</div>
<div class="paragraph">
<p>注释是编译器不认为是直接的源代码片段 执行指令。在 Raku 中，有三种方式留下注释:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>单行注释，</p>
</li>
<li>
<p>多行注释，</p>
</li>
<li>
<p>嵌入式注释。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们来详细研究它们。</p>
</div>
<div class="sect3">
<h4 id="_单行注释">2.3.1. 单行注释</h4>
<div class="paragraph">
<p>使用 # 字符将单行注释与程序源代码分开。# 符号后面的所有内容都被编译器跳过，直到当前行结束。</p>
</div>
<div class="paragraph">
<p>在下面的例子中，我们采用第一章的什么是 Raku 中的 'Hello，World!' 程序，并添加一行注释:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Hello, World!'; # Prints 'Hello, World!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个完全正确的 Raku 程序。它有一个内置 <code>say</code> 函数和一个关于它的作用的注释。字符串的一部分，从 # 字符开始，是一个单行注释。</p>
</div>
<div class="paragraph">
<p>如果你运行该程序，它会打印 <code>Hello，World!</code>。仅此而已。它和没有注释的程序的作用完全相同。</p>
</div>
<div class="paragraph">
<p>单行注释也可能占用一行单独的代码。例如，让我们对同一程序添加更多的注释:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> # This is a program in Raku.
# It prints the 'Hello, World!' string.
# To run it, install Rakudo Star and
# run it from the command-line:
# raku ./hello.pl

say 'Hello, World!'; # it prints the string

# The program ends here.</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也是一个完全有效的 Raku 程序。从业务逻辑的角度来看，与前面的例子一样，程序没有改变，但是从未来维护的角度来看，它变得更好，因为它解释了它的作用。</p>
</div>
<div class="paragraph">
<p>使用单行注释的另一种常见做法是暂时隐藏代码段。例如，在调试过程中，你要禁用某些操作。代替删除代码行，你可以通过在行的开头添加#字符来注释掉它。考虑下面的代码行为例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Hello, World!';
# print "Hello, World!\n";</code></pre>
</div>
</div>
<div class="paragraph">
<p>有时，你执行相反的操作 - 向程序添加其他打印指令来查看不同变量的值，并在代码生产就之前注释这些指令。</p>
</div>
<div class="paragraph">
<p>以下是如何打印传递给函数的值的示例。我使用了来自第一章的什么是 Raku 的附加示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y) {
    say "x = $x, y = $y";
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序只是打印加法的结果，但如果你取消注释子例程代码中的第一行，它还会以人类可读的格式打印 <code>$x</code> 和 <code>$y</code> 变量的值。如下代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">x = 4, y = 5
9</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_多行注释">2.3.2. 多行注释</h4>
<div class="paragraph">
<p>尽管可以使用单行注释来提供大量文档，但在每行中放置 # 字符会使注释本身难以维护。例如，如果你修改注释的文本，你可能还想重新整理整个注释段落，以便所有行的长度大致相同，整个注释在
视觉上更吸引人。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，支持多行注释。多行注释的语法是这样的。它从 #` 序列开始(#字符，与单行注释相同， 然后是一个反引号符号)。然后是带有注释的正文部分。它必须用一对括号括起来。</p>
</div>
<div class="paragraph">
<p>例如，花括号可以像这样使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#`{This program in Raku
prints the 'Hello, World!' string}

say 'Hello, World!';</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，注释位于源代码的两行中，但不需要每一行都用 # 字符标记。</p>
</div>
<div class="paragraph">
<p>可以使用其他环绕字符。例如，圆括号或方括号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> #`(A multi-line comment
placed between pair of parentheses)

#`[Another multi-line comment,
this time in square brackets]</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然这些注释最初是由人类阅读的，但编译器必须了解注释的开始和结束位置。在前面的例子中，注释主体的结束字符由 #` 序列后面的相应字符定义。</p>
</div>
<div class="paragraph">
<p>如果它是一个左花括号(<code>{</code>)，则编译器扫描以下文本并查找此示例中闭合的对应的 <code>}</code> 字符。这也意味着你不能在注释文本中使用闭合花括号，因为它将被视为注释的结尾。</p>
</div>
<div class="paragraph">
<p>在注释中使用这样一个字符的方法之一是使用另一对闭合符号。例如，如果整个注释嵌入在一对圆括号中，然后在该注释的正文中使用结束花括号是安全的，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#`(A multi-line comment
in parentheses and it contains the } character inside
it)</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，如果使用相同字符的平衡字符对，则不会出现问题。例如，考虑以下代码块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#`(Function add(x, y) adds two numbers
and returns their sum)
sub add($x, $y) {
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，注释使用 #`(&#8230;&#8203;) 括号对，但它里面包含另一对括号: `add(x，y)`。在这种情况下，程序是正确的，它应该根据程序员的意图结束注释。</p>
</div>
<div class="paragraph">
<p>在注释中允许相同字符的第二种方法是使用多个字符序列以标记注释。</p>
</div>
<div class="paragraph">
<p>例如，一对双括号将如下工作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#`{{Two characters at the beginning
let us easily include the closing } brace, for
example}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个好的选择是使用不同字符的组合。闭合字符序列应该镜像开口字符序列，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#`([Another way of having
a closing ] character inside the comment])</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，单行注释可能出现在多行注释中。在这种情况下，他们将只是其中的一部分，如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#`{If you want to print the value of the variable $x,
find the following line in the code:
# say $x
and uncomment it.}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_嵌入式注释">2.3.3. 嵌入式注释</h4>
<div class="paragraph">
<p>Raku 中的嵌入式注释是使用多行注释语法的注释，但是放在主代码中。与单行注释不同，嵌入式注释不会传播直到行尾，并可能由闭合字符终止。</p>
</div>
<div class="paragraph">
<p>让我们演示一个关于 <code>add</code> 函数的嵌入式注释的示例，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y) {
    return $x + #`(this is numeric addition) $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>#`(this is numeric addition) 注释通知读者 `+` 运算符期望它的操作数(示例中的变量 <code>$x</code> 和 <code>$y</code> )是数值(例如，不像字符串的连接)。整个注释嵌入到 <code>$x + $y</code> 表达式中。注释结束后，常规代码流继续。编译器忽略注释，因此，该行在语法上保持正确。</p>
</div>
<div class="paragraph">
<p>嵌入式注释应尽可能短，以使整个代码更易于阅读。使用它来提供小的解释或在调试程序期间禁用代码片段。</p>
</div>
</div>
<div class="sect3">
<h4 id="_创建_pod_文档">2.3.4. 创建 Pod 文档</h4>
<div class="paragraph">
<p><strong>Pod</strong> 是 Raku 中用于编写文档的子语言。它可以被视为注释的扩展版本，允许表达内容的更多功能。Raku 中的 Pod 是 Perl 5 中 POD (普通旧文档)的演变。在 Raku 中， 名字不是缩写，因此不是大写的。在本节中，我们将研究 Pod 标记语言的语法。</p>
</div>
<div class="paragraph">
<p>Pod 内容与 Raku 程序本身放在同一个源文件中。一个 Pod 小节是包含一些文本信息的一系列行。在看到 Pod 部分的开始和结束标记时，编译器切换解析 Pod 和 Raku。Pod 语法旨在表达文档的语义并帮助以更有条理的方式组织它。</p>
</div>
<div class="paragraph">
<p>我们来看看如何创建 Pod 块。有几种类型的 Pod 块，以及一些创造 Pod 的方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_begin_end_pod块">2.3.5. `=begin / =end Pod块</h4>
<div class="paragraph">
<p>Pod 块以 <code>=</code> 符号开头，该符号应该是该行中的第一个非空格字符 (因此，你无法启动 Pod 块，因为你在代码旁边执行单行注释 )。</p>
</div>
<div class="paragraph">
<p>该块用一对 <code>=begin</code> 和 <code>=end</code> 指令标记，每个指令必须后跟一个 Raku 标识符，描述 Pod 块中包含的数据类型。 有一些预定义的标识符，它们是完全小写的或完全大写的。 考虑一些最有用的 Pod 块的例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod6" data-lang="pod6">=begin pod
This program is the first program in Raku.
=end pod

say 'Hello, World!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，Pod 块以 <code>=begin pod</code> 开头，并以 <code>=end pod</code> 结束。块外面的一切是一个常规的 Raku 程序。</p>
</div>
<div class="paragraph">
<p>如果只是运行程序，则忽略 Pod。将程序保存在文件中并运行它来自命令行如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku pod.pl
Hello, World!</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第一章的什么是 Raku 中我们查看了 Rakudo Star 编译器支持的不同命令行选项。现在是时候使用其中的一个了 <code>--doc</code> 来查看编译器如何提取来自程序的 Pod 文档并在不执行程序的情况下打印它本身:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku --doc pod.pl
This program is the first program in Raku.</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，块的类型是 <code>pod</code>。还有其他类型的 Pod 块。</p>
</div>
<div class="paragraph">
<p><code>table</code> 类型创建一个带有表的 Pod:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod6" data-lang="pod6">=begin table
    Language    Year of appearance
    C           1973
    C++         1983
    Perl        1987
    Raku      2000
=end table</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以自己在源代码中对表进行一些最小的格式化，但是 Pod 解析器和格式化程序(在我们的例子中是 Rakudo 的一部分)执行一些额外的工作来很好地显示表。如果使用 <code>--pod</code> 命令行选项运行程序，这就是表的外观:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku --doc pod.pl
Language  Year of appearence
C         1973
C++       1983
Perl      1987
Raku    2000</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，缩进会丢失，并且表行从行的开头打印。另一个变化是列之间有两个空格，而我们在源代码中有更多空格。</p>
</div>
<div class="paragraph">
<p>该表可以选择包含一个标题，你可以使用所谓的副词语法将其放在 <code>=begin</code> 行中，如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod6" data-lang="pod6">=begin table :caption&lt;History of Programming Languages&gt;
Language    Year of appearance
C           1973
C++         1983
Perl        1987
Raku      2000
=end table</code></pre>
</div>
</div>
<div class="paragraph">
<p>标题将打印在表格上方:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku --doc pod.pl
History of Programming Languages
Language  Year of appearance
C         1973
C++       1983
Perl      1987
Raku    2000</code></pre>
</div>
</div>
<div class="paragraph">
<p>在我们进一步研究 Raku 中的其他类型的 Pod 块之前，让我们学习另一种语法来声明 Pod 块:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>缩写块</p>
</li>
<li>
<p>段落块</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在缩写块中，开头 <code>=</code> 符号后面紧跟着 Pod 块类型的名字。不再需要闭合的 <code>=end</code> 指令，Pod 块的结尾将是由空行或另一个 Pod 块的开头指示。</p>
</div>
<div class="paragraph">
<p>以下是具有缩写语法的表块的另一个示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod6" data-lang="pod6">=table
    Language    Year of appearance
    C           1973
    C++         1983
    Perl        1987
    Raku      2000

say 'Ok';</code></pre>
</div>
</div>
<div class="paragraph">
<p>带有表格的 Pod 块在空行之前结束。之后，编译器切换回解析 Raku 代码。</p>
</div>
<div class="paragraph">
<p>在段落块中，使用 <code>=for</code> 指令启动 Pod 部分，后面是标识符。因此，最后一个示例可以以 <code>=table</code> 或 <code>=table</code> 开头。</p>
</div>
<div class="paragraph">
<p>对于内容通常很短的其他类型的 Pod 块，这种语法更自然。例如，标题或列表项。在这些情况下，块的内容是在同一行，紧接在开口指令之后，如下例所示，这反映了当前章节的部分内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod6" data-lang="pod6">=head1 Writing Code
=head2 Comments in Raku
=item One-line comments
=item Multi-line comments
=item Embedded comments</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>--doc</code> 命令行选项提取文档会生成以下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Writing Code
  Comments in Raku
  * One-line comments
  * Multi-line comments
  * Embedded comments</code></pre>
</div>
</div>
<div class="paragraph">
<p>它包含两个级别的标题和一个简单的项目符号列表。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_移相器">2.4. 移相器</h3>
<div class="paragraph">
<p>在 Raku 中创建程序时，了解控制程序流程比简单地遵循代码指令要复杂一些非常重要。编译器在编译和执行过程的不同阶段自动调用特殊类型的代码块。这些块称为 <strong>phasers</strong>。</p>
</div>
<div class="paragraph">
<p>当我们谈到编译器的 <code>-c</code> 命令行选项时，我们在第一章中的 Raku 是什么中提到了其中两个，<code>BEGIN</code> 和 <code>CHECK</code>。现在，我们来看看其余部分。</p>
</div>
<div class="paragraph">
<p>从语法上讲，移相器是花括号中的代码块，其前面是移相器名字。下表总结了 Raku 中存在的不同移相器。一些移相器在编译和执行程序的其余部分之前在编译时执行。一些在运行时调用。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Phaser 名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行阶段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">动作</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BEGIN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">编译时</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该块在主程序被编译之前调用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHECK</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">编译时</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该块在编译完成后执行, 并且编译时阶段会停止</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INIT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">运行时</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该块在程序编译时调用并准备运行</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">END</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">运行时</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该块在程序执行后调用并且准备退出</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>让我们扩展 'Hello, World!' 程序并为它添加一些移相器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">BEGIN {
    say 'BEGIN 1';
} END {
    say 'END';
}

say 'Hello, World!';

BEGIN {
    say 'BEGIN 2';
}
CHECK {
    say 'CHECK';
}
INIT {
    say 'INIT';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码产生如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">BEGIN 1
BEGIN 2
CHECK
INIT
Hello, World!
END</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，请注意相位器块的几个特征。这里有两个 <code>BEGIN</code> 块，它们按照它们在源代码中出现的顺序执行。此外，块的实际位置并不总是重要的。例如，<code>END</code> 块位于主程序之前，但在它之后执行。同样，第二个 <code>BEGIN</code> 块和 <code>CHECK</code> 和 <code>INIT</code> 块位于主程序之后但是在其之前调用它。</p>
</div>
<div class="paragraph">
<p>当程序即将开始时，Phasers 是可以做一些工作的好候选者。例如，你可以检查程序是否正确运行在带有 <code>BEGIN</code> 块的环境中。在 <code>END</code> 块中，你可以关闭所有打开的文件或在程序退出前打印某些东西到日志中。</p>
</div>
<div class="paragraph">
<p>在第十章中的使用异常中，我们将使用另外两个移相器-<code>CATCH</code> 和 <code>CONTROL</code>。</p>
</div>
<div class="paragraph">
<p>Raku 中有更多的阶段，有助于在程序执行期间组织钩子，例如当程序流进入或离开代码块时调用的 <code>ENTER</code> 和 <code>LEAVE</code>。有关这些移相器的详细说明，请参阅文档页面 docs.raku.org/language/phasers。</p>
</div>
<div class="sect3">
<h4 id="_简单的输入和输出">2.4.1. 简单的输入和输出</h4>
<div class="paragraph">
<p>在前面的例子中，我们使用内置的 <code>print</code> 和 <code>say</code> 函数来打印一些东西到控制台中(更严格地讲，附加到程序的标准输出中)。在本节中，你将学习如何从标准输入执行基本读取。这基本上是程序如何获得你在控制台上键入的内容。</p>
</div>
<div class="paragraph">
<p>要读取输入，可以直接使用一些函数而无需加载任何模块。它们列在下表中:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">函数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">它是什么</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">get</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这将从输入中读取一行并返回它</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lines</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这将返回包含来自标准输入的数据行的行的列表</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">slurp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这将返回包含整个输入的字符串</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>当你需要按行解析输入数据时，可以使用 <code>get</code> 和 <code>line</code> 函数。例如，如果你知道输入的结构，请根据需要调用 <code>get</code>，或创建一个循环并迭代 <code>lines</code> 返回的数组。</p>
</div>
<div class="paragraph">
<p><code>slurp</code> 函数一次完成工作。例如，你可以使用它来复制从输入到输出的所有内容。这是执行该操作的程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">print slurp;</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有另一个有用的函数: <code>prompt</code>。用它一次做两个动作: 在屏幕上打印文本消息并返回用户输入的字符串的函数。这个函数块阻止程序的执行，直到用户用新行完成输入。</p>
</div>
<div class="paragraph">
<p>让我们用 <code>prompt</code> 函数演示一个计算圆周的示例程序。以下程序从用户请求半径然后打印结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'The circumference is ',
    tau * prompt 'Enter the radius &gt; ';</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序首先打印提示消息 <code>Enter the radius &gt;</code> 并等待直到用户键入一个数字并按 Enter 键。然后，<code>say</code> 函数打印另一个消息，<code>The circumference is,</code>，并附加它乘以后获得的输入值 τ，正如我们在本章的使用 Unicode 部分中看到的那样，等于 2π。我们可以在以下代码中看到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku circumference.pl
Enter the radius &gt; 12
The circumference is 75.398223686155</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们故意没有引入任何变量(我们将在后面的第三章的使用变量和内置数据类型中讨论它们)。请注意，实际输出从右到左发生:首先，来自 <code>prompt</code> 的消息，然后通过 <code>say</code> 打印文本。
我们将在第九章的输入和输出中讨论更复杂的输入和输出，以及处理文件。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_2">2.5. 总结</h3>
<div class="paragraph">
<p>在本章中，我们研究了 Raku 程序的组织方式。源代码是用 Unicode 编写的，并且语言的语法中有许多 Unicode 元素，可用于使程序更具表现力。我们还研究了如何创建和使用从单行注释到可能包含的较大 Pod 块的注释，有关该计划的文档。我们查看了源代码部分可能的方式，被放置在不同的阶段，以改变程序的流程。最后，你学到了一个从用户获取输入的方法。</p>
</div>
<div class="paragraph">
<p>现在，我们准备创建真正的 Raku 程序。在下一章中，我们将讨论 Raku 中的数据类型以及如何使用变量。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_变量和内置数据类型">3. 变量和内置数据类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 是一种渐进类型的语言。这意味着你无需指明创建的变量的类型：您可以自由地使用同一个变量来存储
不同类型的数据。但是，您也可以创建一个类型变量，在这种情况下，编译器将检查该变量的用法，并确保该变量仅在该类型允许的操作中使用。</p>
</div>
<div class="paragraph">
<p>在本章中，我们将首先介绍 Raku 的内置类型，然后学习如何操作变量：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>内置数据类型</p>
</li>
<li>
<p>类型层次结构</p>
</li>
<li>
<p>变量</p>
</li>
<li>
<p>标量，数组和散列</p>
</li>
<li>
<p>数据类型的面向对象属性</p>
</li>
<li>
<p>简单和复合数据类型</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_使用变量">3.1. 使用变量</h3>
<div class="paragraph">
<p>在任何编程语言中，变量都被命名为内存块，可用于存储和检索值。 在 Raku 中，变量是一个容器，可以容纳一种类型的值，这些值可以是语言内置的，也可以是由用户创建的。</p>
</div>
<div class="sect3">
<h4 id="_声明变量">3.1.1. 声明变量</h4>
<div class="paragraph">
<p>在程序中使用每个变量之前必须对其进行声明。 您无需在程序的开头声明所有变量。 从实际的角度来看，声明的位置可以（并且应该）尽可能靠近第一次使用它的位置。 这样做的最实际原因是使变量的可见性更好-如果声明得太早，则迫使程序的读者考虑变量的目的； 另一方面，如果您在代码中进行了更改，那么如果变量声明不位于使用位置附近，则很有可能忘记删除该变量声明。</p>
</div>
<div class="paragraph">
<p>要声明变量，请使用 <code>my</code> 关键字，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在声明变量的同时初始化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 42;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 还定义了常量的概念。这些变量的值只能在初始化器中设置一次。要创建常量，请使用 <code>constant</code> 关键字，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant $C = 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>无法为常量指定新值。</p>
</div>
<div class="paragraph">
<p>现在，让我们看看 Raku 中有哪些变量可用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_raku_中的变量容器">3.1.2. Raku 中的变量容器</h4>
<div class="paragraph">
<p>变量容器有三种基本类型:标量，数组和散列。首先，你会学习如何在代码中使用它们的基础知识。然后，在本章后面的"使用内置数据类型"一节中，我们将深入研究该语言中可用的数据类型。</p>
</div>
<div class="paragraph">
<p>容器的结构类型由称为 <strong>sigil</strong> 的特殊字符表示。它永远在变量名之前，在许多情况下，可以认为它是变量名的一部分。</p>
</div>
<div class="paragraph">
<p>变量名是标识符。标识符是一串字母字符， 数字，下划线字符和连字符。第一个字符不能是数字或连字符。字母数字字符是 Unicode 意义上的，因此，与连字符一起使用，可以创建非常富有表现力的变量名。标识符是大小写敏感的。</p>
</div>
<div class="paragraph">
<p>在以下小节中，您将看到命名变量的示例。注意变量总是以 sigil 开头，而裸标识符可以是函数名或类名， 正如我们将在本书的其他章节中看到的那样。</p>
</div>
</div>
<div class="sect3">
<h4 id="_标量">3.1.3. 标量</h4>
<div class="paragraph">
<p>标量是一个可以保留像整数，字符串或对象这种单个值的容器。</p>
</div>
<div class="paragraph">
<p>标量变量使用 <code>$</code> sigil。我们在前面的章节中已经看到过一些例子，这里还有一些。请注意，如果没有显式声明 数据类型，同一个标量变量可以在不同时刻托管不同类型的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 42;
say $x;
my $y = $x * 2;
say $y;

$x = 'Hello, World!';
say $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>(当然，最好不要在程序流中更改数据类型。)</p>
</div>
<div class="paragraph">
<p>在双引号中的字符串内部，标量变量被内插并由它们替换当前值。在以下程序中，将计算方程的过程打印为字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 3;
my $b = 4;
my $c = sqrt($a * $a + $b * $b);

say "If the legs of a right triangle are $a and $b, ";
say "then the hypotenuse is $c.";</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码打印以下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">If the legs of a right triangle are 3 and 4, then the hypotenuse is 5.</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，让我们继续讨论下一种变量类型-数组。</p>
</div>
</div>
<div class="sect3">
<h4 id="_数组">3.1.4. 数组</h4>
<div class="paragraph">
<p>数组变量可以托管多个值。值可以是相同类型，也可以是不同类型。数组通常用于保存数据项列表。</p>
</div>
<div class="paragraph">
<p>Raku 中的数组以 <code>@</code> sigil 为前缀。要访问数组的元素，请使用一对方括号后缀。例如，<code>@a</code> 数组的第二个元素是 <code>@a[1]</code>。 请注意，索引从零开始。</p>
</div>
<div class="paragraph">
<p>我们来看看如何创建整数数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @odd_numbers = 1, 3, 5, 7, 9, 11;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，您可以使用圆括号或尖括号。以下两个数组与前一个相同:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array2 = (1, 3, 5, 7, 9, 11);
my @array3 = &lt;1 3 5 7 9 11&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>say</code> 内置函数打印时，Raku 会打印出数组的内容，带上方括号，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @odd_numbers; [1 3 5 7 9 11]</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下是包含混合类型数据的数组的另一个示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array = 1, 'two', 3E-2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的所有元素都是不同的类型(整数，字符串和浮点值)，但是可以通过索引轻松访问它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @array[0]; # 1
say @array[1]; # two
say @array[2]; # 0.03</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们进一步了解 Raku 中提供的数组可能性。</p>
</div>
<div class="sect4">
<h5 id="_array_类型的方法">Array 类型的方法</h5>
<div class="paragraph">
<p>Raku 中的数组实际上是 Array 类的一个对象。使用类是第八章中面向对象编程的一个主题。到目前为止，我们将讨论如何访问 Raku 程序中数组的不同属性。</p>
</div>
<div class="paragraph">
<p>要获取数组的长度，请调用 <code>elems</code> 方法，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 3, 5;
say @a.elems; # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>push</code>，<code>pop</code> 和 <code>append</code> 这三个方法修改数组: <code>push</code> 添加一个新元素到数组的末尾; <code>pop</code> 获取最后一个元素，将其从数组中删除，然后返回它; <code>append</code> 在最后添加新元素，与 <code>push</code> 不同，可以添加多个新元素。让我们检查以下程序的输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 3, 5;

@a.push(7);
say @a; # [1 3 5 7]

say @a.pop; # 7
say @a; # [1 3 5]

my @b = 9, 11;
@a.append(@b);
say @a; # [1 3 5 9 11]</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，您可以使用函数而不是方法。前面的程序可以用不同的方式编写，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 3, 5;

push @a, 7;
say @a; # [1 3 5 7]

say pop @a; # 7
say @a; # [1 3 5]
my @b = 9, 11;
append @a, @b;
say @a; # [1 3 5 9 11]</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一组，<code>unshift</code>，<code>shift`和 `prepend</code>，是 <code>push</code>，<code>pop</code> 和 <code>append</code> 方法的补集。<code>unshift</code> 方法将一个元素添加到数组的开头; <code>shift</code> 删除并返回第一个元素; <code>prepend</code> 在开头添加新元素。 以下代码块演示了使用这些方法的效果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 3, 5;

@a.unshift(7);
say @a; # [7 1 3 5]

say @a.shift; # 7
say @a; # [1 3 5]

my @b = 9, 11;
@a.prepend(@b);
say @a; # [9 11 1 3 5]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>splice</code> 方法将数组切割成三个部分，并使用一个新的列表可选择地替换中间的部分。<code>splice</code> 方法的前两个参数是将被删除或替换的第一个元素的索引以及该片段的长度。例如， 考虑以下代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @even = 2, 4, 6, 8, 10, 12, 14, 16, 18, 20;
@even.splice(4, 3);
say @even; # [2 4 6 8 16 18 20]</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，将从原始数组中移除具有索引4,5和6的三个元素。</p>
</div>
<div class="paragraph">
<p>在下一个示例中，相同的元素将替换为值100和200:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @even = 2, 4, 6, 8, 10, 12, 14, 16, 18, 20;
@even.splice(4, 3, (100, 200));
say @even; # [2 4 6 8 100 200 16 18 20]</code></pre>
</div>
</div>
<div class="paragraph">
<p>替换的长度不必与移除部分的长度相同。</p>
</div>
</div>
<div class="sect4">
<h5 id="_散列">散列</h5>
<div class="paragraph">
<p>在数组中，索引是从零开始的整数。散列是 Raku 中另一种结构的数据类型，可以视为索引为字符串的数组。</p>
</div>
<div class="paragraph">
<p>散列使用 <code>%</code> sigil。来自各种编程语言的散列的其他名称是关联数组，字典或词典以及映射。散列在您需要保存一些值时非常有用。例如，请查看以下代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %city =
    name =&gt; 'London',
    country =&gt; 'gb',
    latitude =&gt; 51.52,
    longitude =&gt; 0,
    area =&gt; 1577,
    inhabitants =&gt; 8_700_000;</code></pre>
</div>
</div>
<div class="paragraph">
<p>散列的元素是对，它们又是两个东西 - 键和值。在这个例子中，<code>%city</code> 散列的键是 <code>name</code>，<code>country</code> 等，它们的值是 <code>London`和 `gb</code>。</p>
</div>
<div class="paragraph">
<p>可以更改此类赋值中的代码布局以对齐键和值，你可以在这里看到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %city =
    name        =&gt; 'London',
    country     =&gt; 'gb',
    latitude    =&gt; 51.52,
    longitude   =&gt; 0,
    area        =&gt; 1577,
    inhabitants =&gt; 8_700_000;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在赋值中，散列对可以用括号括起来，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %city = (
    name =&gt; 'London',
    country =&gt; 'gb',
    latitude =&gt; 51.52, longitude =&gt; 0,
    area =&gt; 1577,
    inhabitants =&gt; 8_700_000);</code></pre>
</div>
</div>
<div class="paragraph">
<p>当打印散列(<code>say %city</code>)时，它会显示在一对花括号中，如以下代码行所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">{area =&gt; 1577, country =&gt; gb, inhabitants =&gt; 8700000, latitude =&gt; 51.52, longitude =&gt; 0, name =&gt; London}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果有相同名称的键，则最后一个获胜。考虑以下散列的创建:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %city =
    name =&gt; 'London',
    name =&gt; 'Paris';
say %city;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序只打印 <code>{name &#8658; Paris}</code>。</p>
</div>
<div class="paragraph">
<p>本节中的信息足以继续学习 Raku 中的类型。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用简单的内置数据类型">3.2. 使用简单的内置数据类型</h3>

</div>
<div class="sect2">
<h3 id="_操作日期和时间的数据类型">3.3. 操作日期和时间的数据类型</h3>

</div>
<div class="sect2">
<h3 id="_总结_3">3.4. 总结</h3>
<div class="paragraph">
<p>Hash类的方法 让我们看看哈希有哪些方法可用。
首先，两个方法，键和值，返回包含所有的列表(序列，严格)
哈希的键和值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>类似的方法，对，返回一对对的列表(对是包含键和a的数据类型 值):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>散列的大小，实际上是其中的对数，由elems返回 方法，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>命名约定
Raku不强制用户遵循变量名的任何特定命名约定。 不过，最好遵循一般的常识方法。变量名称可以是 简短的一个字母，但它们也可以是描述性的，包含许多单词。
单字母名称是循环中的最佳选择，或者在某些计算中所有的 变量的提及位置紧凑，在屏幕上清晰可见。单- 当然，字母名称可以使用小写和大写字母。虽然没有
Raku中的标准，大写名称用于常量和伪常量
文件; 例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>以下是单字母名称的一些示例: 常数$ N = 100;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre> 使用变量和内置数据类型 说“你进入$ n”;
如果$ n&gt; $ N，说“这个数字太大了”;
对于更长的名字，有一些替代品。要么是以小写或大写字母开头， 或者整个名称都是大写的。同样，大写名称如$ MAXIMUM更好 表示常量，即使您不使用常量关键字。一般来说，小写</pre>
</div>
</div>
<div class="paragraph">
<p>名字是可取的。让我们重写之前的程序，以便它使用更长的变量
名称:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在许多情况下，甚至需要更长的名称。在这种情况下，有几种方法可以构建 使用两个或多个单词的名称。首先，您可以使用所谓的驼峰案例名称 例如，$ userValue或$ valueFromInput。其次，下划线字符很好 用于连接name- $ user_value或$ value_from_input的部分的候选者; 这种风格叫做蛇案。最后，Raku允许带有破折号的奢侈名称
例如，$ user-value或$ MAXIMUM-VALUE(烤肉串案例)。 - 字符不是减号 在这种情况下，运算符，并且是名称的一部分。那么，$ uservalue，$ userValue，
$ user_value和$ user-value名称是四个不同的名称。考虑以下 代码段:
常数$ MAXIMUM-VALUE = 100;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>选择自己的风格，并尝试在整个计划中始终如一地使用它。
键入的变量
在前面的示例中，托管在变量容器中的内容类型是
由分配给变量的值定义:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用变量和内置数据类型
Raku允许您通过一起指定变量容器的类型 带有变量声明:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，$ x变量只能接受整数。尝试将其分配给字符串，
例如，将导致以下错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>类似地，Raku允许在同一个数组中使用不同类型的元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>声明具有类型的数组会使其元素类型值。这意味着你不能
为其分配另一种类型的值，如下一个示例所示: 我的Int @a;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一个分配导致类型检查错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>类型化变量可以使用任何内置类型或用户定义的类。在下一节中， 我们将在默认情况下讨论Raku中可用的数据类型。在第8章，面向对象 编程，您将学习如何创建自己的类。
使用简单的内置数据类型
Raku带有许多内置类型，涵盖了常见的范围 诸如布尔值，整数和字符串之类的东西，但也提供不寻常的数据类型。我们会 在本节中介绍它们。为了演示内置类型，我们将它们打印到 使用say函数的控制台，正如我们在&#8217;Hello，World!'中所做的那样 例。</p>
</div>
<div class="paragraph">
<p>层次结构使用两种类型的项构建:角色和类。角色以椭圆形绘制， 类是矩形框。角色类似于某些编程中的接又 语言。在本章中，我们不会关注什么是角色或类的细节。您可以 详细了解 第8章，面向对象的编程。现在，我们将假设 你对面向对象编程有一些基本的了解，并且能够 了解数据类型的层次结构。
在本章的以下部分中，我们将介绍您的主要数据类型
可以在你的练习中使用。
 使用变量和内置数据类型
整数数据类型
Int类型的值是Raku中的整数值。该值可以包含正数和 负数，以及零，语言不限制数字的大小。它 可以小到一个字节，例如，看看下面的例子:
说42; 它也可以是任意精度，如下所示:
比如239874637819093248768900298372340;
在前面的例子中，使用了通用的十进制表示法。Raku允许使用其他 基地; 例如，16表示十六进制值。使用除以外的基数创建整数 10，使用所谓的状语表示法，如下例所示:
说:16 &lt;D0CF11E&gt;; 这将打印218951966，这是十进制表示
:16 &lt;D0CF11E&gt;整数。 以同样的方式，您将使用其他基础创建值。考虑以下</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>基值不一定是2的幂。2之间的其他整数值 例如，允许36，考虑以下代码行:
说:5 &lt;342&gt;; 说:30 &lt;102spqr&gt;;
在第一个例子中，基数是5，因此，数字0到4在表示中可用 一个号码。值:5 &lt;342&gt;对应于十进制形式的97。
在第二个例子中，我们可以自由使用更多的“数字”，即30个。那些数字是 常规的阿拉伯数字0到9，后跟拉丁字母的20个字母，它们是a到t。 十进制值:30 &lt;102spqr&gt;是731399307。</p>
</div>
<div class="paragraph">
<p>您可能已经注意到，在前面的示例中，一些字母数字是大写的 有些是小写的。对于Raku，没有区别; 它们的整数位数 包括字母字符，不区分大小写。所以，数字:16 &lt;D0CF11E&gt;和
:16 &lt;d0cf11e&gt;，以及:30 &lt;102spqr&gt;和:30 &lt;102SPQR&gt;是等效的。 不区分大小写会间接定义允许的整数基数范围; 就像我们一样
10个阿拉伯数字和26个拉丁字母，它们的组合提供36种不同的字符。
在Raku中，长整数值(即具有多个数字的整数)可以拼写为 使用下划线字符将数字组视觉分离。最多 该功能的直接目标是提供将数字拆分为的方法 三位数组。例如，请考虑以下代码行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，75_926_028的符号只不过是给出75926028的数字， 但它让我们清楚地看到这个数字是7500万，926千和28 编译器，没有区别，两个数字同样易于阅读。对于人类而言 更容易阅读分成组的数字。
从技术上讲，您不仅限于分割数字的方式。这意味着
以下格式正式正确:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>此格式可能适用于电话号码，但不适用于常规整数。
但是，您不能连续两个下划线。数字也不能开始或结束
用它。以下三次尝试将无法编译:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码将生成编译器错误:</p>
</div>
<div class="paragraph">
<p>数字内部只允许使用隔离的下划线</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这两种情况下的错误消息有点短，编译器只是说它是:
困惑
使用变量和内置数据类型
Int类型的方法
Raku中的数据类型由许多内置类表示，这意味着 可以在这些类的对象上调用方法。面向对象的特性 语言在第8章中描述，面向对象的编程，但是，现在，它不是 可以避免它的一些元素。
在本节中，仅列出最有趣的方法。完整的可能性列表 可以在文档页面上获得(HTTPS:/。。/文档raku组织/类型/诠释)。
现在最重要的是使用点调用方法
在值本身或包含相应类型值的变量上。
您将在下一节中看到立即调用方法的方法。
使用chr方法转换为字符 整数值可以转换为相应的字符。通信是
由Unicode代码点定义。 在值低于256的情况下，它与ASCII表一致。考虑以下因素
代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>较高的值会从Unicode表中生成字符，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用十六进制表示可以获得相同的结果，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>检查数字是否为素数
is-prime方法返回一个布尔值，告诉我们该数字是否为素数 数字与否，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>对大数字执行is-prime方法可能很慢。</p>
</div>
<div class="paragraph">
<p>生成随机数
rand方法返回零和给定值之间的随机数。请注意 此方法继承自Real角色(请参阅开头的图表 在使用简单的内置的数据类型部分)，并且返回值是一个浮点数:
说100.rand; 运行此代码几次会导致打印不同的值，如下所示:
70.1530942429978 57.2150256026057 13.7542877975353 94.6395293813437
获得价值的标志
sign方法(也从Real角色继承)返回-1或1，具体取决于 价值的标志。请考虑以下代码段:
说42.sign; #1 说-42.sign; #-1
调用方法为零的结果为0，如下所示: 说0.sign; #0
符号方法也适用于无穷大: 说Inf.sign; #1
说(-∞).sign; #-1 计算值的平方根
要计算值的平方根，请在其上调用sqrt方法: 说9.sqrt; #3
该例程在Raku中也被定义为独立的内置函数。考虑一下 以下代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>获取下一个和以前的值
pred和succ这两个方法相应地返回上一个和下一个值 对于整数参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>当它们加1或减1时，此方法也适用于非整数值，如图所示 下一个片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>方法的名称来自前任和后继。
获得绝对价值
abs方法返回绝对值。在以下示例中，调用该方法 在变量上:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>要在值上调用它，负值需要括号。否则，一元 减运算符(参见更多 第4章，使用运算符)将应用于结果 调用abs方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>Rational数据类型
在Raku中，存在一种特殊类型的Rat来存储有理数。在很多情况下，老鼠会 在处理浮点数时使用。在内部，表示Rat值 由一对整数值，分子和分母组成。因此，任何Rat数都是a 理性值等于划分N / D. 整数分子部分是可以的值 任意长。分母部分是64位整数。
只要您有一个带小数点的常量而没有一个，就会出现鼠值
指数部分。请考虑以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre> 使用变量和内置数据类型 3.14文字在这里创建了一个Rat值。
还有另一种创建Rat值的语法:在除法中使用斜杠，可选地， 在一对尖括号中包含一个数字，如下所示:</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，您可以为分数使用Unicode字符。例如，以下行将 创建一个等于0.5的Rat数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>Rat值的内部结构为精确计算提供了极好的能力。 与许多其他语言不同，浮点运算使用IEEE数字 精度有限，在Raku中，使用Rat数字有助于避免舍入误差 使用较小的数字时，或者例如两个数字如此接近 另外，他们无法使用IEEE表示法进行精确比较。
在以下示例中，我们将使用Rat编号: 比如1/2 + 1/4 + 1/8 + 1/16;
比如0.1 + 0.2 - 0.3;
最后一个例子很有趣，因为它在Raku中打印0.Raku使用Rat进行计算， 并在内部将值视为1 / 10,2 / 10和3/10。因此，0.1 + 0.2 - 0.3的总和是 相当于1/10 + 2/10 - 3/10，这导致Rat值为0/10，为零。在很多 其他使用浮点数的语言，包括Perl 5，相同的计算方法 不产生零。结果很小，但仍然不为零; 对于 例如，5.55111512312578e-17。
使用Rat进行精确计算的优势显而易见。例如，在财务方面 计算时，您可以使用鼠标数字来避免舍入错误。(但在很多情况下，在 财务计算，您可以使用整数并计算美分; 所以，而不是保持 9.99欧元作为浮点数，代替999美分。)
大鼠类型的方法
Rat方法有一些特定的方法和许多遗传的方法 来自其基类或角色，例如Real或Numeric。其中一些方法已经存在 讨论，在Int类型的方法部分。</p>
</div>
<div class="paragraph">
<p>获取值的Perl表示
Perl方法返回一个字符串，可以表示Raku理解的Rat值 在源代码中。结果可以包含小数点或斜杠，具体取决于</p>
</div>
<div class="paragraph">
<p>什么是更好的精确表示价值。
考虑一些显示上述想法的示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>更多，以下代码是有效的Raku代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>转换为Int值
要将Rat值转换为整数值，请调用Int方法。这是一般的 类型转换的原则:数据类型定义名称重复名称的方法 其他数据类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个程序中，$ x.Int的结果是3，但是你应该记住10/3 赋值不是一个除法，而是一种表达大鼠数字的方法。同样可以做到 使用更明确的表单，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>要获得Rat值的两个部分，请使用分子和分母方法。让我们 看看它们如何处理上一节中的值的示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>舍入值的方法
有四种不同的方法可以将Rat值转换为整数:round，ceiling， 地板，并截断。
round方法根据数学定义舍入值:值为 四舍五入到最接近的整数。我们可以在以下代码片段中看到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>(请注意，第一个点分隔数字的小数部分，而第二个点是a</p>
</div>
<div class="paragraph">
<p>负值也会舍入，以便结果是最接近的整数。我们可以看到
在以下代码段中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>截断方法只是删除小数部分，无论符号如何，如下所示: 比如3.14.truncate; #3</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，这对天花板和地板方法将数字四舍五入到下一个或前一个
整数，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这两种方法的工作方式类似于它们处理整数值的方式。整数部分是
返回，递增或递减，而浮动部分不变，如图所示
如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用变量和内置数据类型
数字数据类型
Num类型用于存储浮点值。它对应于双精度 C。
请注意，在Raku中，仅在数字文字拼写为a时创建Num值 科学计数法。也就是说，值的E部分必须存在。
因此，在以下示例中，仅具有小数点的数字将是Rat 类型:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>以下数字表示相同的值，但属于Num类型，因为它们使用 其定义中的指数部分:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住，Num值使用打包的IEEE二进制格式，因此它们受限制 精度，而Rat数字将分子和分母保持为两个整数
数字。
在Num值中，有一个突出的NaN值，代表Not a 数。
Num与Numeric vs. Real
正如您在类型层次结构图中看到的，某些节点位于椭圆形中 而不是矩形框。那些是角色。角色为类提供了一些接又 是从他们继承而来的。我们将在更详细地讨论角色第8章，对象 - 面向编程。
Numeric角色为我们提供的一些方法是:Real，Int，Rat，Num， 和Bool将值转换为其他数据类型; log，log10，exp，roots，abs和sqrt 用于相应的数学计算; 这对和prec和succ。
除其他外，Real角色类为我们提供了以下方法:rand，sign，round， 地板，天花板和截断。</p>
</div>
<div class="paragraph">
<p>使用变量和内置数据类型 如果你想深入挖掘并查看类之间的所有连接，请参阅
 列出的文档页面 HTTPS:/。。/文档raku组织/ HTML类型。。 枚举
枚举是用于定义某些可能值的数据类型
概念。例如，交通灯颜色有三个值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku已知这些值的名称，因此您可以直接在a中使用它们
程序，例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码打印值的名称:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，红色，黄色和绿色名称的实际值并不重要 对于我们而言，Raku会为它们分配增加的整数值。
说红+黄+绿; #6 这个程序相当于</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>当值很重要时，您可以明确指定它们，就像我们下一步那样
例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将在布尔类型的定义中看到枚举的一个例子
Raku在下一节中。 布尔数据类型
Bool是一种布尔数据类型，它提供两个值:True和False。从技术上讲，这是 具有两个值的枚举:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用变量和内置数据类型 布尔类型的使用非常简单。我们将看到更多的用法
布尔数据类型 第5章，控制流程。 Bool类型的方法
Bool类型有一些方法，我们已经看到使用Int和 大鼠数据，但他们的行为可能略有不同。
使用pred和succ
 这两种方法，pred和succ，都有一个由非常有限的范围引起的特征 可用值。您不应期望值循环。方法的结果 显示在以下代码段的注释中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>生成随机布尔值的方法
有两种方法，pick和roll，这两种方法都可以调用或不调用 论点。必须在类名本身上调用这些方法，而不是在它的值或a上调用 变量。
如果在没有参数的情况下调用pick或roll，它们也会返回一个随机值 对或错。我们可以在以下代码片段中看到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用整数参数调用方法时，随机值列表为
产生。整数参数定义列表中的元素数量，但最重要的是 因此，pick方法添加其限制并仅返回唯一值，在这种情况下 Bool类，不超过两个。比较类似调用的结果，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre> 使用变量和内置数据类型
字符串数据类型
字符串由Raku中的Str数据类型表示。字符串是Unicode序列 字符。考虑以下代码段:</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们直接看看Str类的方法。 Str类的方法
重要的是要始终牢记所有语义都符合规则 Unicode格式。这意味着，例如，将字符串转换为大写将会改变 相应的字符，即使它们需要多个字节的内存。
转换寄存器
有许多方法可以更改字符串中字母的寄存器。第一集 包含简单的lc和uc，它将所有字符转换为小写或大写。考虑 以下代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>其他四种方法更复杂。
fc方法将字符串转换为所谓的fold case。它旨在用于字符串 比较。例如，比较字符串上调用的三个方法的输出 德语字母ß，拼写为SS大写，但在折叠中转换为ss- 案件。请考虑以下代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>(请记住，自2017年6月起，德语正式上版 ß，我们可以在这里知道 HTTPS:/。。/ EN维基百科组织/维基/ Capital_</p>
</div>
<div class="paragraph">
<p>方法的行为可能会改变。)
 使用变量和内置数据类型
tc方法将字符串转换为所谓的标题大小写，其中字符串的第一个字母 是资本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>wordcase方法将每个单词的第一个字符大写，然后完成其余的单词
小写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>另一组方法 - 修剪，修剪前导和修剪 - 尾随 - 削减空间 在字符串的开头和/或结尾。请考虑以下代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>检查字符串内容的方法
Str类定义了一对方法 - starts-with和ends-with-check 字符串是否在其开头或结尾包含给定的子字符串，并返回a 布尔值。请考虑以下示例，该示例显示了这些行为
方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用正则表达式而不是start-with和end-with; 参考章节 11 ，Regexes，详情。
另一组函数index，rindex和indices-查找子字符串并返回它 位置。索引方法查找子串的最左侧出现rindex 从字符串末尾搜索，索引返回所有出现的索引列表 子串。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>值得注意的是，虽然rindex方法从字符串的末尾搜索，但它 返回从左到右计数的字符的索引。
字符串的长度
要获取字符串的长度，请按如下方式调用chars方法: 说&#8217;杜塞尔多夫'.chars; #10
反转一个字符串
flip方法返回字符串，其中所有字符的顺序相反，如 如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>复数
在Raku中，有一个Complex内置类型来表示复数。 复数有两个部分，实数和虚数，并使用以下语法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>没有必要明确拼出实部，但输出总是包含它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>创建复数的另一种方法是调用构造函数(我们将讨论 第8章，面向对象编程中的构造函数，如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>复杂数据类型的方法
我们已经熟悉了一些方法。这些是圆形，天花板，地板和
truncate，它改变复数值的实部和虚部。让我们来 简要介绍一下其他方法。
获得真实和虚构的部分
这两个方法 - 重新和即时 - 返回复数的实部和虚部，如 如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在没有变量i的情况下返回虚部。
reals方法返回包含两个值的列表，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>用于操纵日期和时间的数据类型</p>
</div>
<div class="paragraph">
<p>Raku提供内置支持以处理日期和时间。这非常方便，因为日期 - 时间计算并不容易(你需要考虑闰年，额外的秒数，时间
区域，日历更正等)。 我们将介绍两个类:Date和DateTime。
使用Date类
Date类表示日期 - 三个数字，年，月和日的集合
这个月。要创建新日期，请使用以下三个值调用构造函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>要根据今天的日期创建变量，请使用today方法，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>要克隆日期，请调用clone，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>日期的单独部分可以从日期明确命名的方法中获得，如
如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>另外(这已经是一个很好的奖励)，Date类可以计算出的日期 周(周一是1，周日是7):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用变量和内置数据类型 一些方法有助于计算周数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于1月份的几周，可以通过周和周年方法返回的年份 要么是前一年，要么是下一年，具体取决于当天属于哪一周。对于 以2019年的最后一天和2020年的第一天为例。2019年12月31日是</p>
</div>
<div class="paragraph">
<p>2020年1月1日星期二和1月1日是星期三。两天都属于同一周，所以 周 - 年方法返回2020.检查以下程序的输出
了解该方法的工作原理:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>有一个有趣的工作日的方法可以返回出现的次数 在给定日期之前的这个月的这一天的这一天。例如，2017年7月19日是 2017年7月第三个星期三:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>要获得昨天和明天的日期，请使用我们拥有的pred和succ方法 已经在数值数据类型中看到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用DateTime数据类型 DateTime数据类型的使用与使用Date类型非常相似。在里面
DateTime对象，处理时间的新字段出现。我们可以在下面看到 代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>要创建新的DateTime对象并将其设置为当前时刻，请使用now构造函数， 如下图所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>hh-mm-ss和yyyy-mm-dd方法生成时间和日期的格式化字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>打印秒钟时要小心。第二种方法返回一个浮点数
含有一秒的分数。要获取整数值，请使用全秒方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_4">3.5. 总结</h3>
<div class="paragraph">
<p>在本章中，我们查看了Raku中内置数据类型的概述并进行了学习 如何使用变量。最重要的事实是Raku中的变量是实例 不同的内置数据类型类。这些课程的详细信息位于章节
8 ，面向对象编程，但是面向对象编程的一些元素是 需要在Raku中成功创建和使用变量。
在本章的第一部分中，您学习了三种结构类型的变量
容器 - 标量，数组和散列 - 并检查它们的主要方法。在第二 部分，我们深入研究了不同的数据类型，例如整数，有理数，浮点数 - 点数，字符串，日期和时间。
在下一章中，我们将继续观察Raku程序中的流控制。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_使用运算符">4. 使用运算符</h2>
<div class="sectionbody">
<div class="paragraph">
<p>运算符是语言语法的元素，它们对操作数执行操作并返回结果。Raku 是一种拥有一堆运算符的语言。他们中有一些继承于 Perl 5(直接或修改)，有些是专门为 Raku 而发明的
。在常规运算符集合之上，Raku 定义了所谓的元运算符和超运算符，它扩展了常规运算符对于一组值运算的意义。</p>
</div>
<div class="paragraph">
<p>在本章中，我们将介绍以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>运算符分类</p>
</li>
<li>
<p>一元运算符</p>
</li>
<li>
<p>二元运算符</p>
</li>
<li>
<p>三元运算符</p>
</li>
<li>
<p>按位运算符</p>
</li>
<li>
<p>其他运算符</p>
</li>
<li>
<p>运算符优先级</p>
</li>
<li>
<p>替换元运算符</p>
</li>
<li>
<p>赋值元运算符</p>
</li>
<li>
<p>否定元运算符</p>
</li>
<li>
<p>反转元运算符</p>
</li>
<li>
<p>创建超运算符</p>
</li>
<li>
<p>超操作的类型</p>
</li>
<li>
<p>化简超运算符</p>
</li>
<li>
<p>交叉超级运算符</p>
</li>
<li>
<p>Zip 超运算符</p>
</li>
<li>
<p>顺序超运算符</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Raku 中有几十个内置运算符。为了使概述更加结构化， 我们将它们分组，对应于我们在中描述的类别
前几节:
中缀运算符 后缀运算符 Circumfix运算符 Postcircumfix运算符
在以下部分中，我们将检查分组为这些类别的Raku的运算符。 在每个类别中，运算符按降序排列。</p>
</div>
<div class="sect2">
<h3 id="_运算符分类">4.1. 运算符分类</h3>
<div class="paragraph">
<p>首先，让我们回顾一下我们需要的一些关于运算符的基本术语 。考虑一个简单的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 10;
my $b = 20;
my $c = 0;
$c = $a + $b;
say $c; # 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们来专注于下面的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$c = $a + $b;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们告诉编译器执行两个动作 - 首先，计算 <code>$a</code> 和 <code>$b</code> 变量的总和，其次，将结果分配给第三个变量，即 <code>$c</code>。这个例子中是两个运算符 - <code>+</code> 和 <code>=</code>。运算符由它们的单字符名字表示。在这种情况下，选择名称来复制相应的数学运算符。稍后，我们将看到其他运算符的示例，这些运算符不仅仅是一个字符。 例如，它们可以是两个或三个非字母符号的序列，例如 <code>&gt;=</code> 或 <code>&#8656;</code> 运算符。或者，它们可以是字符串标识符，例如-<code>cmp</code> 或 <code>eq</code>。</p>
</div>
<div class="sect3">
<h4 id="_运算符的类别">4.1.1. 运算符的类别</h4>
<div class="paragraph">
<p>在上一节中，我们看到了一个 <code>+</code> 运算符的示例，它带有两个参数。 还有许多其他类似于 <code>+</code> 的运算符。例如，* 是乘法运算符。与 <code>+</code> 运算符一样，* 运算符接受两个参数并返回一个值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = $a * $b;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种运算符称为中缀运算符，或简称为中缀。这种运算符的操作数通常被称为左操作数和右操作数。因为这种运算符接收两个参数，所以它们通常也称为二元运算符。</p>
</div>
<div class="paragraph">
<p>另一种运算符只需要一个参数。这些运算符称为一元运算符。一元运算符的典型示例是一元减法。在以下示例中， 这个运算符否定了它的参数值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 10;
my $b = -$a;
say $b; # prints -10</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，此运算符使用与二元减法运算符相同的字符，但程序员和编译器可以区分两者:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 10;
my $b = -$a;     # unary minus, $b becomes -10
my $c = $a - $b; # binary subtraction, $c is 20</code></pre>
</div>
</div>
<div class="paragraph">
<p>不同的一元运算符可以放在参数之前或之后。例如， ++ 运算符有两种形式 - 前缀和后缀。以下示例演示了两种选择:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 10;
++$a; # prefix operator ++
$a++; # postfix operator ++</code></pre>
</div>
</div>
<div class="paragraph">
<p>操作符的位置(在参数之前或之后放置)会改变它含义。</p>
</div>
<div class="paragraph">
<p>到目前为止，我们遇到了中缀，前缀和后缀运算符。还有两个类别的 Raku 运算符。</p>
</div>
<div class="paragraph">
<p>环缀运算符是另一种一元运算符。与一元运算符 <code>-</code> 不一样，环缀运算符由两个互补的部分组成，例如括号。环缀运算符唯一的操作数放在这俩个括号之间，例如 <code>[$a]</code> 构造使用带有 <code>$a</code> 作为参数的 <code>[]</code> 环缀运算符。</p>
</div>
<div class="paragraph">
<p>最后，还有后环缀运算符。他们需要两个操作数，语法如下-<code>操作数1[操作数2]</code>。后环缀运算符最实用的例子之一是函数调用。我们已经看到过几次了-<code>add($a, $b)</code>。</p>
</div>
<div class="paragraph">
<p>让我们使用 <code>+</code> 运算符符号作为例子总结下表中的运算符类别:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">类别</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">语法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">中缀</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">操作数1 +  操作数2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">前缀</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+操作数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">后缀</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">操作数+</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">环缀</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(操作数)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">后环缀</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">操作数1[操作数2]</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_运算符作为函数">4.1.2. 运算符作为函数</h4>
<div class="paragraph">
<p>运算符对其参数执行一些操作。运算符的参数叫做操作数。在前面的示例中，<code>+</code> 运算符接收两个操作数 <code>$a</code> 和 <code>$b</code>。 <code>=</code> 运算符也接收两个操作数 - 它期望将其右侧操作数的值赋值给左侧变量。</p>
</div>
<div class="paragraph">
<p>在任何编程语言中，运算符只是一个方便的语法解决方案， 它使程序更具表现力，可以通过函数调用来替换。例如，在前面的例子中，你写的是 <code>$c = $a + $b</code>，但你也可以通过调用 <code>add</code> 函数来做同样的事情， 就像我们在第一章的 Raku 是什么中看到的那样。让我们重写前一个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 10;
my $b = 20;
my $c = 0;
$c = add($a, $b);
say $c; # 30

sub add($a, $b) {
    return $a + $b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，<code>add</code> 函数本身使用 <code>+</code> 运算符，但这里我们无法避免它，因为 Raku 中没有更多用于加法的低级函数。此示例的目的是为了证明运算符可以始终被视为接受几个参数并返回一个值的函数，但是你不直接调用它们; 而是通过一个好看的运算符。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，您可以在使用运算符时使用函数样式。为此，使用带有运算符类别名的关键字，后跟冒号和包含在尖括号中的操作符本身。然后，像函数那样传递参数。以下示例在 <code>+</code> 中缀运算符的示例中演示了这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 10;
my $b = 20;
my $c = infix:&lt;+&gt;($a, $b); # same as $c = $a + $b
say $c; # 40</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，让我们讨论 Raku 提供的运算符的类别。 现在，是时候逐一检查运算符了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_raku_中的运算符">4.1.3. Raku 中的运算符</h4>
<div class="paragraph">
<p>Raku 中有很多内置运算符。为了让概览看起来更加结构化，我们会将它们分组到前面的章节所描述的对应的类别里面:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>中缀运算符</p>
</li>
<li>
<p>后缀运算符</p>
</li>
<li>
<p>环缀运算符</p>
</li>
<li>
<p>后环缀运算符</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在下面的小节中，我们会检查 Raku 红被分组为这些类别的运算符。在每个类别之内，运算符按照倒序的优先级安排。</p>
</div>
<div class="sect4">
<h5 id="_中缀运算符">中缀运算符</h5>
<div class="paragraph">
<p>中缀运算符可能是该语言中最常用的运算符。他们也是最直观的运算符。</p>
</div>
</div>
<div class="sect4">
<h5 id="_赋值运算符">赋值运算符</h5>
<div class="paragraph">
<p><code>=</code> 运算符是赋值运算符。它用于把右侧操作数的值赋值给它左边的变量。在最简单的情况下，运算符的使用方式如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a;
$a = 42;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该操作不仅限于标量。数组，哈希或类的实例(我们将在第八章的面向对象编程中谈论类。)的赋值也如预期一样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = &lt;10 20 30&gt;;
my @b = @a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，赋值运算符使用了两次，首先初始化 <code>@a</code> 数组，然后将其值分配给第二个数组 <code>@b</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_乘法和除法运算符">乘法和除法运算符</h5>
<div class="paragraph">
<p><code>*</code> 和 <code>/</code> 运算符是乘法和除法运算符。必要时他们的操作数被转换为数字类型。请考虑以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 * 20;
say "10" * "20";</code></pre>
</div>
</div>
<div class="paragraph">
<p>两行代码都打印 200.尽管在第一行中是乘法的操作数都是数字(更确切地说，是 Int 类型)。在第二行，我们试图乘以包含数字的字符串。Raku 为我们把字符串转换为数字，然后 <code>*</code> 运算符完成乘法工作。</p>
</div>
<div class="paragraph">
<p><code>*</code> 和 <code>/</code> 运算符适用于浮点数和复数 (因为 <code>Num</code> 和 <code>Complex</code> 类型都实现了 <code>Numeric</code> 角色):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say pi * e;             # 8.53973422267357
say (10+3i) * (2-3.3i); # 29.9-27i</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意复数的相乘，如前面的例子所示。要得到正确的结果，您应该将复数的部分分组在括号中。如果你省略了它们，编译器将解释表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 + 3i * 2 - 3.3i; # 10+2.7i</code></pre>
</div>
</div>
<div class="paragraph">
<p>解释为如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 + (3i * 2) - 3.3i;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在算术表达式中，<code>*</code> 和 <code>/</code> 的优先级高于 <code>+</code> 和 <code>-</code> ，因此根据算术规则按顺序完成所有计算。考虑以下代码块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 + 3 * 6.3 - 3; # 25.9</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果把两个整数值相除，则结果将是 <code>Rat</code> 类型，而不是 <code>Num</code> 类型。要获取 <code>Num</code> 值，则至少有一个操作数必须为 <code>Num</code>，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1 / 2).WHAT;
say (1 / 2.3).WHAT;

say (1e1 / 2.3).WHAT;
say (1e1 / 2.3e-2).WHAT; # Num
say (1 / 2.3e-2).WHAT;   # Num</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>*</code> 和 <code>/</code> 运算符有非 ASCII 形式的等价记法; 你可以使用 <code>×</code> 和 <code>÷</code> 符号代替:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 100;
my $b = 25;
say $a × $b; # 2500
say $a ÷ $b; # 4</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_加法和减法运算符">加法和减法运算符</h5>
<div class="paragraph">
<p><code>+</code> 和 <code>-</code> 运算符是加法和减法运算符。操作数必须是数字类型。</p>
</div>
<div class="paragraph">
<p>关于此运算符没什么好说的; 他们的行为是不言自明的，如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 10;
say $a + 3;  # 13

my $b = 20;
say $b - $a; # 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果与 <code>*</code> 和 <code>/</code> 运算符结合使用，则 <code>+</code> 和 <code>-</code> 运算符的优先级较低，因此适用于标准算术规则。</p>
</div>
<div class="paragraph">
<p>当可以将字符串转换为数字(整数或浮点数)时，即可由编译器执行转换，<code>+</code> 和 <code>-</code> 运算符将使用两个数字作为操作数。请考虑以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = "42";
say $str - 2; # 40</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <code>+</code> 运算符期望它们的参数是数字，所以不能使用 <code>+</code> 运算符来连接字符串。将两个字符串进行相加的幼稚尝试所引发的异常将被编译器捕获。 请使用以下代码，例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str1 = "Hello";
my $str2 = "World";
say $str1 + $str2; # Error</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果编译它，则会出现运行时错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏Hello' (indicated by ⏏)
     in block &lt;unit&gt; at add-str.pl line 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，即使字符串以数字开头，也不会发生字符串转换，例如，字符串 "10 Hello" 导致另一条错误消息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot convert string to number: trailing characters after number in '10⏏&lt; Hello' (indicated by ⏏)</code></pre>
</div>
</div>
<div class="paragraph">
<p>要正确地把字符串转换为数字类型，字符串必须包含数字并且不包含其它任何东西。尽管允许使用空格，如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str1 = " 10 ";
my $str2 = " 20 ";
say $str1 + $str2; # 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>要连接字符串，请使用 <code>~</code> 运算符。</p>
</div>
<div class="paragraph">
<p>可以使用 Unicode 减号代替 <code>-</code> 运算符。可能在终端中视觉上没什么差异，但字符的代码点是不同的-这里的 <code>0x2D</code> - 你可以从键盘输入 Unicode MINUS SIGN: 0x2212:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 20;
my $b = 30;

say $a - $b; # ASCII
say $a − $b; # Unicode</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_取模运算符">取模运算符</h5>
<div class="paragraph">
<p><code>%</code> 是模运算符。它返回其操作数除法的剩余部分，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 100 % 3; # 1
say 10 % 3;  # 1
say 5 % 3;   # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>模运算 <code>$a % `$b</code> 的结果等效于以下罗嗦的表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$a - $b * floor($a / $b);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，<code>floor</code> 是将值向下舍入的函数。采取前面的一个例子 - <code>10 % 3</code>。它的结果意味着可以从 10 中减去几次 3 直到剩下1，1 小于 3，因此不能再减。</p>
</div>
<div class="paragraph">
<p>传统上，模运算符与整数操作数一起使用，但它仍然可以适用有理数和浮点数。这些类型的值可由没有类型强制转换的 <code>%</code> 运算符接受。我们来看看以下例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 % 3.3;   # 0.1 (Rat numbers)
say 10E1 % 3E0; # 1 (same as 100 % 3 but with Num operands)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_除法运算符">除法运算符</h5>
<div class="paragraph">
<p>运算符 <code>%%</code> 称为除法运算符。它告诉左操作数是否可以被右操作数整除。</p>
</div>
<div class="paragraph">
<p>例如，10 除以 3 的整除其余数为 1，因此，<code>%%</code> 运算符将返回 <code>false</code>。如果将 12 除以 3，则没有余数，结果为真，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 %% 3; # False
say 12 %% 3; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$a %% $b</code> 的结果与以下比较相同:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">($a % $b) == 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>它可以用来检查循环中的条件，我们将在第五章的制流中更详细地了解循环。例如，要每 1000 次迭代打印一次消息， 写下面这段代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (0 .. 100_000) {
    say $_ if $_ %% 1000;
    # do some work
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印 1000,2000,3000 等，让您可以看到程序的进度，但是不要用太多的数字来淹没输出。</p>
</div>
</div>
<div class="sect4">
<h5 id="_整除和模运算符">整除和模运算符</h5>
<div class="paragraph">
<p>这对运算符 <code>div</code> 和 <code>mod</code> 是对 <code>/</code> 和 <code>%</code> 运算符的整数模拟。 <code>div</code> 和 <code>mod</code> 运算符将其操作数视为 <code>Int</code> 值，结果也是一个整数。</p>
</div>
<div class="paragraph">
<p>我们来看几个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 100 div 3; # 33
say 10 div 3;  # 3
say 10 div 5;  # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>mod</code> 运算符返回整除的余数，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 mod 3; # 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>必须在将非整数操作数传递给 <code>div</code> 和 <code>mod</code> 运算符之前显式转换它们。否则，会发生编译时错误，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku -e'say 10 div 3.3'
Cannot resolve caller infix:&lt;div&gt;(Int, Rat); none of these signatures
match:
  (Int:D a, Int:D b)
  (int $a, int $b --&gt; int)
  in block &lt;unit&gt; at -e line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>错误消息告诉我们编译器看到了 <code>div</code> 运算符接收一个 <code>Int</code> 和 <code>Rat</code> 操作数，而它只期望在那里看到 <code>Int</code> 或 <code>int</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_按位运算符">按位运算符</h5>
<div class="paragraph">
<p>以加号开头的三个运算符，即 <code>+&amp;</code>，<code>+|</code> 和 <code>+^</code>，是对操作数执行 AND，OR 和 XOR 运算的按位运算符。其操作数必须可转换为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1024 +| 512; # 1536
say 512 +| 512;  # 512

say 1024 +&amp; 512; # 0
say 512 +&amp; 512;  # 512

say 1024 +^ 512; # 1536
say 512 +^ 512;  # 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>按位运算在操作数相应的位上单独执行。</p>
</div>
<div class="paragraph">
<p>如果操作数不是整数值，则通过调用 <code>.Numeric.Int</code> 方法将它们转换为整数。因此，首先，操作数被转换为 <code>Numeric</code> 值然再转换为 <code>Int</code> 值。从实际角度来看，这尤其意味着，浮点值将被截断。请考虑以下示例与前面的例子比较:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 512.67 +| 512;  # 512
say 512.67 +&amp; 512;  # 512</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_整数移位运算符">整数移位运算符</h5>
<div class="paragraph">
<p><code>+&lt;</code> 和 <code>+&gt;</code> 运算符是整数移位运算符。他们将整数操作数按照第二个参数指示的距离向左和向右移动位。以以下代码行为例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 512 +&lt; 2;  # 2048
say 2048 +&gt; 2; # 512</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_字符串逻辑运算符">字符串逻辑运算符</h5>
<div class="paragraph">
<p>这些运算符是字符串的逻辑运算符。他们从 <code>~</code> 字符开始，遵循字符串操作使用波浪号的一般概念。<code><sub>&amp;</code>，<code></sub>|</code> 和 <code>~^</code> 运算符分别对应 AND，OR 和 XOR 操作。</p>
</div>
<div class="paragraph">
<p>在按位运算之前，两个操作数都转换为字符串表示形式(如果必要)。然后，对相应的位执行操作。</p>
</div>
<div class="paragraph">
<p>让我们考虑如何使 ASCII 字母字符变为小写的示例。在 ASCII 中，小写字母和大写字母之间的代码差值是 32(十六进制记法的 <code>0x20</code>)。所以，要使字母小写，在其上执行 <code>~|</code> 操作就可以了，而 <code>0x20</code> 空格的代码，将第五位设置为 1:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'A' ~| ' '; # a</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>~^</code> 运算符，您可以组织行为来更改大小写，如以下例子所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'a' ~^ ' '; # A
say 'A' ~^ ' '; # a</code></pre>
</div>
</div>
<div class="paragraph">
<p>实际上，最好避免使用 ASCII 代码的技巧。</p>
</div>
</div>
<div class="sect4">
<h5 id="_布尔逻辑运算符">布尔逻辑运算符</h5>
<div class="paragraph">
<p>这些运算符是布尔值上的 AND，OR 和 XOR 运算符。下列代码示例列出了操作数的所有可能的组合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say True ?| True;   # True
say True ?| False;  # True
say False ?| True;  # True
say False ?| False; # False

say True ?&amp; True;   # True
say True ?&amp; False;  # False
say False ?&amp; True;  # False
say False ?&amp; False; # False

say True ?^ True;   # False
say True ?^ False;  # True
say False ?^ True;  # True
say False ?^ False; # False</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_最大公约数和最小公倍数">最大公约数和最小公倍数</h5>
<div class="paragraph">
<p><code>gcd</code> 和 <code>lcm</code> 运算符计算两个给定数字的最大公约数和最小公倍数。在许多其他语言中通常不内置这些运算符。但是，在 Raku 中，您不需要包含任何库来使用它们。请考虑以下使用 <code>gcd</code> 和 <code>lcm</code> 运算符的示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 20;
my $b = 30;

say $a gcd $b; # Prints 10
say $a lcm $b; # Prints 60</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，语法要求 <code>gcd</code> 和 <code>lcm</code> 名都用作运算符，而不是函数。以下代码不正确:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say gcd($a, $b);
say lcm($a, $b);</code></pre>
</div>
</div>
<div class="paragraph">
<p>它会生成编译错误，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>未申报的例程:
第4行使用的gcd lcm在第5行使用。你的意思是&#8217;lc&#8217;吗?
对于素数，gcd运算符返回1，因为没有其他除数，如图所示 这里:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">===SORRY!=== Error while compiling
/Users/ash/Books/Packt/code/operators/gcd.pl
Undeclared routines:
  gcd used at line 4
  lcm used at line 5. Did you mean 'lc'?</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于素数，<code>lcm</code> 运算符返回的数字 1， 因为没有其它除数了，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 17 gcd 31; # 1</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>lcm</code> 运算符返回一个等于其素数操作数的乘积的数，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 17 lcm 31; # 527</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，其他数字并非如此。请考虑以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 20 lcm 40; # 40</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_字符串重复运算符">字符串重复运算符</h5>
<div class="paragraph">
<p><code>x</code> 二元运算符是字符串重复运算符。它重复给定次数的字符串，如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = 'Developers ';
say $string x 5;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码打印五次包含 <code>$string</code> 变量初始值的字符串。 显然，原始值没有改变。</p>
</div>
<div class="paragraph">
<p>要修改字符串并将结果保存在同一变量中，请使用该运算符的赋值形式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$string x= 2;
say $string;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，<code>$string</code> 值的长度是之前的两倍。</p>
</div>
</div>
<div class="sect4">
<h5 id="_列表重复运算符">列表重复运算符</h5>
<div class="paragraph">
<p>运算符 <code>xx</code> 是列表重复运算符。它在视觉上和意识形态上与 <code>x</code> 运算符相似，但它适用于列表。请考虑以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @data = (10, 20);
my @big_data = @data xx 100;
say @big_data;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，<code>@data</code> 数组将重复 100 次，<code>@big_data</code> 变量将包含 100 份 <code>@data</code>。</p>
</div>
<div class="paragraph">
<p>小心不要意外混合 <code>xx</code> 和 <code>x</code> 运算符。如果你使用 <code>x</code> 而不是 <code>xx</code>，那么编译器不会警告你，相反，它会将参数视为字符串并执行字符串连接而不是重复数组。</p>
</div>
</div>
<div class="sect4">
<h5 id="_字符串连接运算符">字符串连接运算符</h5>
<div class="paragraph">
<p><code>~</code> 运算符连接两个字符串，如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'a' ~ 'b'; # ab</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果操作数不是字符串，则在操作之前将它们转换为字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 ~ 20;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将打印 <code>1020</code> 字符串。</p>
</div>
<div class="paragraph">
<p>具有赋值形式的 <code>~</code> 在某些应用程序中也非常有用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = 'Hello, ';
$string ~= 'World!';
say $string; # Hello, World!</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_junction_运算符">junction 运算符</h5>
<div class="paragraph">
<p>这三个操作符创建了 junction。我们已经在保存变量中同时具有多个值时看到了最简单形式的 junction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $odd = 1 | 3 | 5 | 7 | 9;
my $value = 5;
say 'Value is odd' if $value == $odd;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码打印 <code>Value is odd</code>，因为 <code>$value</code> 变量中的值是 <code>$odd</code> junction 的其中之一。<code>|</code> 运算符创建一个所谓的<strong>any junction</strong>。</p>
</div>
<div class="paragraph">
<p><code>&amp;</code> 运算符创建一个 <strong>all junction</strong>，其中所有的值必须为非空。考虑以下代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 3;
my $b = 4;

my $both = $a &amp; $b;
say 'ok' if $both; # ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，<code>^</code> 运算符创建一个 <strong>one junction</strong>，其中只有一个操作数必须计算为真。考虑以下代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = 'OK';
my $d = '';

my $one = $c ^ $d;
say 'ok' if $one; # ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>重要的是，使用 <code>any</code>，<code>all</code> 和 <code>one</code> 中的任一运算符创建的值都是 junction; 通过调用 <code>WHAT</code> 方法你可以看到它们的类型，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $one.WHAT; # (Junction)</code></pre>
</div>
</div>
<div class="paragraph">
<p>不要将 <code>&amp;</code>，<code>|</code> 和 <code>^</code> 运算符与布尔运算符 - <code>&amp;&amp;</code>，<code>||</code> 和 <code>^^</code> 混淆。</p>
</div>
</div>
<div class="sect4">
<h5 id="_does_运算符">does 运算符</h5>
<div class="paragraph">
<p><code>does</code> 运算符将角色混合到对象中。我们将在第八章的面向对象编程中讨论混合内容。无论如何，请考虑一个简短的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Animal {}
role Barking {
    method bark() {
        say "Bow-wow!";
    }
}

my $dog = Animal.new();
$dog does Barking;
$dog.bark();</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，<code>$dog</code> 变量首先被创建为 <code>Animal</code> 类的一个实例。然后， <code>Barking</code> 角色的行为被附加到 <code>$dog</code> 实例上。之后，<code>$dog</code> 变量可以 <code>bark()</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_but_操作符">but 操作符</h5>
<div class="paragraph">
<p><code>but</code> 操作符将一个角色混合到一个对象中，类似于 <code>does</code> 操作符的操作方式。<code>but</code> 运算符不会修改对象本身并始终返回一个新对象。另外，<code>but</code> 允许我们使用已经实例化的对象，如下面的例子所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $value = 0 but True;
say 'It is true' if $value;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$value</code> 现在在布尔上下文中变为 <code>True</code>，而它仍然包含纯零值。</p>
</div>
<div class="paragraph">
<p>在混合角色的情况下，同一对象开始表现为属于不同类型的对象的行为，视情况而定。请考虑以下代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Barking {
    method bark() {
        say "Bow-wow!";
    }
}

my $dog = 14 but Barking;
say $dog;    # 14
$dog.bark(); # Bow-wow!</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$dog</code> 变量打印为其数值，但也可以在其上调用 <code>bark</code> 方法。</p>
</div>
<div class="paragraph">
<p>内省表明变量现在是两者的组合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $dog.WHAT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此命令打印 <code>(Int+{Barking})</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_通用比较运算符">通用比较运算符</h5>
<div class="paragraph">
<p><code>cmp</code> 是一个通用的比较运算符。它的多功能性允许比较数字和字符串数据。请考虑以下代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 cmp 2;     # 2 is less than 10
say "10" cmp "2"; # but "2" is more than "10"</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Order</code> 枚举的三个可能值之一的返回值为 <code>Less</code>， <code>Same</code> 或 <code>More</code>。上述程序打印以下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">More
Less</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果操作数具有不同的类型，则它们将转换为相同的类型，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 5 cmp "5"; # Same</code></pre>
</div>
</div>
<div class="paragraph">
<p>当您用 <code>cmp</code> 比较对儿时,它们会以先比较键再比较值的方式进行比较。检查以下示例，其中我们用不同的键和值创建三个对儿，并在不同的组合中比较它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = alpha =&gt; '2';
my $b = beta =&gt; '1';
my $c = alpha =&gt; '1';

say $a cmp $b; # Less
say $a cmp $c; # More</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>$a cmp $b</code> 的情况下，它们的键可按字母顺序排序，而值则不重要。在 <code>$a cmp $c</code> 的情况下，两个键都相等，因此也检查每个对儿的值。</p>
</div>
</div>
<div class="sect4">
<h5 id="_字符串比较运算符_leg">字符串比较运算符 leg</h5>
<div class="paragraph">
<p><code>leg</code> 操作符的名字来自 <strong>less</strong>，<strong>equal</strong>，<strong>greater</strong>。它将两个操作数作为字符串进行比较。如果值不是字符串，则首先对它们进行字符串化。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 leg 2;     # Less
say "10" leg "2"; # Less
say 5 leg "5";    # Same</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果是 <code>Order</code> 枚举的值之一(注意，尽管操作符名字中有e，操作数的相等性返回 <code>Same</code> 值)。</p>
</div>
</div>
<div class="sect4">
<h5 id="_实数的比较运算符">实数的比较运算符</h5>
<div class="paragraph">
<p>这是一个必​​要时将其操作数转换为 <code>Real</code> 类型的比较运算符。以下示例演示了比较我们用 <code>cmp</code> 和 <code>leg</code> 运算符尝试过的相同数据的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 &lt;=&gt; 2;     # More
say "10" &lt;=&gt; "2"; # More
say 5 &lt;=&gt; "5";    # Same</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_范围创建运算符">范围创建运算符</h5>
<div class="paragraph">
<p>这组二元运算符用于创建范围。两个操作数定义范围的左右边界。<code>^</code> 字符的存在表明了相应的边缘是开放的; 因此，它不包括给定的数字。</p>
</div>
<div class="paragraph">
<p>运行以下示例以查看其工作原理:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for 1 .. 5;   # Prints the numbers: 1, 2, 3, 4, 5
.say for 1 ..^ 5;  # 1, 2, 3, 4
.say for 1 ^.. 5;  # 2, 3, 4, 5
.say for 1 ^..^ 5; # 2, 3, 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以根据范围运算符周围的空格选择自己的风格。所以，<code>1&#8230;&#8203;^5</code> 和 <code>1 ..^ 5</code> 都是可以接受的。但是，不可能在运算符的字符之间插入空格，例如 <code>1 . . ^5</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_相等和不相等运算符">相等和不相等运算符</h5>
<div class="paragraph">
<p>两个运算符 <code>==</code> 和 <code>!=</code> 比较两个操作数的数字相等或不相等。在 Raku 中，定义了这些运算符的许多变体以便它们正确使用不同类型的操作数，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Equal' if 10 == 10;
say 'Not equal' if 3.14 != pi;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如有必要，首先将两个操作数转换为 <code>Numeric</code> 值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Also equal' if "10" == 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>!=</code> 运算符具有 Unicode 同义词 - <code>≠</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Not equal' if e ≠ pi;</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为一个有趣的例子，您也可以测试 <code>!≠</code> 运算符，其构造方式与 <code>!=</code> 运算符组装方式类似 - 感叹号否定下一个字符。这在 Raku 中有效，但在实践中避免使用它; 使用传统的 <code>==</code> 代替。</p>
</div>
<div class="paragraph">
<p>要比较字符串，请使用 <code>eq</code> 和 <code>ne</code> 运算符，这将在本章后面介绍。</p>
</div>
</div>
<div class="sect4">
<h5 id="_数值比较运算符">数值比较运算符</h5>
<div class="paragraph">
<p><code>&lt;</code>，<code>&#8656;</code>，<code>≤</code>，<code>&gt;</code>，<code>&gt;=</code> 和 <code>≥</code> 运算符集用于两个操作数的数值比较。如果操作数不是数字，则转换为 <code>Real</code>。考虑一下以下代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 &lt; 2;
say "10" &lt; "2";</code></pre>
</div>
</div>
<div class="paragraph">
<p>在本例中的两种情况下，比较结果都是 <code>False</code>。</p>
</div>
<div class="paragraph">
<p>两个 Unicode 运算符 <code>≤</code> 和 <code>≥</code> 是 <code>&#8656;</code> 和 <code>&gt;=</code> ASCII 形式的同义词，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 ≤ 10; # True
say 20 ≥ 10; # True</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_字符串比较运算符_eq_和_ne">字符串比较运算符 eq 和 ne</h5>
<div class="paragraph">
<p><code>eq</code> 和 <code>ne</code> 运算符比较两个字符串并返回一个布尔值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'abc' eq 'abc'; # True
say 'abc' ne 'def'; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>在比较之前，非字符串操作数将转换为字符串，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 13 eq '13'; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>要比较数字，请使用 <code>==</code> 和 <code>!=</code> 运算符。</p>
</div>
</div>
<div class="sect4">
<h5 id="_其他字符串比较运算符">其他字符串比较运算符</h5>
<div class="paragraph">
<p>这个字符串比较运算符集合分别执行 <strong>greater</strong>(gt)，<strong>greater or equal(ge)</strong>, <strong>later(lt)</strong> 和 <strong>less or equal</strong> 操作。运算符使用字符串，所以如有必要，操作数将转换为 <code>Str</code> 类型。返回值是一个布尔值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'a' lt 'b';
say 'beer' le 'water';

say 'z' gt 'x';
say 'stone' ge 'paper';</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的所有示例中，结果为 <code>True</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_before_和_after_运算符">before 和 after 运算符</h5>
<div class="paragraph">
<p><code>before</code> 和 <code>after</code> 运算符返回 <code>True</code> 或 <code>False</code>，具体取决于操作数的顺序。在 Raku 中，这些运算符是针对不同类型参数存在的多功能的。它们适用于数字和字符串数据。</p>
</div>
<div class="paragraph">
<p>让我们考虑这些例子，比较字符串和数字并给出相反的结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 before 2; # False
say 10 after 2;  # True

say "10" before "2"; # True
say "10" after "2";  # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>不同于一般的比较 <code>cmp</code> 运算符，<code>before</code> 和 <code>after</code> 排序运算符返回一个布尔值。</p>
</div>
</div>
<div class="sect4">
<h5 id="_相等性测试操作符">相等性测试操作符</h5>
<div class="paragraph">
<p><code>eqv</code> 运算符测试它的两个操作数是否相等。该术语假定两个操作数都具有相同的类型并包含相同的值。以下示例演示此操作符的工作原理。
两个整数值是等价的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;
my $b = 42;
say $a eqv $b; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果其中一个值是另一种类型，比如一个字符串，则结果为 <code>False</code>，即使该值可以转换为同一个整数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;
my $c = "42";
say $a eqv $c; # False</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>eqv</code> 运算符使用数组，如以下代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 2, 3;
say @a eqv [1, 2, 3]; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>而且，使用更复杂的数据结构，比如嵌套数组。考虑以下代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @b = [[1, 3], [2, 4]];
say @b eqv [[1, 3], [2, 4]]; # True</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_值恒等运算符">值恒等运算符</h5>
<div class="paragraph">
<p><code>===</code> 运算符是值恒等运算符。对于标量值，它给出了和 <code>eqv</code> 运算符相同的结果 - 当类型和操作数的值都相等时返回真，如你在这儿所见的那样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;
my $b = 42;
say $a === $b; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是另一个比较字符串和整数的示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;
my $c = "42";
say $a === $c; # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于类，如果两个操作数指向同一个对象，则 <code>===</code> 运算符返回 <code>True</code>，如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class O {
}

my $o1 = O.new();
my $o2 = O.new();
say $o1 === $o2; # False: same class but different objects

my $o3 = $o1;
say $o1 === $o3; # True: the same object</code></pre>
</div>
</div>
<div class="paragraph">
<p>请在第八章的面向对象编程中了解更多关于类的东西。</p>
</div>
</div>
<div class="sect4">
<h5 id="_绑定检查运算符">绑定检查运算符</h5>
<div class="paragraph">
<p>如果两个操作数都绑定到同一个变量，或者，更确切地说，绑定到同一个容器，则绑定检查运算符返回真。</p>
</div>
<div class="paragraph">
<p>Raku 中的绑定意味着另一个变量指向同一个容器，你可以使用两个名称更改其值。以下示例演示了这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;
my $b := $a;
$b = 30;
say $a; # 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，使用 <code>$b</code> 别名更改放置在 <code>$a</code> 变量中的值。<code>=:=</code> 运算符为这些名称返回真:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $a =:= $b; # True</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_智能匹配运算符">智能匹配运算符</h5>
<div class="paragraph">
<p><code>~~</code> 运算符是智能匹配运算符。它对不同类型的操作数执行不同类型的比较。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $int = 10;
say $int ~~ 10; # True

my $str = 'str';
say $str ~~ 'str'; # True

say $str ~~ /^ str $/; # ⌈str⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>从这个测试程序的输出可以看出，<code>~~</code> 运算符的结果不总是一个布尔值。</p>
</div>
<div class="paragraph">
<p>在内部，使用智能匹配运算符的 <code>$a ~~ $b</code> 构造等同于调用 <code>$b.ACCEPTS($a)</code>。该 <code>ACCEPTS</code> 方法是 Raku 中所有类型定义的内置方法。可以通过以下方式重写前面的三个智能匹配操作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10.ACCEPTS($int);
say 'str'.ACCEPTS($str);
say /^str$/.ACCEPTS($str);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_近似相等运算符">4.1.4. 近似相等运算符</h4>
<div class="paragraph">
<p>这是编程语言最不寻常的运算符之一。在 Raku 中，<code>=~=</code> 运算符比较近似相等的值。</p>
</div>
<div class="paragraph">
<p>如果操作数之间的差值小于 <code>$*TOLERANCE</code> 变量的值，则近似比较的结果为 <code>True</code>。其默认值为 <code>1E-15</code>。</p>
</div>
<div class="paragraph">
<p>让我们看看 pi 的两个近似值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say pi =~= 3.14159265358979323846;
say pi =~= 3.14;</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个返回 <code>True</code>，而第二个返回 <code>False</code>，因为它不够准确。</p>
</div>
<div class="sect4">
<h5 id="_布尔逻辑运算符_2">布尔逻辑运算符</h5>
<div class="paragraph">
<p>这些运算符是执行 AND，OR 和异或 OR 操作的布尔逻辑运算符。</p>
</div>
<div class="paragraph">
<p>对于布尔操作数，结果为 <code>True</code> 或 <code>False</code>，唯一的例外是 <code>True ^^ True</code> 表达式，它返回 <code>Nil</code>。</p>
</div>
<div class="paragraph">
<p>以下示例演示了布尔操作的所有可能组合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say False &amp;&amp; False; # False
say True  &amp;&amp; True;  # True
say True  &amp;&amp; False; # False
say False &amp;&amp; True;  # False

say False || False; # False
say True  || True;  # True
say True  || False; # True
say False || True;  # True

say False ^^ False; # False
say True  ^^ True;  # Nil
say True  ^^ False; # True
say False ^^ True;  # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于其他类型的操作数，它们要么返回布尔值，要么返回其中一个操作数。让我们逐个检查布尔运算符。</p>
</div>
<div class="paragraph">
<p><code>&amp;&amp;</code> 运算符返回第一个操作数，在布尔上下文中可以将其视为 <code>False</code>  值，如果布尔上下文中的所有操作数都为 <code>True</code>，则为最后一个操作数的值。例如，<code>42 &amp;&amp; 14</code> 表达式的结果是 14。这里，两个操作数都是 <code>True</code>，因此，操作后返回第二个操作数。</p>
</div>
<div class="paragraph">
<p>考虑这些例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 42 &amp;&amp; 14;          # 14
say 0 &amp;&amp; 14;           # 0
say 'Karl' &amp;&amp; 'Marta'; # Marta

my $text;
say $text &amp;&amp; 'default text'; # (Any)
say 'default text' &amp;&amp; $text; # (Any)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>0 &amp;&amp; 14</code> 表达式中，第一个操作数为 <code>False</code>，因此 <code>&amp;&amp;</code> 运算符没有计算第二个操作数并立即返回第一个操作数的值。第二个表达式有两个操作数都为真; 因此，<code>Marta</code> 就是结果。最后，最后两个表达式返回一个未定义的字符串。</p>
</div>
<div class="paragraph">
<p>同样，<code>||</code> 运算符返回第一个为 <code>True</code> 的操作数。如果所有操作数都碰巧为 <code>False</code>，则返回最后一个。我们来看看下面的例子，它们使用了与我们在 <code>&amp;&amp;</code> 运算符的早期测试中使用的相同的操作数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 42 || 14;          # 42
say 0 || 14;           # 14
say 'Karl' || 'Marta'; # Karl

my $text;
say $text || 'default text'; # default text
say 'default text' || $text; # default text</code></pre>
</div>
</div>
<div class="paragraph">
<p>非布尔操作数的 <code>^^</code> 运算符的逻辑有点棘手。如果只有 一个True操作数，然后返回该操作数。如果没有，那么最后一个操作数是 回。如果有多个True操作数，则返回Nil的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>例如，可以链接所有树操作符以选择第一个可接受的值或者
采用默认值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这些运算符具有短路语义，并应该停止评估操作数
价值确定。
定义或运算符
<code>//</code> 运算符称为defined-或 operator。它返回定义的第一个 操作数。//最明显的用例是为输入数据提供默认值，如 如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>//</code> 运算符也是短路运算符。 最小和最大的运算符
min和max运算符分别返回最小或最大操作数。 为了比较这些值，运算符使用与为cmp定义的语义相同的语义 运算符。请考虑以下代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在Raku中，有相同的min和max函数，但使用该函数 调用语法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>运算符和函数都可用于查找最小值和最大值两个以上值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>配对创建运算符
&#8658;运算符创建对。它将左操作数作为键，将右操作数作为 价值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>创建的对象的类型是Pair。
使用&#8658;运算符，如果密钥通过了标识符的限制，则可能不会引用该密钥 Raku.考虑以下示例:
我的$ pair1 = alpha &#8658; 1; 我的$ pair2 = beta &#8658; 2;
逗号运算符
逗号创建提供的操作数列表。在以下示例中，列表保存在
数组变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>调用分隔符
:运算符看起来不像普通的中缀运算符。它用于分离 方法调用中的invocant参数。此调用中的方法调用看起来像是对常规调用 功能。让我们在一个简单的例子中看到这一点。
首先，我们将在$ string上调用index方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过以下代码行可以实现相同的效果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，$ string变量作为索引例程的第一个参数传递 并用冒号与第二个参数分开。</p>
</div>
<div class="paragraph">
<p>Zip操作员</p>
</div>
<div class="paragraph">
<p>Z运算符像拉链一样工作，并从给定的两个数组中创建一个新数组。该
新数组中的元素作为拉链从操作数的元素中获取
连接其项目。
在以下示例中可以清楚地看到Z运算符的行为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>此程序打印以下列表，其中包含基于元素的嵌套列表 来自@odd和@even数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果其中一个数组操作数的长度不同，则Z运算符的结果将包含
尽可能多的元素包含最短的元素。</p>
</div>
<div class="paragraph">
<p>跨运算符
交叉运算符X创建其操作数元素的所有可能组合。 将此运算符的工作与我们在Z的示例中使用的相同数据进行比较 运算符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次，生成的数组要大得多，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>序列运算符
作为中缀运算符，三个点是序列运算符。Raku包含一些数量 做你所说的内置魔术。让我们考虑几个例子&#8230;&#8203;&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;操作的结果是一个序列。不要将此运算符与..运算符混合使用 这会创造范围。
如果将结果分配给列表，则运算符可以互换:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>与运算符合作 序列运算符可以演示更复杂的行为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，使用模式，&#8230;&#8203;运算符创建正方形序列:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>序列运算符理解算术和几何序列，例如以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用&#8230;&#8203;运算符的另一个有趣示例是生成Fibonacci的方法 数字通过使用Whatever(*)字符显示公式，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码创建了一个惰性列表@fib，其元素将按需计算。 打印前十个数字，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>绑定运算符
这两个运算符创建绑定。绑定是可以用来代替的绑定</p>
</div>
<div class="paragraph">
<p>原始变量名称来访问它们的值。 我们在关于=:=运算符的部分中看到了使用:=运算符的示例。
第二种形式:: =创建只读绑定。目前尚未实施 Rakudo。</p>
</div>
<div class="paragraph">
<p>优先级较低的逻辑运算符
两个运算符和和或在语义上等同于逻辑&amp;&amp;和|| 中缀 运算符，但优先级更宽松。
这些低优先级运算符非常适合异常情况和错误
断言，例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，只有在断言$ value &lt;10失败时才执行或只执行。 数据管道运算符
<code>=&#8658;</code> 和 <code>&#8656;=</code> 运算符传递值与|的方式类似 管道运算符传递数据 在Unix命令行shell中。
请考虑以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，@ a数组分三步创建。，生成从10到0的序列
&#8230;&#8203;运算符，然后将值传递给grep函数，该函数选择更多的数字 比五。之后，值将转到sort方法。
该程序的结果是一个6到10之间整数的排序列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8656;=运算符以相反的方向组织数据流:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在这种情况下，排序调用后的括号是必需的，否则就是Raku编译器将尝试将&#8656;=运算符的开头解释为开头引号</p>
</div>
<div class="paragraph">
<p>三元运算符?? !
?? ?? !operator是Raku中唯一的三元运算符。它也称为条件运算符 运算符。它需要三个操作数 - 一个条件和两个值。如果评估条件 如果为True，则作为操作的结果返回第二个操作数。否则，第三个 操作数被返回。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，pi &lt;3条件为False，因此第二个字符串大于3打印。
三元运算符可以(小心)用于测试多个条件。考虑一下
以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，代码的格式化应该有助于您理解开发商。
前缀运算符</p>
</div>
<div class="paragraph">
<p>Raku中的下一组运算符是前缀运算符的集合。仅限前缀运算符 需要一个操作数并放在它们之前的代码中。
增量和减量运算符++和 - 这些是用于递增和递减值的前缀运算符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这些运算符的前缀形式首先更改变量的值然后返回结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在Raku中，++和 - 运算符都具有后缀运算符的形式(参见中的示例) 本章后面的Postfix运算符部分)。
布尔强制算子
的?prefix运算符是布尔强制运算符。它将其操作数转换为布尔值 值。
操作员的行为非常简单。我们来看看下面的例子
了解它的用法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>布尔否定运算符
的!prefix是布尔否定运算符。它反转其操作数的布尔值。</p>
</div>
<div class="paragraph">
<p>数字强制算子
+前缀运算符将操作数强制转换为数值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，您不能使用+前缀运算符来解析字符串中的数字 包含额外字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码将生成以下错误:
无法将字符串转换为数字:数字后面的尾随字符 数字否定运算符
--prefix运算符否定其数字操作数。如果操作数不是数字，则为 首先转换为它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>字符串强制运算符
用作前缀运算符的~运算符将其操作数强制转换为字符串。 对于简单的数据类型，操作符的操作是可预测的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于复杂数据，字符串转换可能会返回对象的地址:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>要更改此默认行为，您可能需要定义自己的转换器(我们将讨论 关于gist方法 第8章，面向对象的编程)。
二补二元否定算子
+ ^运算符执行操作数的二元补码否定，即 首先转换为整数值，如下面的代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>?^运算符将其操作数转换为布尔值并取消它。结果是 同样简单的结果!前缀运算符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>upto运算符 ^运算符称为upto运算符。它创建一个从0到整数值的范围</p>
</div>
<div class="paragraph">
<p>操作数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的代码中，Raku以^ 5的形式打印范围。 让我们在循环中使用范围:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个单行程序打印0,1和2.因此，范围不包括其上限 边界。</p>
</div>
<div class="paragraph">
<p>临时运算符临时用新值替换变量。
请考虑以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>f子例程打印全局变量$ var的值。最初，价值 变量是1.因此，f的第一次调用打印1。
然后，我们在一对花括号之间有一段代码。f的第二个调用是使用 以前$ var的保存值。然后，它的值暂时设置为2.所以，第三个 打印f打印2。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>退出代码块后，临时值的范围结束并且原始范围
$ var的值已恢复。所以，f的第四次调用再次打印1。temp关键字是 与my关键字不同，因为它不会创建局部变量。如果您更改了代码 使用my，那么f子程序仍将使用全局变量$ var，即</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>let运算符为变量设置新值。它的关键特征是能力 let运算符
如果代码块失败，则恢复原始值。
请考虑以下示例。$ var变量在代码中设置为新值 在这对花括号之间阻挡。在块结束后打印变量。如 没有例外，程序打印新的值-2，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果块由于某种原因死亡，那么变量将保持原始值。该 由die导致的异常被CATCH块捕获。然后丢失新值2，并且 程序打印1，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要组织某种事务以确保let运算符非常方便 所有更改只有在没有例外的情况下才会发生。
不是运算符
如果需要，not运算符将其操作数转换为Boolean，并取消该值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>此运算符的优先级低于!运算符。
所以运算符
so运算符将操作数转换为布尔值并返回它，如下所示 以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>的?运算符的优先级高于so运算符。</p>
</div>
<div class="paragraph">
<p>so例程也作为Mu类的方法存在，并且可以像a $ var.so一样被调用 变量。(类将在第8章中讨论，面向对象的编程 ; 穆是其中之一 Raku类层次结构顶部的类。)因此，以下代码可以作为英语读取 短语&#8217;如果是这样，那么请执行以下操作':</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>后缀运算符集包含一些运算符，紧跟在后面
操作数。</p>
</div>
<div class="paragraph">
<p>面向对象的后缀运算符
在Raku中，有一组与对象一起使用的后缀运算符。例如，我们有 用了。运算符调用对象上的方法，比如整数或字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将研究其他与OOP相关的后缀运算符 第8章，面向对象
编程。这些是以下运算符 - 。&amp;，。=，。^，。?，。+，。*，。:和。::。 递增和递减运算符
增量和减量运算符的后缀形式首先返回值
变量然后改变它们的值。我们可以在以下代码中看到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>将以下示例的输出与前缀中显示的程序进行比较
本章前面的运算符部分。</p>
</div>
<div class="paragraph">
<p>Circumfix运算符看起来不像常规运算符，比方说+。Circumfix运算符包含 围绕操作数的两个部分。本节介绍的四个运算符已经建成
使用一对不同种类的两个大括号。
引用词运算符
quote-word operator &lt;&gt;使用以空格分隔的数据位置创建列表 在尖括号之间。
以下示例打印包含三个元素的列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>无需引用&lt;&gt;运算符内的元素。现在，让我们保存创建的 变量中的数组并查看其内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个程序中，将五个元素放入@a数组中，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>元素由空格分隔，因此像1-3或5/7这样的结构被视为 字符串。
集团运算符
组操作符是一对括号 - ()。例如，它将元素分组 数学表达式。
空的括号对创建一个空列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>散列或块创建运算符
这对花括号({})创建一个空哈希或一个代码块。Raku决定 根据它在大括号之间看到的代码做什么。
在以下示例中，您可能会看到Raku符合您的意思。 空大括号或键值对列表会创建一个哈希值，如以下代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然一些可执行代码(引用占位符或默认变量)会创建代码块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，因为Raku在散列和块语法中使用相同的花括号，所以有些 可能会发生混淆，比较以下两个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果显然大括号之间的代码是可执行的，Raku将构成一个块， 例如，当它包含一个分隔语句的分号时:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，如果有隐式或显式参数的引用，那么这是一个块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>占位符$ ^ a和默认变量$ _都表明这是块的一部分
签名。
或者，%()语法可用于创建哈希:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>尝试使用$ _变量可能会导致错误，具体取决于内容。对于
例如，以下行生成错误使用未初始化的值$ _ of 如果代码是隔离的，则在字符串上下文中键入Any:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在定义$ _的情况下，将创建一个没有错误的哈希:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>Postcircumfix运算符
Raku中的Postcircumfix运算符是使用字符对的后缀运算符 拥抱其余的操作数。</p>
</div>
<div class="paragraph">
<p>位置访问运算符
这对方括号[]组织对操作数的位置元素的访问。该 最简单的情况是索引数组，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以传递索引列表以请求多个元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>元素访问运算符
下一组运算符包括{}，&lt;&gt;，&lt;&lt; &gt;&gt;和«»。 主运算符{}用于访问哈希值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>与[]运算符类似，{}接受多个键:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，引用了%h的键。postcircumfix运算符&lt;&gt;允许 我们要避免以&lt;&gt; circumfix的方式引用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;&lt; &gt;&gt;运算符及其Unicode同义词«»，将操作数插入就像它们一样 双引号中的字符串，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>调用运算符
()是一个在其第一个操作数上调用函数或方法调用的运算符。该
置于括号之间的操作数作为参数传递:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，()postcircumfix运算符接收三个操作数 - substr的名称
方法和两个整数，1和3。 虽然代码看起来不像是在使用运算符，但Raku仍然会处理这对代码
括号作为特殊类型的运算符，即postcircumfix运算符。
Raku中的元运算符 到目前为止，我们已经介绍了许多操作常规操作数值的运算符，
变量，对象等。在Raku中，有另一类运算符的运算符 经营者。这些运算符称为元运算符。我们将检查它们 以下部分。除了一些例外，每个元运算符都可以采用任何常规运算符 运算符以创建遵循某些规则的新操作。元运算符也可以使用 用户定义的运算符，我们将在本章的后面讨论，在定义用户 运算符部门。
分配元运算符
赋值元运算符采用op = form，其中op是运算符之一 Raku中提供。
例如，使用infix +运算符。在默认形式中，它需要两个操作数并添加 他们了，返回结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，$ c变量接收$ a和$ b之和，它保持不变。</p>
</div>
<div class="paragraph">
<p>在元运算符形式中，+ =运算符更改左操作数并将结果存储在其中 它，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>$ a + = $ b表达式总是等于以下$ a = $ a + $ b表单。 赋值元运算符与许多其他中缀运算符一起使用。考虑一下 以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>否定元运算符
否定元运算符!正在使用带有布尔值的!op表单中的感叹号 运算符。例如，这里是与元组合创建的否定元运算符
智能匹配运算符</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>反向元运算符R接受一个运算符并创建一个新运算符，其中的顺序为 操作数改变了。
例如，拿中缀 - 运算符。它从第一个操作数减去第二个操作数 如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>与运算符合作 如我们所见，结果就像操作数被交换一样。元运算符的动作
有两个操作数$ a Rop $ b相当于$ b op $ a。
减少元运算符
还原运算符[op]在应用于列表时，会对每个运算符执行op运算</p>
</div>
<div class="paragraph">
<p>随后的一对元素。换句话说，列表已注册，op符号为 插在他们之间。
让我们在下面的例子中检查元运算符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>@a表达式等效于以下表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们来看看另一个例子 - [*]。这个元运算符可用于计算
阶乘:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>交叉元运算符
交叉元运算符Xop采用两个列表并将op运算符应用于每个可能的运算符 列表元素的组合。
操作的结果是另一个列表。用两个看一下下面的例子
每个中包含三个数字的列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>代码打印一个包含六个元素的列表，每个元素是@x和的两个元素的总和 @y:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们使用字符串连接(<sub>)并在X</sub>操作中使用相同的@x和@y数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>与运算符合作 在这种情况下，每对数字都转换为一对字符串，然后它们就是
级联。您可以看到X元运算符如何选择其操作数的元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>Zip元运算符 zip元运算符Zop&#8217;拉链&#8217;其列表操作数并将op操作应用于
操作数的相应元素。 让我们尝试使用与交叉元运算符相同的数据的zip元运算符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序打印两个包含三个元素的列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>超级运算符
Raku中的超级运算符将操作应用于列表操作数的每个元素。他们 使用一元和二元运算符并使用<a href="#和">[和]</a>符号及其符号 同义词，«和»。
让我们通过示例探索超运算符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在第一个示例中，将值3添加到@a数组的每个元素。在左侧
&lt;&lt; + &gt;&gt;超级运算符是一个包含十个元素的数组。在右边，我们有一个 标量值。此值将添加到左侧数组的所有元素中。
在此示例中，相同的&lt;&lt; + &gt;&gt;运算符与两个长度相同的数组一起使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>结果是一个包含三个元素的新数组; 每个元素是相应的总和 源数组的元素。
可以使用引号重写ASCII形式的&lt;&lt; + &gt;&gt;:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>尖括号的方向定义了如果其中一个操作数被克隆的操作数
比另一个短。
让我们检查以下两个数组的不同组合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，使用我们之前使用的相同运算符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>@short数组在这里重复两次，以便有足够的元素供整体使用 @long数组。代码相当于添加两个相同长度的数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，使用&lt;&lt; + &lt;&lt;运算符如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，重复@short数组。
像这样反转箭头:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>数组不再重复，结果只包含两个元素。其余的
@long数组被忽略。 最后，让我们试试&gt;&gt; + &lt;&lt;运算符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>超运算符的形状告诉我们两个操作数都不能被克隆。在这
如果出现以下错误:
中缀的非dwimmy hyperop两侧的列表:&lt;+&gt;不一样 长度</p>
</div>
<div class="paragraph">
<p>也可以使用一元运算符创建超运算符。例如，使用postfix 增量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用&gt;&gt; 超运算符将@d数组的每个元素加1。
使用的前缀形式，相同的示例将如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>用户定义的运算符
Raku允许创建新的运算符。例如，与C +不同，新的运算符不是 限制为现有运算符的预定义列表。您可以将运算符命名为 你想要并选择一个新的角色组合。
用户定义的运算符应属于前面提到的类别之一，例如
作为中缀，前缀或外围设备等。
让我们从创建一个新的中缀运算符%开始，它计算两个数字的总和 操作数，但结果不超过100:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>定义运算符类似于创建子例程，但其名称应包含
类别的名称和运算符本身。
现在是时候测试刚创建的+%运算符了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个富有表现力的例子是阶乘的算子。在数学中，一个因子是 由值后的感叹号表示。在Raku中也可以这样做 用户定义的后缀运算符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>后缀运算符只接受一个操作数-$ n。在运算符的身体，我们使用 减少运算来计算因子。
用户定义的运算符与Raku中的内置运算符具有相同的权限。特别是 意味着在定义一个新运算符后，您可以将它与许多元组合使用 运算符。
例如，%运算符获取%=形式，可以直接使用，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，它可以与简化运算符一起使用，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku设计中没有意图使用户定义的运算符变得神秘。所以，你可以
提出更好的名称，包括一些描述性的字符串标识符，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_raku_中的运算符_2">4.2. Raku 中的运算符</h3>

</div>
<div class="sect2">
<h3 id="_raku_中的元运算符">4.3. Raku 中的元运算符</h3>

</div>
<div class="sect2">
<h3 id="_用户定义的运算符">4.4. 用户定义的运算符</h3>

</div>
<div class="sect2">
<h3 id="_总结_5">4.5. 总结</h3>
<div class="paragraph">
<p>在这一长篇章节中，我们讨论了Raku中的运算符。有几类 运算符，例如infix，prefix，postfix，circumfix和postcircumfix。我们讨论过 每个小组的运算符。然后，我们研究了元运算符和超运算符 根据内置的操作符创建新的操作符。最后，您学习了如何创建用户 - 定义的运算符，它们将自然地嵌入到程序的语言中。
到目前为止，我们已经涵盖了Raku语法的所有基础知识。在下一章中，我们将会 使用子程序进入下一级组织代码。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_控制流">5. 控制流</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本章中，我们将讨论控制流量的主要因素
Raku中的程序。大多数程序不仅仅是一个指令列表，而是它们 对用户输入做出反应，根据计算的数据做出决策，等等。
在本章中，我们将介绍以下主题:
代码块和do关键字 有条件的检查
循环
打破循环体 使用收集和收集来收集数据 设置主题
仅执行一次代码</p>
</div>
<div class="sect2">
<h3 id="_理解代码块和变量作用域">5.1. 理解代码块和变量作用域</h3>
<div class="paragraph">
<p>理解代码块和变量 作用域
在上一章中，我们讨论了变量，这些变量是您在a中使用的命名实体 程序。与许多编程语言一样，在Raku中，名称在其内部可见 范围而不是它之外。
举一个简单的程序，其中$ name变量只使用一次，如 如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>该变量在用于打印问候语后可以重复使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这是有效的，因为两个打印语句都位于相同的范围和
$ name变量在那里可见。
阿块在Raku是一段代码，其位于一对大括号内。一个街区
创造自己的范围。因此，块中声明的变量只能在其中可见。
以下程序将无法编译:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>以下错误消息通知我们，在$ name分配给新的位置 value，未声明具有该名称的变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>要使名称再次可见，请在外部作用域中声明它，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在本演示中，创建单独的代码块没有多大意义。我们会 当我们谈论时，例如关于条件，看到更多有用的代码块应用程序， 本章稍后或在 第6章，子程序，其中代码块用于保存 用户定义函数的主体。
do关键字 do关键字用于执行代码块。上一节的例子可以
以下列方式重写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>当代码块不能是a时，显式使用关键字的必要性是显而易见的 单独的表达式，如下一个示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，在关键字的帮助下(见第4章)，与运营商合作)，
程序检查是否定义了$ name，如果是，则打印问候语。</p>
</div>
<div class="paragraph">
<p>有条件的检查
根据条件做出决策是编程的基本需求之一。该
if关键字是否会更改程序的流程，具体取决于布尔测试的结果。 考虑以下代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，您可以看到if关键字使用的语法。关注关键字 通过布尔条件$ x &lt;10，然后是花括号中的代码块。不像 Perl 5，没有必要围绕条件括起来。
只有在条件评估为True时才会执行代码块。 if语句可以由else分支完成，该分支将在何时进行控制</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用给定的$ x值，程序执行代码后跟else块。
当您需要更精细的分支时，可以链接if-else检查。在这里，联合 elsif关键字出来:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>控制流 elsif分支包含另一个布尔表达式，将在检查时进行检查
第一个if测试的条件是False。 可以使用不同的布尔测试组合重写相同的程序
例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>你必须要小心，不要错误地输入if而不是elsif。如果您这样做，则创建 两个独立的if检查，两者都可以触发它们，如下所示
例。
以下代码检查变量是否小于5或小于10:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个条件$ x &lt;5为True，因此只执行第一个代码块和程序
打印x &lt;5。 现在，让我们用if替换elsif:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，有两个if块。else块仅存在于第二个if。都 条件，$ x &lt;5和$ x &lt;10，现在都是True，因此，程序打印出来 以下两行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，如果关键字而不是单个elsif，请确保不要使用其他两个 你需要一个if-elsif-else链。Raku会抱怨，因为它希望找到 else关键字后面的代码块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>编译以以下错误结束:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在Raku中，请使用“elsif”而不是“else if”
当然，也可以使用嵌套的if-else语句解决问题 你可以看到，有点难看并引入另一层次的嵌套代码，这是不必要的 在以下示例中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用循环
循环结构有助于组织重复的操作。Perl中有几个不同的选项 6用于创建循环。让我们从与C风格的传统循环类似的那个开始。
循环周期
loop关键字需要三个元素来控制循环的数量或重复 身体。请考虑以下代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，$ c是循环迭代的计数器。声明了这个变量 在循环关键字-my $ c = 0之后立即初始化。循环的主体是 如果条件$ c &lt;5为True，则执行。在迭代之后，$ c ++语句是 执行，使计数器递增，循环重复。一旦$ c变得平等 到五，条件不再是真，循环停止。所以，整个程序打印出来 数字从0到4，包括4。
可以省略循环头中的一些或甚至所有部分。例如，如果是计数器
变量在循环之前初始化，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果增量发生在体内。我们可以考虑以下代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，尽管缺少部件，仍然需要使用分号。</p>
</div>
<div class="paragraph">
<p>最后，如果没有给出参数，循环变得无限，你有责任
停下来，如图所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用空标题时，不需要分号，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>循环头部分可以包含多个用逗号分隔的指令。
例如，这是一个包含两个变量的循环:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序递增$ x变量并递减$ y。输出如下所示:
0 10 19 28 37 46
现在，让我们继续讨论for循环。</p>
</div>
<div class="paragraph">
<p>for循环 for循环可以说是一种更简洁的组织循环方式。它不需要
计数器并迭代数据列表。
考虑一个例子。这里，列表是一个奇数整数数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>$ _变量是默认变量，也称为主题。它需要其中一个的价值 当前迭代中的元素。因此，for循环打印@data中的数字 阵列。
您可以使用前面的程序执行两项重要的修改。
首先，如果循环体是单个语句，则可以在后缀中重写循环
表格，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，内置函数说$ _作为参数。也可以调用方法 在主题上使用相同的名称:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以省略默认变量以使程序更短，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这是真正的Raku的一个例子。
第二个更改明确地引入了主题变量。在这种情况下，您给出一个名称
它。语法很简单，可以从以下示例中理解:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>变量在 - &gt;箭头后声明。您不必在此处使用my关键字。 这种格式有一个优点; 因此，它可能需要来自@data的多个值。对于
例如，要在每次迭代中获取两个值，请声明两个变量，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序打印三个总和，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>控制流 在奇数个元素的情况下，将触发异常，如下所示:
通过的位置太少; 预期2个参数但得到1
带箭头的构造(在下面的代码中)称为尖块。它是 相当于采用命名参数的匿名函数，这就是原因 错误消息中提到了参数。我们将在第6章中看到更多相关内容， 子程序。
要正确处理缺失的数据，可以按如下方式使用默认值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，在最后一次迭代中，$ y值将设置为-1，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用while，until和repeat
使用三个关键字，while，until和repeat，您可以创建循环 重复多次由某些条件定义。让我们从最简单的情况开始</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>只要条件$ letter ne&#8217;d'，while循环的主体就会重复
真正。这里，对变量的控制是在循环体中完成的，同时是它的标题 只控制条件。如果在进入循环之前条件为False，那么正文将会
不执行，如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>until关键字的行为与while相反。执行循环体直到 条件变为真。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在前三次迭代中，$ letter eq&#8217;d&#8217;条件为False，因此正文为
执行。一旦$ letter变为d，循环就会停止。
如您所见，无法保证循环体将被执行 一旦。如果条件为False(在while的情况下)或True(在until的情况下)最初， 然后跳过循环体的代码。
repeat关键字将条件的检查移动到正文的末尾，因此它将是 至少执行一次。此关键字与while和until一起使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>该循环打印字母a，b和c。while子句中的条件为False 3 时间，之后变为真。
现在，让我们修改变量的条件和初始值并运行循环</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这次，打印字母t。与裸while循环不同，重复while循环 在检查条件之前执行它的主体。</p>
</div>
<div class="paragraph">
<p>请注意，while子句可以放在代码块之前，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，postfix while子句没有区别。
同样，until关键字可以与repeat一起使用。重复直到循环是 至少执行一次。如果条件为False，则继续运行代码块直到 条件变为真。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，使用后缀形式。请考虑以下代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>两个程序都打印a，b和c。选择一个用于定位条件的变体 试着在实践中坚持下去，或者至少在项目中坚持下去。
打破循环
循环的执行不仅可以通过初始条件控制，还可以通过初始条件控制 循环体本身。有三个关键字 - next，last和redo。他们成为 使用if时与条件检查一起使用时更有用。</p>
</div>
<div class="paragraph">
<p>最后一个关键字只会打破循环。让我们考虑一个循环的例子
它打印的值大于某个预定义的阈值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，如果在此处使用后缀形式 - 它的行为与以下代码相同:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>前几次迭代像往常一样执行，但是当$ x的当前值变为50时， 这使得$ x&gt; 42条件为True，循环停止并执行 循环后的代码(如果有的话)。该程序打印以下行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，代码块中的代码也位于最后一条指令之后 在if条件变为True之前执行。只要$ x变量获得值 50，循环被打破。
接下来，另一个关键字跳过循环体的其余部分并开始另一次迭代。对于 让我们在1到10之间打印偶数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果条件$ x%2为1，则此循环不会打印数字，这将转换为True。它 偶数发生，因此，只说接收通过滤波器的奇数，如 你可以在下面的输出中看到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，redo关键字从当前位置重新启动循环。像下一个和最后一个， 它会跳过循环体的其余部分，但不会影响循环计数器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个简单的程序演示了redo关键字的用法。该程序生成 0到1之间的随机数，只有在数字大于0.5时才使用它。在所有
在其他情况下，循环迭代重新启动。
使用标签
让我们考虑一个嵌套循环的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序打印产品表中的数字从1到5.如果，在某些时候，
我们想跳过给定$ x的表的其余部分，并继续下一个值 $ X?在$ y中循环使用next只会影响内部循环。要做
确保下一个语句正在修改外部循环的执行，使用X_LOOP:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的标签是大写的标识符X_LOOP，后跟冒号。它在提到 下一个语句，因此编译器理解下一次迭代应该从 循环标有X_LOOP。
标签也可以与其他类型的循环一起使用，例如，使用
直到和循环。</p>
</div>
<div class="paragraph">
<p>执行一次代码
在Raku中，有趣的是，只能执行一次身体的一部分。例如，在 下一个循环，应该完成四次迭代，但第一条消息将仅打印:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码打印以下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>once关键字后面的代码块只执行一次。 这也适用于其他类型的循环，例如，循环周期。考虑到
以下代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，如果只有一条指令要执行，则不需要花括号
一旦。
once关键字不仅适用于循环。它可以用于任何其他部分 代码，例如，子程序内部。我们将在下一章详细讨论子程序
第6章，子程序。现在，这是一个打印整数平方的简单示例 在第一次调用函数f时问候我们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>控制流 程序输出如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>收集和采集数据</p>
</div>
<div class="paragraph">
<p>使用Perl中的一对关键字可以非常有条理地组织数据列表 6聚集并采取。了解其工作原理的最简单方法是查看 以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>gather关键字后面的代码块返回保存在@data中的序列 阵列。序列的元素由take关键字提供。所以，会有 @data中的两个元素，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们考虑一个更大的例子。它包含一个整数二维矩阵 和一份说明清单。说明是四个方向 - 左，右，上和
下来，并采取命令。你应该从矩阵的中心开始，然后移动
根据指令当前位置，如果指令则拿起数字
告诉你。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>代码的主要部分是gather关键字的代码块。它包含一个循环
@instructions，并且，根据当前命令，它要么改变 当前位置的坐标或使用take关键字获取数字，如下所示:
拿@matrix [$ y] [$ x] 代码完成后，@result数组将包含三个数字
根据给定的@instructions。
用给定的主题设置主题
在上一节的示例中，我们使用了链式if-elsif结构。让我们 再看看这个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以清楚地看到，所有分支都包含相同的代码，用于比较当前的代码 $ step变量的值与其中一个预定义值。虽然很简单
直截了当，这不是进行这种比较的最优雅的方式。</p>
</div>
<div class="paragraph">
<p>控制流
在某些语言(如C和C ++)中，switch和case关键字有助于重新组织
if-else链。在Raku中，我们使用给定和何时。可以重写上面的代码 以下方式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里发生的是给定$ step变量并使其成为当前主题。 这意味着它现在可通过默认变量$ _获得。你可以清楚地看到它 在给定的代码块内打印，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在内部时，主题变量与给定值智能匹配，换句话说，何时 'up&#8217;相当于if _ _ ~~'up'。
找到匹配后的第一个关键字后，其余的未经过测试。例如，尝试打印
最后一个关键字之前的东西，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>只有在没有任何方向命令时才会访问打印指令
抓住了，你可以在这里看到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于when关键字执行智能匹配操作，因此有更多方法可以创建 条件。例如，可以直接测试变量的类型，如下所示 以下代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个程序中，@ data数组包含不同类型的元素 - 整数和字符串。 两个when语句根据类型名称测试主题并打印其中一个 以下两个字符串:
1是整数 两个是一个字符串 3是整数 四是一个字符串
1 2是别的东西
如果没有触发when块，则执行可选的默认块。 您可能已经注意到，在上一个示例中没有给定关键字。这是因为
该主题已由for循环设置，无需再次设置。 相反，正如您所看到的，可以单独使用给定的关键字来设置默认变量</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_条件检查">5.2. 条件检查</h3>

</div>
<div class="sect2">
<h3 id="_使用循环">5.3. 使用循环</h3>

</div>
<div class="sect2">
<h3 id="_只执行代码一次">5.4. 只执行代码一次</h3>

</div>
<div class="sect2">
<h3 id="_用_gather_和_take_收集数据">5.5. 用 gather 和 take 收集数据</h3>

</div>
<div class="sect2">
<h3 id="_用_given_设置主题">5.6. 用 given 设置主题</h3>

</div>
<div class="sect2">
<h3 id="_总结_6">5.7. 总结</h3>
<div class="paragraph">
<p>在本章中，我们介绍了控制流程，Raku为传统程序提供了控制流程 节目。我们谈到了执行代码块并使用 关键字if，else和elsif。我们还讨论了不同的循环 - 基本循环 循环，重复，直到和循环具有前置条件或后置条件。 然后我们研究了使用gather-take对来收集数据以及Raku的工作方式 主题在给定和关键字的帮助下。
Raku不仅能够使用过程编程风格。你会找到 关于其他范例的更多信息 第13章，并发编程，第1章
14 ，功能编程，和第15章，反应式编程。
同时，在下一章中，我们将讨论组织代码的另一个层次
子程序。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_子例程">6. 子例程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>子程序是编程中的基本概念之一。他们帮助组织 结构更好的代码，也易于重用。Raku提供了很好的支持 子程序和许多有趣的相关功能。在Raku中，通常会调用子例程 潜艇。
我们将在本章中介绍以下主题:
创建子程序 调用子程序 输入的参数
签名属性 按值或按引用传递参数 运算符作为子程序 嵌套的子程序 对子程序的引用 重载子程序和多次调度 匿名子程序和lambda 可变占位符</p>
</div>
<div class="paragraph">
<p>创建和调用子例程
参数和身体。但是，名称和参数列表都是可选的。在
第1章，什么是Raku的?，我们已经创建了一个子程序来添加两个数字。让我们 回想一下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y) {
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，add是名称，稍后将用于调用sub。接下来是一个列表 sub的参数 - ($ x，$ y)。子程序的主体被包围在一对卷曲中 大括号 - {return $ x + $ y;}。
要调用子例程，请再次使用该名称并在括号中传递实际参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 17;
my $b = 71;
my $sum = add($a, $b);
say "Sum of $a and $b is $sum"; # Sum of 17 and 71 is 88</code></pre>
</div>
</div>
<div class="paragraph">
<p>子可以通过两种方式返回值。我们刚刚在add函数中看到的第一个。它 使用显式返回关键字，如下所示:
返回$ a + $ b; 返回调用后，子程序停止执行。return语句后的任何额外代码
不会被执行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">return $a + $b;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在许多情况下，当在子程序体的最后一行计算返回值时， return关键字不是必需的。最后计算的值将是返回值 子程序。考虑到这一点，让我们修改add函数，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y) {
    $x + $y
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>功能的使用没有区别。请注意，不需要分号
块结束。在像前一个这样的简单函数中，这是一件好事
使代码更轻一点。
并非每个子例程都必须返回一个值。它可能有一些副作用，例如， 写入数据库或从子例程主体立即打印。在Raku中，没有 功能和程序之间的区别，例如Pascal。创建一个子 不返回结果，只需使用不带参数的return语句或省略整个</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub print_sum($x, $y) {
    say "$x + $y = ", $x + $y;
}
print_sum(10, 30); # 10 + 30 = 40</code></pre>
</div>
</div>
<div class="paragraph">
<p>return语句本身。例如，让我们修改add子例程，使其打印出来 结果本身。在这种情况下，最好还重命名子例程以使名称
实际上反映了子做的事情:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub width() {
    1.30
}
sub height {
    2.40
}

say width() * height; # Don't follow this practice</code></pre>
</div>
</div>
<div class="paragraph">
<p>学习Raku时，要特别注意函数名和之间的空格 左括号。从第2章，编写代码，我们知道在调用时 函数，子名称和左括号之间不允许有空格。在许多情况下， 但是，根本不需要括号。添加4,5调用的行为完全相同 添加(4,5)。您应该为如何使用括号设计自己的策略 函数调用。
另一个可选部分是参数列表。如果sub不需要它们，你可以 要么使用空括号，要么完全省略它们。在以下示例中，两者都有 使用样式，但最好在程序中坚持使用其中一个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_默认值">6.1. 默认值</h3>
<div class="paragraph">
<p>有时，一个函数，特别是当它需要很多参数时，可以假设一些值 是默认的。在这种情况下，调用代码可以省略默认值。指定默认值 参数的值，在函数签名中的=符号后面添加值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y = 1) {
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用此函数，可以使用一个或两个参数调用函数，如
在以下示例中演示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say add(5, 6); # 11
say add(5);    # 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，如果参数没有默认值(或者不是默认值)，则不能简单地省略它 声明为可选 - 请参阅下一节，可选参数):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y) {
    return $x + $y;
}

say add(5, 6); # OK
say add(5);    # Error</code></pre>
</div>
</div>
<div class="paragraph">
<p>发生以下编译时错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">===SORRY!=== Error while compiling add.pl
Calling add(Int) will never work with declared signature ($x, $y)
at add.pl:6</code></pre>
</div>
</div>
<div class="paragraph">
<p>函数不能包含具有默认值的其他参数。
因此，所有具有默认值的参数必须位于参数列表的末尾。
否则，编译器将无法理解位置参数是什么
传递到子。</p>
</div>
</div>
<div class="sect2">
<h3 id="_可选参数">6.2. 可选参数</h3>
<div class="paragraph">
<p>Raku子程序也允许可选参数。这些参数由表示 签名中的问号。要检查参数是否已通过，请使用内置的 在定义的内置函数中，如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub greet($name, $greeting?) {
    say((defined $greeting) ?? "$greeting, $name!" !! "$name!");
}

greet('John');                 # John!
greet('John', 'Good morning'); # Good morning, John!</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_命名参数">6.3. 命名参数</h3>
<div class="paragraph">
<p>到目前为止，我们已经使用了带有一些参数的subs，并且定义了它们的含义 按他们在参数列表中的位置; 这些论点被称为位置。在Raku中 参数也可以通过名称传递。该命名参数可以出现在功能 在不同的位置打电话。
考虑一个函数的示例，该函数根据数量计算总金额
购买的物品及其价格，并打印总价值。通过常规位置参数，
该函数可能如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub register($item-name, $item-price, $quantity) {
    my $total = $item-price * $quantity;
    my $plural-ending = $quantity &gt; 1 ?? 's' !! '';
    say "$quantity $item-name$plural-ending cost €$total";
}

register('Book', 30, 1); # 1 Book cost €30
register('Book', 30, 5); # 5 Books cost €150</code></pre>
</div>
</div>
<div class="paragraph">
<p>子程序有三个参数，对于最终用户来说，可能会有问题
记住他们必须遵循的顺序。让我们通过给出名称来避免这个问题
参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub register(:$item-name, :$item-price, :$quantity) {
    my $total = $item-price * $quantity;
    my $plural-ending = $quantity &gt; 1 ?? 's' !! '';
    say "$quantity $item-name$plural-ending cost €$total";
}

register(item-name =&gt; 'Book', item-price =&gt; 30, quantity =&gt; 1);
register(item-name =&gt; 'Book', item-price =&gt; 30, quantity =&gt; 5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>命名参数在函数签名中以冒号为前缀。在打电话时 函数，值作为其名称和值的对传递。有两种选择 创建一对的方法 - 使用&#8658;箭头，如前面的例子所示，或者a 冒号，如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">register(:item-name('Book'), :item-price(30), :quantity(1));
register(:item-name('Book'), :item-price(30), :quantity(5));</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你在变量中有函数参数的值，那么 名称与命名参数的名称相同，您可以使用传递值 与sub定义中使用的语法相同，如以下代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $item-name = 'Book';
my $item-price = 30;
my $quantity = 3;

register(:$item-name, :$item-price, :$quantity); # 3 Books cost €90</code></pre>
</div>
</div>
<div class="paragraph">
<p>位置，可选和命名参数以及具有默认值的参数都可以 在同一个子中使用。一般规则是位置参数首先出现，而且 可选，默认为最后。如果您的功能需要太多参数， 也许是时候重新考虑这种方法并引入一些类(我们会 在讨论它们 第8章，面向对象程序设计)，或者使用多分派作为 本章稍后将在Multi subs部分中进行说明。</p>
</div>
</div>
<div class="sect2">
<h3 id="_参数特征">6.4. 参数特征</h3>
<div class="paragraph">
<p>子参数在其体内使用它们。默认情况下，子的参数是 -</p>
</div>
<div class="paragraph">
<p>只有价值; 无法修改子内部的值，如下所示 码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($a) {
    $a = 0;
}

my $x = 10;
f($x);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会导致以下错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot assign to a readonly variable ($a) or a value</code></pre>
</div>
</div>
<div class="paragraph">
<p>有两种方法可以克服这种情况，具体取决于您打算如何使用 修改后的价值 如果仅在子内部需要修改的参数，则创建副本 它的，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($a) {
    my $b = $a;
    $b = 0;
    say "b = $b";
}

my $x = 10;
f($x); # b = 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>为避免创建临时变量，最好通过追加来标记sub的参数 复制特征如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($a is copy) {
    $a = 0;
    say "a = $a";
}

my $x = 10;
f($x);  # a = 0
say $x; # 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想修改原文，Raku提供了另一种可能性 - 即rw特性 变量作为参数传递给sub。在这种情况下，sub之外的变量将具有 通话后的新值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($a is rw) {
    $a = 0;
}

my $x = 10;
f($x);
say $x; # 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用is rw trait，不可能将常量传递给子例程，因为</p>
</div>
<div class="paragraph">
<p>程序将无法修改以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($a is rw) {
    $a = 0;
}

f(5); # Error: Parameter '$a' expected a writable container,
      #        but got Int value</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，检查不太常用的特性是原始的。它的行为有点类似于 是rw trait，但不同之处在于它可以绑定到变量和常量。考虑 下面的两个sub-one的例子是rw trait而另一个是the
原始论点; 子修改其参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($a is rw)  {}
sub g($a is raw) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将变量传递给它时，这两个函数都能正常工作，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 10;
f($x);
g($x);</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果传递一个常量，即没有变量容器的值，则为rw 特质会阻止它被子接受。f(5)调用会发出以下错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Parameter '$a' expected a writable container, but got Int value</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用常量调用g函数仍然有效，尽管你当然不会
能够修改子内部的常量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub g($a is raw) {
    $a = 0;
}

g(5); # Error: Cannot assign to an immutable value</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用替代语法，而不是附加原始特征
反斜杠代替标量符号，如下面的代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub q(\a) {
    a++;
}

my $x = 10;
q($x);
say $x; # 11</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在Raku编译器的源代码中找到反向参数。我们会 请参阅本章后面的“ 创建运算符”部分中的一些示例。</p>
</div>
</div>
<div class="sect2">
<h3 id="_吞噬参数">6.5. 吞噬参数</h3>
<div class="paragraph">
<p>Raku的重要部分是它允许在函数签名中传递数组和散列， 意味着数组作为单个值传递，而不是作为其值列表传递。考虑一下 下面是如何修改add函数以返回all之和的简单示例
数组的元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add(@arr) {
    [+] @arr
}

my @a = &lt;10 20 30&gt;;
say add(@a); # 60</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>[+]</code> 构造是+运算符的简化形式; 看详情第4章， 与运营商合作。它返回@arr数组的所有元素的总和，即 只有sub的参数。
您可以安全地在数组之后向sub添加更多参数。让我们创建一个函数 计算数组的前$ n个元素的总和:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub sum_first(@a, $n) {
    [+] @a[0..$n - 1]
}

my @a = (1..10);
say sum_first(@a, 5); # 1 + 2 + 3 + 4 + 5 = 15</code></pre>
</div>
</div>
<div class="paragraph">
<p>参数不会与@a数组的内容混合在一起。
如果我们尝试使用我们之前创建的add函数来获取元素的总和，该怎么办? 一个数组，由两个值组成?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y) {$x + $y}

my @a = (4, 5);
say add(@a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>代码不会编译:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">===SORRY!=== Error while compiling slurpy.pl
Calling add(Positional) will never work with declared signature ($x, $y) at slurpy.pl:4
------&gt; say add(@a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>sub期望一个数组，但得到两个标量，这是错误的。要让添加功能 接受数组的值，数组应该被展平。也就是说，当传递到 函数，数组成为其值的列表。通过前缀实现展平数组 它们带有垂直条，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y) {$x + $y}

my @a = (4, 5);
say add(|@a); # 9</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在考虑相反的情况 - 你将一个标量列表传递给一个需要的函数 阵列。在这种情况下，您应该将数组参数声明为slurpy。它会消耗掉 标量并将它们累积在一个变量中。这将在下一个示例中进行演示。 slurpy参数以星号为前缀，如以下代码行所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add(*@a) {[+] @a}
say add(3, 4, 5, 6); # 18</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于slurpy数组将使用参数列表的其余部分，因此它应该是最后一个 sub的签名中的参数。</p>
</div>
</div>
<div class="sect2">
<h3 id="_参数占位符">6.6. 参数占位符</h3>
<div class="paragraph">
<p>即使缺少sub的签名，sub仍然可以使用和使用参数。Raku 定义所谓的占位符，它是在子内部具有^ twigil的变量。 我们可以在以下代码中看到这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub greet {
    say "Hello, $^name!";
}

greet('Mark'); # Hello, Mark!</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此代码中，$ ^ name变量获取函数调用时传递的字符串的值。 该值成为sub的只读参数。</p>
</div>
<div class="paragraph">
<p>如果有多个参数，则它们的顺序对应于该字母的字母顺序
占位符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub subtract {
    $^b - $^a
}
say subtract(10, 8); # -2</code></pre>
</div>
</div>
<div class="paragraph">
<p>值10和8位于$ ^ a和$ ^ b变量中。
使用占位符时，函数不能具有与数字冲突的签名 和占位符的类型。因此，在前面的示例中，您无法定义函数 例如greet(){&#8230;&#8203;}或带有空括号的subtract(){&#8230;&#8203;}。</p>
</div>
</div>
<div class="sect2">
<h3 id="_类型约束">6.7. 类型约束</h3>
<div class="paragraph">
<p>在Raku中，您不必声明变量的类型，但如果您愿意，也可以这样做。 相同的规则适用于sub的参数及其返回值。
输入的参数
在本章的前几节中，我们没有说明$ a的类型
和add函数的$ b参数。sub的代码假定参数 应该是数字，因为使用了+运算符。调用具有两个字符串的函数 参数，例如add('Hello'，'World')，将生成以下运行时
错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Cannot convert string to number: base-10 number must begin with valid digits or '.' in ' Hello' (indicated by   )</code></pre>
</div>
</div>
<div class="paragraph">
<p>此异常在运行时发生。虽然编译器看到你传递了两个字符串，但它 不检查是否为该类型的两个参数定义了+操作。有可能的 通过指定sub的类型来防止在编译时出现这种错误 参数，如图所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add(Int $x, Int $b) {
    return $x + $b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>用整数调用sub是可以的。用字符串调用它会增加编译时间 错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">===SORRY!=== Error while compiling add.pl
Calling add(Str, Str) will never work with declared signature (Int $x, Int $b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>调用add(Str，Str)将永远不会使用声明的签名(Int $ x，Int $ B)</p>
</div>
<div class="paragraph">
<p>在sub的声明中，参数列表称为签名。错误消息 告诉我们，我们想要调用的函数的签名不符合
程序中定义的函数的签名。也就是说，它需要调用一个函数 其名称为add，其签名为(Str，Str)。代码包含一个子程序 命名为add，但其签名不同:(Int $ x，Int $ b)。参数的名称 签名检查本身并不重要。
类型约束可以更严格。防止子程序接受 未定义的值，在类型名称后添加:D trait，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add(Int:D $x, Int:D $b) {
    return $x + $b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>仅定义(因此名称:D)值将立即通过类型检查:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a;
my $b = 10;

# add($a, $b); # Run time error because $a is not defined.

add($b, 20);   # Fine. Both operands are Int:D</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_返回类型">6.8. 返回类型</h3>
<div class="paragraph">
<p>从sub返回的值的类型也可以使用特定类型进行归因 约束。在Raku中有三种方法。
第一种方法是签名末尾的箭头:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add(Int $x, Int $y --&gt; Int) {
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种方法是最普遍的。它不仅允许指定返回的类型
值，但也用于给出显式常量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub funky_add(Int, Int --&gt; 100) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>无论参数值如何，此函数将始终返回100。在下一节中，
多子，我们将看到一个更有用的返回常量的应用。 指定返回类型的另一种方法是在签名之间使用of关键字
和sub的主体，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add(Int $x, Int $y) of Int {
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，返回类型可以放在子名称的前面，类似于a的类型 变量已定义。请注意，在这种情况下，您需要将sub声明为my:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int sub add(Int $x, Int $y) {
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>从sub返回的实际值必须是指定的类型。如果不是，a 发生运行时错误。让我们打破我们的添加函数并返回除法的结果 比添加:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add(Int $x, Int $y --&gt; Int) {
    return $x / $y;
}
say add(1, 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>代码将被编译，但您无法执行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Type check failed for return value; expected Int but got Rat (0.5)
    in sub add at return.pl line 1
    in block &lt;unit&gt; at return.pl line 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，即使结果可以转换为整数，也会发生相同的错误 值，不会丢失数据，如add(10,2)调用。这里的结果类型仍然是Rat，而不是
诠释。
子程序</p>
</div>
</div>
<div class="sect2">
<h3 id="_multi_subs">6.9. Multi Subs</h3>
<div class="paragraph">
<p>签名是子的重要属性。它不仅有助于检查类型
参数，但Raku也使用它来控制传递的参数数量。例如， 声明一个带有三个参数的求和函数，但只用两个参数调用它 参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y, $z) {
    return $x + $y + $z;
}
say add(1, 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序不起作用。签名是我们的朋友:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">===SORRY!=== Error while compiling add.pl
Calling add(Int, Int) will never work with declared signature ($x, $y, $z)
at add.pl:5</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，我们看到在决定调用哪个函数时，Raku会考虑该数字 参数以及它们的类型以及sub的名称。一个程序员</p>
</div>
<div class="paragraph">
<p>通过创建共享的功能的不同版本，可以从此功能中受益
一样的名字。它们之间的区别将通过其签名解决。
现在让我们将add函数的两个变体放在一起(我将以不同的方式对其进行格式化 时间)。要通知编译器您打算创建多个变体，请添加
 multi 关键字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub add($x, $y)     {$x + $y}
multi sub add($x, $y, $z) {$x + $y + $z}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在可以使用两个或三个参数调用add函数，如图所示
这里:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say add(1, 2);    # 3
say add(1, 2, 3); # 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>子程序
没有理由让编译器现在抱怨。它几乎没有召唤多个潜艇，
取决于呼叫中使用的参数数量。
类似地，类型参数可用于在多个子选择之间进行选择。让它成为可能 使用添加名称添加字符串。为此，可以使用串联运算符(~)。让我们 创建两个具有相同名称和不同签名的函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub add(Int $x, Int $y) {$x + $y}
multi sub add(Str $x, Str $y) {$x ~ $y}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在可以编写以下代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say add(4, 2);     # 6
say add('4', '2'); # 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>将响应这些调用调用不同的函数。而且，尽管如此 '4&#8217;和'2&#8217;字符串只包含数字，它们是Str类型的值 第一名。
类型参数可用于在不同变体之间进行更精细的分离 功能。例如，让我们为Int，Rat和Num值创建三个函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub f(Int) {say 'f(Int)'}
multi sub f(Rat) {say 'f(Rat)'}
multi sub f(Num) {say 'f(Num)'}

f(10);   # f(Int)
f(20/2); # f(Rat)
f(1E1);  # f(Num)</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例仅用于演示Raku如何选择多子的正确候选。 这些函数对参数没有任何用处，我甚至没有给出一个 参数的名称。从输出中可以看出(参见前面的注释) 代码)，这三个调用指的是三个不同的多子。
使用multi，可以省略sub关键字，如下面的代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi f(Int) {say 'f(Int)'}
multi f(Rat) {say 'f(Rat)'}
multi f(Num) {say 'f(Num)'}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multi subs可以做得更多。可以根据不同的方式路由多个分派 类型，也是价值观。例如，让我们创建一个带有Num值和a的子 仅应为Pi的值触发的单独子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub f(pi) {say 'The value of Pi is well-known!'}
multi sub f(Num $n) {say "Value is $n"}

f(pi); # The value of Pi is well-known!
f(e);  # Value is 2.71828182845905</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种方法也适用于其他类型的其他数据; 例如，字符串。
最后，multi subs非常适合用户创建的类型。我们将讨论使用 第8章中的课程，面向对象的编程。所以，让我们创建一个子类型并拆分 价值分为两组。
我们创建了两个subs，其中一个接受一个Str参数，另一个只接受 短于十个字符的字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub message(Str $str) {
    '&lt;p&gt;' ~ $str ~ '&lt;/b&gt;'
}
multi sub message(Str $str where {$str.chars &lt; 10}) {
    q{&lt;p class="large"&gt;} ~ $str ~ q{&lt;/p&gt;}
}

say message('Hi!');
say message('The weather is fine today');</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序打印带有消息的HTML代码，但添加了一个CSS类来制作字体 短文更大:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;p class="large"&gt;Hi!&lt;/p&gt;
&lt;p&gt;The weather is fine today&lt;/p&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_一个例子">6.10. 一个例子</h3>
<div class="paragraph">
<p>总结一下我们对多子的知识，让我们创建一个递归计算的例子
斐波纳契数。我们还将在此代码中使用类型约束:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub fibonacci(0 --&gt; 0) {}
multi sub fibonacci(1 --&gt; 1) {}
multi sub fibonacci(Int $n --&gt; Int) {
    return fibonacci($n - 1) + fibonacci($n - 2);
}

my @fib;
push @fib, fibonacci($_) for 1..10;
@fib.join(', ').say;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里使用multi subs来引导递归的fibonacci($ n - 1)+ 斐波纳契($ n - 2)公式为$ n的值小于2.前两个变体
fibonacci sub响应0和1的值而不是返回sub中的整数 在body中，我们将使用箭头语法指定签名中的返回值，如图所示
这里:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub fibonacci(0 --&gt; 0) {}
multi sub fibonacci(1 --&gt; 1) {}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_嵌套的子程序">6.11. 嵌套的子程序</h3>
<div class="paragraph">
<p>子程序可以嵌套。换句话说，您可以在另一个子内部定义一个子。让我们
在下一个例子中看到它，它列出了常规英语动词的现在时态:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub list_verb_forms($verb) {
    sub make_form($base, $pronoun) {
        my $form = $base;
        # Adds the 's' ending for he, she, and it.
        # The check uses a regular expression.
        # We cover regular expressions in Chapter 11, Regexes.
        $form ~= 's' if $pronoun ~~ /^ [ he | she | it ] $/;

        return "$pronoun $form";
    }

    my @pronouns = &lt;I we you he she it they&gt;;

    for @pronouns -&gt; $pronoun {
        say make_form($verb, $pronoun);
    }
}

list_verb_forms('read');</code></pre>
</div>
</div>
<div class="paragraph">
<p>list_verb_forms函数迭代@pronouns数组中的代词列表 并为每个子程序调用make_form子程序。因为我们不需要第二个 在代码中的任何地方，将其范围限制在第一个子体的主体是合乎逻辑的。
将子嵌套在另一个子中使其对其余代码不可见。你不能打电话 make_form子在list_verb_forms体外的任何地方:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>未申报的例程:
make_form在第20行使用
创建运营商
Raku中的运算符是子例程。在大多数情况下，operator subs是multisubs。考虑， 例如，<code>+</code> 运算符。它的语义是添加两个值，而这些值又可以是 不同种类。您可以要求Raku添加两个整数，浮点或复数 数字。或者，操作数可以在同一调用中具有不同类型，例如，在添加时 复数和整数。相同的+运算符也适用于类型 代表日期。为了实现所有这些灵活性，Raku使用了多个sub。
让我们简要介绍一下Rakudo的源代码，并搜索一些+的定义 运营商:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>Rakudo编译器部分用Raku编写，因此您可以轻松理解 这些摘录中的函数标题。
在Raku中，还可以创建可在代码中使用的自定义运算符。也， 可以扩展运算符对程序中创建的类型的行为。
例如，如果您希望+运算符连接字符串，只需定义其行为即可 对于字符串操作数，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>您很可能还需要考虑其他可能的组合 操作数类型。想象一下，我们正在创建代码来打印错误消息并希望如此 使用+运算符追加一个数字，如图所示:
说&#8217;线上错误' <code>+</code> 5; 这不起作用，因为 <code>+</code> 运算符没有候选者接受字符串和
整数。其中一个替代方法是执行类型转换: 说&#8217;线上错误'+ ~5;
现在我们有两个字符串和中缀:&lt;&gt;(Str，Str)运算符将被选中 编译器。
为了使开发人员的工作更轻松，最好为其定义更多变体 操作员使他们的使用变得直观。所以，让我们将中缀:&lt;&gt;(Str，Int)添加到我们的 采集:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>也许你还需要定义一个以整数为左侧的运算符
操作数和字符串作为右边的一个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们所见，创建新的运算符是一项非常负责任的任务。你应该思考和
预测可能的用例并定义相应的子例程。
在前面的示例中，我们使用了Raku中已有的操作符之一 您的程序，您还可以定义一个新的运算符并选择运算符的外观 你自己。下面的示例定义了一个名为plus的中缀运算符，它将两个运算符相加 类似于+运算符的整数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>定义新运算符时，请确保代码用户明确其语义。 例如，如果为字符串操作数定义+运算符，则可能会令人困惑
在以下示例中演示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有重新定义的中缀运算符，则“4”“9”将返回13，因为两个操作数都是 转换为数字值。用中缀:&lt;&gt;(Str，Str)定义，程序 打印49，因为操作数是字符串，并且有一个接受两个字符串的中缀子
参数。
将函数作为参数传递
Raku中的函数可以作为参数传递给其他函数。一个典型的例子是 排序算法，需要一个函数来比较两个值。它取决于数据类型 可以是知道如何比较该类型的值的不同函数。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>子程序 让我们来看看以下微小的例子:</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>比较(10,20，及更少); #True 比较(10,20和更多); #False
主代码使用三个参数调用compare子 - 两个整数和一个 参考其中一个功能 - &amp;less或&amp;more。名字前面有一个&amp;符号告诉我们 此时不应调用函数(请记住，在Raku中，括号是 调用函数时不需要)。
在比较函数内部，第三个参数$ f是对函数的引用。您可以 现在通过附加参数列表来调用引用的函数 - $ f($ a，$ b)。这将 相当于调用less($ a，$ b)或更多($ a，$ b)。
$ f参数的类型是Sub; 我们可以为子签名添加一个类型约束 强制使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，$ f $ a，$ b的调用将不会被编译，因为$ f不是sub的名称。
这里的括号是。()postcircumfix call- $ f。($ a，$ b)的缩写形式。
匿名潜艇
没有名称的子程序称为匿名子程序。你不能通过名字来称呼它，但是 它仍然可以通过句柄运行，例如，句柄存储在变量中。一切 常规子的属性，例如签名和正文，以与以下相同的方式定义 正常的潜艇。
在下面的代码中，我们将创建一个匿名子并将其保存在$ add变量中; 一个 需要签名前的空格:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku允许常规和匿名潜艇的混合。anon关键字创建一个 匿名sub出了常规的，所以它的名字仍然可以用来调用它。首先，看看 sub，既可以作为匿名使用，也可以通过名称调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，让我们使用anon关键字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过$ add变量调用函数很好，同时尝试通过它调用函数 名称甚至无法编译 - Raku不会将添加名称放在本地表中 符号，因为匿名明确禁止。
您也可以使用匿名代码块代替匿名子代码。他们叫 尖头块，因为他们使用箭头，如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>匿名子块和尖头块之间的区别在于它们返回的对象 不同种类。子类型为Sub，而尖头块创建块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在Raku对象系统的层次结构中，Sub类是Routine类的子类，它是 是Block的孩子。Routine类为我们提供了其他功能，例如 添加特征或使子成为多子。
另请注意，尖括号的参数未列在括号中。如果你
添加它们，Raku会认为你想在调用一个块时传递一个数组。这是 在以下示例中演示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>传递两个参数会导致以下异常:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_7">6.12. 总结</h3>
<div class="paragraph">
<p>期望2个参数但在子签名中得到0
子程序或子程序是Raku的基石之一。在本章中，您学习了如何使用它 创建和使用子程序。我们详细检查了子参数的属性， 例如通过复制传递参数，允许读写参数，定义 默认值，或提供可选参数。你看着邋.. 参数和展平数组，学会了如何约束两个参数的类型，
然后返回值。</p>
</div>
<div class="paragraph">
<p>最重要的是，讨论了子程序的其他应用程序。也就是说，我们谈了 关于使用multi关键字重载subs，看看新运算符是如何的</p>
</div>
<div class="paragraph">
<p>创建并嵌入在语言中，以及如何将函数传递给其他函数。和，
最后，我们简要介绍了匿名函数和尖代码块。
在下一章中，我们将讨论模块，它们是封装代码的下一级 在Raku中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_创建和调用子例程">6.13. 创建和调用子例程</h3>

</div>
<div class="sect2">
<h3 id="_类型约束_2">6.14. 类型约束</h3>

</div>
<div class="sect2">
<h3 id="_multi_subs_2">6.15. Multi subs</h3>

</div>
<div class="sect2">
<h3 id="_嵌套子例程">6.16. 嵌套子例程</h3>

</div>
<div class="sect2">
<h3 id="_创建运算符">6.17. 创建运算符</h3>

</div>
<div class="sect2">
<h3 id="_传递函数作为参数">6.18. 传递函数作为参数</h3>

</div>
<div class="sect2">
<h3 id="_匿名子例程">6.19. 匿名子例程</h3>

</div>
<div class="sect2">
<h3 id="_总结_8">6.20. 总结</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_模块">7. 模块</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在上一章中，我们讨论了子例程。子程序使代码更可读且易于重用。</p>
</div>
<div class="paragraph">
<p>本章将介绍以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在模块中组织代码</p>
</li>
<li>
<p>加载模块</p>
</li>
<li>
<p>导出名称</p>
</li>
<li>
<p>内省</p>
</li>
<li>
<p>模块位置</p>
</li>
<li>
<p>安装和卸载模块</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_创建模块">7.1. 创建模块</h3>
<div class="paragraph">
<p>Raku中的模块用于将代码保存在单独的文件中。这可能很简单 库由您开发的几个函数组成，或者它可能是一个很大的集合 由外部公司开发的课程。在任何情况下，如果你使用一个模块，你得到 以前的工作的力量，并有一个接又来实现该功能。</p>
</div>
<div class="paragraph">
<p>在本章中，我们将讨论在模块中组织代码并在模块中使用它们程序。</p>
</div>
<div class="paragraph">
<p>让我们创建我们的第一个模块，让我们完成添加数字的简单任务 在前面的章节中利用，例如，在 第2章，编写代码。</p>
</div>
<div class="paragraph">
<p>所以，我们有一个添加函数，用于添加两个数字和使用它的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($a, $b) {
    return $a + $b;
}

my $a = 10;
my $b = 20;
my $sum = add($a, $b);
say $sum; # 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们当前的目标是将add函数的代码放入一个单独的模块然后使用 主程序中的那个模块。
Raku模块通常保存在扩展名为.pm的文件中(代表Perl 模块)。如果由于某种原因你想强调Raku的用法来区分它
以Perl 5为例，你可以使用.pm6扩展名; 在这种情况下，最好使用.p6作为 Raku程序的扩展。
让我们为我们的示例创建一个文件，并将函数的代码复制到它。但是，就是这样
不够。模块必须具有名称，单元模块中提到了该名称
指令，放在文件的开头:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module Add;

sub add($a, $b) {
    return $a + $b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最好保持模块的名称和相应文件的名称一致。在 我们的例子，A​​dd模块位于Add.pm文件中。在How Rakudo商店 本章后面的模块部分，您将看到Rakudo如何管理更复杂的 文件名和模块名之间的关系。</p>
</div>
<div class="paragraph">
<p>现在，让我们尝试使用该模块并重写主程序，以便它调用一个函数
从中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Add;

my $a = 10;
my $b = 20;
my $sum = add($a, $b);
say $sum;</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意该指令使用Add; 在这个文件的开头。为了满足这一点，Raku将会找到 并加载相应的模块文件。
我们的代码还没有工作。让我们尝试执行它，然后尝试查找错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">$ raku main.pl
===SORRY!===
Could not find Add at line 1 in:
    /Users/ash/.raku
    /Applications/Rakudo/share/raku/site
    /Applications/Rakudo/share/raku/vendor
    /Applications/Rakudo/share/raku
    CompUnit::Repository::AbsolutePath<i class="conum" data-value="140518513192432"></i><b>(140518513192432)</b>
    CompUnit::Repository::NQP<i class="conum" data-value="140518512012576"></i><b>(140518512012576)</b>
    CompUnit::Repository::Perl5<i class="conum" data-value="140518512012616"></i><b>(140518512012616)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，编译器无法找到Add.pm文件。它试图搜索一些 目录，被视为默认目录，但失败。由于文件保存在同一目录中
在main.pl文件所在的位置，我们可以帮助编译器并使用它给它定位 -I命令行选项:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku -I . main.pl</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，找到模块文件但我们仍然收到错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>添加在第5行使用。你的意思是&#8217;dd'?
现在的问题是编译器不知道名称add。我们有一个功能 在模块中使用该名称，但使用该模块的代码不可见。要解决 这个，我们必须通知编译器名称已导出，可以在外面使用 模块。将is export trait追加到函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>模块 有了它，我们终于可以运行该程序并获得所需的结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有is export trait，模块的任何功能都将被外部世界隐藏 并且可以在模块内部使用，作为其内部机制，不会暴露给您 码。这有助于解决不同部分中函数之间的名称冲突 程序，并允许更好的模块接又 - 它只导出功能 真的需要出又。
或者，而不是明确使用Add; 主要代码中的指令，您可以要求 使用-M选项通过命令行加载模块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了简化命令并避免重复指令，模块的路径可以是 通过PERL6LIB环境变量传递:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>必须用逗号分隔多个目录:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用模块">7.2. 使用模块</h3>
<div class="paragraph">
<p>在上一节中，我们创建了一个包含单个函数的简单模块，并使用了该模块 程序中的模块。在本节中，我们将研究Raku如何实现的其他方法 加载模块及其功能。
我们将探索四个关键字 - 使用，需求，需求和导入。 它们都在加载模块的上下文中使用，但行为有点不同。
使用模块至少要假设两件事 - 首先，必须找到模块文件 编制; 第二，模块中的名称(如子程序或变量)应该 对程序可见。</p>
</div>
<div class="sect3">
<h4 id="_need_关键字">7.2.1. need 关键字</h4>
<div class="paragraph">
<p>need关键字在编译时加载模块，但不从中导入名称 它。加载模块也意味着将执行其中的所有指令。而且，
将运行BEGIN块。让我们在模块中添加几条打印指令并查看 它如何改变输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在主程序中，我们使用need而不是这次使用，如图所示:
需要添加;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>因为模块中的函数没有导入到程序中，所以它不起作用， 虽然，模块本身的输出会出现(BEGIN模块是 首先触发，因为它在常规程序中):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这是Add.pm</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_导入关键字">7.2.2. 导入关键字</h4>
<div class="paragraph">
<p>import关键字从模块中导入具有导出特征的名称。 结合需要，导入完成从a获取功能的过程
模块。让我们更新程序并运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次，一切正常，程序打印add函数返回的结果。 请考虑以下代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，裸导入不足以加载模块。它应该遵循这个需要
指令。
需要和导入都发生在编译时。这意味着在一个程序之后
编译后，这些指令在主程序之前执行。从实际角度来看
视图意味着你不应该在你的指令中考虑这些指令的位置
程序。例如，以下程序仍然有效，而需要和导入对
位于代码的末尾:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_use_关键字">7.2.3. use 关键字</h4>
<div class="paragraph">
<p>use关键字实际上是需求和导入的组合。同样，它也有效 在编译时，所以use指令的实际位置并不重要(但请参阅 本章后面的范围部分)。
此关键字是加载模块的最简单，最直接的方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>加载模块后，使用会自动从中导入名称
在该计划的其余部分可用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_require_关键字">7.2.4. require 关键字</h4>
<div class="paragraph">
<p>最后一个关键字require在运行时加载模块。因此，秩序很重要。至 从模块访问函数，我们现在需要完全限定的名称。反过来，允许 一个使用其功能的模块，在我们的帮助下，它们的范围必须不同 关键词。
以下代码是Add.pm文件的新版本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个需要模块并使用add函数引用的程序</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，完全限定的名称是在::的帮助下构造的。下一个 例如，我们将使用存储在变量中的模块名称，并且可以更改 不知何故，在程序的其余部分，在需要模块之</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，add例程是从Add.pm模块导入的。它应该按原样标记 出又那里:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_作用域">7.2.5. 作用域</h4>
<div class="paragraph">
<p>上面列出了四个加载模块的指令以及如何导入名称
例如，作用于主代码中的内部函数。在这种情况下，他们的行动仅限于
给定的范围。
例如，如果只在某个函数中需要add函数，则不需要 全局加载模块，如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>重要的是要意识到虽然导出名称的范围仅限于
只有do_calc函数，模块仍然在编译时加载。让我们修改两者 程序和模块，以便我们看到什么时候发生。
在程序中添加一条简单的say指令:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>以同样的方式，将其添加到模块: 单元模块添加;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，运行程序并确认在程序启动之前已加载模块
执行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>启动一个模块</p>
</div>
<div class="paragraph">
<p>如果要有条件地加载模块，以便它只在某种条件下发生 或者在代码的特定分支中，使用require关键字。在这种情况下，你可能很容易 根据程序的流程加载所需的模块。考虑一个变体
以前的程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，输出将是不同的(不要忘记把我们之前的函数放在
模块):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_更多导出">7.2.6. 更多导出</h4>
<div class="paragraph">
<p>我们在前面几节中看到的出又特征的使用并不仅限于此
仅出又潜艇。</p>
</div>
<div class="sect4">
<h5 id="_导出变量">导出变量</h5>
<div class="paragraph">
<p>可以从模块导出变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用此变量就像使用常规变量一样简单:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_选择性导出">7.2.7. 选择性导出</h4>
<div class="paragraph">
<p>有时，模块可以提供大量功能，并且只有一部分由a使用 程序。在这种情况下，您可以以仅限于有限的方式组织模块 导出名称的集合。Raku提供了一种标记名称的机制，如 如下面的模块示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个模块中，有两个函数集合:两个带有:plusminus标记和</p>
</div>
<div class="paragraph">
<p>两个用:muldiv标签。 导入模块时，使用标记选择要导入的名称。例如，让我们
只导入两个函数add和subtract:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>其他两个函数mul和div将不能与该导入一起使用。允许 它们，使用不同的标签再次导入模块或列出所有必需的标签，如图所示 以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>有三个预定义标签 - :ALL，:DEFAULT和:MANDATORY。
<code>:ALL</code> 标签导入所有具有任何导出特征的名称。这包括一个裸露的特质 没有标签，具有命名标签的特征或具有:ALL标签的特征。例如，而不是 两个使用前一个示例中的行，您可以使用具有相同效果的单行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>带有:DEFAULT标记的use指令加载那些用is创建的名称
导出特征没有任何标签。
最后，要强制导入名称而不管导入方法如何，请将其标记为原样
模块中的export(:MANDATORY)。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_内省">7.3. 内省</h3>
<div class="paragraph">
<p>Raku模块包含一种机制，允许您获取有关内容的信息 模块。获取此元信息称为内省。
参考上一节中的Math.pm模块，更多关于导出，作为 例。这是我们列出该模块导出的所有方法的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这是指编译器为我们生成的默认EXPORT子。子回归
实现Raku :: Metamodel :: PackageHOW的EXPORT类型的对象 接又。我们不会深入研究这一理论，并将自己局限于称之为有用的理论</p>
</div>
<div class="paragraph">
<p>方法键，为我们提供模块中可用标签的列表:
(plusminus muldiv ALL) 拥有标记列表，我们可以迭代它们以获取属于的子例程列表
他们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序打印以下三行，每个标记一行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，您清楚地看到:plusminus标记对应于函数add和 减去，:muldiv tag-to mul和div，以及:ALL标签给出所有的列表
导出的功能。同样，如果我们将subs标记为export:DEFAULT或is export:MANDATORY，我们可以使用相同的方法请求它们的列表。
现在，让我们继续自动化在Raku中管理模块的过程。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_zef">7.4. 使用 zef</h3>
<div class="paragraph">
<p>请注意，本节介绍了一种特定于Rakudo Star发行版的工具。 在撰写本文时，Rakudo是唯一可用于生产的Raku编译器 市场。如果您碰巧使用其他编译器，请查看他们的文档，了解如何使用 安装模块。</p>
</div>
<div class="paragraph">
<p>Rakudo Star发行版附带了一个名为zef的便捷模块管理工具。 请注意，自Rakudo Star 2017.01版以来，它一直是发行版的一部分。前 发布包括另一种工具，熊猫，现在已经过时了。
zef是一个用Raku编写的命令行工具。安装Rakudo Star后，它的可执行文件 将在Rakudo / share / raku / site / bin目录中。Rakudo安装程序也修复了
PATH环境变量，以便它包含目录的正确路径 分发的可执行文件。
该工具使用Raku模块的生态系统，该模块仍在积极开发中。至 了解更多信息，请访问modules.raku.org页面，其中包含数百个列表 模块可用于Raku和zef。
要获得zef的帮助，请使用-h命令行选项运行它:</p>
</div>
<div class="paragraph">
<p>让我们探索最有用的命令。</p>
</div>
<div class="sect3">
<h4 id="_安装模块">7.4.1. 安装模块</h4>
<div class="paragraph">
<p>安装模块
要安装模块，请使用install命令并提供模块名称，例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在安装模块之前，您可以快速检查是否已安装模块 要求Raku使用-M命令行选项加载模块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有这样的模块，您将收到一条错误消息，列出Raku扫描的文件夹 在试图找到模块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>那么，让我们安装它。如果一切顺利，将安装模块，您可以
立即开始使用它。安装过程的输出可能看起来像
以下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们安装了XML模块，该模块不需要依赖项。输出 显示安装过程的不同阶段 - 首先，zef查找该位置 分配，然后下载它，然后测试它，最后安装到正确的
地点。
zef的任务是在互联网上查找分发文件的位置，下载和 打开包装。该实用程序了解一些格式，这很好地证明了 以下摘自文档。
首先，可以通过其名称搜索模块，或者使用规范来搜索模块
作者或版本号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，可以通过传递本地路径来安装模块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果zef无法扣除模块的URL(可能会发生，例如，如果 模块未在modules.raku.org上列出，然后可以显式指定URL。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，zef会显示正在安装的模块及其版本的完整详细信息 和作者:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>其他模块可能需要依赖项，zef将尝试满足它们。例如，
安装XML :: XPath将导致安装许多其他模块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>install命令还接受完全指定的模块名称，因此如果需要安装 一个特定的版本，清楚地说:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>zef还支持从给定的URL或文件进行安装。</p>
</div>
</div>
<div class="sect3">
<h4 id="_搜索模块">7.4.2. 搜索模块</h4>
<div class="paragraph">
<p>在安装模块之前，最好先查看其他模块是什么或存在什么
出现所需模块的其他版本。使用搜索命令:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来是一个表格，显示所有找到的模块及其版本和
简要说明。</p>
</div>
</div>
<div class="sect3">
<h4 id="_卸载模块">7.4.3. 卸载模块</h4>
<div class="paragraph">
<p>要卸载模块，请使用uninstall命令:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果模块与其依赖项一起安装，则不会删除它们。对于 让我们尝试卸载我们安装在的 `XML::XPath`模块 安装本章前面的模块部分:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">就这样。其他依赖模块，例如JSON </dt>
<dd>
<p>Class，仍然存在:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_zef命令摘要">7.4.4. zef命令摘要</h4>
<div class="paragraph">
<p>zef是Rakudo Raku的默认模块管理器。下表总结了 它提供的命令</p>
</div>
<table class="tableblock frame-all grid-all stretch">
</table>
<div class="paragraph">
<p>命令 应将描述
安装
卸载
测试
取
建立
看
更新
搜索
信息
名单
按名称或路径安装特定模块 卸载指定的发行版 在给定模块的路径上运行测试 获取并提取模块的源 在给定模块的路径中运行Build.pm. 获取然后shelling到模块的路径 更新存储库的包索引 显示给定术语的可能分发候选列表 显示详细的分发信息 列出已知的可用分布
list --installed列出已安装的发行版
RDEPENDS 根据给定模块直接列出所有分布
定位 抽烟
查找已安装的模块信息
在可用模块上运行烟雾测试
有关如何使用zef的更多信息，请访问项目页面 github.com/ugexe/zef 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_rakudo如何存储模块">7.4.5. Rakudo如何存储模块</h4>
<div class="paragraph">
<p>Raku模块由三个参数引用:模块名称，作者姓名和模块 版。传统上，在Perl 5中，模块名称直接映射到文件系统， 但是在Raku中我们必须处理三个方面。在本节中，我们将看一下 Rakudo和zef存储模块的目录和跟踪它们的信息
 参数。</p>
</div>
<div class="paragraph">
<p>让我们看看Rakudo如何将文件系统中的模块保存为 <code>XML::XPath</code> 的示例 模块。
在Rakudo的安装目录中(在macOS上，这是/ Applications / Rakudo)，你 将找到以下四个目录:</p>
</div>
<div class="paragraph">
<p>模块位于共享目录的树内。每个模块至少可以有 三个档案。首先，share / raku / site / dist目录中包含一个JSON文件 从相同的模块和其他模块一起安装的描述 分配。文件的名称是一些基于散列的标识符。对于版本
我的计算机上的XML :: XPath，这是1DB52FD58FC401775EFFF9619F334A566BAA495F。 让我们看看里面。该文件非常大，因此我们不会完全复制它，限制
我们自己只有最独特的线条:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，它包含有关模块的一些基本元信息，例如名称 和源地址。在文件的末尾，我们看到了依赖项列表-XML和
测试:: META。提供块列出了与其连接的其他模块。例如，我们 看到XML :: XPath :: ExprOperator :: UnaryMinus模块位于文件中</p>
</div>
<div class="paragraph">
<p>命名为669A66B0DACE378D3507F21305B3A5AE0030D1E8。同样，我们可以找到数据 关于 <code>XML::XPath</code> 文件本身:</p>
</div>
<div class="paragraph">
<p>的确，在这个位置
分享/ raku / site / sources / E7C0BBCF69DD5CBC21DBD7027015325F83FADE11，我们看到
XML :: XPath的源代码:</p>
</div>
<div class="paragraph">
<p>但这并不是全部。与源文件一起，Rakudo保留了预编译版本 模块。它存储在文件中，其中的一个子目录中具有相同的名称
share / raku / site / precomp目录。 对于开发人员，没有必要详细了解上述结构。如果你使用
Raku的包管理器，它将负责所有内部细节。</p>
</div>
<div class="paragraph">
<p>在本章中，我们介绍了使用模块的主要步骤。首先，我们看到了 如何创建模块以及如何告诉编译器在哪里找到它。然后，我们检查了 加载模块和从中导入名称的不同方法。最后，我们去了一个 Rakudo特定的模块管理工具zef，并用它来安装和卸载模块 并查看了Rakudo用于将模块保存在磁盘上的内部存储。
在下一章中， 第8章，面向对象的编程，我们将讨论类， 它与代码如何分开的模块共享一些共同的元素
文件。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_9">7.5. 总结</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_面向对象编程">8. 面向对象编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>面向对象编程(OOP)</strong>是现代编程语言最需要的功能之一。在 Raku 中，Perl 早期版本 OOP 的工作方式已经被完全重新设计了。在本章中，我们将学习如何创在 Raku 中创建类和使用对象。以下内容将包括在内:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建类</p>
</li>
<li>
<p>类(读写，公共，私有，状态属性)</p>
</li>
<li>
<p>类方法(公共方法和私有方法)</p>
</li>
<li>
<p>继承(继承自类，重写方法，子方法，多重继承</p>
</li>
<li>
<p>角色</p>
</li>
<li>
<p>内省</p>
</li>
<li>
<p>后缀方法运算符</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_创建类">8.1. 创建类</h3>
<div class="paragraph">
<p>在 Raku 中，类是语言设计中不可或缺的一部分。要创建类，请使用 <code>class</code> 关键词。类的主体及其定义放在一对花括号之间。</p>
</div>
<div class="paragraph">
<p>让我们从创建一个使用类的程序开始。我们将从一个空的 <code>House</code> 类开始:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>类名以大写字母开头是一种很好的做法。这也遵循了 Raku 本身使用的约定。它的类型以相同的方式调用，比较 - <code>Int</code>，<code>Str</code>，<code>Array</code> 等。</p>
</div>
<div class="paragraph">
<p>前面的代码声明了一个类 <code>House</code> 并定义了它的主体。目前，主体是空的，但你已经可以使用此定义来创建该类的实例(或者，使用其他术语，创建该类型的对象)。</p>
</div>
<div class="paragraph">
<p>在某种程度上，术语<strong>类</strong>和<strong>类型</strong>是可互换的。例如，你可以把字符串看作 <code>Str</code> 类的实例，或只是 <code>Str</code> 对象，或 <code>Str</code> 类型的变量。</p>
</div>
<div class="paragraph">
<p>所以，创建一个新房子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>House</code> 类名上调用的 <code>new</code> 方法是类<strong>构造函数</strong>。它由 Raku 创建，每个新类都有。如果你愿意，可以在 <code>new</code> 调用后面附加一对空括号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$house</code> 变量是标量变量。它托管了 <code>House</code> 类型的对象。要确认它，在变量上调用 <code>WHAT</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $house.WHAT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印 (<code>House</code>)。</p>
</div>
<div class="paragraph">
<p>有了一个类，我们可以创建另一个实例，比如 <code>$house2</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house2 = House.new;
say $house.WHAT; # (House)</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们创造一条空房子的街道:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @street;
push @street, House.new for 1..5;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，<code>@street</code> 数组获得了 5  个 <code>House</code> 类型的对象。让我们通过在每个数组元素上调用 <code>WHAT</code> 方法来检查它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $_.WHAT for @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们所看到的，托管对象时，使用了同种变量 - 用于单个对象的的标量和用于多个集合的数组。对于 Raku，<code>$house</code> 是一个容器，你可以填充任何种类的数据，无论是 <code>Int</code> 还是 <code>House</code> 对象。</p>
</div>
<div class="paragraph">
<p>我们刚创建的两个 house 实例是不同的对象。<code>===</code> 运算符可以用于检查对象是否是同一个对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $house === $house2; # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一方面，两个 house 的内容相同。<code>eqv</code> 操作符检查对象的结构内部:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $house eqv $house2; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的下一步是为 <code>House</code> 类填充有用的元素。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用属性">8.2. 使用属性</h3>
<div class="paragraph">
<p>在上一节中，我们创建了 <code>House</code> 类，它不包含任何内容。真实的房子确实有一些参数，如地址，，有多少平方米的面积，房间数， 高度，等等。所有这些都可以使用 Raku 表达。</p>
</div>
<div class="paragraph">
<p>让我们开始在类上添加细节。我们从最简单的元素, 房间的数量开始。此参数可以通过附加到 <code>House</code> 类型对象上的整数值来描述。在 Raku 中，这样的数据元素被称为<strong>属性</strong>，并使用 <code>has</code> 关键字声明，如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    $.rooms;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里做了什么? <code>House</code> 类获得了属性 <code>$.rooms</code>。这是一个属于类对象的标量值。注意美元符号之后的点。这是一个描述属性的访问级别的 twigil; 我们将在本节后面讨论它。</p>
</div>
<div class="paragraph">
<p>现在，尝试创建一个房子，就像我们在上一节中所做的那样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这次，该对象与我们在创建类部分中的对象不同。它包含属性 - <code>$.rooms</code>。可以使用点语法读取此属性，就像你用 Java 或其他语言访问对象属性那样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $house.rooms;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为我们没有将此属性设置为任何值，程序会告诉我们该属性为空:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">(Any)</code></pre>
</div>
</div>
<div class="paragraph">
<p>要为属性设置初始值，可以使用构造函数参数。而不是创造一个 <code>House.new</code> 的实例，将命名参数传递给它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(rooms =&gt; 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果现在打印 <code>$.rooms</code> 的值，它将返回值 2:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $house.rooms; # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>房屋数量可能会有所不同。让我们在程序中反映这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(rooms =&gt; 2);
say $house.rooms; # 2
my $house2 = House.new(rooms =&gt; 4);
say $house2.rooms; # 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>变量 <code>$house</code> 和 <code>$house2</code> 的 <code>$.rooms</code> 属性使用不同的值初始化, 其与对象保持一致。</p>
</div>
<div class="paragraph">
<p>现在，这两个房子不仅是不同的对象，而且因为它们按其内容不同而不相同:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $house === $house2; # False
say $house eqv $house2; # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们通过访问 <code>$.rooms</code> 属性来打印房间数量。对于给定的对象 <code>$house</code>，获取其属性 <code>$.rooms</code> 的值的语法是 <code>$house.rooms</code>。</p>
</div>
<div class="paragraph">
<p>为了设置值，我们使用了一个传递给构造函数-<code>House.new(rooms &#8658; 2)</code> 的命名参数。</p>
</div>
<div class="paragraph">
<p>不要忘记 Raku 不允许方法名和左圆括号之间有空格。</p>
</div>
<div class="sect3">
<h4 id="_读写属性">8.2.1. 读写属性</h4>
<div class="paragraph">
<p><code>$.rooms</code> 属性的值是在创建对象 <code>$house</code> 时设置的。如果我们稍后需要改变它的值呢? 当然，现实中房间数量发生变化的情况很罕见，但在新房主接收房屋后仍然可能发生, 例如，改变其平面图。</p>
</div>
<div class="paragraph">
<p>设置新值的原生尝试失败了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.rooms ;
}

my $house = House.new(rooms =&gt; 2);
$house.rooms = 3; # Fails here
say $house.rooms;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在赋值时，发生运行时错误并终止程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot modify an immutable Int in block &lt;unit&gt; at house.pl line 7</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$.rooms</code> 属性是不可变的，无法更改。这是类属性的默认行为。</p>
</div>
<div class="paragraph">
<p>为了使属性可变，换句话说，为了允许写入属性，属性必须用 <code>rw</code> 特征声明:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.rooms is rw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，允许进行修改，没有例外:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(rooms =&gt; 2);
say $house.rooms; # 2
$house.rooms = 3;
say $house.rooms; # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>读写属性可以与其他运算符一起用作左值，例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house2 = House.new(rooms =&gt; 3);
$house2.rooms++;
say $house2.rooms; # 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>任何可以访问 <code>$house</code> 的代码都可以更改这些属性。在许多情况下，访问对象的内部属性必须是受限制的。在下一节中，我们将讨论如何在 Raku 中做到这一点。</p>
</div>
<div class="paragraph">
<p>在我们进一步学习类方法之前，让我们用更多字段扩展类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.rooms   is rw;
    has $.area    is rw;
    has $.height  is rw;
    has $.address is rw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，该实例包含四个数据属性，可以在构造函数中初始化:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(
    rooms   =&gt; 2,
    area    =&gt; 100,
    height  =&gt; 4,
    address =&gt; '22, rue du Grenier-Saint-Lazare, 75003, Paris, France',
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在最后一对参数之后放一个逗号是很好的。虽然没有必要，但与创建哈希一样，它使添加新元素的过程更容易。</p>
</div>
<div class="paragraph">
<p>现在，所有属性都已初始化。如果打印对象，则默认的字符串化机制会列出所有属性及其值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">say $house;

House.new(rooms =&gt; 2, area =&gt; 100, height =&gt; 4, address =&gt; "22, rue duGrenier-Saint-Lazare, 75003, Paris, France")</code></pre>
</div>
</div>
<div class="paragraph">
<p>在下一节中，我们将讨论缩小可存储在属性中的数据类型。</p>
</div>
</div>
<div class="sect3">
<h4 id="_带类型的属性">8.2.2. 带类型的属性</h4>
<div class="paragraph">
<p>我们继续 <code>House</code> 类，现在是时候考虑可​​能存储在属性中的值了。</p>
</div>
<div class="paragraph">
<p>在前面的示例中，我们将它们设置为一些有意义的值，但如果你输入一些无意义的数据，语言也不介意; 例如，如果我们不小心放了一个地址到 <code>$.area</code> 属性上:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(
    rooms   =&gt; 2,
    area    =&gt; 'Calle Velázquez 57, 28001 Madrid, Spain', height =&gt; 4.0,
    address =&gt; 100.0,
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设现在你想计算一个房间的平均面积:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $house.area / $house.rooms;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是不可能完成的，因为 <code>$.area</code> 属性包含字符串，而不是数字。编译器报告运行时错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot convert string to number: base-10 number must begin with valid digits or '.'</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了防止在类属性中存储错误类型的数据，Raku 提供了一种带类型的属性的机制。这个想法与类型化变量相同，并在以下代码片段中演示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has Int  $.rooms   is rw;
    has Real $.area    is rw;
    has Real $.height  is rw;
    has Str  $.address is rw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，<code>House</code> 类的每个属性都带有类型。编译器知道房间数是一个整数，面积和高度是浮点数并且地址是一个字符串。编译器将阻止尝试存储错误的数据:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Type check failed in assignment to $!area; expected Rat but got Str ("Calle Velázquez 57, ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>异常也发生在运行时，但你不能对该对象做一些事情，因为它甚至不会被创建。</p>
</div>
<div class="paragraph">
<p>这不是你可以对类属性施加的所有限制。以 <code>$.rooms</code> 属性为例。它可以只是一个整数，但也应该是一个正整数。Raku允许你使用 <code>where</code> 关键字指定值的子集:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has Int  $.rooms   is rw where {$_ &gt; 0};
    has Real $.area    is rw where {$_ &gt; 0};
    has Real $.height  is rw where {$_ &gt; 3};
    has Str  $.address is rw where {$_ ne ''};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有属性现在都使用内置 Raku 类型的子集。<code>$.rooms</code> 和 <code>$.area</code> 属性的值都应该是正数，房子的高度必须至少为 3 米，地址不能是空字符串。</p>
</div>
<div class="paragraph">
<p>现在，如果构造函数中传递的值不符合条件，则会发生运行时异常。例如，如果地址为空:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Type check failed in assignment to $!address; expected &lt;anon&gt; but got Str ("")</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在让我们仔细看看 <code>$.address</code> 属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用其他类作为数据类型">8.2.3. 使用其他类作为数据类型</h4>
<div class="paragraph">
<p>在前面的代码中，房屋的地址是一个自由文本字符串。在更复杂的应用程序中，最好将地址保存为一组不同的字段 - 国家，城镇，邮政编码，街道名称和门牌号码。</p>
</div>
<div class="paragraph">
<p>其中一个可能的实现是向 <code>House</code> 类添加更多属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has Int  $.rooms      is rw where {$_ &gt; 0};
    has Real $.area       is rw where {$_ &gt; 0};
    has Real $.height     is rw where {$_ &gt; 3};

    has Int  $.husenumber is rw where {$_ ne ''};
    has Int  $.zipcode    is rw where {$_ &gt; 0};
    has Str  $.country    is rw where {$_ ne ''};
    has Str  $.town       is rw where {$_ ne ''};
    has Str  $.street     is rw where {$_ ne ''};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它有效但不是最好的解决方案。地址详细信息可以单独保存在一个单独的属性中。要定义地址的内部结构，我们引入另一个类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> class Address {
    has Str $.housenumber is rw where {$_ ne ''};
    has Str $.zipcode     is rw where {$_ ne ''};
    has Str $.country     is rw where {$_ ne ''};
    has Str $.town        is rw where {$_ ne ''};
    has Str $.street      is rw where {$_ ne ''};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有意地将属性的类型选择为字符串以允许门牌号, 例如 <code>3A</code> 和以零开头或包含字母或空格的邮政编码，例如在伦敦的 <code>WC2B 4PH</code>。有了这个，<code>House</code> 类可以包含 <code>Address</code> 类型的属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has Int $.rooms       is rw where {$_ &gt; 0};
    has Real $.area       is rw where {$_ &gt; 0};
    has Real $.height     is rw where {$_ &gt; 3};
    has Address $.address is rw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，让我们创建一个 <code>House</code> 对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(
       rooms   =&gt; 2,
       height  =&gt; 4,
       area    =&gt; 100,
       address =&gt; Address.new(
           housenumber =&gt; '31A',
           zipcode  =&gt; '00194',
           country  =&gt; 'Italy',
           town     =&gt; 'Rome',
           street   =&gt; 'Via Dante',
       ),
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>表示地址的对象是在 <code>House</code> 对象的 <code>$.address</code> 属性需要时使用自己的构造函数 <code>Address.new</code> 创建的。</p>
</div>
<div class="paragraph">
<p>关于类属性还有很多东西需要学习，但在我们继续之前，我们必须介绍类方法。所以，下一节是关于类方法的，之后我们将会返回更多关于属性部分中的属性。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用方法">8.3. 使用方法</h3>
<div class="paragraph">
<p>在 OOP 中，对象不仅保留数据，还执行某些操作。在 Raku 中，数据保存在属性中, 动作是通过<strong>方法</strong>完成的。</p>
</div>
<div class="paragraph">
<p>方法类似于常规 subs，但在类中定义。他们可以使用来自对象的数据 他们工作的属性。</p>
</div>
<div class="paragraph">
<p>继续前面几节中的Address类。地址的详细信息是 保持独立的属性。这有利于创建干净和结构化的表示 但是，在某些情况下，我们需要一起使用所有数据。例如，让我们打印一个格式化的 放在信封上的地址:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Address {
    has Str $.housenumber;
    has Str $.zipcode;
    has Str $.country;
    has Str $.town;
    has Str $.street;
}

my $address = Address.new(
    housenumber =&gt; '10',
    zipcode =&gt; '1020',
    country =&gt; 'Country',
    town    =&gt; 'Town',
    street  =&gt; 'Street',
);

print qq:to/ADDRESS/;
    {$address.street} {$address.housenumber}
    {$address.zipcode} {$address.town}
    {$address.country}
ADDRESS</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Address</code> 类包含一些数据元素，用于字符串插值以显示他们的观。请注意，你需要使用花括号，以便 Raku 能够理解点是名称的一部分，后跟属性名称。该程序的结果打印成三行的地址:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Street 10
1020 Town
Country</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们完成了我们的任务，但考虑为另一个地址打印另一个信封标签。为避免代码重复，我们必须将格式化字符串放到子例程中。要做到更好，地址的格式必须成为 <code>Address</code> 类的一部分。让我们将 <code>full_address</code> 方法添加到类中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">class Address {
    has Str $.housenumber;
    has Str $.zipcode;
    has Str $.country;
    has Str $.town;
    has Str $.street;
    method full_address() {
        return qq:to/ADDRESS/;
            $.street $.housenumber
            $.zipcode $.town
            $.country
        ADDRESS
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在方法内部，可以使用 <code>$.street</code> ， <code>$.zipcode</code> 等名称来访问对象属性。</p>
</div>
<div class="paragraph">
<p>让我们关注这个重要方面。在类代码之外，访问属性需要一个对象。例如，如果我们通过调用新的构造函数创建了一个对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Address {
    has $.street is rw;
}
my $address = Address.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，为了访问 <code>$address</code> 属性的字段，我们使用点语法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$address.street = 'Ramblas';
say $address.street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们之前已经看到的，另一个地址将保留其自己的 <code>$.street</code> 属性值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $address2 = Address.new;
$address2.street = 'Calle de Alcalá';

say $address2.street; # Calle de Alcalá
say $address.street;  # Ramblas</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，让我们使用方法中的属性。我们创建了两个方法，一个用于设置 <code>$.street</code> 的新值，另一个用于读取它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Address {
    has $.street is rw;

    method get_street() {
        return $.street;
    }

    method set_street($new_street) {
        $.street = $new_street;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以，该类现在提供方法 <code>get_street()</code> 和 <code>set_street()</code>，然后我们立即使用它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $address = Address.new;
$address.set_street('Ramblas');

my $address2 = Address.new;
$address2.set_street('Calle de Alcalá');

say $address.get_street();  # Ramblas
say $address2.get_street(); # Calle de Alcalá</code></pre>
</div>
</div>
<div class="paragraph">
<p>在方法内部，该属性称为 <code>$.street</code>。使用相同的代码设置并获取 <code>$address</code> 和 <code>$address2</code> 实例的属性值。</p>
</div>
<div class="paragraph">
<p>在类方法中，我们没有看到任何提及 <code>$address</code> 或 <code>$address2</code>，而 Raku 知道要使用哪个对象，因为为这些对象调用了方法。什么时候编译器看到一个构造如 <code>$address.get_street()</code>，该方法接收一个指向对象的指针。我们没有明确地看到它，但你可以通过以下方式重写它， 它类似于对常规子程序的调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">set_street($address: 'New value');
say get_street($address:);</code></pre>
</div>
</div>
<div class="paragraph">
<p>该对象现在作为 <code>set_street</code> 和 <code>get_street</code> 例程的第一个参数传递。对象，我们为之调用的方法，被称为调用者。我们在第四章, 使用运算符中讨论过。用这样的传统语法作为 <code>$address.get_street()</code>，调用者仍然传递给方法但不是显式的。</p>
</div>
<div class="sect3">
<h4 id="_私有方法">8.3.1. 私有方法</h4>
<div class="paragraph">
<p>要隐藏属性，你需要将 twigil 更改为 <code>.!</code>。同样，可以使用相同的感叹号将方法设为私有方法以隐藏方法。私有方法不能在对象上调用; 它们只能用于该类的其他方法。检查一下以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class X {
  method !a() {
    say 'Private method';
  }

  method b() {
    say 'Public method';
    self!a();
  }
}

my $x = X.new();</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个类有两个方法，<code>a</code> 和 <code>b</code>。第一个方法被声明为私有方法, 所以试图将其调用为 <code>$x.a()</code> 会导致运行时错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">No such method 'a' for invocant of type 'X'</code></pre>
</div>
</div>
<div class="paragraph">
<p>方法 <code>b</code> 是公有的因此可以被调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$x.b();</code></pre>
</div>
</div>
<div class="paragraph">
<p>在里面，这个方法在 <code>self</code> 关键字 - <code>self!a()</code> 的帮助下调用私有方法 <code>a</code>。<code>self</code> 指向当前正在处理的对象， 因此它与外部程序中的 <code>$x</code> 相同。你也可以使用 <code>self</code> 来调用公共方法-<code>self.b()</code>，但它是多余的，只应用于解决名称冲突。</p>
</div>
<div class="paragraph">
<p>现在，在我们讨论了类方法之后，让我们回到属性并看看有什么我们可以通过方法了解它们的新的信息。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_再谈属性">8.4. 再谈属性</h3>
<div class="paragraph">
<p>我们从Class属性开始本章，但是有一些特性 属性与方法密切相关，这就是我们休息的原因 能够继续谈论属性。</p>
</div>
<div class="sect3">
<h4 id="_公共和私有属性">8.4.1. 公共和私有属性</h4>
<div class="paragraph">
<p>在前面的代码示例中，class属性是用dot声明的
sigil - <code>$.rooms</code> 或 <code>$.street</code>。该位置的一个点表示该属性是公共的, 可以通过不属于该类的代码访问。
还有另一个twigil，!，它使属性变得私密。这意味着唯一的方法 读取或更改属性的值是从方法中访问它。</p>
</div>
<div class="paragraph">
<p>让我们回到 House 类并将其方法的所有细节改为 <code>!</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $!rooms;
    has $!area;
    has $!height;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建房屋可以像以前一样完成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(
    rooms  =&gt; 2,
    area =&gt; 100,
    height =&gt; 3,
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，现在无法读取属性的值。试图获得  $house.rooms 的值失败:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">No such method 'rooms' for invocant of type 'House'</code></pre>
</div>
</div>
<div class="paragraph">
<p>$house!房间的工作原理:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Private method call to rooms must be fully qualified with the package containing the method</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是因为 !twigil 将属性标记为私有属性，但不能 从类外访问。我们可以从方法代码中使用它们， 虽然。让我们创建方法 get_rooms 和 set_rooms 来获取和设置房间的数量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> class House {
       has $!rooms;
       has $!area;
       has $!height;
       method get_rooms() {
           return $!rooms;
       }
 method set_rooms($new_value) {
           $!rooms = $new_value;
} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次，创建一个具有一些初始值的新房子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(
    rooms =&gt; 2,
    area =&gt; 100,
    height =&gt; 3,
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，使用新方法首先修改房间数，然后打印它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$house.set_rooms(3);
say $house.get_rooms(); # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>在面向对象编程理论中，隐藏对象属性称为封装。Raku 使用了! 为此而言。该属性成为私有属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_setter_和_getter_方法">8.4.2. setter 和 getter 方法</h4>
<div class="paragraph">
<p>在上一节中，我们创建了一对 getter 和 setter 方法，get_rooms 和 set_rooms，仅用于House类的一个属性。我们也可以为其他人这样做
属性，例如 $!area 和 $!height，但这需要大量的复制和粘贴工作，并不是花时间的最佳方式。</p>
</div>
<div class="paragraph">
<p>实际上，我们在本章前面使用的点语法来设置和读取属性 是一种使用 Raku 为我们创建的 getter 和 setter 方法的语法作弊。让我们一步一步地检查它。
首先，用 <code>$.</code> 创建一个简单的类属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class X {
    has $.y;
}

my $x = X.new(y =&gt; 1);
say $x.y; # 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>$x 对象具有名为y的属性。这是一个公共属性(因为.twigil) 并且可以从外面访问。在幕后，Raku 创建了一个相同的方法
name y，返回 <code>$.y</code> 的值。所以， <code>$x.y</code> 的调用实际上调用了那个看不见的东西方法。</p>
</div>
<div class="paragraph">
<p>将此示例与其修改进行比较，其中明确定义方法y:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class X {
has $.y;
    method y() {
        return 2;
    }
}

my $x = X.new(y =&gt; 1);
say $x.y; # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>调用代码 $x.y 没有改变，但打印的值现在不同了，因为我们的
方法重新定义了与编译器创建的名称相同的方法。 现在，让我们通过将值赋给 $x.y 来设置值。当然，必须声明属性</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class X {
    has $.y is rw;
}

my $x = X.new(y =&gt; 1);
$x.y = 2;
say $x.y; # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>这次，编译器创建一个 setter 方法，在我们为其分配新值时调用该方法 <code>$.y</code> 属性。我们可以通过创建一对多方法来模仿整个画面。 多方法是共享相同名称但具有不同签名的方法。在其他语言这个概念在术语函数重载或方法下也是已知的超载。它们类似于多子程序，我们将在第6章中介绍它们，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class X {
    has $.y is rw;
    multi method y() {
        return $!y;
    }

    multi method y($value) {
        $!y = $value;
    }
}

my $x = X.new(y =&gt; 1);
$x.y(2);
say $x.y(); # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此代码中，我们仅使用显式多方法更改 <code>$.y</code> 属性的值 <code>y()</code> 和 <code>y($value)</code>。</p>
</div>
<div class="paragraph">
<p>请注意，在方法内部，<code>!</code> twigil 用于 <code>$.y</code> 属性。当你设置或</p>
</div>
<div class="paragraph">
<p>使用获取属性 <code>!</code> twigil，Raku 直接访问它的属性而不使用自动生成的 getter 和 setter 方法。所以，即使你有一个公共属性
<code>$.y</code>，用点声明，最好在类方法中使用直接访问 <code>$!y</code>。 最后，让我们再次看一下访问公共变量之间的区别而且是特征。在下一个代码中，<code>$.x</code> 属性是公共的，但不是声明的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class C {
    has $.x;
    method set() {
        $!x = 4;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>无法从主程序设置新值，但仍可以
从方法修改属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = C.new;
$c.set();
say $c; # 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>该属性是公共的，因此编译器为它生成一个 getter 方法，但不是读写属性，因此不会创建 setter。</p>
</div>
</div>
<div class="sect3">
<h4 id="_类属性">8.4.3. 类属性</h4>
<div class="paragraph">
<p>现在假设我们正在建造一条街道，并想给任何人提供门牌号码新对象。为简单起见，让我们暂时删除除了之外的所有属性</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Address {
    has Int $.housenumber is rw;
}

class House {
    has Address $.address is rw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一步是构建 house 并将它们保存在 @street 数组中的循环:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @street;
   for 1..10 {
       push @street, House.new(
           address =&gt; Address.new(
               housenumber =&gt; @street.elems + 1
           )
) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>要增加门牌号，我们按以下方式使用 @street 的大小:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@street.elems + 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可以确保每个新房都有一个数字，这个数字大于现有房屋的所有数字。要看到这一点，遍历数组以打印数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $_.address.housenumber for @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，保持外部柜台跟踪创建的房屋并不是什么大不了的事，但是
还有另一种方法 - Address 类本身可以告诉我们创建了多少个对象。
我们将使用所谓的类属性，它们属于类而不属于实例 它的。这意味着所有对象共享相同的类属性。这与之形成鲜明对比常规属性 - 每个对象都接收自己的容器。在其他编程语言中， 类属性也称为静态数据成员。</p>
</div>
<div class="paragraph">
<p>所以，这是代码，其中 Address 类配备了 class 属性 $last_assigned_number，这是一个用 my 关键字 inside 声明的整数值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Address {
    my Int $last_assigned_number = 0;
    has Int $.housenumber is rw;
    method assign_next() {
        $last_assigned_number++;
        $.housenumber = $last_assigned_number;
    }
}

class House {
    has Address $.address is rw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建 assign_next 方法以执行必要的操作以增加值 class 属性 $last_assigned_number 并将其分配给实例属性
$.housenumber。 让我们修改用于生成房屋数组的循环以使用 assign_next 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @street;
   for 1..10 {
        my $house = House.new(
            address =&gt; Address.new()
        );
        $house.address.assign_next();
        push @street, $house;
}
say $_.address.housenumber for @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序从1到10打印10个数字。如你所见，我们所需要做的就是调用 Address 对象上的方法。现在所有的计算都是通过这种方法完成的，而不是通过使用类的代码。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类方法">8.5. 类方法</h3>
<div class="paragraph">
<p>在前面的示例中，我们使用 class 属性来保存数据 在所有类的实例之间共享。我们正在使用一种与之相关的方法属性。</p>
</div>
<div class="paragraph">
<p>类属性的概念也可以投射到方法上。在 Raku 中，类可以包含类方法，使用 sub 关键字定义。这些方法可以访问所有人类属性，但不接收对该对象的隐式自引用。考虑一下两个类的示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Address {
    my Int $last_assigned_number = 0;
    has Int $.housenumber is rw;
    our sub get_next() {
        return ++$last_assigned_number;
    }
}

class House {
    has Address $.address is rw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>get_next 类方法也使用 our 关键字声明。这是必要的，因为我们想从外部代码访问该方法。默认情况下，范围将限制为只有类。
现在，进行循环设计的下一次迭代以生成街道:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @street;
   for 1..10 {
       my $house = House.new(
           address =&gt; Address.new()
       );
       $house.address.housenumber = Address::get_next();
       push @street, $house;
}

say $_.address.housenumber for @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的主要区别是我们分配门牌号的方式。get_next 方法无法在 Address 类的实例上调用，因此编译器不接受
表达式 $house.address.get_next。对称，你无法访问 方法中的自变量。</p>
</div>
<div class="paragraph">
<p>必须使用类名称 Address::get_next() 调用 get_next 方法。它 更改 $last_assigned_number 计数器的值。计数器也是一个变量 不属于 Address 类的任何特定实例。实际上，
甚至可以在创建任何对象之前调用 Address::get_next() 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Address::get_next(); # 1
say Address::get_next(); # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在是时候更详细地了解 Raku 的面向对象设施了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_继承">8.6. 继承</h3>
<div class="paragraph">
<p>面向对象编程的下一个特性是继承。在本节中，我们进行讨论关于 Raku 中的继承和相关主题。</p>
</div>
<div class="sect3">
<h4 id="_从类继承">8.6.1. 从类继承</h4>
<div class="paragraph">
<p>在 OOP 中继承意味着创建一个新类，该类扩展另一个已存在的类。 最简单的继承形式是两个类的子父对。
在前面的部分中，我们创建了 House 类。让我们将它用作父类另一个概念。我们将创建一个 ModernHouse 类，这是一个带太阳能屋顶的房子面板。我们在本章前面创建的裸房子包含四个
attributes - 房间数，面积，高度和地址。地址属性是
在我们之前的示例中解决了对象，但在本节中，我们将保持简单和
假设地址是一个字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.rooms;
    has $.area;
    has $.height;
    has $.address;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 ModernHouse，增加了太阳能电池板生成的另一个属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class ModernHouse is House {
    has $.power;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>ModernHouse 类现在是一个具有五个属性的类，其中四个来自 House 类和在 ModernHouse 的定义中添加了一个。从用户的角度来看，所有的 ModernHouse 类的属性是相同的，你初始化并使用它们就像它们一样 ModernHouse 类中定义的属性，如以下示例中所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = ModernHouse.new(
    rooms   =&gt; 5,
    area    =&gt; 150,
    height  =&gt; 5,
    address =&gt; '...',
    power   =&gt; 200,
);

say $house.area;  # 100
say $house.power; # 200</code></pre>
</div>
</div>
<div class="paragraph">
<p>在不同的编程语言中，使用不同的术语来指代类 参与继承。House 类可以被称为基类，父类或 a 超类。ModernHouse 类是派生类，子类或子类。
在 Raku 的文档中，使用了术语父类和子类。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用子类实例作为基础的对象">8.6.2. 使用子类实例作为基础的对象</h4>
<div class="paragraph">
<p>类
ModernHouse 类型的对象也是 House。考虑一个带有的函数 f 论证并认为它是众议院类型的对象。功能的签名对参数应用限制:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f(House $h) {
    say "There are {$h.rooms} rooms in this house.";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，让我们创建两个不同的房子并用它们调用函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(rooms =&gt; 2);
my $modern_house = ModernHouse.new(rooms =&gt; 3, power =&gt; 100);

f($house);
f($modern_house);</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码完美运行并打印预期的字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">There are 2 rooms in this house.
There are 3 rooms in this house.</code></pre>
</div>
</div>
<div class="paragraph">
<p>该函数仅使用在父类中定义的属性，因此可以轻松实现
处理子类的对象，因为它还包含必需的属性。
如果我们逆转这种情况怎么办 - 创建一个期望子类对象的函数， 并将基类的对象传递给它?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f2(ModernHouse $h) {
    say "This house generates {$h.power} kWh.";
}

f2($modern_house);</code></pre>
</div>
</div>
<div class="paragraph">
<p>到目前为止，它的工作原理，因为对象的类型没有区别:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">This house generates 100 kWh.</code></pre>
</div>
</div>
<div class="paragraph">
<p>f2 函数正在访问 $.power 属性，该属性在 House 类中不存在。如果
你调用函数并将 $house 变量传递给它，将引发错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Type check failed in binding to parameter '$h'; expected ModernHouse but got House (House.new(rooms =&gt; 2,...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>考虑使用类型变量的另一个例子。在下一个示例中，@street 数组是
House 类型的一系列对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my House @street;
push @street, ModernHouse.new(rooms =&gt; 3, power =&gt; 100);
push @street, House.new(rooms =&gt; 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>两个房子都成功添加到 @street 数组，因为它们兼容 房子类型。如果循环遍历数组，则可以读取 House 类的属性， 它们也出现在 ModernHouse 类型的对象中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">f($_) for @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果更严格地声明 @street 数组，即，如果我们使用 ModernHouse 类型
数组元素的类型，那么编译器将不接受 House 类型的对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my ModernHouse @street;
push @street, ModernHouse.new(rooms =&gt; 3, power =&gt; 100);
# push @street, House.new(rooms =&gt; 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果取消注释最后一行，程序将停止并显示类型检查错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Type check failed in assignment to @street; expected ModernHouse but got House (House.new(rooms =&gt; 2,...)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_重写方法">8.6.3. 重写方法</h4>
<div class="paragraph">
<p>在许多情况下，子类的方法应该与其中的方法有不同的反应
父类。在这里，我们来看一个重新定义或重写方法的重要概念。
让我们继续使用 House 和 ModernHouse 的示例并实现该方法 计算暖房所需的电费。我们专注于主题 简化类和计算成本的方法，假设它是成比例的 到房子的区域。
在这两个类中，我们定义了名为 energy_cost 的方法，它的方法不同每个类的计算:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.area;
    method energy_cost() {
        return 0.8 * $!area;
    }
}

class ModernHouse is House {
    has $.power;
    method energy_cost() {
        return 0.3 * $.area;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意使用区域值的微小差异。在 House 类中，可以参考它是一个带有 $!area 语法的本地属性。在 ModernHouse 类中，我们必须使用生成的 getter $.area。
现在，创建两个实例并打印成本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(area =&gt; 100);
my $modern_house = ModernHouse.new(area =&gt; 100, power =&gt; 150);

say $house.energy_cost();        # 80
say $modern_house.energy_cost(); # 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>毫无疑问，每个对象都使用自己的 energy_cost 方法变体。 当我们保留不同类型的房屋时，这种行为更加有趣</p>
</div>
<div class="paragraph">
<p>相同的集合。在下一个例子中，我们将两个不同的房子放入 @street 数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my House @street;

push @street, House.new(area =&gt; 100);
push @street, ModernHouse.new(area =&gt; 100, power =&gt; 150);</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们迭代数组并在循环变量上调用 energy_cost 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $_.energy_cost() for @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序打印的输出与前一个输出完全相同。这个 意味着我们面对多态行为 - 每个对象都知道它属于哪个类 调用正确的方法。
多态性可能更复杂。让我们重新组织上一个例子中的代码 并引入 tariff_coef 方法，该方法将用于计算成本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.area;
    method tariff_coef() {
        return 0.8;
    }

    method energy_cost() {
        return self.tariff_coef() * $!area;
    }
}

class ModernHouse is House {
    has $.power;
    method tariff_coef() {
        return 0.3;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，energy_cost 方法仅在基类中定义。所以，一个实例
ModernHouse 类将使用该方法。但是，在 energy_cost 方法里面 正在调用 tarif_coef 方法，Raku 将找到它的正确实现
取决于对象的类型。这在以下代码中演示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(area =&gt; 100);
my $modern_house = ModernHouse.new(area =&gt; 100, power =&gt; 150);

say $house.energy_cost();        # 80
say $modern_house.energy_cost(); # 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，方法解析的行为表明它按预期工作。
请注意，方法 energy_cost 必须是公共方法，否则不会遗传。
子方法
正如我们所看到的，子类接收基类定义的所有公共方法。在
在某些情况下，这是不希望的。将该方法设为私有也不总是一种解决方案
你可能希望在基类的对象上调用它。
Raku 允许所谓的子方法。它们不是遗传的。让我们一起来了解它们 小例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Parent {
    method meth() {
        say 'meth()';
    }

    submethod submeth() {
        say 'submeth()';
     }
}

class Child is Parent {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，创建两个对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $o1 = Parent.new;
my $o2 = Child.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Parent 类中，可以在该类型的对象上调用两种方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$o1.meth(); # meth()
$o1.submeth(); # submeth()</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Child 类中，只有 meth 方法可用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$o2.meth(); #meth()</code></pre>
</div>
</div>
<div class="paragraph">
<p>禁止调用 submeth 子方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">No such method 'submeth' for invocant of type 'Child'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_多重继承">8.6.4. 多重继承</h4>
<div class="paragraph">
<p>在 Raku 中，允许多重继承。多重继承意味着子类源自多个父母。检查以下框架示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class P1 {
    method p1() {
        say 'p1()';
    }
}

class P2 {
    method p2() {
        say 'p2()';
    }
}

class C is P1 is P2 {
    method c() {
        say 'c()';
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class C is P1 is P2 { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着 C 类的实例接收到任何可用的所有方法</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = C.new;
$c.p1();
$c.p2();
$c.c();</code></pre>
</div>
</div>
<div class="paragraph">
<p>多重继承是一种强大的技术，但它也可以提供隐藏的名称冲突。 想象一下，在前面的例子中，还有另一个类 P，它是基类 P1 和 P2:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class P {
    has $!count;
    method get_count() {
        return $!count++;
    }
}

class P1 is P {
    method p1() {
        say 'p1()';
    }
}

class P2 is P {
    method p2() {
        say 'p2()';
    }

    method get_count() {
        return -1;
    }
}

Class C is P1 is P2 {
    method c() {
        say 'c()';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>P 和 P2 类都有自己的 get_count 方法实现。在里面
P 类，这个方法使用一个属性，每次都返回一个递增的数字在 P2 类中，返回值始终为 -1。</p>
</div>
<div class="paragraph">
<p>C 类对象发生了什么，它是从 P1 和 P2 派生而来的
P，正在调用 get_count 方法?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = C.new;
say $c.get_count();
say $c.get_count();
say $c.get_count();</code></pre>
</div>
</div>
<div class="paragraph">
<p>一方面，C 类中的 get_count 方法是通过 P1 从 P 类派生的。上另一方面，具有相同名称的方法源自 P2。Raku 选择了来自 P2 的方法，因为它更靠近 C .因此，程序打印-1三次。
如果你想了解有关 Raku 解决多个名称冲突的方式的更多信息 继承，参考 C3 线性化方法的分辨率顺序 <a href="https://" class="bare">https://</a>。 到目前为止，我们经历了经典的面向对象编程的主要概念。Raku
还支持角色的新概念，我们将在下一步介绍。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用角色追加对象和类">8.7. 使用角色追加对象和类</h3>
<div class="paragraph">
<p>角色是现代 OOP 中的另一种机制。角色就像是类的外部部分，它附加到现有对象或类，提供一些额外的属性和方法。角色与某些编程语言中的接又非常接近。
让我们把房子变成一个漂浮的房子。为简单起见，House 类只有一个属性，房子的面积。Floating 角色有一个属性保持 浮动房屋的重量以及如果房屋也是如此，则返回布尔值的方法沉重而且正在下沉:</p>
</div>
<div class="paragraph">
<p>从语法上讲，创建角色的唯一区别是代替了关键字角色
class 关键字。 从现在开始，有两种方法可以应用角色。首先，让我们采取一个已经存在的
房子并应用它的角色。在该示例中，使用构造函数创建房屋 House.new，并使用 does 关键字追加角色:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.area is rw;
}

role Floating {
    has $.weight is rw;
    method is_sinking() {
        return $!weight &gt; 500 * $.area;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见，$.weight 属性和浮动的is_sinking方法 角色可用于 $floating_house 对象。
该对象获得复合类型 House + {Floating}:
说 $floating_house.WHAT; #(House + {Floating})
在第二种方法中，首先创建一个新类。FloatingHouse类是派生的 来自 House 并导入 Floating 角色。要连接角色，关键字是相同的用过的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class FloatingHouse is House does Floating {
}

my $floating_house = FloatingHouse.new;
$floating_house.area = 100;
$floating_house.weight = 100_000;
say $floating_house.is_sinking(); # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序的行为与前面的示例相同，但是类型
对象是不同的，不包含任何角色的痕迹:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $floating_house.WHAT; # (House+{Floating})</code></pre>
</div>
</div>
<div class="paragraph">
<p>在某些方面，使用角色非常接近类继承。两种方法都可行
在某些情况下同样好。这是继承和继承之间选择的经验法则</p>
</div>
<div class="paragraph">
<p>当你可以说 A 是 B 时，你从 B 继承 A ; 你可以这么说的时候申请一个角色
A不乙。
例如，狗是一种动物，所以你继承了 Dog from Animal。但狗确实吠叫了</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Dog is Animal does Bark { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>考虑另一个例子，可以使用上面定义的 Floating 角色。我们是创建一个水上餐厅。餐厅也是一个房子，它也漂浮。所以，层次结构可以这样做:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.area is rw;
}

class Restaurant is House {
    has $.seats is rw;
}

role Floating {
    has $.weight is rw;
    method is_sinking() {
        return $!weight &gt; 500 * $.area;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，Floating 角色与我们在前一个示例中使用的角色完全相同漂浮的房子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $restaurant = Restaurant.new does Floating;
$restaurant.seats = 30;
$restaurant.area = 100;
$restaurant.weight = 10_000;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $restaurant.is_sinking(); # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们停下来创建类层次结构并应用角色，看看 Raku 如何提供帮助检查这些对象的内部结构。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用内省学习更多">8.8. 使用内省学习更多</h3>
<div class="paragraph">
<p>Raku对象系统有一个内置的内省机制，你可以看到它这个特定的对象可以做什么，它正在实现哪个类，哪些方法 可以使用，等等。</p>
</div>
<div class="paragraph">
<p>在前面的章节中，我们已经使用了内省的一种机制 - 什么方法。它返回类型对象，其中包含有关对象类型的信息
现在位于容器中。我们正在讨论专用章节中的内省面向对象的编程，但你应该记住，在 Raku 中，还有很多其他的诸如字符串或整数之类的简单变量也是对象。
例如，这是你可以看到字符串类型和整数的方式。程序打印 WHAT 方法返回的字符串化版本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'string'.WHAT; # (Str)
say 42.WHAT;       # (Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用用户定义的类，WHAT方法提供类的名称:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class C {
}
my $c = C.new;
say $c.WHAT; # (C)</code></pre>
</div>
</div>
<div class="paragraph">
<p>HOW 方法返回 Raku::Metamodel::ClassHOW 类的对象。这是一个 Raku 中所谓的元对象模型的一部分，它负责Raku的工作原理 处理对象及其属性和行为。我们不会去学习的元对象协议(MOP)，但会看看两个有用的方法，它 提供名称和 mro。</p>
</div>
<div class="paragraph">
<p>name 方法返回类的名称。请注意，WHAT 方法返回一个类型对象，在打印时以(<code>ClassName</code>)的格式进行字符串化，而名称则为
Raku::Metamodel::ClassHOW 类的方法返回一个字符串。这是怎么命名的必须调用方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $c.HOW.name($c); # C</code></pre>
</div>
</div>
<div class="paragraph">
<p>在给定变量 $c 上，调用方法 HOW。它返回一个名称的对象 使用变量 $c作为参数调用方法。这种冗余是由一些人完成的 Raku 开发人员牢记的未来计划。出于实用目的，它更容易使用另一种更简单的语法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $c.HOW.name($c); # C</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>HOW.mro</code>，或简称 <code>^mro</code>，方法(名称代表方法解析顺序) 返回显示类层次结构的列表。它可以用来了解名称冲突将得到解决。
例如，以下是一些具有子父关系的类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {}
class B is A {}
class C is A {}
class D {}
class E is D is B is C {}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say E.^mro;

my $e = E.new;
say $e.^mro;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下，将打印以下字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt"> ((E) (D) (B) (C) (A) (Any) (Mu))</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果复杂层次结构中存在困难关系，你可以调用此方法查看 Raku 如何在内部看到它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_方法后缀运算符">8.9. 方法后缀运算符</h3>
<div class="paragraph">
<p>在第4章，使用运算符，我们没有涵盖一组特殊的后缀运算符， 这与面向对象的编程有关。现在是填补这一空白的时候了。该 本节中描述的运算符是语法结构，但它们可能都是考虑后缀运算符。
要在对象上调用方法，请使用点运算符。我们已经多次使用它了
本章:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    method m() {
        return 42;
    }
}

my $o = A.new; # calling the 'new' method
say $o.m();    # calling the 'm' method</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果该方法不存在，比如说，如果你调用 $on()，则调用失败:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">No such method 'n' for invocant of type 'A'</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 'A' 类型的调用者，没有这样的方法 'n' 为防止引发异常，<code>.?</code> 方法调用操作符的形式可以帮助:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $o.?m(); # 42
say $o.?n(); # Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>像往常一样调用现有方法，而不存在方法的调用返回没有，程序继续。
<code>.+</code> 和 <code>.*</code> 运算符用于调用具有给定名称的所有方法。这可能是当你有一个类的层次结构时很有用。考虑以下程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    method m() {
        return 'A::m';
    }
}

class B is A {
    method m() {
        return 'B::m';
    }
}

my $o = B.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>m 方法在父类和子类中定义，因此 <code>$om()</code> 的调用被路由到 B 类的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $o.m(); # B::m</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.+</code> 方法调用所有方法并返回结果列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @result = $o.+m();
say @result; # [B::m A::m]</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见，调用 $o`.+`  m()会调用 <code>$o.^mro</code> 命令中的 m 方法(参见 上一节，内省，详情)。
如果方法名称未知，则会发生异常。例如，它是不可能的叫 <code>$o.+n()</code>:
对于 'B' 类型的调用者，没有这样的方法 'n'</p>
</div>
<div class="paragraph">
<p><code>.*</code> 运算符与 <code>.+</code> 运算符类似，但允许尝试调用不存在的运算符 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $o.*m(); # (B::m A::m)
say $o.*n(); # ()</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 n 方法，返回空的结果列表。要记住操作员，你可以 比较 + 和 * 的语义与常规中使用的相应量词</p>
</div>
<div class="paragraph">
<p>表达式(见 第11章，正则表达式) <code>.+</code> 表示至少应该有一种方法 使用该名称，而 * 允许任意数量，包括零。
现在让我们看看如何在同一个例子中从基类调用该方法。那里 是个  <code>.::</code> 运算符，可用于完全限定调用方法的名称:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $o.A::m(); # A::m</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">这里， $o 变量是 B 类的一个对象，但是在它的帮助下。</dt>
<dd>
<p>运算符调用父类中的方法 A::m。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在本章中，我们了解了 Raku 中面向对象的支持。我们经历了创建 一个类，向其添加属性和方法，以及公开方法和类数据或私人的。然后我们讨论了类层次结构和使用角色的替代方法以及如何使用 Raku 内置工具来内省对象。在一组 例子，我们研究了许多处理复杂对象的技术。最后， 列出了 postfix 方法运算符，你可以使用它创建更多通用和强大的计划。</p>
</div>
<div class="paragraph">
<p>在下一章中，描述了异常。在 Raku 中，它们基于类，所以 本章的知识对于更好地理解非常有用例外。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_10">8.10. 总结</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_输入和输出">9. 输入和输出</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章专门介绍输入和输出，主要基于 Raku 中的 <code>IO::Handle</code> 类。计算机程序通常与用户通信。它可能是控制台应用程序中的输入和输出，或读取配置文件或保存
结果到磁盘上的文件。在本章中，我们将讨论 Raku 中的输入和输出设施。</p>
</div>
<div class="paragraph">
<p>本章将介绍以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>标准输入和输出</p>
</li>
<li>
<p>使用文件</p>
</li>
<li>
<p>分析文件和目录的属性</p>
</li>
<li>
<p>读取输入流的方法</p>
</li>
<li>
<p>写到输出流的方法</p>
</li>
<li>
<p>格式化输出</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_从流中读取">9.1. 从流中读取</h3>

</div>
<div class="sect2">
<h3 id="_写出到流">9.2. 写出到流</h3>

</div>
<div class="sect2">
<h3 id="_标准输入和输出">9.3. 标准输入和输出</h3>
<div class="paragraph">
<p>在前面的章节中，我们创建了许多可以打印到控制台并从控制台读取的程序。让我们刷新一些第二章中编写代码的知识，并创建一个询问用户的名字并问候他们程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = prompt 'What is your name? ';
say "Hello, $name!";
note "Greeted $name at " ~ time;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，<code>prompt</code> 函数打印消息并等待用户输入字符串。该字符串被保存在 <code>$name</code> 变量中，稍后被插值到双引号字符串中。<code>note</code> 函数打印调试消息并记录受到欢迎的时间。</p>
</div>
<div class="paragraph">
<p>在这个程序中，Raku 使用两个标准通信通道，即标准输入流(简称 stdin)和标准输出流(stdout)。这些是接收用户输入并接受程序打印内容的默认流。另一个通道，我们在第二章的编写代码中已经提到过，是打印错误消息和警告的流，即标准错误输出(stderr)。</p>
</div>
<div class="paragraph">
<p>在 Linux 系统上，POSIX 标准确定文件描述符编号为数字 0, 1 和 2 分别是 stdout，stdin 和 stderr。在 Raku 中，有三个具有动态作用域的特殊变量，<code>$*OUT</code>，<code>$*IN</code> 和 <code>$*ERR</code>， 它们默认附加到这些通道上。</p>
</div>
<div class="paragraph">
<p><code>print</code> 和 <code>warn</code> 等内置函数使用 <code>$*OUT</code>，<code>$*IN</code> 和 <code>$*ERR</code> 的值。 下表显示了函数和通道之间的对应关系:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">函数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">输入或输出方向</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">输入或输出流</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">print</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">output</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*OUT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">say</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">output</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*OUT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">prompt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">output</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*OUT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">prompt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">input</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*IN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">note</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">output</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*ERR</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">warn</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">output</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*ERR</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><code>$*OUT</code>，<code>$*IN</code> 和 <code>$*ERR</code> 变量是 <code>IO::Handle</code> 类的实例。让我们来探索它。</p>
</div>
<div class="paragraph">
<p><code>IO::Handle</code> 类表示打开的文件或输入/输出流。在 Raku 中，这个类实现了 <code>IO</code> 角色。在本节中，我们将讨论 <code>IO::Handle</code> 类和 <code>IO</code> 角色赋予程序员的最有用的方法。</p>
</div>
<div class="paragraph">
<p>我们将学习的内容适用于标准输入/输出流和使用文件。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用文件和目录">9.4. 使用文件和目录</h3>
<div class="paragraph">
<p>和很多其它语言一样，在 Raku 中使用文件是通过文件句柄来完成的。 打开文件后立即获得文件句柄; 稍后，你使用该句柄写入文件或者从中读取。所有其他操作，例如刷新缓冲区或关闭文件，也都是通过句柄执行的。</p>
</div>
<div class="sect3">
<h4 id="_打开文件">9.4.1. 打开文件</h4>
<div class="paragraph">
<p>要打开文件，请使用 <code>open</code> 函数(它由 <code>IO</code> 角色提供，但可以用作简单的内置函数)。它接收一个文件路径和许多可选参数。 返回值是文件句柄，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open '/etc/passwd';</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，文件以只读模式打开。可以显式地使用命名参数传递模式名称。以上示例等同于以下代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open '/etc/passwd', :r;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下表列出了打开文件的可能模式:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">参数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:r</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">只读模式。这是默认模式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">只写模式。文件不存在则创建，文件存在则覆盖。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:rw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可读可写模式。文件不存在则创建，文件存在则覆盖。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">追加模式。文件不存在则创建，文件存在把数据追加到现有文件的末尾。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>根据打开文件的模式，<code>IO::Handle</code> 类中的一组方法将可用。例如，你无法写入使用 <code>:r</code> 选项打开的文件，即使文件句柄仍然是通用的 <code>IO::Handle</code> 类的实例。在这种情况下将抛出 <code>X::AdHoc</code> 异常:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open '/etc/passwd', :r;
try {
    $fh.say('Hello'); # Attempt to write to a read-only file
}
say $!.^name;         # X::AdHoc, see details in Chapter 10, Exceptions</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>open</code> 函数还接受一些配置参数，如下表所示:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">参数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:bin</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">以二进制模式打开文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:enc('encoding')</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">给文件关联给定的编码。查看写入到流一节中的例子。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:chomp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果 :chomp 被设置为真，那么按行读取时，新行符会被截断(请参阅从流中读取一节)</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_关闭文件">9.4.2. 关闭文件</h4>
<div class="paragraph">
<p>要关闭文件，请在文件句柄上调用 <code>close</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open '/etc/passwd';
# .... read from file
$fh.close;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_测试文件和目录属性">9.4.3. 测试文件和目录属性</h4>
<div class="paragraph">
<p><code>IO</code> 角色提供了许多单字母方法来检查文件和目录的不同指标。返回值是布尔值。下表中列出了这些方法:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">e</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查路径是否存在</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查路径是否为已存在的目录</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">f</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查路径是否为已存在的文件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">l</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查路径是否为符号链接</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">r</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查路径是否可访问(因此，已设置读取位)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查路径是否可写(已设置写位)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查路径是否可执行(已设置执行位)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查路径是否可读和可写</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rwx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查是否为路径设置了所有 r，w 和 x 位</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查文件是否为非空</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">z</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查文件大小是否为零</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>将这些方法视为示例。由于方法是在 <code>IO</code> 角色中定义的，我们必须首先在可以表示路径的变量上调用 <code>IO</code> 方法来访问它们。例如，它可以是文字字符串或包含文件或目录路径的变量。还有，你可以在文件句柄上调用 <code>IO</code> 方法。</p>
</div>
<div class="paragraph">
<p>我们来看几个例子。检查文件是存在:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $path = '/etc/passwd';
say "File $path exists" if $path.IO.e;</code></pre>
</div>
</div>
<div class="paragraph">
<p>检查目录是否存在:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if '/Users'.IO.d {
    say '/Users is a directory';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>d</code> 方法仅适用于目录。如果路径存在但它是一个文件，那么该方法返回 <code>False</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Not a directory' unless '/etc/passwd'.IO.d;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要检查路径是否存在，请使用 <code>e</code> 方法。结果不取决于路径是目录还是文件:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'File or directory exists' if '/'.IO.e;</code></pre>
</div>
</div>
<div class="paragraph">
<p>用于测试文件和目录属性的所有上述方法都可以与使用智能匹配运算符和以冒号开头的副词结构的不同语法一起使用，例如 <code>:e</code>。以下示例介绍了如何执行此操作; 两行代码都是一样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Exists' if 'data.txt'.IO.e;
say 'Exists' if 'data.txt'.IO ~~ :e;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_操纵文件">9.4.4. 操纵文件</h4>
<div class="paragraph">
<p>可用于 <code>IO::Handle</code> 类型的对象的 <code>path</code> 方法返回 <code>IO::Path</code> 对象，这对于处理磁盘上的物理文件很方便。<code>IO::Path</code> 类为程序员提供了一些重命名，移动或删除文件的方法。这些方法也作为内置函数存在，因此你无需获取或创建 <code>IO::Path</code> 对象来操纵磁盘上的文件。成功后，他们会返回 <code>True</code> 值。如果有错误， 可能会抛出异常。</p>
</div>
<div class="paragraph">
<p>在下表中，我们总结了操纵路径最常用的函数:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">函数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">例子</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">copy</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">复制文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">copy 'data.txt', 'data-copy.txt';</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rename</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">重命名文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">rename 'old.txt', 'new.txt';</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">move</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">移动文件(将文件复制为新文件然后删除原文件)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">move '/old/path/to/file', '/new/path/to/file';</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">unlink</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">删除文件(不像move，它不复制文件)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unlink 'secret.txt';</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">symlink</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">创建符号链接</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">symlink 'target.txt', 'existing-file.txt';</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">chmod</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">更改文件权限</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">chmod 0o755, 'prog.pl'; Notice the octal notation</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>拥有 <code>IO</code> 对象后，你可能会获得该文件的许多特征。我们来简单地看看。</p>
</div>
<div class="paragraph">
<p><code>mode</code> 方法返回路径的访问模式位。考虑一个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '/etc/passwd'.IO.mode;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码打印诸如 <code>0644</code> 之类的值。请注意，此方法返回 <code>IntStr</code> 类型的对象，到目前为止我们没有在本书中介绍过这种类型。这是一个双重值，在
字符串上下文中它包含八进制值 "0644" 的字符串表示形式，而在整数上下文它是一个整数值 420，如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '/etc/passwd'.IO.mode.Str; # 0644
say '/etc/passwd'.IO.mode.Int; # 420</code></pre>
</div>
</div>
<div class="paragraph">
<p>其他三种方法，<code>modified</code>，<code>accessed</code> 和 <code>changed</code>，返回相应路径的时间属性。返回值是 <code>Instant</code> 类型的对象。得到纪元值或 <code>Date</code> 对象，另外调用 <code>Int</code> 或 <code>Date</code> 方法，如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '/etc/passwd'.IO.modified;      # Instant:1383139040
say '/etc/passwd'.IO.modified.Int;  # 1383139040
say '/etc/passwd'.IO.modified.Date; # 2013-10-30</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用目录">9.4.5. 使用目录</h4>
<div class="paragraph">
<p><code>IO::Path</code> 类有一些处理目录的方法。我们将在这一节中讨论它们。同样，例程可以作为方法和独立子例程访问。</p>
</div>
<div class="paragraph">
<p><code>chdir</code> 函数更改当前工作目录。可以从 <code>$*CWD</code> 变量读取当前路径。该值是 <code>IO</code> 类型。要获取字符串，请使用 <code>Str</code> 方法或添加 <code>~</code> 前缀将其字符串化，如下面的代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $*CWD.Str; # /Users/ash/code, for example
chdir '/tmp';
say ~$*CWD;    # /tmp</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建和删除目录是通过 <code>mkdir</code> 和 `rmdir 例程完成的。创建目录时，可以传递可选参数以设置权限模式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">mkdir 'data';
mkdir 'data/secret', 0o400;</code></pre>
</div>
</div>
<div class="paragraph">
<p>目录为空时 <code>rmdir</code> 例程才有效。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">mkdir 'temp';
# ... do something
rmdir 'temp';</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>dir</code> 函数将目录的内容作为 <code>IO</code> 对象的列表返回。这是你列出当前的工作目录的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @dir = dir;
say $_.Str for @dir;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要指定目录的路径，请将其作为参数传递，或者在字符串上创建 <code>IO</code> 对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @root_dir = dir('/');
my @temp_dir = '/tmp'.IO.dir;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们知道如何使用文件和目录，我们移到读写数据的方法。</p>
</div>
<div class="paragraph">
<p>在下一节中，我们将讨论 <code>IO::Handle</code> 类中读写数据的方法。为简单起见，许多代码示例都使用标准输入和输出。虽然，它们将使用 <code>open</code> 函数返回的 <code>$fh</code> 文件句柄。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_从流中读取_2">9.5. 从流中读取</h3>
<div class="paragraph">
<p><code>IO::Handle</code> 类提供了许多不同的方法供我们读取流。我们已经在第二章的编写代码中的简单的输入和输出一节中看到过一些。在这里，我们将详细讨论它们并查看其他替代方案。</p>
</div>
<div class="sect3">
<h4 id="_读取一行">9.5.1. 读取一行</h4>
<div class="paragraph">
<p>我们从 <code>get</code> 方法开始，该方法从输入流中读取一行。例如，从标准输入读取一行，在 <code>$*IN</code> 实例上调用方法，如下面的例子所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = $*IN.get;
say $line;</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序等待你输入一些文本。该行完成并按下 'Enter' 键后，<code>get</code> 方法将控制返回给程序，然后将行打印到屏幕。或者，你可以使用命令行解释程序的基础设施来重定向输入流并将文件的内容传递给程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku get.pl &lt; get.pl
my $line = $*IN.get;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这次，程序打印出程序自身的第一行。</p>
</div>
<div class="paragraph">
<p>代码中的 <code>$*IN.get</code> 构造等同于 <code>get</code> 的裸调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = get;
say $line;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用文件时，请以与我们刚刚使用 <code>$*IN</code> 相同的方式打开文件句柄:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open 'data.txt', :r;
my $line = $fh.get;
say $line;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在运行此程序之前，请创建一个新文件 <code>data.txt</code> 并在其中放入一些文本。如果是文件不存在，<code>$fh</code> 句柄将被设置为 <code>Failure</code> 对象，并且 <code>get</code> 方法的以下调用会引发错误(请在第十章的使用异常中查看更多关于异常和失败的错误):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Failed to open file /Users/ash/code/data.txt: no such file or directory
  in block &lt;unit&gt; at open.pl line 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_读取字符">9.5.2. 读取字符</h4>
<div class="paragraph">
<p>要获取单个字符，请使用 <code>getc</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $ch = $*IN.getc;
say $ch;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>getc</code> 方法阻止程序执行，直到字符出现在流中。如果流中没有剩余字符，则返回空值 <code>Any</code>。在布尔值上下文中，它是假的，所以它可以用在循环条件中。让我们创建一个按字符读取其输入字符的程序，并在单独的行上打印它们。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">while my $ch = $*IN.getc {
    say $ch;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当处理 Unicode 字符时，<code>getc</code> 方法非常智能。为了展示这个行为，让我们创建一个文本文件 <code>text.txt</code>，并在其中放入一个 <code>u</code> 字符。然后， 将文件传递给程序并读取字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku getc.pl &lt; text.txt
u</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个带有 ASCII 子空间字符的单字节。现在，让我们使用另一种字符，比方说，拉脱维亚语你(u)上面有一个横线: ū。在 Unicode 中，此字符称为 <code>LATIN SMALL LETTER U WITH MACRON</code>，其码位号为 <code>0x016B</code>。在 UTF-8 编码中，该字符由两个字节组成: <code>0xC5</code> 和 <code>0xAB</code>。所以，如果你把该字符保存在文件中，它的大小将是两个字节。现在针对此文件运行程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku getc.pl &lt; text.txt
ū</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们所见，Raku 设法理解这个以两个字节表示开头单个 UTF-8 字符的文件。</p>
</div>
<div class="paragraph">
<p>现在，<code>getc</code> 的任务有点复杂。这次我们将使用该字符的分解版本。在 UTF 编码中，诸如 ū 之类的字符可以被替代地存储为两个元素的序列: 代码位为 <code>0x0075</code>(与在 ASCII 中相同)的 <code>LATIN SMALL LETTER U</code>，和 <code>COMBINING MACRON</code>(0x0304)。</p>
</div>
<div class="paragraph">
<p>我们将它保存在一个文件中。其中一种方法是使用 Raku，打印相应的字节，并将输出重定向到文件。这就是你用单行做的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku -e'print "u"; print 0x0304.chr' &gt; text.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>要打印字符而不是整数值，请调用 <code>chr</code> 方法: <code>0x0304.chr</code>。 该文件现在包含三个字节: <code>75 CC 84</code>。将其传递给我们的程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku getc.pl &lt; text.txt
ū</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序中只有一次 <code>getc</code> 调用，它会打印出正确的字符。Raku 在它看到一个有效的 ASCII 字符后不立即停止，但试图验证后面的字节是否仍然是组合字符的 Unicode 表示的一部分。</p>
</div>
<div class="paragraph">
<p>现在，我们让这项工作变得更加复杂，并构建一个不存在的字符， 假设 u 上面有一个双重波浪号，下面是一个“逗号”。此字符在 Unicode 中没有代码点，但它仍然可以用三个元素构造 - <code>COMBINING ALMOST EQUAL TO ABOVE (0x034C)</code> 和 <code>COMBINING CEDILLA (0x0327)</code>。准备文本文件:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku -e'print "u"; print 0x034C.chr; print 0x0327.chr' &gt; text.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>这三个元素现在位于 UTF-8 编码-<code>75 CD 8C CC A7</code> 中的五个字节中。仍然，Raku 将其作为单个字符读取，因为你可以再次通过运行程序来验证:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku getc.pl &lt; text.txt
u̧͌</code></pre>
</div>
</div>
<div class="paragraph">
<p>要一次读取多个字符，请使用 <code>readchars</code> 方法。它的工作原理类似于 <code>getc</code> 方法但返回一个包含字符的字符串。要读取的最大字符数作为参数传递:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = $*IN.readchars(12); # read 12 characters from standard input
say $str;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，要重现本节中的示例，你需要一个支持的 Unicode 的终端。</p>
</div>
</div>
<div class="sect3">
<h4 id="_惰性读取">9.5.3. 惰性读取</h4>
<div class="paragraph">
<p><code>IO::Handle</code> 类定义了一些惰性读取的方法。这里的惰性意味着，当程序确实需要另一部分时，Raku 才实际执行读取数据。所以它不应该立即读取整个文件。</p>
</div>
<div class="paragraph">
<p><code>lines</code> 方法返回一个行列表。这是一个把输入复制为输出的短程序的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for lines;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可以使用更传统的语法以不同的形式重写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $*IN.lines -&gt; $line {
    say $line;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$*IN.lines</code> 的调用返回一个输入行的数组。我们可以直接将它保存在变量中，并用于打印:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @lines = $*IN.lines;
.say for @lines;</code></pre>
</div>
</div>
<div class="paragraph">
<p>重要的是 <code>lines</code> 方法删除末尾的换行符。因此，如果你需要重现它，请使用 <code>say</code> 函数在输出的结尾打印换行。</p>
</div>
<div class="paragraph">
<p><code>lines</code> 方法接受一个整数参数来指示要读取的最大行数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for $*IN.lines(3); # prints the first 3 lines from input</code></pre>
</div>
</div>
<div class="paragraph">
<p>从输入流中读取逻辑数据的另一种方法是使用 <code>words</code> 方法。它类似于前面描述的 <code>lines</code> 方法，但是将输入拆分为单词而不是行。分隔符是一系列空格。考虑一个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for $*IN.words;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序在单独的行上打印输入中的每个单词。</p>
</div>
<div class="paragraph">
<p><code>split</code> 方法概括了一种读取逻辑元素的方法，并允许我们指定一个用于分隔元素的拆分器。例如，下面这段代码教你如何用冒号分隔输入:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for $*IN.split(':');</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，例如，从 <code>/etc/passwd</code> 文件提供一行，程序会将它的各个部分打印出来:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ cat /etc/passwd | grep nobody | raku split.pl
nobody
*
-2
-2
Unprivileged User
/var/empty
/usr/bin/false</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>comb</code> 方法返回它在输入流中找到的所有匹配项的列表。对于匹配，使用正则表达式。我们将在第十一章的正则表达式一节中讨论正则，但这是一个从输入中提取所有数字的简单示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @numbers = $*IN.comb(/\d+/);
say @numbers.join(', ');</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下输入演示了此程序的工作原理。输入文本后，程序打印它找到的以逗号分隔的整数列表。粗体的行是你的输入:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku comb.pl
There are 3 points in a triangle, 4 points in a square,
and 5 points in a star.
3, 4, 5</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_eof_方法">9.5.4. eof 方法</h4>
<div class="paragraph">
<p>只有当数据存在时，才能从文件中读取数据。检查文件或流是否仍然包含数据，请使用 <code>eof</code> 方法，当到达文件结尾时返回 <code>False</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open 'data.txt';
if $fh &amp;&amp; !$fh.eof { # Only if file exists and has something to read
    my $line = $fh.get;
    say $line;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_写入流">9.6. 写入流</h3>
<div class="paragraph">
<p>在本节中，我们将研究 <code>IO::Handle</code> 类为写入流提供的方法。</p>
</div>
<div class="sect3">
<h4 id="_print_函数">9.6.1. print 函数</h4>
<div class="paragraph">
<p>我们将从简单的 <code>print</code> 函数开始。基本上，它的用法很明显。它把文本打印到流。在标准输出的情况下，使用裸的 <code>print</code> 函数或 <code>$*IN.print</code> 方法。如果使用文件，请使用其文件句柄。</p>
</div>
<div class="paragraph">
<p>以下程序创建一个名为 <code>hello.txt</code> 的文件，并写入字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open 'hello.txt', :w; # Open a file for writing
$fh.print('Hello, World');     # Print to the file
$fh.close;                     # Close the file so that the data is saved</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果文件已存在，则将重写该文件，之前的所有内容都将丢失。如果需要将新输出附加到现有文件，则使用 <code>:a</code> 追加模式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open 'hello.txt', :a; # Open in append mode
$fh.print('!');                # Now the file contains 'Hello, World!'
$fh.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>close</code> 方法关闭文件。实际上，不需要手动关闭文件，因为一旦文件句柄超出其作用域，Raku 将立即关闭该文件。</p>
</div>
<div class="paragraph">
<p><code>open</code> 函数的 <code>:enc</code> 命名参数设置文件的编码。考虑一下以下代码。它打开两个文件并打印相同的字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = 'ä';

my $fh1 = open 'enc-latin1.txt', :w, enc =&gt; 'Latin1';
$fh1.print($str);
$fh1.close;

my $fh2 = open 'enc-utf-8.txt', :w, enc =&gt; 'UTF-8';
$fh2.print($str);
$fh2.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，查看该程序创建的文件的文件大小:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ ls -la enc-*.txt
-rw-r--r-- 1 ash ash 1 Mar 16 07:59 enc-latin1.txt
-rw-r--r-- 1 ash ash 2 Mar 16 07:59 enc-utf-8.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如所料，其中一个文件是用 Latin-1 编码编写的。ä 字符很适合这种编码，所以文件内容是一个带有字符代码的单字节:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ hexdump enc-latin1.txt
0000000 e4
0000001</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二个文件使用 UTF-8 编码，同一个字符需要两个字节:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ hexdump enc-utf-8.txt
0000000 c3 a4
0000002</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，两种编码都能够表示写入到文件的字符。如果所选编码不支持，则会发生运行时错误。在下一个程序中，我们尝试将 Unicode 笑脸以 Latin-1 编码写入打开的文件中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open 'smiley.txt', :w, :enc('Latin1');
$fh.print(0x263a.chr); # The WHITE SMILING FACE character
$fh.close;
say 'OK?';</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序在尝试写入文件时退出，而程序的其余部分则不会执行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Error encoding Latin-1 string: could not encode codepoint 9786
  in block &lt;unit&gt; at enc2.pl line 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在之前的程序中，使用了两种不同的语法选项来为函数的命名参数传递值-<code>enc &#8658; 'UTF-8'</code> 和 <code>:enc('Latin1')</code>。 两种形式都是等同的; 你可以选择你喜欢的那个。</p>
</div>
</div>
<div class="sect3">
<h4 id="_say_方法">9.6.2. say 方法</h4>
<div class="paragraph">
<p>乍一看，<code>say</code> 方法与 <code>print</code> 方法类似，并在末尾添加一个换行符。但这不是全部的真相。在内部，<code>say</code> 在对象上调用 <code>gist</code> 方法以获得它的文本表示。</p>
</div>
<div class="paragraph">
<p>对于字符串和整数等数据类型，它们的文本形式很简单。在下面的例子中，<code>print</code> 和 <code>say</code> 的输出没有区别:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = 'String';
print $str, "\n";
say $str;

my $int = 42;
print $int, "\n";
say $int;</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于更复杂的数据结构，这两种方法的行为是不同的。该程序的输出显示在注释中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array = &lt;10 20 30&gt;;
print @array, "\n"; # 10 20 30
say @array;         # [10 20 30]

my %hash = alpha =&gt; 1, beta =&gt; 2, gamma =&gt; 3;
print %hash, "\n";  # alpha   1
                    # beta 2
                    # gamma   3
say %hash;          # {alpha =&gt; 1, beta =&gt; 2, gamma =&gt; 3}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用_gist_方法的示例">9.6.3. 使用 gist 方法的示例</h4>
<div class="paragraph">
<p>对于用户定义的类，可以创建一个准备按预期输出的 <code>gist</code> 方法。让我们在下面的例子中尝试这个。</p>
</div>
<div class="paragraph">
<p>我们创建了一个用于存储化学公式的类。目标是允许以纯 ASCII 格式制造化学公式，然后打印它，以使数字索引显示为下标。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Chemical {
    has $.formula;
    method gist {
        my $output = $!formula;
        $output ~~ s:g/(&lt;[0..9]&gt;)/{(0x2080+$0).chr}/;
        $output;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Chemical</code> 类有一个数据成员 <code>$.formula</code>，它将原始 ASCII 公式保留为字符串。<code>gist</code> 方法将其转换为带有下标的字符串。我们用正则表达式做替换。正则表达式在第十一章的正则表达式一节中有详细介绍。现在，只需知道以下代码行将从 0 到 9 的数字替换为其下标版本就足够了。要获取下标数字的代码值，用公式中数字值加上 <code>SUBSCRIPT ZERO</code> Unicode 字符的代码点值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$output ~~ s:g/(&lt;[0..9]&gt;)/{(0x2080+$0).chr}/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，是时候使用这个类了。在循环中，创建了几个实例来测试不同的情况: 简单的公式，带括号的公式和带两位数字索引的公式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt; H2O Al2(SO4)3 Al6O13Si2 &gt; {
    my $chem = Chemical.new(formula =&gt; $_);
    say $chem;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序给出以下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你使用 <code>print</code> 函数而不是 <code>say</code>，那么输出将是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Chemical<i class="conum" data-value="140226845929544"></i><b>(140226845929544)</b>
Chemical<i class="conum" data-value="140226845929664"></i><b>(140226845929664)</b>
Chemical<i class="conum" data-value="140226845929704"></i><b>(140226845929704)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>此输出包含类的名称和内存中变量位置的地址。要使输出对最终用户更有用，请为其类定义 <code>gist</code> 方法并使用 <code>say</code> 函数来 'print' 对象。</p>
</div>
</div>
<div class="sect3">
<h4 id="_printf_方法">9.6.4. printf 方法</h4>
<div class="paragraph">
<p><code>printf</code> 方法以给定格式打印值。它大部分都与来自 C 和 C++ 标准库的 <code>printf</code> 函数相同。这个方法的第一个参数是描述格式的字符串，其余参数是将要替换为指令的值
，从格式字符串中的 <code>%</code> 字符开始。</p>
</div>
<div class="paragraph">
<p>在许多情况下，可以通过字符串插值来实现格式化。例如，以下两行产生相同的输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $temperature = 25.6;
printf("Temperature is %g °C\n", $temperature);
say "Temperature is $temperature °C";</code></pre>
</div>
</div>
<div class="paragraph">
<p>在下表中，列出了主要的格式化指令。</p>
</div>
</div>
<div class="sect3">
<h4 id="_字符和字符串">9.6.5. 字符和字符串</h4>
<div class="paragraph">
<p>我们从打印文本数据开始:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">指令</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%%</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">% 字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%c</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个 字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个字符串</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>下面是一些上述表格中的指令的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">printf "The percent sign: %%\n";
printf "Character %c\n", 167;
printf "String %s\n", 'Hello, World';</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序打印如下行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The percent sign: %
Character §
String Hello, World</pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>%c</code> 指令把对应的参数当作字符, 而不是当作整数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_整数">9.6.6. 整数</h4>
<div class="paragraph">
<p>有几个用于以不同格式打印整数的不同指令:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">指令</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">二进制表示的整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%d 或 %i</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">有符号十进制整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%u</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无符号十进制整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%o</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">八进制格式的整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">十六进制格式的无符号整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与 %x 相同但是以大写字母表示</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>让我们以不同的格式打印相同的数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">printf "Binary: %b, decimal: %d, octal: %o\n", 10, 10, 10;
printf "Hexadecimal: %x, uppercased: %X\n", 10, 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序的输出看起来像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Binary: 1010, decimal: 10, octal: 12
Hexadecimal: a, uppercased: A</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>%u</code> 指令需要一个无符号整数，因此如果看到一个负数，编译器则会引发错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">$ raku -e'printf "%u", -10'
negative value '-10' for %u in sprintf
Directive u not applicable for type Int</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_浮点数字">9.6.7. 浮点数字</h4>
<div class="paragraph">
<p>对于浮点数，请使用以下格式之一:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">指令</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%e</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">以科学计数法表示的浮点数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">和 %e 相同但是大写字母 E 表示指数部分</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%f</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个浮点数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%g</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">%e 或 %f(以较好者为准)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在以下示例中，<code>pi</code> 的值以不同的格式打印:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">printf "%e, %E\n", pi, pi;
printf "%f, %g\n", pi, pi;</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果是这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">3.141593e+00, 3.141593E+00
3.141593, 3.14159</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>%g</code> 格式是最“人性化”的 - 它显示精度有限的浮点数，切换到非常大和非常小的科学记数法数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">printf "%g\n", 0.000001; # 1e-06
printf "%g\n", 0.1;      # 0.1
printf "%g\n", 1;        # 1
printf "%g\n", 10;       # 10
printf "%g\n", 10000000; # 1e+07</code></pre>
</div>
</div>
<div class="paragraph">
<p>格式化字符串后传递的参数数量必须与其指令的数量一致 。否则会发生 <code>X::Str::Sprintf::Directives::BadType</code> 异常:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku -e'printf "%c", 1, 2'
Your printf-style directives specify 1 argument, but 2 arguments were
supplied</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关格式化字符串的详细说明，请参阅以下文档页面的内容: docs.raku.org/type/Str#sub_sprintf。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_11">9.7. 总结</h3>
<div class="paragraph">
<p>在本章中，我们讨论了 Raku 中提供的输入和输出功能。 <code>IO::Handle</code> 类提供了使用标准输入和输出流的通用方法以及使用相同接口的文件。我们讨论了如何创建文件和
如何测试文件和目录的不同属性并检查各种读写方法。</p>
</div>
<div class="paragraph">
<p>处理文件时，你有时可能会遇到异常情况; 我们已经在本章中看到了一些例子。在下一章中，我们将详细地讨论 Raku 中的异常。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_异常">10. 异常</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在前两章中，我们讨论了面向对象的编程和关于 输入和输出，使用对象实现。在本章中，我们将继续努力 与对象和将讨论Raku中的另一个领域，其实现广泛使用 类和具有庞大的层次结构。</p>
</div>
<div class="paragraph">
<p>例外情况是程序进入无法进一步运行的状态。 一些例外是由程序设计中的缺陷引起的，其他例外是​​由于
外部因素，例如磁盘故障或与数据库的连接断开。在这种情况下，一个
异常并不是一种非常特殊的东西，它必须停止程序，而是一种处理方式
错误并继续执行。
在本章中，我们将讨论程序可能面临的异常情况。
此外，我们还将看到程序员可以预防后果的方法
特殊时刻。
本章将介绍以下主题:
试块 使用CATCH阶段块捕获异常 异常类
投掷和重新抛出异常 Failure类和软故障 使用类型化异常 创建自定义例外</p>
</div>
<div class="sect2">
<h3 id="_try_块">10.1. try 块</h3>

</div>
<div class="sect2">
<h3 id="_catch_phaser">10.2. CATCH phaser</h3>

</div>
<div class="sect2">
<h3 id="_exception_对象">10.3. Exception 对象</h3>

</div>
<div class="sect2">
<h3 id="_failure_对象">10.4. Failure 对象</h3>

</div>
<div class="sect2">
<h3 id="_创建自定义异常">10.5. 创建自定义异常</h3>

</div>
<div class="sect2">
<h3 id="_总结_12">10.6. 总结</h3>
<div class="paragraph">
<p>试块
让我们从一个最简单的例外开始，除以零。运行以下一项 - 衬垫:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序中断并打印以下错误消息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们不能除以零。请注意，错误消息还包含堆栈跟踪
程序。由于我们不使用任何模块或具有任何函数调用，因此堆栈跟踪很短。
现在，让我们在除法之前和之后做一些其他操作，这会失败:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于零除零的异常在运行时发生。所以，程序执行
第一行并打印第一条消息。然后，发生异常和程序
终止。将不会执行任何其他操作，并且永远不会到达最后一行。</p>
</div>
<div class="paragraph">
<p>现在让我们通过从外部输入值来更改内置值。让用户输入
划分的数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你运行这个程序，它将要求两个数字并打印他们的部门的结果。
尝试使用一些非零值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用例外 现在尝试输入零作为除数。马上，你得到一个异常:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>此行为可能不是该计划最期望的结果。我们应该做到
程序更稳定，因此它不依赖于来自外部的错误数字。
在Raku中，代码中有问题的部分可以放在try块中。在我们的例子中， 这部分代码是除法操作的行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们将其与打印结果的行一起放在try块中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，我们在此程序中的try块之后有一些代码。 使用与以前相同的输入值运行它。首先，非零数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>完成。
该程序的行为与引入try块之前的行为完全相同。 现在，尝试零:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>而已。这里有三件事需要注意。首先，我们没有看到有关的错误消息 非法分裂。二，字符串&#8230;&#8203;&#8230;&#8203;的结果不打印。三，代码 在执行块之后执行并打印。</p>
</div>
<div class="paragraph">
<p>这里发生了什么?在try块内部，异常发生，但事实并非如此 停止执行程序。try块隐藏了我们的例外事实。的 当然，我们输掉了结果，但我们保留了继续使用的能力 程序。</p>
</div>
<div class="paragraph">
<p>$!变量</p>
</div>
<div class="paragraph">
<p>现在让我们看看如果发生了错误，我们怎么能理解。在Raku中，有 一个特殊的变量$!，称为错误变量。如果它发生，它包含一个例外。让 我们用它来检查一切是否正常:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果$!我们添加了测试。它对待$!布尔上下文中的变量。实际上，价值 存在异常时变量的值是Exception类型的值。我们会看到 它将在本章后面的The Exception对象部分中介绍。现在，知道这一点就足够了 在布尔上下文中，Exception给出True值。如果没有例外，那就是
$!变量将包含Any类型的对象，在布尔上下文中为False。
如果你运行更新的程序并传递零作为除数，程序将打印出
失败!信息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>软故障</p>
</div>
<div class="paragraph">
<p>在前面的示例中，try块包含两个数学计算的指令 并打印结果。在实际程序中，这些操作通常是分开的。让我们重新写一下 程序，以便它将数字分成一个单独的子程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在危险的动作发生在calculate函数内部并且使用了结果
在它之外。
使用应导致异常的值运行程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>仔细检查输出。在异常消息之前，行就绪了
打印出现在屏幕上。在打印时，已经进行了计算
完成后，非法分区已经发生，但该计划仍然存在
仅在结果即将打印时失败。
发生这种情况是因为Raku允许轻柔失败。一个软故障是unthrown例外。 除法的结果仅用于打印$ c值的行。在那之前， 什么都没有停止程序，它打印消息，好像没有发生错误。</p>
</div>
<div class="paragraph">
<p>理解软故障会导致我们得出以下结论。如果你使用try块来 防止程序终止，你应该把它放在那里的地方 即将使用不可能的结果(例如使用say函数)。下列 修改将完成工作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>围绕分区本身是不够的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，尝试块后，$!变量包含Any对象，因为失败没有 发生了。
CATCH移相器 在本章的前面，我们使用try块来捕获异常。如果发生异常
在try块内，它设置$!变量，您可以稍后检查。
在Raku中，这不是处理异常的唯一方法。让我们回到上一个
程序，但这次我们将使用CATCH块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>运行程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>抓住了异常! 尝试使用div将10除以零</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦除零发生并使用其结果，就会触发CATCH块。 CATCH块是Raku中的一个相位器，我们在第2章中讨论过它， 写作 码。当发生异常时，编译器将执行传递给此块，而没有人 到目前为止已经处理过了。
再次注意，异常不是在除零的时刻发生的，而是在
结果将打印到控制台。
如果我们将有问题的代码放在try块中，则不会按原样运行CATCH块 在我们的程序的以下变体中看到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在该程序中，来自CATCH块的消息和异常消息都不会 打印。try块隐藏了异常并设置了$!变量。CATCH块是 没有启动，因为已经处理了异常。
到目前为止，我们已经介绍了处理异常的基本方法。现在是时候潜水了 更深入一点，看看Raku如何使用Exception类实际操作异常。
异常对象
Raku中的异常是通过派生自的类的对象来处理的 异常类。这些对象包含有关的所有必要信息
异常，包括一些文本描述和堆栈跟踪(在Raku中，它被称为回溯)。</p>
</div>
<div class="paragraph">
<p>当出现异常时，Raku会创建一个异常对象。我们已经看到了一个例子 本章前面的这种情况 - 在尝试打印时错误变得明显 非法数学运算的结果。现在，让我们自己制作一个例外</p>
</div>
<div class="paragraph">
<p>使用die关键字。
die关键字抛出致命异常并终止程序。典型的用法是 如果程序无法打开文件或加载对其余部分至关重要的资源，请停止该程序 程序，例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有这样的文件，则布尔上下文中的$ fh变量为false，第二个分支
将执行或运算符。
die函数接受文本消息。考虑一个示例，其中调用die 无条件的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个简短的程序打印如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，它可以正常工作，直到异常发生并在它之后停止工作。模具功能
获取与回溯信息一起打印的文本消息。这是个
程序员如何生成自己的错误消息的示例。提供错误
有良好的描述有助于理解出错的原因。
要处理此异常，请使用try或CATCH块。try块抑制了 错误消息，但允许程序继续:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用例外 使用CATCH块，我们捕获异常，但程序终止:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>该计划的输出如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>开始 抓住 错误信息</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是我们之前看到的，但这里涉及的内容还有很多，我们将会这样做检查他们。</p>
</div>
<div class="paragraph">
<p>进入CATCH块时，Raku将异常对象放入默认变量 <code>$_</code>。 用它来分析原因并做出相应的反应。让我们打印一些调试 信息，以便我们看到$ _和$发生了什么!变量。在下面的 代码，^ name方法返回变量类的名称:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>该计划的结果揭示了一些有趣的细节:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>$_</code> 中的对象是X </dt>
<dd>
<p>AdHoc类的一个实例。特殊例外是一个例子 从Exception类派生的类型。Raku创建了这样一个对象来响应 召唤死亡。惯例使用X ::名称空间作为异常类。
然后，当我们通过将$ _变量传递给say函数来打印它时，实际的错误 消息打印:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意$的事实!变量为空 - 它包含Nil值。 最后，编译器从CATCH块打印消息，打印错误消息
连同回溯信息，并终止程序。
抛出异常
现在我们可以开始检查异常对象了。Exception基类定义了 throw方法，可用于抛出异常。为简单起见，让我们开始吧
X :: AdHoc例外。 在以下程序中，使用新方法显式创建异常
立即抛出throw方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序的输出对我们来说很熟悉:
开始
抓住 原因不明的错误</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们没有提供任何错误消息，程序打印默认值
string-Unexplained错误。 要使用消息，请在创建异常对象时使用有效负载命名参数:
X :: AdHoc.new(payload &#8658;'我的错误消息')。throw;
从例外中恢复
如我们所见，CATCH块停止执行程序。这并非总是如此 最佳策略。在Raku中，异常对象(类型派生自的对象)
异常类)可以将控制权返回给发生错误的代码中的位置。
为此，请在异常对象上调用resume方法，如下所示 例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.resume</code> 行调用默认变量$ _上的方法。它相当于一个明确的
叫$ _。resume。 这一次，程序不会退出，而是在异常后继续工作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，将不会打印错误消息，类似于它与try一起使用的方式 块。例如，从不存在的文件恢复读取没有意义。在 另一方面，当进行一系列计算时，即使其中一个计算也可能有用 他们除以零。
键入的例外</p>
</div>
<div class="paragraph">
<p>在Raku中预定义的X ::名称空间中还有更多类。要查看完整列表 内置异常，请访问以下页面 - docs.raku.org/type-exceptions.html。您 可以为您的特定异常创建自己的类。我们先来看看如何 区分CATCH块中不同类型的异常。
让我们创建一个程序，尝试将当前工作目录更改为不存在 一。在Raku中，您可以使用chdir函数来更改目录:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出显示以下错误消息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，让我们通过调用$ _变量上的^ name方法来查看异常的类型
在CATCH块内:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>它将告诉我们 <code>$_</code> 变量包含 <code>X::IO::Chdir</code> 类的对象。
现在，让我们利用这些知识做出不同的行动以应对不同的例外
案例。让我们构建程序，首先更改目录，然后抛出一个
临时例外。
要分隔不同异常的路径，我们将使用when关键字 匹配给定类型的$ _变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>运行此程序并确认两个异常都被正确捕获:
不存在的目录 临时例外</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在CATCH块中，有两个分支，每个异常类型一个，我们想要的 处理。重要的是要意识到，在找到并执行了when块之后，
CATCH块返回控制并忽略该点之后的所有代码。这就是为什么 恢复方法放在块中。如果你把它放在整个CATCH的末尾
阻止，只有在其他类型的异常发生且没有异常时才会到达该代码
什么时候块满意。
重新抛出异常
有时，异常处理程序无法处理异常。在这种情况下，它 可以通过调用rethrow方法再次抛出它。该异常将被捕获 默认异常处理程序
请考虑以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，尝试打印后捕获 <code>X::Numeric::DivideByZero</code> 异常 除法的结果为1 / 0.然后重新抛出异常，Raku打印出 适当的错误消息并终止程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>Failure对象 让我们创建一个程序，尝试打开一个不存在的文件并从中读取第一行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序将引发异常:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，只有在尝试读取文件后才会发生异常。只是
打开文件不会产生错误，它只将$ f文件处理程序设置为Failure对象。 失败对象是Exception对象的包装器。例外本身就是
可通过异常方法访问:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在布尔上下文中测试失败对象，例如，在打开后立即测试
一份文件:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>要查看是否已处理故障，请使用已处理的方法。在以下示例中， 这个方法被调用两次 - 在try块之前和之后围绕着引发的方法 例外:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦程序流离开try块，异常的状态就会变为
处理。
创建自定义例外
在前面的部分中，我们已经看到Raku中的异常使用面向对象 方法，特别是有助于区分不同的例外
CATCH块。
在本节中，我们将创建一个集成到Raku系统中的自定义异常
像X ::名称空间中的任何其他内置类一样顺利。如果你没有任何特别之处 要求，在同一名称空间中创建自定义异常类。
例如，让我们与X :: Lift :: Overload异常一起创建Lift类， 当太多人进入电梯时会触发:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们不需要Lift类之外的异常类，因此最好限制范围 并在主类中定义异常。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">X </dt>
<dd>
<p>Lift :: Overload类扩展了Exception类，并且必须至少提供
message方法，以便异常处理程序可以打印错误消息。
在List类中，有两个数据成员，$ .capacity和$!people，用于保存 电梯的默认容量和实际人数。enter方法增加了 编号并检查是否已达到容量。如果有更多的人进来，一个 抛出异常。
现在，让我们创建一个Lift类的实例，让一些人进入电梯:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">第三次进入后，将有五个人在电梯中，最大容量为 四强。因此，引发X </dt>
<dd>
<p>Lift :: Overload异常并且程序退出 以下错误消息:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_13">10.7. 总结</h3>
<div class="paragraph">
<p>在本章中，我们学习了如何在Raku中处理异常。我们详细研究过 通过使用不同的机制来抛出，捕获和隐藏异常的方法 语言尝试块和CATCH移相器。我们谈到了软故障 推迟的异常只有在真的不可避免时才被抛出。我们也是 演示了如何使用面向对象的方法来处理不同的异常 类型以及如何创建自定义异常。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_正则表达式">11. 正则表达式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>正则表达式是 Perl 最有价值的功能之一。在 Raku 中, 正则表达式经过重新设计, 使它们更加规则和强大。这个词也变了, 正则表达式现在更多地被简称为<strong>正则</strong>。在这一章当中,  我们将介绍正则表达式语法的所有元素。</p>
</div>
<div class="paragraph">
<p>本章将介绍以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>与正则表达式匹配</p>
</li>
<li>
<p>字面量</p>
</li>
<li>
<p>字符类</p>
</li>
<li>
<p>量词</p>
</li>
<li>
<p>锚</p>
</li>
<li>
<p>备选</p>
</li>
<li>
<p>分组</p>
</li>
<li>
<p>捕获和命名捕获</p>
</li>
<li>
<p>命名正则表达式</p>
</li>
<li>
<p>Match 对象</p>
</li>
<li>
<p>断言</p>
</li>
<li>
<p>副词</p>
</li>
<li>
<p>替换</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_与正则表达式匹配">11.1. 与正则表达式匹配</h3>
<div class="paragraph">
<p>正则表达式描述文本模式。他们为我们提供了一种语言, 我们可以在其中表达文本的结构。</p>
</div>
<div class="paragraph">
<p>考虑一个例子。电话号码是一系列数字。短语 <strong>sequence of digits</strong> 可以写成 <code>\d+</code>。如果我们考虑到电话号码可能用空格和短划线写的事实, 那么我们不得不说电话号码是用空格或破折号分隔的数字序列。这已经是一个更复杂的正则表达式了, 根据我们的严格程度, 可以用不同的方式编写, 例如, 如果我们允许两个空格在一起或者如果一个短划线可以跟一个空格, 或者一组数字可以由一个数字组成的话。</p>
</div>
<div class="paragraph">
<p>让我们从最不严格开始, 并将其形式化为 <code>(\d || \s || \-)+</code>, 即多个数字(<code>\d</code>)或空格(<code>\s</code>)或短划线(<code>\-</code>)。双垂直条在这里代表"<strong>或</strong>", <code>+</code> 意味着<strong>不止一个</strong>。最后, 国际电话号码可以带有一个前缀 <code>+</code> 号字符, 这是可选的。那么, 我们的最终电话号码正则表达式是 <code>+? (\d || \s || \-)+</code>。</p>
</div>
<div class="paragraph">
<p>这个正则表达式并不完美。在本章的后面部分, 我们将努力使其变得更好, 更强大。但是, 让我们从那个正则开始, 并进行第一次<strong>匹配</strong>。字符串与正则表达式相比较在 Perl 中称为匹配。为了匹配正则表达式, 使用双波浪形运算符。正则表达式本身放在一对斜杠中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'OK' if '+31 645-23-10' ~~ /\+? (\d || \s || \-)+/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此程序打印 OK, 这意味着带有电话号码的字符串匹配该正则表达式。让我们尝试一些文本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'OK' if 'phone' ~~ /\+? (\d || \s || \-)+/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个字符串中, 没有正则表达式需要的任何字符, 程序什么也没有打印。此正则表达式不匹配。</p>
</div>
<div class="paragraph">
<p>字符串和正则表达式都可以放在变量中, 它们会彼此匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $phone = '+31 645-23-10';
my $re = /\+? (\d || \s || \-)+/;
say 'OK' if $phone ~~ $re;</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了 <code>/ &#8230;&#8203; /</code> 之外, 正则表达式可以使用其他围绕的符号。如果正则表达式包含许多斜杠, 例如用于解析 URL 的正则表达式, 这可能是有用的。在这种情况下, 你需要在正则表达式之前加上 <code>m</code> 或 <code>rx</code> 前缀。以下所有例子是等价的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> / \d+ /
m/ \d+ /
m{ \d+ }
m| \d+ |</code></pre>
</div>
</div>
<div class="paragraph">
<p>要创建将放入变量的正则表达式, 请使用 <code>rx</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $phone = '+31 65 253-45-93';
my $re = rx/\+? (\d || \s || \-)+/;
say 'OK' if $phone ~~ $re;</code></pre>
</div>
</div>
<div class="paragraph">
<p>分隔符可以是不同的, 例如, 一对花括号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $re = rx{\+? (\d || \s || \-)+};</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>m</code> 或 <code>rx</code> 创建直接在匹配中使用的正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Not OK' unless 'phone' ~~ m/\+? (\d || \s || \-)+/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了否定匹配的结果, Raku 提供了一个不同的运算符, <code>!~~</code>。选择使整个结构更容易理解的那个。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Not OK' if 'phone' !~~ rx/\+? (\d || \s || \-)+/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>从前两个例子可以看出, <code>unless</code> 和 <code>~~</code> 的组合相当于 <code>if</code> 和 <code>!~~</code>。</p>
</div>
<div class="paragraph">
<p>现在, 因为我们知道如何匹配字符串与正则表达式, 并制作我们的第一个正则表达式, 让我们详细了解一下正则表达式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_字面量">11.2. 字面量</h3>
<div class="paragraph">
<p>正则表达式的语法是 Raku 中的一种小语言。因为有很多东西需要表达,  它使用某些字符来表达意思。字母, 数字和下划线代表它们自身, 没有任何特殊意义。这些字符可以按原样使用, 如下面的示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = 'John';
say 'OK' if $name ~~ /John/; # OK

my $id = 534;
say 'OK' if $id ~~ /534/; # OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果正则表达式中的字符串包含其他字符, 例如空格, 则应该小心它们。其中一种可能性是引用整个字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = 'Smith Jr.' ;
say 'Junior' if $last-name ~~ /' Jr'/; # Junior</code></pre>
</div>
</div>
<div class="paragraph">
<p>正则表达式中的文字字符串 <code>' Jr'</code> 包含一个必须存在于变量 <code>$name</code> 中的空格。</p>
</div>
<div class="paragraph">
<p>另一种方法是使用特殊字符, 前缀为反斜杠。使用 <code>\s</code> 匹配空格:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = 'Smith Jr.' ;
say 'Junior' if $name ~~ /\sJr/; # Junior</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下, Raku 的正则表达式中的空格被忽略。这个事实可以被利用来添加一些<strong>空气</strong>到正则表达式中。比较我们之前使用的没有空格的正则表达式和与之等价的为清晰起见使用空格的正则表达式:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">原始正则表达式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">带空格的正则表达式</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/John/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ John /</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/' Jr'/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ 'Jr' /</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/\sJr/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ \s Jr /</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/\+?(\d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\s</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\-)+/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ \+? (\d</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\-)+ /</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_字符类">11.3. 字符类</h3>
<div class="paragraph">
<p>正则表达式中的字符类是一个特殊的序列, 它匹配某些给定集合中的字符。例如, 在上一节中, 我们已经使用了一个字符类 <code>\s</code>, 它匹配 ASCII 空格以及其他一些空白字符, 例如制表符。让我们探索Raku 的正则表达式中的字符类。</p>
</div>
<div class="sect3">
<h4 id="_点字符">11.3.1. .(点)字符</h4>
<div class="paragraph">
<p>一个非常简单的字符, 只有一个点, 可以匹配字符串中的任何字符。当你不关心两个部分之间的某些特征时经常使用它。例如, 以下代码将匹配 <code>a</code> 和 <code>d</code> 之间具有任意两个字符的字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'OK' if 'abcd' ~~ / a . . d /; # OK
say 'OK' if 'aefd' ~~ / a . . d /; # OK
say 'OK' if 'a*^d' ~~ / a . . d /; # OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前两个示例中, 每个点都匹配其中一个字母。在第三个示例中, 两个点都匹配一个特殊字符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_反斜线字符类">11.3.2. 反斜线字符类</h4>
<div class="paragraph">
<p>有一组预定义的字符类, 以反斜杠开头, 后跟一个小写或大写的字母。大写版本与其小写版本语义相反, 其否定字符集匹配的字符集。下表包含反斜线字符类的概述:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">否定</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\S</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空白</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\t</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">制表</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\h</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\H</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">水平空白</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\v</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\V</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">垂直空白</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\n</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">换行</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数字</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\W</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单词字符</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>现在我们将详细测试所有字符类。</p>
</div>
</div>
<div class="sect3">
<h4 id="_s_和_s_字符">11.3.3. \s 和 \S 字符</h4>
<div class="paragraph">
<p>我们已经看到这个字符类的一个示例-用于匹配空格字符。它的大写对应, <code>\S</code>, 意义相反 - 它与除空格之外的任何字符匹配。 我们来看一个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = 'Hello, World!';
say 'OK' if $str ~~ / \s World /; # OK
say 'OK' if $str ~~ / Hello\S /;  # OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>两个正则表达式都匹配。第一个正则中的 <code>\s</code> 与单词之间的空格匹配。第二个示例中的 <code>\S</code> 与逗号匹配。</p>
</div>
<div class="paragraph">
<p>字符类 <code>\s</code> 是其它空格字符类的组合 - <code>\h</code> 和 <code>\v</code>,  这些将在以下部分中介绍。这些字符类还包括单独的诸如 <code>\t</code> (水平制表符, 0x09)或 <code>\r</code> (换行, 0x0A)等字符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_t_和_t_字符">11.3.4. \t 和 \T 字符</h4>
<div class="paragraph">
<p><code>\t</code> 和 <code>\T</code> 分别与制表符和非制表符匹配。想象一下你有一行制表符分隔的数据, 你想把它放到一个数组中。以下代码会为你做到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $data = "John\tSmith\t1970";
my @data = $data.split(/\t/);

print qq:to/OUT/
Name          = @data[0]
Last name     = @data[1]
Year of birth = @data[2]
OUT</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, 我们在 <code>$data</code> 字符串上调用 <code>split</code> 方法并将其传递给包含单个 <code>\t</code> 字符类的正则表达式, 这应该与制表符匹配。因此, 它将源数据行拆分成三部分并将它们放入 <code>@data</code> 数组中。</p>
</div>
<div class="paragraph">
<p><code>qq:to/OUT/</code> 结构是 heredoc 的开始, 它在第二次出现的标签 <code>OUT</code> 处结束。双 <code>qq</code> 需要在 heredoc 内部进行变量插值。 这种方法可以更容易地准备模板以输出所需的数据布局:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">$ raku name-split.pl
Name          = John
Last name     = Smith
Year of birth = 1970</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_h_和_h_字符">11.3.5. \h 和 \H 字符</h4>
<div class="paragraph">
<p>这些字符类的小写版本与水平空格匹配(并且, 大写版本分别否定匹配结果)。</p>
</div>
<div class="paragraph">
<p>在常见的空格和制表字符中, 还有许多其他的水平空格, 例如, 在 HTML 中被标记为 <code>&nbsp;</code> 的不换行空格。</p>
</div>
<div class="paragraph">
<p>下表列出了属于此字符类的所有当前定义的字符:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unicode 代码点</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符名</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHARACTER TABULATION</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xA0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NO-BREAK SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x1680</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OGHAM SPACE MARK</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x180E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MONGOLIAN VOWEL SEPARATOR</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EN QUAD</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2001</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EM QUAD</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2002</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EN SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2003</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EM SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2004</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">THREE-PER-EM SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2005</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FOUR-PER-EM SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2006</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SIX-PER-EM SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2007</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FIGURE SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2008</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUNCTUATION SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2009</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">THIN SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x200A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HAIR SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x202F</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NARROW NO-BREAK SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x25F</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MEDIUM MATHEMATICAL SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x3000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IDEOGRAPHIC SPACE</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>此表中有许多字符, 你可能永远不会使用这些字符, 而是查看表格。 你可以想象 Raku 对于 Unicode 和空格有多么谨慎。</p>
</div>
</div>
<div class="sect3">
<h4 id="_v_和_v_字符">11.3.6. \v 和 \V 字符</h4>
<div class="paragraph">
<p>\v 和 \V 字符类表示垂直空格和字符的字符, 这不是垂直空格。与水平空格集相比, Raku 对垂直空格的了解要少得多, 但仍然覆盖不同 Unicode 符号的整个范围, 如下面的列表所示:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unicode 代码点</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符名</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LINE FEED</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LINE TABULATION</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FORM FEED</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CARRIAGE RETURN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x85</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NEXT LINE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2028</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LINE SEPARATOR</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2029</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PARAGRAPH SEPARATOR</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_n_和_n_字符">11.3.7. \n 和 \N 字符</h4>
<div class="paragraph">
<p><code>\n</code> 字符匹配逻辑新行。<code>\N</code> 字符与之相反, 匹配任何不是新行的字符。</p>
</div>
<div class="paragraph">
<p>匹配新行很棘手, 因为不同操作系统中逻辑行的分离的有不同的约定。在类 Unix 系统上, 行由单个 <code>\r</code> 字符(代码为0x0A)分隔。在 Windows 中创建的文件中, 新行分隔符是 CARRIAGE RETURN(0x0A) 和 LINE FEED(0x0D) 两个字符的组合。Raku 的 <code>\n</code> 字符匹配其中任何一个。</p>
</div>
<div class="paragraph">
<p>让我们在以下示例中演示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $unix-str = "Hello,\rWorld!";
my $windows-str = "Hello,\r\nWorld!";

my @unix-lines = $unix-str.split(/\n/);
my @windows-lines = $windows-str.split(/\n/);

say @unix-lines.join('//');
say @windows-lines.join('//');</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里有两个带不同新行分隔符的字符串。然后, 我们用相同的正则表达式 <code>/\n/</code> 将这两行分开。程序的输出显示行被分割成了相同的部分:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Hello,//World!
Hello,//World!</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_d_和_d_字符">11.3.8. \d 和 \D 字符</h4>
<div class="paragraph">
<p><code>\d</code> 字符类与数字匹配。这里的数字被理解为 <code>Number</code> 类别中 Unicode 字符。在传统的阿拉伯数字 <code>0-9</code> 中, 有来自其他字母和脚本的数字。这些字符的整个列表令人筋疲力尽, 但是让我们举几个其他数字的例子:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>阿拉伯语-印度语: ٠ ١ ٢ ٣ ٤ ٥ ٦</p>
</li>
<li>
<p>Nko (来自西非的从右到左的字母表): 梵文 (印度和尼泊尔): ० १ २ ३ ४</p>
</li>
<li>
<p>孟加拉: ০ ১ ২ ৩ ৪</p>
</li>
<li>
<p>数学粗体: 𝟎 𝟏 𝟐 𝟑 𝟒</p>
</li>
<li>
<p>数学双倍体: 𝟘 𝟙 𝟚 𝟛 𝟜</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些数字的任何一个都将匹配 <code>\d</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">$ raku -e'say "OK" if "   " ~~ /\d/'
OK</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_w_和_w_字符">11.3.9. \w 和 \W 字符</h4>
<div class="paragraph">
<p><code>\w</code> 字符类与可以是单词的一部分的字符匹配, 即和字母, 数字与下划线符号匹配。<code>\W</code> 与其他所有除字面、数字和下划线的字符匹配。字母在这里是以 Unicode 意义理解的 - 这些是 <code>Letter</code> 类别中的字符。</p>
</div>
<div class="paragraph">
<p>例如, <code>\w</code> 将始终与任何希腊字母匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku -e'say "OK" if "λ" ~~ /\w/'
OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>与我们在上一节中介绍的数字一样, 你必须准备好 <code>\w</code> 将根据你所熟悉的语言与你可能期望的更多字符匹配。</p>
</div>
</div>
<div class="sect3">
<h4 id="_字符类_2">11.3.10. 字符类</h4>
<div class="paragraph">
<p>字符类是一种请求与给定字符列表匹配的机制。例如, 要匹配十六进制数字, 我们需要匹配一个带十进制数字 0 到 9 和六个字母 a 到 f(也包括它们的大写变体 A 到 F)的字符。</p>
</div>
<div class="paragraph">
<p>在 Raku 正则表达式中, 这可以写为字符类 <code>&lt;[0..9 a..f A..F]&gt;</code>。让我们将此正则表达式应用于大写拉丁字母列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 'A'..'Z' {
    .print if /&lt;[0..9 a..f A..F]&gt;/;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将打印字符串 <code>ABCDEF</code>, 其中包含与给定正则表达式匹配的字母。</p>
</div>
<div class="paragraph">
<p>字符类还可以包括反斜杠序列。在电话号码正则表达式中, 我们可以使用与数字, 空格或连字符匹配的字符类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ \+? &lt;[\d\s\-]&gt;+ /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们继续使用 Raku 正则表达式引擎中内置的其他字符类。</p>
</div>
</div>
<div class="sect3">
<h4 id="_预定义的子规则">11.3.11. 预定义的子规则</h4>
<div class="paragraph">
<p>Raku 中的正则表达式包括一些预定义的<strong>子规则</strong>, 它们也是字符类并且与反斜杠字符类部分相交。从句法上讲, 子规则是尖括号中的名字。下表总结了它们:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">子规则</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">意义</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;alpha&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字母符号和_</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;alnum&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与 \w 相同</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;digit&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与 \d 相同</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;lower&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小写字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;upper&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大写字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;space&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空格, 与 \s 相同</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;blank&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">水平空格, 与 \h 相同</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;cntrl&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;punct&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标点符号</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;graph&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与 &lt;alnum&gt; + &lt;punct&gt; 相同</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;print&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可打印字符, 与 &lt;alnum&gt; + &lt;space&gt; 相同, 不带 &lt;punct&gt;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>预定义的子规则是 Raku 正则表达式中的有效部分, 可以在正则表达式与其他字面量字符类一起的任何地方使用。在以下示例中, 我们检查字符串是否包含一个数字后跟一个字母:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $regex = / &lt;digit&gt; &lt;alpha&gt; /;

say 'Match'    if '3a' ~~ $regex;    # Match
say 'No match' if 'abcd' !~~ $regex; # No match
say 'No match' if 678 !~~ $regex;    # No match</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面提到的子规则不是根据它们的 Unicode 属性选择字符的唯一方法 。在下一节中, 我们将了解如何直接使用 Unicode 类别。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用_unicode_属性">11.3.12. 使用 Unicode 属性</h4>
<div class="paragraph">
<p>Unicode 字符属于不同的类别, 例如字母或数字, 或标点。类别可能具有额外级别的详细信息, 例如字母可以是小写或大写。</p>
</div>
<div class="paragraph">
<p>Raku 中的正则表达式为我们提供了基于 Unicode 类别的字符类机制 。要创建这样的类, 请使用一对包含冒号的尖括号, 后跟首字母大写的类别名称。要指定子类别, 请添加相应的小写字母。</p>
</div>
<div class="paragraph">
<p>例如, 匹配字母的字符类是 <code>&lt;:L&gt;</code>, 而匹配大写字母的字符类是 <code>&lt;:Lu&gt;</code>。在下面的示例中, 我们把几个字母与这些字符类相匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;A a B b Ω ω 1 2 * ^ &gt; -&gt; $char {
    say "$char ~~ &lt;:L&gt;"  if $char ~~ / &lt;:L&gt; /;
    say "$char ~~ &lt;:Lu&gt;" if $char ~~ / &lt;:Lu&gt; /;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码循环遍历一个有不同字符的列表, 并报告它们是否匹配 <code>&lt;:L&gt;</code> 或 <code>&lt;:Lu&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">A ~~ &lt;:L&gt;
A ~~ &lt;:Lu&gt;
a ~~ &lt;:L&gt;
B ~~ &lt;:L&gt;
B ~~ &lt;:Lu&gt;
b ~~ &lt;:L&gt;
Ω ~~ &lt;:L&gt;
Ω ~~ &lt;:Lu&gt;
ω ~~ &lt;:L&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>从输出中可以看出, 所有字母都通过了 <code>&lt;:L&gt;</code> 过滤器, 只有大写字母匹配了 <code>&lt;:Lu&gt;</code> 字符类, 并且非字母字符与其中任何一个测试都不匹配。</p>
</div>
<div class="paragraph">
<p>与 Unicode 相关的字符类在 Raku 中有两个名称, 短名称和长名称, 可以互换使用。可以像这样使用长名称编写相同的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;A a B b Ω ω 1 2 * ^ &gt; -&gt; $char {
    say "$char ~~ &lt;:L&gt;"  if $char ~~ / &lt;:Letter&gt; /;
    say "$char ~~ &lt;:Lu&gt;" if $char ~~ / &lt;:Uppercase_Letter&gt; /;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下表列出了与 Unicode 类别对应的所有字符类。在此表中, 单字母类别后面是两个字母的子类别。请注意一些字母组合不能从完整的类别名称中直接扣除; 例如, <code>Punctuation</code> 字符类, <code>Open</code> 类别的字符类在 Unicode 中称为 <code>Ps</code>, 因此它在 Raku 中是 <code>&lt;:Ps&gt;</code>:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Short name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Category</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Comment</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼&lt;:L&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Letter&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼￼Letter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Ll&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Lowercase_Letter&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Letter, lowercase</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a, b 等等
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Lu&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Uppercase_Letter&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Letter, uppercase</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A, B 等等
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Lt&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Titlecase_Letter&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Letter, titlecase</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ligatures such as Lj
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Lm&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Modifier_Letter&gt;￼￼￼￼￼</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Letter, modifier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">某些变音符号, 例如  ̃
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Lo&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Other_Letter&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Letter, other</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">来自希伯来语, 例如 ݢ 或阿拉伯语, 例如 א, 的字母
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:M&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Mark&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mark</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼￼&lt;:Mn&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Nonspacing_Mark&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mark, nonspacing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">重音符, 例如  ̀ 或  ́</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼ &lt;:Mc&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Spacing_Mark&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mark, spacing combining</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">某些组合字符
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Me&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Enclosing_Mark&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mark, enclosing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">符号, 围绕其他符号, 如旧的西里尔标志 1000: ҈
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:N&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Number&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Nd&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Decimal_Number&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number, decimal digit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0, 1, 2 等等
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Nl&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Letter_Number&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number, letter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">例如, 罗马数字(像 VIII 那样的单独字符)
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:No&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Other_Number&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number, other</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">其他与数字相关的字符, 如 1⁄4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼ &lt;:P&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Punctuation&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Punctuation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Pc&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Connector_Punctuation&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Punctuation, connector</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">例如, 字母上方的圆弧: ⁀
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Pd&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Dash_Punctuation&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼￼Punctuation, dash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">像破折号这样的符号: —
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Ps&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Open_Punctuation&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Punctuation, open</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">开口符号对, 例如 [ 或 (, 等等
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Pe&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Close_Punctuation&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Punctuation, close</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">闭合符号对, 例如 ] 或 ), 等等
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Pi&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Initial_Punctuation&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Punctuation, initial quote</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼起始引号字符, 如 «
￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Pf&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Final_Punctuation&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Punctuation, final quote</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">闭合引号字符, 如 »</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Po&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Other_Punctuation&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Punctuation, other</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">许多传统的标点字符如 ! 或 ?</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:S&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Symbol&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Symbol</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Sm&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Math_Symbol&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Symbol, math</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数学符号: +, ±, × 等等</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Sc&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Currency_Symbol&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Symbol, currency</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">货币符号: ¤, €, $ 等等</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Sk&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Modifier_Symbol&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Symbol, modifier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">变音符号, 例如  ̧ 或  ̈</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:So&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Other_Symbol&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Symbol, other</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不属于其他类别的符号:  ©, ® 等等</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Z&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Separator&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Separator</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Zs&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Space_Separator&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Separator, space</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">各种类型的空白</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Zl&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Line_Separator&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Separator, line</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">行分隔符的唯一符号, 代码为 0x8232</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Zp&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Paragraph_Separator&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Separator, paragraph</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">段落分割符的唯一符号, 代码为 0x2029</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:C&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Other&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Other</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Cc&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Control&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Other, control</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制字符, 例如 BELL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Cf&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Format&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Other, format</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不同的格式字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Cs&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Surrogate&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Surrogate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">少量代理字符</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_字符类算术">11.3.13. 字符类算术</h4>
<div class="paragraph">
<p>Raku 提供了强大的功能, 允许你使用集合运算创建新的字符类。这些是 - 用于并集的 <code>+</code> 或 <code>|</code>,  用于差集的 <code>-</code>, 用于交集的 <code>&amp;</code>, 用于异或运算的 <code>^</code>。此外, 可以使用 <code>-</code> 或 <code>!</code> 来否定字符类。</p>
</div>
<div class="paragraph">
<p>让我们看看例子。首先, 创建与小写字母和数字都匹配的连接类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;a A 3&gt; -&gt; $char {
    say "$char is a lowercase letter or a digit"
        if $char ~~ / &lt;:Ll + :Nd&gt; /;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此程序打印匹配字符 <code>a</code> 和 <code>3</code>。大写字母 A 不匹配, 因为它既不是小写字母也不是数字。</p>
</div>
<div class="paragraph">
<p>在另一个例子中, 我们通过从所有字母的集合中减去小写字母来重新发明大写字母:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;a A 3&gt; -&gt; $char {
    say "$char is an uppercase letter" if $char ~~ / &lt;:L - :Ll&gt; /;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 取所有小写字母并删除所有元音:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 'a'..'z' -&gt; $char {
    say "$char is consonant" if $char ~~ / &lt;:Ll - [aoeiu]&gt; /;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>(如果你想尝试使用其他语言, 请小心这种方法, 因为 <code>&lt;:Ll&gt;</code> 包括英文字母外的字母。)</p>
</div>
<div class="paragraph">
<p>如果你需要匹配除给定字符之外的任何字符, 差集是有用的。例如, 这就是你如何匹配英语字母表中, 不是原始拉丁语, 不包含一些现代英文字母的任何内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 'A'..'Z' -&gt; $char {
    say "$char is pure Roman" if $char ~~ / &lt;[A .. Z] - [GJUWY]&gt; /;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要否定一个字符类, 在它之前加一个减号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'OK' if 'x' ~~ / &lt;-[abcdef]&gt;/; # OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用感叹号否定 Unicode 预定义字符类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'OK' if 'x' ~~ / &lt;:!Lu&gt;/; # OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>字符类本身匹配单个字符。为了使正则表达式更强大, 让我们检查量词。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用量词创建可重复模式">11.4. 使用量词创建可重复模式</h3>
<div class="paragraph">
<p>量词修饰它前面的原子并要求特定次数的重复。<strong>原子</strong>是一个字符或字符类, 或字符串字面量或组(我们稍后将在本章的"使用捕获提取子字符串”一节中讨论组)。</p>
</div>
<div class="paragraph">
<p><code>+</code> 量词允许前一个原子重复一次或多次。例如, 正则表达式 <code>/a+/</code> 与单个字符 a 匹配, 以及与包含两个字符的 aa 字符串匹配 , 或三个 a 或更多-aaaaaa。但是, 它不会与根本不包含 a 字符的字符串匹配。</p>
</div>
<div class="paragraph">
<p><code>\*</code> 量词允许任意数量的重复, 包括零次。所以, <code>/a*/</code> 正则表达式与 bdef, abc 或 baad 等字符串匹配。当然, 单个 <code>/a*/</code> 可能不是那么有有; <code>*</code> 量词的更自然的用例是在其他子串之间, 例如 <code>/ ab*c/</code>。 此正则表达式与 ac, abc 或 abbc 匹配。</p>
</div>
<div class="paragraph">
<p><code>?</code> 量词需要一个原子出现一次或不存在。考虑正则表达式 <code>/colou?r/</code>, 它与英式和美式拼写单词 colour 和 color 相匹配。</p>
</div>
<div class="paragraph">
<p>也可以使用后面跟着重复次数或范围的 <code>*\*</code> 量词来请求给定的重复次数。例如, <code>/ 'a' 'b' <strong> 3..4 'c' /</code> 匹配包含 bbb 或 bbbb 子串的字符串, 例如, abbbc 匹配, 但不匹配
abbc 或 abbbbbbbc。在 <code>^</code> 的帮助下, 可以排除范围的边缘 - <code>/'a' 'b' \</strong> 3..^10 'c'/</code> 将与包含 3 到 9 个字母 a 的序列的子串匹配。开区间, 例如 <code>b <strong>* ^10</code>(0 到 9 个 b)或 <code>b \</strong>* 3..*</code> (三次或更多次) 也允许。</p>
</div>
<div class="paragraph">
<p>还有另一对量词, <code>%</code> 和 <code>%%</code>, 它们的使用方式略有不同。他们与 <code>+</code>, <code>?</code>, <code>*</code> 和 <code>**</code> 量词一起工作, 请求通过 <code>%</code> 或 <code>%%</code> 右侧提到的分隔符分割的重复序列。在 <code>%%</code> 的情况下, 分隔符也可能出现在最后一个重复元素之后。请考虑以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1 if 'a,b,c,d' ~~ / \w+ % ',' /;
say 1 if 'a,b,c,d' ~~ / \w ** 2..3 % ',' /;
say 1 if 'a,b,c,d' ~~ / \w ** 2..3 %% ',' /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码与第一种情况-a, b, c, d 中的所有四个字母都匹配, 第二种情况匹配前三个字母-a, b, c。在最后一种情况下, 只有三个字母匹配, 但是 c 和 d 之间的逗号也将被消耗-<code>a, b, c,</code>。</p>
</div>
<div class="sect3">
<h4 id="_贪婪">11.4.1. 贪婪</h4>
<div class="paragraph">
<p>上述量词默认表现为<strong>贪婪</strong>。这意味着他们从源字符串中匹配尽可能多的字符。例如, 在匹配 <code>'bbb' ~~ /b*/</code> 中, 正则表达式将始终消耗这三个字符。同样, <code>+</code> 量词尝试尽可能多地消耗重复字符。</p>
</div>
<div class="paragraph">
<p>有时候这种行为是不可取的。考虑从 HTML 标签中选择属性的正则表达式 。从给定的字符串 <code>&lt;a href="index.html" class="menu"&gt;</code> 中, 我们想要提取除属性的值, 即引号中的字符串。试图创建这样一个正则表达式, 如 <code>/ \" .* \" /</code> 将取在第一个引号和最后一个引号之间的整个子串- <code>"index.html" class="menu"</code>。这是因为 <code>*</code> 量词不想停在第一个属性值的末尾并继续消耗字符。</p>
</div>
<div class="paragraph">
<p>它更进一步, 甚至通过最后一个引号和结束角括号。在那之后, 没有剩下更多的字符, 但正则表达式希望与双引号匹配。所以正则表达式引擎执行回溯, 将消耗的字符<strong>返回</strong>给字符串, 直到正则表达式被满足或者失败。</p>
</div>
<div class="paragraph">
<p>为防止量词的贪婪性质, 请在其后添加一个问号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ \" .*? \" /</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 它只匹配第一个属性值(包括引号) - <code>"index.html"</code>。</p>
</div>
<div class="paragraph">
<p>请注意, 在正则表达式中, "字符应该被转义 - \"。正如我们在*字面量*一节中学到的那样, 只有字母数字字符和下划线符号匹配他们自身。或者, 我们可以通过把双引号放置在一对单引号中来创建一个引用字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ '"' .*? '"' /</code></pre>
</div>
</div>
<div class="paragraph">
<p>反贪婪行为可以应用于任何量词, 甚至可以应用于 <code>?</code> 一。在那种情况下, 如果可能, 修改量词 <code>??</code> 将尝试不匹配任何东西。因此, 如果是字符串 abc 针对 <code>/ab?/</code> 正则表达式进行测试, 那么它的子串会被匹配。使用非贪婪的 <code>/ab??/</code> 正则表达式, 只有 <code>a</code> 会匹配。当然, 如果我们以这种方式修改正则表达式, 那么 <code>b??</code> 必须与某些东西相匹配, 如 <code>/ab??c/</code>, 然后它会这样做。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用捕获提取子字符串">11.5. 使用捕获提取子字符串</h3>
<div class="paragraph">
<p>只匹配正则表达式是不够的。如果不能提取与正则表达式一致的子串, 那么正则表达式的真正力量不完整的。 将字符串的一部分保存在特殊变量中称为<strong>捕获</strong>。</p>
</div>
<div class="sect3">
<h4 id="_捕获组">11.5.1. 捕获组</h4>
<div class="paragraph">
<p>在 Raku 中, 通过将正则表达式的一部分放在圆括号中来实现捕获。圆括号在正则表达式中具有双重含义。我们已经在电话号码中分组备选项中看过圆括号的用法了。</p>
</div>
<div class="paragraph">
<p>让我们继续提取 HTML 属性值的示例。我们现在想要把值打印出来。因此, 我们需要创建一个正则表达式并标记我们想要提取的数据边界。捕获的数据被放入变量 <code>$0</code>, <code>$1</code> 等等。数字索引从零开始, 对应于正则表达式中捕获括号的顺序编号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = q{&lt;a href="index.html" class="menu"&gt;};
$str ~~ / \" (.*?) \" .* \" (.*?) \" /;
say $0;
say $1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行此代码并查看它打印的内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">⌈index.html⌋
⌈menu⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>实际上, 我们获得了我们想要的 HTML 属性的值。它们包含那些 <code>$str</code> 变量与圆括号中的正则表达式 - <code>(.*?)</code> 部分匹配的子字符串。因为它们出现了两次, 所以有两个变量被填充。</p>
</div>
<div class="paragraph">
<p>作为旁注, 此时我们可以说非贪婪量词并不是表达意思的唯一方式。而不是说"取双引号之前的尽可能少的字符", 我们可以要求"取尽可能多的不是引号的字符"并使用否定字符类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = q{&lt;a href="index.html" class="menu"&gt;};
$str ~~ / \" (&lt;-[\"]&gt;+) \" .* \" (&lt;-[\"]&gt;+) \" /;
say $0;
say $1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样, 必须转义引号, 即使在字符类中也是如此。</p>
</div>
</div>
<div class="sect3">
<h4 id="_match_对象">11.5.2. Match 对象</h4>
<div class="paragraph">
<p>你可能已经注意到, 在前面示例的输出中, 实际的子字符串是显示在一对角括号之间。这是因为变量 <code>$0</code> 和 <code>$1</code> 的内容不是裸字符串, 而是 <strong>Match</strong> 类型的对象。在使用 <code>say</code> 或 <code>print</code> 函数打印时, <strong>Match</strong> 对象以这种方式格式化。</p>
</div>
<div class="paragraph">
<p><code>$0</code>, <code>$1</code> 等变量实际上是完整形式 <code>$/[0]</code>, <code>$/[1]</code> 等等的快捷方式变体。<code>$/</code> 变量是 <strong>Match 对象</strong>。它是接收正则表达式匹配结果的默认变量。它包含所有的捕获字符串, 以及
与整个正则表达式匹配的整个子字符串。要获取单独的捕获, 使用诸如 <code>$/[1]</code> 或 <code>$1</code> 的索引。</p>
</div>
<div class="paragraph">
<p>那么, 让我们打印上一个例子中 <code>$/</code> 的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = q{&lt;a href="index.html" class="menu"&gt;};
$str ~~ / \" (.*?) \" .* \" (.*?) \" /;
say $/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将得到以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">⌈"index.html" class="menu"⌋
 0 =&gt; ⌈index.html⌋
 1 =&gt; ⌈menu⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一部分 ⌈"index.html" class="menu"⌋ 包含正则表达式匹配的整个子字符串。接下来是一些与捕获圆括号匹配的索引元素。</p>
</div>
<div class="paragraph">
<p>当匹配对象在字符串内被插值时, 它们打印时不带括号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'April 2017' ~~ / (\d+) /;
say "Year is $0";</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, <code>$0</code> 将被字符串化, 输出将是 <code>Year is 2017</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_命名捕获">11.5.3. 命名捕获</h4>
<div class="paragraph">
<p>当正则表达式具有不止一到两个捕获组以及正则表达式中有备选项时, 捕获变得更加棘手。例如, 请考虑以下正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $re = rx/ (&lt;[a..z]&gt;+) || (&lt;[A..Z]&gt;) (\d) /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这包含两个备选项, 但是每个分支中捕获组的编号不同。(备选分支将在下一节中详细介绍。)</p>
</div>
<div class="paragraph">
<p>现在, 提供与 <code>&lt;[a..z]+&gt;</code> 或与 <code>&lt;[A..Z]&gt;\d</code> 正则表达式匹配的字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'letter' ~~ $re;
'A5'     ~~ $re;</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一次匹配后, 将只定义 <code>$0</code>。打印 <code>$1</code> 将给 <code>Nil</code>。在第二例子中, 两个变量都将包含一个值。也不容易推断每种情况下正则表达式匹配的是哪一部分。如果两个备选项都具有相同数量的捕获, 则直接检查有定义的变量的数量的方法不起作用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $re = rx/ $&lt;type&gt;=(&lt;[a..z]&gt;+) ||
             $&lt;letter&gt;=(&lt;[A..Z]&gt;) $&lt;size&gt;=(\d)
           /;

'letter' ~~ $re;
say $/;

'A5' ~~ $re;
say $/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中, 我们还看到了格式化长正则表达式的方法, 使其更容易和更有逻辑性。</p>
</div>
<div class="paragraph">
<p>检查输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">⌈letter⌋
 type =&gt; ⌈letter⌋
⌈A5⌋
 letter =&gt; ⌈A⌋
 size =&gt; ⌈5⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>你会看到 <strong>Match</strong> 对象现在具有命名对而不是数字索引。如果你把 <code>$/</code> 变量视为哈希, 也可以使用名字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'letter' ~~ $re;
say $&lt;type&gt;;

'A5' ~~ $re;
say $&lt;letter&gt;;
say $&lt;size&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&lt;$name&gt;</code> 记法是 <code>$/&lt;name&gt;</code> 的简写。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_在正则表达式中使用备选项">11.6. 在正则表达式中使用备选项</h3>
<div class="paragraph">
<p>让我们再次看看我们原生的匹配电话号码的正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rx/ \+? (\d || \s || \-)+ /</code></pre>
</div>
</div>
<div class="paragraph">
<p>垂直条在圆括号中分隔组内的不同变体。它可以是 <code>\d</code>, 或 <code>\s</code>, 或 <code>\-</code> 。在正则表达式上下文中, 这叫做<strong>备选</strong>。相应地, 不同的变体称为<strong>备选项</strong>。</p>
</div>
<div class="paragraph">
<p>在 Raku 中, 正则表达式中有两种形式的备选分隔符-单个垂直条 <code>|</code> 和双垂直条 <code>||</code>。使用单个垂直条, 最长的变体总是匹配成功。随着双垂直条, 第一个匹配的备选项匹配成功。</p>
</div>
<div class="paragraph">
<p>在电话号码示例中, 每个备选项只有一个符号的长度。所以, 没有 <code>|</code> 和 <code>||</code> 之间没有区别。在其他情况下, 运算符的选择可能会非常大地改变结果。</p>
</div>
<div class="paragraph">
<p>例如, 从以下示例中获取两个正则表达式并匹配形容词 <code>bug</code> 的比较级形式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;big bigger biggest&gt; -&gt; $form {
    say "Testing '$form'";

    $form ~~ / big | bigger | biggest /;
    say $/;

    $form ~~ / big || bigger || biggest /;
    say $/;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序的输出如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Testing 'big'
⌈big⌋
⌈big⌋
Testing 'bigger'
⌈bigger⌋
⌈big⌋
Testing 'biggest'
⌈biggest⌋
⌈big⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>分析输出, 我们可以看到带单个垂直条的正则表达式, 每次都选择最长的备选项 - <code>big, bigger, biggest</code>。使用另一个带双竖条的正则表达式, 第一个匹配总是胜利 - <code>big</code>, 所有其他变种都不尝试。 你可以玩玩代码并更改正则表达式中备选项的顺序以查看它如何改变这个程序的行为。</p>
</div>
<div class="paragraph">
<p>例如, 如果按照其长度的相反顺序列出变体, 则两个正则表达式的输出将类似:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$form ~~ / big | bigger | biggest /;
say $/;

$form ~~ / biggest || bigger || big /;
say $/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>备选项通常只是正则表达式的一部分。在我们的例子中, 有一个序列 <code>\+?</code> 匹配电话号码中的可选加号。这不是备选项列表的一部分。 要标记备选的边界, 请使用括号。</p>
</div>
<div class="paragraph">
<p>括号还会创建一个原子, 随后由 <code>+</code> 量词修饰, 它应用于括号内的正则表达式的整个部分。</p>
</div>
<div class="paragraph">
<p>如果括号仅用于分组而不需要捕获, 请使用方括号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $phrase = 'Eat an apple, please';

$phrase ~~ / ( apple || pear ) /;
say $0;

say 'Healthy' if $phrase ~~ / [ apple || pear ] /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里, 第一个例子提取 <code>$parse</code> 中提到的水果, 而第二个匹配仅检查字符串是否包含两个所需单词之一并且不在任何地方保存它。第二次匹配后, <code>$0</code> 变量将包含 <code>Nil</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_用锚点定位正则表达式">11.7. 用锚点定位正则表达式</h3>
<div class="paragraph">
<p>在许多情况下, 正则表达式必须以其开头与字符串的开头重合的方式应用于字符串。例如, 如果电话号码包含 <code>+</code> 字符, 它只能出现在第一个位置。</p>
</div>
<div class="paragraph">
<p>Raku 正则表达式具有所谓的锚点-特殊字符, 它将正则表达式锚定到字符串或逻辑行的开头或结尾。</p>
</div>
<div class="sect3">
<h4 id="_匹配行或字符串的开头和末尾">11.7.1. 匹配行或字符串的开头和末尾</h4>
<div class="paragraph">
<p>让我们修改电话号码正则表达式, 以强制正则表达式与包含潜在电话号码的字符串整体匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ ^ \+? &lt;[\d\s\-]&gt;+ $ /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里, <code>^</code> 是匹配字符串开头的锚点, 它不会消耗任何字符。在正则表达式的另一边, <code>$</code> 要求正则表达式的结尾匹配字符串的结尾。因此, 有效的电话号码, 例如 <code>+49 20 102-14-25</code> 将通过过滤器,  而诸如 <code>124 + 35 - 36</code> 这样的数学表达则不会。</p>
</div>
<div class="paragraph">
<p>为了获得更好的可见性, 可以把锚点写在代码的不同行上:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $rx = /
    ^
        \+?
        &lt;[\d\s\-]&gt;+
    $
/;

say 'OK'     if '+49 20 102-14-25' ~~ $rx; # OK
say 'Not OK' if '124 + 35 - 36'   !~~ $rx; # Not OK</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>^</code> 和 <code>$</code> 都匹配字符串的边界(字符串作为变量)。如果你需要匹配逻辑行(如果字符串包含由 <code>\n</code> 分隔的几行), 请使用另一对锚点 - <code>^^</code> 和 <code>$$</code>。</p>
</div>
<div class="paragraph">
<p>在下一个示例中, 我们要选择菠萝的颜色:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fruits = "yellow banana\ngreen pineapple\nred apple";

$fruits ~~ / (\w+) \s pineapple $$ /;
say $0;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码打印 <code>green</code>, 因为 <code>(\w+)</code> 与菠萝行中的该字符匹配。行尾锚点 <code>` 匹配在行的末尾。结果不依赖于水果清单中的行的顺序。如果使用单个 `$` 而不是 `</code>, 那么只有 <code>green pineapple</code> 位于整个字符串的末尾, 正则表达式才匹配。</p>
</div>
</div>
<div class="sect3">
<h4 id="_匹配单词边界">11.7.2. 匹配单词边界</h4>
<div class="paragraph">
<p>要匹配单词边界, 请使用以下锚点之一:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">锚点</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">w&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何单词边界</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;&lt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">单词的开头</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&gt;&gt;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>这些锚点匹配单词的边界, 不消耗字符。例如,  <code>/&lt;|w&gt; apple /</code> 匹配 <code>apple</code> 但是不匹配 <code>pineapple</code>。</p>
</div>
<div class="paragraph">
<p><code>&lt;|w&gt;</code> 锚点有与之相反的对, <code>&lt;!|w&gt;</code>, 它与任何不是单词边界的东西匹配。这个锚点也不消耗字符, 所以 <code>/ o &lt;!|w&gt; p /</code> 匹配 <code>opera</code>。</p>
</div>
<div class="paragraph">
<p>要更精确地指定边界, 请使用 <code>&lt;&lt;</code> 或 <code>&gt;&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @words = 'fourty-four' ~~ m:g/ &lt;&lt; four /;
say +@words;

@words = 'fourty-four' ~~ m:g/ four &gt;&gt; /;
say +@words;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这些示例中, 第一个匹配将找到两个单词, 而在第二个尝试中, 仅找到一个以 <code>four</code> 结尾的单词。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用断言进行向前查看和向后查看">11.8. 使用断言进行向前查看和向后查看</h3>
<div class="paragraph">
<p>操纵正则表达式流的另一个主题是<strong>断言</strong>。在匹配过程中, 该模式不消耗源字符串的字符。断言有助于在当前位置不吃字符而进行一些检查。</p>
</div>
<div class="paragraph">
<p>Raku 正则表达式中有两种类型的断言 - <strong>向前查看</strong>和<strong>向后查看</strong>。这两个都有否定形式。在下表中, 列出了所有可能的组合:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">正向断言</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">否定断言</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">向前查看</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;?before X&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;!before X&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">向后查看</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;?after X&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;!after X&gt;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>被放置在正则表达式中, 向前查看断言 <code>&lt;?before X&gt;</code> 检查在这个位置后面跟着的字符是否是 <code>X</code>。如果是, 那么断言成功, 正则表达式引擎继续工作。其他断言的行为遵循相同的逻辑考虑, 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'Etiquette' ~~ / (.*?) &lt;?after 'qu'&gt; (e .*) /;
say $/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印出这个结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">⌈Etiquette⌋
 0 =&gt; ⌈Etiqu⌋
 1 =&gt; ⌈ette⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>讨论中的单词分为两部分。该规则在 <code>e</code> 处分开, 其后是 <code>qu</code>。 <code>qu</code> 这两个字符已被第一个 <code>.*?</code> 捕获块消耗掉但向前查看断言仍然能够查看源字符串以查看那里是否存在序列 <code>qu</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用副词修饰正则表达式">11.9. 使用副词修饰正则表达式</h3>
<div class="paragraph">
<p><strong>副词</strong>是正则表达式修饰符。它们是冒号前缀字母, 可以改变正则表达式的行为。</p>
</div>
<div class="paragraph">
<p>副词以两种形式存在 - <strong>短形式</strong>和<strong>长形式</strong> - 并出现在正则表达式的前面, 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'OK' if 'ABCD' ~~ m:i/ abcd /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, 当副词应用于整个正则表达式时, 如本例所示, 需要一个 <code>m</code> 或 <code>rx</code>。或者, 副词可以放在正则表达式中。在这种情况下, 它从它出现的位置开始起作用。这在下一个关于 <code>:i</code> 副词的部分例子中得到证明。</p>
</div>
<div class="paragraph">
<p>下表列出了所有副词:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">短形式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">长形式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:i</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ignorecase</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配字符是大小写不敏感的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:sigspace</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空白是重要的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:p(N)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:pos(N)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从位置 N 开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:g</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:global</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">全局匹配</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:c</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:continue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在前一个匹配之后继续</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:r</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ratchet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">禁用回溯</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ov</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:overlap</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">重叠匹配</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:exhaustive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">找到所有可能的匹配</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>让我们浏览列表并检查每个副词。</p>
</div>
<div class="sect3">
<h4 id="_iignorecase">11.9.1. i(:ignorecase)</h4>
<div class="paragraph">
<p>这是最简单的正则表达式副词。它允许正则表达式与大小写无关。因此, <code>m:i/X/</code> 和 <code>m:i /x/</code> 这两个正则表达式中的每一个都将成功匹配 <code>x</code> 和 <code>X</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $rx = rx:i/hello/;
say 'Matches' if 'Hello, World!' ~~ $rx;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当 <code>:i</code> 副词在正则表达式里面时, 只有其后面的部分是大小写不敏感的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'No match' if 'HeLLO, World!' !~~ /he :i llo/;
say 'Matches'  if 'HeLLO, World!'  ~~ /He :i llo/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要停掉该副词的行为, 请使用否定副词:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Matches' if 'HeLLo, World!' ~~ /He :i ll :!i o/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>捕获括号和非捕获括号限制副词的作用域:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Not OK' if $str !~~ / (:i hello)\, \s world /;
say 'OK' if $str ~~ / [:i hello]\, \s World /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这些示例中, <code>:i</code> 只影响第一个单词。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ssigspace">11.9.2. :s(:sigspace)</h4>
<div class="paragraph">
<p>我们已经多次看到在正则表达式中忽略了额外的空格, 空格通常用于使正则表达式更具可读性。但是, 在某些情况下, 特别是在正则表达式与带空格的字符串匹配时, 最好禁用此功能并要求匹配空格字面量。</p>
</div>
<div class="paragraph">
<p>在以下示例中, 我们从日期中提取出天, 月份和年份这三个部分。 由于原始的面向人的字符串中有空格, 我们需要在正则表达式中注意它们。默认情况下, 空格被忽略, 正则表达式应该在位置中预计会有空格的地方包含 <code>\s</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $date = '19 April 2017';
$date ~~ / (\d+) \s (\w+) \s (\d+) /;

say "Year = $2, month = $1, day = $0";</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>:s</code> 副词, 正则表达式中的字面值空格将与字符串匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $date = '19 April 2017';
$date ~~ m:s/ (\d+) (\w+) (\d+) /;

say "Year = $2, month = $1, day = $0";</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 好的部分(有些可能令人困惑)是正则表达式周围的空格仍被忽略。在上面的例子中, 我们看到第一个斜线后面和最后一个斜线前面有空格。那些空格不需要匹配。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ppos">11.9.3. :p(:pos)</h4>
<div class="paragraph">
<p>带有 <code>:p</code> 或 <code>:pos</code> 副词的正则表达式从副词的参数指定的位置匹配字符串。从以下示例可以清楚地看到该行为。</p>
</div>
<div class="paragraph">
<p>默认情况下, 正则表达式从字符串的开头开始匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'pineapple' ~~ / (\w+) /;
say $0; # pineapple</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <code>\w+</code> 的贪婪性, 整个字符串被消耗和匹配。让我们试试跳过几个字符并将正则表达式应用于相同的字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'pineapple' ~~ m:p(4)/ (\w+) /;
say $0; # apple</code></pre>
</div>
</div>
<div class="paragraph">
<p>这次, 只匹配 <code>apple</code> 子串。</p>
</div>
<div class="paragraph">
<p><code>:p</code> 副词的索引也表现得像锚点。类似于 <code>^</code> 如何将正则表达式绑定到字符串的开头, <code>:p(N)</code> 副词将正则表达式绑定到给定的位置。比较以下两个匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'pineapple' ~~ m:p(4)/ (a\w+) /;
'pineapple' ~~ m:p(3)/ (a\w+) /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>他们中的第一个成功, 因为它在字符串的第四个位置找到了 <code>a</code>。第二个匹配, 当它在第三个位置看到 <code>e</code> 时立即失败了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_gglobal">11.9.4. :g(:global)</h4>
<div class="paragraph">
<p><code>:g</code> 副词用于全局匹配。正则表达式将应用于字符串几次, 每次从上一个匹配停止的位置开始。</p>
</div>
<div class="paragraph">
<p>例如, 让我们将一个句子分成单独的单词:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @words = 'Hello, World!' ~~ m:g/ (\w+) /;
say join ';', @words; # Hello;World</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住从本章的 Match 对象一节中提取 HTML 属性的示例 。要获得两个值, 正则表达式包含同一模式的两个相同的副本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = q{&lt;a href="index.html" class="menu"&gt;};
$str ~~ / \" (.*?) \" .* \" (.*?) \" /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要避免这种情况并使正则表达式更通用, 请使用全局匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = q{&lt;a href="index.html" class="menu"&gt;};
$str ~~ m:g/ \" .+? \" /;
say ~$/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序打印 "index.html" "menu", 它们是从字符串中提取的两个匹配的元素。<code>~$/</code> 语法对 <strong>Match</strong> 对象进行字符串化; 这个动作相当于在双引号字符串中插值对象, 就像我们之前做的那样。</p>
</div>
<div class="paragraph">
<p>与 <code>:i</code> 修饰符不同, 你不能把 <code>:g</code> 放在正则表达式里面。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ccontinue">11.9.5. :c(:continue)</h4>
<div class="paragraph">
<p><code>:c</code> 副词请求从最后一个位置继续。</p>
</div>
<div class="paragraph">
<p>考虑上一节关于 <code>:g</code> 副词的例子。我们可以只匹配几次, 而不是全局匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = q{&lt;a href="index.html" class="menu"&gt;};

$str ~~ m/ \" .+? \" /;
say ~$/;

$str ~~ m:c/ \" .+? \" /;
say ~$/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有 <code>:c</code>, 第二个匹配将从字符串的开头开始, 它将会返回与第一个匹配相同的结果。使用 <code>:c</code>, 它使用相同的字符串继续匹配, 所以第二个属性将被捕获。</p>
</div>
<div class="paragraph">
<p>这个副词可以将索引作为参数。在这种情况下, 相应的正则表达式匹配将从给定位置开始。以下示例演示了这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = q{&lt;div class="menu"&gt;&lt;div class="item"&gt;};
$str ~~ m:c(10)/ 'class="' .*? '"' /;
say ~$/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>正则表达式应用于从第 10 个字符开始的字符串。在这种情况下, 跳过第一个潜在匹配, 程序找到第二个类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">class="item"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rracate">11.9.6. :r(:racate)</h4>
<div class="paragraph">
<p>此副词禁用正则表达式中的回溯。在贪婪一节中, 我们已经看到了一个贪婪量词消耗了太多的字符后, 正则表达式引擎如何回滚以用较少的字符尝试另一次匹配。<code>:r</code> 副词不会让回滚发生。它解释了名称`:ratchet` - 它只管前进。</p>
</div>
<div class="paragraph">
<p>例如, 在下一个示例中, 创建正则表达式以查找以零结尾的所有数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 1..100 {
    .say if / \d+ 0 /;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码打印数字 10,20, 依此类推。如果使用 <code>:r</code>, 则不会打印任何内容, 因为 <code>\d+</code> 消耗数字中的所有数字, 并且 <code>:r</code> 没有留下匹配 0 的空间。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ovoverlap">11.9.7. :ov(:overlap)</h4>
<div class="paragraph">
<p><code>:ov</code> 副词改变正则表达式应用于字符串的方式, 以便找出每个位置上最长匹配的所有重叠匹配。</p>
</div>
<div class="paragraph">
<p>让我们在查找 <code>pi</code> 值内的所有数字子序列的任务中说明这一点,  以 1 开头和结尾:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pi =
   '3.1415926535897932384626433832795028841971693993751058209749445923078164';
my @a = $pi ~~ m:g/1.*?1/;
say ~@a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码打印以下值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">141 1971 10582097494459230781</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可能会注意到它在原始值的不同部分中找到了序列, 它们是不相交的。</p>
</div>
<div class="paragraph">
<p>现在, 让我们添加 <code>:ov</code> 副词。要将另一个副词添加到已有副词的正则表达式中,  只需将其附加到上一个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pi =
   '3.1415926535897932384626433832795028841971693993751058209749445923078164';
my @a = $pi ~~ m:g:ov/1.*?1/;
say ~@a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次, 输出是不同的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">141 15926535897932384626433832795028841 1971 1693993751 10582097494459230781</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个下一个值与前一个值共享相同的字符 1。结果包含所有来自前一个示例的值, 但也包括介于两者之间的值, 它因为匹配模式 <code>1.*?1</code>。</p>
</div>
<div class="paragraph">
<p>如果我们删除反贪婪量词, 那么 <code>:ov</code> 副词的性质会更可见。在这种情况下, 正则表达式 <code>m:g:ov/1.*1/</code> 返回每个位置的最长匹配, 它在那里看到 1。当它到达字符串的末尾时, 子匹配变得越来越短:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">14159265358979323846264338327950288419716939937510582097494459230781 159265358979323846264338327950288419716939937510582097494459230781 19716939937510582097494459230781 16939937510582097494459230781 10582097494459230781</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们将模式更改为此模式会怎么样?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = $pi ~~ m:g:ov/1.*?2/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>将它应用到 <code>$pi</code> 后, 程序将打印以下行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">141592 1592 19716939937510582 16939937510582 10582</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次, 重叠甚至更强 - 例如, 字符串 <code>1592</code> 完全包含在第一个匹配 <code>141592</code> 中。</p>
</div>
</div>
<div class="sect3">
<h4 id="_exexhaustive">11.9.8. :ex(:exhaustive)</h4>
<div class="paragraph">
<p>这个副词尽可能多地找到子串, 考虑到每个可能性, 包括不同长度的重叠值和子串。这部分类似具有 <code>:ov</code> 副词的正则表达式的行为, 但不选择最长匹配。</p>
</div>
<div class="paragraph">
<p>让我们在 <code>pi</code> 值上用相同的模式 <code>/1.*1/</code> 来测试这个副词(但是这一次, 我们会取较短的字符串):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pi = '3.141592653589793238462643383279502884197169';
my @a = $pi ~~ m:g:ex/1.*1/;
say ~@a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们取了较短的版本来节省一些输出空间:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1415926535897932384626433832795028841971 1415926535897932384626433832795028841 141 15926535897932384626433832795028841971 15926535897932384626433832795028841 1971</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为练习, 使用带非贪婪量词 <code>m:g:ex/1.*?1/</code> 的另一个正则表达式尝试相同的值。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用正则表达式替换和修改字符串">11.10. 使用正则表达式替换和修改字符串</h3>
<div class="paragraph">
<p>使用正则表达式匹配字符串通常会从给定数据中提取一些信息。另一个常见的任务是用不同的字符替换部分文本。在 Raku 中, <code>s</code> 内置函数就是这样。</p>
</div>
<div class="paragraph">
<p>它需要两个参数, 正则表达式和替换。将正则表达式应用于源字符串并且模式匹配时, 匹配的字符串部分被替换为第二个参数。</p>
</div>
<div class="paragraph">
<p>考虑一个简单的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = 'Its length is 10 mm';
$str ~~ s/&lt;&lt;mm&gt;&gt;/millimeters/;
say $str; # Its length is 10 millimeters</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的正则表达式 <code>/<a href="#mm">[mm]</a>/</code> 与单词 <code>mm</code> 匹配。第二部分是说要使用测量单位的全名替换它 。替换就地发生并且原始字符串被修改。</p>
</div>
<div class="paragraph">
<p>传统上, <code>s</code> 使用斜杠作为分隔符, 但可以使用不同的字符。看着与前面的代码进行相同替换的示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$str ~~ s|&lt;&lt;mm&gt;&gt;|millimeters|;
$str ~~ s;&lt;&lt;mm&gt;&gt;;millimeters;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第二个例子中, 最后两个分号表示不同的东西 - 其中一个是正则表达式和替换的分隔符, 而另一个是 Raku 的表达式分隔符。</p>
</div>
<div class="paragraph">
<p>在替换部分中, 替换文本可以使用变量插值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = 'Its length is 10 mm';
my $standard-length = 7;
$str ~~ s/\d+/$standard-length/;
say $str; # Its length is 7 mm;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>s///</code> 的第一部分中捕获的值也可用于替换:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $date = '20070419';
$date ~~ s/ (\d ** 4) (\d\d) (\d\d) /$2.$1.$0/;
say $date;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>s</code> 中的正则表达式将日期分为年, 月和日部分, 并在替换模式中按不同顺序将它们组合起来。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_14">11.11. 总结</h3>
<div class="paragraph">
<p>在本章中, 我们讨论了 Raku 中的正则表达式。他们和 Perl 5 中的正则表达式有很多通用之处, 但也提供了许多引人入胜的新东西。我们检查了构建正则表达式和匹配文本的方法, 学会了如何通过编写自定义字符类或内置字符类来扩展正则表达式引擎的能力。我们也看了 Raku 在 Match 对象中存储结果的方法, 以及如何使用正则表达式替换字符串。</p>
</div>
<div class="paragraph">
<p>在下一章中, 我们将会遇到一个非常强大的工具, 它可以极大地扩展正则表达式, 即 grammar。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_grammars">12. Grammars</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 带来了一个非常有用和强大的机制来实现正则表达式—grammars。</p>
</div>
<div class="paragraph">
<p>Grammars 是 Raku 中的一种迷你语言, 允许你描述其他语言的规则(包括 Raku 本身)。使用 grammars, 创建解析器、翻译器或领域特定语言(DSL)或编程语言的编译器, 甚至是人类语言的解析器都非常容易。</p>
</div>
<div class="paragraph">
<p>在本章中, 我们将通过为其创建 Raku 编译器的子集来学习 Raku 的 grammar。本章将介绍以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建 grammar</p>
</li>
<li>
<p>grammar 的元素 - rule 和 token</p>
</li>
<li>
<p>TOP 规则</p>
</li>
<li>
<p>空白处理</p>
</li>
<li>
<p>解析文本</p>
</li>
<li>
<p>使用 Action</p>
</li>
<li>
<p>使用抽象语法树(AST)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本章假定你熟悉正则表达式。如果你还没有读过第11章, 正则表达式, 现在正是这样做的合适时机。另外, 了解在 Raku 中组织类是必需的, 这包含在第8章面向对象的编程中。</p>
</div>
<div class="sect2">
<h3 id="_创建_grammar">12.1. 创建 grammar</h3>
<div class="paragraph">
<p>与正则表达式一样, grammar 定义了一些从给定文本中提取信息的规则。一个典型的正则表达式应用是在文本块中找到片段并将它们分成有意义的片段, 例如, 查找电子邮件或检查其格式是否正确。 Grammar 有一个更大的目标 - 他们的任务通常是阅读全文并理解它所有的内容。例如, 如果将 grammar 应用于以某些编程语言编写的源代码 , 则 grammar 必须检查其有效性并创建该程序的语法树。这种差异仍然是一种约定 - grammar 可以解析小文本部分, 正如正则表达式可用于分析大文本部分。</p>
</div>
<div class="paragraph">
<p>Raku 中 grammar 的语法就像定义一个类。grammar 从 <strong>grammar</strong> 关键字开始:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此 grammar 为空, 无法应用于文本。我们必须添加起始规则, 它将是 grammar 的入口点。</p>
</div>
<div class="paragraph">
<p>Grammar 包含 <strong>rule</strong> 和 <strong>token</strong>。我们将在本章中更详细地讨论它们, 但目前我们需要创建主规则, 这是 grammar 的应用于文本的第一条规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
    rule TOP {
        .*
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见, 规则类似于类中的方法。与方法不同, 规则在主体块中包含正则表达式。此示例中的 <code>TOP</code> 规则匹配模式 <code>.*</code>,  它实际上匹配任何东西。现在这已经足够了, 首先我们必须创建一个最小的 grammar, 以了解如何将其应用于文本。<code>TOP</code> 是预定义的名字, 你可以将其赋予 grammar 中的第一条规则。</p>
</div>
<div class="paragraph">
<p>正如本章开头所提到的, 我们将为小型 Raku 子集(为简单起见, 我们将忽略真实 Raku grammar 中的一些边缘情况)创建一个解析器。因此, 我们 grammar 要解析的第一个文本, 可能如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $text = 'my $x;';</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用我们的 grammar <code>G</code> 解析 <code>$text</code>, 请在其上调用 <code>parse</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result = G.parse($text);
say $result;</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果是一个复杂的 grammar 对象, 其中包含所匹配的文本。在我们这个简单的例子中, <code>TOP</code> 规则消耗整个文本, 字符串化的值如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">「my $x」</code></pre>
</div>
</div>
<div class="paragraph">
<p>应用 grammar 至少有三个目标:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>检查源文本是否在文法上正确。</p>
</li>
<li>
<p>将文本拆分为语法元素。</p>
</li>
<li>
<p>根据语言规则执行 action。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在本章中, 我们将编写所有这三个部分, 但我们的第一个任务是学习如何检查文本是否与 grammar 一致。</p>
</div>
<div class="sect3">
<h4 id="_匹配_grammar">12.1.1. 匹配 grammar</h4>
<div class="paragraph">
<p>我们的示例程序将在本章的其余部分逐行解析, 看起来像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;
$x = 5;
say $x; # 5

my $y;
$y = $x;
say $y; # 5

my $z;
$z = $x + $y;
say $z; # 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个有效的 Raku 程序, 我们必须创建解析和执行它的 grammar。</p>
</div>
<div class="paragraph">
<p>让我们将参考程序保存在一个单独的文件中, 比如, <code>refer.pl</code>, 并使用 <code>parsefile</code> 方法而不是 <code>parse</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result = G.parsefile('refer.pl');
say $result;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此程序打印文件的全部内容, 因为此 <code>TOP</code> 规则仍然匹配它得到的一切。为了确保 grammar 解析整个文件, 让我们添加锚点以绑定文本的开头和结尾:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> grammar G {
    rule TOP {
        ^ .* $
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以在规则中随意使用空格以使正则表达式更清晰:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    ^
        .*
    $
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一个子目标是单独解析代码的每一行。确切地说, grammar 不应该解析源文本的行, 而是解析用分号分隔的指令。解析器不应该依赖于代码添加了多少空格和换行符。</p>
</div>
<div class="paragraph">
<p>现在我们必须使用 grammar 形式化刚才所说的内容。源程序是一个用分号分隔的语句的列表。让我们修改 <code>TOP</code> 规则来表达:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    ^
        (.*? ';')*
    $
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们从最小的程序开始:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;
$x = 5;
say $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你查看打印 <code>$result</code> 的程序的输出, 你会看到整个文件的内容后跟单独的指令, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">⌈my $x;
$x = 5;
say $x;⌋
 0 =&gt; ⌈my $x;⌋
 0 =&gt; ⌈
$x = 5;⌋
 0 =&gt; ⌈
say $x;⌋;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出有点乱, 但我们可以看到源文件中的每个语句都被放到了 <code>$result</code> 的一个单独元素中, 类似于 <strong>Match</strong> 对象包含正则表达式匹配字符串的一部分的结果。</p>
</div>
<div class="paragraph">
<p>提取的片段包含前导空格, 我们可以在 grammar 中允许他们, 很容易地抑制它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    ^
        [\s* (.*? ';')]*
    $
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为避免不必要的捕获, 使用方括号。现在输出看起来更清晰:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">⌈my $x;
$x = 5;
say $x;⌋
 0 =&gt; ⌈my $x;⌋
 0 =&gt; ⌈$x = 5;⌋
 0 =&gt; ⌈say $x;⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>引用程序的所有语句都被捕获; 我们只需要让 grammar 忽略注释:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    ^
        [\s* (.*? ';') ['#' &lt;-[\n]&gt;* ]? ]*
    $
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>正则表达式的附加部分 <code>['#' &#8592;[\n]&gt;* ]?</code> 找到可选的以井字符开始, 直到行尾(换句话说, 它们包含非 <code>\n</code> 字符)的子字符串。</p>
</div>
<div class="paragraph">
<p><code>TOP</code> 规则的正则表达式变得越来越复杂, 因此是时候将它分成几部分了, 以使整个 grammar 更具可读性和可维护性。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用_rules_和_tokens">12.2. 使用 rules 和 tokens</h3>
<div class="paragraph">
<p>Raku 中的 grammar 提供了一种将 grammar 元素分成几部分的非常有用的方法。让我们用它来澄清 grammar 元素。</p>
</div>
<div class="paragraph">
<p>复杂的正则表达式 <code>\s* (.<strong>? ';') ['#' &#8592;[\n]&gt;</strong> ]?</code> 包含两个部分 - 提取语句的正则表达式和用于注释的正则表达式。我们将它们提取为单独的规则。 单个 <strong>rule</strong> 描述了一小段 grammar, 可以引用其他规则。检查以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
    rule TOP {
        ^
            [ &lt;statement&gt; \s* &lt;comment&gt;? ]*
        $
    }
    rule statement {
        .*? ';'
    }
    rule comment {
        '#' &lt;-[\n]&gt;*
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在 <code>TOP</code> 规则更加清晰, 你会立即看到该程序是一个语句序列, 其后带有可选注释(我们的 grammar 不允许不带语句的注释)。</p>
</div>
<div class="paragraph">
<p>到目前为止, grammar 完全解析了 <code>refer.pl</code> 文件, 但我们可以更进一步。我们可以提取语句, 接下来的任务就是理解它们。现在让我们按行解析该文件, 添加新行以及可以解析语句的 grammar 规则。 你可以通过将源文本嵌入到我们的主文件中来实现:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $prog = q:to/END/;
my $x;
END

my $result = G.parse($prog);
say $result;</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一行 <code>my $x</code> 包含一个变量声明语句。当我们开始 grammar 时, 它只能解析变量声明, 这里是修改后的 <code>statement</code> 规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule statement {
    &lt;variable-declaration&gt; ';'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>变量声明是一系列的 <code>my</code> 关键字和变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule variable-declaration {
    'my' &lt;variable&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此 <code>variable-declaration</code> 规则包含两个部分 - 文字字符串 <code>'my'</code> 和对另一个规则 <code>&lt;variable&gt;</code> 的引用。关于这两部分之间的任何空格我们没有明说。Raku 中的规则关心那些空格。因此, 规则可以解析在 <code>my</code> 和变量之间包含一个, 两个或多个空格的变量声明。 即使是以下字符串也可以正确解析 - <code>my$x</code>。</p>
</div>
<div class="paragraph">
<p>为了描述变量, 我们创建一个 <strong>token</strong>。token 就像规则但他们的元素之间不允许空格。所以有效的变量名应该是不带空格的字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token variable {
    &lt;sigil&gt; &lt;identifier&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>sigil 要么是标量 sigil <code>$</code>, 要么是数组 sigil <code>@</code>。虽然在本章开头的示例程序中我们没有任何数组, 让我们准备将来要使用的 grammar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token sigil {
    '$' | '@'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后, 描述一个标识符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token identifier {
    &lt;alpha&gt; &lt;alnum&gt;*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在该 grammar 描述的语言中, 标识符是以字母开头的字母数字字符序列。</p>
</div>
<div class="paragraph">
<p>使用先前列出的 rule 和 token, grammar 解析我们的引用程序的第一行, 它看起来长这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">⌈my $x;
⌋
 statement =&gt; ⌈my $x;
⌋
 variable-declaration =&gt; ⌈my $x⌋
  variable =&gt; ⌈$x⌋
   sigil =&gt; ⌈$⌋
    identifier =&gt; ⌈x⌋
     alpha =&gt; ⌈x⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出显示该程序的分析树。缩进有助于更好地理解结构。在顶层, 我们看到程序 <code>my $x</code> 包含一个语句 <code>my $x</code>, 这是一个变量声明。变量是 <code>$x</code>, 它包含一个符号 <code>$</code> 和一个以字母 x 开头的标识符 <code>x</code>。</p>
</div>
<div class="paragraph">
<p>对于更长的变量名, 例如 <code>@array</code>, 解析树将包含与 <code>identifier</code> 规则的 <code>&lt;alnum&gt;*</code> 部分匹配的所有字母:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">variable-declaration =&gt; ⌈my @array⌋
 variable =&gt; ⌈@array⌋
  sigil =&gt; ⌈@⌋
  identifier =&gt; ⌈array⌋
   alpha =&gt; ⌈a⌋
   alnum =&gt; ⌈r⌋
   alnum =&gt; ⌈r⌋
   alnum =&gt; ⌈a⌋
   alnum =&gt; ⌈y⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们解析文件的第二行, 其中包含赋值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $prog = q:to/END/;
my $x;
$x = 100;
END</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>assignment</code> 也是一个 <code>statement</code>, 因此要解析它, <strong>statement</strong> 规则必须知道 <strong>assignment</strong> 是什么:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule statement {
    [
        | &lt;variable-declaration&gt;
        | &lt;assignment&gt;
    ]
    ';'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>新规则包含由垂直条分隔的备选列表; 一对方括号将备选项分组而不捕获文本。实际上, 第一个垂直条不是必须的, 但加上它可以使代码看起来更结构化。</p>
</div>
<div class="paragraph">
<p><code>assignment</code> 规则的第一种方法仅包括数值赋值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule assignment {
    &lt;variable&gt; '=' &lt;value&gt;
}
token value {
    &lt;number&gt;
}
token number {
    &lt;digit&gt;+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此时, grammar 解析以下程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;
$x = 100;</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二个语句根据 grammar 进行解析, 并形成以下解析树:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">statement =&gt; ⌈$x = 100;
⌋
 assignment =&gt; ⌈$x = 100⌋
  variable =&gt; ⌈$x⌋
  sigil =&gt; ⌈$⌋
  identifier =&gt; ⌈x⌋
   alpha =&gt; ⌈x⌋
  value =&gt; ⌈100⌋
   number =&gt; ⌈100⌋
    digit =&gt; ⌈1⌋
    digit =&gt; ⌈0⌋
    digit =&gt; ⌈0⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序的第三行是 <code>say $x;</code>。让我们称这种语句为 <code>say-function</code>,  并为它实现规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule say-function {
    'say' &lt;variable&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见, 这非常简单, 因为我们已经有一个解析变量的规则了。最后, 必须将此新规则添加到 <code>statement</code> 规则中的备选列表中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule statement {
    [
        | &lt;variable-declaration&gt;
        | &lt;assignment&gt;
        | &lt;say-function&gt;
    ]
    ';'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>语句被成功解析:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">statement =&gt; ⌈say $x;
⌋
 say-function =&gt; ⌈say $x⌋
  variable =&gt; ⌈$x⌋
   sigil =&gt; ⌈$⌋
   identifier =&gt; ⌈x⌋
    alpha =&gt; ⌈x⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在让我们休息一下, 教我们的编译器不仅要解析程序, 还要执行它。在这里, action 应运而生了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_actions">12.3. 使用 actions</h3>
<div class="paragraph">
<p>Grammar 本身不只是解析源文本还从中提取数据。要使程序执行代码, 需要 actions。Grammar 中的 action 是 grammar 成功解析 rule 或 token 时触发的 Raku 代码片段。</p>
</div>
<div class="paragraph">
<p>让我们看一下 <code>variable-declaration</code> 规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule variable-declaration {
    'my' &lt;variable&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当 grammar 在源文本中找到序列 <code>my $x</code> 时, 该规则就满足了。此时, 你可以添加一个 action:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule variable-declaration {
    'my' &lt;variable&gt; {say 'Declaring a variable'}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>action 可以是这样的简单警报, 但它也可能是更复杂的将作为对变量声明的反应所执行的代码。</p>
</div>
<div class="paragraph">
<p>为了使 action 正常, 它需要知道变量的类型(它是否包含 <code>$</code> 或 <code>@</code> 符号)及其名字。Action 可以访问反应解析片段的当前状态的 <strong>Match</strong> 对象。可以在 <strong>Match</strong> 对象中按名字找到命名子规则; 例如, <code>$&lt;variable&gt;</code> 返回字符串 <code>$x</code>。</p>
</div>
<div class="paragraph">
<p>要深入挖掘, 请使用 <strong>Match</strong> 对象的嵌套元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule variable-declaration {
    'my' &lt;variable&gt; {
        say 'Declaring ' ~
            ($&lt;variable&gt;&lt;sigil&gt; eq '$'
             ?? 'a scalar variable'
             !! 'an array') ~
             '"' ~ $&lt;variable&gt;&lt;identifier&gt; ~ '"';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行带两个变量声明的程序的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $prog = q:to/END/;
my $x;
my @array;
END

G.parse($prog);</code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Declaring a scalar variable "x"
Declaring an array "array"</code></pre>
</div>
</div>
<div class="paragraph">
<p>这证明 grammar 理解程序并且 action 得到了正确的变量名和变量类型。</p>
</div>
<div class="paragraph">
<p>只要我们可以区分标量和数组, 我们就可以保存它们的值以在未来使用。为此, 定义两个全局变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %scalar;
my %array;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些哈希的键对应于变量名。我们将在 grammar 的 action 中填充存储:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule variable-declaration {
    'my' &lt;variable&gt; {
        given $&lt;variable&gt;&lt;sigil&gt; {
            when '$' {
                %scalar{$&lt;variable&gt;&lt;identifier&gt;} = 'undefined';
            }
            when '@' {
                %array{$&lt;variable&gt;&lt;identifier&gt;} = 'undefined';
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在程序结束之前, 让我们打印变量存储的内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %scalar;
say %array;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出告诉我们成功找到了变量, 并在存储中为它们创建插槽:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">{x =&gt; undefined}
{array =&gt; undefined}</code></pre>
</div>
</div>
<div class="paragraph">
<p>想想下一步。当然, 将值赋给变量会很棒。 在上面的代码中, 我们使用 <code>given/when</code> 选择器分隔标量代码和数组代码。如果我们想添加对哈希的支持该怎么办? 添加一个新的 <code>when</code> 分支没问题, 但是我们必须在所有与变量一起使用的 action 中做出类似的分支。</p>
</div>
<div class="paragraph">
<p>其中一个解决方案是要求 grammar 区分变量的类型:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token variable {
    | &lt;scalar-variable&gt;
    | &lt;array-variable&gt;
}
token scalar-variable {
    '$' &lt;identifier&gt;
}
token array-variable {
    '@' &lt;identifier&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个解决方案是把变量存储成为单个变量 <code>%var</code> 并将其用作两维哈希:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %var;
# .. .
rule variable-declaration {
    'my' &lt;variable&gt; {
        %var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;} =
            'undefined';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这个, <code>%var</code> 容器将获得以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">{$ =&gt; {x =&gt; undefined}, @ =&gt; {array =&gt; undefined}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要为变量赋值, 应该写一个 action。Grammar 已经有了赋值规则, 因此添加 action 是一项简单的任务:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule assignment {
    &lt;variable&gt; '=' &lt;value&gt; {
        %var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;} =
            ~$&lt;value&gt;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 action 内部赋值的左侧, 我们看到相同的代码, 我们已经用它访问 <code>%var</code> 存储中的变量。右侧的表达式需要额外注意。</p>
</div>
<div class="paragraph">
<p>裸的 <code>$&lt;value&gt;</code> 当前包含 <code>G</code> 类型的对象。要使它成为字符串, 使用字符串强制运算符(前缀 <code>~</code>)。因此, 它将被字符串化并且变量得到我们想要在那里保存的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">{$ =&gt; {x =&gt; 100}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了确认所有工作都按预期工作, 让我们解析一个使用两个标量变量的程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $prog = q:to/END/;
my $alpha;
$alpha = 50;
say $alpha;

my $beta;
$beta = 60;
say $beta;
END

G.parse($prog);
say %var; # {$ =&gt; {alpha =&gt; 50, beta =&gt; 60}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在让我们将注意力转移到实现 <code>say</code> 函数上。这个任务应该不难, 因为我们已经拥有其他规则和 action 中的所有代码片段。把它们组合起来:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule say-function {
    'say' &lt;variable&gt; {
        say %var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;};
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 编译器理解三种语法结构 - 声明变量, 赋值, 并打印标量变量的内容。作为家庭作业, 你可以实现程序想要使用未声明的变量或仍包含未定义的值时的错误处理。</p>
</div>
<div class="paragraph">
<p>这个 grammar 已经相当复杂, 但给它添加越来越多的功能并不是很困难。每个新功能通常需要修改现有规则和 action 或添加新的规则和 action。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用抽象语法树">12.4. 使用抽象语法树</h3>
<div class="paragraph">
<p>目前, <code>G</code> grammar 仅在将整数值赋值给变量时解析构造:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$x = 100;</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们看看如何添加对以下赋值的支持:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$x = $y;</code></pre>
</div>
</div>
<div class="paragraph">
<p>解析 <code>$x = 100</code> 等结构的规则使用了以下规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule assignment {
    &lt;variable&gt; '=' &lt;value&gt; { . . . }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在等号的右侧, 我们看到一个 <code>value</code>, 我们可以用更一般的项, <code>expression</code> 代替。最后, 表达式可以是任何语言理解的表达式, 例如 <code>10</code>, <code>$x</code>, <code>10 + 3</code> 或 <code>$x + $y</code> 等等。让我们一步一步地接近这一点。首先, 介绍 <code>expression</code> 规则。问题是我们必须将表达式的值返回给进行赋值的 action。</p>
</div>
<div class="paragraph">
<p>为了保留临时值, Raku grammar 提供了<strong>抽象语法树的属性(AST)</strong>。要保存该值, 请使用 <code>$/.make</code> 方法。要获得该值, 请使用 <code>$/.made</code> 或 <code>$/.ast</code> 方法(他们是同义词):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule assignment {
    &lt;variable&gt; '=' &lt;expression&gt; {
        %var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;} =
            $&lt;expression&gt;.made;
    }
}
rule expression {
    | &lt;value&gt; {
          $/.make(~$&lt;value&gt;)
      }
    | &lt;variable&gt; {
          $/.make(%var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;})
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用 <code>$/.make</code> 方法传递的值是附加到解析树节点的属性。执行 action 后, 这些值不会消失, 并且其他规则的 action 通过 <code>$/</code> 变量仍然可以访问该值。</p>
</div>
<div class="paragraph">
<p>例如, 在前面的代码中, <code>expression</code> 规则的第一个分支中解析的字符串化值被附加到相应的节点 - <code>$/.make(~$ &lt;value&gt;)</code>。随后, 此值用于 <code>assignment</code> action <code>$&lt;expression&gt;.made</code>。我们在第 11 章, 正则表达式中已经见过, 即 <code>$&lt;expression&gt;</code> 是完整表达式 <code>$/&lt;expression&gt;</code> 的简写形式。</p>
</div>
<div class="paragraph">
<p>当 grammar 符合诸如 <code>$x = $y</code> 的赋值时, 表达式规则的第二个分支变为活动状态。在这种情况下, 它从 <code>%var</code> 存储获取变量的值并将其放在 AST 属性中。此时, 我们的编译器可以处理以下程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;
$x = 100;

my $y;
$y = $x;
say $y; # 100</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_处理表达式">12.4.1. 处理表达式</h4>
<div class="paragraph">
<p>在许多旨在用不同编程语言解析源代码的 grammar 中, 其中一个核心部分是处理表达式。我们已经介绍了 <code>expression</code> 规则, 它可以理解简单的表达式, 如 <code>100</code> 或 <code>$x</code>。</p>
</div>
<div class="paragraph">
<p>让我们继续使用表达式并教导编译器使用 <code>+</code> 运算符解析和计算表达式。我们将从一个简单的情况开始, 即当两个操作数都是整数字面量时:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
    | &lt;value&gt; '+' &lt;value&gt; {
          $/.make($&lt;value&gt;[0].ast + $&lt;value&gt;[1].ast)
      }
    | &lt;value&gt; {
          $/.make(~$&lt;value&gt;)
      }
    | &lt;variable&gt; {
          $/.make(%var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;})
      }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该规则得到了一个新的分支 <code>&lt;value&gt; '+' &lt;value&gt;</code>, 它使用了两个相同的规则名。在 action 中, 这两个操作数是从数组的两个元素的 <code>ast</code>(或 <code>make</code>)属性中提取的 - 即 <code>$&lt;value&gt;[0]</code> 和 <code>$&lt;value&gt;[1]</code>。</p>
</div>
<div class="paragraph">
<p>应该在 <code>value</code> token 中进行另一个更改。到现在为止, 我们还没有在 AST 中保存任何内容。如果你不这样做, 那么进一步的解析将不得不处理复杂的结构而不是简单的值。所以只需将其添加到树中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token value {
    &lt;number&gt; {$/.make(+$&lt;number&gt;)}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此处使用前缀 <code>+</code> 将值转换为数字类型。</p>
</div>
<div class="paragraph">
<p>下一步是允许变量, 以便我们可以解析 <code>3 + $x</code> 等表达式。</p>
</div>
<div class="paragraph">
<p>正如我们之前看到的, <code>expression</code> 规则可以表示变量的值。那么, 让我们把 <code>expression</code> 规则中的第二个 <code>value</code> 替换为 <code>expression</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
    | &lt;value&gt; '+' &lt;expression&gt; {
          $/.make($&lt;value&gt;.ast + $&lt;expression&gt;.ast)
      }
    | &lt;value&gt; {
          $/.make(~$&lt;value&gt;)
      }
    | &lt;variable&gt; {
          $/.make(%var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;})
      }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外, 更新 <code>variable</code> 规则以在 AST 中保存变量的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token variable {
    &lt;sigil&gt; &lt;identifier&gt; {
        $/.make(%var{$&lt;sigil&gt;}{$&lt;identifier&gt;})
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是将变量用作 <code>+</code> 运算符的第二个操作数所需的全部内容。该 grammar 现在解析这个程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;
my $y;

$x = 3;
$y = 4 + $x;

say $y; # 7</code></pre>
</div>
</div>
<div class="paragraph">
<p>允许 <code>+</code> 运算符左侧的变量有点困难。到目前为止, 我们已经在我们可能期望变量的地方使用了 <code>expression</code> 规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
    | &lt;value&gt; '+' &lt;expression&gt;
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>只将左侧的 <code>value</code> 更改为 <code>expression</code> 是不行的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
    | &lt;expression&gt; '+' &lt;expression&gt;
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种更改导致无限递归 - 要表达式是什么你需要解析解析表达式, 它是表达式加表达式等等。一种可能的解决方案是隐式列出第一个可以是操作数的选项:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
    | &lt;value&gt; '+' &lt;expression&gt; {
          $/.make($&lt;value&gt;.ast + $&lt;expression&gt;.ast)
      }
    | &lt;variable&gt; '+' &lt;expression&gt; {
          $/.make($&lt;variable&gt;.ast + $&lt;expression&gt;.ast)
      }
    | &lt;value&gt; {
          $/.make(~$&lt;value&gt;)
      }
    | &lt;variable&gt; {
          $/.make(%var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;})
      }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>更好的方法是引入另一个规则, <code>term</code>, 可以是 <code>value</code> 或 <code>variable</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
    | &lt;term&gt; '+' &lt;expression&gt; {
          $/.make($&lt;term&gt;.ast + $&lt;expression&gt;.ast)
      }
    | &lt;value&gt; {
          $/.make(~$&lt;value&gt;)
      }
    | &lt;variable&gt; {
          $/.make(%var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;})
      }
}
rule term {
    | &lt;value&gt; {$/.make($&lt;value&gt;.ast)}
    | &lt;variable&gt; {$/.make($&lt;variable&gt;.ast)}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>目前可以做些什么?  微小的(已经相当复杂的)Raku 语言的子集程序可以解析和执行了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;
my $y;

$x = 3;
$y = 4 + $x;
say $y; # 7

my $z;
$z = $x + $y;
say $z; # 10

my $a;
$a = $z + 5;
say $a; # 15</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为奖励, 程序还可以解析涉及 <code>+</code> 运算符的复杂表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $b;
$b = $a + $x + $y + $z + 7;
say $b; # 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们没有做任何特别的事情来允许它工作, 但 grammar 将表达式分割为简单的表达式, 如 <code>$a + $x</code>, 计算值, 然后更进一步。伴随着每一个步骤, 执行具有两个操作数的简单运算。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用_action_类">12.5. 使用 action 类</h3>
<div class="paragraph">
<p>Grammar 越复杂, action 就越复杂。我们当前 grammar 中几乎所有 rule 或 token 有一个 action。即使大多数 action 只是一两行代码, Raku 代码与 grammar 语言混合的事实让阅读代码变得很困难。格式化代码也成为一项艰巨的任务, 因为你需要添加更多空格以正确缩进代码。在本节中, 我们将看到 Raku 提供了什么来解决这个问题。</p>
</div>
<div class="paragraph">
<p>所有的 action 都可以移动到单独的类中。因此, 完整的 grammar 包含一个 grammar 本身和 action 类。grammar 的 rule 与 token 之间的对应关系是通过简单地为 action 类给出相同的名字来实现的。让我们将 grammar 转换为使用拆分方法。</p>
</div>
<div class="paragraph">
<p>首先, 为 action 创建一个类并将其传递给解析器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> grammar G {
    ...
}
class A {
    ...
}
...

G.parse($prog, :actions(A));</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 将 action 代码从 grammar 的 rule 或 token 中移动到单独的 action 类的方法中。</p>
</div>
<div class="paragraph">
<p>举例来说, <strong>variable</strong> 规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token variable {
    &lt;sigil&gt; &lt;identifier&gt; {
        $/.make(%var{$&lt;sigil&gt;}{$&lt;identifier&gt;})
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码应分为 grammar 规则和 action:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
    ...
    token variable {
        &lt;sigil&gt; &lt;identifier&gt;
    }
    ...
}
class A {
    ...
    method variable($/) {
        $/.make(%var{$&lt;sigil&gt;}{$&lt;identifier&gt;})
    }
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于代码现在放在 grammar 之外, 我们必须传递 <code>$/</code> 变量作为方法的参数。可以为此参数使用任何其他名称, 但 <code>$/</code> 似乎是最常见和最常规的选择。</p>
</div>
<div class="paragraph">
<p>以相同的方式, 可以提取其他 action 并将其放入 action 类中。我们不会花时间描述那些重复的代码更改(你可以在本章的最后看到最终代码)但我们将直接查看具有备选项的规则。此 grammar 中有两个这样的规则, 即 <code>expression</code> 和 <code>term</code>。</p>
</div>
<div class="paragraph">
<p>考虑 <strong>term</strong> 规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> rule term {
    | &lt;value&gt; {$/.make($&lt;value&gt;.ast)}
    | &lt;variable&gt; {$/.make($&lt;variable&gt;.ast)}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们在这里有两个不同的 action, 但我们只能在 action 类中添加一个方法。</p>
</div>
<div class="paragraph">
<p>至少有三种解决方案。首先, 该规则可以分为两个规则, 因此分为两个单独的 action。其次, 我们可以分析 <code>$/</code> 变量的内容并执行其中的一个分支:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method term($/) {
    if $&lt;value&gt; {
        $/.make($&lt;value&gt;.ast)
    }
    elsif $&lt;variable&gt; {
        $/.make($&lt;variable&gt;.ast)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是 Raku 为我们提供了更好的选择 - 使用 <code>multi</code> 方法并使它们对 <code>$/</code> 参数中接收到的数据变得敏感:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method term($/ where $/&lt;value&gt;) {
    $/.make($&lt;value&gt;.ast)
}
multi method term($/ where $/&lt;variable&gt;) {
    $/.make($&lt;variable&gt;.ast)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在方法的签名中, 创建子类型。<code>multi</code> 方法的每个变体都是响应规则的不同分支的匹配而调用。我们在第 6 章的 Multi subs 中用了这个技巧。</p>
</div>
<div class="paragraph">
<p>在将所有的 action 移动到单独的类中之后, 移动全局变量 <code>%var</code> 到类中也是明智的。目前, 整个程序的骨架如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
    ...
}

class A {
    my %var;
    ...
}

G.parse($prog, :actions(A));</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>%var</code> 存储现在是类属性 - 它属于类, 而不属于它的实例。 实际上, 我们不创建 <code>A</code> 的任何实例-<code>G.parse</code> 方法接收类的名字。这可能适用于某些应用程序, 但要确保变量存储不保留先前运行的解析器的值, 最好使 <code>%var</code> 变为私有属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    has %!var;
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该类需要首先实例化。否则, 将不会为 <code>%var</code> 属性分配内存。<code>parse</code> 方法还接受 <code>action</code> 类的实例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">G.parse($prog, :actions(A.new));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_完整的程序">12.6. 完整的程序</h3>
<div class="paragraph">
<p>通过了解 Raku 中的 grammar, 我们取得了很多成就。想象一下我们所创建的程序可以解析用 Raku 编写的另一个程序!</p>
</div>
<div class="paragraph">
<p>仍有很大的改进空间, 但你一定能做到这一点。例如, 你可以从实现对数组的支持开始。</p>
</div>
<div class="paragraph">
<p>以下是我们在本章中创建的编译器的完整代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
    rule TOP {
        ^
            [ &lt;statement&gt; \s* &lt;comment&gt;? ]*
        $
    }
    rule statement {
        [
            | &lt;variable-declaration&gt;
            | &lt;assignment&gt;
            | &lt;say-function&gt;
        ]
        ';'
    }
    rule comment {
        '#' &lt;-[\n]&gt;*
    }
    rule variable-declaration {
        'my' &lt;variable&gt;
    }
    token variable {
        &lt;sigil&gt; &lt;identifier&gt;
    }
    token sigil {
        '$' | '@'
    }
    token identifier {
        &lt;alpha&gt; &lt;alnum&gt;*
    }
    rule assignment {
        &lt;variable&gt; '=' &lt;expression&gt;
    }
    rule expression {
        | &lt;term&gt; '+' &lt;expression&gt;
        | &lt;value&gt;
        | &lt;variable&gt;
    }
    rule term {
        | &lt;value&gt;
        | &lt;variable&gt;
    }
    token value {
        &lt;number&gt;

    }
    token number {
        &lt;digit&gt;+
    }
    rule say-function {
        'say' &lt;variable&gt;
    }
}

class A {
    has %!var;
    method variable-declaration($/) {
        %!var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;} =
            'undefined';
    }
    method variable($/) {
        $/.make(%!var{$&lt;sigil&gt;}{$&lt;identifier&gt;})
    }
    method assignment($/) {
        %!var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;} =
            $&lt;expression&gt;.ast;
    }
    method value($/) {
        $/.make(+$&lt;number&gt;)
    }
    method say-function($/) {
        say %!var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;};
    }
    multi method term($/ where $/&lt;value&gt;) {
        $/.make($&lt;value&gt;.ast)
    }
    multi method term($/ where $/&lt;variable&gt;) {
        $/.make($&lt;variable&gt;.ast)
    }
    multi method expression($/ where $/&lt;term&gt;) {
        $/.make($&lt;term&gt;.ast + $&lt;expression&gt;.ast)
    }

    multi method expression($/ where $/&lt;value&gt;) {
        $/.make(~$&lt;value&gt;)
    }
    multi method expression($/ where $/&lt;variable&gt;) {
        $/.make(%!var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;})
    }
}

my $prog = q:to/END/;
my $x;
$x = 5;
say $x;# 5
my $y;
$y = $x;
say $y; # 5
my $z;
$z = $x + $y;
say $z; # 10
my $sum;
$sum = 10 + 12 + $x + $y + $z;
say $sum; # 42
END

G.parse($prog, :actions(A.new));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_15">12.7. 总结</h3>
<div class="paragraph">
<p>在本章中, 我们讨论了 grammar, 这是 Raku 领先的新功能。Grammar 允许为你自己的特定领域的语言构建解析器, 并且已经内置在语言中, 因此无需外部模块即可开始使用它们。</p>
</div>
<div class="paragraph">
<p>使用 Raku 子集的编译器示例, 我们创建了一个 grammar 并查看了它的元素 - rule 和 token。后来我们用 action 更新了 grammar, 最后将 action 移动到一个单独的类中, 以使代码更易于维护和清理。</p>
</div>
<div class="paragraph">
<p>在接下来的章节中, 我们将讨论 Raku 中的并发, 反应式和函数式编程。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_并发编程">13. 并发编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 是一种完全在二十一世纪创建的语言。这并不奇怪, 它内置了对一些基本概念的支持，这使得它易于创建支持并行和并发编程的应用程序。</p>
</div>
<div class="paragraph">
<p>在本章中，我们将介绍以下主题。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Junction</p>
</li>
<li>
<p>线程</p>
</li>
<li>
<p>Promise</p>
</li>
<li>
<p>通道</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_junction">13.1. Junction</h3>
<div class="paragraph">
<p>Junction 是 Raku 可以并行工作的最简单的例子之一。在编写本书时可用的 Rakudo 版本中，此功能尚未完全实现。</p>
</div>
<div class="paragraph">
<p>Junction 是一个可以同时保留多个值的值。检查以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $j = 1 | 3 | 5;
say 'OK' if $j == 3;
say 'Not OK' if $j != 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>变量 <code>$j</code> 是一个持有三个奇数，<code>1</code>, <code>3</code> 和 <code>5</code> 的 junction。你可以将 <code>$j</code> 与整数进行比较，如果该值是 junction 所存储的值之一，则得到布尔值 <code>True</code>。在与 3 进行比较时，结果为 <code>True</code>，而与 <code>2</code> 的第二个比较则失败了。</p>
</div>
<div class="sect3">
<h4 id="_自动线程化">13.1.1. 自动线程化</h4>
<div class="paragraph">
<p>现在尝试将 junction 传递给一个接收标量的函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($x) {
    say $x;
    return $x;
}

say 'OK' if f(1 | 3 | 5) == 3;
say 'Not OK' if f(1 | 3 | 5) != 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该函数的行为直观易懂 - 分别对 junction 的每个值执行该函数。然后，该函数的返回值将用作 junction 的值。</p>
</div>
<div class="paragraph">
<p>上面的代码与以下代码的作用相同，其中函数接收单个标量值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'OK' if f(1) | f(3) | f(5) == 3;
say 'Not OK' if f(1) | f(3) | f(5) != 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>把 junction 操作移动到函数参数外面被称作<strong>自动线程化</strong>。理论上，最后一个例子的代码可以并行执行。</p>
</div>
<div class="paragraph">
<p>现在，让我们转到下一个主题，看看我们如何明确地创建线程。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_线程">13.2. 线程</h3>
<div class="paragraph">
<p>在 Raku 中，有 <code>Thread</code> 类，它负责创建和运行线程。要查看你当前在哪个线程中，请使用 <code>$*THREAD</code> 伪常量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $*THREAD;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它返回一个 <code>Thread</code> 类的值，并且它的默认字符串化表示形式为包含标识符和线程名称的字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Thread #1 (Initial thread)</code></pre>
</div>
</div>
<div class="paragraph">
<p>不要依赖线程标识符的特定值，因为即使对于主线程，标识符也可能不同。</p>
</div>
<div class="sect3">
<h4 id="_开启线程">13.2.1. 开启线程</h4>
<div class="paragraph">
<p>在本节和以下小节中，我们将研究 <code>Thread</code> 类的方法。但是，我们将从 <code>start</code> 方法开始，该方法创建一个线程并开始执行。</p>
</div>
<div class="paragraph">
<p>在以下示例中，创建了三个线程。他们每个都接收一个名字和一个代码块。在每个线程中代码块做相同的工作，并且只打印 <code>$*THREAD</code> 变量的值，这个变量的值在不同的线程中是不同的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $*THREAD;

my $t1 = Thread.start(name =&gt; 'Test 1', sub {say $*THREAD});
my $t2 = Thread.start(name =&gt; 'Test 2', sub {say $*THREAD});
my $t3 = Thread.start(name =&gt; 'Test 3', sub {say $*THREAD});

say $t1.WHAT;
say $t2.WHAT;
say $t3.WHAT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行该程序，看看它打印的内容。你的输出可能与以下片段不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Thread #1 (Initial thread)
Thread #4 (Test 1)
Thread #5 (Test 2)
(Thread)
Thread #6 (Test 3)
(Thread)
(Thread)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见，程序从四个不同的线程中打印 - <strong>初始线程 <code>#1</code></strong> 和我们创建的三个线程。他们获得标识符 <code>3</code>, <code>4</code> 和 <code>5</code>。Rakudo 开发人员告诉我，<strong>线程 <code>#2</code></strong> 可能由虚拟机在启动期间使用。再强调一下，这些数字的主要特性是它们是唯一的，但不一定按顺序排列。</p>
</div>
<div class="paragraph">
<p>还要注意不同线程的输出是重叠的。多次运行程序很有可能产生不同的结果。</p>
</div>
<div class="paragraph">
<p>线程是在调用 <code>Thread.start</code> 时创建的，然后执行返回到主线程。最简单的查看方法是在用作线程代码块的子例程中嵌入不同的延迟。</p>
</div>
<div class="paragraph">
<p>在以下程序中，创建了三个匿名线程（在某种意义上它们不保存在变量中）。他们的名字不同，还有它们在主体中产生的延迟和输出也不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $*THREAD;

Thread.start(
    name =&gt; 'Sleep 3 seconds',
    sub {
        say $*THREAD;
        sleep 3;
        say 1;
    }
);

Thread.start(
    name =&gt; 'Sleep 2 seconds',
    sub {
        say $*THREAD;
        sleep 2;
        say 2;
    }
);

Thread.start(
    name =&gt; 'Sleep 1 second',
    sub {
        say $*THREAD;
        sleep 1;
        say 3;
    }
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它，这是你将在控制台中得到的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Thread #1 (Initial thread)
Thread #4 (Sleep 3 seconds)
Thread #5 (Sleep 2 seconds)
Thread #6 (Sleep 1 second)
3
2
1</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序开始后立即打印了前四行，而其余的延迟打印 - 每个数字在延迟 1 秒后打印。因此，<code>Thread.start</code> 创建一个线程并退出，而该线程与主程序（以及其他线程）并行地执行。</p>
</div>
<div class="paragraph">
<p>由于线程并行工作，因此无法预测它们将产生副作用的顺序（例如打印到控制台）。查看创建两个线程的程序，每个线程打印五个数字。第一个线程打印从 1 到 5 的数字，而第二个线程打印从 11 到 15 的数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Thread.start(sub {
    .say for 1..5;
});

Thread.start(sub {
    .say for 11..15;
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>两个线程都是并行执行的。 语言规范中没有定义实际的实现，无论代码是分发到处理器的不同内核上还是通过为线程分配专用的时间原子来初始化线程，因此在 Raku 中创建线程时，您不应指望这两种实现。</p>
</div>
<div class="paragraph">
<p>运行该程序几次，可以看到每次结果都是不同的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">1
11
12
2
3
13
4
5
14
15</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二个线程也可能在第一个线程之前开始打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">11
1
2
12
13
3
14
15
4
5</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>Thread.start</code> 方法很简单，但在某些情况下，你可能希望更好地控制线程的创建和运行。</p>
</div>
</div>
<div class="sect3">
<h4 id="_创建并运行新线程">13.2.2. 创建并运行新线程</h4>
<div class="paragraph">
<p>要创建线程对象，请使用 <code>Thread</code> 类的构造函数。它以相应的命名参数 <code>name</code> 和 <code>code</code> 接收线程名称和代码块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t = Thread.new(
    name =&gt; 'My thread',
    code =&gt; sub {
        say 'Hi there!';
    }
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>线程现在已创建但未激活。要运行它，必须调用 <code>run</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$t.run();</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行以下示例并检查屏幕上行的显示顺序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t = Thread.new(
    name =&gt; 'My thread',
    code =&gt; sub {
        say 'Start';
        sleep 2;
        say 'End';
    }
);

say 'Before';
$t.run();
say 'After';</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦线程运行起来, 它打印两条信息, <code>Start</code> 和 <code>End</code>, 两者之间有 2 秒的延迟:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Before
After
Start
End</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以推迟主程序，直到线程完成其工作。使用 <code>finish</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Before';
$t.run();
$t.finish();
say 'After';</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序将一直等待直到线程代码块完成其工作，然后才从下一条指令继续:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Before
Start
End
After</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>finish</code> 方法有一个同义词 <code>join</code> - <code>$t.join()</code>，它与 <code>$t.finish()</code> 完全相同。</p>
</div>
</div>
<div class="sect3">
<h4 id="_id_和_name_方法">13.2.3. id 和 name 方法</h4>
<div class="paragraph">
<p>在"开启新线程"一节中，我们已经看到了一些标识符被分配给新线程的示例。在 <code>Thread</code> 类中，有一个返回 <code>id</code> 的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $*THREAD;

my $t1 = Thread.start(sub {});
my $t2 = Thread.start(sub {});
my $t3 = Thread.start(sub {});

say $t1.id();
say $t2.id();
say $t3.id();</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序的可能输出之一是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">3
4
5</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如，如果要在主线程中保留一些跟踪信息，可以使用线程标识符。</p>
</div>
<div class="paragraph">
<p>识别线程的另一种方法是使用名字。名字是你通过 <code>name</code> 参数创建线程时指定的字符串标签:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t1 = Thread.start(name =&gt; 'My thread one', sub {});
my $t2 = Thread.start(name =&gt; 'My thread two', sub {});
my $t3 = Thread.start(name =&gt; 'My thread three', sub {});

say $*THREAD.name();
say $t1.name();
say $t2.name();
say $t3.name();</code></pre>
</div>
</div>
<div class="paragraph">
<p>主线程的名字是 <code>Initial thread</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Initial thread
My thread one
My thread two
My thread three</code></pre>
</div>
</div>
<div class="paragraph">
<p>名字不必是唯一的，因此你可以自由选择任何你想要的名字。</p>
</div>
</div>
<div class="sect3">
<h4 id="_将线程对象打印为字符串">13.2.4. 将线程对象打印为字符串</h4>
<div class="paragraph">
<p>当通过 <code>say</code> 函数打印线程对象时，<code>Thread</code> 类的 <code>Str</code> 方法定义了线程对象的行为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t1 = Thread.start(name =&gt; 'My thread one', sub {});
my $t2 = Thread.start(name =&gt; 'My thread two', sub {});
my $t3 = Thread.start(name =&gt; 'My thread three', sub {});

say $*THREAD;
say $t1;
say $t2;
say $t3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认字符串包含线程的编号及其名字(如果已定义)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Thread #1 (Initial thread)
Thread #3 (My thread one)
Thread #4 (My thread two)
Thread #5 (My thread three)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，所有线程都具有不同的ID(它们始终不同)且不同的名字(由程序员定义)。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_终身线程">13.3. 终身线程</h3>
<div class="paragraph">
<p>创建新线程时，可以设置 <code>app_lifetime</code> 属性，请求该线程一直存在，直到主程序结束。否则它会在其主体执行后终止。要添加此标志，请将其添加为 <code>:app_lifetime</code> 或通过显式将 <code>True</code> 值传递给构造函数-<code>app_lifetime &#8658; True</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Thread.new(
    name =&gt; 'Long thread',
    code =&gt; sub {
        say 'OK';
    },
    :app_lifetime,
).run().join();

say 'Done';</code></pre>
</div>
</div>
<div class="paragraph">
<p>等待线程很重要(使用 <code>finish</code> 或 <code>join</code> 方法)。否则主线程可能会在该线程返回之前停止执行。</p>
</div>
<div class="sect3">
<h4 id="_在_raku_中使用锁">13.3.1. 在 Raku 中使用锁</h4>
<div class="paragraph">
<p>Raku 提供了一种确保代码的特定部分仅由单个线程执行的机制。如果有其他线程想从此代码中访问变量，他们应该等到它解锁。</p>
</div>
<div class="paragraph">
<p>要包含关键代码，请使用 <code>Lock</code> 类的 <code>protect</code> 方法。检查一下以下来自 Raku 文档的示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 0;
my $l = Lock.new;
await (^10).map: {
    start {
        $l.protect({ $x++ });
    }
}
say $x; # OUTPUT: «10␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将在本章后面的工厂方法一节中讨论 <code>await</code> 函数。</p>
</div>
<div class="paragraph">
<p>关键代码以这种方式受到保护，每次只有一个线程可以访问 <code>$x</code> 计数器。</p>
</div>
<div class="paragraph">
<p>建议不要直接使用锁，因为它们提供的接口太低级。 相反，使用承诺，通道和供应。我们稍后会在本章中讨论前两个概念，供应将在第十五章的反应式编程中讨论。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_promise">13.4. Promise</h3>
<div class="paragraph">
<p>在上一节中，我们创建了一些并行运行的代码块。 承诺有助于了解这种块的完成状态。在 Raku 中，承诺由 <code>Promise</code> 类处理。</p>
</div>
<div class="sect3">
<h4 id="_创造一个承诺">13.4.1. 创造一个承诺</h4>
<div class="paragraph">
<p>要创建一个承诺，只需调用 <code>Promise</code> 类的构造函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.new();</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建好的对象什么也没做。在本章后面的工厂方法一节中，我们将看到如何创建执行某些代码的承诺。同时，让我们看看承诺所具有的属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_承诺的状态">13.4.2. 承诺的状态</h4>
<div class="paragraph">
<p>承诺的力量是它们可以被保留或破坏，你可以跟踪他们。通过调用 <code>Promise.new</code> 创建的新承诺既不保留也不破坏。它的状态是 <code>Planned</code>。要查看状态，请调用 <code>status</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.new();
say $promise.status(); # Planned</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Promise</code> 类还为我们提供了一对方法，<code>keep</code> 和 <code>break</code>，这些方法把承诺的状态更改为 <code>Kept</code> 或 <code>Broken</code>。这在以下示例中进行了演示，其中一个承诺被标记为保留，而第二个承诺被强制破坏:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise1 = Promise.new();
my $promise2 = Promise.new();

$promise1.keep();
$promise2.break();

say $promise1.status();
say $promise2.status();</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Kept
Broken</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，在我们知道如何更改承诺的状态以及如何读取它之后，我们将使用承诺并行地执行代码。</p>
</div>
</div>
<div class="sect3">
<h4 id="_工厂方法">13.4.3. 工厂方法</h4>
<div class="paragraph">
<p>让我们从一个简单的程序开始，该程序使用打印某些东西然后退出的代码块创建一个承诺。<code>Promise.start</code> 方法创建一个块并返回一个承诺。 请注意，返回的值是一个承诺，而不是线程。使用 <code>await</code> 函数等待直到该承诺的代码块完成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.start({
    say 'I am a promise';
});
await $promise;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序等待直到代码块打印消息并退出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">I am a promise</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，<code>start</code> 例程作为 <code>Promise</code> 类的方法调用。 或者，可以通过独立的 <code>start</code> 函数创建承诺:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = start {
    say 'I am a promise';
};
await $promise;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，代码块周围没有圆括号。</p>
</div>
<div class="paragraph">
<p>让我们修改前面的例子并创建一个只能睡一秒钟的承诺。创建承诺后，立即首次打印其状态。这里的一秒延迟是重要的，以确保在我们检查下一行的承诺的状态之前承诺没有完成它的工作。</p>
</div>
<div class="paragraph">
<p>然后，<code>await</code> 等待直到承诺的代码完成，并第二次检查承诺的状态:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.start({
    sleep 1;
});

say $promise.status;
await $promise;
say $promise.status;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是程序打印的内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Planned
Kept</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了处理时间，可以使用另一个工厂方法 <code>Promise.in</code> 而不是使用 <code>start</code> 和 <code>sleep</code> 的组合。它创造了一种在给定的秒数后状态变为保留的承诺:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.in(2);
await $promise;
say 'Done';
say $promise.status; # Kept</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序创建并等待承诺。2 秒后，承诺状态变为保留，程序继续。承诺的状态在此之后变为 <code>Kept</code> 状态。</p>
</div>
</div>
<div class="sect3">
<h4 id="_承诺的结果">13.4.4. 承诺的结果</h4>
<div class="paragraph">
<p>承诺的另一个有趣特征是它们可以返回结果。结果是由代码块计算，最后计算的值是返回值。考虑一下以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.start({
    sleep 1;
    'Result'; # no return keyword!
});

await $promise;
say $promise.result;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，代码块返回一个字符串 <code>Result</code>，然后在 <code>$promise</code> 变量上调用 <code>result</code> 打印承诺的结果。</p>
</div>
<div class="paragraph">
<p>从逻辑上讲，结果仅在保留承诺后才可用。在之前的例子中，使用了明确的 <code>await</code>。实际上，它是多余的，因为 <code>result</code> 方法的调用将等到代码完成。因此，代码可以简化为如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.start({
    sleep 1;
    'Result';
});

say $promise.result; # waits</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_组合承诺">13.4.5. 组合承诺</h4>
<div class="paragraph">
<p>在实际的程序中，可以使用多个承诺。结合不同的承诺可以提供非常有表现力的方法来编码代码的不同部分之间的复杂关系。</p>
</div>
<div class="paragraph">
<p>让我们从一个简单的例子开始，使用独立的 <code>start</code> 函数创建三个承诺:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Start';
await
    start {sleep 2; say 2;},
    start {sleep 3; say 3;},
    start {sleep 1; say 1;};
say 'Done';</code></pre>
</div>
</div>
<div class="paragraph">
<p>目标是暂停程序，直到保留所有承诺。正如你从这个例子中看到的那样，<code>await</code> 函数接受一个承诺列表并等待直到所有承诺都完成。程序的输出如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Start
1
2
3
Done</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个承诺创建一个单独的线程，通过打印 <code>$*THREAD</code> 变量可以清楚地看到它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">await
    start {say $*THREAD;},
    start {say $*THREAD;},
    start {say $*THREAD;};</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个 <code>start</code> 创建它自己的线程:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Thread #3
Thread #5
Thread #4</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_保留过破坏承诺后执行代码">13.4.6. 保留过破坏承诺后执行代码</h4>
<div class="paragraph">
<p><code>Promise</code> 类有 <code>then</code> 方法，可用于绑定承诺被保留或被破坏后将要执行的代码。实际上，这种方法创建并返回一个新的承诺，它将在初始承诺状态更改后运行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.in(1);
my $next = $promise.then({
    say 'Done';
});
await $next;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序在启动一秒后打印 <code>Done</code>。第一个承诺，保存在 <code>$promise</code> 变量中，在给定的时间延迟后状态变为保留。然后，<code>then</code> 创建另一个承诺，它保存在 <code>$next</code> 变量中。要连接到主程序，有必要等到 <code>$next</code> 打印输出，从而完成。</p>
</div>
</div>
<div class="sect3">
<h4 id="_anyof_和_allof_方法">13.4.7. anyof 和 allof 方法</h4>
<div class="paragraph">
<p><code>Promise</code> 类中的两个方法，<code>anyof</code> 和 <code>allof</code>，创建了一个新的保留的承诺, 当承诺的任何一个或所有承诺都被保留时。这两个方法接受一个承诺列表。</p>
</div>
<div class="paragraph">
<p>让我们在下面的例子中说明 <code>anyof</code> 方法的运作，它检查长时间运行的代码是否执行时间过长:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $timeout = Promise.in(2).then({
       say 'Timeout'
});
my $long_code = start {
    sleep 3;
    say 'Work done';
};

await Promise.anyof($timeout, $long_code);
say 'Continuing';</code></pre>
</div>
</div>
<div class="paragraph">
<p>这创造了两个承诺。<code>$timeout</code> 这个在创建承诺后保存了2 秒。<code>$long_code</code> 模仿代码的缓慢部分，执行时间比计时器能等待的时间更长 。然后，这两个承诺都传递给 <code>Promise.anyof</code> 方法，该方法返回另一个承诺，在发生超时或执行长时间运行的代码时其承诺状态变为保留。</p>
</div>
<div class="paragraph">
<p>使用不同的延迟组合运行此程序，并查看此程序的不同输出结果。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_通道">13.5. 通道</h3>
<div class="paragraph">
<p>通道是一种可用于从一段代码到另一段代码传递数据的通信方式。关于通道的好处是它们是线程兼容的，因此它可以让不同的线程相互通信。在本节中，我们将学习如何使用 Raku 中的通道。</p>
</div>
<div class="sect3">
<h4 id="_基本用例">13.5.1. 基本用例</h4>
<div class="paragraph">
<p>通道由 <code>Channel</code> 类定义。要创建新的通道变量，请调用构造函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们可以使用 <code>send</code> 方法把数据发送到通道中并使用 <code>receive</code> 方法接收它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new;
$channel.send(42);

my $value = $channel.receive();
say $value;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序做了很小的事情 - 它把值发送到通道中并立即读取它。该程序通过通道打印值 <code>42</code>。</p>
</div>
<div class="paragraph">
<p>现在，让我们修改程序并在其中引入第二个线程，以便通道填充在该线程中，结果在主程序中读取:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new();
start {
    $channel.send(42);
};

my $value = $channel.receive;
say $value;</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行的结果与之前相同，打印出了 42，而传递值的逻辑完全不同。</p>
</div>
<div class="paragraph">
<p><code>receive</code> 方法一直等待直到通道有足够的数据要读取。如果我们给线程代码添加延迟，然后程序将暂停，直到线程将数据发送到通道:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new();
start {
    sleep 1;
       $channel.send(42);
};

my $value = $channel.receive;
say $value;</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后两个例子的唯一区别是在调用 <code>$channel.send</code> 方法之前的延迟。</p>
</div>
</div>
<div class="sect3">
<h4 id="_等或者不等">13.5.2. 等或者不等?</h4>
<div class="paragraph">
<p>正如我们在上一节中看到的那样，如果通道中没有数据， 那么 <code>Channel</code> 类的 <code>receive</code> 方法会停止。</p>
</div>
<div class="paragraph">
<p><code>poll</code> 方法也从通道读取但不阻止程序的执行。如果没有要读取的内容，则立即返回空值。让我们再稍微修改下上一个例子并用 <code>poll</code> 调用之间的一秒的延迟读取通道五次:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new();

start {
    sleep 3;
    $channel.send(42);
};

for 1..5 {
    my $value = $channel.poll;
    say $value;
    sleep 1;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序打印以下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(Any)
(Any)
(Any)
42
(Any)</code></pre>
</div>
</div>
<div class="paragraph">
<p>前三次尝试无法获得任何值，因为没有任何内容发送到 <code>$channel</code>， 因为它之前有三秒的延迟。在第四次迭代中，该值可用且可以被阅读。在读取之后，该值将从通道中删除，从而 <code>poll</code> 的下一次调用再次返回一个空值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_关闭通道">13.5.3. 关闭通道</h4>
<div class="paragraph">
<p><code>close</code> 方法关闭一个通道。这意味着不会再添加任何数据到通道中。要检查通道是否关闭，调用 <code>close</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new();
say 'Open' unless $channel.closed(); # Open

$channel.close();
say 'Closed' if $channel.closed();   # Closed</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>close</code> 方法的返回值不是布尔值。相反，该方法返回一个承诺，在通道关闭后该承诺变为保留状态:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new();
say $channel.closed().status(); # Planned

$channel.close();
say $channel.closed().status(); # Kept</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如，可以使用承诺来响应关闭通道来运行一些代码，如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new();

my $promise = $channel.closed();
$promise.then({
    say 'Channel is closed';
});

say 'Before calling close()';
$channel.close();
say 'After calling close()';</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行此程序其输出可能如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Before calling close()
After calling close()
Channel is closed</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为承诺是在一个单独的线程中执行的，所以这些行可能是不可预测的以不同的顺序打印。如果我们在主线程中打印字符串之前添加一个小延迟，我们就可以看到它了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Before calling close()';
$channel.close();
sleep 1;
say 'After calling close()';</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，<code>$promise</code> 的代码将在第二个 <code>say</code> 指令之前完成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Before calling close()
Channel is closed
After calling close()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_通道作为队列">13.5.4. 通道作为队列</h4>
<div class="paragraph">
<p>当多个值发送到通道中时，它们实际上变成队列。所以第一个添加到通道中的值将是从通道中接收到的第一个值。</p>
</div>
<div class="paragraph">
<p>由于通道是线程安全的，没有人限制我们关于线程的数量，我们打算写入到通道中或从通道中读取。以下示例演示了如何在几个线程之间共享一个通道。</p>
</div>
<div class="paragraph">
<p>该程序打印从 0 到 10 的数字的平方。首先发送数字到这个通道中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new();
$channel.send($_) for 0..10;
$channel.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>发送完所有数字之后，该通道将关闭。在下一阶段，通过调用 <code>start</code> 函数创建三个线程(不要忘记这个函数间接地通过创造承诺创建一个线程)。在每个线程中，无限循环尝试从相同的通道中接收值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @readers;
for 1..3 {
    push @readers, start {
        while 1 {
            my $value = $channel.poll;
            last if $value === Any;
            say "$value2 = " ~ $value * $value;
        }
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此处使用非阻塞的 <code>poll</code> 方法从通道读取值。如果队列被消费了并且返回值为空，则循环中断并且线程完成。</p>
</div>
<div class="paragraph">
<p>在退出主程序之前，我们必须等到所有承诺都变为保留状态:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">await @readers;</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个线程计算它可以从通道中读取的值的平方:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">0² = 0
2² = 4
1² = 1
3² = 9
5² = 25
4² = 16
6² = 36
7² = 49
8² = 64
10² = 100
9² = 81</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行程序几次，看它产生不同的输出。当然，每次运行都产生相同的计算值，但输出行的顺序可能会变化。该通道以和我们将数字发送给它的相同的顺序返回数字。线程是并发的，所以他们中的一些打印他们的结果并在其他线程之前选择下一个值。 尽管线程的工作顺序，但通道只给出数字一次。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_16">13.6. 总结</h3>
<div class="paragraph">
<p>在本章中，我们简要地讨论了 junction 的并行性质，其余时间我们深入地研究了线程，承诺和通道 - Raku 中实现并行和并发功能的机制。开发人员使用它们非常容易并且不需要任何手动操作底层机制以确保线程执行的时候不会发生冲突。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_函数式编程">14. 函数式编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 是一种多范式编程语言。在前面的章节中，我们主要使用传统的命令式编程。在本章中，我们将讨论 Raku 的函数式编程风格。</p>
</div>
<div class="paragraph">
<p>本章将介绍这些主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>函数式编程原理</p>
</li>
<li>
<p>使用递归重写传统程序</p>
</li>
<li>
<p>化简操作</p>
</li>
<li>
<p>高阶函数，lambda 和 whatever 代码块</p>
</li>
<li>
<p>使用 Feed 运算符管道输送数据</p>
</li>
<li>
<p>闭包、柯里化和动态作用域</p>
</li>
<li>
<p>惰性列表和无限列表以及序列生成器</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在我们详细讨论前面列出的主题之前，让我们先谈谈什么是函数式编程。</p>
</div>
<div class="sect2">
<h3 id="_什么是函数式编程">14.1. 什么是函数式编程</h3>
<div class="paragraph">
<p>函数式编程是使用一系列函数进行计算的方式。在这里，函数是从数学意义上理解的，而不是 Raku 中的子例程的含义。函数式编程的一个重要原则是函数必须没有副作用。 特别是，这意味着变量必须是不可变的 - 禁止分配新值。</p>
</div>
<div class="paragraph">
<p>我们将在本章中讨论的所有主题都是上述限制的结果。重要的是要意识到，例如，lambda 函数不是函数式编程的核心要素，而只是遵循无副作用这一主要原则的方式之一，例如更改一些影响函数结果的全局变量。</p>
</div>
<div class="paragraph">
<p>让我们取一个函数 <code>f($x)</code> 并用相同的参数调用它两次。请问第二次调用返回的结果与第一次调用返回的结果相同吗? 在函数式编程中，要求使用相同的参数调用函数时始终返回相同的结果。</p>
</div>
<div class="paragraph">
<p>这是一个返回 <code>$x + 1</code> 的函数示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($x) {
    return $x + 1;
}

say f(5); # 6
say f(5); # 6

say f(5) == f(5); # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>两个调用都返回相同的结果。此外，比较 <code>f(5) == f(5)</code> 结果为 <code>True</code>。这个程序可能已被视为以函数式风格编写的程序。</p>
</div>
<div class="paragraph">
<p>引入变量并不违反原则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($x) {
    return $x + 1;
}

my $a = 5;

say f($a); # 6
say f($a); # 6

say f($a) == f($a); # True</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$a</code> 变量仅在初始化期间获取一次值。在那之后它永远不会改变。</p>
</div>
<div class="paragraph">
<p>现在，让我们修改函数的参数(你需要使用 <code>is rw</code> trait):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($x is rw) {
    $x += 1;
return $x; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一次调用具有相同原始值 <code>$a</code> 的函数将返回与以前相同的结果。 尽管在函数调用之后 <code>$a</code> 的值被更改，并且第二个调用 <code>f($a)</code> 无法返回相同的结果。 条件 <code>f($a) == f($a)</code> 不再为 True：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 5;

say f($a); # 6
say f($a); # 7

say f($a) == f($a); # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，函数创建了修改其参数的副作用，这是由于它被声明为可读可写的参数，改变了主代码中变量的值。</p>
</div>
<div class="paragraph">
<p>另一种产生副作用的方法是在函数内部使用全局变量。检查一下以下函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $step = 0;

sub f($x) {
    $step++;
    return $x + $step;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>函数的参数现在没有改变，但当它被调用两次时函数返回不同的结果。</p>
</div>
<div class="paragraph">
<p>现在，仔细查看 <code>f</code> 函数的三个变体。在第一个变体中，函数主体中没有涉及到赋值。在第二个和第三个例子中， 函数参数或全局变量被重新赋值了。虽然没有显式地使用 = 运算符，<code>$x += 1</code> 和 <code>$step++</code> 结构等效于以下赋值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$x = $x + 1;
$step = $step + 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下，这都是打破 <code>f($a) == f($a)</code> 条件的根源。</p>
</div>
<div class="paragraph">
<p>函数本身不一定会改变全局值。全局值可以被两个函数调用之间的其他代码修改:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $step = 1;

sub f($x) {
    return $x + $step;
}

say f(5); # 6
$step = 2;
say f(5); # 7</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然函数似乎是可预测的，但其环境会影响其工作。在某种感觉中，变量重新赋值在程序中引入了时间的概念。在不同时间对 <code>f(5)</code> 的同一次调用会返回不同的结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t1 = f(5);
$step = 2;
my $t2 = f(5);

say $t1 == $t2; # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 不禁止设置变量的新值，而是在编写函数式程序时，你应该只初始化变量一次，应该避免任何新的赋值。在下一节中，您将看到如何修改传统程序以遵循函数式编程原则。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用递归">14.2. 使用递归</h3>
<div class="paragraph">
<p>本章的下一个程序是一个简单的循环，可以打印 10 到 15 之间的数字并计算他们的总和。我们先打印一下数字。正如我们在第 5 章控制流中看到的那样，在 Raku 中有不同的循环方式。在它们之间进行选择可以引导我们已经在功能编程的方向上了。</p>
</div>
<div class="paragraph">
<p><code>loop</code> 循环需要一个 <code>loop</code> 计数器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum = 0;
loop (my $n = 10; $n &lt;= 15; $n++) {
    $sum += $n;
}
say $sum; # 75</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个程序中有两个变量可以改变它们的值 - <code>$n</code> 和 <code>$sum</code>。这很容易摆脱 <code>$n</code> 计数器，从而重新赋值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum = 0;
for 10..15 {
    $sum += $_;
}
say $sum;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们使用 <code>$_</code> 变量而不是 <code>$n</code>，实际上 <code>for</code> 循环可以使用显式循环变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum = 0;
for 10..15 -&gt; $n {
    $sum += $n;
}
say $sum;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个代码和带 <code>loop</code> 的程序之间的区别在于现在变量 <code>$n</code> 仅存在于一个循环迭代中。它在进入循环体之前被赋值，运行后被撤回。在第一个示例中，它在每次迭代时递增。</p>
</div>
<div class="paragraph">
<p>其中一项赋值消失了。我们怎样才能避免修改 <code>$sum</code> 变量呢? 它看起来不可避免，因为它的性质 - 它应该在循环数字时积累总和。答案是 - 使用递归。递归给了我们与我们相同的技巧 刚看到 <code>$n</code> 变量。而不是保持一个全局 <code>$sum</code> 变量程序的状态，每次更改总和时创建一个新变量。更重要的是，它可以完全摆脱那个变量，如下一个例子所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub sum($min, $max) {
    if ($min == $max - 1) {
        return $min + $max;
    }
    else {
        return $min + sum($min + 1, $max);
    }
}
say sum(10, 15); # 75</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们仔细看看这个程序。首先，这里没有保存状态的变量 - 没有循环计数器 <code>$n</code>，也没有保存中间结果的 <code>$sum</code> 变量。代替创建一个关于如何求和的指令，以该数字开始, 假设这是一个总和; 增加数字，将其加到前一个总和上; 我们实际描述了总和的意思 - 数字的和是当前数字加上所有先前数字的总和。</p>
</div>
<div class="paragraph">
<p><code>sum</code> 函数调用自身，每次使用不同的参数。当然，在某个时候停止递归很重要，这就是测试 <code>$min == $max - 1</code> 存在的原因，当值是我们想要加起来的最后两个值时，它变为 <code>True</code>。
这个程序已经是一个功能程序:它编码一个总和的定义，它没有
保持状态，它使用功能来实现目标。</p>
</div>
<div class="paragraph">
<p>最后，让我们使用一些Raku语法元素来使程序更紧凑:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub sum($min, $max) {
    return $min == $max - 1
        ?? $min + $max
        !! $min + sum($min + 1, $max);
}
say sum(10, 15);</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，此处不需要 <code>return</code> 关键字，因为 Raku 将采用函数最后一个计算的值。最后一个分号也可以省略:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub sum($min, $max) {
    $min == $max - 1
        ?? $min + $max
        !! $min + sum($min + 1, $max)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个转换是从两个表达式中移出类似的部分:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub sum($min, $max) {
    $min + ($min == $max - 1 ?? $max !! sum($min + 1, $max))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们到此为止，看看 Raku 为我们提供了哪些其他令人着迷的选择。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用化简">14.3. 使用化简</h3>
<div class="paragraph">
<p>在上一节中，我们计算了 10 到 15 之间的数字之和。 经过一些转换后，该程序变得等同于以下程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 + (11 + (12 + (13 + (14 + 15))));</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的每对括号对应于 <code>sum</code> 函数的递归调用。函数的调用在这里用它的实现替换。这是无状态方法的限制后果之一。函数是否取决于程序状态， 在不同时刻，如果不知道值反射状态，那么用它的实现替换函数调用是不可能的。</p>
</div>
<div class="paragraph">
<p>由于括号在此处不会更改任何执行顺序，因此我们将其删除:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 + 11 + 12 + 13 + 14 + 15;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们在这里看到的是由 <code>+</code> 运算符分隔的 10 到 15 之间的所有值的列表。 我们已经在第4章的使用运算符的化简元运算符一节中遇到过。整个结构可以用简单的代码替换:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [+] 10..15;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也是一个函数式风格的程序。比较一下它和上一节示例中的其中之一的大小。</p>
</div>
<div class="paragraph">
<p>化简运算符 <code>[+]</code> 也可以与任意数组完美配合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 10, 11, 100, 101, 1000, 1001;
say [+] @a; # 2223</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们现在越来越接近函数式编程中的另一个重要概念，高阶函数。</p>
</div>
</div>
<div class="sect2">
<h3 id="_高阶函数和_lambdas">14.4. 高阶函数和 lambdas</h3>
<div class="paragraph">
<p>我们刚刚在上一节中看到的 <code>[+]</code> 化简运算符可以根据需要多次执行 <code>+</code> 运算符的动作以把所提供数据的所有元素加起来。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，还有一种进行化简操作的替代方法。有一个内置的函数 <code>reduce</code> 需要一个会执行操作的代码块。首先，我们将使用我们在第 2 章编写代码中所创建的函数 <code>add($a, $b)</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($a, $b) {
    return $a + $b;
}

say reduce &amp;add, 10..15;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>reduce</code> 函数将函数的引用作为第一个参数并展平值的列表。在 <code>&amp;add</code> 中，函数名称前面的 <code>&amp;</code> 符号告诉 Raku 这不是函数调用，而是对函数的代码引用。</p>
</div>
<div class="paragraph">
<p><code>reduce</code> 函数是高阶函数的一个例子。参数的其中之一是另一个函数。在 Raku 中，函数是一等对象，这意味着它们可以作为参数传递给其他函数，就像使用常规变量一样容易。从高阶函数调用的函数有时也称为回调函数。</p>
</div>
<div class="paragraph">
<p>由于 <code>add</code> 函数仅用于 <code>reduce</code> 函数，因此可以内联并在它需要的地方直接创建:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say reduce sub add($a, $b) {return $a + $b}, 10..15;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在很明显，<code>add</code> 名称没有添加任何值，因此可以省略使函数匿名:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say reduce sub ($a, $b) {return $a + $b}, 10..15;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此上下文中，匿名函数也称为 lambda 函数。它有常规子例程的所有属性，除了它既没有名字也不能从程序中的其它地方调用。整个函数定义是内联的。</p>
</div>
<div class="paragraph">
<p>现在让我们看看 Raku 如何在语法上帮助简化创建 lambdas。 首先，<code>sub</code> 块可以用尖号块替换:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say reduce -&gt; $a, $b {$a + $b}, 10..15;</code></pre>
</div>
</div>
<div class="paragraph">
<p>匿名函数的参数列在 <code>&#8594;</code> 箭头后面，你不需要用括号括起来。另请注意，使用尖号块，<code>return</code> 关键字无法使用(编译器将生成错误:Attempt to return outside of any Routine)。实际上，根本不需要 <code>return</code>，因为函数所要做的所有事情就是计算一个表达式，其结果将是函数的结果。</p>
</div>
<div class="paragraph">
<p>此外，即使是参数也不是这种函数的强制性要素。他们可以用花括号中代码块内的占位符变量替换(参见第六章《子程序》中的参数占位符一节):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say reduce {$^a + $^b}, 10..15;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 中有更多内置函数可以充当高阶函数。这些是，<code>map</code>，<code>grep</code> 和 <code>sort</code>。他们每个都可以接收一个可选的代码块或对现有函数的引用作为第一个参数。让我们看几个例子。</p>
</div>
<div class="paragraph">
<p><code>map</code> 函数为序列的每个元素启动回调。结果是新的包含使用回调函数代码的每个元素的单独映射的列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say map {.uc}, 'a'..'d'; # (A B C D)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>grep</code> 函数还为每个元素调用它的回调，但只复制那些回调返回 <code>True</code> 值的元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say grep {$_ &gt; 10}, 1..15; # (11 12 13 14 15)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两个例子中，使用了 $_ 变量: 对于 <code>map</code>，它是隐式的, 因为为 <code>.uc</code> 是 <code>$_.uc</code> 的快捷方式。</p>
</div>
<div class="paragraph">
<p>使用 <code>sort</code> 函数，它有点复杂，因为回调函数需要两个参数。最简单的方法是使用占位符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say sort {$^b &lt;=&gt; $^a}, 10..15; # (15 14 13 12 11 10)</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码块允许以相反的顺序对数字进行排序。</p>
</div>
<div class="sect3">
<h4 id="_whatevercode_块">14.4.1. WhateverCode 块</h4>
<div class="paragraph">
<p>现在，因为我们已经使用了 <code>sort</code>，<code>grep</code>，<code>map</code> 和 <code>reduce</code> 代码块，所以是时候使用 Raku 中所谓的 <code>WhateverCode</code> 类型了。它涉及(*)星号并创建一个代码块，可以用作我们之前使用的任何代码块。</p>
</div>
<div class="paragraph">
<p>例如，您可以编写 <code>*.uc</code> 代替 <code>{.uc}</code>。以下两行代码是等价的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say map {.uc}, 'a'..'d'; # (A B C D)
say map *.uc, 'a'..'d';  # (A B C D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>类似地，这就是 <code>WhateverCode</code> 块可以用来替换 <code>grep</code> 和 <code>sort</code> 示例中匿名代码的方式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say grep * &gt; 10, 1..15; # (11 12 13 14 15)

say sort * &lt;=&gt; *, &lt;11 12 10 13 15 14&gt;; # (10 11 12 13 14 15)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第二个例子中，有两个星号，分别对应于前面使用的 <code>$^a</code> 和 <code>$^b</code> 占位符参数。使用 * 时，不需要花括号来创建块。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_管道数据和_feed_运算符">14.5. 管道数据和 feed 运算符</h3>
<div class="paragraph">
<p><code>grep</code>，<code>map</code>，<code>reduce</code> 和 <code>sort</code> 函数功能强大且易于使用(与其他类似的用户定义的高阶函数一起使用)他们可以处理许多实际的传统命令式编程通过循环组织它们的那些领域的任务。</p>
</div>
<div class="paragraph">
<p>通常，您需要调用另一个函数返回的结果中的一个函数。考虑一个街道上房屋清单的例子。其中一些房子必须是漆过的，但你只需要选择街道的一侧，它有红色的外墙，五年多前进行了翻新。任务是你要知道需要多少油漆。</p>
</div>
<div class="paragraph">
<p>让我们假设有关房屋属性的信息包含在像这样的结构的数据中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @street = (
       {
           number          =&gt; 1,
           renovation_year =&gt; 2000,
           storeys         =&gt; 4,
           colour          =&gt; 'green',
           width           =&gt; 20,
       },
       {
           number          =&gt; 2,
           renovation_year =&gt; 2014,
           storeys         =&gt; 6,
           colour          =&gt; 'red',
           width           =&gt; 10,
       },

       # . . .
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>显然应该创建某种过滤器。它应该检查每个房子并确定它是否通过了所有条件，或者它可以逐步过滤匹配的房屋,一次一个条件。例如，让我们从选定的偶数一侧的房屋开始:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @houses-to-paint = grep {$_&lt;number&gt; %% 2}, @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>grep</code> 函数逐个接收 <code>@street</code> 数组的所有元素。在每次迭代中，元素可以通过 $_ 主题变量访问。在计算 <code>$_&lt;number&gt; %% 2</code> 条件后，只返回那些非零结果元素传递给
 <code>@houses-to-paint</code> 数组。</p>
</div>
<div class="paragraph">
<p>同样，可以添加基于颜色和翻新年份的过滤:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @houses-to-paint =
    grep {$_&lt;renovation-year&gt; &lt; 2012},
    grep {$_&lt;colour&gt; eq 'red'},
    grep {$_&lt;number&gt; %% 2},
    @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不要被第一个 <code>grep</code> 中的巧合对 <code>&gt; &lt;</code> 迷惑。每个角括号都有它自己的功能，编译器完全理解它。</p>
</div>
<div class="paragraph">
<p>最后，我们需要计算表面积，以了解需要多少油漆。让我们假设每平方米需要 0.7 升油漆和每层楼高度为 3 米:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $paint-volume = 0.7 * [+] map {$_&lt;width&gt; * $_&lt;storeys&gt; * 3}, @houses-to-paint;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>map</code> 函数用于将房屋转换为其表面积。<code>[+]</code> 化简运算符将所有值相加以获得总结果。</p>
</div>
<div class="paragraph">
<p>我们现在可以将所有代码组合在一个语句中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say
    0.7 *
    [+]
        map  {$_&lt;width&gt; * $_&lt;storeys&gt; * 3},
        grep {$_&lt;renovation-year&gt; &lt; 2013},
        grep {$_&lt;colour&gt; eq 'red'},
        grep {$_&lt;number&gt; %% 2},
    @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以在这里提出自己的缩进方式。</p>
</div>
<div class="paragraph">
<p>如果房屋存放在对象而不是哈希中，那就更好了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.number;
    has $.renovation-year;
    has $.storeys;
    has $.colour;
    has $.width;
    method area {
        return $!width * $!storeys;
    }
}

my @street = (
    House.new(
           number          =&gt; 1,
           renovation_year =&gt; 2000,
           storeys         =&gt; 4,
           colour          =&gt; 'green',
           width           =&gt; 20),
    House.new(
           number          =&gt; 2,
           renovation_year =&gt; 2014,
           storeys         =&gt; 6,
           colour          =&gt; 'red',
           width           =&gt; 10),

       # . . .
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，<code>map</code> 和 <code>grep</code> 函数的代码块可能看起来更简单:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say
    0.7 *
    [+]
        map  {.area * 3},
        grep {.renovation-year &lt; 2013},
        grep {.colour eq 'red'},
        grep {.number %% 2},
    @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在它看起来完成了。在一分钟内，我们将使它变得更好，但现在再一次注意到，没有赋值操作符来更改变量的值。其实，整个程序中的变量并不多。</p>
</div>
<div class="paragraph">
<p>最后一个带有链式 <code>map</code> 和 <code>grep</code> 的示例中的数据流从下到上发生。 首先，过滤 <code>@street</code> 以查找具有偶数的房屋，然后挑选红房子，然后只选择旧房子，然后计算他们的表面积。Raku 允许我们以这样的方式组织代码，使用 <code>=&#8658;</code> 从上到下阅读以及 <code>&#8656;=</code> 运算符。在第四章的《使用运算符》中的数据管道运算符一节中简要介绍了 feed 运算符。这是你如何使用它们重新编写链:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 0.7 * (@street ==&gt;
    grep {.number %% 2} ==&gt;
    grep {.colour eq 'red'} ==&gt;
    grep {.renovation-year &lt; 2013} ==&gt;
    map  {.area * 3} ==&gt;
    reduce {$^a + $^b});</code></pre>
</div>
</div>
<div class="paragraph">
<p>反转的 <code>&#8656;=</code> 运算符会更改数据流。</p>
</div>
<div class="paragraph">
<p>在此示例中，链的结果是数字。如果你得到数组，你甚至可以在链的末尾定义变量。例如，代替传统的赋值(这里需要圆括号):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @even-red-houses =
    (@street ==&gt; grep {.number %% 2} ==&gt; grep {.colour eq 'red'});</code></pre>
</div>
</div>
<div class="paragraph">
<p>把 <code>my</code> 声明放在最后:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@street ==&gt; grep {.number %% 2} ==&gt;
grep {.colour eq 'red'} ==&gt; my @even-red-houses;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要减少花括号的数量，可以使用 <code>Whatever</code> 块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@street ==&gt; grep *.number %% 2 ==&gt;
grep *.colour eq 'red' ==&gt; my @even-red-houses;</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们所见，Raku 提供了多种不同的方式来尽可能地表达您的想法。</p>
</div>
<div class="paragraph">
<p>再次，您看到没有涉及变量，但这并不意味着变量在函数式编程风格中是被禁止的。不希望的只是修改他们。在下一节中，我们将讨论我们可以用变量做些什么。</p>
</div>
</div>
<div class="sect2">
<h3 id="_操作作用域">14.6. 操作作用域</h3>
<div class="paragraph">
<p>在本节中，我们将学习三种可以改变变量作用域的技术。这些是闭包，柯里化和动态作用域。</p>
</div>
<div class="sect3">
<h4 id="_闭包">14.6.1. 闭包</h4>
<div class="paragraph">
<p>在 Raku 中，词法变量存在于其作用域内。闭包是可以扩展该作用域并让你访问词法值的函数，这些值在闭包定义之处可以访问。让我们考虑在变量中保持当前状态的计数器的示例。</p>
</div>
<div class="paragraph">
<p>首先，不涉及任何闭包。计数器值保存在全局变量中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $counter = 0;

sub next-number() {
    return $counter++;
}

say next-number(); # 0
say next-number(); # 1
say next-number(); # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>每次调用 <code>next-number</code> 函数时，都会返回一个递增的整数。</p>
</div>
<div class="paragraph">
<p>现在，目标是隐藏 <code>$counter</code> 变量，以便用户无法直接访问 <code>next-number</code>。这是一个闭包。首先，变量和函数都放在另一个函数中，这为它们创建了一个词法作用域:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub new-counter() {
    my $counter = 0;

    sub next-number() {
        return $counter++;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在无法从 <code>new-counter</code> 函数外部访问 <code>$counter</code>， 虽然它仍然可以在 <code>next-number</code> 子例程中访问。<code>$counter</code> 变量和 <code>next-number</code> 子例程是本地的，它们的作用域等于 <code>new-counter</code> 的主体。</p>
</div>
<div class="paragraph">
<p>虽然，<code>new-counter</code> 子例程返回 <code>next-number</code> 子例程并且它可以保存在变量中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = new-counter();</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>$c</code> 中存储的内容的类型是 <code>Sub</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $c.WHAT; # (Sub)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着 <code>$c</code> 是可调用的并且可以用作函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $c(); # 0
say $c(); # 1
say $c(); # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>每次调用都会更改在闭包内捕获的 <code>$counter</code> 变量，因此 <code>$c()</code> 的调用按预期返回递增的数字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = new-counter();
my $b = new-counter();

say $b(); # 0
say $b(); # 1
say $a(); # 0
say $b(); # 2
say $a(); # 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以创建另一个独立的计数器，它将在内部包含另一个 <code>$counter</code> 容器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = new-counter();
say $c;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，<code>$a</code> 和 <code>$b</code> 计数器保存调用之间的状态，不会彼此影响。</p>
</div>
<div class="paragraph">
<p>在前面的代码中，子例程保存在标量变量中，前缀为 <code>$</code> sigil。如果你这样做，你总是需要添加圆括号来表示函数调用。如果不带圆括号，则会打印内存中的函数地址:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub next-number () { #`(Sub|140645269514272) ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是你在输出中得到的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub next-number () { #`(Sub|140645269514272) ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所知，对于常规函数可以省略空的圆括号，比如说 <code>new-counter</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $cntr = new-counter;
say $cntr(); # 0
say $cntr(); # 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 有一个单独的 sigil，<code>&amp;</code>，用于保存实现 <code>Callable</code> 接口的值的容器。我们在此不再详述，如果您有兴趣，请参考 link:https:/​/​docs.​raku.​org/​type/​Callable。带有 <code>&amp;</code> sigil 的变量被编译器视为可以调用的对象，所以空的圆括号甚至是 sigil 本身可以省略，如下一个程序所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;d = new-counter();
say &amp;d(); # 0
say d();  # 1
say d;    # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>裸的 <code>d</code> 和 <code>d()</code> 以及完整形式的 <code>&amp;d()</code> 都是相同的调用。</p>
</div>
<div class="paragraph">
<p>最后的注释是关于如何从 <code>new-counter</code> 函数中返回子例程。如果更严格，可以使用引用隐式返回，如下一个片段所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub new-counter() {
    my $counter = 0;
    sub next-number() {
        return $counter++;
    }

    return &amp;next-number;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里使用的 <code>&amp;</code> 符表示这不是函数调用而是 <code>sub</code> 本身。</p>
</div>
</div>
<div class="sect3">
<h4 id="_柯里化">14.6.2. 柯里化</h4>
<div class="paragraph">
<p>柯里华是一种通过创建一个用于替换原始函数的某些预定义值的包装函数以减少函数参数数量的技术 。</p>
</div>
<div class="paragraph">
<p>让我们看一下一个带有两个参数的简单函数的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub greet($type, $name) {
    return "$type, $name!";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在假设我们要选择默认问候语; 函数调用将包含重复的参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say greet('Hello', 'Liza');
say greet('Hello', 'John');
say greet('Hello', 'Carl');</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以通过创建一个单独的函数 <code>hello</code> 来解决问题，它正好用所需的参数调用 <code>greet</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub hello($name) {
    return greet('Hello', $name);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 为我们提供了简单的语法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;hello = &amp;greet.assuming('Hello');</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>assume</code> 方法创建一个新的可调用子例程实际上是一个带有给定的第一个参数的 <code>greet</code> 子例程。现在，<code>hello</code> 是一个新的可调用对象的名称，它接受一个参数并且可以用作函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say hello('Liza');
say hello('John');
say hello('Carl');</code></pre>
</div>
</div>
<div class="paragraph">
<p>柯里化在某种程度上类似于使用子例程的默认参数，但主要有两个差异。首先，默认参数只能出现在签名的末尾。第二， 通过柯里化，可以创建多个默认值。例如，可以从同一个 <code>greet</code> 函数创建另一个替代问候语:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;hi = &amp;greet.assuming('Hi');

say hi('Liza');
say hi('John');
say hi('Carl');</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在让我们看看如何处理带有命名参数的函数。这是一个修改过的 <code>greet</code> 函数的版本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub greet(:$type, :$name) {
    return "$type, $name!";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建特定的 <code>hello</code> 版本很简单:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub hello($name) {
    return greet(:type('Hello'), :$name);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，<code>:$type</code> 参数获取预定义值-<code>:type('Hello')</code>，而第二个参数 <code>:$name</code> 直接使用其原始名称传递。结果是连接了问候语的字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say hello('John'); # Hello, John!</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，让我们看看扩展变量作用域的另一种方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_动态作用域">14.6.3. 动态作用域</h4>
<div class="paragraph">
<p>动态作用域使用 <code>*</code> twigil，例如，动态标量变量 <code>$*a</code>。不像常规局部变量，动态变量可以在函数中使用，从变量的当前作用域中调用。看下面这个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f() {
    $*a++;
}

my $*a = 1;
f();
say $*a; # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，<code>$*a</code> 是主程序中的动态变量。它的初始值为 1。 <code>f</code> 函数在被调用时会改变同一个变量的值，因此该程序打印 2。事实是 <code>$*a</code> 未在 <code>f</code> 函数内声明。编译器会在函数被调用的作用域内搜索此名称。</p>
</div>
<div class="paragraph">
<p>在前面的示例中，可以使用简单的全局变量而不是动态变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 1;
f();
say $a;

sub f() {
    $a++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用动态变量，您可以在不同的上下文中访问不同的容器。例如，如果从另一个函数中调用 <code>f</code> 函数怎么办?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub g() {
    my $*a = 10;
    f();
    say $*a; # 21
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，<code>f</code> 将修改 <code>g</code> 中初始化的变量。在作用域中包含动态变量的任何其他调用都会遇到同样的情况:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f() {
    $*a++;
}

sub g() {
    my $*a = 10;
    f();
    say $*a;
}

sub h() {
    my $*a = 20;
    f();
    say $*a;
}

g(); # 11
h(); # 21
g(); # 11</code></pre>
</div>
</div>
<div class="paragraph">
<p>在下一节中，我们将讨论如何创建更高级的函数，例如迭代器。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_创建并使用迭代器">14.7. 创建并使用迭代器</h3>
<div class="paragraph">
<p>迭代器是一种强大的技术，可按需提供数据并避免手动计数。这些函数每次调用都返回某个序列的下一个元素。在上一节中，我们已经创建了迭代器 <code>new-counter</code>，它生成递增的整数。让我们做一些更复杂的事情:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub make-iter(@data) {
    my $index = 0;
    sub {
        return @data[$index++];
    }
}

my &amp;iter = make-iter(&lt;red green blue orange&gt;);

say iter; # red
say iter; # green
say iter; # blue
say iter; # orange</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>make-iter</code> 函数获取一个数组，将 <code>$index</code> 位置安装为零并返回一个将用作迭代器的子例程。下次调用 <code>iter</code> 对象时，它返回当前位置的值并将内部指针移动到下一个元素。数据耗尽之后，会返回 <code>Nil</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub make-factorial-iter() {
    my $n = 1;
    my $f = 1;

    sub {
        $f *= $n++;
        return $f;
    }
}

my &amp;iter = make-factorial-iter();
say iter for 1..5;</code></pre>
</div>
</div>
<div class="paragraph">
<p>迭代器也可以根据某些规则生成序列。例如，这是一个每次调用时返回下一个阶乘数的迭代器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-scala" data-lang="scala">sub make-factorial-iter() {
       my $n = 1;
my $f = 1;
       sub {
           $f *= $n++;
return $f; }
}
   my &amp;iter = make-factorial-iter();
   say iter for 1..5;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序打印 5 个数字 - 阶乘1到5。请注意，算法没有使用递归或循环，只需要最少的必要操作来计算下一个值。它始终使用先前计算的 <code>$n - 1</code> 的值。</p>
</div>
<div class="paragraph">
<p>现在我们来谈另一个话题，惰性计算的数据。</p>
</div>
</div>
<div class="sect2">
<h3 id="_惰性和无限列表">14.8. 惰性和无限列表</h3>
<div class="paragraph">
<p>只要电脑的内存限制允许，带有阶乘的示例就可以生成数字。虽然我们可能想要计算，比如 100 的阶乘，在我们真正需要值之前，这个程序不会计算。如果结果还不需要，那么就不需要计算资源
。这是惰性计算背后的想法。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，<code>&#8230;&#8203;</code> 运算符创建一个序列。最简单的情况看起来类似于范围创建的方式。将在下一个示例中创建常规数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1...100;
say @a.elems;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@a</code> 数组被立即创建，它获取所有 100 个元素，即从 1 到 100 的整数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @a[0];  # 1
say @a[1];  # 2

say @a[98]; # 99
say @a[99]; # 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反，使用 <code>lazy</code> 关键字创建的惰性序列不会填充数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @b = lazy 1...100;</code></pre>
</div>
</div>
<div class="paragraph">
<p>试图通过调用 <code>@b.elems</code> 来获取它的大小，会导致错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Cannot .elems a lazy list</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然可以获取此数组的元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @b[0]; # 1
say @b[1]; # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>在数组末尾请求元素也将生成相应的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @b[98]; # 99
say @b[99]; # 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，当数组结束并请求一个额外的元素时，返回空值 <code>Any</code>。此时，数组不再是惰性的，<code>elems</code> 方法返回数组大小。 要检查数组是否是惰性的，请使用 <code>is-lazy</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @b.is-lazy; # True

say @b[100];    # (Any)
say @b.elems;   # 100
say @b.is-lazy; # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 还允许我们创建序列，其上边界是无限的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @c = 1 ... Inf; # or 1 ... ∞

say @c[0];    # 1
say @c[1000]; # 1001</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于无法达到这样一个序列的末尾，<code>@c.is-lazy</code> 将始终保持为 <code>True</code>。</p>
</div>
<div class="paragraph">
<p><code>&#8230;&#8203;</code> 序列运算符在你提供算术或几何级数时可以生成更复杂的序列:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @arithm = 1, 3 ... 11;
say @arithm; # [1 3 5 7 9 11]

my @geom = 2, 4, 8 ... 256;
say @geom; # [2 4 8 16 32 64 128 256]

my @float = 3.14, 3.15 ... 3.19;
say @float; # [3.14 3.15 3.16 3.17 3.18 3.19]</code></pre>
</div>
</div>
<div class="paragraph">
<p>要创建无限序列，请使用 <code>Inf</code> 或 <code>*</code> 作为序列的右端:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @inf = 1, 2 ... Inf;
say @inf[0..5]; # (1 2 3 4 5 6)</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序立即打印其结果，而不必等到数组充满无限列表。</p>
</div>
<div class="paragraph">
<p>最后，可以使用自定义生成器来计算下一个值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @cubes = {state $n; $n++; $n ** 3} ... Inf;
say @cubes[0..5]; # (1 8 27 64 125 216)</code></pre>
</div>
</div>
<div class="paragraph">
<p>生成代码块使用 <code>state</code> 变量来跟踪数字产生。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_17">14.9. 总结</h3>
<div class="paragraph">
<p>在本章中，我们讨论的是函数式编程。Raku，虽然不是函数式编程语言，包括可以实现许多这样的语言功能的元素。我们谈到了关于高阶函数的递归和化简， lambda 函数和 WhateverCode 代码块(那些使用 <code>*</code> 来要求 Raku 做事的代码块)。我们创建了许多使用数据管道，闭包，柯里化和动态作用域的例子。最后，我们讨论了无限列表和惰性列表，以及如何生成它们。</p>
</div>
<div class="paragraph">
<p>下一章的主题是反应式编程，这是另一种 Raku 支持的编程范式。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_反应式编程">15. 反应式编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在前一章中，我们讨论了函数式编程。Raku 内置支持多范式。在本章中，我们讨论反应式 编程，也称为函数反应式编程或事件驱动编程。 同样，Raku 的核心支持这种风格的编程, 开箱即用。</p>
</div>
<div class="paragraph">
<p>本章将介绍以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>反应式编程的概念</p>
</li>
<li>
<p>按需供应和现场供应</p>
</li>
<li>
<p>过滤和转换数据流</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_什么是反应式编程">15.1. 什么是反应式编程</h3>
<div class="paragraph">
<p>在过程式编程中，程序列出了变量的指令和变量 获取特定值的时间，或代码块执行的时间。例如，一个变量将另外两个整数变量值的和作为它的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$z = $x + $y;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在该赋值后更改了 <code>$x</code> 或 <code>$y</code>，则 <code>$z</code> 的值不会发生任何变化。另一个例子 - 函数返回值被赋给一个变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$area = area-of-circle($r);</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然从代码中可以清楚地看到它用给定的半径计算圆的面积，如果更改 <code>$r</code> 变量，则必须手动更新 <code>$area</code> 的值。</p>
</div>
<div class="paragraph">
<p>反应式编程旨在改变依赖值的“静态”行为。 许多计算机程序和网页的交互式界面是一个很好的反应式方法的例子 。想象一下在线计算器，您可以在其中键入两个值并 立即在页面上的另一个地方得到结果。或者输入半径, 圆的面积 被重新计算并显示。让我们看看 Raku 如何处理反应式编程。</p>
</div>
<div class="paragraph">
<p>有两个主类可以处理反应式编程所需的大部分内容-<code>Supply</code>，它是一个异步数据流，以及 <code>Supplier</code>，它是供应的变体之一的工厂，即现场供应(<strong>live supplies</strong>)。还存在- 按需供应(<strong>on-demand supplies</strong>)，我们会先说说它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_按需供应">15.2. 按需供应</h3>
<div class="paragraph">
<p>供应的数据流包含两个部分 - 发数据的供应者和接收数据的阀门。Raku 的反应式编程模型是一个线程安全的观察者设计模式实现。</p>
</div>
<div class="paragraph">
<p>让我们使用 <code>supply</code> 关键字创建我们的第一个按需供应:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">supply {
    emit($_) for 'a'..'e';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里有 <code>supply</code>，但它没有发出任何数据，因为没有需求。如果你向循环添加打印指令，则很容易看到这个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">supply {
    for 'a'..'e' {
        emit($_);
        say "Emitted $_";
    }
}
sleep 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序在 2 秒后静默退出。</p>
</div>
<div class="paragraph">
<p>为了使供应者生成数据，我们需要创建一个 <code><strong>tap</strong></code>。<code>supply</code> 块返回一个  <code>Supply</code> 类型的值，您可以在其上调用 <code>tap</code> 方法来传递将要执行的代码以响应发出的数据:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">supply {
    emit($_) for 'a'..'e';
}.tap({
    .say;
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这次，程序打印几行从 <code>a</code> 到 <code>e</code> 的字母。让我们在我们的“调试器”程序中打开一个阀门，看到它确实执行了发射块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">supply {
    for 'a'..'e' {
        say "Emitting $_";
        emit($_);
    }
}.tap({
    say "Tap received $_";
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>实际上，现在两个 <code>say</code> 函数都被调用了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Emitting a
Tap received a
Emitting b
Tap received b
Emitting c
Tap received c
Emitting d
Tap received d
Emitting e
Tap received e</code></pre>
</div>
</div>
<div class="paragraph">
<p>将多个阀门连接到供应者也不是问题。他们每一个都会收到相同的数据:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = supply {
    emit($_) for 'a'..'e';
}

$supply.tap({
    say "Tap 1 got $_";
});

$supply.tap({
    say "Tap 2 got $_";
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>与通道不同(见第13章, 并发编程)，tap 不竞争以得到发送的值。根据需要，供应者可以提供任意数量的阀门。请注意，这也意味着 tap 不能作为并行进程。如果给第一个 tap 添加一个小的延迟，这就变得清晰可见了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$supply.tap({
    say "Tap 1 got $_";
    sleep 0.5;
});
$supply.tap({
    say "Tap 2 got $_";
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在输出中，您将看到从a到e的所有值将首先到达第一个 tap，然后第二个才被服务:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Tap 1 got a
Tap 1 got b
Tap 1 got c
Tap 1 got d
Tap 1 got e
Tap 2 got a
Tap 2 got b
Tap 2 got c
Tap 2 got d
Tap 2 got e</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_用_suppiles_生成数据">15.2.1. 用 suppiles 生成数据</h4>
<div class="paragraph">
<p>在上一节中，使用 emit 方法将值发送到供应。对于每个数据 项，单独调用。供应可以自己生成数据。Supply 类的 interval 方法以给定的间隔发出数据。在下一个示例中，它会每 300 毫秒生成递增的数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Supply.interval(0.3).tap({
    say $_;
});
sleep 5;</code></pre>
</div>
</div>
<div class="paragraph">
<p>每次触发 tap 时，它都会获得一个递增的整数。第一个值是 0.因此， 上面的程序将打印0到16之间的数字。
这里需要调用 sleep 函数才能看到 tap 的接收到的头几个结果。没有它，程序会立即停止。</p>
</div>
<div class="paragraph">
<p>顺便说一句，如果你想使用一个命名变量而不是 $_，请使用带有一个尖号块的参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Supply.interval(0.5).tap( -&gt; $x {say $x});
sleep 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>interval 方法也接受第二个参数，即在第一个数据项发出之前以秒为单位的延迟:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Supply.interval(1, 2).tap({
    .say;
});
sleep 4;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在程序在2秒后开始打印数字。初始延迟不会影响 供应产生的顺序。该程序也从0开始打印(并结束 在1，因为当程序有一个工作 tap 时，sleep 函数允许2秒。
tap 可以随时关闭。Tap 是 <code>Tap</code> 类的对象，它具有 <code>close</code> 方法。它的用法在以下程序中证明:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval(0.3);
my $tap = $supply.tap({
    .say;
});

sleep 1;
$tap.close;
sleep 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第一秒打印前几个数字后，关闭 tap，之后该程序只需等待几秒钟即可打印。
如果没有 tap，则供应不会生成新数据。让我们在以下示例中创建 tap 之前暂停以查看其中的行为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval(0.3);

sleep 2;
my $tap = $supply.tap({
    .say;
});
sleep 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>tap 连接之前的延迟比潜在数据生成之间的间隔长。在2秒内，可能会生成一些数字，但程序仍然从从0开始打印数字。</p>
</div>
<div class="paragraph">
<p>当 tap 连接到已经为另一个 tap 生成数据的供应时，该原理也有效:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval(0.5);

say "Tap 1\t| Tap 2";
say '_' x 15;

$supply.tap({
    say "$_\t|";
});

sleep 2;

$supply.tap({
    say "\t| $_";
});

sleep 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这两个 tap 在这里独立工作。这就是程序输出的样子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Tap 1 | Tap 2
_______________
0     |
1     |
2     |
3     |
      | 0
4     |
      | 1
5     |
      | 2
6     |
      | 3
7     |
      | 4
8     |
      | 5
9     |</code></pre>
</div>
</div>
<div class="paragraph">
<p>两个 tap 都接收从零开始的序列。 interval 方法是一种创建按需供应的工厂方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval(10);
say $supply.WHAT; # (Supply)</code></pre>
</div>
</div>
<div class="paragraph">
<p>有一种创建供应的替代语法 - 我们将在下一节中讨论它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_react_和_whenever_关键字">15.2.2. react 和 whenever 关键字</h4>
<div class="paragraph">
<p>在 Raku 中，有一些特殊的关键字用于按需供应。使用 react 关键字代替显式创建 Supply 类的对象。在这种情况下，用 <code>whenever</code> 块替换创建 tap:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    whenever Supply.interval(0.5) {
        .say;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序每0.5秒打印一次数字。注意与以前的例子的主要区别。通过 react，无需调用 sleep 或在创建 tap 后以某种方式控制程序的生命周期。该程序无限运行，直到你使用 Ctrl + C 退出.</p>
</div>
<div class="paragraph">
<p>要以编程方式中断循环，请调用 <code>done</code> 函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    whenever Supply.interval(0.5) {
        .say;
        done if $_ &gt; 3;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这次，程序只打印几秒钟的数字。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用列表作为_supply_数据的源">15.2.3. 使用列表作为 supply 数据的源</h4>
<div class="paragraph">
<p>Supply 类提供了一个特殊的方法, <code>from-list</code>, 它接收一个列表并从该列表中发送元素作为发出的数据项:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.from-list('a'..'e');
$supply.tap({
    .say;
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，可以使用 react-whenever 结构:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    whenever Supply.from-list('a'..'e') {
        .say;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下，程序立即将所有元素流式传输到 tap 来打印它们。</p>
</div>
<div class="paragraph">
<p>与 interval 方法类似，from-list 创建一个供应对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.from-list(1..10);
say $supply.WHAT; # (Supply)</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在是时候谈论另一种类型的供应了，即现场供应。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_现场供应">15.3. 现场供应</h3>
<div class="paragraph">
<p>无论 tap 数量多少，现场供应都会生成数据。与按需供应不同，如果没有打开 tap，仍然会生成发射的数据，只是它会消失。只要打开了 tap，它从那一刻开始接收数据; 所有的历史都丢失了。</p>
</div>
<div class="paragraph">
<p>要创建现场供应，请调用 <code>Supplier</code> 类的构造函数。必须在供应上连接 tap，由 <code>Supply</code> 工厂方法返回。这一切都在下面的例子中显示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supplier = Supplier.new;

$supplier.Supply.tap({
    say $_;
});

$supplier.emit($_) for 'a'..'e';</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能会对 <code>Supply</code> 和 <code>Supplier</code> 类的存在感到困惑。<code>Supplier</code> 类是生产现场供应的工厂。</p>
</div>
<div class="paragraph">
<p>让我们看看现场供应如何流式传输数据以及没有 tap 打开时会发生什么。在在下面的程序中，现场供应在由 <code>start</code> 关键字创建的单独线程中生成数据。实际上，<code>start</code> 创造了一个承诺(见第13章，并发编程)，因此它伴随着 <code>await</code> 关键字，等待一切都完成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supplier = Supplier.new;

my $emitter = start {
    for 'a'..'e' {
        sleep 1;
        $supplier.emit($_);
    }
}

sleep 3;
$supplier.Supply.tap({
    say $_;
});

await $emitter;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$emitter</code> 承诺在程序开始后每秒从 'a'&#8230;&#8203;'e' 范围发布其数据。tap 在 3 秒后创建。从那一刻起，tap 开始从供应中获取值，程序打印 c，d 和 e。前三个数据片丢失(没有打开的 tap 接收它们)。请注意，供应和 tap 都没有排队历史。</p>
</div>
<div class="paragraph">
<p>如果有超过一个 tap 连接，现场供应以及按需供应会平均分配数据:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supplier = Supplier.new;
my $supply = $supplier.Supply;

$supply.tap({
    say "Tap 1 got $_";
});

$supply.tap({
    say "Tap 2 got $_";
});

$supplier.emit(10.rand);
$supplier.emit(10.rand);</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序发出两个随机数，这两个随机数都会落在这两个 tap 中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Tap 1 got 3.49754022030442
Tap 2 got 3.49754022030442
Tap 1 got 0.196464185630715
Tap 2 got 0.196464185630715</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 中的反应式编程是线程安全的。例如，让我们创建一个程序， 其中所有的供应和 tap 都在它们自己的线程中执行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supplier = Supplier.new;

start {
    $supplier.Supply.tap({
        say "Tap 1 got $_";
    })
}

start {
    $supplier.Supply.tap({
        say "Tap 2 got $_";
    })
}

start {
    sleep 1;
    $supplier.emit(42);
}

sleep 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它完美地工作 - 两个 tap 都接收供应发出的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Tap 2 got 42
Tap 1 got 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要我们有线程并且它们并行地工作，那么程序的输出就可能是不同的，这取决于哪个 tap 首先得到它的数据:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Tap 2 got 42
Tap 1 got 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>要了解有关 <code>Supply</code> 和 <code>Supplier</code> 类方法的更多信息，请参阅 <a href="docs.raku.org" class="bare">docs.raku.org</a> 网站的有关文档。</p>
</div>
<div class="sect3">
<h4 id="_过滤和转换数据流">15.3.1. 过滤和转换数据流</h4>
<div class="paragraph">
<p><code>Supply</code> 类的对象具有 <code>grep</code> 和 <code>map</code> 方法，可用于过滤流的数据, 这类似于同名的内置函数。<code>grep</code> 和 <code>map</code> 方法都创建一个新的 <code>Supply</code> 对象，你可以在它上面连接 tap。</p>
</div>
<div class="paragraph">
<p>请考虑以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval(0.3);

my $filtered = $supply.grep(* %% 2);

$filtered.tap({
    .say;
});

sleep 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们之前在按需供应一节中有类似的程序。这一次，另一个供应，<code>$filtered</code>，嵌入在数据流中。它由在原始的 <code>$supply</code> 身上调用的 <code>grep</code> 方法创建。</p>
</div>
<div class="paragraph">
<p>过滤器本身由 <code>WhateverCode</code> 块 <code>* %% 2</code> 实现。现在只有偶数从 <code>$supply</code> 传递到 <code>$filtered</code>。</p>
</div>
<div class="paragraph">
<p>对于其他，<code>$supply</code> 和 <code>$filtered</code> 对象都是常规的按需供应，而且你可以根据需要附加任意数量的 tap:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval(0.3);
my $filtered = $supply.grep(* %% 2);

$supply.tap({
    "Unfiltered tap got $_".say;
});

$filtered.tap({
    "Filtered tap 1 got $_".say;
});

$filtered.tap({
    "Filtered tap 2 got $_".say;
});

sleep 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序生成以下输出，其中包含来自所有三个 tap 的反应:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Filtered tap 1 got 0
Unfiltered tap got 0
Filtered tap 2 got 0
Unfiltered tap got 1
Unfiltered tap got 2
Filtered tap 1 got 2
Filtered tap 2 got 2
Unfiltered tap got 3
Unfiltered tap got 4
Filtered tap 1 got 4
Filtered tap 2 got 4
Unfiltered tap got 5
Unfiltered tap got 6
Filtered tap 1 got 6
Filtered tap 2 got 6
Unfiltered tap got 7
Unfiltered tap got 8
Filtered tap 1 got 8
Filtered tap 2 got 8
Unfiltered tap got 9</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，发出的数字是递增的，过滤后的供应只接收偶数值。</p>
</div>
<div class="paragraph">
<p>另一个方法是 <code>map</code>，转换数据并返回变换后的流的新供应。请考虑以下示例，其中由 <code>interval</code> 供应所生成的所有数字都转换为2次方:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Supply.interval(0.3).map(* ** 2).tap(*.say);
sleep 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，两个 <code>*</code> 是为了简洁。如果您更喜欢冗长的样式，请使用 <code>$_</code> 变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Supply.interval(0.3).map({
    $_ ** 2
}).tap({
    .say
});

sleep 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序按预期打印前几个整数的平方。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_18">15.4. 总结</h3>
<div class="paragraph">
<p>在本章中，我们讨论的是 Raku 中的反应式编程。这个范式有语言核心的支持，因此无需外部模块即可开始编程。供应是本章的主角 - 我们介绍了它们的两种不同类型， 按需供应和现场供应。我们有许多将 tap 连接到供应上的例子，并且看到了如何组织数据流以及如何过滤数据流。</p>
</div>
<div class="paragraph">
<p>这是本书的最后一章。在 15 章中，我们从 Raku 的基础知识出发， 通过面向对象的方法和并发编程到更高阶的功能， 例如函数式编程和反应式编程。Raku 自然地嵌入了所有这些范式。毫无疑问，超过 15 年的开发增加了质量和成熟度。</p>
</div>
<div class="paragraph">
<p>本书大约花费了半年时间，Rakudo 发布了 3 个主版本。我不得不承认编译器的质量是如此之高， 在过去的2到3年里，从未经历过任何崩溃或奇怪的行为。在各种 Perl 会议上的与会者，我注意到越来越多的人对 Raku 感兴趣并说现在一切正常。您可以下载编译器，它开箱即用，提供了 Raku 所具有的大量功能。</p>
</div>
<div class="paragraph">
<p>语言本身的当前版本是 6.c. 字母 c 代表圣诞节。很长一段时间，人们宣布 Raku 将在圣诞节前准备好，而不提及它会发生在哪一年。最后，6.c 标准在圣诞节期间成为现实。 2015 年晚些时候或2018 年初，将发布该语言的新版本。你可以在 Larry Wall 的主题演讲中找到更多细节，他在 2002 年的 Perl 会议上发表了主题演讲 <a href="https://youtube/E5t8qaAGw9w" class="bare">https://youtube/E5t8qaAGw9w</a>。</p>
</div>
<div class="paragraph">
<p>作为本书的作者，我希望我的读者能够喜欢这种语言并开始在他们的语言中实践使用它。您使用该语言的次数越多，您就越了解其潜力有多大。我们现在正处于 Raku 新时代的开端。</p>
</div>
</div>
</div>
</div>

</article>


    

  </main><section class="site__search">
    <label class="site__form">
        <p class="form__label">Search around the site</p> 
        <input class="site__search-bar form__input" type="text">
    </label>
    <div class="site__search-bar-results"></div>
</section>
  
  <footer class="site__footer">
    
    
    <p class="footer__sign">© 2020 ohmyraku</p></footer>
    

    
    <script>
        window.addEventListener("load", function () {
            const script = document.createElement("script");
            script.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
            script.async = true

            document.head.appendChild(script);
        })
    </script>





<script defer type="text/javascript" src="https://ohmyraku.github.io/js/script.14164ab553b19613ce98aadb54b1ed9a89ae5b056c72b99a4c672e37954f33d67bebe1452b0279025ba889964b51bdf8ec69683933cf427ae67c08ac2cdda7b1.js" integrity="sha512-FBZKtVOxlhPOmKrbVLHtmomuWwVscrmaTGcuN5VPM9Z76&#43;FFKwJ5AluoiZZLUb347GloOTPPQnrmfAisLN2nsQ=="></script>



</body>
</html>