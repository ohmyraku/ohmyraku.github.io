<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Raku 深入研究 :: 山川异域, 风月同天</title>

<meta name="author" content="ohmyraku">
<meta name="application-name" content="山川异域, 风月同天">
<meta name="description" content="Table of Contents 1. 什么是 Raku 1.1. Raku 起源 1.2. 与 Perl 5 的区别 1.3. 类 1.4. 与 Perl 5 的兼容性 1.5. Raku 资源 1.6. 文档 1.7. 测试套件 1.8. STD.pm 1.9. 社区 1.10. 编译器 1.11. 使用 Rakudo Star 1.12. 命令行选项 1.13. 总结   2. 编写代码 2.1. 使用 Unicode 2.2. 空白和反空白 2.3. 注释 2.4. phaser 2.5. 总结   3. 变量和内置数据类型 3.1. 使用变量 3.2. 使用简单的内置数据类型 3.3. 操作日期和时间的数据类型 3.4. 总结   4.">
<meta name="robots" content="noodp"/>
<meta name="generator" content="Hugo 0.63.2" />
<meta name="referrer" content="no-referrer" />
<meta name="format-detection" content="telephone=no">

<link rel="canonical" href="https://ohmyraku.github.io/raku-deep-dive/" />


<link rel="icon" href="https://ohmyraku.github.io/logo.png" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Raku 深入研究" />
<meta name="twitter:description" content="Table of Contents 1. 什么是 Raku 1.1. Raku 起源 1.2. 与 Perl 5 的区别 1.3. 类 1.4. 与 Perl 5 的兼容性 1.5. Raku 资源 1.6. 文档 1.7. 测试套件 1.8. STD.pm 1.9. 社区 1.10. 编译器 1.11. 使用 Rakudo Star 1.12. 命令行选项 1.13. 总结   2. 编写代码 2.1. 使用 Unicode 2.2. 空白和反空白 2.3. 注释 2.4. phaser 2.5. 总结   3. 变量和内置数据类型 3.1. 使用变量 3.2. 使用简单的内置数据类型 3.3. 操作日期和时间的数据类型 3.4. 总结   4." />
<meta name="twitter:site" content="https://ohmyraku.github.io" />
<meta name="twitter:creator" content="ohmyraku" />
<meta name="twitter:image" content="https://ohmyraku.github.io/logo.png">
<meta property="og:type" content="article" />
<meta property="og:locale" content="en" />
<meta property="og:name" content="ohmyraku" />
<meta property="og:title" content="Raku 深入研究" />
<meta property="og:url" content="https://ohmyraku.github.io" />
<meta property="og:site_name" content="山川异域, 风月同天" />
<meta property="og:description" content="Table of Contents 1. 什么是 Raku 1.1. Raku 起源 1.2. 与 Perl 5 的区别 1.3. 类 1.4. 与 Perl 5 的兼容性 1.5. Raku 资源 1.6. 文档 1.7. 测试套件 1.8. STD.pm 1.9. 社区 1.10. 编译器 1.11. 使用 Rakudo Star 1.12. 命令行选项 1.13. 总结   2. 编写代码 2.1. 使用 Unicode 2.2. 空白和反空白 2.3. 注释 2.4. phaser 2.5. 总结   3. 变量和内置数据类型 3.1. 使用变量 3.2. 使用简单的内置数据类型 3.3. 操作日期和时间的数据类型 3.4. 总结   4." />
<script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "Article",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https:\/\/ohmyraku.github.io\/raku-deep-dive\/"
      },
      "headline": "Raku 深入研究",
      
      "datePublished": "2020-02-05",
      "dateModified": "2020-02-05 15:26:52 \x2b0800 CST",
      "author": {
        "@type": "Person",
        "name": "ohmyraku"
      },
      "description": "Table of Contents 1. 什么是 Raku 1.1. Raku 起源 1.2. 与 Perl 5 的区别 1.3. 类 1.4. 与 Perl 5 的兼容性 1.5. Raku 资源 1.6. 文档 1.7. 测试套件 1.8. STD.pm 1.9. 社区 1.10. 编译器 1.11. 使用 Rakudo Star 1.12. 命令行选项 1.13. 总结   2. 编写代码 2.1. 使用 Unicode 2.2. 空白和反空白 2.3. 注释 2.4. phaser 2.5. 总结   3. 变量和内置数据类型 3.1. 使用变量 3.2. 使用简单的内置数据类型 3.3. 操作日期和时间的数据类型 3.4. 总结   4.",
      "publisher": {
        "@type": "Organization",
        "name": "https:\/\/ohmyraku.github.io",
        "logo": {
          "@type": "ImageObject",
          "url": "https:\/\/ohmyraku.github.io\/logo.png"
        }
      }
    }
</script><link rel="stylesheet" href="https://ohmyraku.github.io/scss/main.min.84f71d25d375c522a861bb4719728ce6839cf3635b15ca0c7a1b4d799c2dc3399a1d6cb46058a9d8fdbebe9156a8857279cfdeb70aa3862e629de234b5a41fa1.css" integrity="sha512-hPcdJdN1xSKoYbtHGXKM5oOc82NbFcoMehtNeZwtwzmaHWy0YFip2P2&#43;vpFWqIVyec/etwqjhi5ineI0taQfoQ==">
<script>

const theme = window.localStorage.getItem('theme'); 
if (theme && theme !== "1") {
    document.documentElement.classList.add('theme-' + theme);
}
</script>


</head>
<body>
  <main class="site__content">
    <div class="site__page">
  <nav class="site__breadcrumbs">
    <a class="site__breadcrumb" href="https://ohmyraku.github.io/">山川异域, 风月同天</a><a class="site__breadcrumb--active" href="https://ohmyraku.github.io/raku-deep-dive/">Raku 深入研究</a>
</nav>

<h1 class="page__title">Raku 深入研究</h1>
  <div class="page__meta">
    <p>
    
    <span class="page__date">
    on <time datetime="2020-02-05T15:26:52&#43;08:00">2020-02-05</time>
    
    </span>
    </p>

    

    
    </div>
</div>


</div>

<article class="page__content" ><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_什么是_raku">1. 什么是 Raku</a>
<ul class="sectlevel2">
<li><a href="#_raku_起源">1.1. Raku 起源</a></li>
<li><a href="#_与_perl_5_的区别">1.2. 与 Perl 5 的区别</a></li>
<li><a href="#_类">1.3. 类</a></li>
<li><a href="#_与_perl_5_的兼容性">1.4. 与 Perl 5 的兼容性</a></li>
<li><a href="#_raku_资源">1.5. Raku 资源</a></li>
<li><a href="#_文档">1.6. 文档</a></li>
<li><a href="#_测试套件">1.7. 测试套件</a></li>
<li><a href="#_std_pm">1.8. STD.pm</a></li>
<li><a href="#_社区">1.9. 社区</a></li>
<li><a href="#_编译器">1.10. 编译器</a></li>
<li><a href="#_使用_rakudo_star">1.11. 使用 Rakudo Star</a></li>
<li><a href="#_命令行选项">1.12. 命令行选项</a></li>
<li><a href="#_总结">1.13. 总结</a></li>
</ul>
</li>
<li><a href="#_编写代码">2. 编写代码</a>
<ul class="sectlevel2">
<li><a href="#_使用_unicode">2.1. 使用 Unicode</a></li>
<li><a href="#_空白和反空白">2.2. 空白和反空白</a></li>
<li><a href="#_注释">2.3. 注释</a></li>
<li><a href="#_phaser">2.4. phaser</a></li>
<li><a href="#_总结_2">2.5. 总结</a></li>
</ul>
</li>
<li><a href="#_变量和内置数据类型">3. 变量和内置数据类型</a>
<ul class="sectlevel2">
<li><a href="#_使用变量">3.1. 使用变量</a></li>
<li><a href="#_使用简单的内置数据类型">3.2. 使用简单的内置数据类型</a></li>
<li><a href="#_操作日期和时间的数据类型">3.3. 操作日期和时间的数据类型</a></li>
<li><a href="#_总结_3">3.4. 总结</a></li>
</ul>
</li>
<li><a href="#_使用运算符">4. 使用运算符</a>
<ul class="sectlevel2">
<li><a href="#_运算符分类">4.1. 运算符分类</a></li>
<li><a href="#_raku_中的运算符">4.2. Raku 中的运算符</a></li>
<li><a href="#_raku_中的元运算符">4.3. Raku 中的元运算符</a></li>
<li><a href="#_总结_4">4.4. 总结</a></li>
</ul>
</li>
<li><a href="#_控制流">5. 控制流</a>
<ul class="sectlevel2">
<li><a href="#_了解代码块和变量作用域">5.1. 了解代码块和变量作用域</a></li>
<li><a href="#_有条件的检查">5.2. 有条件的检查</a></li>
<li><a href="#_使用循环">5.3. 使用循环</a></li>
<li><a href="#_执行代码一次">5.4. 执行代码一次</a></li>
<li><a href="#_使用_gather_和_take_收集数据">5.5. 使用 gather 和 take 收集数据</a></li>
<li><a href="#_总结_5">5.6. 总结</a></li>
</ul>
</li>
<li><a href="#_子例程">6. 子例程</a>
<ul class="sectlevel2">
<li><a href="#_默认值">6.1. 默认值</a></li>
<li><a href="#_可选参数">6.2. 可选参数</a></li>
<li><a href="#_命名参数">6.3. 命名参数</a></li>
<li><a href="#_参数特征">6.4. 参数特征</a></li>
<li><a href="#_吞噬参数">6.5. 吞噬参数</a></li>
<li><a href="#_参数占位符">6.6. 参数占位符</a></li>
<li><a href="#_类型约束">6.7. 类型约束</a></li>
<li><a href="#_返回类型">6.8. 返回类型</a></li>
<li><a href="#_multi_subs">6.9. Multi Subs</a></li>
<li><a href="#_一个例子">6.10. 一个例子</a></li>
<li><a href="#_嵌套的子程序">6.11. 嵌套的子程序</a></li>
<li><a href="#_总结_6">6.12. 总结</a></li>
<li><a href="#_创建和调用子例程">6.13. 创建和调用子例程</a></li>
<li><a href="#_类型约束_2">6.14. 类型约束</a></li>
<li><a href="#_multi_subs_2">6.15. Multi subs</a></li>
<li><a href="#_嵌套子例程">6.16. 嵌套子例程</a></li>
<li><a href="#_创建运算符">6.17. 创建运算符</a></li>
<li><a href="#_传递函数作为参数">6.18. 传递函数作为参数</a></li>
<li><a href="#_匿名子例程">6.19. 匿名子例程</a></li>
<li><a href="#_总结_7">6.20. 总结</a></li>
</ul>
</li>
<li><a href="#_模块">7. 模块</a>
<ul class="sectlevel2">
<li><a href="#_创建模块">7.1. 创建模块</a></li>
<li><a href="#_使用模块">7.2. 使用模块</a></li>
<li><a href="#_内省">7.3. 内省</a></li>
<li><a href="#_使用_zef">7.4. 使用 zef</a></li>
<li><a href="#_总结_8">7.5. 总结</a></li>
</ul>
</li>
<li><a href="#_面向对象编程">8. 面向对象编程</a>
<ul class="sectlevel2">
<li><a href="#_创建类">8.1. 创建类</a></li>
<li><a href="#_使用属性">8.2. 使用属性</a></li>
<li><a href="#_使用方法">8.3. 使用方法</a></li>
<li><a href="#_更多关于属性的信息">8.4. 更多关于属性的信息</a></li>
<li><a href="#_类方法">8.5. 类方法</a></li>
<li><a href="#_继承">8.6. 继承</a></li>
<li><a href="#_使用角色添加对象和类">8.7. 使用角色添加对象和类</a></li>
<li><a href="#_使用内省学习更多">8.8. 使用内省学习更多</a></li>
<li><a href="#_方法后缀运算符">8.9. 方法后缀运算符</a></li>
<li><a href="#_总结_9">8.10. 总结</a></li>
</ul>
</li>
<li><a href="#_输入和输出">9. 输入和输出</a>
<ul class="sectlevel2">
<li><a href="#_从流中读取">9.1. 从流中读取</a></li>
<li><a href="#_写出到流">9.2. 写出到流</a></li>
<li><a href="#_标准输入和输出">9.3. 标准输入和输出</a></li>
<li><a href="#_使用文件和目录">9.4. 使用文件和目录</a></li>
<li><a href="#_从流中读取_2">9.5. 从流中读取</a></li>
<li><a href="#_写入流">9.6. 写入流</a></li>
<li><a href="#_总结_10">9.7. 总结</a></li>
</ul>
</li>
<li><a href="#_异常">10. 异常</a>
<ul class="sectlevel2">
<li><a href="#_try_块">10.1. try 块</a></li>
<li><a href="#_catch_phaser">10.2. CATCH phaser</a></li>
<li><a href="#_exception_对象">10.3. Exception 对象</a></li>
<li><a href="#_failure_对象">10.4. Failure 对象</a></li>
<li><a href="#_创建自定义异常">10.5. 创建自定义异常</a></li>
<li><a href="#_总结_11">10.6. 总结</a></li>
<li><a href="#_总结_12">10.7. 总结</a></li>
</ul>
</li>
<li><a href="#_正则表达式">11. 正则表达式</a>
<ul class="sectlevel2">
<li><a href="#_与正则表达式匹配">11.1. 与正则表达式匹配</a></li>
<li><a href="#_字面量">11.2. 字面量</a></li>
<li><a href="#_字符类">11.3. 字符类</a></li>
<li><a href="#_使用量词创建可重复模式">11.4. 使用量词创建可重复模式</a></li>
<li><a href="#_使用捕获提取子字符串">11.5. 使用捕获提取子字符串</a></li>
<li><a href="#_在正则表达式中使用备选项">11.6. 在正则表达式中使用备选项</a></li>
<li><a href="#_用锚点定位正则表达式">11.7. 用锚点定位正则表达式</a></li>
<li><a href="#_使用断言进行向前查看和向后查看">11.8. 使用断言进行向前查看和向后查看</a></li>
<li><a href="#_使用副词修饰正则表达式">11.9. 使用副词修饰正则表达式</a></li>
<li><a href="#_使用正则表达式替换和修改字符串">11.10. 使用正则表达式替换和修改字符串</a></li>
<li><a href="#_总结_13">11.11. 总结</a></li>
</ul>
</li>
<li><a href="#_grammars">12. Grammars</a>
<ul class="sectlevel2">
<li><a href="#_创建_grammar">12.1. 创建 grammar</a></li>
<li><a href="#_使用_rule_和_token">12.2. 使用 rule 和 token</a></li>
<li><a href="#_使用_action">12.3. 使用 action</a></li>
<li><a href="#_使用抽象语法树属性">12.4. 使用抽象语法树属性</a></li>
<li><a href="#_使用_action_类">12.5. 使用 action 类</a></li>
<li><a href="#_完整的程序">12.6. 完整的程序</a></li>
<li><a href="#_总结_14">12.7. 总结</a></li>
</ul>
</li>
<li><a href="#_并发编程">13. 并发编程</a>
<ul class="sectlevel2">
<li><a href="#_junction">13.1. Junction</a></li>
<li><a href="#_线程">13.2. 线程</a></li>
<li><a href="#_终身线程">13.3. 终身线程</a></li>
<li><a href="#_promise">13.4. Promise</a></li>
<li><a href="#_channel">13.5. Channel</a></li>
<li><a href="#_总结_15">13.6. 总结</a></li>
</ul>
</li>
<li><a href="#_函数式编程">14. 函数式编程</a>
<ul class="sectlevel2">
<li><a href="#_什么是函数式编程">14.1. 什么是函数式编程</a></li>
<li><a href="#_使用递归">14.2. 使用递归</a></li>
<li><a href="#_使用化简">14.3. 使用化简</a></li>
<li><a href="#_高阶函数和_lambda">14.4. 高阶函数和 lambda</a></li>
<li><a href="#_管道数据和_feed_运算符">14.5. 管道数据和 feed 运算符</a></li>
<li><a href="#_操作作用域">14.6. 操作作用域</a></li>
<li><a href="#_创建并使用迭代器">14.7. 创建并使用迭代器</a></li>
<li><a href="#_惰性和无限列表">14.8. 惰性和无限列表</a></li>
<li><a href="#_总结_16">14.9. 总结</a></li>
</ul>
</li>
<li><a href="#_反应式编程">15. 反应式编程</a>
<ul class="sectlevel2">
<li><a href="#_什么是反应式编程">15.1. 什么是反应式编程</a></li>
<li><a href="#_按需供应">15.2. 按需供应</a></li>
<li><a href="#_实时供应">15.3. 实时供应</a></li>
<li><a href="#_总结_17">15.4. 总结</a></li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_什么是_raku">1. 什么是 Raku</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在这一章中，我们将研究 Raku 出现的原因，并跟踪了解 Perl 语言的发展历史。你会看到一些自 Perl 5 以来发生的变化，你会看到一些例子，你会学习如何下载和使用编译器，在哪里找到文档，以及如何在 Raku 中运行你的第一个程序。</p>
</div>
<div class="paragraph">
<p>在这一章中，我们将介绍以下内容:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku 的起源</p>
</li>
<li>
<p>与 Perl 5 的区别</p>
</li>
<li>
<p>Raku 资源</p>
</li>
<li>
<p>编译器</p>
</li>
<li>
<p>使用 Rakudo Star</p>
</li>
<li>
<p>编写我们的 Hello World 程序</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_raku_起源">1.1. Raku 起源</h3>
<div class="paragraph">
<p>Raku 是 Perl 家族中的一种编程语言。Perl 本身出现于 1987 年，从那时起，它就在不断发展：目前的稳定版本是 2017年5月发布的5.26。2000年，Perl 的创造者 Larry Wall 提出要开始研究该语言的下一个版本- Raku 。</p>
</div>
<div class="paragraph">
<p>这有几个原因。首先，一种语言应该继续发展，以反映开发者的新要求。第二，它可能会改变非 Perl 社区对 Perl 的看法。5.0 版本出现在 1993 年，尽管如此，Perl 语言仍在继续发展。当时的主要版本号仍然是 5，在很多人看来，这意味着 Perl 从 1993 年开始就停滞不前了。新的主要版本更新会刷新人们的认知。</p>
</div>
<div class="paragraph">
<p>这个想法是让 Raku 成为"Perl 社区的重写"。拉里要求社区分享他们想要改变的 Perl 的部分。变更请求导致了 361 份 RFC (请求评论)文档，这些文档发布在 <a href="https://raku.org/archive/rfc" class="bare">https://raku.org/archive/rfc</a> 中。这些文件仅具有历史意义。</p>
</div>
<div class="paragraph">
<p>随后，人们对各种提案进行了系统的分析，按相似的主题进行了分组，并作为一系列概要发布。这些文档背后的命名和编号原则是为了保持 Programming Perl 一书的章节结构。</p>
</div>
<div class="paragraph">
<p>后来，概要再次被归纳和解释为一组名为 Apocalypses 和 Exegeses 的文档。所有这些文件今天都可以在 <a href="http://design.raku.org" class="bare">http://design.raku.org</a> 上找到，但同样的，它们并不是语言的最终规范，只是历史文献的集合。</p>
</div>
<div class="paragraph">
<p>关于 Raku 的另一个重要想法是关于编译器的创建方式。在 Perl 5 中，语言规则是由单一可用的编译器间接定义的。一些 bug，或者是编译器的不明显的行为，可能会被认为是语言标准的一部分。在 Raku 中，决定有一个明确的语言规范，没有参考编译器。可以有不止一个编译器。对它们的主要要求是实现规范并通过测试集。</p>
</div>
</div>
<div class="sect2">
<h3 id="_与_perl_5_的区别">1.2. 与 Perl 5 的区别</h3>
<div class="paragraph">
<p>让我们简单地看一下在通往 Raku 的路上发生的一些变化。在下面的章节中，你会看到一些 Perl 5 和 Raku 中的代码示例。这些例子的目的是为了让你对 Perl 5 到 Raku 的转变有一个大致的了解，但你不需要了解其中的每一个细节。所有关于 Raku 语法的细节将在本书的后面讲解。</p>
</div>
<div class="sect3">
<h4 id="_符号">1.2.1. 符号</h4>
<div class="paragraph">
<p>对于初学 Perl 的人来说，最难的一个东西就是 sigil。sigil 是 Perl 中变量名称前面的一个字符，表示变量的结构类型。例如，<code>$</code> 代表标量值，<code>@</code> 代表数组，<code>%</code> 代表散列。</p>
</div>
<div class="paragraph">
<p>当你访问数组或散列的元素时，问题就出现了。让我们以下面这几行 Perl 5 斐波那契数组的前几个数为例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @fibonacci = (0, 1, 1, 2, 3, 5, 8, 13);
print $fibonacci[4];</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，创建一个 <code>@fibonacci</code> 数组。变量的名称中包含了 <code>@</code> 字符作为标志。在第二行中，我们访问该数组中的一个元素，这次我们使用另一个标号 <code>$</code>。这是因为数组中的单个元素是标量，而标量使用 <code>$</code> 作为符号。对于学习 Perl 的人来说，符号的这个小变化对理解 Perl 语言的基础知识是个大问题。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，符号是统一的，是变量名的一部分。无论你是访问数组中的一个元素，还是访问整个数组，都不能单独改变它。上面的例子在 Raku 中是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @fibonacci = (0, 1, 1, 2, 3, 5, 8, 13);
print @fibonacci[4];</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两行中，<code>@fibonacci</code> 数组和它的 <code>@fibonacci[4]</code> 元素都使用了相同的符号。这种方法对于初学者来说，更加一致，也更容易。</p>
</div>
</div>
<div class="sect3">
<h4 id="_签名">1.2.2. 签名</h4>
<div class="paragraph">
<p>在 Perl 5 中，你必须通过使用内置的 <code>shift</code> 函数或者从默认的 @_ 数组中提取函数的参数值。</p>
</div>
<div class="paragraph">
<p>让我们用下面的例子来看看，一个计算两个参数之和的函数。在 Perl 5 中，你必须做一些额外的工作来获取实际传递的参数。</p>
</div>
<div class="paragraph">
<p>首先，用 Perl 5 中的 <code>shift</code> 来获取参数值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">sub add {
    my $x = shift;
    my $y = shift;
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，通过使用 @_ 数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">sub add {
    my ($x, $y) = @_;
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与许多其他编程语言不同的是，不可能直接声明一个函数的形式参数列表。例如，你在 C 语言或 <code>C++</code> 中就是这样做的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">int add(int x, int y) {
    return x + y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Perl 5 中，可以借助于原型来限制参数的数量和结构类型。这里的符号是用来告诉 Perl 参数的类型。上面的加法函数在 Perl 5 中可能是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($$) {
    my ($x, $y) = @_;
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用函数原型会使编译器在使用不同数量的参数（例如，一个或三个参数而不是两个）时产生抱怨，但你仍然需要自己获取它们的值。</p>
</div>
<div class="paragraph">
<p>Perl 5.20 引入了函数签名。所以，现在，你可能会从一次性声明参数中受益。下面的代码给出了这样一个例子。<code>$x</code> 和 <code>$y</code> 参数都在函数头中声明:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">use v5.20;

use feature qw(signatures);
no warnings qw(experimental::signatures);

sub add($x, $y) {
    return $x + $y;
}

say add(4,5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>你会注意到，你需要在脚本中提到 Perl 5.20 的最小版本号来指示 Perl 使用 Perl 5.20 的功能。你还会注意到，你必须通过单独的指令激活相应的功能。但是，更重要的是，由于签名是一个实验性的功能，你必须手动关闭警告信息，才能得到一个干净的输出。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，函数签名从一开始就被允许使用，所以你可以直接使用它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># This is  Raku
sub add($x, $y) {
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上，Perl 5.20 中的签名是将 Raku 的功能从 Raku 中移植到 Perl 5 中的一个例子，所以尽管 Raku 是 Perl 5 的下一个版本，但 Perl 5 中的一些元素在 Raku 中仍然得到了一些设计上的元素，使 Perl 变得更好。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类">1.3. 类</h3>
<div class="paragraph">
<p>为了让用户体验更好，让我们来看看另一个重要的例子，看看 Raku 中 Perl 语法的变化在哪里。</p>
</div>
<div class="paragraph">
<p>传统上，在 Perl 5 中，面向对象编程是借助于所谓的被祝福的散列来完成的。对象中的数据成员是散列的元素，而这个散列的被祝福的引用可以用来调用类的实例上的方法。下面的例子告诉你如何在 Perl 5 中定义一个类并创建一个类的实例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">package MyClass;

sub new {
    my ($class) = @_;
    my $this = {
        counter =&gt; 0
    };
    bless $this, $class;
    return $this;
}

sub inc {
    my ($this) = @_;
    $this-&gt;{counter}++;
    return $this-&gt;{counter};
}

1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>到目前为止，名为 <code>MyClass</code> 的类有两个方法 - <code>new</code>，用于创建一个新的实例，和 <code>inc</code>，用于递增计数器并返回新值。在处理 Perl 5 的类时，不要忘了在模块的末尾返回一个真值，这就是文件最后一行中的1的目标。</p>
</div>
<div class="paragraph">
<p>在主程序中，你可以通过创建一个实例并在变量上调用方法来使用 <code>MyClass</code>，方法如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use MyClass;

my $var = MyClass-&gt;new;

print $var-&gt;inc, "\n";
print $var-&gt;inc, "\n";
print $var-&gt;inc, "\n";</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Perl 5 中实现面向对象的东西是另一个障碍，因为对于新手来说，他们可能有过在其他语言中使用类的经验，但对 Perl 5 创建类的方式感到困惑。</p>
</div>
<div class="paragraph">
<p>对于使用过其他面向对象编程语言的开发人员来说，Raku 中的类对他们来说更加熟悉。</p>
</div>
<div class="paragraph">
<p>这就是在 Raku 中定义同样的类的方法，如上例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class MyClass {
    has $!counter;

    method inc() {
        $!counter++;
        return $!counter;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见，整个类是在这对花括号内定义的。它的数据成员是用 <code>has</code> 关键字显式声明的，不需要在文件的最后返回 1。</p>
</div>
<div class="paragraph">
<p>现在，创建一个类的对象，然后像我们之前在 Perl 5 中的例子一样，将内部计数器增量三次。在 Raku 中就是这样做的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $var = MyClass.new;

say $var.inc;
say $var.inc;
say $var.inc;</code></pre>
</div>
</div>
<div class="paragraph">
<p>暂时不要把注意力放在细节上，因为这一切都会在后面的章节中解释。</p>
</div>
<div class="paragraph">
<p>到目前为止，我们已经看到了三个例子，希望改进 Perl 5 的语法。</p>
</div>
<div class="paragraph">
<p>要查看更多关于 Perl 5 和 Raku 之间的变化的例子，你可以参考 Raku 的文档  <a href="docs.raku.org/language.html" class="bare">docs.raku.org/language.html</a>，其中有几篇文章以 "Perl 5 到 Raku 指南"为标题，专门讨论这个主题。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5to6-nutshell</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Perl 5 到 Raku 指南 - 一言以蔽之,我怎么做我以前做的事?</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5to6-perlfunc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Perl 5 到 Raku 指南 — 函数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5to6-perlop</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Perl 5 到 Raku 指南 - 操作符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5to6-perlsyn</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Perl 5 到 Raku 指南 - 语法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5to6-perlvar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Perl 5 到 Raku 指南 - 特殊变量</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_与_perl_5_的兼容性">1.4. 与 Perl 5 的兼容性</h3>
<div class="paragraph">
<p>现有的 Raku 编译器在不修改源代码的情况下，无法执行 Perl 5 程序。Perl 5 和 Raku 有时被称为姐妹语言。两者有着相同的 Perl 精神，在很多情况下，可以将程序从 Perl 5 转换为 Raku。</p>
</div>
<div class="paragraph">
<p>Perl 5 的最大优势之一是 <strong>CPAN(Perl 综合档案网络)</strong>。它包含了无数的模块，适用于大量的领域。最有可能的是，你的任务已经被 CPAN 的一些作者解决了。要想在 Raku 中使用这些有用的遗产，你可能想使用 <code>Inline::Perl5</code> 模块，它允许在不修改源代码的情况下使用现有的 Perl 5 模块。</p>
</div>
<div class="paragraph">
<p>例如，让我们以 Perl 5 中最流行的模块之一 <code>Text::CSV</code> 为例，将其嵌入到 Raku 中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Inline::Perl5;
use Text::CSV:from&lt;Perl5&gt;;

my $csv = Text::CSV.new;

$csv.parse('First name,Last name');
say $csv.fields.join("\t");

$csv.parse('Astrid,Lindgren');
say $csv.fields.join("\t");</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>Inline::Perl5</code> 启用后， <code>:from&lt;Perl5&gt;</code> 后缀将从 Perl 5 模块目录中加载 <code>Text::CSV</code> 模块。这个模块必须作为一个普通的 Perl 5 模块从 CPAN 中安装。</p>
</div>
<div class="paragraph">
<p>程序的其余部分使用 <code>$csv</code> 对象，它是 <code>Text::CSV</code> 的一个实例。注意，你必须遵循 Raku 的语法，因此，比如说，不要用  <code>Text::CSV&#8594;new</code> 来创建对象，而是用 <code>Text::CSV.new</code>。调用解析方法也是一样的：在 Perl 5 中是 <code>$csv&#8594;parse()</code> ，而在 Raku 中则是用点号: <code>$csv.parse()</code> 。在 Raku 中如何处理对象，请看第八章的"面向对象的编程"。</p>
</div>
<div class="paragraph">
<p>幸运的是，在 Raku 中已经有一个 <code>Text::CSV</code> 模块。你可以在 <a href="http://modules.raku.org" class="bare">http://modules.raku.org</a> 页面上找到它。使用  <code>Inline::Perl5</code> 对于那些在 CPAN 上还没有等价物或替代物的模块，使用 <code>Inline::Perl5</code> 可以非常有用。例如，下面的例子来自于模块文档中的例子显示了如何连接到数据库(当然，你需要安装 PostgreSQL 来测试这个例子):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Inline::Perl5;
use DBI:from&lt;Perl5&gt;;

my $dbh = DBI.connect('dbi:Pg:database=test');
my $products = $dbh.selectall_arrayref(
    'select * from products', {Slice =&gt; {}}
);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Inline::Perl5</code> 模块可在 <a href="https:/​/​github.​com/​niner/​Inline-Perl5" class="bare">https:/​/​github.​com/​niner/​Inline-Perl5</a> 上找到。</p>
</div>
</div>
<div class="sect2">
<h3 id="_raku_资源">1.5. Raku 资源</h3>
<div class="paragraph">
<p>Raku 有着悠久的历史，在那段时间里，有很多文档被创造出来，比如语言的想法、规范草案、编译器文档等。很多爱好者写了很多关于 Raku 的文章和博文。其中有些已经过时了，并不能反映语言的现状。在这一章中，我将给大家列举一些最新的资料，这些资料都是最新的，也是大家在使用 Raku 的实践中应该用到的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_文档">1.6. 文档</h3>
<div class="paragraph">
<p>Raku 编程语言文档的主要入口是 Raku 网站的文档部分(<a href="http:/​/​docs.raku.​org" class="bare">http:/​/​docs.raku.​org</a>)。它包含了几个部分，全面地描述了 Raku 中的类型、操作符和内置类。由于 Raku 语言还在发展中，有时你可能会发现文档中有些地方没有反映出语言的现状。在这种情况下，你可以咨询语言开发者社区或者从测试套件中查看文件。</p>
</div>
</div>
<div class="sect2">
<h3 id="_测试套件">1.7. 测试套件</h3>
<div class="paragraph">
<p>Raku 的测试套件，叫做 Roast，可以在  <a href="perl6/roast" class="bare">perl6/roast</a> 仓库中找到。它包含了成千上万的测试，涵盖了 Raku 的许多角落。如果你想了解用 Raku 编写程序的方法，这个测试套件也是个不错的地方。它有时可能是一个长篇大论，但很多测试都是从各个可能的角度来检查功能。</p>
</div>
<div class="paragraph">
<p>在 Roast 中，这些测试被归类到目录中，目录中的名称如 S32-io 等。这些名称对应着 Synopses 的编号，并被分成了主题部分。例如，对于 Synopses 11 "编译单元"，测试中存在三个目录- S11-compunits、S11-modules 和 S11-repository。</p>
</div>
</div>
<div class="sect2">
<h3 id="_std_pm">1.8. STD.pm</h3>
<div class="paragraph">
<p>STD.pm 是一个巨大的文件，描述了正式的 Raku 的 grammar。 Raku 的 grammar 是用 Raku 本身编写的。在资源库中包含了这个语法和 viv 工具，它可以将语法翻译成 Perl 5 的代码。我们之所以提到 STD.pm 语法，是因为对于那些想深入挖掘语法内部结构的读者来说，可能会有兴趣。在本书的其余部分，我们将以 Raku 中的代码实例为基础来解释这个语法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_社区">1.9. 社区</h3>
<div class="paragraph">
<p>Raku 的开发者们传统上使用IRC进行交流。你也可以加入 #raku 频道，在线询问有关该语言的问题或执行 Raku 的某个片段。
要加入该频道，请按照  页面上列出的说明进行操作。</p>
</div>
<div class="paragraph">
<p>如果你想在 IRC 中运行代码，请参考 rakudo bot 如下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">&lt;me&gt; rakudo: say "Hello, World!"
&lt;+camelia&gt; rakudo-moar cb8fa0: OUTPUT: «Hello, World!␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在输出中，可以看到 Rakudo 默认使用 MoarVM 后端。字符串 程序打印出来的数据会显示在 OUTPUT 关键字之后。</p>
</div>
<div class="paragraph">
<p>慎重使用这个功能，因为你的请求结果会被整个房间的人看到，也会被记录下来。最好的用例是当你发现 bug 或看到与文档中所说的不同的结果时，显示编译器的行为。 Raku 的开发者们总是在IRC频道中，他们会给你提供建议，指出错误的地方，或者会致力于修复 bug，并使文档正确。</p>
</div>
<div class="paragraph">
<p>如果你在 Facebook 上，请访问 Raku 小组。</p>
</div>
<div class="paragraph">
<p>在线下，你会在各种会议上看到很多热爱 Raku 的人。去参加 Perl 大会(以前叫YAPC，(Yet Another Perl Conference))，它
每年都会在欧洲和美国举行。你可以在  <a href="theperlconference.org" class="bare">theperlconference.org</a> 和脸书上找到更多关于他们的信息。多年来，在 OSCON 和 FOSDEM 等大型开源会议上都有 Perl 的工作展位。还有很多地方性的会议、研讨会和当地的小组会议。在脸书上找到离你所在的地方最近的小组。</p>
</div>
</div>
<div class="sect2">
<h3 id="_编译器">1.10. 编译器</h3>
<div class="paragraph">
<p>在 Raku 的开发过程中，产生了许多编译器。其中有的只是一个测试一些想法的游乐场，有的则是比较成熟的。其中最重要的，我们应该提到以下四个项目。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Parrot</p>
</li>
<li>
<p>Pugs</p>
</li>
<li>
<p>Perlito</p>
</li>
<li>
<p>Rakudo</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>之前有更多的人尝试过创建 Raku 编译器，但都不太成功，或者说不太完善。我们先看前面的列表，看看每个项目的亮点，然后重点介绍一下Rakudo，也就是今天应该使用的编译器。</p>
</div>
<div class="sect3">
<h4 id="_parrot">1.10.1. Parrot</h4>
<div class="paragraph">
<p>Parrot是第一个旨在成为 Raku 编译器基础的虚拟机。该语言最初的设计建议是将源代码编译成字节码，由虚拟机执行。Parrot的目标是创建一个适合处理 Raku 的所有需求的虚拟机，从简单的数据类型（如整数），到更复杂的结构（如类），都可以在对象上调用方法并遵循对象层次结构。</p>
</div>
<div class="paragraph">
<p>这个项目可以在 <a href="parrot.org" class="bare">parrot.org</a> 上找到。过了一段时间后，Parrot 开始支持其他编程语言，比如 Lua 或 Python，虚拟机也变得不那么专注于 Raku 本身。例如，Ponie 项目就是试图创建一个可以使用 Parrot 执行 Perl 5 程序的编译器。</p>
</div>
<div class="paragraph">
<p>Parrot 成为另一个项目 Rakudo 内部的虚拟机之一。不过，在说 Rakudo 之前，让我们沿着历史的轨迹来谈谈 Pugs。</p>
</div>
</div>
<div class="sect3">
<h4 id="_pugs">1.10.2. Pugs</h4>
<div class="paragraph">
<p>Pugs(Perl 用户高尔夫系统)是一个用 Haskell 编写的 Raku 编译器。它由一个单独的开发者在 2005 年开始，很快就吸引了更多的人加入到团队中来。Pugs 是当时最成熟的编译器。这个项目的编译难度很大，非常耗时，执行速度很低，但编译质量和 Raku 规范的覆盖面都很突出。</p>
</div>
<div class="paragraph">
<p>到今天为止，Pugs 在 Raku 中的主要作用是庞大的测试套件。它最初是为了测试 Pugs 本身而创建的，但后来变成了 Raku 的官方测试套件。一个自称是 Raku 编译器的编译器必须通过测试套件的测试。</p>
</div>
<div class="paragraph">
<p>Pugs 已经不再开发了，但它的源代码可以在 GitHub 上找到： <a href="github.com/perl6/Pugs.hs" class="bare">github.com/perl6/Pugs.hs</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_perlito">1.10.3. Perlito</h4>
<div class="paragraph">
<p>Perlito 是另一个非常有趣的例子，它是一个构建 Raku 编译器的项目。它的目标是将 Perl 5 或 Raku 交叉编译到这些语言中的一种 - JavaScript、Java、Go、Python、Ruby 或 Lisp。你可以在  <a href="fglock/Perlito" class="bare">fglock/Perlito</a> 中找到这个项目的版本库。</p>
</div>
<div class="paragraph">
<p>Perlito 提供了一个 Web 接口，可以在浏览器中编译 Raku 的子集。它将 Raku 中的代码编译成 JavaScript，并立即执行。这个页面可以在 <a href="fglock.github.io/Perlito/perlito/perlito6.html" class="bare">fglock.github.io/Perlito/perlito/perlito6.html</a> 中找到。这个项目只涵盖了 Raku 的部分规范，但它仍然可以用来创建各种在线教育系统，包括 Perl 5 和 Raku 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_rakudo">1.10.4. Rakudo</h4>
<div class="paragraph">
<p>Rakudo 是一个最初建立在 Parrot 虚拟机上的编译器。后来，它开始使用 Java 虚拟机(JVM)，但最后 Parrot 的开发者创建了自己的虚拟机 MoarVM(Metamodel on a Runtime Virtual Machine(<a href="www.moarvm.org" class="bare">www.moarvm.org</a>))。目前，JVM 的支持有限，主要的虚拟机是 MoarVM。</p>
</div>
<div class="paragraph">
<p>Rakudo 本身就是一个 Raku 编译器。对我们来说，最有用的编译器是 Rakudo Star，它是一个包括编译器以及一些 Raku 模块和一些命令行工具（如模块安装程序）的发行版。本书中，我们将使用 Rakudo Star 编译器来运行 Raku 中的程序。</p>
</div>
<div class="paragraph">
<p>Rakudo 的网站是 <a href="rakudo.org" class="bare">rakudo.org</a>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用_rakudo_star">1.11. 使用 Rakudo Star</h3>
<div class="paragraph">
<p>Rakudo 是目前最完整的编译器。它支持 Raku 语言中最大的子集，如果说 Rakudo 是学习 Raku 的唯一编译器，那是不会错的。</p>
</div>
<div class="sect3">
<h4 id="_下载和安装_rakudo_star">1.11.1. 下载和安装 Rakudo Star</h4>
<div class="paragraph">
<p>在电脑上安装乐酷星有几种方法。您可以下载源码并编译它，或者下载一个安装程序为您的平台。Rakudo Star 适用于所有主要平台，即 Windows（32位和64位版本）、Mac OS X 和Linux。</p>
</div>
<div class="paragraph">
<p>Rakudo Star 的主要下载页面是 。在该页面上，您将找到不同平台的 Rakudo Star 发行版的最新版本的链接，以及关于如何安装的说明。</p>
</div>
<div class="paragraph">
<p>在 Windows 上，这个过程非常简单。只需下载最新版本的 MSI 安装程序，运行它，并按照说明进行操作。</p>
</div>
<div class="paragraph">
<p>在 Mac OS X 上，你可以下载一个 .dmg 安装程序，或者使用 brew 管理器，如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ brew install rakudo-star</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Linux 上，你必须从源文件中安装 Rakudo Star。</p>
</div>
<div class="paragraph">
<p>安装完 Rakudo Star 后，你会在其 bin 目录下找到 perl6 可执行文件。确保将该目录的路径添加到你的系统范围内的 PATH 变量中，这样你就可以从任何位置输入 perl6。</p>
</div>
<div class="paragraph">
<p>在本书的其余部分中，我们将假设 Rakudo Star 已经安装了，我们将使用 perl6 可执行文件来运行程序。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_命令行选项">1.12. 命令行选项</h3>
<div class="paragraph">
<p>Rakudo Star 的 Raku 编译器接受了一些命令行选项。让我们来看一下其中的一些选项。</p>
</div>
<div class="sect3">
<h4 id="_c_命令">1.12.1. -c 命令</h4>
<div class="paragraph">
<p>-c 命令行检查程序的语法并退出。它还可以运行程序中的 BEGIN 和 CHECK 块，这在本书后面的第2章 "编写代码"一节 "Phasers" 中讨论过。如果你只想检查代码中是否有语法错误而不想执行，这个命令行选项是很有用的，BEGIN 和 CHECK 代码块中的代码是个例外。</p>
</div>
<div class="paragraph">
<p>在正确编程的情况下，它会打印出以下输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Syntax OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果有编译时错误，编译将在第一个错误处停止，并在控制台中显示，并提到发现错误的行号。</p>
</div>
<div class="paragraph">
<p>错误信息包含了错误的描述，并通过弹出字符()表示代码中的确切位置。如果你的控制台支持颜色，那么在弹出字符之前的代码片段是绿色的，其余部分是红色的。</p>
</div>
<div class="paragraph">
<p>下面是一个程序漏掉了字符串的结尾引号的例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "Hello;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它来检查语法，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ perl6 -c err.pl</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序没有编译，编译器打印出来的结果是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">===SORRY!=== Error while compiling /Users/ash/code/err.pl
Unable to parse expression in double quotes; couldn't find final '"' at /Users/ash/code/err.pl:2
------&gt; &lt;BOL&gt; &lt;EOL&gt;
       expecting any of:
           argument list
           double quotes
           term</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_doc命令">1.12.2. --doc命令</h4>
<div class="paragraph">
<p>--doc（注意是双连字符）命令行提取程序中的文档并打印出来。这里指的是所谓的 Pod 文档。我们将在第二章"编写代码"中介绍 Pod 的语法。</p>
</div>
<div class="paragraph">
<p>让我们来看看这个包含了文档的小程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=begin pod
=head1 Hello, World program
=item This program prints "Hello, World!"
=end pod

say "Hello, World!";</code></pre>
</div>
</div>
<div class="paragraph">
<p>用 --doc 命令行选项运行它，如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ perl6 --doc pod.pl</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将只打印文档的部分内容。代码本身不会被执行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Hello, World program
      * This program prints "Hello, World!"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_e_命令">1.12.3. -e 命令</h4>
<div class="paragraph">
<p>-e 选项允许你在命令行中传递整个程序。这对于只做几个动作的短程序很有用，或者是在检查 Raku 中的工作原理时进行小测试。</p>
</div>
<div class="paragraph">
<p>用引号中包含的程序运行它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ perl6 -e'say "Hello"'</code></pre>
</div>
</div>
<div class="paragraph">
<p>而这就是你会看到的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Hello</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_h_和_help_命令">1.12.4. -h 和 --help 命令</h4>
<div class="paragraph">
<p>-h 和 --help 命令会打印出包含可用命令行选项列表的文本。</p>
</div>
</div>
<div class="sect3">
<h4 id="_n_命令">1.12.5. -n 命令</h4>
<div class="paragraph">
<p>命令行选项 -n 会创建一个循环，这样程序就会对每一行提交到程序输入的文本执行一次。</p>
</div>
<div class="paragraph">
<p>例如，它可以是一个单行的实用程序，从 STDIN 输入中打印出字符串的第一个字母。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">perl6 -n -e'print $_.substr(0, 1)' &lt; file.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将打印出由 file.txt 中行的第一个字符组成的行。</p>
</div>
</div>
<div class="sect3">
<h4 id="_p_命令">1.12.6. -p 命令</h4>
<div class="paragraph">
<p>-p 命令行选项的作用与前面描述的 -n 选项类似，但它也会在每行的末尾打印出默认变量 $_ 的值。我们将在下面的章节中看到默认变量的含义。</p>
</div>
</div>
<div class="sect3">
<h4 id="_i_和_m_命令">1.12.7. -I 和 -M 命令</h4>
<div class="paragraph">
<p>-I 和 -M 选项用于将模块加载到程序中。模块的名称被传递到 -M 选项中，如果需要的话，模块的路径应该在 -I 选项中传递。</p>
</div>
</div>
<div class="sect3">
<h4 id="_v_和_version_命令">1.12.8. -v 和 --version 命令</h4>
<div class="paragraph">
<p>-v 和 --version 选项可以打印出当前 Raku 编译器的版本，如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ perl6 -v</code></pre>
</div>
</div>
<div class="paragraph">
<p>在写这篇文章的时候，我使用的是 Rakudo Star 2017.01 版，输出是这个样子的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">This is Rakudo version 2017.01 built on MoarVM version 2017.01 implementing  Raku .c.</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里除了版本本身之外，重要的是用来执行 Raku 的虚拟机(MoarVM，如前文所示)和 Raku 语言规范的版本（本例中是6.c）。</p>
</div>
<div class="paragraph">
<p>Rakudo Star 的版本方案使用的是发行版的年月日。Rakudo 正在快速发展，所以定期检查 <a href="rakudo.org" class="bare">rakudo.org</a> 网站以获得更新。</p>
</div>
</div>
<div class="sect3">
<h4 id="_stagestats_命令">1.12.9. --stagestats 命令</h4>
<div class="paragraph">
<p>--stagestats 是一个命令行选项，它比我们前面描述的其他命令行选项更具有 Rakudo 的特性。它打印了编译器在编译和执行程序的不同阶段所花费的时间。</p>
</div>
<div class="paragraph">
<p>输出结果的不同，取决于你是在运行程序还是用 -c 命令行选项检查它的语法。让我们先来看看当使用 -c 选项时打印出了什么。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ perl6 --stagestats -c hello.pl</code></pre>
</div>
</div>
<div class="paragraph">
<p>产出情况如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Stage start : 0.000
Stage parse : 0.107
Stage syntaxcheck: Syntax OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有 -c 选项，你会看到更多的统计数据，因为程序不仅会被编译，还会被执行，如图所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ perl6 --stagestats hello.pl</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序的常规输出被打印出来:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Stage start       : 0.000
Stage parse       : 0.327
Stage syntaxcheck : 0.000
Stage ast         : 0.000
Stage optimize    : 0.003
Stage mast        : 0.008
Stage mbc         : 0.000
Stage moar        : 0.000
Hello, World!</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_编写我们的_hello_world_程序">1.12.10. 编写我们的 "Hello World" 程序</h4>
<div class="paragraph">
<p>至此，由于我们已经安装了 Rakudo Star 编译器，现在是时候在 Raku 中创建第一个程序了。它将打印出 Hello, World！并退出。</p>
</div>
<div class="paragraph">
<p>这个程序其实很简单。你所需要的只是一行，唯一的指令就是调用内置的 <code>say</code> 函数。它获取字符串，将其打印到控制台，并在后面添加一行新的指令。</p>
</div>
<div class="paragraph">
<p>这就是整个程序的样子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Hello, World!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>将代码保存到文件中，比如说 hello.pl，然后将其传递给编译器，如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ perl6 hello.pl</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将编译程序并立即执行。结果就是在屏幕上显示出想要的字符串。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Hello, World!</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，输出结束时有新的一行。这就是内置的 <code>say</code> 函数的行为。另外，我们还可以使用另一种方法来打印输出，使用内置的 <code>print</code> 函数。与 <code>say</code> 不同的是，它不会在输出的结尾添加新的行，所以你必须通过添加特殊符号 <code>\n</code> 来完成。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">print "Hello, World!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，这次使用了一对双引号。与单引号相比，双引号对特殊字符（如 <code>\n</code>）的处理方式不同。在双引号内，<code>\n</code> 会转换为一个新的行字符。这在单引号中是不会发生的，在这种情况下，<code>\n</code> 将作为两个字符的序列出现在屏幕上，\ 和 n。</p>
</div>
<div class="paragraph">
<p>因为程序只包含一行代码，所以没有必要用分号结束。不过，你可以一直这样做。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "Hello, World!";</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序所产生的输出与之前完全一样。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结">1.13. 总结</h3>
<div class="paragraph">
<p>在这一章中，我们简单地了解了 Raku 是一种什么样的编程语言，以及它与它的姐妹语言 Perl 5 的区别。我们了解了 Raku 的历史，以及 Raku 编译器的不同项目。最后，我们安装了当今最好的编译工具 Rakudo Star，并创建了第一个 "Hello, World!" 程序。</p>
</div>
<div class="paragraph">
<p>在下面的章节中，我们将研究如何组织程序中的代码。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_编写代码">2. 编写代码</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章将为你编写 Raku 代码做好准备。在我们研究变量、数据类型、面向对象和其他重要主题之前, 让我们先来了解一下 Raku 中的源代码是如何组织的。这里有很多与其他编程语言不同的元素, 值得我们花时间去熟悉它。</p>
</div>
<div class="paragraph">
<p>在本章中, 我们将涵盖以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用 Unicode</p>
</li>
<li>
<p>空白和反空白</p>
</li>
<li>
<p>注释</p>
</li>
<li>
<p>创建 Pod 文档</p>
</li>
<li>
<p>Phaser</p>
</li>
<li>
<p>简单的输入和输出</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_使用_unicode">2.1. 使用 Unicode</h3>
<div class="paragraph">
<p>默认的假设是 Raku 程序的源代码使用 UTF-8。它给你了整个字符的力量, 而不用担心它是否会起作用。例如, 在 Perl 5 中, 你必须添加一些特殊的指令来通知解释器你在源代码中使用了非 ASCII 字符。在 Raku 中, 这就简单多了。</p>
</div>
<div class="paragraph">
<p>首先, 在字符串中可以自由地使用 Unicode 字符。例如, 让我们尝试一下希腊语和中文的一些词组, 如下面的代码行所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'C = 2πr';     # Circumference of a circle
say '日 + 月 = 明'; # 'Sun' and 'Moon' give 'bright'</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的两行代码会按照预期打印出相应的字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">C = 2πr
日 + 月 = 明</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外, 也可以用它们的名字来引用 Unicode 代码点。例如, 考虑下面这行代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "Raku is \c[FLEXED BICEPS]";</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面这行代码用肌肉表情符号打印出以下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Raku is 💪</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中使用 Unicode 并不限于字符串、内容。变量和函数的名称中也可以使用 ASCII 以外的字符。让我们回到第一章《什么是 Raku》中的 <code>add($x, $y)</code> 函数的例子, 用希腊字母重命名它和它的参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub Σ($α, $β) {
    return $α + $β;
}

say Σ(8, 9); # 17</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外, 一些 Unicode 字符可以用来表达简单的操作, 而不是更多的常规代码。例如, 这里是有理分数的字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ½;     # prints 0.5
say ½ + ¼; # 0.75</code></pre>
</div>
</div>
<div class="paragraph">
<p>非 ASCII Unicode 数字也是允许的, 但是在没有特殊需求的情况下, 在普通代码中使用这些数字也许不是一个好主意:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ୪૨; # prints 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以用诸如 ² 或 ³ 这样的上标而不是调用函数来计算数字的幂, 如下面的几行代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 7²; # 49
say 2⁷; # 128</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个使用 Unicode 字符的例子是集合上的数学运算符, 例如 ∈ 或 ∪。</p>
</div>
<div class="paragraph">
<p>在下一个例子中, 我们使用了 Unicode 版本的简单算术运算符, 而不是传统上使用的常规 <code>*</code> 和 <code>/</code> 字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 × 4;  # 40
say 100 ÷ 4; # 25</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 程序中, 你可能经常会看到一些其他 Unicode 字符。我们来看一下其中最常见的几个。</p>
</div>
<div class="paragraph">
<p>法语引号 <code>« »</code> 可以用来代替一对引号来创建列表。例如, 在下面的代码中, <code>@array</code> 可以得到斐波纳契数的序列。我们已经在第一章《Raku 是什么》中看到过这个例子。让我们先把它更新为使用引用语法来创建数组, 如下面的几行代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @fibonacci = &lt;0 1 1 2 3 5 8 13&gt;;
say @fibonacci[4]; # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将在第三章《处理变量和内置数据类型》中详细介绍这种语法, 不过, 现在让我们来看看如何使用法语引号来包围值列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @fibonacci = «0 1 1 2 3 5 8 13»;
say @fibonacci[4]; # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于单行程序(主要在 <code>-e</code> 命令行选项中执行的短程序), Unicode 引号可能会很有帮助, 因为它们有助于避免嵌套单引号的问题。你可以在下面的例子中看到它是如何工作的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku –e'say ‘Hello, World!’'</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里用一对 Unicode 引号(‘ 和 ’)来代替单引号(')。</p>
</div>
<div class="paragraph">
<p>在使用正则表达式和 grammar 时(我们将在第十一章《正则表达式》和第十二章《Grammar》中讨论它们), 你经常会看到一对方角括号, 你可以在代码中自由地使用它来引用字符串, 如下面的代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ⌈Hello, World!⌋;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中, 可以用 Unicode 字符来表示语言的元素, 它和用 ASCII 形式编写的等价。这些 ASCII 字符有时被称为德克萨斯字符。下表列出了 Unicode 和 ASCII 版本中最常见的结构的对应关系:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unicode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ASCII 等价物</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在 Raku 中的意思</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">« »</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;&lt; &gt;&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这些引用一组数组元素, 也用于超运算符中(参见第四章,《使用运算符》)。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">‘’ “„”</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">' ' " " "</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这些单引号和双引号用于引用字符串。诸如 n 这样的特殊字符在双引号中被插值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⌈ ⌋</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Q/ /</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这个语法用于创建不带插值的字符串。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">× ÷</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">* /</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这些是乘法和除法的算术运算符。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">−</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">例如, 减号, 用作运算符(注意, Unicode 中有一个单独的 <code>MINUS SIGN</code> 字符, 其代码为 0x2212)。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>有几个预定义的数学计算常数 - <code>π</code>, <code>e`和 `τ</code>。还有一个单独的符号来表示无穷大 <code>∞</code>。所有这些符号在 ASCII 表示法中也有对应的符号:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">符号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ASCII 等价物</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注释</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">π</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">pi</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这是 π 的值(3.14159&#8230;&#8203;)。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">𝑒</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">e</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这是 𝑒 的值(2.71828)。注意它的 Unicode 表示是 0x1D452 字符, 而不是 ASCII 字符 e。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">τ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tau</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">τ 的值为 2π(6.283185&#8230;&#8203;)。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∞</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inf</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无穷大总是比任何数都大</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>键入 Unicode 字符可能是一项单独的任务。当然, 你可以随时从谷歌或维基百科上复制字符, 但在这种情况下, 你会失去效率。请参考 Raku 在线文档 <a href="docs.raku.org/language/unicode_entry" class="bare">docs.raku.org/language/unicode_entry</a> 中输入 Unicode 字符的页面。它包含了如何在不同的编辑器和 IDE 中输入 Unicode 字符的详细说明。</p>
</div>
</div>
<div class="sect2">
<h3 id="_空白和反空白">2.2. 空白和反空白</h3>
<div class="paragraph">
<p>正如我们刚才看到的那样, Raku 程序可以在传统的 ASCII 集之外集中使用 Unicode 字符。这也适用于空白。空白是指程序元素之间的空隙, 传统上用空格(ASCII 代码 0x20)、制表符(0x09)和换行符(在 Unix 中是一个单一的换行符 0x0A, 在 Windows 中是一系列的两个字符, 回车符 0x0D 和换行符 0x0A)来表示。Raku 扩展了空白的概念, 在代码的每一个允许使用普通空白的地方都接受 Unicode 空白。当你使用现有的代码时要小心, 因为某些原因, 这些代码中充满了 Unicode 字符。</p>
</div>
<div class="paragraph">
<p>Raku 中的空白字符集包含具有如下 Unicode 属性之一的字符:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Zs: 分隔符, 空白</p>
</li>
<li>
<p>Zl: 分隔符, 行</p>
</li>
<li>
<p>Zp: 分隔符, 段落</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你可以在 <a href="https:/​/​en.wikipedia.​org/​wiki/​Whitespace_​character" class="bare">https:/​/​en.wikipedia.​org/​wiki/​Whitespace_​character</a> 页面列出的类别中找到完整的字符列表。其中有普通空白、垂直和水平制表符、换行符, 不可分空格和窄空格。</p>
</div>
<div class="paragraph">
<p>在更大的范围内, Raku 允许程序按照程序员的要求进行格式化。另一方面, 关于空白可能出现的地方, 有一些规则, 在编写 Raku 程序时应该遵循这些规则。</p>
</div>
<div class="paragraph">
<p>如果语言不允许在代码中的某个特定位置有空格, 但是你希望将程序格式化, 使其更宽敞, 你可以添加所谓的 <strong>unspace</strong>。这是一个以反斜杠开始的序列, 紧接在前一段代码之后, 后面是一个或多个空格字符。它类似于 Unix 命令行指令末尾的反斜杠, 用于继续下一行。</p>
</div>
<div class="paragraph">
<p>让我们来看看最重要的情况, 语言中关于空白的规则很严格, 可能与你的习惯相冲突。</p>
</div>
<div class="paragraph">
<p>第一个例子是函数调用。在 Raku 中, 函数的参数周围不需要圆括号, 但只要你使用括号, 函数名和左开口圆括号之间就不能有空格。检查下面的三个调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say add 4, 5;   # OK, no parentheses
say add(4, 5);  # OK, no space
say add (6, 7); # Error</code></pre>
</div>
</div>
<div class="paragraph">
<p>前两行是正确的, 而最后一行产生了编译时错误, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Too few positionals passed; expected 2 arguments but got 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个错误消息听起来可能会有误导性, 但请记住, 在 Raku 中, 你可以向函数传递数组。在这种情况下, 编译器不能保证正确理解程序员的意图。<code>add (6, 7)</code> 结构可以解释为调用一个带单一参数的函数, 这个参数是一个双元素数组——<code>(6,7)</code>。</p>
</div>
<div class="paragraph">
<p>如果你仍然喜欢将参数列表和函数名称直观地分开, 可以在它们之间放置一个 unspace, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say add\ (6, 7);</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在它正在编译, 没有任何抱怨。在 unspace 内部使用换行符也是允许的; 考虑以下例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say add\
(6, 7);</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以采用不同的格式化方式, 将开口圆括号与函数名留在同一行, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say add(
    6, 7
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你需要传递许多参数时, 这种方法可能会很方便, 例如, 给每个参数添加注释:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say add(
    6, # first argument
    7  # second argument
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将在第六章的《子例程》中更多地讨论函数。不过, 现在, 让我们回到组织源代码的方法上。</p>
</div>
</div>
<div class="sect2">
<h3 id="_注释">2.3. 注释</h3>
<div class="paragraph">
<p>在第一章《Raku 是什么》中, 我们已经看到了两种编写程序的方法 - 一是在 <code>-e</code> 命令行选项中传递, 二是将代码保存在文件中。当然, 所有大型程序都是保存在文件中。在本节中, 我们将看到 Raku 如何通过添加注释来帮助程序员更好地组织代码。</p>
</div>
<div class="paragraph">
<p>注释是源代码的一部分, 编译器会忽略这些内容。注释的目的是为了提供有关该程序本身的额外信息。好的注释的例子是对所用算法的解释, 或变量的目的, 或函数的输入参数的描述。</p>
</div>
<div class="paragraph">
<p>Raku 提供了两种方法, 通过使用注释和所谓的 Pod 来保存源代码中面向人类的额外信息。首先, 我们来研究一下注释。</p>
</div>
<div class="paragraph">
<p>注释是源代码中的片段, 编译器不会将其视为直接执行的指令。在 Raku 中, 有三种方式可以留下注释:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>单行注释,</p>
</li>
<li>
<p>多行注释,</p>
</li>
<li>
<p>嵌入式注释。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们来详细研究一下它们。</p>
</div>
<div class="sect3">
<h4 id="_单行注释">2.3.1. 单行注释</h4>
<div class="paragraph">
<p>使用 <code><mark></code> 字符将单行注释与程序源代码分开。编译器会跳过 <code></mark></code> 符号后面的所有内容, 直到当前行结束。</p>
</div>
<div class="paragraph">
<p>在下面的例子中, 我们把第一章的《Raku 是什么》中的 'Hello, World!' 程序作为例子, 并在其中添加了一个单行注释:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Hello, World!'; # prints 'Hello, World!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个完全正确的 Raku 程序。它有一个内置的 <code>say</code> 函数的调用和一个关于它的注释。字符串中从 <code>#</code> 字符开始的部分是一个单行注释。</p>
</div>
<div class="paragraph">
<p>如果你运行这个程序, 它会打印出 <code>Hello, World!</code>。仅此而已。它和没有注释的程序的作用完全一样。</p>
</div>
<div class="paragraph">
<p>单行注释也可以占用单独的一行代码。例如, 让我们在同一程序中添加更多的注释:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> # This is a program in Raku.
# It prints the 'Hello, World!' string.
# To run it, install Rakudo Star and
# run it from the command-line:
# raku ./hello.pl

say 'Hello, World!'; # it prints the string

# The program ends here.</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也是一个完全有效的 Raku 程序。从业务逻辑的角度来看, 与前面的例子一样, 程序没有变化, 但是从以后维护的角度来看, 它变得更好了, 因为它解释了它的作用。</p>
</div>
<div class="paragraph">
<p>使用单行注释的另一种常见做法是暂时隐藏代码段。例如, 在调试过程中, 你想禁用某些操作。你可以通过在这行代码的开头加上 <code>#</code> 字符来代替删除这行代码。以下面几行代码为例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Hello, World!';
# print "Hello, World!\n";</code></pre>
</div>
</div>
<div class="paragraph">
<p>有时, 你会做相反的事情, 即在程序中添加额外的打印指令, 以查看不同变量的值, 并在代码生产就绪之前注释掉这些指令。</p>
</div>
<div class="paragraph">
<p>下面是一个例子, 说明你如何打印传递给函数的值。我使用了第一章《什么是 Raku》中的加法例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y) {
    say "x = $x, y = $y";
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序只是简单地打印了加法的结果, 但如果你取消了子例程代码的第一行注释, 它也会以人类可读的格式打印出 <code>$x</code> 和 <code>$y</code> 变量的值。如下面的代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">x = 4, y = 5
9</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_多行注释">2.3.2. 多行注释</h4>
<div class="paragraph">
<p>虽然单行注释可以用来提供大块的文档, 但必须在每行中放置 <code>#</code> 字符会使注释本身难以维护。例如, 如果你修改了注释的文本, 你可能也想把整个段落重新整理, 使所有行的都差不多长, 使整个注释在视觉上更有吸引力。</p>
</div>
<div class="paragraph">
<p>在 Raku 中, 支持多行注释。多行注释的语法如下。它从 <mark>` 序列开始(与单行注释中的 <code></mark></code> 字符相同, 后面是一个反引号符号)。然后注释的主体部分进入。它必须用一对括号括起来。</p>
</div>
<div class="paragraph">
<p>例如, 可以这样使用花括号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#`{This program in Raku
prints the 'Hello, World!' string}

say 'Hello, World!';</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里, 注释位于源代码的两行中, 但没有必要用 <code>#</code> 字符标记每一行。</p>
</div>
<div class="paragraph">
<p>还可以使用其它的环绕字符对。例如, 圆括号或方括号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> #`(A multi-line comment
placed between pair of parentheses)

#`[Another multi-line comment,
this time in square brackets]</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然注释的目的首先是为了让人类阅读, 但编译器必须理解注释的起始和结束的位置。在前面的例子中, 注释正文的结束字符是由 #` 序列后的相应字符定义的。</p>
</div>
<div class="paragraph">
<p>如果它是一个开口花括号(<code>{</code>), 那么编译器就会扫描下面的文本, 并寻找对应的闭合字符, 也就是本例中的 <code>}</code> 字符。这也意味着你不能在注释的文本中使用闭合花括号, 因为它将被视为注释的结尾。</p>
</div>
<div class="paragraph">
<p>在注释中使用这样的字符的方法之一是使用不同的括号对。例如, 如果整个注释被嵌入在一对圆括号中, 那么在该注释的正文中使用闭合花括号是安全的, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#`(A multi-line comment
in parentheses and it contains the } character inside
it)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外, 如果使用相同字符的平衡字符对也不会有问题。例如, 考虑一下下面这段代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#`(Function add(x, y) adds two numbers
and returns their sum)
sub add($x, $y) {
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里, 注释使用的是 #`(...) 括号对, 但它里面又包含了另一对括号: <code>add(x, y)</code>。在这种情况下, 程序是正确的, 它会根据程序员的意图结束注释。</p>
</div>
<div class="paragraph">
<p>第二种允许在注释中使用相同字符的方法是使用一个以上的字符序列来标记注释。</p>
</div>
<div class="paragraph">
<p>例如, 一对双括号就可以这样操作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#`{{Two characters at the beginning
let us easily include the closing } brace, for
example}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个好的方法是使用不同字符的组合。闭合字符序列应该与开口字符序列相仿, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#`([Another way of having
a closing ] character inside the comment])</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后, 单行注释可能出现在多行注释里面。在这种情况下, 他们将只是其中的一部分, 如下面的例子所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#`{If you want to print the value of the variable $x,
find the following line in the code:
# say $x
and uncomment it.}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_嵌入式注释">2.3.3. 嵌入式注释</h4>
<div class="paragraph">
<p>Raku 中的嵌入式注释是使用多行注释的语法, 但放在主代码内部的注释。与单行注释不同的是, 嵌入式注释不会传播直到行尾, 并且可以由闭合字符结束。</p>
</div>
<div class="paragraph">
<p>让我们以 <code>add</code> 函数中的嵌入式注释为例进行演示, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y) {
    return $x + #`(this is numeric addition) $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>#`(this is numeric addition) 注释告诉读者, <code>+</code> 运算符希望它的操作数(例子中的变量 <code>$x</code> 和 <code>$y</code> )是数字值(例如, 与字符串的连接不同)。整个注释被嵌入到 <code>$x + $y</code> 表达式中。注释结束后, 普通代码流继续进行。编译器会忽略注释, 因此, 该行在语法上仍然是正确的。</p>
</div>
<div class="paragraph">
<p>嵌入式注释应该尽可能简短, 以使整个代码更容易阅读。在调试程序的过程中, 用它来给出一些小的解释, 或者在调试程序的过程中暂时停用某个代码片段。</p>
</div>
</div>
<div class="sect3">
<h4 id="_创建_pod_文档">2.3.4. 创建 Pod 文档</h4>
<div class="paragraph">
<p><strong>Pod</strong> 是 Raku 中的子语言, 用于编写文档。它可以被认为是注释的扩展版本, 它允许表达内容的功能更多。Raku 中的 Pod 是由 Perl 5 中 POD(Plain Old Documentation)演变而来。在 Raku 中, Pod 这个名字不是缩写, 因此不需要大写。在本节中, 我们将研究 Pod 标记语言的语法。</p>
</div>
<div class="paragraph">
<p>Pod 内容与 Raku 程序本身放在同一个源文件中。一个 Pod 小节是一系列包含一些文本信息的行。编译器在看到 Pod 部分的开始和结束标记时, 会在解析 Pod 和 Raku 之间进行切换。Pod 语法是为了表达文档的语义而设计的, 也是为了帮助将文档组织得更有条理一些。</p>
</div>
<div class="paragraph">
<p>我们来看看如何创建一个 Pod 块。有几种类型的 Pod 块, 也有几种创造 Pod 块的方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_begin_end_pod_块">2.3.5. =begin / =end Pod 块</h4>
<div class="paragraph">
<p>Pod 块以 <code>=</code> 符号开始, 该符号应该是该行中的第一个非空格字符(因此, 你不能像在同一行中的单行注释-下一个代码一样开始一个 Pod 块)。</p>
</div>
<div class="paragraph">
<p>这个块用 <code>=begin</code> 和 <code>=end</code> 指令来标记, 每个指令必须有一个 Raku 标识符来描述 Pod 块中的数据类型。有几个预定义的标识符, 它们可以完全小写, 也可以完全大写。请看几个最有用的 Pod 块的例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod6" data-lang="pod6">=begin pod
This program is the first program in Raku.
=end pod

say 'Hello, World!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里, Pod 块以 <code>=begin pod</code> 开头, 并以 <code>=end pod</code> 结束。块之外的所有内容都是一个普通的 Raku 程序。</p>
</div>
<div class="paragraph">
<p>如果只是运行程序, 那么 Pod 块就会被忽略。将程序保存到一个文件中, 然后用命令运行, 方法如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku pod.pl
Hello, World!</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第一章《什么是 Raku》中我们考察了 Rakudo Star 编译器支持的不同命令行选项。现在是时候使用其中的一个 <code>--doc</code> 来看看编译器是如何从程序中提取出 Pod 文档, 并在不执行程序本身的情况下打印出来的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku --doc pod.pl
This program is the first program in Raku.</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的例子中, 块的类型是 <code>pod</code>。还有其他类型的 Pod 块。</p>
</div>
<div class="paragraph">
<p><code>table</code> 类型创建一个带有表的 Pod:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod6" data-lang="pod6">=begin table
    Language    Year of appearance
    C           1973
    C++         1983
    Perl        1987
    Raku      2000
=end table</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以自己在源代码中对表做一些最低限度的格式化, 但是 Pod 解析器和格式化程序(我们的例子中是 Rakudo 的一部分)会做一些额外的工作来很好地显示表。如果你用 <code>--pod</code> 命令行选项运行程序, 表格就会是这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku --doc pod.pl
Language  Year of appearence
C         1973
C++       1983
Perl      1987
Raku    2000</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, 缩进丢失了, 并且表的行从行的开头打印。另一个变化是列之间有两个空格, 而我们在源代码中有更多空格。</p>
</div>
<div class="paragraph">
<p>该表可以选择包含一个标题, 你可以使用所谓的副词语法将其放在 <code>=begin</code> 行中, 如下面的例子所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod6" data-lang="pod6">=begin table :caption&lt;History of Programming Languages&gt;
Language    Year of appearance
C           1973
C++         1983
Perl        1987
Raku      2000
=end table</code></pre>
</div>
</div>
<div class="paragraph">
<p>标题将被打印在表格的上方:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku --doc pod.pl
History of Programming Languages
Language  Year of appearance
C         1973
C++       1983
Perl      1987
Raku    2000</code></pre>
</div>
</div>
<div class="paragraph">
<p>在我们进一步研究 Raku 中其他类型的 Pod 块之前, 让我们先来学习一下其他类型的 Pod 块的声明语法:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>缩写块</p>
</li>
<li>
<p>段落块</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在缩写块中, 开头 <code>=</code> 符号后面紧跟着 Pod 块类型的名字。不再需要闭合的 <code>=end</code> 指令, Pod 块的结尾将以空行或另一个 Pod 块的开始来表示。</p>
</div>
<div class="paragraph">
<p>下面是另一个使用缩写语法的表块的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod6" data-lang="pod6">=table
    Language    Year of appearance
    C           1973
    C++         1983
    Perl        1987
    Raku      2000

say 'Ok';</code></pre>
</div>
</div>
<div class="paragraph">
<p>带有表格的 Pod 块在空行之前结束。在这之后, 编译器又切换回解析 Raku 代码。</p>
</div>
<div class="paragraph">
<p>在段落块中, 使用 <code>=for</code> 指令开始 Pod 部分, 后面是标识符。因此, 最后一个例子可能以 <code>=table</code> 或 <code>=table</code> 开始。</p>
</div>
<div class="paragraph">
<p>这种语法对于内容通常较短的其他类型的 Pod 块来说比较自然。例如, 标题或列表项。在这种情况下, 块的内容会在同一行中提供, 紧接在开口指令之后, 就像下面的例子所示, 它反映了当前章节的部分内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod6" data-lang="pod6">=head1 Writing Code
=head2 Comments in Raku
=item One-line comments
=item Multi-line comments
=item Embedded comments</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>--doc</code> 命令行选项提取文档, 会产生以下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Writing Code
  Comments in Raku
  * One-line comments
  * Multi-line comments
  * Embedded comments</code></pre>
</div>
</div>
<div class="paragraph">
<p>它包含了两层标题和一个简单的项目列表。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_phaser">2.4. phaser</h3>
<div class="paragraph">
<p>在 Raku 中创建程序时, 要明白控制程序的流程比简单地按照代码指令来执行要麻烦一些。有一些特殊类型的代码块会在编译器在编译和执行过程的不同阶段自动调用。这些代码块称为 <strong>phaser</strong>。</p>
</div>
<div class="paragraph">
<p>我们在第一章《Raku 是什么》中谈论编译器的 <code>-c</code> 命令行选项时提到了其中两个, <code>BEGIN</code> 和 <code>CHECK</code>。现在, 我们来看看剩下的部分。</p>
</div>
<div class="paragraph">
<p>从语法上讲, phaser 是用花括号括起来的代码块, 其前面是 phaser 的名称。下表总结了 Raku 中存在的不同的 phaser。有些 phaser 是在编译时执行, 然后再编译和执行程序的其余部分。有些是在运行时调用的。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Phaser 名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行阶段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">动作</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BEGIN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">编译时</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该块是在主程序编译之前调用的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHECK</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">编译时</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该块是在编译完成后, 编译阶段即将停止时调用的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INIT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">运行时</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该块是在程序编译完成并准备运行时调用的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">END</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">运行时</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该块是在程序执行完毕, 准备退出时调用的</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>让我们扩展一下 'Hello, World!' 程序并为它添加一些 phaser:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">BEGIN {
    say 'BEGIN 1';
} END {
    say 'END';
}

say 'Hello, World!';

BEGIN {
    say 'BEGIN 2';
}
CHECK {
    say 'CHECK';
}
INIT {
    say 'INIT';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码产生以下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">BEGIN 1
BEGIN 2
CHECK
INIT
Hello, World!
END</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中, 请注意 phaser 块的几个特点。这里有两个 <code>BEGIN</code> 块, 它们是按照它们在源代码中出现的顺序执行的。另外, 块的实际位置并不是很重要。例如, <code>END</code> 块位于主程序之前, 但在主程序之后执行。同样, 第二个 <code>BEGIN</code> 块和 <code>CHECK</code> 和 <code>INIT</code> 块位于主程序之后, 但在主程序之前被调用。</p>
</div>
<div class="paragraph">
<p>Phaser 是很好的候选者, 它可以在程序即将开始或结束时做一些工作。例如, 你可以用 <code>BEGIN</code> 块检查程序是否在正确的环境中运行。在 <code>END</code> 块中, 你可以在程序退出前关闭所有打开的文件或打印一些东西到日志中。</p>
</div>
<div class="paragraph">
<p>在第十章《处理异常》中, 我们将使用另外两个 phaser-<code>CATCH</code> 和 <code>CONTROL</code>。</p>
</div>
<div class="paragraph">
<p>在 Raku 中还有很多 phaser, 它们在程序执行过程中帮助组织钩子, 比如当程序流进入或离开某个代码块时, 会调用 <code>ENTER</code> 和 <code>LEAVE</code>。关于这些 phaser 的详细描述, 请参考文档页面 <a href="docs.raku.org/language/phasers" class="bare">docs.raku.org/language/phasers</a>。</p>
</div>
<div class="sect3">
<h4 id="_简单的输入和输出">2.4.1. 简单的输入和输出</h4>
<div class="paragraph">
<p>在前面的例子中, 我们使用内置的 <code>print</code> 和 <code>say</code> 函数将一些东西打印到控制台(说得更严格一点, 是指程序附带的标准输出)。在本节中, 你将学习如何从标准输入中执行基本的读取。这基本上是程序如何把你输入的东西拿到控制台上。</p>
</div>
<div class="paragraph">
<p>为了读取输入, 可以直接使用一些函数而无需加载任何模块。它们列在下面的表格中:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">函数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">它是什么</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">get</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这是从输入中读取一行并返回</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lines</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这将返回包含来自于标准输入的数据行的行的列表</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">slurp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这将返回一个包含整个输入的字符串</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>当你需要逐行解析输入数据时, 可以使用 <code>get</code> 和 <code>line</code> 函数。例如, 如果你知道输入的结构, 你可以根据需要调用 <code>get</code>, 或者创建一个循环并迭代 <code>lines</code> 返回的数组。</p>
</div>
<div class="paragraph">
<p><code>slurp</code> 函数可以一次完成工作。比如说, 你可以用它把所有东西从输入复制到输出。下面这个程序就是这样做的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">print slurp;</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有另一个有用的函数: <code>prompt</code>。使用它可以同时进行两个操作: 该函数在屏幕上打印一个文本信息, 并返回用户输入的字符串。这个函数可以阻止程序的执行, 直到用户用换行完成输入。</p>
</div>
<div class="paragraph">
<p>让我们用一个计算圆的周长的例子程序来演示一下 <code>prompt</code> 函数的工作。下面的程序向用户请求半径, 然后打印出结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'The circumference is ',
    tau * prompt 'Enter the radius &gt; ';</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序首先打印出提示消息 <code>Enter the radius &gt;</code>, 然后等待用户输入一个数字并按 Enter 键。然后, <code>say</code> 函数会打印出另一条消息, <code>The circumference is,</code>, 并把输入值乘以 τ 后得到的值加在后面, 正如我们本章的使用 Unicode 部分中看到的那样, 等于 2π。我们可以在下面的代码中看到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku circumference.pl
Enter the radius &gt; 12
The circumference is 75.398223686155</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们故意没有引入任何变量(我们将在后面的第三章《使用变量和内置数据类型》中讨论)。请注意, 实际输出是从右到左: 首先是来自 <code>prompt</code> 的消息, 然后是 <code>say</code> 打印的文本。</p>
</div>
<div class="paragraph">
<p>更复杂的输入和输出, 以及文件的处理, 我们将在第九章《输入和输出》中讨论。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_2">2.5. 总结</h3>
<div class="paragraph">
<p>在本章中, 我们研究了 Raku 程序的组织方式。源代码是用 Unicode 编写的, 在语言的语法中, 有很多 Unicode 元素可用来使程序更有表现力。我们还研究了如何创建和使用注释, 从单行注释到可能包含程序文档的更大的 Pod 块。我们还研究了如何将源代码中的部分放在不同的 phaser 来改变程序的流程。最后, 你还学会了一种获取用户输入的方法。</p>
</div>
<div class="paragraph">
<p>现在, 我们准备创建真正的 Raku 程序了。在下一章中, 我们将讨论 Raku 中的数据类型以及如何使用变量。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_变量和内置数据类型">3. 变量和内置数据类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 是一种渐进类型的语言。这意味着你不需要指明你所创建的变量的类型：你可以自由地使用同一个变量来存储不同类型的数据。但是，你也可以创建一个类型变量，在这种情况下，编译器会检查该变量的用法，并确保该变量只用于该类型允许的操作。</p>
</div>
<div class="paragraph">
<p>在这一章中，我们将先了解 Raku 的内置类型，然后再学习如何使用变量:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>内置数据类型</p>
</li>
<li>
<p>类型层次结构</p>
</li>
<li>
<p>变量</p>
</li>
<li>
<p>标量、数组和散列</p>
</li>
<li>
<p>数据类型的面向对象属性</p>
</li>
<li>
<p>简单和复合数据类型</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_使用变量">3.1. 使用变量</h3>
<div class="paragraph">
<p>在任何编程语言中，变量都被命名为内存块，可用于存储和检索值。 在 Raku 中，变量是一个容器，可以容纳一种类型的值，这些值可以是语言中内置的，也可以是用户创建的。</p>
</div>
<div class="sect3">
<h4 id="_声明变量">3.1.1. 声明变量</h4>
<div class="paragraph">
<p>每一个变量在程序中使用之前都必须先声明。你不需要在程序开始时就声明所有的变量。从实际的角度来看，声明的位置可以(也应该)尽可能地靠近它第一次使用的地方。这样做的最实际的原因是为了让变量的可见性更好&#8212;&#8203;如果你过早地声明，就会迫使程序的读者去思考这个变量的用途；另一方面，如果你在代码中做了修改，如果变量声明的位置不靠近它使用的地方，就有很大的几率会忘记去掉。</p>
</div>
<div class="paragraph">
<p>要声明一个变量，请使用 <code>my</code> 关键字，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在初始化的同时声明一个变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 42;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 还定义了常量的概念。这些变量的值只能在初始化器中设置一次。要创建一个常量，请使用 <code>constant</code> 关键字，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant $C = 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不能给常量指定一个新的值。</p>
</div>
<div class="paragraph">
<p>现在，让我们来看看 Raku 中都有哪些变量可用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_raku_中的变量容器">3.1.2. Raku 中的变量容器</h4>
<div class="paragraph">
<p>变量容器有三种基本类型: 标量、数组和散列。首先，你将学习如何在代码中使用它们的基础知识。然后，在本章后面的《使用内置数据类型》一节中，我们将深入了解该语言中可用的数据类型。</p>
</div>
<div class="paragraph">
<p>容器的结构类型由一个特殊的字符 <strong>sigil</strong> 表示。它总是在变量名之前，在很多情况下，它可以被认为是变量名的一部分。</p>
</div>
<div class="paragraph">
<p>变量名是一个标识符。标识符是由字母字符、数字、下划线字符和连字符组成的字符串。第一个字符不能是数字或连字符。字母数字字符是 Unicode 意义上的，因此，与连字符一起使用，可以创建非常有表现力的变量名。标识符是区分大小写的。</p>
</div>
<div class="paragraph">
<p>在下面的章节中，你将看到关于变量命名的例子。注意, 变量总是以 sigil 开头，而裸标识符可以是函数名或类名，我们将在本书的其他章节中看到。</p>
</div>
</div>
<div class="sect3">
<h4 id="_标量">3.1.3. 标量</h4>
<div class="paragraph">
<p>标量是一个可以保留单个值的容器，例如整数、字符串或对象。</p>
</div>
<div class="paragraph">
<p>标量变量使用 <code>$</code> sigil。我们在前面的章节中已经看到过一些例子，这里再举几个例子。注意，同一个标量变量，如果没有显式地声明数据类型，可以在不同时刻托管不同类型的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 42;
say $x;
my $y = $x * 2;
say $y;

$x = 'Hello, World!';
say $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>(当然，在程序流中最好不要改变数据的类型。)</p>
</div>
<div class="paragraph">
<p>在双引号中的字符串内部，标量变量被插值, 并以其当前值代替。在下面的程序中，将一个方程的计算过程以字符串的形式打印出来:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 3;
my $b = 4;
my $c = sqrt($a * $a + $b * $b);

say "If the legs of a right triangle are $a and $b, ";
say "then the hypotenuse is $c.";</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码打印出以下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">If the legs of a right triangle are 3 and 4, then the hypotenuse is 5.</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，让我们进入下一个类型的变量-数组。</p>
</div>
</div>
<div class="sect3">
<h4 id="_数组">3.1.4. 数组</h4>
<div class="paragraph">
<p>数组变量可以托管多个值。这些值可以是相同类型的，也可以是不同类型的。数组通常用来保存数据项的列表。</p>
</div>
<div class="paragraph">
<p>在 Raku 中, 数组的前缀是 <code>@</code> sigil。要访问数组中的元素，需要使用方括号的后缀对儿。例如，<code>@a</code> 数组的第二个元素是 <code>@a[1]</code>。 注意，索引从 0 开始。</p>
</div>
<div class="paragraph">
<p>我们来看看如何创建一个整数数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @odd_numbers = 1, 3, 5, 7, 9, 11;</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，也可以使用圆括号或角括号。下面的两个数组与前一个数组相同:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array2 = (1, 3, 5, 7, 9, 11);
my @array3 = &lt;1 3 5 7 9 11&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当使用 <code>say</code> 内置的函数打印时，Raku 将数组的内容用方括号打印出来，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @odd_numbers; # [1 3 5 7 9 11]</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面是另一个包含混合类型数据的数组的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array = 1, 'two', 3E-2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里所有的元素都是不同类型的(整数、字符串和浮点值)，但是通过索引可以很容易地访问它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @array[0]; # 1
say @array[1]; # two
say @array[2]; # 0.03</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们进一步了解一下 Raku 中数组提供的可能性。</p>
</div>
<div class="sect4">
<h5 id="_数组类型的方法">数组类型的方法</h5>
<div class="paragraph">
<p>Raku 中的数组实际上是 Array 类的一个对象。使用类是第八章《面向对象编程》中的一个主题。到目前为止，我们将讨论如何在 Raku 程序中访问数组的不同属性。</p>
</div>
<div class="paragraph">
<p>要获取数组的长度，可以调用 <code>elems</code> 方法，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 3, 5;
say @a.elems; # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>push</code>，<code>pop</code> 和 <code>append</code> 这三个方法修改数组: <code>push</code> 在数组的末尾添加一个新元素; <code>pop</code> 获取最后一个元素，将其从数组中删除，然后返回它; <code>append</code> 在末尾添加新元素，与 <code>push</code> 不同的是，<code>append</code> 可以添加多个新元素。让我们来看看下面这个程序的输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 3, 5;

@a.push(7);
say @a; # [1 3 5 7]

say @a.pop; # 7
say @a; # [1 3 5]

my @b = 9, 11;
@a.append(@b);
say @a; # [1 3 5 9 11]</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，也可以使用函数代替方法。前面的程序可以用不同的方式来编写，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 3, 5;

push @a, 7;
say @a; # [1 3 5 7]

say pop @a; # 7
say @a; # [1 3 5]
my @b = 9, 11;
append @a, @b;
say @a; # [1 3 5 9 11]</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来的一组，<code>unshift</code>、<code>shift`和 `prepend</code>，是与 <code>push</code>、<code>pop</code> 和 <code>append</code> 相辅相成的三种方法。<code>unshift</code> 方法将一个元素添加到数组的开头; <code>shift</code> 方法删除并返回第一个元素; <code>prepend</code> 方法将新元素添加到开头。下面的代码块演示了使用这些方法的效果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 3, 5;

@a.unshift(7);
say @a; # [7 1 3 5]

say @a.shift; # 7
say @a; # [1 3 5]

my @b = 9, 11;
@a.prepend(@b);
say @a; # [9 11 1 3 5]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>splice</code> 方法将数组切割成三部分，并有选择地用新的列表可替换中间的部分。<code>splice</code> 方法的前两个参数是将被删除或替换的第一个元素的索引和该片段的长度。例如，考虑一下下面的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @even = 2, 4, 6, 8, 10, 12, 14, 16, 18, 20;
@even.splice(4, 3);
say @even; # [2 4 6 8 16 18 20]</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，将从原始数组中删除三个索引为 4、5 和 6 的元素。</p>
</div>
<div class="paragraph">
<p>在下一个例子中，同样的元素被替换为值 100 和 200:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @even = 2, 4, 6, 8, 10, 12, 14, 16, 18, 20;
@even.splice(4, 3, (100, 200));
say @even; # [2 4 6 8 100 200 16 18 20]</code></pre>
</div>
</div>
<div class="paragraph">
<p>替换的长度不需要与被删除部分的长度相同。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_散列">3.1.5. 散列</h4>
<div class="paragraph">
<p>在数组中，索引是从 0 开始的整数。在 Raku 中, 散列是另一种结构类型的数据，它可以视为数组, 其索引是字符串。</p>
</div>
<div class="paragraph">
<p>散列使用 <code>%</code> sigil。不同编程语言中的散列的其他名称还有关联数组、字典或词典以及映射。当你需要把几个值放在一起时, 散列是非常有用的。例如，看看下面的代码片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %city =
    name =&gt; 'London',
    country =&gt; 'gb',
    latitude =&gt; 51.52,
    longitude =&gt; 0,
    area =&gt; 1577,
    inhabitants =&gt; 8_700_000;</code></pre>
</div>
</div>
<div class="paragraph">
<p>散列的元素是对儿，反过来又是两个东西 - 键和值。在这个例子中，<code>%city</code> 散列的键是 <code>name</code>、<code>country</code> 等，它们的值是 <code>London`和 `gb</code>。</p>
</div>
<div class="paragraph">
<p>在这种赋值中，代码的布局可以改变，使键和值对齐，就像你在这里看到的那样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %city =
    name        =&gt; 'London',
    country     =&gt; 'gb',
    latitude    =&gt; 51.52,
    longitude   =&gt; 0,
    area        =&gt; 1577,
    inhabitants =&gt; 8_700_000;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在赋值中，可以用括号将散列对包围起来，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %city = (
    name =&gt; 'London',
    country =&gt; 'gb',
    latitude =&gt; 51.52, longitude =&gt; 0,
    area =&gt; 1577,
    inhabitants =&gt; 8_700_000);</code></pre>
</div>
</div>
<div class="paragraph">
<p>当印散被打印出来(<code>say %city</code>)时，它会显示在一对花括号中，如下面的几行代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">{area =&gt; 1577, country =&gt; gb, inhabitants =&gt; 8700000, latitude =&gt; 51.52, longitude =&gt; 0, name =&gt; London}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果有相同名称的键，那么最后一个键获胜。考虑一下下面的散列创建:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %city =
    name =&gt; 'London',
    name =&gt; 'Paris';
say %city;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序只打印 <code>{name &#8658; Paris}</code>。</p>
</div>
<div class="paragraph">
<p>本节的信息已经足够我们继续学习 Raku 中的类型。</p>
</div>
<div class="sect4">
<h5 id="_散列类的方法">散列类的方法</h5>
<div class="paragraph">
<p>我们来看看散列有哪些方法。</p>
</div>
<div class="paragraph">
<p>首先，<code>keys</code> 和 <code>values</code> 这两个方法，返回包含了散列的所有键和值的列表(严格来说是序列)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %capitals =
    Spain =&gt; 'Madrid',
    Italy =&gt; 'Rome',
    France =&gt; 'Paris';

my @countries = %capitals.keys;
my @cities = %capitals.values;

say @countries; # [France Italy Spain]
say @cities;    # [Paris Rome Madrid]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>kv</code> 方法返回的是一个包含键和值的列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %capitals.kv; # (France Paris Italy
                  #  Rome Spain Madrid)</code></pre>
</div>
</div>
<div class="paragraph">
<p>类似的方法是 <code>pairs</code>，返回一个对儿的列表(对儿是包含一个键和一个值的数据类型):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %capitals.pairs; # (France =&gt; Paris
                     #  Italy =&gt; Rome
                     #  Spain =&gt; Madrid)</code></pre>
</div>
</div>
<div class="paragraph">
<p>要反转这些对儿，使用 <code>antipairs</code> 方法，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %capitals.antipairs; # (Paris =&gt; France
                         #  Rome =&gt; Italy
                         #  Madrid =&gt; Spain)</code></pre>
</div>
</div>
<div class="paragraph">
<p>散列的大小，实际上就是其中的对儿的数量，由 <code>elems</code> 方法返回, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %capitals.elems; # 3</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_命名约定">3.1.6. 命名约定</h4>
<div class="paragraph">
<p>Raku 并没有强迫用户遵循任何特定的变量命名规则。不过，最好还是遵循一般的常识性方法。变量名可能只有一个字母那么短，但也可以是描述性的，并且包含很多单词。</p>
</div>
<div class="paragraph">
<p>在循环中，或者在一些计算中，单字母名称是最好的选择，因为在循环中，所有提到的变量都是紧凑的，并且在屏幕上可以清楚地看到。当然，单字母名称可以使用小写字母和大写字母。虽然在 Raku 中没有标准，但在文档中常量和伪常量都使用大写的名字；例如，请查看 link:https:/​/​docs.​perl6.​org/​language/ variables#Compile-​time_​variables[]。</p>
</div>
<div class="paragraph">
<p>下面是一些单字母名称的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant $N = 100;
my $n = prompt('Enter a number: ');

say "You entered $n";
say 'This number is too big' if $n &gt; $N;</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于较长的名字，有几种选择。要么以小写字母或大写字母开头，要么整个名字大写。同样，大写的名字，比如 <code>$MAXIMUM</code>，即使你不使用 <code>constant</code> 关键字，也最好用大写的名字来表示常量。一般来说，更偏爱小写的名字。让我们重写前面的程序，使其使用较长的变量名:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant $MAXIMUM = 100;
my $value = prompt('Enter a number: ');
say "You entered $value";
say 'This number is too big' if $value &gt; $MAXIMUM;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在很多情况下，甚至需要更长的名字。在这种情况下，有几种方法可以用两个或更多的单词来构造名称。首先，可以使用所谓的驼峰式的大小写名称，例如 <code>$userValue</code> 或 <code>$valueFromInput</code>。其次，下划线字符是一个很好的候选者，可以将名字中的部分连接起来-<code>$user_value</code> 或 <code>$value_from_input</code>；这种风格被称为 snake case。最后，Raku 允许用破折号来表示多余的名字，例如 <code>$user-value</code> 或 <code>$MAXIMUM-VALUE</code>(kebab case)。在这种情况下，<code>-</code> 字符不是减号运算符，而是名称的一部分。所以，<code>$uservalue</code>、<code>$userValue</code>、<code>$user_value</code>、<code>$user_value</code>、<code>$user-value</code> 是四个不同的名字。考虑一下下面的代码片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant $MAXIMUM-VALUE = 100;
my $entered-value = prompt('Enter a number: ');
say "You entered $entered-value";
say 'This number is too big'
    if $entered-value &gt; $MAXIMUM-VALUE;</code></pre>
</div>
</div>
<div class="paragraph">
<p>选择自己的风格，并尽量在整个程序中保持一致。</p>
</div>
</div>
<div class="sect3">
<h4 id="_类型化的变量">3.1.7. 类型化的变量</h4>
<div class="paragraph">
<p>在前面的例子中，托管在变量容器中的内容类型是由分配给变量的值来定义的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;      # Declaring a variable as a container.
$x = 2;     # Now it contains an integer.
$x = 'Two'; # But now it keeps a string.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 允许你通过将变量容器的类型与变量声明一起指定，使变量容器的类型变得严格:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int $x = 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，<code>$x</code> 变量只能接受整数。例如，如果试图将其分配给一个字符串，会导致以下错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$x = 'Two'; # Type check failed in assignment to $x;
            # expected Int but got Str ("Two")</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，Raku 允许在同一个数组中使用不同类型的元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = (1, 'two', 3.0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>声明一个带类型的数组，会使其元素成为带类型的值。这意味着你不能给它分配另一种类型的值，如下面的例子所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int @a;
@a = 1, 2, 3;
say @a;
@a[2] = 'Two';</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后的赋值会导致类型检查错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Type check failed in assignment to @a; expected Int
but got Str ("Two")
in block &lt;unit&gt; at typed-arr.pl line 7</code></pre>
</div>
</div>
<div class="paragraph">
<p>类型化的变量可以使用任何内置类型或用户定义的类。在下一节中，我们将讨论 Raku 中默认的数据类型。在第八章《面向对象编程》中，你将学习如何创建自己的类。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用简单的内置数据类型">3.2. 使用简单的内置数据类型</h3>
<div class="paragraph">
<p>Raku 自带了许多不同的内置类型，这些类型涵盖了一些常见的东西，如布尔、整数、字符串等，但也提供了一些不常见的数据类型。我们将在本节中介绍这些类型。为了演示这些内置类型，我们将使用 <code>say</code> 函数将它们打印到控制台，就像我们在 'Hello, World! 例子中所做的那样。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://s3-img.meituan.net/v1/mss_3d027b52ec5a4d589e68050845611e68/ff/n0/0k/g3/e8_290655.jpg@596w_1l.jpg" alt="e8 290655.jpg@596w 1l">
</div>
</div>
<div class="paragraph">
<p>层次结构是用两种类型的项来建立的：角色和类。角色是用椭圆画的，而类是矩形框。角色类似于某些编程语言中的接口。在本章中，我们不会重点讨论什么是角色或类的细节。你可以在第八章《面向对象编程》中详细了解。现在，我们将假设你对面向对象编程有了一些基本的理解，并且能够理解数据类型的层次结构。</p>
</div>
<div class="paragraph">
<p>在本章下面的章节中，我们将对你在实践中可能会用到的主要数据类型进行梳理。</p>
</div>
<div class="sect3">
<h4 id="_整数数据类型">3.2.1. 整数数据类型</h4>
<div class="paragraph">
<p>在 Raku 中，<code>Int</code> 类型的值是一个整数值。该值可以容纳正数和负数，也可以容纳零，而且语言不限制数值的大小。它可以小到一个字节，例如，看看下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 42;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它也可以是任意精度的，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 239874637819093248768900298372340;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的例子中，使用了普通的十进制符号。Raku 允许使用其他的基数；例如，十六进制的值可以使用 16。要创建一个除 10 以外的整数基数，可以使用所谓的副词记号，如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say :16&lt;D0CF11E&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将打印出 <code>218951966</code>，这是 <code>:16&lt;D0CF11E&gt;</code> 整数的十进制表示。</p>
</div>
<div class="paragraph">
<p>以同样的方式，你将用其他基数创建值。考虑一下下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say :8&lt;755&gt;;
say :2&lt;10101&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的两行代码会分别打印出 <code>493</code> 和 <code>21</code>。</p>
</div>
<div class="paragraph">
<p>基数值不一定是 2 的次方。其他在 2 到 36 之间的整数值也是允许的，例如，考虑以下几行代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say :5&lt;342&gt;;
say :30&lt;102spqr&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第一个例子中，基数是 5，因此，在表示数的时候可以用 0 到 4 的数字来表示。值 <code>:5&lt;342&gt;</code> 对应于十进制形式的 <code>97</code>。</p>
</div>
<div class="paragraph">
<p>在第二个例子中，我们可以自由使用更多的"数位"，即 30 位。这些数字是常规的阿拉伯数字 0 到 9，后面是 20 个从 a 到 t 的拉丁字母。<code>:30&lt;102spqr&gt;</code> 的十进制值是 <code>731399307</code>。</p>
</div>
<div class="paragraph">
<p>你可能已经注意到，在前面的例子中，有些字母数字是大写的，有些是小写的。对于 Raku 来说，没有什么区别；当整数数字包含字母字符时，不区分大小写。所以，<code>:16&lt;D0CF11E&gt;</code> 和 <code>:16&lt;d0cf11e&gt;</code>，以及 <code>:30&lt;102spqr&gt;</code> 和 <code>:30&lt;102spqr&gt;</code> 是等价的。</p>
</div>
<div class="paragraph">
<p>大小写不敏感间接地定义了整数允许的基数范围；由于我们有 10 个阿拉伯数字和 26 个拉丁字母，因此它们的组合给出了 36 个不同的字符。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，长整型数值(也就是有很多位数的整数)可以用下划线字符来拼写成数字组。该功能最直接的目的是提供了将数字分割成三位数组的方法。例如，考虑一下下面这行代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 75_926_028;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，<code>75_926_028</code> 的记号，无非是给出了 <code>75926028</code> 这个数字，但它让我们清楚地看到这个数字是 7500 万，926 个千，加上 28。对于编译器来说，没有什么区别，两个数字同样容易读懂。而对于人类来说，把一个数字拆成一组，就更容易读懂了。</p>
</div>
<div class="paragraph">
<p>严格来说，你不受限于拆分数字的方式。也就是说，下面的格式在形式上是正确的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 2_12_85_06;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种格式可能适用于电话号码，但不适用于普通整数。</p>
</div>
<div class="paragraph">
<p>但是，你不能在一行中出现两个下划线。数字也不能以下划线开头或结尾。下面的三次尝试将无法编译:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 20__17;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码将产生编译器错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Only isolated underscores are allowed inside numbers</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say _2017;
say 2017_;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这两种情况下的错误信息比较短，编译器只是这样说的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Confused</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_int_类型的方法">Int 类型的方法</h5>
<div class="paragraph">
<p>Raku 中的数据类型由许多内置类表示，这意味着可以对这些类的对象调用方法。语言的面向对象的特性在第八章《面向对象编程》中已经介绍过了，但是，暂时还不能回避其中的一些元素。</p>
</div>
<div class="paragraph">
<p>在本节中，将只列出最有趣的方法。可以在文档页面 <a href="https:/​/​docs.raku.​org/​type/​Int" class="bare">https:/​/​docs.raku.​org/​type/​Int</a> 上获得完整的可能性列表。</p>
</div>
<div class="paragraph">
<p>现在最基本的是，最重要的是，方法的调用是使用值本身或包含相应类型值的变量上的点来调用。在下一节中，你会看到方法的调用方式，马上就可以看到。</p>
</div>
<div class="sect5">
<h6 id="_使用_chr_方法转换为字符">使用 chr 方法转换为字符</h6>
<div class="paragraph">
<p>可以将整数值转换为相应的字符。其对应关系由 Unicode 代码点定义。</p>
</div>
<div class="paragraph">
<p>如果是 256 以下的值，则与 ASCII 表一致。考虑一下下面的代码片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 65.chr; # prints A</code></pre>
</div>
</div>
<div class="paragraph">
<p>更高的值会从 Unicode 表中产生字符，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 8594.chr; # →</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用十六进制表示法也可以得到同样的结果，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 0x2192.chr; # →</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_检查数字是否为质数">检查数字是否为质数</h6>
<div class="paragraph">
<p><code>is-prime</code> 方法返回一个布尔值，告诉我们这个数是否是质数，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10.is-prime; # False
say 11.is-prime; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>在大数上执行 <code>is-prime</code> 方法可能会很慢。</p>
</div>
</div>
<div class="sect5">
<h6 id="_生成一个随机数">生成一个随机数</h6>
<div class="paragraph">
<p><code>rand</code> 方法返回一个介于 0 和给定值之间的随机数。请注意，这个方法是从 <code>Real</code> 角色继承而来的(请参考《使用简单的内置数据类型》一章中开头的图表)，而返回值是一个浮点数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 100.rand;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行这段代码几次后，会打印出不同的值，就像你在这里看到的那样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">70.1530942429978
57.2150256026057
13.7542877975353
94.6395293813437</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_获取值的符号">获取值的符号</h6>
<div class="paragraph">
<p><code>sign</code> 方法(也继承自 <code>Real</code> 角色)返回 <code>-1</code> 或 <code>1</code>，这取决于值的符号。考虑一下下面的代码片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 42.sign;  # 1
say -42.sign; # -1</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 0 上调用该方法的结果是 0，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 0.sign; # 0</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>sign</code> 方法也适用于无穷大的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Inf.sign;  # 1
say (-∞).sign; # -1</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_计算值的平方根">计算值的平方根</h6>
<div class="paragraph">
<p>要计算值的平方根，请在其上调用 <code>sqrt</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 9.sqrt; # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个例程在 Raku 中也被定义为一个独立的内置函数。考虑一下下面的代码片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say sqrt(9); # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <code>sqrt</code> 方法继承自 <code>Numeric</code> 角色，所以结果是一个浮点值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10.sqrt; # 3.16227766016838</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_获取下一个值和前一个值">获取下一个值和前一个值</h6>
<div class="paragraph">
<p><code>pred</code> 和 <code>succ</code> 这两个方法分别返回整数参数的前一个值和下一个值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 42.pred; # 41
say 42.succ; # 43</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个方法也适用于非整数值的加减法，当它们加减 1 时，如下一个片段所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say pi.pred;    # 2.14159265358979
say (3/4).succ; # 1.75</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些方法的名称来自于 predecessor 和 successor 这两个单词。</p>
</div>
</div>
<div class="sect5">
<h6 id="_获取绝对值">获取绝对值</h6>
<div class="paragraph">
<p><code>abs</code> 方法返回绝对值。在下面的例子中，该方法是在一个变量上调用的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = -42;
say $x.abs; # 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>要在一个值上调用它，需要在负值上加上括号。否则，将对调用 <code>abs</code> 方法的结果应用一元减法运算符(详见第四章《使用运算符》)。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rat_类型">3.2.2. Rat 类型</h4>
<div class="paragraph">
<p>在 Raku 中，有一个特殊的 <code>Rat</code> 类型来存储有理数。在很多情况下，当你处理浮点数时，<code>Rat</code> 会被使用。在内部，<code>Rat</code> 值由一对整数表示, 即分子和分母。因此，任何 <code>Rat</code> 数都是一个等于除法 <code>N/D</code> 的有理数。整数的分子部分是一个可以任意长的值。分母部分是一个 64 位的整数。</p>
</div>
<div class="paragraph">
<p>只要你有一个带小数点的常数，没有指数部分就会出现 <code>Rat</code> 值。请考虑下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 3.14;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>3.14</code> 这个字面值在这里创建了一个 <code>Rat</code> 值。</p>
</div>
<div class="paragraph">
<p>还有另一种语法来创建 <code>Rat</code> 值：像除法那样使用斜线, 并且可以选择在一对角括号中加上一个数字，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1/2;
say &lt;1/2&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，你可以用 Unicode 字符来表示分数。例如，下面这一行将创建一个等于 0.5 的 Rat 数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ½;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Rat</code> 值的内部结构为精确计算提供了一种奇妙的能力。与许多其他语言不同的是，在 Raku 中，浮点运算使用的是精度有限的 IEEE 数字，而在 Raku 中， <code>Rat</code> 数的使用有助于避免在处理小数时出现四舍五入的错误，或者是在处理两个数字非常接近的数字时，无法使用 IEEE 表示法进行精确比较。</p>
</div>
<div class="paragraph">
<p>在下面的例子中，我们将使用 <code>Rat</code> 数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1/2 + 1/4 + 1/8 + 1/16;
say 0.1 + 0.2 - 0.3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一个例子很有意思，因为它在 Raku 中打印出了 0。Raku 使用 <code>Rat</code> 进行计算，并在内部将这些值处理为 <code>1/10</code>、<code>2/10</code> 和 <code>3/10</code>。因此，<code>0.1 + 0.2 - 0.3</code> 的总和等于 <code>1/10 + 2/10 - 3/10</code>，结果 <code>Rat</code> 值为 <code>0/10</code>，也就是 0。在其他许多使用浮点数的语言中，包括 Perl 5，同样的计算不会产生 0。结果会很小，但仍然不是零；例如，<code>5.55111512312578e-17</code>。</p>
</div>
<div class="paragraph">
<p>使用 <code>Rat</code> 进行精确计算的优势是显而易见的。例如，在财务计算中，你可以使用 <code>Rat</code> 数来避免四舍五入的错误。(不过，在很多情况下，在财务计算中，你可以使用整数，并以分值为单位进行计算；因此，不要把 9.99 欧元作为浮点数，而是用 999 分来操作。)</p>
</div>
<div class="sect4">
<h5 id="_rat_类型的方法">Rat 类型的方法</h5>
<div class="paragraph">
<p><code>Rat</code> 方法有一些特定的方法和一些从其基类或角色继承的方法，如 <code>Real</code> 或 <code>Numeric</code>。其中一些方法已经在 <code>Int</code> 类型的方法一节中讨论过了。</p>
</div>
<div class="sect5">
<h6 id="_获取值的_raku_表示法">获取值的 Raku 表示法</h6>
<div class="paragraph">
<p><code>raku</code> 方法返回一个可以表示 <code>Rat</code> 值的字符串，这个字符串可以表示 Raku 在源码中的理解。结果可以包含一个小数点或斜线，这取决于哪种方法更有利于精确地表示值。</p>
</div>
<div class="paragraph">
<p>考虑一下几个例子，就能体现出前面的想法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 1/3;
say $x.perl; # &lt;1/3&gt;

my $y = 1/2;
say $y.perl; # 0.5</code></pre>
</div>
</div>
<div class="paragraph">
<p>更有甚者，下面的代码是有效的 Raku 代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10/20.raku; # 0.5</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_转换为_int_值">转换为 Int 值</h6>
<div class="paragraph">
<p>要将 <code>Rat</code> 值转换为整数值，调用 <code>Int</code> 方法。这就是类型转换的一般原理：数据类型定义的方法，其名称重复了其他数据类的名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 10/3;
say $x.Int; # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个程序中，<code>$x.Int</code> 的结果是3，但你要记住，赋值中的 <code>10/3</code> 不是除法，而是表示 <code>Rat</code> 数的一种方法。同样的，也可以用更明确的形式来表达，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = &lt;10/3&gt;;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_获取分子和分母">获取分子和分母</h6>
<div class="paragraph">
<p>要得到一个 <code>Rat</code> 值的两部分，可以使用 <code>numerator</code> 和 <code>denominator</code> 方法。我们来看看上一节中的值的例子，看看它们是如何工作的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 10/3;
say $x.numerator;   # 10
say $x.denominator; # 3</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_四舍五入的方法">四舍五入的方法</h6>
<div class="paragraph">
<p>有四种不同的方法可以将 <code>Rat</code> 值转换为整数：<code>round</code>、<code>ceiling</code>、<code>floor</code> 和 <code>truncate</code>。</p>
</div>
<div class="paragraph">
<p><code>round</code> 方法根据数学定义对数值进行四舍五入：数值向最接近的整数进位。我们可以从下面的代码片段中看到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 3.14.round; # 3
say 2.71.round; # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>(注意，第一个小点分隔了数字的小数部分，而第二个小点是方法调用)。</p>
</div>
<div class="paragraph">
<p>负值也会被四舍五入，使结果是最接近的整数。我们可以在下面的代码片段中看到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (-3.14).round; # -3
say (-2.71).round; # -3</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>truncate</code> 方法只是将小数部分切掉，不考虑符号，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 3.14.truncate; # 3
say 2.71.truncate; # 2

say (-3.14).truncate; # -3
say (-2.71).truncate; # -2</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，<code>ceiling</code> 和 <code>floor</code> 方法将数字四舍五入到下一个或上一个整数，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 3.14.ceiling; # 4
say 3.14.floor;   # 3

say (-2.71).ceiling; # -2
say (-2.71).floor;   # -3</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_方法_pred_和_succ">方法 pred 和 succ</h6>
<div class="paragraph">
<p>这两种方法的工作原理与它们对整数值的工作原理类似。整数部分返回、递增或递减，而浮点部分保持不变，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 3.14.pred; # 2.14
say 3.14.succ; # 4.14</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_numeric_数据类型">3.2.3. Numeric 数据类型</h4>
<div class="paragraph">
<p><code>Num</code> 类型用于存储浮点值。它对应于 C 语言中的双精度。</p>
</div>
<div class="paragraph">
<p>注意，在 Raku 中，只有当数值字面值用科学符号拼写时，<code>Num</code> 值才会被创建。也就是说，值的 <code>E</code> 部分必须存在。</p>
</div>
<div class="paragraph">
<p>因此，在下面的例子中，只有小数点的数字将是 <code>Rat</code> 类型的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 3.14;    # Rat
say 123.456; # Rat
say 0.9;     # Rat</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的数字表示相同的值，但都属于 <code>Num</code> 类型，因为它们在定义中使用了指数部分:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 3.14E0;    # Num
say 1.23456E2; # Num
say 9E-1;      # Num</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住，<code>Num</code> 值使用的是 IEEE 的二进制格式，所以它们的精度是有限的，而 <code>Rat</code> 类型的数字将其分子和分母为保存为两个整数。</p>
</div>
<div class="paragraph">
<p>在 <code>Num</code> 值中，有一个突出的 <code>NaN</code> 值，它代表的是 Not a Number。</p>
</div>
<div class="sect4">
<h5 id="_num_与_numeric_和_real_的比较">Num 与 Numeric 和 Real 的比较</h5>
<div class="paragraph">
<p>正如你在类型层次结构图中看到的那样，有些节点被放置在椭圆中而不是矩形框中。这些都是角色。角色提供了一些继承于类的接口。我们将在第八章《面向对象编程》中更详细地讨论角色。</p>
</div>
<div class="paragraph">
<p><code>Numeric</code> 角色为我们提供的一些方法有: <code>Real</code>、<code>Int</code>、<code>Rat</code>、<code>Num</code> 和 <code>Bool</code>，用于将值转换为其他数据类型；<code>log</code>、<code>log10</code>、<code>exp</code>、<code>roots</code>、<code>abs</code> 和 <code>sqrt</code> 用于相应的数学计算；以及 <code>prec</code> 和 <code>succ</code> 对。</p>
</div>
<div class="paragraph">
<p><code>Real</code> 角色类给了我们以下方法: <code>rand</code>、<code>sign</code>、<code>round</code>、<code>floor</code>、<code>ceiling</code> 和 <code>truncate</code>。</p>
</div>
<div class="paragraph">
<p>如果你想深入挖掘并查看所有类之间的联系，请参考文档页面 <a href="https:/​/​docs.raku.​org/​type.​html" class="bare">https:/​/​docs.raku.​org/​type.​html</a>。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_枚举">3.2.4. 枚举</h4>
<div class="paragraph">
<p>枚举是用于定义数据类型，例如，某些概念的可能值。例如，交通灯的颜色有三个值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum TrafficLight &lt;red yellow green&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些值的名字在 Raku 中会被知道，因此你可以直接在程序中使用它们。例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say red;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码会打印出该值的名称:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">red</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，red、yellow 和 green 的实际值对我们来说并不重要，但 Raku 会给它们分配递增的整数值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say red + yellow + green; # 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序相当于 <code>say `0 + 1 + 2</code>。</p>
</div>
<div class="paragraph">
<p>当这些值很重要的时候，那么你可以显式指定它们，就像我们在下一个例子中所做的那样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Floors (
    garage =&gt; -1, ground-floor =&gt; 0,
    first =&gt; 1, second =&gt; 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将在下一节中看到 Raku 中 <code>Boolean</code> 类型定义中的枚举的一个例子。</p>
</div>
</div>
<div class="sect3">
<h4 id="_boolean_数据类型">3.2.5. Boolean 数据类型</h4>
<div class="paragraph">
<p><code>Bool</code> 是一个布尔数据类型，提供两个值。<code>True</code> 和 <code>False</code>。从技术上讲，这是一个枚举的两个值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Bool &lt;True False&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>布尔类型的用法很简单。我们将在第五章《控制流》中看到更多布尔数据类型的用法。</p>
</div>
<div class="sect4">
<h5 id="_布尔类型的方法">布尔类型的方法</h5>
<div class="paragraph">
<p><code>Bool</code> 类型有一些方法，我们已经看到了 <code>Int</code> 和 <code>Rat</code> 数据的使用，但它们的行为可能略有不同。</p>
</div>
<div class="sect5">
<h6 id="_使用_pred_和_succ">使用 pred 和 succ</h6>
<div class="paragraph">
<p><code>pred</code> 和 <code>succ</code> 这两种方法有一个特点，就是可用值的范围非常有限。你不应该期望值是循环的。这些方法的结果显示在下面这段代码的注释中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say True.pred;  # False
say True.succ;  # True

say False.pred; # False
say False.succ; # True</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_生成随机布尔值的方法">生成随机布尔值的方法</h6>
<div class="paragraph">
<p>有两个方法，<code>pick</code> 和 <code>roll</code>，这两个方法都可以用或不用参数来调用。这些方法必须对类名本身进行调用，而不是对它的值或变量进行调用。</p>
</div>
<div class="paragraph">
<p>当调用 <code>pick</code> 或 <code>roll</code> 没有参数时，它们会返回一个随机值，要么是 <code>True</code>，要么是 <code>False</code>。我们可以在下面的代码片段中看到这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Bool.pick;
say Bool.roll;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当用整数参数调用这些方法时，会生成一个随机值的列表。整数参数定义了列表中元素的数量，但在此基础上，<code>pick</code> 方法增加了它的限制，只返回唯一的值，对于 <code>Bool</code> 类来说，这个值不超过两个。比较类似的调用结果，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Bool.pick(4); # (False True) or (True False)
say Bool.roll(4); # e.g. (False True False False)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_字符串数据类型">3.2.6. 字符串数据类型</h4>
<div class="paragraph">
<p>在 Raku 中，字符串由 <code>Str</code> 数据类型表示。一个字符串是一个 Unicode 字符的序列。考虑到下面的代码片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = 'Hello, World!';
say $str;</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们直接进入 <code>Str</code> 类的方法。</p>
</div>
<div class="sect4">
<h5 id="_str_类的方法">Str 类的方法</h5>
<div class="paragraph">
<p>重要的是要始终记住，所有的语义都与 Unicode 的规则一致。例如，这意味着，将一个字符串转换为大写字母将改变相应的字符，即使它们需要超过一个字节的内存。</p>
</div>
<div class="sect5">
<h6 id="_转换寄存器">转换寄存器</h6>
<div class="paragraph">
<p>有很多方法可以改变字符串中字母的寄存器。第一组包含简单的 <code>lc</code> 和 <code>uc</code>，它将所有字符转换为小写或大写。考虑下面的代码片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'String'.lc; # string
say 'String'.uc; # STRING</code></pre>
</div>
</div>
<div class="paragraph">
<p>其他四个方法比较复杂。</p>
</div>
<div class="paragraph">
<p><code>fc</code> 方法将一个字符串转换为所谓的折叠大小写。它的目的是用于字符串比较。例如，将这三种方法在字符串上调用的输出与德文字母 ß 进行比较，ß 的大写字母是 SS，但在折叠大小写中被转换为 ss。请考虑以下代码片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Hello, Straße!'.lc; # hello, straße!
say 'Hello, Straße!'.uc; # HELLO, STRASSE!
say 'Hello, Straße!'.fc; # hello, strasse!</code></pre>
</div>
</div>
<div class="paragraph">
<p>(请记住，自2017年6月起，德语正式有了 ß 的大写版本，我们可以在这里 link:https:/​/​en.​wikipedia.​org/​wiki/​Capital_ %E1%BA%9E[] 了解一下。方法的行为可能会改变。)</p>
</div>
<div class="paragraph">
<p><code>tc</code> 方法将一个字符串转换为所谓的标题大小写，其中字符串的第一个字母是大写。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'hey, you'.tc; # Hey, you</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，如果字符串中已经包含了大写字母，它们将保持原样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'dear Mr. Johnson'.tc; # Dear Mr. Johnson</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>tclc</code> 方法将所有其他字母转换为小写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'HI THERE!'.tclc; # Hi there!</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>wordcase</code> 方法将每个单词的第一个字母大写，其余的字母小写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'hello WORLD'.wordcase; # Hello World</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_切割字符串的方法">切割字符串的方法</h6>
<div class="paragraph">
<p>这两种方法-<code>chop</code> 和 <code>chomp</code>-有相似的名字，但对它们所处理的字符有不同的敏感性。<code>chop</code> 方法切断了字符串的最后一个字符。只有当最后一个字符是换行符时，<code>chomp</code> 方法才会将其切掉。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "Text\n".chomp; # Text
say "Text\n".chop; # Text

say "Text".chomp; # Text
say "Text".chop; # Tex</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一组方法-<code>trim</code>、<code>trim-leading</code> 和 <code>trim-trailing</code>-切断字符串开头和/或结尾的空格。请看下面的代码片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = ' word '.trim;
say "[$s]"; # [word]

$s = ' word '.trim-leading;
say "[$s]"; # [word ]

$s = ' word '.trim-trailing;
say "[$s]"; # [ word]</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_检查字符串内容的方法">检查字符串内容的方法</h6>
<div class="paragraph">
<p><code>Str</code> 类定义了一对方法-<code>starts-with</code> 和 <code>ends-with</code>-检查字符串的开头或结尾是否包含一个给定的子串，并返回一个布尔值。考虑下面的例子，它显示了这些方法的行为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Hello, World'.starts-with('Hello'); # True
say 'Hello, World'.starts-with('World'); # False
say 'Hello, World'.ends-with('Hello');   # False
say 'Hello, World'.ends-with('World');   # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用正则表达式来代替 <code>starts-with</code> 和 <code>ends-with</code>; 详情请参考第十一章,《正则表达式》。</p>
</div>
<div class="paragraph">
<p>另一组函数-<code>index</code>、<code>rindex</code> 和 <code>indices</code>-查找子串并返回它的位置。<code>index</code> 方法找到子串最左边的出现，<code>rindex</code> 从字符串的末尾开始搜索，而 <code>index</code> 则返回子串所有出现的索引列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $town = 'Baden-Baden';

say $town.index('Baden');   # 0
say $town.rindex('Baden');  # 6
say $town.indices('Baden'); # (0 6)</code></pre>
</div>
</div>
<div class="paragraph">
<p>值得注意的是，虽然 <code>rindex</code> 方法是从字符串的末尾搜索，但它返回的是一个从左到右计算的字符索引。</p>
</div>
</div>
<div class="sect5">
<h6 id="_字符串的长度">字符串的长度</h6>
<div class="paragraph">
<p>要获得字符串的长度，像下面这样调用 <code>chars</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Düsseldorf'.chars; # 10</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_翻转字符串">翻转字符串</h6>
<div class="paragraph">
<p><code>flip</code> 方法返回的字符串中，所有字符的顺序都是相反的，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Rose'.flip; # esoR</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_复数">3.2.7. 复数</h4>
<div class="paragraph">
<p>在 Raku 中，有 <code>Complex</code> 内置类型来呈现复数。</p>
</div>
<div class="paragraph">
<p>复数有两个部分，实数和虚数，并使用以下语法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 3+4i;
my $y = -5i;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它不需要明确地写出实数部分，但输出总是包含它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $x; # 3+4i
say $y; # -0-5i
say $z; # 0+1i</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建 <code>Complex</code> 数的另一种方法是调用构造函数(我们将在第八章，《面向对象编程》中讨论构造函数)，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = Complex.new(4, 5);
say $n; # 4+5i</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_复数数据类型的方法">复数数据类型的方法</h5>
<div class="paragraph">
<p>其中有些方法我们已经很熟悉了。这些方法是 <code>round</code>、<code>ceiling</code>、<code>floor</code> 和 <code>truncate</code>，它们同时改变了复数值的实部和虚部。让我们简单地看一下其他的方法。</p>
</div>
<div class="sect5">
<h6 id="_获取实部和虚部">获取实部和虚部</h6>
<div class="paragraph">
<p>这两个方法-<code>re</code> 和 <code>im</code>-返回复数的实部和虚部，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $z = 4+5i;

say $z.re; # 4
say $z.im; # 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>虚数部分的返回不包含变量 <code>i</code>。</p>
</div>
<div class="paragraph">
<p><code>reals</code> 方法返回一个包含这两个值的列表，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $z = 4+5i;
say $z.reals; # (4 5)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_操作日期和时间的数据类型">3.3. 操作日期和时间的数据类型</h3>
<div class="paragraph">
<p>Raku 提供了对日期和时间的内置支持，这非常方便，因为日期-时间的计算并不容易(你需要考虑闰年、额外的秒数、时区、日历校正等)。</p>
</div>
<div class="paragraph">
<p>我们将涉及两个类: <code>Date</code> 和 <code>DateTime</code>。</p>
</div>
<div class="sect3">
<h4 id="_使用_date_类">3.3.1. 使用 Date 类</h4>
<div class="paragraph">
<p><code>Date</code> 类表示日期-由年、月和日这三个数字组成的集合。要创建一个新的日期，使用这三个值调用一个构造函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $date = Date.new(2017, 7, 19);
say $date; # 2017-07-19</code></pre>
</div>
</div>
<div class="paragraph">
<p>要创建一个基于今天日期的变量, 使用 <code>today</code> 方法, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $today = Date.today;
say $today; # 2017-07-17</code></pre>
</div>
</div>
<div class="paragraph">
<p>要克隆一个日期，调用 <code>clone</code>，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $date2 = $today.clone;</code></pre>
</div>
</div>
<div class="paragraph">
<p>日期的各个部分可以从日期的明确命名方法中获得，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $date.year;  # 2017
say $date.month; # 7
say $date.day;   # 19</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外(这已经是一个很好的奖励了)，<code>Date</code> 可以计算一周的哪一天(周一是 1，周日是 7):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $date.day-of-week; # 3 (Wednesday)</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有 <code>day-of-month</code> 和 <code>day-of-year</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $date.day-of-month; # 19 (same as $date.day)
say $date.day-of-year;  # 20</code></pre>
</div>
</div>
<div class="paragraph">
<p>有一些方法可以帮助计算周数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $date.week;        # (2017 29)
say $date.week-number; # 29
say $date.week-year;   # 2017</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于一月的周数，<code>week</code> 和 <code>week-year</code> 方法返回的年份可能是上一年或下一年，这取决于这一天属于哪一周。例如，以 2019 年的最后一天和 2020 年的第一天为例。2019年12月31日是星期二，2020年1月1日是星期三。两天都属于同一周，所以 <code>week-year</code> 方法返回 2020。检查下面程序的输出，以了解该方法的工作原理:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $d1 = Date.new(2019, 12, 31);
say $d1.day-of-week; # 3
say $d1.year; # 2019
say $d1.week-year; # 2020

my $d2 = Date.new(2020, 1, 1);
say $d2.day-of-week; # 4
say $d2.year; # 2020
say $d2.week-year; # 2020</code></pre>
</div>
</div>
<div class="paragraph">
<p>有一个有趣的 <code>weekday-of-month</code> 方法，可以返回这个月在给定日期之前的这个星期的这一天的出现次数。例如，2017年7月19日是2017年7月的第三个星期三:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $date.weekday-of-month; # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>earlier</code> 和 <code>later</code> 方法的帮助下，日期计算非常简单:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $today.later(days =&gt; 2);   # 2017-07-19
say $today.later(months =&gt; 2); # 2017-07-21</code></pre>
</div>
</div>
<div class="paragraph">
<p>要得到昨天和明天的日期，使用 <code>pred</code> 和 <code>succ</code> 方法，我们已经在数字数据类型中看到过:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $today.pred; # 2017-07-18
say $today.succ; # 2017-07-20</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用_datetime_数据类型">3.3.2. 使用 DateTime 数据类型</h4>
<div class="paragraph">
<p><code>DateTime</code> 数据类型的使用与 <code>Date</code> 类型的工作非常相似。在 <code>DateTime</code> 对象中，出现了处理时间的新字段。我们可以在下面的代码片段中看到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $dt = DateTime.new(
    year =&gt; 2017,
    month =&gt; 7,
    day =&gt; 19,
    hour =&gt; 1,
    minute =&gt; 46,
    second =&gt; 48);

say $dt;        # 2017-07-19T01:46:48Z

say $dt.year;   # 2017
say $dt.month;  # 7
say $dt.day;    # 19

say $dt.hour;   # 1
say $dt.minute; # 46
say $dt.second; # 48</code></pre>
</div>
</div>
<div class="paragraph">
<p>要创建一个新的 <code>DateTime</code> 对象并将其设置为当前时刻，使用 <code>now</code> 构造函数，如这里所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $dt = DateTime.now;
say $dt; # 2017-07-19T01:44:00.301537+02:00</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>hh-mm-ss</code> 和 <code>yyyy-mm-dd</code> 方法为时间和日期生成格式化的字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $dt.yyyy-mm-dd; # 2017-07-19
say $dt.hh-mm-ss;   # 01:45:44</code></pre>
</div>
</div>
<div class="paragraph">
<p>打印秒数时要小心。<code>second</code> 方法返回一个包含分数秒的浮点数。要获得一个整数值，请使用 `whole-second ` 方法。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_3">3.4. 总结</h3>
<div class="paragraph">
<p>在本章中，我们看了 Raku 中内置数据类型的概述，并学习了如何使用变量。最重要的事实是，Raku 中的变量是不同的内置数据类型类的实例。这些类的细节位于第八章《面向对象编程》中，但要在 Raku 中成功创建和使用变量，需要一些面向对象编程的元素。</p>
</div>
<div class="paragraph">
<p>在本章的第一部分，你学习了变量容器的三种结构类型-标量、数组和散列，并研究了它们的主要方法。在第二部分中，我们深入了解了不同的数据类型，如整数、有理数、浮点数、字符串、日期和时间。</p>
</div>
<div class="paragraph">
<p>在下一章中，我们将继续研究 Raku 程序中的流程控制。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_使用运算符">4. 使用运算符</h2>
<div class="sectionbody">
<div class="paragraph">
<p>运算符是语言语法的元素, 它们对操作数执行操作并返回结果。Raku 是一门拥有几十个运算符的语言。其中有些是继承自 Perl 5 的(直接或经过修改), 有些则是专门为 Raku 而发明的。在常规运算符集合之上, Raku 还定义了所谓的元运算符和超运算符, 它扩展了常规运算符的含义, 用于处理一组值。</p>
</div>
<div class="paragraph">
<p>在本章中, 我们将介绍以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>运算符分类</p>
</li>
<li>
<p>一元运算符</p>
</li>
<li>
<p>二元运算符</p>
</li>
<li>
<p>三元运算符</p>
</li>
<li>
<p>按位运算符</p>
</li>
<li>
<p>其他运算符</p>
</li>
<li>
<p>运算符优先级</p>
</li>
<li>
<p>替换元运算符</p>
</li>
<li>
<p>赋值元运算符</p>
</li>
<li>
<p>否定元运算符</p>
</li>
<li>
<p>反转元运算符</p>
</li>
<li>
<p>创建超运算符</p>
</li>
<li>
<p>超运算符的类型</p>
</li>
<li>
<p>化简超运算符</p>
</li>
<li>
<p>交叉超运算符</p>
</li>
<li>
<p>Zip 超运算符</p>
</li>
<li>
<p>顺序超运算符</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_运算符分类">4.1. 运算符分类</h3>
<div class="paragraph">
<p>首先, 让我们提醒自己在谈论运算符时需要的一些基本术语。考虑一个简单的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 10;
my $b = 20;
my $c = 0;
$c = $a + $b;
say $c; # 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们专注于下面这行代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$c = $a + $b;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, 我们告诉编译器执行两个操作 - 首先, 计算 <code>$a</code> 和 <code>$b</code> 变量的总和, 其次, 将结果分配给第三个变量, 即 <code>$c</code>。在这个例子中, 有两个运算符 - <code>+</code> 和 <code>=</code>。运算符由它们的单字符名字表示。在本例中, 选择这些名称是为了复制数学中相应的运算符。稍后, 我们将看到其他运算符的例子, 这些运算符不仅仅是一个字符。例如, 它们可以是一个由两个或三个非字母符号组成的序列, 如 <code>&gt;=</code> 或 <code>&#8656;</code> 运算符。或者, 它们可以是一个字符串标识符, 例如-<code>cmp</code> 或 <code>eq</code>。</p>
</div>
<div class="sect3">
<h4 id="_运算符的类别">4.1.1. 运算符的类别</h4>
<div class="paragraph">
<p>在上一节中, 我们看到了一个 <code>+</code> 运算符的例子, 它需要两个参数。还有许多其他运算符与 <code>+</code> 类似。例如, <code><strong></code> 是乘法运算符。和 <code>+</code> 运算符一样, <code></strong></code> 运算符也是接受两个参数并返回一个值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = $a * $b;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种运算符称为中缀运算符, 或简称中缀。这种运算符的操作数通常被称为左操作数和右操作数。因为这种运算符接收两个参数, 所以也常被称为二元运算符。</p>
</div>
<div class="paragraph">
<p>另一种运算符只需要一个参数。这些运算符被称为一元运算符。一元运算符的一个典型例子是一元减法。在下面的例子中, 这个运算符否定了它的参数值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 10;
my $b = -$a;
say $b; # prints -10</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, 这个运算符与二元减法运算符使用相同的字符, 但程序员和编译器都可以区分这两者:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 10;
my $b = -$a;     # unary minus, $b becomes -10
my $c = $a - $b; # binary subtraction, $c is 20</code></pre>
</div>
</div>
<div class="paragraph">
<p>不同的一元运算符可以放在参数之前或之后。例如, <code>++</code> 运算符有两种形式 - 前缀和后缀。下面的例子演示了这两种形式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 10;
++$a; # prefix operator ++
$a++; # postfix operator ++</code></pre>
</div>
</div>
<div class="paragraph">
<p>运算符的位置(它可以放在参数之前或之后)会改变它的含义。</p>
</div>
<div class="paragraph">
<p>到目前为止, 我们认识了中缀、前缀和后缀运算符。在 Raku 中还有两类运算符。</p>
</div>
<div class="paragraph">
<p>环缀运算符是另一种一元运算符。与一元运算符 <code>-</code> 不同的是, 环缀运算符由两个互补部分组成, 例如括号。环缀运算符唯一的操作数是放在这俩个括号之间的, 例如 <code>[$a]</code> 结构使用 <code>[]</code> 环缀运算符, 将 <code>$a</code> 作为参数。</p>
</div>
<div class="paragraph">
<p>最后, 还有后环缀运算符。它们需要两个操作数, 语法如下-<code>操作数1[操作数2]</code>。后环缀运算符最实用的例子之一是函数调用。我们已经看到过几次了-<code>add($a, $b)</code>。</p>
</div>
<div class="paragraph">
<p>下面我们以 <code>+</code> 运算符符号为例, 总结一下运算符的类别:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">类别</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">语法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">中缀</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">操作数1 + 操作数2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">前缀</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+操作数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">后缀</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">操作数+</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">环缀</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(操作数)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">后环缀</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">操作数1[操作数2]</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_运算符作为函数">4.1.2. 运算符作为函数</h4>
<div class="paragraph">
<p>运算符对其参数执行一些操作。运算符的参数称为操作数。在前面的例子中, <code>+</code> 运算符接受两个操作数 <code>$a</code> 和 <code>$b</code>。<code>=</code> 运算符也接受两个操作数 - 它期望将其右边操作数的值赋值给左侧变量。</p>
</div>
<div class="paragraph">
<p>在任何编程语言中, 运算符只是一个方便的语法解决方案, 它使程序更具表现力, 并且可以通过函数调用来替换。例如, 在前面的例子中, 你写的是 <code>$c = $a + $b</code>, 但你也可以通过调用我们在第一章《Raku 是什么》中的 <code>add</code> 函数来做同样的事情。让我们重写前面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 10;
my $b = 20;
my $c = 0;
$c = add($a, $b);
say $c; # 30

sub add($a, $b) {
    return $a + $b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然, <code>add</code> 函数本身也使用了 <code>+</code> 运算符, 但我们在这里无法避免, 因为在 Raku 中没有更多的低级函数用于加法。这个例子的目的是为了说明, 运算符可以一直被当作接受几个参数并返回一个值的函数, 但你并不能直接调用它们, 而是通过一个好看的运算符。</p>
</div>
<div class="paragraph">
<p>在 Raku 中, 你可以在使用运算符时使用函数式。为此, 请使用带有运算符类别名的关键字, 后面是冒号, 运算符本身则放在角括号中。然后, 像使用函数一样传递参数。下面以 <code>+</code> 中缀运算符为例进行了演示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 10;
my $b = 20;
my $c = infix:&lt;+&gt;($a, $b); # same as $c = $a + $b
say $c; # 40</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 我们来讨论一下 Raku 提供的运算符的类别。 而现在, 是时候逐一研究这些运算符了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_raku_中的运算符">4.2. Raku 中的运算符</h3>
<div class="paragraph">
<p>在 Raku 中, 有几十种内置的运算符。为了使概述更有条理, 我们将它们按照前面几节中描述的类别进行分组:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>中缀运算符</p>
</li>
<li>
<p>后缀运算符</p>
</li>
<li>
<p>环缀运算符</p>
</li>
<li>
<p>后环缀运算符</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在下面的小节中, 我们将对 Raku 中的运算符进行研究, 这些运算符被分成了几类。在每一个类别中, 运算符的排列顺序都是按降序排列的。</p>
</div>
<div class="sect3">
<h4 id="_中缀运算符">4.2.1. 中缀运算符</h4>
<div class="paragraph">
<p>中缀运算符可能是该语言中最常用的运算符。它们也是最直观的运算符。</p>
</div>
<div class="sect4">
<h5 id="_赋值运算符">赋值运算符</h5>
<div class="paragraph">
<p><code>=</code> 运算符是赋值运算符。它用于将其右侧操作数的值赋值给左侧的变量。在最简单的情况下, 运算符的使用是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a;
$a = 42;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该操作并不只限于标量。数组、散列或类的实例(我们将在第八章《面向对象编程》中讨论类)的赋值也如预期一样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = &lt;10 20 30&gt;;
my @b = @a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里, 赋值运算符被使用了两次, 首先是初始化 <code>@a</code> 数组, 然后将其值赋给第二个数组 <code>@b</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_乘法和除法运算符">乘法和除法运算符</h5>
<div class="paragraph">
<p><code>*</code> 和 <code>/</code> 运算符是乘法和除法运算符。必要时, 它们的操作数会被转换为数字类型。请看下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 * 20;
say "10" * "20";</code></pre>
</div>
</div>
<div class="paragraph">
<p>两行代码均打印 200。尽管在第一行中, 乘法运算符的操作数都是数字(更准确地说, 是 Int 类型)。在第二行中, 我们试图对包含数字的字符串进行乘法运算。Raku 为我们转换了字符串, 使其成为数字, 然后 <code>*</code> 运算符完成了乘法工作。</p>
</div>
<div class="paragraph">
<p><code>*</code> 和 <code>/</code> 运算符也适用于浮点数和复数(因为 <code>Num</code> 和 <code>Complex</code> 类型都实现了 <code>Numeric</code> 角色):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say pi * e;             # 8.53973422267357
say (10+3i) * (2-3.3i); # 29.9-27i</code></pre>
</div>
</div>
<div class="paragraph">
<p>如前面的例子所示, 复数相乘时要注意。为了得到正确的结果, 你应该把复数的各部分用括号括起来。如果你省略了它们, 编译器将解释这个表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 + 3i * 2 - 3.3i; # 10+2.7i</code></pre>
</div>
</div>
<div class="paragraph">
<p>解释为如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 + (3i * 2) - 3.3i;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在算术表达式中, <code>*</code> 和 <code>/</code> 的优先级高于 <code>+</code> 和 <code>-</code> , 因此所有的计算都是根据算术规则的顺序进行的。考虑以下代码块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 + 3 * 6.3 - 3; # 25.9</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你将两个整数值相除, 那么结果是 <code>Rat</code> 类型, 而不是 <code>Num</code> 类型。要得到 <code>Num</code> 值, 至少有一个操作数必须是 <code>Num</code>, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1 / 2).WHAT;
say (1 / 2.3).WHAT;

say (1e1 / 2.3).WHAT;
say (1e1 / 2.3e-2).WHAT; # Num
say (1 / 2.3e-2).WHAT;   # Num</code></pre>
</div>
</div>
<div class="paragraph">
<p>在非 ASCII 空间中, <code>*</code> 和 <code>/</code> 运算符具有等价的记法; 你可以使用 <code>×</code> 和 <code>÷</code> 符号来代替:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 100;
my $b = 25;
say $a × $b; # 2500
say $a ÷ $b; # 4</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_加法和减法运算符">加法和减法运算符</h5>
<div class="paragraph">
<p><code>+</code> 和 <code>-</code> 运算符是加法和减法运算符。操作数必须是数字类型。</p>
</div>
<div class="paragraph">
<p>关于这些运算符, 没有什么好说的; 他们的行为是不言自明的, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 10;
say $a + 3;  # 13

my $b = 20;
say $b - $a; # 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果与 <code>*</code> 和 <code>/</code> 等组合, 则 <code>+</code> 和 <code>-</code> 运算符的优先级较低, 因此适用标准的算术规则。</p>
</div>
<div class="paragraph">
<p>当可以将字符串转换为数字(整数或浮点数)时, 编译器将进行转换, 并且 <code>+</code> 和 <code>-</code> 运算符将使用两个数字作为操作数。请看下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = "42";
say $str - 2; # 40</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于这些运算符希望它们的参数是数字型的, 你不能使用 <code>+</code> 运算符来连接字符串。天真的将两个字符串相加所引发的异常将被编译器捕获。以下面的代码为例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str1 = "Hello";
my $str2 = "World";
say $str1 + $str2; # Error</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你编译这段代码, 则会得到一个运行时错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏Hello' (indicated by ⏏)
     in block &lt;unit&gt; at add-str.pl line 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, 即使字符串以数字开头, 也不会发生字符串转换, 例如, 字符串 "10 Hello" 导致另一个错误信息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot convert string to number: trailing characters after number in '10⏏&lt; Hello' (indicated by ⏏)</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了正确地转换为数字类型, 字符串必须包含一个数字, 而不包含其它内容。虽然允许使用空格, 但如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str1 = " 10 ";
my $str2 = " 20 ";
say $str1 + $str2; # 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>要连接字符串, 请使用 <code>~</code> 运算符。</p>
</div>
<div class="paragraph">
<p>可以使用 Unicode 减号来代替 <code>-</code> 运算符。在终端上可能没有太大的视觉差异, 但字符的代码点是不同的-这里的 <code>0x2D</code> - 你可以从键盘输入 Unicode MINUS SIGN: 0x2212:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 20;
my $b = 30;

say $a - $b; # ASCII
say $a − $b; # Unicode</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_取模运算符">取模运算符</h5>
<div class="paragraph">
<p><code>%</code> 是模运算符。它返回其操作数除法的余数, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 100 % 3; # 1
say 10 % 3;  # 1
say 5 % 3;   # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>模运算 <code>$a % `$b</code> 的结果相当于下面这个冗长的表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$a - $b * floor($a / $b);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里, <code>floor</code> 是将值向下舍入的函数。以前面的一个例子 - <code>10 % 3</code> 为例。它的结果意味着 3 可以从 10 中减去几次, 直到剩下1, 1 小于 3, 因此不能再减。</p>
</div>
<div class="paragraph">
<p>传统上, 模运算符用于整数操作数, 但它仍然可以用于有理数和浮点数。这些类型的值可以被 <code>%</code> 运算符接受, 而不需要类型转换。我们来看看下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 % 3.3;   # 0.1 (Rat numbers)
say 10E1 % 3E0; # 1 (same as 100 % 3 but with Num operands)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_整除运算符">整除运算符</h5>
<div class="paragraph">
<p>运算符 <code>%%</code> 被称为整除运算符。它告诉我们左操作数是否可以被右操作数整除而没有余数。</p>
</div>
<div class="paragraph">
<p>例如, 10 除以 3 的整除, 余数为 1, 因此, <code>%%</code> 运算符将返回 <code>false</code>。如果将 12 除以 3, 则没有余数, 结果为真, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 %% 3; # False
say 12 %% 3; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$a %% $b</code> 的结果与下面的比较相同:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">($a % $b) == 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>它可以用来检查循环中的条件, 我们将在第五章《控制流》中更详细地了解循环。例如, 想要每 1000 次迭代打印一次消息, 可以写下面一段代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (0 .. 100_000) {
    say $_ if $_ %% 1000;
    # do some work
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它可以打印 1000、2000、3000 等, 这样可以看到程序的进度, 但不会让输出的数字过多。</p>
</div>
</div>
<div class="sect4">
<h5 id="_整除和模运算符">整除和模运算符</h5>
<div class="paragraph">
<p>这对运算符, <code>div</code> 和 <code>mod</code>, 是对 <code>/</code> 和 <code>%</code> 运算符的整数模拟。 <code>div</code> 和 <code>mod</code> 运算符把它们的操作数当作 <code>Int</code> 值, 结果也是一个整数。</p>
</div>
<div class="paragraph">
<p>我们来看看几个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 100 div 3; # 33
say 10 div 3;  # 3
say 10 div 5;  # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>mod</code> 运算符返回整除的余数, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 mod 3; # 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>在将非整数操作数传递给 <code>div</code> 和 <code>mod</code> 运算符之前, 必须明确地进行转换。否则, 就会出现编译时错误, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku -e'say 10 div 3.3'
Cannot resolve caller infix:&lt;div&gt;(Int, Rat); none of these signatures
match:
  (Int:D a, Int:D b)
  (int $a, int $b --&gt; int)
  in block &lt;unit&gt; at -e line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>该错误消息告诉我们, 编译器看到 <code>div</code> 运算符需要一个 <code>Int</code> 和 <code>Rat</code> 操作数, 而它只期望在那里看到 <code>Int</code> 或 <code>int</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_按位运算符">按位运算符</h5>
<div class="paragraph">
<p>以加号开头的三个运算符, 即 <code>+&amp;</code>, <code>+|</code> 和 <code>+^</code>, 是位运算符, 对操作数进行 AND、OR 和 XOR 运算。操作数必须可以转换为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1024 +| 512; # 1536
say 512 +| 512;  # 512

say 1024 +&amp; 512; # 0
say 512 +&amp; 512;  # 512

say 1024 +^ 512; # 1536
say 512 +^ 512;  # 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>在操作数的相应位上独立地进行位运算。</p>
</div>
<div class="paragraph">
<p>如果操作数不是整数, 则通过调用 <code>.Numeric.Int</code> 方法将它们转换为整数。因此, 首先, 操作数被转换为 <code>Numeric</code> 值, 然后再转换为 <code>Int</code> 值。从实际角度来看, 这意味着, 浮点值将被截断。下面的例子与前面的例子进行了比较:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 512.67 +| 512;  # 512
say 512.67 +&amp; 512;  # 512</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_整数移位运算符">整数移位运算符</h5>
<div class="paragraph">
<p><code>+&lt;</code> 和 <code>+&gt;</code> 运算符是整数移位运算符。他们将其整数操作数的位按第二个操作数所指示的距离向左和向右移动。考虑以下代码行作为例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 512 +&lt; 2;  # 2048
say 2048 +&gt; 2; # 512</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_字符串逻辑运算符">字符串逻辑运算符</h5>
<div class="paragraph">
<p>这些运算符是对字符串的逻辑运算符。他们以 <code>~</code> 字符开头, 遵循字符串操作使用波浪线的一般思想。<code><sub>&amp;</code>、<code></sub>|</code> 和 <code>~^</code> 运算符分别进行 AND、OR 和 XOR 运算。</p>
</div>
<div class="paragraph">
<p>在进行位运算之前, 两个操作数都要转换为字符串表示形式(如有必要)。然后, 在相应的位上执行操作。</p>
</div>
<div class="paragraph">
<p>让我们考虑一个如何使 ASCII 字母字符变为小写的例子。在 ASCII 中, 小写字母和大写字母之间的代码差值是 32(十六进制记法的 <code>0x20</code>)。所以, 要使字母小写, 就要对其执行 <code>~|</code> 操作, <code>0x20</code> 即空格的代码, 将第五位设置为 1:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'A' ~| ' '; # a</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>~^</code> 运算符, 你可以组织行为来改变大小写, 如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'a' ~^ ' '; # A
say 'A' ~^ ' '; # a</code></pre>
</div>
</div>
<div class="paragraph">
<p>在实际操作中, 最好避免使用 ASCII 码位的技巧。</p>
</div>
</div>
<div class="sect4">
<h5 id="_布尔逻辑运算符">布尔逻辑运算符</h5>
<div class="paragraph">
<p>这些运算符是布尔值的 AND、OR 和 XOR 运算符。下面的代码示例列出了操作数的所有可能组合的整个表格:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say True ?| True;   # True
say True ?| False;  # True
say False ?| True;  # True
say False ?| False; # False

say True ?&amp; True;   # True
say True ?&amp; False;  # False
say False ?&amp; True;  # False
say False ?&amp; False; # False

say True ?^ True;   # False
say True ?^ False;  # True
say False ?^ True;  # True
say False ?^ False; # False</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_最大公约数和最小公倍数运算符">最大公约数和最小公倍数运算符</h5>
<div class="paragraph">
<p><code>gcd</code> 和 <code>lcm</code> 运算符计算给定两个数的最大公约数和最小公倍数。这些运算符通常不包含在许多其他语言内置的运算符列表中。然而, 在 Raku 中, 你不需要包含任何库就可以使用它们。考虑以下使用 <code>gcd</code> 和 <code>lcm</code> 运算符的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 20;
my $b = 30;

say $a gcd $b; # Prints 10
say $a lcm $b; # Prints 60</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, 语法要求 <code>gcd</code> 和 <code>lcm</code> 名称都作为运算符使用, 而不是作为函数使用。下面的代码是不正确的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say gcd($a, $b);
say lcm($a, $b);</code></pre>
</div>
</div>
<div class="paragraph">
<p>它会产生编译错误, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">===SORRY!=== Error while compiling
/Users/ash/Books/Packt/code/operators/gcd.pl
Undeclared routines:
  gcd used at line 4
  lcm used at line 5. Did you mean 'lc'?</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于素数, <code>lcm</code> 运算符返回 1, 因为没有其它的除数, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 17 gcd 31; # 1</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>lcm</code> 运算符返回的数等于其操作数中素数的乘积, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 17 lcm 31; # 527</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然, 对于其它数字来说, 情况并非如此。请看下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 20 lcm 40; # 40</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_字符串重复运算符">字符串重复运算符</h5>
<div class="paragraph">
<p><code>x</code> 二元运算符是字符串重复运算符。它重复一个字符串给定的次数, 如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = 'Developers ';
say $string x 5;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码将包含 <code>$string</code> 变量初始值的字符串打印了五次。 很明显, 原始值没有改变。</p>
</div>
<div class="paragraph">
<p>要修改字符串并将结果保存在同一个变量中, 请使用运算符的赋值形式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$string x= 2;
say $string;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, <code>$string</code> 值的长度是之前的两倍。</p>
</div>
</div>
<div class="sect4">
<h5 id="_列表重复运算符">列表重复运算符</h5>
<div class="paragraph">
<p>运算符 <code>xx</code> 是列表重复运算符。它在视觉上和意识形态上都与 <code>x</code> 运算符相似, 但它适用于列表。请看下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @data = (10, 20);
my @big_data = @data xx 100;
say @big_data;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里, <code>@data</code> 数组将重复 100 次, <code>@big_data</code> 变量将包含 100 份。</p>
</div>
<div class="paragraph">
<p>小心不要把 <code>xx</code> 和 <code>x</code> 运算符混在一起。如果你使用 <code>x</code> 而不是 <code>xx</code>, 那么编译器不会警告你, 而是将参数视为字符串, 并执行字符串连接, 而不是重复一个数组。</p>
</div>
</div>
<div class="sect4">
<h5 id="_字符串连接运算符">字符串连接运算符</h5>
<div class="paragraph">
<p><code>~</code> 运算符将两个字符串连接起来, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'a' ~ 'b'; # ab</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果操作数不是字符串, 则在操作前将其转换为字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 ~ 20;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将打印 <code>1020</code> 字符串。</p>
</div>
<div class="paragraph">
<p>具有赋值形式的 <code>~</code> 在某些应用程序中也很有用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = 'Hello, ';
$string ~= 'World!';
say $string; # Hello, World!</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_junction_运算符">junction 运算符</h5>
<div class="paragraph">
<p>这三个运算符创建了 junction。我们已经见过最简单的 junction 形式, 即在保存变量中同时有多个值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $odd = 1 | 3 | 5 | 7 | 9;
my $value = 5;
say 'Value is odd' if $value == $odd;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码打印出 <code>Value is odd</code>, 因为 <code>$value</code> 变量中的值是 <code>$odd</code> junction 的其中之一。运算符 <code>|</code> 创建一个所谓的<strong>any junction</strong>。</p>
</div>
<div class="paragraph">
<p>运算符 <code>&amp;</code> 创建了一个 <strong>all junction</strong>, 其中所有的值必须是非空的。请看下面的代码片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 3;
my $b = 4;

my $both = $a &amp; $b;
say 'ok' if $both; # ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后, <code>^</code> 运算符创建了一个 <strong>one junction</strong>, 其中只有一个操作数必须被计算为真。请看下面的代码片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = 'OK';
my $d = '';

my $one = $c ^ $d;
say 'ok' if $one; # ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>重要的是, 使用 <code>any</code>, <code>all</code> 和 <code>one</code> 中的任一运算符创建的值都是 junction; 你可以通过调用 <code>WHAT</code> 方法来查看它们的类型, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $one.WHAT; # (Junction)</code></pre>
</div>
</div>
<div class="paragraph">
<p>不要将 <code>&amp;</code>, <code>|</code> 和 <code>^</code> 运算符与布尔运算符 - <code>&amp;&amp;</code>, <code>||</code> 和 <code>^^</code> 混淆。</p>
</div>
</div>
<div class="sect4">
<h5 id="_does_运算符">does 运算符</h5>
<div class="paragraph">
<p><code>does</code> 运算符将一个角色混入到一个对象中。我们将在第八章《面向对象编程》中讨论混入的问题。总之, 请看一个简单的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Animal {}
role Barking {
    method bark() {
        say "Bow-wow!";
    }
}

my $dog = Animal.new();
$dog does Barking;
$dog.bark();</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里, 首先将 <code>$dog</code> 变量创建为 <code>Animal</code> 类的一个实例。然后, 将 <code>Barking</code> 角色的行为附加到 <code>$dog</code> 实例上。之后, <code>$dog</code> 变量可以 <code>bark()</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_but_运算符">but 运算符</h5>
<div class="paragraph">
<p><code>but</code> 运算符将一个角色混入一个对象, 类似于 <code>does</code> 运算符的做法。<code>but</code> 运算符不会修改对象本身, 总是返回一个新的对象。此外, <code>but</code> 还允许我们使用已经实例化的对象, 如下面的例子所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $value = 0 but True;
say 'It is true' if $value;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在 <code>$value</code> 在布尔上下文中变为 <code>True</code>, 而它仍然包含纯零值。</p>
</div>
<div class="paragraph">
<p>在角色混合的情况下, 同一个对象开始表现为属于不同类型的对象的行为, 这视情况而定。请看下面的代码片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Barking {
    method bark() {
        say "Bow-wow!";
    }
}

my $dog = 14 but Barking;
say $dog;    # 14
$dog.bark(); # Bow-wow!</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$dog</code> 变量被打印成它的数值, 但也可以对它调用 <code>bark</code> 方法。</p>
</div>
<div class="paragraph">
<p>内省后发现, 现在的变量是两者的组合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $dog.WHAT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此命令打印出 <code>(Int+{Barking})</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_通用比较运算符">通用比较运算符</h5>
<div class="paragraph">
<p><code>cmp</code> 是一个通用的比较运算符。它的通用性允许比较数字和字符串数据。请看下面的代码片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 cmp 2;     # 2 is less than 10
say "10" cmp "2"; # but "2" is more than "10"</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Order</code> 枚举的三个可能值之一的返回值是 <code>Less</code>、<code>Same</code> 或 <code>More</code>。前面的程序打印了以下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">More
Less</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果操作数的类型不同, 则按以下方式转换为同一类型:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 5 cmp "5"; # Same</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你用 <code>cmp</code> 比较对儿时,它们的比较方式是先比较键, 再比较值。请看下面的例子, 我们创建了三个不同的键和值的对儿, 并以不同的组合进行比较:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = alpha =&gt; '2';
my $b = beta =&gt; '1';
my $c = alpha =&gt; '1';

say $a cmp $b; # Less
say $a cmp $c; # More</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>$a cmp $b</code> 的情况下, 它们的键是可以按字母顺序排序的, 而值则不重要。在 <code>$a cmp $c</code> 的情况下, 两个键都是相等的, 所以每对键的值也被检查。</p>
</div>
</div>
<div class="sect4">
<h5 id="_字符串比较运算符_leg">字符串比较运算符 leg</h5>
<div class="paragraph">
<p><code>leg</code> 运算符的名字来自于单词 <strong>less</strong>、<strong>equal</strong> 和 <strong>greater</strong>。它将两个操作数作为字符串进行比较。如果值不是字符串, 则先将其字符串化。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 leg 2;     # Less
say "10" leg "2"; # Less
say 5 leg "5";    # Same</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果是 <code>Order</code> 枚举的其中一个值(注意, 尽管运算符名字里有e, 但操作数的相等性返回 <code>Same</code> 值)。</p>
</div>
</div>
<div class="sect4">
<h5 id="_实数比较运算符">实数比较运算符</h5>
<div class="paragraph">
<p>这是一个比较运算符, 必​​要时可以将其操作数转换为 <code>Real</code> 类型。下面的例子演示了我们用 <code>cmp</code> 和 <code>leg</code> 运算符对相同数据进行比较的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 &lt;=&gt; 2;     # More
say "10" &lt;=&gt; "2"; # More
say 5 &lt;=&gt; "5";    # Same</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_范围创建运算符">范围创建运算符</h5>
<div class="paragraph">
<p>这组二元运算符用于创建范围。两个操作数定义了范围的左右边界。<code>^</code> 字符的存在表明了相应的边界是开放的; 因此, 它不包括给定的数字。</p>
</div>
<div class="paragraph">
<p>运行下面的例子来看看它是如何工作的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for 1 .. 5;   # prints the numbers: 1, 2, 3, 4, 5
.say for 1 ..^ 5;  # 1, 2, 3, 4
.say for 1 ^.. 5;  # 2, 3, 4, 5
.say for 1 ^..^ 5; # 2, 3, 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以根据范围运算符周围的空格选择自己的风格。因此, <code>1&#8230;&#8203;^5</code> 和 <code>1 ..^ 5</code> 都是可以接受的。但是, 不可能在运算符的字符之间插入空格, 例如 <code>1 . . ^5</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_相等和不相等运算符">相等和不相等运算符</h5>
<div class="paragraph">
<p>两个运算符 <code>==</code> 和 <code>!=</code> 比较两个操作数是否是数值相等的。在 Raku 中, 定义了这些运算符的一些变体, 以便它们能够正确地处理不同类型的操作数, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Equal' if 10 == 10;
say 'Not equal' if 3.14 != pi;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要, 两个操作数都要先转换为 <code>Numeric</code> 值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Also equal' if "10" == 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>!=</code> 运算符有一个 Unicode 同义词 - <code>≠</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Not equal' if e ≠ pi;</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为一个有趣的例子, 你也可以测试 <code>!≠</code> 运算符, 它的构造类似于 <code>!=</code> 运算符的组合方式 - 感叹号否定下一个字符。这在 Raku 中是可行的, 但在实践中要避免使用它; 应使用传统的 <code>==</code> 来代替。</p>
</div>
<div class="paragraph">
<p>要比较字符串, 可以使用本章后面介绍的 <code>eq</code> 和 <code>ne</code> 运算符。</p>
</div>
</div>
<div class="sect4">
<h5 id="_数值比较运算符">数值比较运算符</h5>
<div class="paragraph">
<p><code>&lt;</code>, <code>&#8656;</code>, <code>≤</code>, <code>&gt;</code>, <code>&gt;=</code> 和 <code>≥</code> 运算符集用于两个操作数的数值比较。如果操作数不是数值, 则将其转换为 <code>Real</code>。看一下下面的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 &lt; 2;
say "10" &lt; "2";</code></pre>
</div>
</div>
<div class="paragraph">
<p>在本例中的两种情况下, 比较的结果都是 <code>False</code>。</p>
</div>
<div class="paragraph">
<p>两个 Unicode 运算符 <code>≤</code> 和 <code>≥</code> 是 <code>&#8656;</code> 和 <code>&gt;=</code> ASCII 形式的同义词, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 ≤ 10; # True
say 20 ≥ 10; # True</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_字符串比较运算符_eq_和_ne">字符串比较运算符 eq 和 ne</h5>
<div class="paragraph">
<p><code>eq</code> 和 <code>ne</code> 运算符比较两个字符串并返回一个布尔值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'abc' eq 'abc'; # True
say 'abc' ne 'def'; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>非字符串操作数在比较前被转换为字符串, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 13 eq '13'; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>要比较数字, 请使用 <code>==</code> 和 <code>!=</code> 运算符。</p>
</div>
</div>
<div class="sect4">
<h5 id="_其他字符串比较运算符">其他字符串比较运算符</h5>
<div class="paragraph">
<p>这个字符串比较运算符的集合分别执行 <strong>greater</strong>(gt), <strong>greater or equal(ge)</strong>, <strong>later(lt)</strong> 和 <strong>less or equal</strong> 操作。这些运算符的工作对象是字符串, 所以必要时操作数会被转换为 <code>Str</code> 类型。返回值是一个布尔值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'a' lt 'b';
say 'beer' le 'water';

say 'z' gt 'x';
say 'stone' ge 'paper';</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面所有的例子中, 结果都是 <code>True</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_before_和_after_运算符">before 和 after 运算符</h5>
<div class="paragraph">
<p>根据操作数的顺序, <code>before</code> 和 <code>after</code> 运算符返回 <code>True</code> 或 <code>False</code>。在 Raku 中, 这些运算符是存在于不同类型参数的 multi 函数。它们可以很好地处理数字和字符串数据。</p>
</div>
<div class="paragraph">
<p>让我们来看看这些例子, 比较字符串和数字会得到相反的结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 before 2; # False
say 10 after 2;  # True

say "10" before "2"; # True
say "10" after "2";  # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>与一般的比较 <code>cmp</code> 运算符不同, <code>before</code> 和 <code>after</code> 排序运算符返回一个布尔值。</p>
</div>
</div>
<div class="sect4">
<h5 id="_相等性测试运算符">相等性测试运算符</h5>
<div class="paragraph">
<p><code>eqv</code> 运算符测试两个操作数是否相等。该术语假定两个操作数的类型相同, 并包含相同的值。下面的例子展示了该运算符的工作原理。</p>
</div>
<div class="paragraph">
<p>两个整数值是等价的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;
my $b = 42;
say $a eqv $b; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果其中一个值是另一种类型, 比如说是字符串, 那么结果就是 <code>False</code>, 即使这个值可以转换为相同的整数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;
my $c = "42";
say $a eqv $c; # False</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>eqv</code> 运算符适用于数组, 如以下代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 2, 3;
say @a eqv [1, 2, 3]; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>而且, 对于更复杂的数据结构, 比如, 嵌套的数组。考虑以下代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @b = [[1, 3], [2, 4]];
say @b eqv [[1, 3], [2, 4]]; # True</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_值恒等运算符">值恒等运算符</h5>
<div class="paragraph">
<p><code>===</code> 运算符是值恒等运算符。对于标量值, 它给出的结果与 <code>eqv</code> 运算符相同的结果 - 当操作数的类型和值都相同时, 它就会返回真, 正如你在这里看到的那样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;
my $b = 42;
say $a === $b; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是另一个使用字符串和整数的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;
my $c = "42";
say $a === $c; # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于类来说, 如果两个操作数都指向同一个对象, 则 <code>===</code> 运算符返回 <code>True</code>, 如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class O {
}

my $o1 = O.new();
my $o2 = O.new();
say $o1 === $o2; # False: same class but different objects

my $o3 = $o1;
say $o1 === $o3; # True: the same object</code></pre>
</div>
</div>
<div class="paragraph">
<p>更多关于类的内容请参见第八章《面向对象编程》。</p>
</div>
</div>
<div class="sect4">
<h5 id="_绑定检查运算符">绑定检查运算符</h5>
<div class="paragraph">
<p>如果两个操作数都绑定在同一个变量上, 或者更准确地说, 绑定到同一个容器上, 那么绑定检查运算符返回真。</p>
</div>
<div class="paragraph">
<p>在 Raku 中, 绑定意味着另一个变量指向同一个容器, 你可以用两个名字来改变它的值。下面的例子就说明了这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;
my $b := $a;
$b = 30;
say $a; # 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, 使用 <code>$b</code> 别名来更改放在 <code>$a</code> 变量中的值。对于这样的名字, <code>=:=</code> 运算符返回真:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $a =:= $b; # True</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_智能匹配运算符">智能匹配运算符</h5>
<div class="paragraph">
<p><code>~~</code> 运算符是智能匹配运算符。它对不同类型的操作数进行不同类型的比较。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $int = 10;
say $int ~~ 10; # True

my $str = 'str';
say $str ~~ 'str'; # True

say $str ~~ /^ str $/; # ⌈str⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>从这个测试程序的输出可以看出, <code>~~</code> 运算符的结果并不总是布尔值。</p>
</div>
<div class="paragraph">
<p>在内部, 用智能匹配运算符构造的 <code>$a ~~ $b</code> 相当于调用 <code>$b.ACCEPTS($a)</code>。<code>ACCEPTS</code> 方法是 Raku 中为所有类型定义的内置方法。前面的三个智能匹配操作可以用下面的方式重写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10.ACCEPTS($int);
say 'str'.ACCEPTS($str);
say /^str$/.ACCEPTS($str);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_近似相等运算符">4.2.2. 近似相等运算符</h4>
<div class="paragraph">
<p>这是编程语言中最不寻常的运算符之一。在 Raku 中, <code>=~=</code> 运算符比较近似相等的值。</p>
</div>
<div class="paragraph">
<p>如果操作数之间的差值小于 <code>$*TOLERANCE</code> 变量的值, 则近似比较的结果为 <code>True</code>。它的默认值为 <code>1E-15</code>。</p>
</div>
<div class="paragraph">
<p>让我们来看看 pi 值的两个近似值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say pi =~= 3.14159265358979323846;
say pi =~= 3.14;</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个返回 <code>True</code>, 而第二个返回 <code>False</code>, 因为它不够准确。</p>
</div>
<div class="sect4">
<h5 id="_布尔逻辑运算符_2">布尔逻辑运算符</h5>
<div class="paragraph">
<p>这些运算符是布尔逻辑运算符, 执行 AND、OR 和异或 OR 等操作。</p>
</div>
<div class="paragraph">
<p>对于布尔操作数, 结果要么是 <code>True</code>, 要么是 <code>False</code>, 唯一的例外是 <code>True ^^ True</code> 表达式, 它返回的是 <code>Nil</code>。</p>
</div>
<div class="paragraph">
<p>下面的一组例子展示了布尔操作数的所有可能组合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say False &amp;&amp; False; # False
say True  &amp;&amp; True;  # True
say True  &amp;&amp; False; # False
say False &amp;&amp; True;  # False

say False || False; # False
say True  || True;  # True
say True  || False; # True
say False || True;  # True

say False ^^ False; # False
say True  ^^ True;  # Nil
say True  ^^ False; # True
say False ^^ True;  # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于其他类型的操作数, 它们要么返回一个布尔值, 要么返回操作数之一。让我们逐一研究一下这些运算符。</p>
</div>
<div class="paragraph">
<p>运算符 <code>&amp;&amp;</code> 返回第一个操作数, 在布尔上下文中, 它可以被当作一个 <code>False</code> 值, 如果布尔上下文中的所有操作数都是 <code>True</code>, 则返回最后一个操作数。例如, <code>42 &amp;&amp; 14</code> 表达式的结果是 14。这里, 两个操作数都是 <code>True</code>, 因此, 运算后返回第二个操作数。</p>
</div>
<div class="paragraph">
<p>考虑这些例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 42 &amp;&amp; 14;          # 14
say 0 &amp;&amp; 14;           # 0
say 'Karl' &amp;&amp; 'Marta'; # Marta

my $text;
say $text &amp;&amp; 'default text'; # (Any)
say 'default text' &amp;&amp; $text; # (Any)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>0 &amp;&amp; 14</code> 表达式中, 第一个操作数是 <code>False</code>, 所以 <code>&amp;&amp;</code> 运算符立即返回, 而不计算第二个操作数。第二个表达式有两个操作数都是 True; 因此, 结果是 <code>Marta</code>。最后, 在最后两个表达式中返回一个未定义的字符串。</p>
</div>
<div class="paragraph">
<p>同样, <code>||</code> 运算符返回第一个为 <code>True</code> 的操作数。如果所有操作数恰好都是 <code>False</code>, 则返回最后一个操作数。让我们来看看下面的例子, 它们使用的操作数与我们在前面测试 <code>&amp;&amp;</code> 运算符时使用的操作数相同:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 42 || 14;          # 42
say 0 || 14;           # 14
say 'Karl' || 'Marta'; # Karl

my $text;
say $text || 'default text'; # default text
say 'default text' || $text; # default text</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于非布尔操作数的 <code>^^</code> 运算符的逻辑有点棘手。如果只有一个 True 操作数, 那么就返回这个操作数。如果没有, 则返回最后一个操作数。如果有一个以上的 True 操作数, 则返回 <code>Nil</code> 值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 42 ^^ 14;          # Nil
say 0 ^^ 14;           # 14
say 'Karl' ^^ 'Marta'; # Nil

my $text;
say $text ^^ 'default text'; # default text
say 'default text' ^^ $text; # default text</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有的树状运算符都可以被链接起来使用, 例如, 选择第一个可接受的值或取默认值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = '';
my $first_name = '';
say $name || $first_name || 'No name'; # No name</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些运算符具有短路语义, 当数值确定时, 应该停止计算操作数。</p>
</div>
</div>
<div class="sect4">
<h5 id="_defined_or_运算符">Defined-or 运算符</h5>
<div class="paragraph">
<p><code>//</code> 运算符被称为 <code>defined-or</code> 运算符。它返回定义的第一个操作数。<code>//</code> 最明显的用例是为输入数据提供默认值, 如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $planet;

# Some code that may change the value of $planet.
# $planet = 'Mars';

say $planet // 'Earth';</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>//</code> 运算符也是短路运算符。</p>
</div>
</div>
<div class="sect4">
<h5 id="_minimum_和_maximum_运算符">minimum 和 maximum 运算符</h5>
<div class="paragraph">
<p><code>min</code> 和 <code>max</code> 运算符分别返回最小或最大操作数。 为了比较这些值, 这两个运算符使用了与 <code>cmp</code> 运算符相同的语义。请看下面的代码片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 min 2;     # 2
say "10" min "2"; # 10

say 10 max 2;     # 10
say "10" max "2"; # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, 在 Raku 中, 有 <code>min</code> 和 <code>max</code> 函数可以做相同的事情, 但使用的是函数调用语法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say min(2, 10); # 2
say max(2, 10); # 10

say min("2", "10"); # 10
say max("2", "10"); # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>运算符和函数都可用来查找两个以上的最小值和最大值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 min 20 min 30; # 10
say max(10, 20, 30);  # 30</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_pair_创建运算符">pair 创建运算符</h5>
<div class="paragraph">
<p><code>&#8658;</code> 运算符创建对。它将左操作数作为键, 右操作数作为值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pair = 'key' =&gt; 'value';</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建的对象的类型是 <code>Pair</code>。</p>
</div>
<div class="paragraph">
<p>在使用 <code>&#8658;</code> 运算符时, 如果键通过了 Raku 中对标识符的限制, 则可以不加引号。请看下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pair1 = alpha =&gt; 1;
my $pair2 = beta =&gt; 2;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_逗号运算符">逗号运算符</h5>
<div class="paragraph">
<p>逗号为提供的操作数创建一个列表。在下面的例子中, 这个列表被保存在数组变量中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 10;
my $b = 20;
my $c = 30;

my @a = $a, $b, $c;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_调用分隔符">调用分隔符</h5>
<div class="paragraph">
<p><code>:</code> 运算符看起来不像普通的中缀运算符。它是在方法调用中用来分隔调用者参数的。这个调用中的方法调用看起来就像一个普通函数的调用。让我们在一个简单的例子中看到这一点。</p>
</div>
<div class="paragraph">
<p>首先, 我们将调用 <code>$string</code> 上的 <code>index</code> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = 'Hello, World!';
my $pos = $string.index('W');
say $pos; # 7</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样的效果可以通过以下几行代码来实现:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pos = index($string: 'W');
say $pos; # 7</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你所看到的, $string变量是作为索引例程的第一个参数传递的, 并且与第二个参数之间用冒号分开。</p>
</div>
</div>
<div class="sect4">
<h5 id="_zip_运算符">zip 运算符</h5>
<div class="paragraph">
<p><code>Z</code> 运算符的工作原理就像一个拉链, 从给定的两个数组中创建一个新的数组。新数组中的元素是由操作数中的元素拾取的, 因为拉链连接了它的项。</p>
</div>
<div class="paragraph">
<p><code>Z</code> 运算符的行为可以在下面的例子中清楚地看到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @odd = 1, 3, 5, 7, 9;
my @even = 2, 4, 6, 8, 10;
my @all = @odd Z @even;
say @all;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序打印以下列表, 其中包含基于@odd和@even两个数组中元素的嵌套列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">[(1 2) (3 4) (5 6) (7 8) (9 10)]</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果其中一个数组操作数的长度不同, <code>Z</code> 运算符的结果将包含与最短操作数相同的元素。</p>
</div>
</div>
<div class="sect4">
<h5 id="_交叉运算符">交叉运算符</h5>
<div class="paragraph">
<p>交叉运算符 <code>X</code> 创建其操作数元素的所有可能组合。比较这个运算符在我们在 <code>Z</code> 运算符的例子中使用的相同数据上的工作情况。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @odd = 1, 3, 5, 7, 9;
my @even = 2, 4, 6, 8, 10;
my @all = @odd X @even;
say @all;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次, 产生的数组要大得多, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[(1 2) (1 4) (1 6) (1 8) (1 10) (3 2) (3 4) (3 6) (3 8) (3 10) (5 2) (5 4)
(5 6) (5 8) (5 10) (7 2) (7 4) (7 6) (7 8) (7 10) (9 2) (9 4) (9 6) (9 8)
(9 10)]</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_序列运算符">序列运算符</h5>
<div class="paragraph">
<p>作为一个中缀运算符, 这三个点就是序列运算符。Raku 包含了一些内置的魔法, 可以实现你的意思。让我们来看看几个使用 <code>&#8230;&#8203;</code> 运算符的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 5 ... 10;
say 'a' ... 'f';</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的两行打印出以下序列:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">(5 6 7 8 9 10)
(a b c d e f)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&#8230;&#8203;</code> 操作的结果是一个序列。不要将这个运算符与创建范围的 <code>&#8230;&#8203;</code> 运算符混合使用。</p>
</div>
<div class="paragraph">
<p>如果你把结果分配给一个列表, 那么这两个运算符可以互换:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 5...10;
my @b = 5..10;
say @a; # [5 6 7 8 9 10]
say @b; # [5 6 7 8 9 10]</code></pre>
</div>
</div>
<div class="paragraph">
<p>序列运算符可以展示更复杂的行为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @squares = 1, 2, 4 ... 64;
say @squares;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中, 使用了模式, <code>&#8230;&#8203;</code> 运算符创建了平方序列。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">[1 2 4 8 16 32 64]</code></pre>
</div>
</div>
<div class="paragraph">
<p>序列运算符能理解算术和几何序列, 如下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1, 2 ... 10;    # Arithmetic
                    # (1 2 3 4 5 6 7 8 9 10)

say 1, 2, 4 ... 32; # Geometric
                    # (1 2 4 8 16 32)</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>&#8230;&#8203;</code> 运算符的另一个有趣的例子是通过用 Whatever(<code>*</code>)字符呈现公式来生成斐波那契数的方法, 正如你可以在这里看到的那样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @fib = 0, 1, * + * ... *;
say @fib[0..10];</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码创建了一个惰性列表 <code>@fib</code>, 其元素将按需计算。 前十个数字被打印出来, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">(0 1 1 2 3 5 8 13 21 34 55)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_绑定运算符">绑定运算符</h5>
<div class="paragraph">
<p>这两个运算符创建了绑定。绑定是同义词, 可以用来代替原来的变量名来访问它们的值。</p>
</div>
<div class="paragraph">
<p>我们在关于 <code>=:=</code> 运算符的章节中看到了使用 <code>:=</code> 运算符的例子。</p>
</div>
<div class="paragraph">
<p>第二种形式, <code>::=</code>, 创建一个只读绑定。目前, 它还没有在 Rakudo 中实现。</p>
</div>
</div>
<div class="sect4">
<h5 id="_优先级较低的逻辑运算符">优先级较低的逻辑运算符</h5>
<div class="paragraph">
<p><code>and</code> 和 <code>or</code> 这两个运算符在语义上等同于逻辑上的 <code>&amp;&amp;</code> 和 <code>||</code> 中缀运算符, 但优先级较低。</p>
</div>
<div class="paragraph">
<p>这些低优先级的运算符是特殊情况和错误断言的完美搭配, 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $value = prompt('Enter a small value&gt; ');
$value &lt; 10 or die 'Too big';
say 'OK, thanks';</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里, 只有当断言 <code>$value&lt;10</code> 失败时, 才会执行 <code>or</code> 的右侧。</p>
</div>
</div>
<div class="sect4">
<h5 id="_数据管道运算符">数据管道运算符</h5>
<div class="paragraph">
<p><code>=&#8658;</code> 和 <code>&#8656;=</code> 运算符传递值的方式与类 Unix 命令行 shell 中 <code>|</code> 管道运算符传递数据的方式类似。</p>
</div>
<div class="paragraph">
<p>请看下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = (10...0 ==&gt; grep {$_ &gt; 5} ==&gt; sort);
say @a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, <code>@a</code> 数组的创建有三个步骤：首先, 用 <code>&#8230;&#8203;</code> 运算符生成从 10 到 0 的序列, 然后将数值传递给 <code>grep</code> 函数, 选择 5 以上的数字。之后, 这些值进入 <code>sort</code> 方法。</p>
</div>
<div class="paragraph">
<p>这个程序的结果是一个 6 到 10 之间的整数的排序列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">[6 7 8 9 10]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&#8656;=</code> 运算符以相反的方向组织数据流:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @b = (sort() &lt;== grep {$_ &gt; 5} &lt;== 10...0);
say @b; # [6 7 8 9 10]</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, 在这种情况下, 排序调用后面的括号是必须的, 因为, 否则, Raku 编译器会试图将 <code>&#8656;=</code> 运算符的开头解释为 <code>&lt; &#8230;&#8203; &gt;</code> 列表的开口引号。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_三元运算符">4.2.3. 三元运算符 ?? !!</h4>
<div class="paragraph">
<p><code>?? !!</code> 运算符是 Raku 中唯一的三元运算符。它也被称为条件运算符。它需要三个操作数-一个条件和两个值。如果条件被计算为 True, 那么第二个操作数将作为操作的结果返回。否则, 将返回第三个操作数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say pi &lt; 3 ?? 'Less than 3' !! 'More than 3';</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中, <code>pi &lt; 3</code> 的条件是 False, 所以第二个字符串 <code>More than 3</code> 被打印出来。</p>
</div>
<div class="paragraph">
<p>三元运算符可以(小心地)用来测试一个以上的条件。请看下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $value = rand;
say $value;

say $value &lt; 0.3 ?? '0.0 to 0.3'
 !! $value &lt; 0.5 ?? '0.3 to 0.5'
 !! $value &lt; 0.7 ?? '0.5 to 0.7'
 !!                 '0.7 to 1.0';</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下, 代码的格式化应该有助于你理解开发者的想法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_前缀运算符">4.2.4. 前缀运算符</h4>
<div class="paragraph">
<p>Raku 中的下一组运算符是前缀运算符的集合。前缀运算符只需要一个操作数, 并且放在代码中的前面。</p>
</div>
<div class="sect4">
<h5 id="_自增和自减运算符_和">自增和自减运算符 ++ 和&#8201;&#8212;&#8201;</h5>
<div class="paragraph">
<p>这些是前缀运算符, 用来递增和递减数值。</p>
</div>
<div class="paragraph">
<p>这些运算符的前缀形式首先改变变量的值, 然后返回结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = 42;
++$n;
say $n;   # 43
say --$n; # 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中, <code>++</code> 和 <code>--</code> 运算符都具有后缀运算符的形式(参见本章后面的《后缀运算符》一节中的例子)。</p>
</div>
</div>
<div class="sect4">
<h5 id="_布尔转换运算符">布尔转换运算符</h5>
<div class="paragraph">
<p><code>?</code> 前缀运算符是布尔强制运算符。它将其操作数转换为一个布尔值。</p>
</div>
<div class="paragraph">
<p>该运算符的行为非常直接。让我们来看看下面的例子, 了解一下它的用法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ?4; # True
say ?0; # False

say ?'abc'; # True
say ?'';    # False

my $var = 'Hello, World!';
say ?$var; # True

my $undefined_var;
say ?$undefined_var; # False

my $empty_str = '';
say ?$empty_str; # False</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_布尔否定运算符">布尔否定运算符</h5>
<div class="paragraph">
<p><code>!</code> 前缀是布尔否定运算符。它将操作数的布尔值反转。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say !True; # False
say !'';   # True
say !0;    # True
say !42;   # False</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_数值转换运算符">数值转换运算符</h5>
<div class="paragraph">
<p><code>+</code> 前缀运算符将操作数转换为一个数值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say +True; # 1
say +42;   # 42
say +'42'; # 42

my $var = '42';
say +$var; # 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, 你不能使用 <code>+</code> 前缀运算符从一个包含额外字符的字符串中解析数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># my $text = '12 volts';
# say +$text;</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码会产生以下错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot convert string to number: trailing characters after number</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_数字否定运算符">数字否定运算符</h5>
<div class="paragraph">
<p><code>-</code> 前缀运算符否定其数值操作数。如果操作数不是数字, 则先将其转换为数字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $var = 42;
say -$var; # -42

say -"42"; # -42</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_字符转换运算符">字符转换运算符</h5>
<div class="paragraph">
<p><code>~</code> 运算符作为前缀运算符, 将操作数转换为字符串。对于简单的数据类型, 该运算符的作用是可以预测的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $var = 42;
my $str = ~$var;
say $str.WHAT; # (Str)</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于复杂的数据, 字符串转换可能会返回对象的地址:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class X { }
my $x = X.new;
say ~$x; # X<i class="conum" data-value="140372183360608"></i><b>(140372183360608)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>要改变这种默认行为, 你可能需要定义自己的转换器(我们将在第八章, 《面向对象编程》中讨论 gist 方法)。</p>
</div>
</div>
<div class="sect4">
<h5 id="_二元互补二元否定运算符">二元互补二元否定运算符</h5>
<div class="paragraph">
<p><code>+^</code> 运算符做操作数的二元互补二元否定, 先将操作数转换为整数值, 如下面的代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say +^42; # -43

my $neg = -42;
say +^$neg; # 41

say +^0;  # -1
say +^-1; # 0</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_布尔转换和否定运算符">布尔转换和否定运算符</h5>
<div class="paragraph">
<p><code>?^</code> 运算符将其操作数转换为布尔值并将其否定。其结果与简单的 <code>!</code> 前缀运算符的结果相同。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ?^True; # False
say ?^'';   # True
say ?^0;    # True
say ?^42;   # False</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_upto_运算符">upto 运算符</h5>
<div class="paragraph">
<p><code>^</code> 运算符被称为 <strong>upto</strong> 运算符。它创建了一个从0到操作数的整数值的范围:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ^5;

my $right = 5;
say ^$right;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的代码中, Raku 以 <code>^5</code> 的形式打印了范围。</p>
</div>
<div class="paragraph">
<p>让我们在循环中使用这个范围。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $_ for ^3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个单行程序打印出 0、1 和 2。因此, 范围不包括它的上边界。</p>
</div>
</div>
<div class="sect4">
<h5 id="_temp_运算符">temp 运算符</h5>
<div class="paragraph">
<p><code>temp</code> 运算符临时用一个新的值替换一个变量。请看下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $var = 1;

f(); # 1

{
    f(); # 1
    temp $var = 2;
    f(); # 2
}

f(); # 1

sub f() {
    say $var;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>f</code> 子程序打印全局变量 <code>$var</code> 的值。初始变量的值是 1, 因此, <code>f</code> 子程序的第一次调用打印的是 1。</p>
</div>
<div class="paragraph">
<p>然后, 我们在一对花括号之间有一个代码块。<code>f</code> 的第二次调用和之前一样使用 <code>$var</code> 的保存值。然后, 它的值被临时设置为 2, 所以, <code>f</code> 的第三次调用打印出 2。</p>
</div>
<div class="paragraph">
<p>从代码块中退出后, 临时值的范围结束, 恢复 <code>$var</code> 的原始值。所以, <code>f</code> 的第四次调用又打印出 1。<code>temp</code> 关键字与 <code>my</code> 关键字不同, 因为它没有创建一个局部变量。如果把代码改成使用 <code>my</code>, 那么 <code>f</code> 子程序仍然会使用全局变量 <code>$var</code>, 而全局变量是没有变化的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">...
{
    f(); # 1
    my $var = 2;
    f(); # 1
}
...</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_let_运算符">let 运算符</h5>
<div class="paragraph">
<p><code>let</code> 运算符为变量设置一个新的值。它的主要特点是, 如果代码块失败, 能够恢复原始值。</p>
</div>
<div class="paragraph">
<p>请看下面的例子。<code>$var</code> 变量在一对花括号之间的代码块内被设置为一个新的值。该变量在代码块结束后被打印出来。由于没有异常, 程序打印新值-<code>2</code>, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $var = 1;

{
    let $var = 2;
}

say $var; # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果这个块由于某种原因死掉了, 那么变量将保持原来的值。由 <code>die</code> 引起的异常, 会被 <code>CATCH</code> 块捕获。新的值, <code>2</code> 就会丢失, 程序打印出 <code>1</code>, 如你所见:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $var = 1;

try {
    let $var = 2;
    die;
}
CATCH {

}

say $var; # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你需要组织某种事务, 以确保所有的更改只在没有例外的情况下进行, 那么 <code>let</code> 运算符是非常方便的。</p>
</div>
</div>
<div class="sect4">
<h5 id="_not_运算符">not 运算符</h5>
<div class="paragraph">
<p>如果需要的话, <code>not</code> 运算符将其操作数转换为布尔型, 并否定其值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say not 42;    # False
say not False; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个运算符的优先级比 <code>!</code> 运算符低。</p>
</div>
</div>
<div class="sect4">
<h5 id="_so_运算符">so 运算符</h5>
<div class="paragraph">
<p><code>so</code> 运算符将操作数转换为布尔值并返回, 如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so 0;    # False
say so 42;   # True
say so True; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>?</code> 运算符比 <code>so</code> 运算符有更高的优先级。</p>
</div>
<div class="paragraph">
<p><code>so</code> 例程也作为 <code>Mu</code> 类的一个方法存在, 可以像 <code>$var.so</code> 一样对变量进行调用。(类的讨论在第八章《面向对象编程》中进行, <code>Mu</code> 是 Raku 类层次结构中最上面的一个类。) 所以, 下面的代码可以理解为一句英文短语 'If something is so, then do the following':</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $smth = True;
if $smth.so {
    say 'True';
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_后缀运算符">4.2.5. 后缀运算符</h4>
<div class="paragraph">
<p>后缀运算符集包含一些紧跟在操作数后面的运算符。</p>
</div>
<div class="sect4">
<h5 id="_面向对象的后缀运算符">面向对象的后缀运算符</h5>
<div class="paragraph">
<p>在 Raku 中, 有一组后缀运算符, 用于对象。例如, 我们已经使用了 <code>.</code> 运算符来调用对象上的方法, 例如, 整数或字符串。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 42.Str; # 42
say 'Hello'.WHAT # (Str)

say 'UP'.lc; # up</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将在第八章, 《面向对象编程》中研究其他与 OOP 相关的后缀运算符。这些运算符如下-<code>.&amp;</code>、<code>.=</code>、<code>.^</code>、<code>.?</code>、<code>.+</code>、<code>.*</code>、<code>.:</code> 和 <code>.::</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_自增和自减运算符">自增和自减运算符</h5>
<div class="paragraph">
<p>后缀形式的自增和自减运算符首先返回变量的值, 然后改变它们的值。我们可以从下面的代码中看到这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = 42;
$n++;
say $n;   # 43
say $n--; # 43</code></pre>
</div>
</div>
<div class="paragraph">
<p>将下面例子的输出与本章前面前缀运算符部分所示的程序进行比较。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_环缀运算符">4.2.6. 环缀运算符</h4>
<div class="paragraph">
<p>环缀运算符不像普通的运算符, 比如 <code>+.</code>。环缀运算符包含两个包围操作数的部分。本节介绍的四种运算符, 是利用不同种类的两个括号对儿建立的。</p>
</div>
<div class="sect4">
<h5 id="_引号单词运算符">引号单词运算符</h5>
<div class="paragraph">
<p>引号单词运算符 <code>&lt; &gt;</code> 使用角括号之间以空格分隔的数据创建一个列表。</p>
</div>
<div class="paragraph">
<p>下面的例子打印了一个包含三个元素的列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &lt;a b c&gt;; # (a b c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>不需要在 <code>&lt; &gt;</code> 运算符内引用元素。现在, 让我们把创建的数组保存在一个变量中, 看看它的内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = &lt; 1-3 two 3+6 four 5/7 &gt;;
say @a.elems;
say @a.join('|');</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个程序中, 有五个元素被放入 <code>@a</code> 数组中, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">5
1-3|two|3+6|four|5/7</code></pre>
</div>
</div>
<div class="paragraph">
<p>元素之间用空格隔开, 所以像 <code>1-3</code> 或 <code>5/7</code> 这样的结构被视为字符串。</p>
</div>
</div>
<div class="sect4">
<h5 id="_分组运算符">分组运算符</h5>
<div class="paragraph">
<p>分组运算符是一对小括号-<code>( )</code>。例如, 它对数学表达式中的元素进行分组。</p>
</div>
<div class="paragraph">
<p>空括号对创建一个空列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ().WHAT; # (List)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_散列或块创建运算符">散列或块创建运算符</h5>
<div class="paragraph">
<p>这对h花括号(<code>{ }</code>)既可以创建一个空的散列, 也可以创建一个代码块。Raku 根据它在花括号之间看到的代码来决定做什么。</p>
</div>
<div class="paragraph">
<p>在下面的例子中, 你可能会看到 Raku 会按照你的意思去做。</p>
</div>
<div class="paragraph">
<p>空括号或键值对的列表会创建一个散列, 如下面的代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say {}.WHAT;               # (Hash)
say {a =&gt; 1, b =&gt; 2}.WHAT; # (Hash)</code></pre>
</div>
</div>
<div class="paragraph">
<p>而一些可执行的代码, 引用占位符, 或默认变量会创建一个代码块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say {say 1}.WHAT;     # (Block)
say {$^x * $^y}.WHAT; # (Block)
say {$_}.WHAT;        # (Block)
say {$_ =&gt; 1}.WHAT;   # (Block)</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, 由于 Raku 在散列和块语法中都使用了相同的花括号, 所以可能会发生一些混淆, 比较一下下面两个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say {$_ =&gt; 1}.WHAT; # (Block)
say {a =&gt; 1}.WHAT;  # (Hash)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果这很明显, 括号之间的代码是可执行的, 比如包含分号, 分隔语句, Raku 就会制作一个块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say {;a =&gt; 2}.WHAT; # (Block)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外, 如果有隐式或显式参数的引用, 那么这就是一个块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say {$^a =&gt; 2}.WHAT; # (Block)</code></pre>
</div>
</div>
<div class="paragraph">
<p>占位符 <code>$^a</code> 和默认变量 $_ 都表明这是块签名的一部分。</p>
</div>
<div class="paragraph">
<p>另外, <code>%()</code> 语法也可以用来创建一个散列:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %('a', 2).WHAT; # (Hash)</code></pre>
</div>
</div>
<div class="paragraph">
<p>试图使用 $_ 变量可能会导致一个错误, 这取决于内容。例如, 下面这行会产生一个错误, 如果代码是孤立的, 那么下面的代码行就会生成 <code>Use of uninitialized value $_ of type Any in string context</code> 的错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %($_, 2).WHAT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在定义了 $_ 的情况下, 将无误地创建一个散列:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 1..5 {
    say %($_ =&gt; 2 * $_).WHAT; # (Hash)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_后环缀运算符">4.2.7. 后环缀运算符</h4>
<div class="paragraph">
<p>在 Raku 中, 后环缀运算符是后缀运算符, 它使用成对的字符来环绕操作数的其余部分。</p>
</div>
<div class="sect4">
<h5 id="_位置访问运算符">位置访问运算符</h5>
<div class="paragraph">
<p>一对方括号 <code>[ ]</code> 组织对操作数的位置元素的访问。最简单的情况是对一个数组进行索引, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = &lt;1 3 5 7 9&gt;;
say @a[2]; # 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以通过一个索引列表来请求一个以上的元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @a[1, 2, 3]; # (3 5 7)</code></pre>
</div>
</div>
<div class="paragraph">
<p>范围是另一个选择元素的好候选者。</p>
</div>
</div>
<div class="sect4">
<h5 id="_元素访问运算符">元素访问运算符</h5>
<div class="paragraph">
<p>下一组运算符包括 <code>{ }</code>、<code>&lt; &gt;</code>、<code>&lt;&lt; &gt;&gt;</code> 和 <code>« »</code>。</p>
</div>
<div class="paragraph">
<p>主运算符 <code>{ }</code> 用于访问一个散列值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h = alpha =&gt; 'a',
        beta =&gt; 'b',
        gamma =&gt; 'c';

say %h{'beta'}; # b</code></pre>
</div>
</div>
<div class="paragraph">
<p>与 <code>[ ]</code> 运算符类似, <code>{ }</code> 接受多个键:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %h{'alpha', 'beta'}; # (a b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的例子中, 引用了 <code>%h</code> 的键。后环缀运算符 <code>&lt; &gt;</code> 允许我们避免像 <code>&lt; &gt;</code> 环缀那样引用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %h&lt;beta&gt;;       # b
say %h&lt;alpha beta&gt;; # (a b)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&lt;&lt; &gt;&gt;</code> 运算符和它的 Unicode 同义词 <code>« »</code>, 将操作数作为双引号中的字符串进行插值, 如你在 这里看到的那样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = 'gamma';
say %h«$name»;   # (c)
say %h&lt;&lt;$name&gt;&gt;; # (c)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_调用运算符">调用运算符</h5>
<div class="paragraph">
<p><code>( )</code> 是一个运算符, 它在第一个操作数上调用一个函数或方法。操作数放在括号中, 作为参数传递:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Hello'.substr(1, 3); # ell</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, <code>( )</code> 后环缀运算符接收三个操作数-<code>substr</code> 方法的名称和两个整数, 1 和 3。</p>
</div>
<div class="paragraph">
<p>虽然这段代码看起来并没有使用运算符, 但 Raku 仍然将一对括号视为一种特殊类型的运算符, 即后环缀运算符。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_raku_中的元运算符">4.3. Raku 中的元运算符</h3>
<div class="paragraph">
<p>到目前为止, 我们已经介绍了许多对常规操作数&#8212;&#8203;值、变量、对象等进行操作的运算符。在 Raku 中, 还有另一种运算符-在运算符上进行操作的运算符。这些运算符被称为元运算符。我们将在下面的章节中研究它们。除了一些例外, 每个元运算符都可以接受任何普通运算符来创建一个新的操作, 并遵循一定的规则。元运算符也可以与用户定义的运算符一起工作, 我们将在本章后面的用户定义运算符一节中讨论这些运算符。</p>
</div>
<div class="sect3">
<h4 id="_赋值元运算符">4.3.1. 赋值元运算符</h4>
<div class="paragraph">
<p>赋值元运算符采用 <code>op=</code> 形式, 其中 <code>op</code> 是 Raku 中可用的运算符之一。</p>
</div>
<div class="paragraph">
<p>例如, 以中缀 <code>+</code> 运算符为例, 它的默认形式是将两个操作数相加, 然后返回结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 10;
my $b = 20;
my $c = $a + $b;
say $c; # 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中, <code>$c</code> 变量接收 <code>$a</code> 和 <code>$b</code> 之和, 保持不变。</p>
</div>
<div class="paragraph">
<p>在元运算符形式中, <code>+=</code> 运算符改变左操作数, 并将结果存储在其中, 如这里所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $d = 10;
my $e = 20;
$e += $d;
say $e; # 30</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$a += $b</code> 表达式总是等同于下面的 <code>$a = $a + $b</code> 形式。</p>
</div>
<div class="paragraph">
<p>赋值元运算符与许多其他中缀运算符一起工作。请看下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = pi;
$x *= 2/3;
say $x;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_否定元运算符">4.3.2. 否定元运算符</h4>
<div class="paragraph">
<p>否定元运算符 <code>!</code> 是用 <code>!op</code> 形式的感叹号与布尔运算符配合使用。例如, 这里是与智能匹配运算符 <code>~~</code> 相结合创建的否定元运算符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Hello' ~~ /o/;  # ⌈o⌋
say 'World' !~~ /x/; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>World</code> 中没有 <code>x</code>, 所以 <code>!~~</code> 运算符返回 <code>True</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_反转元操作器">4.3.3. 反转元操作器</h4>
<div class="paragraph">
<p>反转元运算符 <code>R</code> 接收一个运算符, 并创建一个新的运算符, 其中操作数的顺序被改变。</p>
</div>
<div class="paragraph">
<p>例如, 以中缀 <code>-</code> 运算符为例。它从第一个操作数中减去第二个操作数, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 20 - 10; # 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 让我们使用元运算符 <code>R-</code>, 看看它有什么变化:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 20 R- 10; # -10</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们看到, 结果就像操作数被交换了一样。元运算符与两个操作数 <code>$a Rop $b</code> 的操作相当于 <code>$b op $a</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_化简元运算符">4.3.4. 化简元运算符</h4>
<div class="paragraph">
<p>化简运算符 <code>[op]</code> 应用于一个列表时, 对其后的每一对元素执行 <code>op</code> 运算。换句话说, 列表被注册并在它们之间插入 <code>op</code> 符号。</p>
</div>
<div class="paragraph">
<p>让我们在下面的例子中研究一下这个元运算符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = (1, 2, 3);
say [+] @a; # 6</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>[+] @a</code> 表达式相当于下面的表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @a[0] + @a[1] + @a[2];</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们再来看另一个例子-<code>[*]</code>。这个元运算符可以用来计算阶乘:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [*] 1..5; # 120</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_交叉元运算符">4.3.5. 交叉元运算符</h4>
<div class="paragraph">
<p>交叉元运算符 <code>Xop</code> 接受两个列表, 并将运算符应用于列表中元素的每一个可能的组合上。</p>
</div>
<div class="paragraph">
<p>操作的结果是另一个列表。请看下面的例子, 两个列表中各有三个数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @x = (1, 2, 3);
my @y = (4, 5, 6);
say @x X+ @y;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码打印了一个有六个元素的列表, 每个元素都是 <code>@x</code> 和 <code>@y</code> 两个元素之和:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(5 6 7 6 7 8 7 8 9)</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们使用字符串连接(<code>~</code>), 并在 <code>X~</code> 操作中使用相同的 <code>@x</code> 和 <code>@y</code> 数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @x X~ @y;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下, 每一对数字都会被转换为一对字符串, 然后将它们连接起来。你可以看到 <code>X</code> 元运算符如何挑选操作数的元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(14 15 16 24 25 26 34 35 36)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_zip_元运算符">4.3.6. Zip 元运算符</h4>
<div class="paragraph">
<p><code>zip</code> 元运算符 <code>Zop</code> 对其列表操作数进行"压缩", 并将运算符操作应用于操作数的对应元素。</p>
</div>
<div class="paragraph">
<p>让我们在相同的数据上尝试使用 <code>zip</code> 元运算符, 就像我们使用交叉元运算符一样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @x = (1, 2, 3);
my @y = (4, 5, 6);
say @x Z+ @y;
say @x Z~ @y;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序打印两个列表, 每个列表有三个元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(5 7 9)
(14 25 36)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_超运算符">4.3.7. 超运算符</h4>
<div class="paragraph">
<p>Raku 中的超运算符将运算应用于列表操作数的每个元素上。它们既适用于一元运算符, 也适用于二元运算符, 并使用 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 符号, 以及它们的同义词 <code>«</code> 和 <code>»</code>。</p>
</div>
<div class="paragraph">
<p>让我们通过实例来探讨超运算符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1..10;
@a = @a &lt;&lt;+&gt;&gt; 3;
say @a; # [4 5 6 7 8 9 10 11 12 13]</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第一个例子中, <code>@a</code> 数组的每个元素都加了 3。在 <code>&lt;&lt;+&gt;&gt;</code> 超运算符的左边, 是一个有十个元素的数组。在右侧, 我们有一个标量值。这个值被加到左边数组的所有元素上。</p>
</div>
<div class="paragraph">
<p>在这个例子中, 相同的 <code>&lt;&lt;+&gt;&gt;</code> 运算符被用于两个长度相同的数组上:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @x = (1, 2, 3);
my @y = (4, 5, 6);
say @x &lt;&lt;+&gt;&gt; @y; # [5 7 9]</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果是一个有三个元素的新数组；每个元素是源数组中相应元素的和。</p>
</div>
<div class="paragraph">
<p><code>&lt;&lt;+&gt;&gt;</code> 的 ASCII 形式可以使用引号重写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @x «+» @y; # [5 7 9]</code></pre>
</div>
</div>
<div class="paragraph">
<p>角括号的方向定义了如果其中一个操作数比另一个操作数短, 如何克隆操作数。</p>
</div>
<div class="paragraph">
<p>让我们来看看下面两个数组上的不同组合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @short = (1, 2);
my @long = (3, 4, 5, 6);</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先, 使用与我们之前使用的相同的运算符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @short &lt;&lt;+&gt;&gt; @long; # [4 6 6 8]</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里重复了两次 <code>@short</code> 数组, 这样整个 <code>@long</code> 数组就有足够的元素。这段代码相当于将两个相同长度的数组相加:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, 2, 1, 2) &lt;&lt;+&gt;&gt; (3, 4, 5, 6);</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 使用 <code>&lt;&lt;+&lt;&lt;</code> 运算符, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @short &lt;&lt;+&lt;&lt; @long; # [4 6 6 8]</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样, <code>@short</code> 数组也是重复的。</p>
</div>
<div class="paragraph">
<p>像这样把箭头反过来:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @short &gt;&gt;+&gt;&gt; @long; # [4 6]</code></pre>
</div>
</div>
<div class="paragraph">
<p>数组不再重复, 结果只包含两个元素。<code>@long</code> 数组的其余元素则被忽略。</p>
</div>
<div class="paragraph">
<p>最后, 让我们试试 <code>&gt;&gt;+&lt;&lt;</code> 运算符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @short &gt;&gt;+&lt;&lt; @long;</code></pre>
</div>
</div>
<div class="paragraph">
<p>超运算符的形状告诉我们, 两个操作数都不能克隆。在这种情况下, 会出现以下错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Lists on either side of non-dwimmy hyperop of infix:&lt;+&gt; are not of the same length</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以用一元运算符创建一个超运算符。例如, 用后缀自增:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @d = 1..5;
@d&gt;&gt;++;
say @d; # [2 3 4 5 6]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@d</code> 数组中的每一个元素都会使用 <code>&gt;&gt;++</code> 超运算符递增 1。</p>
</div>
<div class="paragraph">
<p>如果使用 <code>++</code> 的前缀形式, 同样的例子会是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @d = 1..5;
++&lt;&lt;@d;
say @d; # [2 3 4 5 6]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_用户定义的运算符">4.3.8. 用户定义的运算符</h4>
<div class="paragraph">
<p>Raku 允许创建新的运算符。与 <code>C++</code> 不同的是, 新的运算符并不局限于预定义的现有运算符列表。你可以自由地给运算符命名, 并选择新的字符组合。</p>
</div>
<div class="paragraph">
<p>一个用户定义的运算符应该属于前面提到的类别之一, 如中缀、前缀或环缀等。</p>
</div>
<div class="paragraph">
<p>让我们从创建一个新的后缀运算符-<code>+%</code> 开始, 它可以计算两个数字操作数之和, 但结果不超过 100:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;+%&gt;($a, $b) {
    my $sum = $a + $b;
    return $sum &lt; 100 ?? $sum !! 100;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>定义一个运算符类似于创建一个子例程, 但它的名称应该包含类别名和运算符本身。</p>
</div>
<div class="paragraph">
<p>现在是测试刚刚创建的 <code>+%</code> 运算符的时候了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 +% 20; # 30
say 40 +% 70; # 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个有表现力的例子是阶乘运算符。在数学中, 阶乘是由值后的感叹号来表示的。在 Raku 中, 通过用户定义的后缀运算符也可以做到这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub postfix:&lt;!&gt;($n) {
    [*] 1..$n
}

say 5!; # 120</code></pre>
</div>
</div>
<div class="paragraph">
<p>后缀运算符只需要一个操作数-<code>$n</code>。在运算符的主体中, 我们使用化简操作来计算一个阶乘。</p>
</div>
<div class="paragraph">
<p>在 Raku 中, 用户定义的运算符获得了与内置运算符相同的权限。这尤其意味着, 在定义了一个新的运算符之后, 你可以将它与许多元运算符组合使用。</p>
</div>
<div class="paragraph">
<p>例如, <code>+%</code> 运算符得到 <code>+%=</code> 形式, 可以直接使用, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $var = 50;

$var +%= 30;
say $var; # 80

$var +%= 30;
say $var; # 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者, 也可以用化简运算符, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [+%] 1..10; # 55
say [+%] 1..50; # 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 的设计中, 并没有打算让用户定义的运算符变得神秘。所以, 你可以想出更好的名字, 包括一些描述性的字符串标识符, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub postfix:&lt;Factorial&gt;($n) {
    [*] 1..$n
}

say 5Factorial; # 120</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_4">4.4. 总结</h3>
<div class="paragraph">
<p>在这一长章中, 我们谈到了 Raku 中的运算符。运算符有几类, 如中缀、前缀 、后缀、环缀和后环缀。我们讨论了每一类的运算符。然后, 我们看了元运算符和超运算符如何在内置运算符的基础上创建新的运算符。最后, 你学会了如何创建用户定义的运算符, 这些运算符将自然地嵌入到你的程序语言中。</p>
</div>
<div class="paragraph">
<p>到目前为止, 我们已经介绍了 Raku 语法的所有基础知识。在下一章中, 我们将进入使用子例程组织代码的下一个层次。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_控制流">5. 控制流</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本章中, 我们将讨论 Raku 中控制程序流的主要内容。大多数程序不只是一个指令列表, 而是应该对用户的输入做出反应, 根据计算出的数据做出决策等等。</p>
</div>
<div class="paragraph">
<p>在本章中, 我们将涉及以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>代码块和 do 关键字</p>
</li>
<li>
<p>有条件的检查</p>
</li>
<li>
<p>循环</p>
</li>
<li>
<p>中断循环体</p>
</li>
<li>
<p>使用 gather 和 take 方法收集数据</p>
</li>
<li>
<p>设定主题</p>
</li>
<li>
<p>只执行一次代码</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_了解代码块和变量作用域">5.1. 了解代码块和变量作用域</h3>
<div class="paragraph">
<p>在上一章中, 我们讨论了变量, 它们是你在程序中使用的命名实体。与许多编程语言一样, 在 Raku 中, 名字在其作用域内可见, 而在作用域外则不可见。</p>
</div>
<div class="paragraph">
<p>以一个简单的程序为例, <code>$name</code> 变量只使用一次, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = 'Mark';
say "Hello, $name!";</code></pre>
</div>
</div>
<div class="paragraph">
<p>该变量在用于打印问候语后可以重复使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = 'Mark';
say "Hello, $name!";

$name = 'Carl';
say "Hello, $name!";</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样做的原因是两个打印语句都位于同一个作用域中, 而且 <code>$name</code> 变量在那里是可见的。</p>
</div>
<div class="paragraph">
<p>在 Raku 中, 块是位于一对大括号内的一段代码。一个代码块可以创建自己的作用域。因此, 在代码块中声明的变量只有在它内部可见。</p>
</div>
<div class="paragraph">
<p>下面的程序将无法编译:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    my $name = 'Mark';
    say "Hello, $name!";
}

$name = 'Carl'; # Error here
say "Hello, $name!";</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的错误信息告诉我们, 在 <code>$name</code> 被分配给一个新值的地方, 没有声明这个名字的变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">===SORRY!=== Error while compiling /Users/ash/code/control-flow/3.pl
Variable '$name' is not declared
at /Users/ash/code/control-flow/3.pl:6
------&gt; &lt;BOL&gt;   $name = 'Carl';</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了使名称再次可见, 在外层作用域中声明如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name;

{
    $name = 'Mark';
    say "Hello, $name!";
}

$name = 'Carl';
say "Hello, $name!";</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个演示中, 创建单独的代码块没有太大的意义。当我们在本章后面讲到例如条件时, 或者在第六章子程序时, 我们会看到代码块的更多有用的应用, 代码块是用来保存用户定义函数的主体。</p>
</div>
<div class="sect3">
<h4 id="_do_关键字">5.1.1. do 关键字</h4>
<div class="paragraph">
<p><code>do</code> 关键字用于执行一个代码块。上一节的例子可以按以下方式重写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name;

do {
    $name = 'Mark';
    say "Hello, $name!";
}

$name = 'Carl';
say "Hello, $name!";</code></pre>
</div>
</div>
<div class="paragraph">
<p>当代码块不能成为一个独立的表达式时, 显式使用关键字的必要性是显而易见的, 如下一个例子所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name;
$name = 'Carl';
$name and do {say "Hello, $name!"};</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, 借助于 <code>and</code> 关键字(见第四章,《使用运算符), 程序会检查 <code>$name</code> 是否被定义, 如果是, 则打印出问候语。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_有条件的检查">5.2. 有条件的检查</h3>
<div class="paragraph">
<p>根据条件进行决策是编程中的基本需求之一。<code>if</code> 关键字会根据布尔测试的结果, 改变程序的流程。请看以下代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 5;
if $x &lt; 10 {
    say "$x &lt; 10"; # 5 &lt; 10
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中, 你可以看到使用 <code>if</code> 关键字的语法。关键字后面是一个布尔条件 <code>$x &lt; 10</code>, 后面是花括号中的代码块。与 Perl 5 不同的是, 条件周围的圆括号是不必要的。</p>
</div>
<div class="paragraph">
<p>只有当条件值为 <code>True</code> 时, 这段代码才会被执行。</p>
</div>
<div class="paragraph">
<p><code>if</code> 语句可以由 <code>else</code> 分支来完成, 当条件为 <code>False</code> 时, 该分支将接管控制权:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 11;
if $x &lt; 10 {
    say "$x &lt; 10";
}
else {
    say "$x &gt;= 10"; # 11 &gt;= 10
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在给定值 <code>$x</code> 的情况下, 程序执行代码, 然后是 <code>else</code> 块。</p>
</div>
<div class="paragraph">
<p>当你需要更细化的分支时, 可以将 <code>if-else</code> 检查链接起来。这里, 连带的 <code>elsif</code> 关键字就派上用场了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 10;
if $x &lt; 10 {
    say "$x &lt; 10";
}
elsif $x == 10 {
    say "$x == 10"; # 10 == 10
} else {
    say "$x &gt; 10";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>elsif</code> 分支包含另一个布尔表达式, 当第一个 <code>if</code> 测试的条件为 <code>False</code> 时, 将对其进行检查。</p>
</div>
<div class="paragraph">
<p>同一程序可以使用不同的布尔测试组合重新编写, 举例说明:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 10;
if $x &lt; 10 {
    say "$x &lt; 10";
}
elsif $x &gt; 10 {
    say "$x &gt; 10";
} else {
    say "$x == 10";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你必须小心不要误写成 <code>if</code> 而不是 <code>elsif</code>。如果你这样做, 你会创建两个独立的 <code>if</code> 检查, 这两个检查都可以触发它们的, 如下面的例子所示。</p>
</div>
<div class="paragraph">
<p>下面这段代码检查变量是否小于5或小于10:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 3;
if $x &lt; 5 {
    say 'x &lt; 5';
}
elsif $x &lt; 10 {
    say 'x &lt; 10';
} else {
    say 'x &gt;= 10';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个条件 <code>$x &lt; 5</code> 为 <code>True</code>, 所以只执行第一个代码块, 程序打印 <code>x &lt; 5</code>。</p>
</div>
<div class="paragraph">
<p>现在, 让我们用 <code>if</code> 代替 <code>elsif</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 3;
if $x &lt; 5 {
    say 'x &lt; 5';
}
if $x &lt; 10 {
    say 'x &lt; 10';
}
else {
    say 'x &gt;= 10';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下, 有两个 <code>if</code> 块。<code>else</code> 块只存在于第二个 <code>if</code> 中。这两个条件, <code>$x &lt; 5</code> 和 <code>$x &lt; 10</code>, 现在都是 <code>True</code>, 因此, 程序打印下面两行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">x &lt; 5
x &lt; 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外, 确保在需要 <code>if-elsif-else</code> 链的地方不要使用两个 <code>else if</code> 关键字而不是一个 <code>elsif</code>。Raku 会抱怨, 因为它希望在 <code>else</code> 关键字之后找到代码块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 3;
if $x &lt; 5 {
    say 'x &lt; 5';
}
else if $x &lt; 10 {
    say 'x &lt; 10';
}
else {
    say 'x &gt;= 10';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>编译以以下错误结束:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">===SORRY!=== Error while compiling /Users/ash/ifelseif.pl
In Raku, please use "elsif" instead of "else if"</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然, 也可以使用嵌套的 <code>if-else</code> 语句来解决这个问题, 这可能有点丑, 而且还引入了另一层没有必要的嵌套代码, 在下面的例子中可以看到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 3;
if $x &lt; 5 {
    say 'x &lt; 5';
}
else {
    if $x &lt; 10 {
        say 'x &lt; 10';
    }
    else {
        say 'x &gt;= 10';
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用循环">5.3. 使用循环</h3>
<div class="paragraph">
<p>循环结构有助于组织重复的操作。在 Raku 中, 有几个不同的选项可以用来创建循环。让我们从类似于传统的 C 风格的循环开始。</p>
</div>
<div class="sect3">
<h4 id="_循环周期">5.3.1. 循环周期</h4>
<div class="paragraph">
<p><code>loop</code> 关键字期望有三个元素来控制循环体的数量或重复次数。请看下面的代码片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop (my $c = 0; $c &lt; 5; $c++) {
    say $c;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在本例中, <code>$c</code> 是循环迭代的计数器。这个变量是在循环关键字-<code>my $c = 0</code> 之后立即声明并初始化的, 如果条件 <code>$c &lt; 5</code> 为 <code>True</code>, 则执行循环的主体。循环迭代后, 执行 <code>$c++</code> 语句, 使计数器递增, 循环重复。只要 <code>$c</code> 等于 5, 条件就不再是 <code>True</code> 了, 循环就停止了。所以, 整个程序打印从0一直到4的数字, 包括 4。</p>
</div>
<div class="paragraph">
<p>循环头中的某些甚至全部部分可能会被省略。例如, 如果在循环前初始化计数器变量, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = 0;
loop (; $c &lt; 5; $c++) {
    say $c;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果增量发生在主体内部。我们可以考虑以下代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = 0;
loop (; $c &lt; 5; ) {
    say $c;
    $c++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, 尽管缺失了部分, 但还是需要分号。</p>
</div>
<div class="paragraph">
<p>最后, 如果没有给出参数, 循环就会变成无限循环, 你有责任停止它, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = 0;
loop (;;) {
    say $c;
    $c++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果是空头, 则不需要分号, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = 0;
loop {
    say $c;
    $c++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>循环头的各部分可以包含多条指令, 用逗号分隔。例如, 这里是一个有两个变量的循环:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop (my $x = 0, my $y = 10; $x &lt; 5 &amp;&amp; $y &gt; 5; $x++, $y--) {
    say "$x $y";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序将 <code>$x</code> 变量递增, 并将 <code>$y</code> 递减。输出结果是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">0 10
1 9
2 8
3 7
4 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 让我们进入 <code>for</code> 循环。</p>
</div>
</div>
<div class="sect3">
<h4 id="_for_循环">5.3.2. for 循环</h4>
<div class="paragraph">
<p><code>for</code> 循环可以说是一种比较 Perlish 的组织循环的方式。它不需要计数器, 并且在一个数据列表上进行迭代。</p>
</div>
<div class="paragraph">
<p>看一个例子。这里, 列表是一个奇数整数的数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @data = 1, 3, 5, 7, 9, 11;
for @data {
    say $_;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>$_ 变量是默认变量, 也叫主题。它取当前迭代中的一个元素的值。因此, <code>for</code> 循环会打印 <code>@data</code> 数组中的数字。</p>
</div>
<div class="paragraph">
<p>你可以对前面的程序执行两个重要的修改。</p>
</div>
<div class="paragraph">
<p>首先, 如果循环的主体是一条语句, 可以用后缀形式重写循环, 如这里所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @data = 1, 3, 5, 7, 9, 11;
say $_ for @data;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里, 内置函数 <code>say</code> 以 $_ 为参数。也可以在主题上调用一个同名的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_.say for @data;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见, 可以省略默认变量, 使程序更短:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for @data;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个真实的 Raku 的例子。</p>
</div>
<div class="paragraph">
<p>第二个变化是明确地引入了主题变量。在这种情况下, 你给它起了一个名字。语法很简单, 可以从下面的例子中理解:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @data = 1, 3, 5, 7, 9, 11;
for @data -&gt; $x {
    say $x;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>变量是在 <code>&#8594;</code> 箭头后面声明的。你不需要在这里使用 <code>my</code> 关键字。这种格式有一个优点, 就是它可以从 <code>@data</code> 中取多个值。例如, 如果要在每次迭代时取两个值, 可以像下面这样声明两个变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @data = 1, 3, 5, 7, 9, 11;
for @data -&gt; $x, $y {
    say "$x + $y = ", $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见, 这个程序可以打印出三个和:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1 + 3 = 4
5 + 7 = 12
9 + 11 = 20</code></pre>
</div>
</div>
<div class="paragraph">
<p>在元素数量为奇数的情况下, 会出现异常, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Too few positionals passed; expected 2 arguments but got 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>带箭头的结构(在下面的代码中)被称为尖号块。它相当于一个匿名函数, 接受命名参数, 这就是为什么在错误信息中提到参数的原因。我们将在第六章《子程序》中看到更多的内容。</p>
</div>
<div class="paragraph">
<p>为了正确处理缺失的数据, 可以使用如下的默认值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @data = 1, 3, 5, 7, 9, 11, 13;
for @data -&gt; $x, $y = -1 {
    say "$x, $y";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见, 在这种情况下, 在最后一次迭代时, <code>$y</code> 的值将被设置为 <code>-1</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1, 3
5, 7
9, 11
13, -1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用_whileuntil_和_repeat">5.3.3. 使用 while、until 和 repeat</h4>
<div class="paragraph">
<p>通过 <code>while</code>、<code>until</code> 和 <code>repeat</code> 这三个关键字, 你可以创建由一定条件定义的重复次数的循环。我们先从最简单的情况开始, 用一个裸关键字 <code>while</code> 和 <code>until</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $letter = 'a';
while $letter ne 'd' {
    say $letter;
    $letter++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要条件 <code>$letter ne 'd'</code> 为 <code>True</code>, 就会重复执行 <code>while</code> 循环的主体。在这里, 对变量的控制是在循环的主体中完成的, 而其头部只控制条件。如果在进入循环前条件为 <code>False</code>, 则不会执行主体, 如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $letter = 't';
while $letter le 'd' { # 't' is not less or equal then 'd';
    say $letter;       # body is not executed.
    $letter++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>until</code> 关键字的行为与 <code>while</code> 相反。循环体被执行, 直到条件变为 <code>True</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $letter = 'a';
until $letter eq 'd' {
    say $letter;
    $letter++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前三次迭代过程中, <code>$letter eq 'd'</code> 条件为 <code>False</code>, 所以主体被执行。只要 <code>$letter</code> 变成 <code>d</code>, 循环就会停止。</p>
</div>
<div class="paragraph">
<p>正如你所看到的, 并不能保证循环的主体会被执行哪怕一次。如果条件最初是 <code>False</code>(在 <code>while</code> 的情况下)或 <code>True</code>(在 <code>until</code> 的情况下), 那么循环主体的代码就会被跳过。</p>
</div>
<div class="paragraph">
<p><code>repeat</code> 关键字将条件检查移动到主体的末尾, 因此它将至少被执行一次。这个关键字与 <code>while</code> 和 <code>until</code> 一起使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $letter = 'a';
repeat {
    say $letter;
    $letter++;
} while $letter ne 'd';</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个循环打印出字母 a、b、c, <code>while</code> 子句中的条件为 <code>False</code> 三次, 之后变为 <code>True</code>。</p>
</div>
<div class="paragraph">
<p>现在, 让我们同时修改条件和变量的初始值, 然后再次运行这个循环:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $letter = 't';
repeat {
    say $letter;
    $letter++;
} while $letter le 'd';</code></pre>
</div>
</div>
<div class="paragraph">
<p>这次打印的是字母 <code>t</code>。与裸 <code>while</code> 循环不同的是, <code>repeat while</code> 循环在检查条件之前执行其主体。</p>
</div>
<div class="paragraph">
<p>注意, <code>while</code> 子句可以放在代码块之前, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $letter = 't';
repeat while $letter le 'd' {
    say $letter;
    $letter++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下, 与后缀 <code>while</code> 子句没有区别。</p>
</div>
<div class="paragraph">
<p>同样, <code>unit</code> 关键字也可以和 <code>repeat</code> 一起使用。<code>repeat until</code> 循环至少执行一次。如果条件为 <code>False</code>, 则继续运行代码块, 直到条件变为 <code>True</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $letter = 'a';
repeat until $letter eq 'd' {
    say $letter;
    $letter++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者, 使用后缀形式。请看下面的代码片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $letter = 'a';
repeat {
    say $letter;
    $letter++;
} until $letter eq 'd';</code></pre>
</div>
</div>
<div class="paragraph">
<p>这两个程序都会打印出a、b、c, 选择其中一个定位条件的变体, 并在实践中尝试坚持使用, 至少在项目里面是这样。</p>
</div>
</div>
<div class="sect3">
<h4 id="_中断循环">5.3.4. 中断循环</h4>
<div class="paragraph">
<p>循环的执行不仅可以用初始条件控制, 还可以从循环体本身控制。有三个关键字-<code>next</code>、<code>last</code> 和 <code>redo</code>。当它们与使用 <code>if</code> 的条件检查一起使用时, 会变得更加有用。</p>
</div>
<div class="paragraph">
<p><code>last</code> 关键字只是中断循环。让我们看一个例子, 在打印一个大于某个预定义阈值的值后, 循环就会中断:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @data = 3, 1, 7, 12, 50, 2, 14;
for @data -&gt; $x {
    last if $x &gt; 42;
    say $x;
}
say 'Done.';</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, 这里的 <code>if</code> 是以后缀的形式使用的-它的行为和下面的代码一样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $x &gt; 42 {
    last;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前几次迭代照常执行, 但当 <code>$x</code> 的当前值变成 50, 使得 <code>$x &gt; 42</code> 的条件为 <code>True</code> 时, 循环停止, 执行到循环后的代码(如果有的话)。程序打印出以下几行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">3
1
7
12 Done.</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, 代码块中位于最后一条指令之后的代码, 也是在 <code>if</code> 条件变为 <code>True</code> 之前执行的。只要 <code>$x</code> 变量得到 50 的值, 循环就会被中断。</p>
</div>
<div class="paragraph">
<p>另一个关键字 <code>next</code>, 跳过循环体的其余部分, 开始另一次迭代。例如, 让我们打印1到10之间的偶数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 1..10 -&gt; $x {
    next if $x % 2;
    say $x;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果条件 <code>$x % 2</code> 是 1, 这个循环不会打印一个数字, 而这个条件是转换为 <code>True</code> 的。它发生在偶数上, 因此, <code>say</code> 只接收通过过滤器的奇数, 正如你可以在下面的输出中看到的那样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">2
4
6
8
10</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后, <code>redo</code> 关键字从当前位置重新启动循环。与 <code>next</code> 和 <code>last</code> 一样, 它跳过循环主体的其余部分, 但不影响循环计数器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 1..5 -&gt; $n {
    my $r = rand;
    say "Trying $r";
    redo if $r &lt; 0.5;

    say $n + $r;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个简单的程序演示了 <code>redo</code> 关键字的用法。程序会生成一个0和1之间的随机数, 只有当这个数大于0.5时才会使用它。在所有其他情况下, 循环迭代会重新开始。</p>
</div>
<div class="sect4">
<h5 id="_使用标签">使用标签</h5>
<div class="paragraph">
<p>让我们考虑一个嵌套循环的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 1..5 -&gt; $x {
    for 1..5 -&gt; $y {
        say "$x * $y = ", $x * $y;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序打印了1到5的数字的乘法表。如果在某些时候, 我们想跳过给定的 <code>$x</code> 的表的其余部分, 继续计算 <code>$x</code> 的下一个值, 怎么办？直接在循环内使用 <code>next</code> 对 <code>$y</code> 的使用, 只会影响到内循环。为了确保 <code>next</code> 语句是修改外循环的执行, 使用 <code>X_LOOP</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">X_LOOP: for 1..5 -&gt; $x {
    for 1..5 -&gt; $y {
        next X_LOOP if $y == $x;
        say "$x $y = ", $x $y;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的标签是一个大写的标识符 <code>X_LOOP</code>, 后面是冒号。它在下一条语句中被提及, 所以编译器明白下一次迭代应该从标有 <code>X_LOOP</code> 的循环开始。</p>
</div>
<div class="paragraph">
<p>标签也可以用于其他类型的循环, 例如, 用于 <code>until</code> 和 <code>while</code> 循环。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_执行代码一次">5.4. 执行代码一次</h3>
<div class="paragraph">
<p>在 Raku 中, 有趣的是, 可以只执行部分主体一次。例如, 在下一个循环中, 应该有四次迭代完成, 但第一条消息只打印一次:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 1, 2, 3, 4 {
    once {
        say 'Looping from 1 to 4';
    }
    say "Current value is $_";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码打印了以下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Looping from 1 to 4
Current value is 1
Current value is 2
Current value is 3
Current value is 4</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>once</code> 关键字后的代码块只执行了一次。</p>
</div>
<div class="paragraph">
<p>这也适用于其他类型的循环, 例如, <code>loop</code> 循环。看一下下面的代码片段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop (my $c = 1; $c != 5; $c++) {
    once say 'Looping from 1 to 4';
    say "Current value is $c";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, 如果你只有一条指令要执行一次, 就不需要花括号。</p>
</div>
<div class="paragraph">
<p><code>once</code> 关键字不仅适用于循环。它可以用在代码的任何其他部分, 例如, 在子程序内部。我们将在下一章第六章《子程序》中详细讨论子程序。现在, 这里有一个简单的例子, 它可以打印整数的平方, 并在函数 <code>f</code> 的第一次调用时向我们问好:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($x) {
    once say 'Hi!';
    say $x * $x;
}

f(1);
f(2);
f(3);</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序的输出如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Hi!
1
4
9</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用_gather_和_take_收集数据">5.5. 使用 gather 和 take 收集数据</h3>
<div class="paragraph">
<p>用 Raku 中的一对关键字-<code>gather</code> 和 <code>take</code> 就可以很有表现力地组织数据列表的准备工作。要了解其工作原理, 最简单的方法就是看看下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @data = gather {
    take 'a';
    take 'b';
}

say @data;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gather</code> 关键字后的代码块返回一个序列, 保存在 <code>@data</code> 数组中。序列中的元素由 <code>take</code> 关键字提供。所以, 在 <code>@data</code> 中会有两个元素, 如你所见:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">[a b]</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们考虑一个更大的例子。它包含一个二维整数矩阵和一个指令列表。指令是 <code>left</code>、<code>right</code>、<code>up</code> 和 <code>down</code> 四个方向, 还有一个命令-<code>take-it</code>。你应该从矩阵的中心开始, 然后根据指令移动当前的位置, 如果指令告诉你, 你就应该拾取数字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @matrix = (
    [ 8, 10, 3, 16, 11],
    [ 4, 13, 5, 1, 6],
    [20, 9, 0, 15, 19],
    [14, 2, 24, 7, 23],
    [21, 17, 18, 12, 22],
);

my ($x, $y) = 2, 2; # Starting position
my @instructions = &lt;down down take-it
                    left up up take-it
                     right right up up take-it&gt;;

my @result = gather {
    for @instructions -&gt; $step {
        if $step eq 'up'         {$y--}
        elsif $step eq 'down'    {$y++}
        elsif $step eq 'right'   {$x++}
        elsif $step eq 'left'    {$x--}
        elsif $step eq 'take-it' {take @matrix[$y][$x]}
    }
}

say @result; # [18 9 16]</code></pre>
</div>
</div>
<div class="paragraph">
<p>代码的主要部分是 <code>gather</code> 关键字的代码块。它包含了对 <code>@instructions</code> 的循环, 根据当前的命令, 它要么改变当前位置的坐标, 要么使用 <code>take</code> 关键字取数, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">take @matrix[$y][$x]</code></pre>
</div>
</div>
<div class="paragraph">
<p>代码完成后, <code>@result</code> 数组将包含根据给定的 <code>@instructions</code> 选择的三个数字。</p>
</div>
<div class="sect3">
<h4 id="_用_given_设置主题">5.5.1. 用 given 设置主题</h4>
<div class="paragraph">
<p>在上一节的例子中, 我们使用了链式 <code>if-elsif</code> 结构。让我们再看一次:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $step eq 'up'         {$y--}
elsif $step eq 'down'    {$y++}
elsif $step eq 'right'   {$x++}
elsif $step eq 'left'    {$x--}
elsif $step eq 'take-it' {take @matrix[$y][$x]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以清楚地看到, 所有的分支都包含相同的代码, 将 <code>$step</code> 变量的当前值与预定义的值进行比较。虽然简单明了, 但这并不是进行这种比较的最优雅方式。</p>
</div>
<div class="paragraph">
<p>在一些语言中, 如 C和 <code>C++</code>, <code>switch</code> 和 <code>case</code> 关键字有助于重新组织 <code>if-else</code> 链。在 Raku 中, 我们使用 <code>given</code> 和 <code>when</code>。前面的代码可以用下面的方式重写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given $step {
    when 'up'      {$y--}
    when 'down'    {$y++}
    when 'right'   {$x++}
    when 'left'    {$x--}
    when 'take-it' {take @matrix[$y][$x]}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里发生的事情是, <code>given</code> 将 <code>$step</code> 变量作为当前主题。这意味着它现在可以通过默认变量 $_ 使用。如果你在给定的代码块中打印, 你可以清楚地看到它, 如这里所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given $step {
    say $_;

    when 'up' {$y--}
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>when</code> 里面, 主题变量与给定的值进行智能匹配, 换句话说, <code>when 'up'</code> 相当于 <code>if $_ ~~ 'up'</code>。</p>
</div>
<div class="paragraph">
<p>在第一个关键字 <code>when</code> 找到匹配后, 其他的就不测试了。例如, 尝试在最后一个关键字 <code>when</code> 之前打印一些东西, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given $step {
    when 'up'    {$y--}
    when 'down'  {$y++}
    when 'right' {$x++}
    when 'left'  {$x--}
    say "Can only be 'take-it': $step";
    when 'take-it' {take @matrix[$y][$x]}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见, 打印指令只有在没有一个方向指令被捕获时才会被访问:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Can only be 'take-it': take-it
Can only be 'take-it': take-it
Can only be 'take-it': take-it
[18 9 16]</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <code>when</code> 关键字执行的是智能匹配操作, 所以创建条件的方法比较多。例如, 可以直接测试变量的类型, 如下一段代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @data = 1, 'two', 3, 'four', [1, 2];
for @data {
    when Int {
        say "$_ is an integer";
    }
    when Str {
        say "$_ is a string";
    }
    default {
        say "$_ is something else"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个程序中, <code>@data</code> 数组包含不同类型的元素-整数和字符串。两个 <code>when</code> 语句根据类型名测试主题, 并打印出下面两个字符串中的一个。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1 is an integer
two is a string
3 is an integer
four is a string
1 2 is something else</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有触发任何一个 <code>when</code> 块, 则会执行可选的默认块。</p>
</div>
<div class="paragraph">
<p>你可能已经注意到, 在最后一个例子中没有 <code>given</code> 关键字。这是因为主题已经被 <code>for</code> 循环设置了, 没有必要再设置一次。</p>
</div>
<div class="paragraph">
<p>相反, 如你所见, <code>given</code> 关键字可以单独用来设置默认变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given 'John' {
    .say # prints $_, which is 'John'
}

given 'John' {
    say "Hello, $_"; # prints 'Hello, John'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_5">5.6. 总结</h3>
<div class="paragraph">
<p>在本章中, 我们介绍了 Raku 为传统的程序化编程提供的控制流。我们谈到了执行代码块, 并使用关键字 <code>if</code>、<code>elsif</code> 和 <code>elsif</code> 进行决策。我们还谈到了不同的循环-基本循环、<code>for</code> 循环、以及带有前置条件或后置条件的 <code>repeat</code>、<code>until</code> 和 <code>while</code> 循环。然后, 我们看了使用 <code>gather-take</code> 对来收集数据, 以及 Raku 借助 <code>given</code> 和 <code>when</code> 关键字来处理主题的方式。</p>
</div>
<div class="paragraph">
<p>Raku 不仅仅能够使用程序化的编程风格。你将在第十三章《并发编程》、第十四章《函数式编程》和第十五章《反应式编程》中找到更多关于其他范式的信息。</p>
</div>
<div class="paragraph">
<p>同时, 在下一章中, 我们将讨论组织代码和子程序的另一个层次。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_子例程">6. 子例程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>子程序是编程中的基本概念之一。他们帮助组织 结构更好的代码，也易于重用。Raku提供了很好的支持 子程序和许多有趣的相关功能。在Raku中，通常会调用子例程 潜艇。
我们将在本章中介绍以下主题:
创建子程序 调用子程序 输入的参数
签名属性 按值或按引用传递参数 运算符作为子程序 嵌套的子程序 对子程序的引用 重载子程序和多次调度 匿名子程序和lambda 可变占位符</p>
</div>
<div class="paragraph">
<p>创建和调用子例程
参数和身体。但是，名称和参数列表都是可选的。在
第1章，什么是Raku的?，我们已经创建了一个子程序来添加两个数字。让我们 回想一下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y) {
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，add是名称，稍后将用于调用sub。接下来是一个列表 sub的参数 - ($ x，$ y)。子程序的主体被包围在一对卷曲中 大括号 - {return $ x + $ y;}。
要调用子例程，请再次使用该名称并在括号中传递实际参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 17;
my $b = 71;
my $sum = add($a, $b);
say "Sum of $a and $b is $sum"; # Sum of 17 and 71 is 88</code></pre>
</div>
</div>
<div class="paragraph">
<p>子可以通过两种方式返回值。我们刚刚在add函数中看到的第一个。它 使用显式返回关键字，如下所示:
返回$ a + $ b; 返回调用后，子程序停止执行。return语句后的任何额外代码
不会被执行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">return $a + $b;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在许多情况下，当在子程序体的最后一行计算返回值时， return关键字不是必需的。最后计算的值将是返回值 子程序。考虑到这一点，让我们修改add函数，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y) {
    $x + $y
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>功能的使用没有区别。请注意，不需要分号
块结束。在像前一个这样的简单函数中，这是一件好事
使代码更轻一点。
并非每个子例程都必须返回一个值。它可能有一些副作用，例如， 写入数据库或从子例程主体立即打印。在Raku中，没有 功能和程序之间的区别，例如Pascal。创建一个子 不返回结果，只需使用不带参数的return语句或省略整个</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub print_sum($x, $y) {
    say "$x + $y = ", $x + $y;
}
print_sum(10, 30); # 10 + 30 = 40</code></pre>
</div>
</div>
<div class="paragraph">
<p>return语句本身。例如，让我们修改add子例程，使其打印出来 结果本身。在这种情况下，最好还重命名子例程以使名称
实际上反映了子做的事情:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub width() {
    1.30
}
sub height {
    2.40
}

say width() * height; # Don't follow this practice</code></pre>
</div>
</div>
<div class="paragraph">
<p>学习Raku时，要特别注意函数名和之间的空格 左括号。从第2章，编写代码，我们知道在调用时 函数，子名称和左括号之间不允许有空格。在许多情况下， 但是，根本不需要括号。添加4,5调用的行为完全相同 添加(4,5)。您应该为如何使用括号设计自己的策略 函数调用。
另一个可选部分是参数列表。如果sub不需要它们，你可以 要么使用空括号，要么完全省略它们。在以下示例中，两者都有 使用样式，但最好在程序中坚持使用其中一个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_默认值">6.1. 默认值</h3>
<div class="paragraph">
<p>有时，一个函数，特别是当它需要很多参数时，可以假设一些值 是默认的。在这种情况下，调用代码可以省略默认值。指定默认值 参数的值，在函数签名中的=符号后面添加值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y = 1) {
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用此函数，可以使用一个或两个参数调用函数，如
在以下示例中演示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say add(5, 6); # 11
say add(5);    # 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，如果参数没有默认值(或者不是默认值)，则不能简单地省略它 声明为可选 - 请参阅下一节，可选参数):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y) {
    return $x + $y;
}

say add(5, 6); # OK
say add(5);    # Error</code></pre>
</div>
</div>
<div class="paragraph">
<p>发生以下编译时错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">===SORRY!=== Error while compiling add.pl
Calling add(Int) will never work with declared signature ($x, $y)
at add.pl:6</code></pre>
</div>
</div>
<div class="paragraph">
<p>函数不能包含具有默认值的其他参数。
因此，所有具有默认值的参数必须位于参数列表的末尾。
否则，编译器将无法理解位置参数是什么
传递到子。</p>
</div>
</div>
<div class="sect2">
<h3 id="_可选参数">6.2. 可选参数</h3>
<div class="paragraph">
<p>Raku子程序也允许可选参数。这些参数由表示 签名中的问号。要检查参数是否已通过，请使用内置的 在定义的内置函数中，如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub greet($name, $greeting?) {
    say((defined $greeting) ?? "$greeting, $name!" !! "$name!");
}

greet('John');                 # John!
greet('John', 'Good morning'); # Good morning, John!</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_命名参数">6.3. 命名参数</h3>
<div class="paragraph">
<p>到目前为止，我们已经使用了带有一些参数的subs，并且定义了它们的含义 按他们在参数列表中的位置; 这些论点被称为位置。在Raku中 参数也可以通过名称传递。该命名参数可以出现在功能 在不同的位置打电话。
考虑一个函数的示例，该函数根据数量计算总金额
购买的物品及其价格，并打印总价值。通过常规位置参数，
该函数可能如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub register($item-name, $item-price, $quantity) {
    my $total = $item-price * $quantity;
    my $plural-ending = $quantity &gt; 1 ?? 's' !! '';
    say "$quantity $item-name$plural-ending cost €$total";
}

register('Book', 30, 1); # 1 Book cost €30
register('Book', 30, 5); # 5 Books cost €150</code></pre>
</div>
</div>
<div class="paragraph">
<p>子程序有三个参数，对于最终用户来说，可能会有问题
记住他们必须遵循的顺序。让我们通过给出名称来避免这个问题
参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub register(:$item-name, :$item-price, :$quantity) {
    my $total = $item-price * $quantity;
    my $plural-ending = $quantity &gt; 1 ?? 's' !! '';
    say "$quantity $item-name$plural-ending cost €$total";
}

register(item-name =&gt; 'Book', item-price =&gt; 30, quantity =&gt; 1);
register(item-name =&gt; 'Book', item-price =&gt; 30, quantity =&gt; 5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>命名参数在函数签名中以冒号为前缀。在打电话时 函数，值作为其名称和值的对传递。有两种选择 创建一对的方法 - 使用&#8658;箭头，如前面的例子所示，或者a 冒号，如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">register(:item-name('Book'), :item-price(30), :quantity(1));
register(:item-name('Book'), :item-price(30), :quantity(5));</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你在变量中有函数参数的值，那么 名称与命名参数的名称相同，您可以使用传递值 与sub定义中使用的语法相同，如以下代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $item-name = 'Book';
my $item-price = 30;
my $quantity = 3;

register(:$item-name, :$item-price, :$quantity); # 3 Books cost €90</code></pre>
</div>
</div>
<div class="paragraph">
<p>位置，可选和命名参数以及具有默认值的参数都可以 在同一个子中使用。一般规则是位置参数首先出现，而且 可选，默认为最后。如果您的功能需要太多参数， 也许是时候重新考虑这种方法并引入一些类(我们会 在讨论它们 第8章，面向对象程序设计)，或者使用多分派作为 本章稍后将在Multi subs部分中进行说明。</p>
</div>
</div>
<div class="sect2">
<h3 id="_参数特征">6.4. 参数特征</h3>
<div class="paragraph">
<p>子参数在其体内使用它们。默认情况下，子的参数是 -</p>
</div>
<div class="paragraph">
<p>只有价值; 无法修改子内部的值，如下所示 码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($a) {
    $a = 0;
}

my $x = 10;
f($x);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会导致以下错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot assign to a readonly variable ($a) or a value</code></pre>
</div>
</div>
<div class="paragraph">
<p>有两种方法可以克服这种情况，具体取决于您打算如何使用 修改后的价值 如果仅在子内部需要修改的参数，则创建副本 它的，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($a) {
    my $b = $a;
    $b = 0;
    say "b = $b";
}

my $x = 10;
f($x); # b = 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>为避免创建临时变量，最好通过追加来标记sub的参数 复制特征如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($a is copy) {
    $a = 0;
    say "a = $a";
}

my $x = 10;
f($x);  # a = 0
say $x; # 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想修改原文，Raku提供了另一种可能性 - 即rw特性 变量作为参数传递给sub。在这种情况下，sub之外的变量将具有 通话后的新值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($a is rw) {
    $a = 0;
}

my $x = 10;
f($x);
say $x; # 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用is rw trait，不可能将常量传递给子例程，因为</p>
</div>
<div class="paragraph">
<p>程序将无法修改以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($a is rw) {
    $a = 0;
}

f(5); # Error: Parameter '$a' expected a writable container,
      #        but got Int value</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，检查不太常用的特性是原始的。它的行为有点类似于 是rw trait，但不同之处在于它可以绑定到变量和常量。考虑 下面的两个sub-one的例子是rw trait而另一个是the
原始论点; 子修改其参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($a is rw)  {}
sub g($a is raw) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将变量传递给它时，这两个函数都能正常工作，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 10;
f($x);
g($x);</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果传递一个常量，即没有变量容器的值，则为rw 特质会阻止它被子接受。f(5)调用会发出以下错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Parameter '$a' expected a writable container, but got Int value</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用常量调用g函数仍然有效，尽管你当然不会
能够修改子内部的常量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub g($a is raw) {
    $a = 0;
}

g(5); # Error: Cannot assign to an immutable value</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用替代语法，而不是附加原始特征
反斜杠代替标量符号，如下面的代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub q(\a) {
    a++;
}

my $x = 10;
q($x);
say $x; # 11</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在Raku编译器的源代码中找到反向参数。我们会 请参阅本章后面的“ 创建运算符”部分中的一些示例。</p>
</div>
</div>
<div class="sect2">
<h3 id="_吞噬参数">6.5. 吞噬参数</h3>
<div class="paragraph">
<p>Raku的重要部分是它允许在函数签名中传递数组和散列， 意味着数组作为单个值传递，而不是作为其值列表传递。考虑一下 下面是如何修改add函数以返回all之和的简单示例
数组的元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add(@arr) {
    [+] @arr
}

my @a = &lt;10 20 30&gt;;
say add(@a); # 60</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>[+]</code> 构造是+运算符的简化形式; 看详情第4章， 与运营商合作。它返回@arr数组的所有元素的总和，即 只有sub的参数。
您可以安全地在数组之后向sub添加更多参数。让我们创建一个函数 计算数组的前$ n个元素的总和:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub sum_first(@a, $n) {
    [+] @a[0..$n - 1]
}

my @a = (1..10);
say sum_first(@a, 5); # 1 + 2 + 3 + 4 + 5 = 15</code></pre>
</div>
</div>
<div class="paragraph">
<p>参数不会与@a数组的内容混合在一起。
如果我们尝试使用我们之前创建的add函数来获取元素的总和，该怎么办? 一个数组，由两个值组成?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y) {$x + $y}

my @a = (4, 5);
say add(@a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>代码不会编译:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">===SORRY!=== Error while compiling slurpy.pl
Calling add(Positional) will never work with declared signature ($x, $y) at slurpy.pl:4
------&gt; say add(@a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>sub期望一个数组，但得到两个标量，这是错误的。要让添加功能 接受数组的值，数组应该被展平。也就是说，当传递到 函数，数组成为其值的列表。通过前缀实现展平数组 它们带有垂直条，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y) {$x + $y}

my @a = (4, 5);
say add(|@a); # 9</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在考虑相反的情况 - 你将一个标量列表传递给一个需要的函数 阵列。在这种情况下，您应该将数组参数声明为slurpy。它会消耗掉 标量并将它们累积在一个变量中。这将在下一个示例中进行演示。 slurpy参数以星号为前缀，如以下代码行所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add(*@a) {[+] @a}
say add(3, 4, 5, 6); # 18</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于slurpy数组将使用参数列表的其余部分，因此它应该是最后一个 sub的签名中的参数。</p>
</div>
</div>
<div class="sect2">
<h3 id="_参数占位符">6.6. 参数占位符</h3>
<div class="paragraph">
<p>即使缺少sub的签名，sub仍然可以使用和使用参数。Raku 定义所谓的占位符，它是在子内部具有^ twigil的变量。 我们可以在以下代码中看到这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub greet {
    say "Hello, $^name!";
}

greet('Mark'); # Hello, Mark!</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此代码中，$ ^ name变量获取函数调用时传递的字符串的值。 该值成为sub的只读参数。</p>
</div>
<div class="paragraph">
<p>如果有多个参数，则它们的顺序对应于该字母的字母顺序
占位符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub subtract {
    $^b - $^a
}
say subtract(10, 8); # -2</code></pre>
</div>
</div>
<div class="paragraph">
<p>值10和8位于$ ^ a和$ ^ b变量中。
使用占位符时，函数不能具有与数字冲突的签名 和占位符的类型。因此，在前面的示例中，您无法定义函数 例如greet(){&#8230;&#8203;}或带有空括号的subtract(){&#8230;&#8203;}。</p>
</div>
</div>
<div class="sect2">
<h3 id="_类型约束">6.7. 类型约束</h3>
<div class="paragraph">
<p>在Raku中，您不必声明变量的类型，但如果您愿意，也可以这样做。 相同的规则适用于sub的参数及其返回值。
输入的参数
在本章的前几节中，我们没有说明$ a的类型
和add函数的$ b参数。sub的代码假定参数 应该是数字，因为使用了+运算符。调用具有两个字符串的函数 参数，例如add('Hello'，'World')，将生成以下运行时
错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Cannot convert string to number: base-10 number must begin with valid digits or '.' in ' Hello' (indicated by   )</code></pre>
</div>
</div>
<div class="paragraph">
<p>此异常在运行时发生。虽然编译器看到你传递了两个字符串，但它 不检查是否为该类型的两个参数定义了+操作。有可能的 通过指定sub的类型来防止在编译时出现这种错误 参数，如图所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add(Int $x, Int $b) {
    return $x + $b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>用整数调用sub是可以的。用字符串调用它会增加编译时间 错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">===SORRY!=== Error while compiling add.pl
Calling add(Str, Str) will never work with declared signature (Int $x, Int $b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>调用add(Str，Str)将永远不会使用声明的签名(Int $ x，Int $ B)</p>
</div>
<div class="paragraph">
<p>在sub的声明中，参数列表称为签名。错误消息 告诉我们，我们想要调用的函数的签名不符合
程序中定义的函数的签名。也就是说，它需要调用一个函数 其名称为add，其签名为(Str，Str)。代码包含一个子程序 命名为add，但其签名不同:(Int $ x，Int $ b)。参数的名称 签名检查本身并不重要。
类型约束可以更严格。防止子程序接受 未定义的值，在类型名称后添加:D trait，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add(Int:D $x, Int:D $b) {
    return $x + $b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>仅定义(因此名称:D)值将立即通过类型检查:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a;
my $b = 10;

# add($a, $b); # Run time error because $a is not defined.

add($b, 20);   # Fine. Both operands are Int:D</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_返回类型">6.8. 返回类型</h3>
<div class="paragraph">
<p>从sub返回的值的类型也可以使用特定类型进行归因 约束。在Raku中有三种方法。
第一种方法是签名末尾的箭头:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add(Int $x, Int $y --&gt; Int) {
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种方法是最普遍的。它不仅允许指定返回的类型
值，但也用于给出显式常量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub funky_add(Int, Int --&gt; 100) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>无论参数值如何，此函数将始终返回100。在下一节中，
多子，我们将看到一个更有用的返回常量的应用。 指定返回类型的另一种方法是在签名之间使用of关键字
和sub的主体，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add(Int $x, Int $y) of Int {
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，返回类型可以放在子名称的前面，类似于a的类型 变量已定义。请注意，在这种情况下，您需要将sub声明为my:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int sub add(Int $x, Int $y) {
    return $x + $y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>从sub返回的实际值必须是指定的类型。如果不是，a 发生运行时错误。让我们打破我们的添加函数并返回除法的结果 比添加:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add(Int $x, Int $y --&gt; Int) {
    return $x / $y;
}
say add(1, 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>代码将被编译，但您无法执行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Type check failed for return value; expected Int but got Rat (0.5)
    in sub add at return.pl line 1
    in block &lt;unit&gt; at return.pl line 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，即使结果可以转换为整数，也会发生相同的错误 值，不会丢失数据，如add(10,2)调用。这里的结果类型仍然是Rat，而不是
诠释。
子程序</p>
</div>
</div>
<div class="sect2">
<h3 id="_multi_subs">6.9. Multi Subs</h3>
<div class="paragraph">
<p>签名是子的重要属性。它不仅有助于检查类型
参数，但Raku也使用它来控制传递的参数数量。例如， 声明一个带有三个参数的求和函数，但只用两个参数调用它 参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($x, $y, $z) {
    return $x + $y + $z;
}
say add(1, 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序不起作用。签名是我们的朋友:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">===SORRY!=== Error while compiling add.pl
Calling add(Int, Int) will never work with declared signature ($x, $y, $z)
at add.pl:5</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，我们看到在决定调用哪个函数时，Raku会考虑该数字 参数以及它们的类型以及sub的名称。一个程序员</p>
</div>
<div class="paragraph">
<p>通过创建共享的功能的不同版本，可以从此功能中受益
一样的名字。它们之间的区别将通过其签名解决。
现在让我们将add函数的两个变体放在一起(我将以不同的方式对其进行格式化 时间)。要通知编译器您打算创建多个变体，请添加
 multi 关键字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub add($x, $y)     {$x + $y}
multi sub add($x, $y, $z) {$x + $y + $z}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在可以使用两个或三个参数调用add函数，如图所示
这里:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say add(1, 2);    # 3
say add(1, 2, 3); # 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>子程序
没有理由让编译器现在抱怨。它几乎没有召唤多个潜艇，
取决于呼叫中使用的参数数量。
类似地，类型参数可用于在多个子选择之间进行选择。让它成为可能 使用添加名称添加字符串。为此，可以使用串联运算符(~)。让我们 创建两个具有相同名称和不同签名的函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub add(Int $x, Int $y) {$x + $y}
multi sub add(Str $x, Str $y) {$x ~ $y}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在可以编写以下代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say add(4, 2);     # 6
say add('4', '2'); # 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>将响应这些调用调用不同的函数。而且，尽管如此 '4&#8217;和'2&#8217;字符串只包含数字，它们是Str类型的值 第一名。
类型参数可用于在不同变体之间进行更精细的分离 功能。例如，让我们为Int，Rat和Num值创建三个函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub f(Int) {say 'f(Int)'}
multi sub f(Rat) {say 'f(Rat)'}
multi sub f(Num) {say 'f(Num)'}

f(10);   # f(Int)
f(20/2); # f(Rat)
f(1E1);  # f(Num)</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例仅用于演示Raku如何选择多子的正确候选。 这些函数对参数没有任何用处，我甚至没有给出一个 参数的名称。从输出中可以看出(参见前面的注释) 代码)，这三个调用指的是三个不同的多子。
使用multi，可以省略sub关键字，如下面的代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi f(Int) {say 'f(Int)'}
multi f(Rat) {say 'f(Rat)'}
multi f(Num) {say 'f(Num)'}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multi subs可以做得更多。可以根据不同的方式路由多个分派 类型，也是价值观。例如，让我们创建一个带有Num值和a的子 仅应为Pi的值触发的单独子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub f(pi) {say 'The value of Pi is well-known!'}
multi sub f(Num $n) {say "Value is $n"}

f(pi); # The value of Pi is well-known!
f(e);  # Value is 2.71828182845905</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种方法也适用于其他类型的其他数据; 例如，字符串。
最后，multi subs非常适合用户创建的类型。我们将讨论使用 第8章中的课程，面向对象的编程。所以，让我们创建一个子类型并拆分 价值分为两组。
我们创建了两个subs，其中一个接受一个Str参数，另一个只接受 短于十个字符的字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub message(Str $str) {
    '&lt;p&gt;' ~ $str ~ '&lt;/b&gt;'
}
multi sub message(Str $str where {$str.chars &lt; 10}) {
    q{&lt;p class="large"&gt;} ~ $str ~ q{&lt;/p&gt;}
}

say message('Hi!');
say message('The weather is fine today');</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序打印带有消息的HTML代码，但添加了一个CSS类来制作字体 短文更大:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;p class="large"&gt;Hi!&lt;/p&gt;
&lt;p&gt;The weather is fine today&lt;/p&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_一个例子">6.10. 一个例子</h3>
<div class="paragraph">
<p>总结一下我们对多子的知识，让我们创建一个递归计算的例子
斐波纳契数。我们还将在此代码中使用类型约束:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub fibonacci(0 --&gt; 0) {}
multi sub fibonacci(1 --&gt; 1) {}
multi sub fibonacci(Int $n --&gt; Int) {
    return fibonacci($n - 1) + fibonacci($n - 2);
}

my @fib;
push @fib, fibonacci($_) for 1..10;
@fib.join(', ').say;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里使用multi subs来引导递归的fibonacci($ n - 1)+ 斐波纳契($ n - 2)公式为$ n的值小于2.前两个变体
fibonacci sub响应0和1的值而不是返回sub中的整数 在body中，我们将使用箭头语法指定签名中的返回值，如图所示
这里:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub fibonacci(0 --&gt; 0) {}
multi sub fibonacci(1 --&gt; 1) {}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_嵌套的子程序">6.11. 嵌套的子程序</h3>
<div class="paragraph">
<p>子程序可以嵌套。换句话说，您可以在另一个子内部定义一个子。让我们
在下一个例子中看到它，它列出了常规英语动词的现在时态:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub list_verb_forms($verb) {
    sub make_form($base, $pronoun) {
        my $form = $base;
        # Adds the 's' ending for he, she, and it.
        # The check uses a regular expression.
        # We cover regular expressions in Chapter 11, Regexes.
        $form ~= 's' if $pronoun ~~ /^ [ he | she | it ] $/;

        return "$pronoun $form";
    }

    my @pronouns = &lt;I we you he she it they&gt;;

    for @pronouns -&gt; $pronoun {
        say make_form($verb, $pronoun);
    }
}

list_verb_forms('read');</code></pre>
</div>
</div>
<div class="paragraph">
<p>list_verb_forms函数迭代@pronouns数组中的代词列表 并为每个子程序调用make_form子程序。因为我们不需要第二个 在代码中的任何地方，将其范围限制在第一个子体的主体是合乎逻辑的。
将子嵌套在另一个子中使其对其余代码不可见。你不能打电话 make_form子在list_verb_forms体外的任何地方:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>未申报的例程:
make_form在第20行使用
创建运营商
Raku中的运算符是子例程。在大多数情况下，operator subs是multisubs。考虑， 例如，<code>+</code> 运算符。它的语义是添加两个值，而这些值又可以是 不同种类。您可以要求Raku添加两个整数，浮点或复数 数字。或者，操作数可以在同一调用中具有不同类型，例如，在添加时 复数和整数。相同的+运算符也适用于类型 代表日期。为了实现所有这些灵活性，Raku使用了多个sub。
让我们简要介绍一下Rakudo的源代码，并搜索一些+的定义 运营商:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>Rakudo编译器部分用Raku编写，因此您可以轻松理解 这些摘录中的函数标题。
在Raku中，还可以创建可在代码中使用的自定义运算符。也， 可以扩展运算符对程序中创建的类型的行为。
例如，如果您希望+运算符连接字符串，只需定义其行为即可 对于字符串操作数，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>您很可能还需要考虑其他可能的组合 操作数类型。想象一下，我们正在创建代码来打印错误消息并希望如此 使用+运算符追加一个数字，如图所示:
说&#8217;线上错误' <code>+</code> 5; 这不起作用，因为 <code>+</code> 运算符没有候选者接受字符串和
整数。其中一个替代方法是执行类型转换: 说&#8217;线上错误'+ ~5;
现在我们有两个字符串和中缀:&lt;&gt;(Str，Str)运算符将被选中 编译器。
为了使开发人员的工作更轻松，最好为其定义更多变体 操作员使他们的使用变得直观。所以，让我们将中缀:&lt;&gt;(Str，Int)添加到我们的 采集:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>也许你还需要定义一个以整数为左侧的运算符
操作数和字符串作为右边的一个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们所见，创建新的运算符是一项非常负责任的任务。你应该思考和
预测可能的用例并定义相应的子例程。
在前面的示例中，我们使用了Raku中已有的操作符之一 您的程序，您还可以定义一个新的运算符并选择运算符的外观 你自己。下面的示例定义了一个名为plus的中缀运算符，它将两个运算符相加 类似于+运算符的整数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>定义新运算符时，请确保代码用户明确其语义。 例如，如果为字符串操作数定义+运算符，则可能会令人困惑
在以下示例中演示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有重新定义的中缀运算符，则“4”“9”将返回13，因为两个操作数都是 转换为数字值。用中缀:&lt;&gt;(Str，Str)定义，程序 打印49，因为操作数是字符串，并且有一个接受两个字符串的中缀子
参数。
将函数作为参数传递
Raku中的函数可以作为参数传递给其他函数。一个典型的例子是 排序算法，需要一个函数来比较两个值。它取决于数据类型 可以是知道如何比较该类型的值的不同函数。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>子程序 让我们来看看以下微小的例子:</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>比较(10,20，及更少); #True 比较(10,20和更多); #False
主代码使用三个参数调用compare子 - 两个整数和一个 参考其中一个功能 - &amp;less或&amp;more。名字前面有一个&amp;符号告诉我们 此时不应调用函数(请记住，在Raku中，括号是 调用函数时不需要)。
在比较函数内部，第三个参数$ f是对函数的引用。您可以 现在通过附加参数列表来调用引用的函数 - $ f($ a，$ b)。这将 相当于调用less($ a，$ b)或更多($ a，$ b)。
$ f参数的类型是Sub; 我们可以为子签名添加一个类型约束 强制使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，$ f $ a，$ b的调用将不会被编译，因为$ f不是sub的名称。
这里的括号是。()postcircumfix call- $ f。($ a，$ b)的缩写形式。
匿名潜艇
没有名称的子程序称为匿名子程序。你不能通过名字来称呼它，但是 它仍然可以通过句柄运行，例如，句柄存储在变量中。一切 常规子的属性，例如签名和正文，以与以下相同的方式定义 正常的潜艇。
在下面的代码中，我们将创建一个匿名子并将其保存在$ add变量中; 一个 需要签名前的空格:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku允许常规和匿名潜艇的混合。anon关键字创建一个 匿名sub出了常规的，所以它的名字仍然可以用来调用它。首先，看看 sub，既可以作为匿名使用，也可以通过名称调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，让我们使用anon关键字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过$ add变量调用函数很好，同时尝试通过它调用函数 名称甚至无法编译 - Raku不会将添加名称放在本地表中 符号，因为匿名明确禁止。
您也可以使用匿名代码块代替匿名子代码。他们叫 尖头块，因为他们使用箭头，如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>匿名子块和尖头块之间的区别在于它们返回的对象 不同种类。子类型为Sub，而尖头块创建块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在Raku对象系统的层次结构中，Sub类是Routine类的子类，它是 是Block的孩子。Routine类为我们提供了其他功能，例如 添加特征或使子成为多子。
另请注意，尖括号的参数未列在括号中。如果你
添加它们，Raku会认为你想在调用一个块时传递一个数组。这是 在以下示例中演示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>传递两个参数会导致以下异常:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_6">6.12. 总结</h3>
<div class="paragraph">
<p>期望2个参数但在子签名中得到0
子程序或子程序是Raku的基石之一。在本章中，您学习了如何使用它 创建和使用子程序。我们详细检查了子参数的属性， 例如通过复制传递参数，允许读写参数，定义 默认值，或提供可选参数。你看着邋.. 参数和展平数组，学会了如何约束两个参数的类型，
然后返回值。</p>
</div>
<div class="paragraph">
<p>最重要的是，讨论了子程序的其他应用程序。也就是说，我们谈了 关于使用multi关键字重载subs，看看新运算符是如何的</p>
</div>
<div class="paragraph">
<p>创建并嵌入在语言中，以及如何将函数传递给其他函数。和，
最后，我们简要介绍了匿名函数和尖代码块。
在下一章中，我们将讨论模块，它们是封装代码的下一级 在Raku中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_创建和调用子例程">6.13. 创建和调用子例程</h3>

</div>
<div class="sect2">
<h3 id="_类型约束_2">6.14. 类型约束</h3>

</div>
<div class="sect2">
<h3 id="_multi_subs_2">6.15. Multi subs</h3>

</div>
<div class="sect2">
<h3 id="_嵌套子例程">6.16. 嵌套子例程</h3>

</div>
<div class="sect2">
<h3 id="_创建运算符">6.17. 创建运算符</h3>

</div>
<div class="sect2">
<h3 id="_传递函数作为参数">6.18. 传递函数作为参数</h3>

</div>
<div class="sect2">
<h3 id="_匿名子例程">6.19. 匿名子例程</h3>

</div>
<div class="sect2">
<h3 id="_总结_7">6.20. 总结</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_模块">7. 模块</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在上一章中, 我们讨论了子例程。子程序使代码更易读, 也更容易重用。</p>
</div>
<div class="paragraph">
<p>本章将涵盖以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在模块中组织代码</p>
</li>
<li>
<p>加载模块</p>
</li>
<li>
<p>导出名称</p>
</li>
<li>
<p>内省</p>
</li>
<li>
<p>模块位置</p>
</li>
<li>
<p>安装和卸载模块</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_创建模块">7.1. 创建模块</h3>
<div class="paragraph">
<p>Raku 中模块的作用是将代码保存在不同的文件中。它可能是由你自己开发的几个函数组成的简单库, 也可能是一个由外部公司开发的大类集合。无论如何, 如果你使用了一个模块, 你就可以获得前人的工作能力, 并且有一个接口来实现这个功能。</p>
</div>
<div class="paragraph">
<p>在本章中, 我们将讨论用模块组织代码, 并在程序中使用模块。</p>
</div>
<div class="paragraph">
<p>让我们创建我们的第一个模块, 让我们以前面几章中开拓的数字加法的简单任务为例, 比如在第2章《编写代码》中。</p>
</div>
<div class="paragraph">
<p>所以, 我们有一个加法函数, 用于将两个数字相加, 以及使用该函数的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($a, $b) {
    return $a + $b;
}

my $a = 10;
my $b = 20;
my $sum = add($a, $b);
say $sum; # 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们目前的目标是将 <code>add</code> 函数的代码放到一个独立的模块中, 然后在主程序中使用该模块。</p>
</div>
<div class="paragraph">
<p>Raku 的模块通常被保存在以 <code>.pm</code> 为扩展名的文件中(这代表着 Perl 模块)。如果由于某种原因, 你想强调 Raku 的用法, 以区别于 Perl 5, 你可以使用 <code>.pm6</code> 扩展名; 在这种情况下, 你最好使用 <code>.p6</code> 作为 Raku 程序的扩展名。</p>
</div>
<div class="paragraph">
<p>让我们为这个例子创建一个文件, 并将函数的代码复制到这个文件中。然而, 这还不够。模块必须要有一个名字, 这个名字在 <code>unit module</code> 指令中提到, 放在文件的开头。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module Add;

sub add($a, $b) {
    return $a + $b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>模块的名称和对应的文件名最好保持一致。在我们的案例中, <code>Add</code> 模块位于文件 <code>Add.pm</code> 中。在本章后面的 Rakudo 如何存储模块一节中, 你会看到 Rakudo 如何管理文件名和模块名之间更复杂的关系。</p>
</div>
<div class="paragraph">
<p>现在, 让我们尝试使用该模块, 并重写主程序, 使其从模块中调用一个函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Add;

my $a = 10;
my $b = 20;
my $sum = add($a, $b);
say $sum;</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意这个文件的开头有一个指令 <code>use Add;</code>。为了满足这个要求, Raku 会找到并加载相应的模块文件。</p>
</div>
<div class="paragraph">
<p>但我们的代码还不能工作。让我们试着执行它, 然后再试着定位错误。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">$ raku main.pl
===SORRY!===
Could not find Add at line 1 in:
    /Users/ash/.raku
    /Applications/Rakudo/share/raku/site
    /Applications/Rakudo/share/raku/vendor
    /Applications/Rakudo/share/raku
    CompUnit::Repository::AbsolutePath<i class="conum" data-value="140518513192432"></i><b>(140518513192432)</b>
    CompUnit::Repository::NQP<i class="conum" data-value="140518512012576"></i><b>(140518512012576)</b>
    CompUnit::Repository::Perl5<i class="conum" data-value="140518512012616"></i><b>(140518512012616)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见, 编译器无法找到 <code>Add.pm</code> 文件。它试图在几个被认为是默认的目录中搜索, 但失败了。由于该文件保存在和 <code>main.pl</code> 文件所在的同一个目录中, 我们可以帮助编译器, 使用命令行选项 <code>-I</code> 给它提供位置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku -I . main.pl</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 模块文件找到了, 但我们仍然得到一个错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">===SORRY!=== Error while compiling /Users/ash/code/modules/main.pl Undeclared routine:
add used at line 5. Did you mean 'dd'?</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在的问题是, 编译器不知道 <code>add</code> 这个名字。我们在模块里有一个带这个名字的函数, 但使用该模块的代码却看不到它。为了解决这个问题, 我们必须通知编译器这个名字是导出的, 可以在模块之外使用。在函数中附加 <code>is export</code> trait:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module Add;

sub add($a, $b) is export {
    return $a + $b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这个, 我们终于可以运行程序, 得到理想的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ perl6 -I . main.pl
30</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有 <code>is export</code> 特性, 模块的任何函数都会被隐藏起来, 可以作为模块内部的内部机制使用, 不会暴露在你的代码中。这有助于解决程序中不同部分的函数之间的名称冲突, 同时也允许更好地与模块接口—它只导出真正需要导出的函数。</p>
</div>
<div class="paragraph">
<p>另外, 你可以在主代码中使用 <code>-M</code> 选项来请求加载模块, 而不是在主代码中明确的使用 <code>use Add;</code> 指令:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ perl6 -M Add -I . main.pl
30</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了简化命令和避免重复指令, 可以通过 <code>PERL6LIB</code> 环境变量传递模块的路径:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ export PERL6LIB=.
$ perl6 main.pl</code></pre>
</div>
</div>
<div class="paragraph">
<p>多个目录之间必须用逗号隔开:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ export PERL6LIB=/Users/ash/lib,/Users/ash/code/modules
$ perl6 main.pl</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用模块">7.2. 使用模块</h3>
<div class="paragraph">
<p>在上一节中, 我们创建了一个简单的模块, 其中有一个函数, 并在程序中使用了这个模块。在本节中, 我们将探讨 Raku 如何加载模块及其函数的其他方法。</p>
</div>
<div class="paragraph">
<p>有四个关键词, 我们要探讨的是 <code>use</code>、<code>need</code>、<code>requird</code> 和 <code>import</code>。它们都是在加载模块的上下文中使用的, 但它们的行为方式有些不同。</p>
</div>
<div class="paragraph">
<p>使用一个模块至少有两个条件：第一, 必须找到并编译模块文件；第二, 模块中的名字(如子程序或变量)对程序来说应该是可见的。</p>
</div>
<div class="sect3">
<h4 id="_need_关键字">7.2.1. need 关键字</h4>
<div class="paragraph">
<p><code>need</code> 关键字在编译时加载一个模块, 但不会从模块中导入名称。加载一个模块也意味着其中的所有指令都将被执行。同时, <code>BEGIN</code> 块也将被运行。让我们在模块中添加一些打印指令, 看看它是如何改变输出的。</p>
</div>
<div class="paragraph">
<p>下面是新的模块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module Add;

say 'Start';

sub add($a, $b) is export {
    return $a + $b;
}

BEGIN {
    say 'This is Add.pm';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在主程序中, 我们这次使用 <code>need</code> 而不是 <code>use</code>, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">need Add;

my $a = 10;
my $b = 20;
my $sum = add($a, $b);
say $sum;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为模块中的函数没有导入到程序中, 所以不会出现模块本身的输出, 不过, 模块本身的输出会出现(<code>BEGIN</code> 模块是先触发的, 就像普通程序一样)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ perl6 -I . main.pl
This is Add.pm
Start
===SORRY!=== Error while compiling /Users/ash/code/modules/main.pl Undeclared routine:
add used at line 5. Did you mean 'dd'?</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_import_关键字">7.2.2. import 关键字</h4>
<div class="paragraph">
<p><code>import</code> 关键字从模块中导入具有 <code>export</code> 特征的名称。</p>
</div>
<div class="paragraph">
<p>结合 <code>need</code>, <code>import</code> 完成了从模块中获取功能的过程。让我们来更新程序并运行它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">need Add;
import Add;

say add(10, 20);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次, 一切正常, 程序打印出了 <code>add</code> 函数返回的结果。考虑一下下面的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ perl6 -I . main.pl
This is Add.pm
Start
30</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, 光有 <code>import</code> 是不足以加载模块的。它应该遵循 <code>need</code> 指令。</p>
</div>
<div class="paragraph">
<p><code>need</code> 和 <code>import</code> 都是在编译时发生的。这意味着, 在程序编译后, 这些指令在主程序之前执行。从实际的角度来说, 这意味着你不应该考虑这些指令在程序中的位置。例如, 下面的程序仍然可以工作, 而 <code>need</code> 和 <code>import</code> 对位于代码的末尾。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say add(10, 20); # 30

need Add;
import Add;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_use_关键字">7.2.3. use 关键字</h4>
<div class="paragraph">
<p><code>use</code> 关键字实际上是作为 <code>need</code> 和 <code>import</code> 的组合来工作的。同样的, 它在编译时工作, 所以 <code>use</code> 指令的实际位置并不重要（但请看本章后面的《作用域》部分）。</p>
</div>
<div class="paragraph">
<p>这个关键字是加载模块的最简单、最直接的方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Add;

say add(10, 20); # 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦模块被加载, <code>use</code> 就会自动从模块中导入名称, 它们就会在程序的其他部分中变得可用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_require_关键字">7.2.4. require 关键字</h4>
<div class="paragraph">
<p>最后一个关键字, <code>require</code>, 在运行时加载一个模块。因此, 顺序很重要。为了从模块中访问函数, 我们现在需要完全限定的名称。反过来, 要想让模块使用它的函数, 就必须借助于 <code>our</code> 关键字, 对它们进行不同的作用域化处理。</p>
</div>
<div class="paragraph">
<p>下面的代码就是新版的文件 <code>Add.pm</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module Add;

our sub add($a, $b) {
    return $a + $b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而这里有一个程序, 需要该模块, 并使用其全名引用 <code>add</code> 函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">require Add;

say Add::add(10, 20); # 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, 完全限定的名称是在 <code>::</code> 的帮助下构造的。在下一个例子中, 我们将使用存储在一个变量中的模块名, 这个模块名可能会在程序的其他部分中以某种方式改变, 然后才需要这个模块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $module = 'Add.pm';
# ...
require $module '&amp;add';
say add(10, 20); # 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里, <code>add</code> 例程是从 <code>Add.pm</code> 模块中导入的。它应该在那里标记为 <code>is export</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module Add;

our sub add($a, $b) is export {
     return $a + $b;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_作用域">7.2.5. 作用域</h4>
<div class="paragraph">
<p>上面列举了四个加载模块的指令, 以及导入名称的是如何被作用域化的, 例如, 在主代码中的函数内部, 可以对其进行作用域化。在这种情况下, 它们的行为被限制在给定的作用域内。</p>
</div>
<div class="paragraph">
<p>例如, 如果 <code>add</code> 函数只在某些函数内部被需要, 就不需要全局加载模块, 如下面的例子所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say do_calc();

sub do_calc {
    use Add;
    return add(10, 20);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要知道, 虽然导出的名称的作用域只限于 <code>do_calc</code> 函数, 但在编译时仍然会加载模块。让我们修改一下程序和模块, 看看会发生什么情况。</p>
</div>
<div class="paragraph">
<p>在程序中添加一个简单的 <code>say</code> 指令:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Starting a program';
say do_calc();

sub do_calc {
    use Add;
    return add(10, 20);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以同样的方式, 将其添加到模块中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module Add;

say 'Starting a module';

sub add($a, $b) is export {
    return $a + $b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 运行程序, 确认程序启动执行前, 模块已经加载完毕。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku -I . main.pl
Starting a module
Starting a program
30</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想有条件地加载一个模块, 使其只在特定条件下或在特定的代码分支中发生, 请使用 <code>require</code> 关键字。在这种情况下, 你可以根据程序的流程轻松地加载所需的模块。考虑一下上一个程序的变体。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Starting a program';
say do_calc();

sub do_calc {
    require Add;
    return Add::add(10, 20);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下, 输出会不一样（别忘了在模块中的函数前加上 <code>our</code>）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku -I . main.pl
Starting a program
Starting a module
30</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_更多关于_is_export_的信息">7.2.6. 更多关于 is export 的信息</h4>
<div class="paragraph">
<p>我们在前面的章节中看到, <code>is export</code> 特征的使用并不局限于导出子例程。</p>
</div>
<div class="sect4">
<h5 id="_导出变量">导出变量</h5>
<div class="paragraph">
<p>可以从模块导出变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module Credentials;

our $username is export = 'alpha'</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用这个变量就像使用常规变量一样简单:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Credentials;

say "User = $username";</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_选择性导出">7.2.7. 选择性导出</h4>
<div class="paragraph">
<p>有时, 一个模块可能提供了大量的功能, 而程序只使用了其中的一部分。在这种情况下, 你可以用这样的方式来组织一个模块, 以便只导出有限的名称集合。Raku 提供了一种标记名称的机制, 如下面所示的模块示例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module Math;

sub add($a, $b) is export(:plusminus) {
       return $a + $b;
}

sub subtract($a, $b) is export(:plusminus) {
    return $a - $b;
}

sub mul($a, $b) is export(:muldiv) {
    return $a * $b;
}

sub div($a, $b) is export(:muldiv) {
    return $a / $b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个模块中, 有两个函数的集合：两个用 <code>:plusminus</code> 标签, 两个用 <code>:muldiv</code> 标签。</p>
</div>
<div class="paragraph">
<p>在导入模块时, 使用该标签选择要导入的名称。例如, 让我们只导入 <code>add</code> 和 <code>subtract</code> 这两个函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Math :plusminus;

say add(10, 20);
say subtract(20, 10);</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外两个函数, <code>mul</code> 和 <code>div</code>, 在导入时将无法使用。要允许使用这两个函数, 请用不同的标签重新导入模块, 或者如下面的例子所示, 列出所有需要的标签。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Math :plusminus, :muldiv;

say add(10, 20);
say subtract(20, 10);

say mul(1, 2);
say div(5, 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>有三个预定义的标签--<code>:ALL</code>、<code>:DEFAULT</code> 和 <code>:MANDATORY</code>。</p>
</div>
<div class="paragraph">
<p><code>:ALL</code> 标签会导入所有带任何 <code>is export</code> trait的名字。这包括一个没有标签的裸露的 trait, 一个带有命名标签的 trait 或者一个带有 <code>:ALL</code> 标签的 trait。例如, 你可以用一个具有相同效果的单行来代替上一个例子中的两个使用行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Math :ALL;</code></pre>
</div>
</div>
<div class="paragraph">
<p>带有 <code>:DEFAULT</code> 标签的 <code>use</code> 指令会加载这些名称, 这些名称是用 <code>is export</code> 特征创建的, 没有任何标签。</p>
</div>
<div class="paragraph">
<p>最后, 为了强制导入一个名称, 无论导入方法如何, 在模块中标记为 <code>is export(:MANDATORY)</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_内省">7.3. 内省</h3>
<div class="paragraph">
<p>Raku 模块包含一个机制, 它允许你获得关于模块内容的信息。获取这种元信息被称为内省。</p>
</div>
<div class="paragraph">
<p>以上一节 <code>Math.pm</code> 模块为例, <code>Math.pm</code> 模块在上一节《更多关于 is export 的信息》中的内容为例。这样我们就可以列举出该模块导出的所有方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Math;

say Math::EXPORT::.keys;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里指的是默认的 <code>EXPORT</code> 子例程, 是编译器为我们生成的。<code>sub</code> 返回一个 <code>EXPORT</code> 类型的对象, 它实现了 <code>Perl6::Metamodel::PackageHOW</code> 接口。我们不会深入研究这个理论, 只限于调用一个有用的方法 <code>keys</code>, 它可以给我们提供模块中可用的标签列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(plusminus muldiv ALL)</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了标签的列表, 我们可以对其进行迭代, 得到属于它们的子例程列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Math;

say Math::EXPORT::plusminus::.keys;
say Math::EXPORT::muldiv::.keys;
say Math::EXPORT::ALL::.keys;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序打印出以下三行, 每一个标签一个。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">(&amp;add &amp;subtract)
(&amp;mul &amp;div)
(&amp;mul &amp;div &amp;add &amp;subtract)</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以, 你可以清楚地看到 <code>:plusminus</code> 标签对应的是 <code>add</code> 和 <code>subtract</code> 函数, <code>:muldiv</code> 标签对应的是 <code>mul</code> 和  <code>div</code>, 而 <code>:ALL</code> 标签则给出了所有导出的函数列表。同样的, 如果我们把子例程标记为 <code>is export :DEFAULT</code> 或 <code>is export :MANDATORY</code>, 我们可以用同样的方法请求它们的列表。</p>
</div>
<div class="paragraph">
<p>现在, 让我们继续在 Raku 中自动化管理模块的过程。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_zef">7.4. 使用 zef</h3>
<div class="paragraph">
<p>请注意, 本节介绍的是 Rakudo Star 发行版特有的工具。在编写本文的时候, Rakudo 是市场上唯一的生产就绪的 Raku 编译器。如果你刚好使用其他编译器, 请查看它们的文档, 了解如何安装模块。</p>
</div>
<div class="paragraph">
<p>Rakudo Star 发行版自带了一个名为 zef 的模块管理工具。请注意, 从 Rakudo Star 2017.01 版本开始, 它就已经是发行版的一部分了。早期的版本包括另一个工具 panda, 现在已经过时了。</p>
</div>
<div class="paragraph">
<p>zef 是一个用 Raku 编写的命令行工具。安装 Rakudo Star 后, 它的可执行文件会在 Rakudo/share/perl6/site/bin 目录下。Rakudo 安装程序还修改了 PATH 环境变量, 使其包含了一个正确的路径, 可以到达该发行版的可执行文件的目录。</p>
</div>
<div class="paragraph">
<p>这个工具使用的是 Raku 模块的生态系统, 目前还在积极开发中。要了解更多信息, 请访问 <a href="modules.raku.org" class="bare">modules.raku.org</a> 页面, 其中包含了数百个适用于 Raku 和 zef 的模块列表。</p>
</div>
<div class="paragraph">
<p>要获得 zef 的帮助, 请使用 -h 命令行选项运行它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">zef -h</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们来探讨一下最有用的命令。</p>
</div>
<div class="sect3">
<h4 id="_安装模块">7.4.1. 安装模块</h4>
<div class="paragraph">
<p>要安装一个模块, 请使用 <code>install</code> 命令, 并给出模块名称, 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ zef install XML</code></pre>
</div>
</div>
<div class="paragraph">
<p>在安装一个模块之前, 你可以通过要求 Raku 6用 <code>-M</code> 命令行选项加载模块来快速检查你是否已经安装了它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ perl6 -M XML -e1</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有这样的模块, 你会收到一条错误消息, 列出 Raku 在试图找到该模块时扫描的文件夹。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">===SORRY!===
   Could not find XML at line 1 in:
   /Users/ash/.perl6
   /Applications/Rakudo/share/perl6/site
   /Applications/Rakudo/share/perl6/vendor
   /Applications/Rakudo/share/perl6</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么, 我们就来安装吧。如果一切顺利, 模块就会安装完毕, 你就可以马上开始使用了。安装过程的输出可能看起来像下面这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ zef install XML
===&gt; Searching for: XML
===&gt; Fetching: XML
===&gt; Testing: XML:ver('0.0.2'):auth('Timothy Totten')
t/comments.t .......... ok
t/emitter.t ........... ok
t/example.t ........... ok
t/make.t .............. ok
t/namespaces.t ........ ok
t/open-xml.t .......... ok
t/parser.t ............ ok
t/preamble.t .......... ok
t/proxies.t ........... ok
t/query-methods.t ..... ok
t/query-positional.t .. ok
All tests successful.
Files=11, Tests=127, 9 wallclock secs
Result: PASS
===&gt; Testing [OK] for XML:ver('0.0.2'):auth('Timothy Totten')
===&gt; Installing: XML:ver('0.0.2'):auth('Timothy Totten')</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中, 我们安装了 XML 模块, 它不需要任何依赖关系。输出中显示了安装过程的不同阶段&#8212;&#8203;首先, zef 寻找分布式文件的位置, 然后下载, 测试, 最后安装到正确的位置。</p>
</div>
<div class="paragraph">
<p>zef 的任务是在互联网上找到分布式文件的位置, 然后下载并解压。该实用程序可以理解几种格式, 下面从文档中摘录的内容就很好地证明了这一点。</p>
</div>
<div class="paragraph">
<p>首先, 可以通过模块的名称来搜索, 也可以通过作者或版本号来搜索。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ zef install CSV::Parser
$ zef install "CSV::Parser:auth&lt;tony-o&gt;:ver&lt;0.1.2&gt;"
$ zef install "CSV::Parser:ver('0.1.2')"</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么, 可以通过本地路径来安装模块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ zef install ./Perl6-Net--HTTP</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 zef 不能推断出模块的 URL（可能会发生, 例如, 如果模块没有被列在 <a href="modules.raku.org" class="bare">modules.raku.org</a> 上）, 那么可以显式地指定 URL。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ zef -v install git://github.com/ugexe/zef.git
$ zef -v install https://github.com/ugexe/zef/archive/master.tar.gz
$ zef -v install https://github.com/ugexe/zef.git@v0.1.22</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, zef 会显示它正在安装的模块的全部细节, 以及它的版本和作者。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">===&gt; Installing: XML:ver('0.0.2'):auth('Timothy Totten')</code></pre>
</div>
</div>
<div class="paragraph">
<p>其他模块可能需要依赖, 而 zef 会尽量满足它们。例如, 安装 <code>XML::XPath</code> 会导致安装一些其他模块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ zef install XML::XPath
===&gt; Searching for: XML::XPath
===&gt; Searching for missing dependencies: Test::META
===&gt; Searching for missing dependencies: META6
===&gt; Searching for missing dependencies: JSON::Class
===&gt; Searching for missing dependencies: JSON::Marshal, JSON::Unmarshal
===&gt; Searching for missing dependencies: JSON::Name
===&gt; Fetching: XML::XPath
===&gt; Fetching: Test::META
===&gt; Fetching: META6
===&gt; Fetching: JSON::Class
===&gt; Fetching: JSON::Unmarshal
===&gt; Fetching: JSON::Marshal
===&gt; Fetching: JSON::Name
...</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>install</code> 命令也可以接受完全限定的模块名称, 所以如果你需要安装某个版本, 就说清楚。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ zef install "XML:ver('0.0.2'):auth('Timothy Totten')"</code></pre>
</div>
</div>
<div class="paragraph">
<p>zef 还支持从指定的 URL 或文件中安装。</p>
</div>
</div>
<div class="sect3">
<h4 id="_搜索模块">7.4.2. 搜索模块</h4>
<div class="paragraph">
<p>在安装模块之前, 最好先看看还有哪些其他模块存在, 或者出现了哪些其他版本的模块。请使用 <code>search</code> 命令:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ zef search Time
===&gt; Found 14 results</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后是一个表格, 显示所有找到的模块及其版本和简要说明。</p>
</div>
</div>
<div class="sect3">
<h4 id="_卸载模块">7.4.3. 卸载模块</h4>
<div class="paragraph">
<p>要卸载模块, 请使用 <code>uninstall</code> 命令:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ zef uninstall XML
===&gt; Uninstalled from /Applications/Rakudo/share/perl6/site XML:ver('0.0.2'):auth('Timothy Totten')</code></pre>
</div>
</div>
<div class="paragraph">
<p>s如果一个模块是和它的依赖项一起安装的, 那么它们不会被移除。例如, 让我们尝试卸载 <code>XML::XPath</code> 模块, 我们在本章前面的《安装模块》一节中安装了这个模块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ zef uninstall XML::XPath
===&gt; Uninstalled from /Applications/Rakudo/share/perl6/site XML::XPath:ver('0.9.0')</code></pre>
</div>
</div>
<div class="paragraph">
<p>仅此而已。其他的依赖模块, 比如说 <code>JSON:::Class</code>, 还在那里。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ perl6 -MJSON::Class -e'say 1'
1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_zef_命令摘要">7.4.4. zef 命令摘要</h4>
<div class="paragraph">
<p>zef 是 Raku 的默认模块管理器。下表总结了它提供的命令。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">命令</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">install</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">按名称或路径安装特定模块</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uninstall</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">卸载指定的发行版</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">test</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在给定模块的路径上运行测试</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fetch</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获取和提取模块的源码</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">build</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在给定模块的路径中运行 Build.pm。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">look</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fetch, 然后在模块的路径中进行 shelling。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">update</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">更新版本库的软件包索引</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">search</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示给定条件的可能的发行版候选列表</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">info</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示详细的发行版信息</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">list</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">列出已知的现有发行版情况</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">list --installed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">列出已安装的发行版</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rdepends</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根据给定的模块直接列出所有的发行版情况</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">locate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">查询已安装的模块信息</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">smoke</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在现有模块上运行 smoke 测试</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>关于如何使用 zef 的更多信息可以在 <a href="github.com/ugexe/zef" class="bare">github.com/ugexe/zef</a> 项目页面上找到。</p>
</div>
</div>
<div class="sect3">
<h4 id="_rakudo_如何存储模块">7.4.5. Rakudo 如何存储模块</h4>
<div class="paragraph">
<p>Raku 中的模块由三个参数来引用：模块名、作者名和模块版本。传统上, 在 Perl 5 中, 模块名是直接映射到文件系统中的, 但在Raku 中, 我们需要处理三个维度。在这一节中, 我们将看一看 Rakudo 和 zef 存储模块的目录, 并跟踪模块的参数信息。</p>
</div>
<div class="paragraph">
<p>让我们来看看 Rakudo 是如何在文件系统中保存模块的, 以 <code>XML::XPath</code> 模块为例。</p>
</div>
<div class="paragraph">
<p>在 Rakudo 的安装目录中（在 macOS 上是 /Applications/Rakudo）, 你会发现以下四个目录。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">bin
include
lib
share</code></pre>
</div>
</div>
<div class="paragraph">
<p>模块位于 <code>share</code> 目录的树内。每个模块可能至少有三个文件。首先, 在 share/perl6/site/dist 目录下有一个 JSON 文件, 其中包含了模块和其他模块的描述, 这些模块和其他模块一起安装在同一个发行版中。这些文件的名称是一些基于哈希的标识符。对于我电脑上的 <code>XML::XPath</code> 版本, 这个是 1DB52FD58FC401775EFFF9619F334A566BAA495F。</p>
</div>
<div class="paragraph">
<p>我们来看看里面的情况。这个文件比较大, 所以我们在这里就不完全复制, 只限于最明显的几行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "id" : "1DB52FD58FC401775EFFF9619F334A566BAA495F",
  "name" : "XML::XPath",
  "files" : { },
  "api" : null,
  "support" : { },
  "source-url" : "git://github.com/ufobat/p6-XML-XPath.git", "resources" : [ ],
  "build-depends" : [ ],
  "auth" : null,
  "provides" : {
    "XML::XPath::ExprOperator::UnaryMinus" : {
        "lib/XML/XPath/ExprOperator/UnaryMinus.pm6" : {
            "cver" : "2017.01",
            "file" : "669A66B0DACE378D3507F21305B3A5AE0030D1E8",
            "time" : null
        }
    },
    "XML::XPath::ExprOperator::Div" : {
        "lib/XML/XPath/ExprOperator/Div.pm6" : {
            "cver" : "2017.01",
            "file" : "3D8EAACC880CA211F6E2D99C3AC0F2B0F64BA267",
            "time" : null
        }
    },
...
  "Str" : "XML::XPath:ver&lt;0.9.0&gt;:auth&lt;&gt;:api&lt;&gt;",
  "depends" : [
    "XML",
    "Test::META"
   ],
  "license" : null,
  "ver" : "0.9.0",
  "description" : "XPath perl6 library",
  "test-depends" : [ ],
  "identity" : "XML::XPath:ver('0.9.0')"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你所看到的, 它包含了一些关于模块的基本元信息, 比如名称和源地址。在文件的最后, 我们可以看到依赖关系列表- XML 和 <code>Test::META</code>。提供块列出了与之相连的其他模块。例如, 我们看到 <code>XML::XPath::ExprOperator::UnaryMinus</code> 模块位于名为 669A66B0DACE378D3507F21305B3A5AE0030D1E8 的文件中。同样, 我们可以找到关于 <code>XML::XPath</code> 文件本身的数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">"XML::XPath" : {
    "lib/XML/XPath.pm6" : {
      "cver" : "2017.01",
      "file" : "E7C0BBCF69DD5CBC21DBD7027015325F83FADE11",
      "time" : null
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的确, 在 <code>share/perl6/site/source/E7C0BBCF69DD5CBC21DBD7027015325F83FADE11</code> 这个位置, 我们看到了 <code>XML:::XPath</code> 的源代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use XML;
use XML::XPath::Actions;
use XML::XPath::Grammar;
use XML::XPath::Utils;

class XML::XPath {
    has $.document;
    has %.registered-namespaces is rw;

    submethod BUILD(:$file, :$xml, :$document) {
           my $doc;
           if $document {
               $doc = $document;
           }
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>但这还不是全部。和源文件一起, Rakudo 还保留了一个预编译的模块版本。它存储在共享 perl6/site/precomp 目录内的一个子目录下的同名文件中。</p>
</div>
<div class="paragraph">
<p>对于开发者来说, 没有必要详细了解上述结构。如果你使用 Raku 的包管理器, 它将会处理好内部的所有细节。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_8">7.5. 总结</h3>
<div class="paragraph">
<p>在本章中, 我们经历了使用模块工作的主要步骤。首先, 我们看到了如何创建一个模块, 以及如何告诉编译器在哪里可以找到它。然后, 我们研究了加载模块和导入模块名称的不同方法。最后, 我们来到了 Rakudo 专用的模块管理工具 zef, 用它来安装和卸载模块, 并考察了 Rakudo 用于保存模块到磁盘上的内部存储。</p>
</div>
<div class="paragraph">
<p>在下一章, 第八章, 面向对象的程序设计, 我们将讲到类, 类与模块有一些共同的元素, 即代码如何在单独的文件中定位。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_面向对象编程">8. 面向对象编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>面向对象编程(OOP)</strong>是现代编程语言最需要的功能之一。在 Raku 中，Perl 早期版本 OOP 的工作方式已经被完全重新设计了。在本章中，我们将学习如何在 Raku 中创建类和处理对象。这会涉及到以下内容:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建类</p>
</li>
<li>
<p>类(读写、公共、私有、状态属性)</p>
</li>
<li>
<p>类方法(公共方法和私有方法)</p>
</li>
<li>
<p>继承(继承自类、重写方法、子方法、多重继承)</p>
</li>
<li>
<p>角色</p>
</li>
<li>
<p>内省</p>
</li>
<li>
<p>后缀方法运算符</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_创建类">8.1. 创建类</h3>
<div class="paragraph">
<p>在 Raku 中，类是语言设计中不可或缺的一部分。要创建一个类，请使用 <code>class</code> 关键字。类的主体, 包含了类的定义, 它被放在一对花括号之间。</p>
</div>
<div class="paragraph">
<p>让我们从创建一个使用类的程序开始。我们将从一个空的 <code>House</code> 类开始:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>类名以大写字母开头是一种很好的做法。这也符合 Raku 中的惯例。它的类型也是以同样的方式调用的，对比一下 - <code>Int</code>，<code>Str</code>，<code>Array</code> 等。</p>
</div>
<div class="paragraph">
<p>前面的代码声明了一个类 <code>House</code> 并定义了它的主体。目前，主体是空的，但你已经可以使用这个定义来创建该类的实例(或者，使用其他术语，创建该类型的对象)。</p>
</div>
<div class="paragraph">
<p>在某种程度上，<strong>类</strong>和<strong>类型</strong>这两个术语是可以互换的。例如，你可以把字符串当作 <code>Str</code> 类的实例，或只是 <code>Str</code> 对象，或者说是 <code>Str</code> 类型的变量。</p>
</div>
<div class="paragraph">
<p>所以，创建一个新房子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>House</code> 类名上调用的 <code>new</code> 方法是类<strong>构造函数</strong>。它由 Raku 为你的每一个新类创建的。如果你愿意，你可以在 <code>new</code> 的调用中附加一对空括号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$house</code> 变量是标量变量。它承载着一个 <code>House</code> 类型的对象。为了确认这一点，在变量上调用 <code>WHAT</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $house.WHAT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印出 (<code>House</code>)。</p>
</div>
<div class="paragraph">
<p>有了一个类，我们可以创建另一个实例，比如 <code>$house2</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house2 = House.new;
say $house.WHAT; # (House)</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们创造一条空房子的街道:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @street;
push @street, House.new for 1..5;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，<code>@street</code> 数组获得了 5  个 <code>House</code> 类型的对象。让我们通过在每个数组元素上调用 <code>WHAT</code> 方法来检查它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $_.WHAT for @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们所看到的那样，为了托管对象，我们使用了相同类型的变量来托管对象，对单个对象使用标量，对多个集合使用数组。对于  Raku，<code>$house</code> 是一个容器，你可以用任何类型的数据来填充，不管是 <code>Int</code> 还是 <code>House</code> 对象。</p>
</div>
<div class="paragraph">
<p>我们刚才创建的两个 <code>house</code> 实例是不同的对象。可以使用 <code>===</code> 运算符来检查对象是否是同一个对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $house === $house2; # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一方面，两个 house 的内容是相同的。<code>eqv</code> 运算符检查对象的内部结构:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $house eqv $house2; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的下一步要做的就是用有用的元素来填充 <code>House</code> 类。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用属性">8.2. 使用属性</h3>
<div class="paragraph">
<p>在上一节中，我们创建了 <code>House</code> 类，它不包含任何内容。真实的房子确实有一些参数，比如地址、面积(平方米)、房间数、高度等。所有这些都可以用 Raku 来表达。</p>
</div>
<div class="paragraph">
<p>让我们开始在类中添加细节。我们从最简单的元素, 房间数开始。这个参数可以通过附加在 <code>House</code> 类型对象上的整数值来描述。在 Raku 中，这样的数据元素被称为<strong>属性</strong>，并使用 <code>has</code> 关键字声明，如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    $.rooms;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里做了什么? <code>House</code> 类获得了属性 <code>$.rooms</code>。这是一个属于类对象的标量值。注意美元符号之后的点。这是一个描述属性的访问级别的 twigil; 我们将在本节后面讨论它。</p>
</div>
<div class="paragraph">
<p>现在，尝试创建一个房子，就像我们在上一节中所做的那样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次，这个对象与我们在《创建类》的部分不同。它包含了一个属性-<code>$.rooms</code>。这个属性可以使用点语法来读取，就像在 Java 或其他语言中访问对象属性一样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $house.rooms;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为我们没有将这个属性设置为任何值，所以程序告诉我们这个属性是空的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">(Any)</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了给属性设置一个初始值，可以使用构造函数参数。不要像 <code>House.new</code> 那样创建一个实例，而是将命名参数传递给它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(rooms =&gt; 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你现在打印 <code>$.rooms</code> 的值，它将返回值 2:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $house.rooms; # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>房屋在房间数量上可能会有所不同。让我们在程序中反映这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(rooms =&gt; 2);
say $house.rooms;  # 2

my $house2 = House.new(rooms =&gt; 4);
say $house2.rooms; # 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>变量 <code>$house</code> 和 <code>$house2</code> 的 <code>$.rooms</code> 属性被初始化为不同的值，并与对象一起保留。</p>
</div>
<div class="paragraph">
<p>现在，这两个房子不仅是不同的对象，而且因为内容不同，所以也不相等。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $house === $house2; # False
say $house eqv $house2; # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们是通过访问 <code>$.house</code> 属性来打印房间的数量。对于给定对象 <code>$house</code>，获取其属性 <code>$.rooms</code> 的值的语法是 <code>$house.rooms</code>。</p>
</div>
<div class="paragraph">
<p>为了设置该值，我们使用一个命名参数传递给构造函数-<code>House.new(rooms &#8658; 2)</code>。</p>
</div>
<div class="paragraph">
<p>不要忘记，Raku 不允许在方法名和开口的括号之间留白。</p>
</div>
<div class="sect3">
<h4 id="_读写属性">8.2.1. 读写属性</h4>
<div class="paragraph">
<p><code>$.rooms</code> 属性的值是在创建对象 <code>$house</code> 时设置的。如果我们以后需要改变它的值怎么办？当然，在真实的房屋中，房间数发生变化的情况很少见，但这种情况还是有可能发生，比如说在新房主拿下房子后，改变了房子的平面图。</p>
</div>
<div class="paragraph">
<p>天真地试图设定一个新的值就会失败:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.rooms ;
}

my $house = House.new(rooms =&gt; 2);
$house.rooms = 3; # Fails here
say $house.rooms;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在赋值时，发生运行时错误，程序被终止:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot modify an immutable Int in block &lt;unit&gt; at house.pl line 7</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$.room</code> 属性是不可变的，无法更改。这是类属性的默认行为。</p>
</div>
<div class="paragraph">
<p>要使属性是可变的，换句话说，要允许写到属性，必须用 <code>rw</code> trait 声明。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.rooms is rw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，修改是允许的，而且没有发生异常:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(rooms =&gt; 2);
say $house.rooms; # 2

$house.rooms = 3;
say $house.rooms; # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>读写属性可以作为左值与其他运算符一起使用，例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house2 = House.new(rooms =&gt; 3);
$house2.rooms++;
say $house2.rooms; # 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样的属性可以被任何能访问 <code>$house</code> 的代码所改变。在很多情况下，对对象内部属性的访问必须受到限制。在下一节中，我们将讨论在 Raku 中如何做到这一点。</p>
</div>
<div class="paragraph">
<p>在我们进一步学习类的方法之前，让我们用更多的字段来扩展类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.rooms   is rw;
    has $.area    is rw;
    has $.height  is rw;
    has $.address is rw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，该实例包含四个数据属性，可以在构造函数中初始化:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(
    rooms   =&gt; 2,
    area    =&gt; 100,
    height  =&gt; 4,
    address =&gt; '22, rue du Grenier-Saint-Lazare, 75003, Paris, France',
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在最后一对参数后面加上一个逗号是很好的。这不是必须的，但就像创建散列一样，它可以使添加新元素的过程更容易。</p>
</div>
<div class="paragraph">
<p>现在，所有的属性都被初始化了。如果你打印对象，默认的字符串化机制会列出所有的属性及其值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">say $house;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">House.new(rooms =&gt; 2, area =&gt; 100, height =&gt; 4, address =&gt; "22, rue duGrenier-Saint-Lazare, 75003, Paris, France")</code></pre>
</div>
</div>
<div class="paragraph">
<p>在下一节中，我们将讨论缩小可以存储在属性中的数据类型。</p>
</div>
</div>
<div class="sect3">
<h4 id="_带类型的属性">8.2.2. 带类型的属性</h4>
<div class="paragraph">
<p>我们继续讨论 <code>House</code> 类的内容，现在要考虑的是可以存储在属性中的值。</p>
</div>
<div class="paragraph">
<p>在前面的例子中，我们把它们设置成一些有意义的值，但如果你放了一些无意义的数据，语言是不会抵挡的；比如，我们不小心把地址放到了 <code>$.area</code> 属性中，就会有一个地址。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(
    rooms   =&gt; 2,
    area    =&gt; 'Calle Velázquez 57, 28001 Madrid, Spain', height =&gt; 4.0,
    address =&gt; 100.0,
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>想象一下，现在你要计算出一个房间的平均面积:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $house.area / $house.rooms;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是不可能的，因为 <code>$.area</code> 属性包含一个字符串，而不是一个数字。编译器会报告一个运行时错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot convert string to number: base-10 number must begin with valid digits or '.'</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了防止在类属性中存储错误类型的数据，Raku 提供了一种类型化属性的机制。这个想法与类型化变量相同，在下面的代码片段中可以看到。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has Int  $.rooms   is rw;
    has Real $.area    is rw;
    has Real $.height  is rw;
    has Str  $.address is rw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，<code>House</code> 类的每个属性都是带有类型的。编译器知道，房间数是整数，面积和高度是浮点数，地址是字符串。试图存储错误的数据会被编译器阻止:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Type check failed in assignment to $!area; expected Rat but got Str ("Calle Velázquez 57, ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>异常也会在运行时发生，但你不能对对象做什么，因为它甚至不会被创建。</p>
</div>
<div class="paragraph">
<p>这不是你可以对类属性施加的所有限制。以 <code>$.room</code> 属性为例，它可以只是一个整数，但也应该是正整数。它可以是一个整数，但也应该是一个正整数。Raku 允许你使用 <code>where</code> 关键字指定子集的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has Int  $.rooms   is rw where {$_ &gt; 0};
    has Real $.area    is rw where {$_ &gt; 0};
    has Real $.height  is rw where {$_ &gt; 3};
    has Str  $.address is rw where {$_ ne ''};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在所有的属性都使用了 Raku 内置的子集类型。<code>$.rooms</code> 和 <code>$.area</code> 属性的值都应该是正数，房子的高度必须至少是3米，地址不能是空字符串。</p>
</div>
<div class="paragraph">
<p>现在，如果构造函数中传递的值不符合条件，就会出现运行时异常。例如，如果地址是空的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Type check failed in assignment to $!address; expected &lt;anon&gt; but got Str ("")</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在让我们仔细看看 <code>$.address</code> 属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用其他类作为数据类型">8.2.3. 使用其他类作为数据类型</h4>
<div class="paragraph">
<p>在前面的代码中，房屋的地址是一个自由文本字符串。在更复杂的应用程序中，最好将地址保存为一组不同的字段 - 国家，城镇，邮政编码，街道名称和门牌号码。</p>
</div>
<div class="paragraph">
<p>其中一个可能的实现是在 <code>House</code> 类中添加更多的属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has Int  $.rooms      is rw where {$_ &gt; 0};
    has Real $.area       is rw where {$_ &gt; 0};
    has Real $.height     is rw where {$_ &gt; 3};

    has Int  $.husenumber is rw where {$_ ne ''};
    has Int  $.zipcode    is rw where {$_ &gt; 0};
    has Str  $.country    is rw where {$_ ne ''};
    has Str  $.town       is rw where {$_ ne ''};
    has Str  $.street     is rw where {$_ ne ''};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个方法很管用，但不是最好的解决方案。地址的详细信息可以保存在一个单独的属性中。要定义地址的内部结构，我们引入另一个类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> class Address {
    has Str $.housenumber is rw where {$_ ne ''};
    has Str $.zipcode     is rw where {$_ ne ''};
    has Str $.country     is rw where {$_ ne ''};
    has Str $.town        is rw where {$_ ne ''};
    has Str $.street      is rw where {$_ ne ''};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>属性的类型被有意地选择为字符串, 以允许门牌号, 如 <code>3A</code> 和以 0 开头或包含字母或空格的邮政编码，如伦敦的 <code>WC2B 4PH</code>。有了这个，<code>House</code> 类可以包含 <code>Address</code> 类型的属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has Int     $.rooms   is rw where {$_ &gt; 0};
    has Real    $.area    is rw where {$_ &gt; 0};
    has Real    $.height  is rw where {$_ &gt; 3};
    has Address $.address is rw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，让我们创建一个 <code>House</code> 对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(
       rooms   =&gt; 2,
       height  =&gt; 4,
       area    =&gt; 100,
       address =&gt; Address.new(
           housenumber =&gt; '31A',
           zipcode  =&gt; '00194',
           country  =&gt; 'Italy',
           town     =&gt; 'Rome',
           street   =&gt; 'Via Dante',
       ),
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>代表地址的对象是在需要 <code>House</code> 对象的 <code>$.address</code> 属性的时候, 用自己的构造函数 <code>Address.new</code> 创建的。</p>
</div>
<div class="paragraph">
<p>关于类属性, 我们需要学习的东西还有很多，但在继续学习之前，我们必须先介绍一下类方法。所以，下一节是关于类方法的介绍，之后我们将在《更多关于属性》一节中回到属性的介绍。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用方法">8.3. 使用方法</h3>
<div class="paragraph">
<p>在 OOP 中，对象不仅要保存数据，还要执行某些操作。在 Raku 中，数据保存在属性中, 而动作是通过<strong>方法</strong>来完成的。</p>
</div>
<div class="paragraph">
<p>方法类似于普通的 subs，但定义在类的内部。它们可以使用对象属性中的数据来进行工作。</p>
</div>
<div class="paragraph">
<p>继续上一节中的 <code>Address</code> 类。地址的详细信息被保存在单独的属性中。这对于创建一个干净、结构化的表示方式是很好的，但是在某些情况下，我们需要将所有的数据一起使用。例如，让我们打印一个格式化的地址，放在信封上:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Address {
    has Str $.housenumber;
    has Str $.zipcode;
    has Str $.country;
    has Str $.town;
    has Str $.street;
}

my $address = Address.new(
    housenumber =&gt; '10',
    zipcode =&gt; '1020',
    country =&gt; 'Country',
    town    =&gt; 'Town',
    street  =&gt; 'Street',
);

print qq:to/ADDRESS/;
    {$address.street} {$address.housenumber}
    {$address.zipcode} {$address.town}
    {$address.country}
ADDRESS</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Address</code> 类包含一些数据元素，在字符串插值中使用这些元素来显示他们的值。注意，你需要使用花括号，这样 Raku 就可以理解点是名称的一部分，后面是属性名。这个程序的结果就是打印成三行的地址:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Street 10
1020 Town
Country</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的任务完成了，但是试想一下给另一个地址打印另一个信封标签。为了避免代码重复，我们必须将格式化字符串放到一个子例程中。为了让它更完美，地址的格式必须成为 <code>Address</code> 类的一部分。让我们把 <code>full_address</code> 方法添加到类中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">class Address {
    has Str $.housenumber;
    has Str $.zipcode;
    has Str $.country;
    has Str $.town;
    has Str $.street;
    method full_address() {
        return qq:to/ADDRESS/;
            $.street $.housenumber
            $.zipcode $.town
            $.country
        ADDRESS
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在方法内部，可以使用 <code>$.street</code>，<code>$.zipcode</code> 等名称来访问对象属性, 以此类推。</p>
</div>
<div class="paragraph">
<p>让我们把重点放在这个重要的方面。在类代码之外，访问属性需要一个对象。例如，如果我们通过调用新的构造函数创建一个对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Address {
    has $.street is rw;
}
my $address = Address.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，为了访问 <code>$address</code> 属性的字段，我们使用点语法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$address.street = 'Ramblas';
say $address.street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们之前已经看到的，另一个地址将保留其自己的 <code>$.street</code> 属性值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $address2 = Address.new;
$address2.street = 'Calle de Alcalá';

say $address2.street; # Calle de Alcalá
say $address.street;  # Ramblas</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，让我们对方法中的属性进行处理。我们创建了两个方法，一个用于设置 <code>$.street</code> 的新值，另一个用于读取它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Address {
    has $.street is rw;

    method get_street() {
        return $.street;
    }

    method set_street($new_street) {
        $.street = $new_street;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以，这个类现在提供了 <code>get_street()</code> 和 <code>set_street()</code> 两个方法，然后我们马上使用它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $address = Address.new;
$address.set_street('Ramblas');

my $address2 = Address.new;
$address2.set_street('Calle de Alcalá');

say $address.get_street();  # Ramblas
say $address2.get_street(); # Calle de Alcalá</code></pre>
</div>
</div>
<div class="paragraph">
<p>在方法内部，该属性被称为 <code>$.street</code>。在 <code>$address</code> 和 <code>$address2</code> 实例中, 设置和获取属性值的代码是一样的。</p>
</div>
<div class="paragraph">
<p>在类方法内部，我们没有看到任何提及 <code>$address</code> 或 <code>$address2</code> 的代码，但 Raku 知道该使用哪个对象，因为这些方法都是为这些对象调用的。当编译器看到像 <code>$address.get_street()</code> 这样的构造时，该方法会接收到一个指向对象的指针。我们没有明确地看到它，但你可以用下面的方法来重写它，这类似于对常规子程序的调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">set_street($address: 'New value');
say get_street($address:);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个对象现在被作为第一个参数传递给 <code>set_street</code> 和 <code>get_street</code> 例程。我们要调用方法的对象被称为 invocant。我们在第四章《操作符的使用》中讨论了 <code>: 操作符。在传统的语法中，例如 `$address.get_street()</code>，调用对象仍然被传递给方法，但不是显式的。</p>
</div>
<div class="sect3">
<h4 id="_私有方法">8.3.1. 私有方法</h4>
<div class="paragraph">
<p>要隐藏属性，你需要将 twigil 更改为 <code>.!</code>。同样，可以用同样的感叹号将方法设为私有来隐藏方法。私有方法不能在对象上调用，它们只能从类的其他方法中使用。请看下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class X {
  method !a() {
    say 'Private method';
  }

  method b() {
    say 'Public method';
    self!a();
  }
}

my $x = X.new();</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个类有两个方法，<code>a</code> 和 <code>b</code>。其中第一个方法被声明为私有方法, 所以试图将其调用为 <code>$x.a()</code> 会导致运行时错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">No such method 'a' for invocant of type 'X'</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>b</code> 方法是公共的, 因此可以被调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$x.b();</code></pre>
</div>
</div>
<div class="paragraph">
<p>在内部，这个方法在 <code>self</code> 关键字 - <code>self!a()</code> 的帮助下调用私有方法 <code>a</code>。<code>self</code> 指向当前正在处理的对象，因此它与外部程序中的 <code>$x</code> 是一样的。你也可以使用 <code>self</code> 来调用公共方法-<code>self.b()</code>，但它是多余的，应用只用于解决名称冲突。</p>
</div>
<div class="paragraph">
<p>现在，在我们讲完了类方法，让我们回到属性，看看在与方法有关的地方，我们可以了解到哪些新的信息。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_更多关于属性的信息">8.4. 更多关于属性的信息</h3>
<div class="paragraph">
<p>本章我们从类属性这一节开始，但属性的一些特性与方法密切相关，这也是我们中断了一下，现在可以继续讲属性的原因。</p>
</div>
<div class="sect3">
<h4 id="_公共和私有属性">8.4.1. 公共和私有属性</h4>
<div class="paragraph">
<p>在前面的代码示例中，类属性是用点符号声明的-<code>$.rooms</code> 或 <code>$.street</code>。这个位置上的点表示该属性是公共的, 可以被不属于该类的代码访问。</p>
</div>
<div class="paragraph">
<p>还有另一个 twigil，!，表示属性是私有的。这意味着读取或更改属性值的唯一方法是通过方法访问它。</p>
</div>
<div class="paragraph">
<p>让我们回到 <code>House</code> 类, 把它的方法的所有 twigils 都改成 <code>!</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $!rooms;
    has $!area;
    has $!height;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建房屋的方法和以前一样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(
    rooms  =&gt; 2,
    area =&gt; 100,
    height =&gt; 3,
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，现在无法读取属性的值。试图获取 $house.rooms 的值会失败:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">No such method 'rooms' for invocant of type 'House'</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$house!rooms</code> 也不例外:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Private method call to rooms must be fully qualified with the package containing the method</code></pre>
</div>
</div>
<div class="paragraph">
<p>出现这种情况是因为 !twigil 将属性标记为私有属性，不能从类外访问。不过我们可以从方法的代码中处理它们。让我们创建 <code>get_rooms</code> 和 <code>set_rooms</code> 方法来获取和设置房间数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $!rooms;
    has $!area;
    has $!height;
    method get_rooms() {
        return $!rooms;
    }

    method set_rooms($new_value) {
        $!rooms = $new_value;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次，创建一个具有一些初始值的新房子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(
    rooms =&gt; 2,
    area =&gt; 100,
    height =&gt; 3,
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在用新的方法, 先修改房间数，然后再打印:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$house.set_rooms(3);
say $house.get_rooms(); # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>在面向对象编程理论中，隐藏对象属性被称为封装。Raku 为此使用了 ! twigil。这个属性就变成了一个私有属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_自动的_setter_和_getter_方法">8.4.2. 自动的 setter 和 getter 方法</h4>
<div class="paragraph">
<p>其实, 我们在本章前面的点语法就是我们在本章中使用的设置和读取属性的点语法，是使用 Raku 为我们创建的 getter 和 setter 方法的一种语法上的欺骗。让我们一步步来研究它。</p>
</div>
<div class="paragraph">
<p>首先，用 <code>$.</code> 创建一个简单的类属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class X {
    has $.y;
}

my $x = X.new(y =&gt; 1);
say $x.y; # 1</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$x</code> 对象有一个名为 y 的属性。这是一个公共属性(因为.twigil) 并且可以从外部访问。在幕后，Raku 创建了一个同名的方法 y，它返回 <code>$.y</code> 的值。所以，<code>$x.y</code> 实际上是调用了那个不可见的方法。</p>
</div>
<div class="paragraph">
<p>对比一下这个例子和它的修改，在这个例子中，方法 y 被显式定义了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class X {
    has $.y;

    method y() {
        return 2;
    }
}

my $x = X.new(y =&gt; 1);
say $x.y; # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>调用代码 <code>$x.y</code> 没有改变，但现在打印的值却不一样了，因为我们的方法重新定义了与编译器创建的同名的方法。</p>
</div>
<div class="paragraph">
<p>现在，让我们通过将值赋给 <code>$x.y</code> 来设置值。当然，这个属性必须用 <code>is rw</code> trait 声明。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class X {
    has $.y is rw;
}

my $x = X.new(y =&gt; 1);
$x.y = 2;
say $x.y; # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>这次，编译器创建一个 setter 方法，当我们给 <code>$.y</code> 属性分配一个新的值时，这个方法就会被调用。我们可以通过创建一对 multi 方法来模仿整个画面。multi 方法是指共享相同名称但有不同签名的方法。在其他语言中，这个概念也被称为函数重载或方法重载。它们类似于我们在第6章《子例程》中介绍的 multi 子例程。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class X {
    has $.y is rw;

    multi method y() {
        return $!y;
    }

    multi method y($value) {
        $!y = $value;
    }
}

my $x = X.new(y =&gt; 1);
$x.y(2);
say $x.y(); # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这段代码中，我们只使用显式 multi 方法 <code>y()</code> 和 <code>y($value)</code> 来更改 <code>$.y</code> 属性的值。</p>
</div>
<div class="paragraph">
<p>注意，在这些方法内部，<code>$.y</code> 属性使用了 <code>!</code> twigil。当你使用 <code>!</code> twigil 设置或获取属性时，Raku 会直接访问它的属性，而不使用自动生成的 getter 和 setter 方法。所以，即使你有一个公共属性 <code>$.y</code>，用圆点声明，最好的做法是在类方法中直接访问 <code>$!y</code>。</p>
</div>
<div class="paragraph">
<p>最后，让我们再来看一下访问公共变量和 <code>is rw</code> trait 之间的区别。在下面的代码中，<code>$.x</code> 属性是公共的，但没有声明为 <code>is rw</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class C {
    has $.x;

    method set() {
        $!x = 4;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然不能从主程序中设置新值，但还是可以从方法中修改属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = C.new;
$c.set();
say $c; # 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个属性是公共的，所以编译器为它生成一个 getter 方法，但不是读写属性，所以没有创建 setter。</p>
</div>
</div>
<div class="sect3">
<h4 id="_类属性">8.4.3. 类属性</h4>
<div class="paragraph">
<p>假设现在我们正在建造一条街道，并想给任何新对象赋予门牌号。为了简单起见，让我们暂时删除除了 <code>House</code> 中的 <code>$.address</code> 和 <code>Address</code> 中的 <code>$.housenumber</code> 以外的所有属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Address {
    has Int $.housenumber is rw;
}

class House {
    has Address $.address is rw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一步是一个构建 house 的循环, 将房屋保存在 <code>@street</code> 数组中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @street;
   for 1..10 {
       push @street, House.new(
           address =&gt; Address.new(
               housenumber =&gt; @street.elems + 1
           )
) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了增加门牌号，我们按以下方式使用 <code>@street</code> 的大小:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@street.elems + 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样可以确保每个新的房子都会得到一个数字，这个数字大于所有现有房子的数量。要看到这一点，遍历数组以打印数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $_.address.housenumber for @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，用一个外部计数器来记录被创建的房子并不是什么大问题，但有一个备用的方法-- <code>Address</code> 类本身就可以告诉我们有多少个对象被创建。</p>
</div>
<div class="paragraph">
<p>我们将使用所谓的类属性，这些属性属于类，而不属于类的实例。这意味着所有的对象都共享同一个类属性。这与常规属性不同&#8212;&#8203;每个对象都会收到自己的容器。在其他编程语言中，类属性也被称为静态数据成员。</p>
</div>
<div class="paragraph">
<p>所以，这里是这样的代码，<code>Address</code> 类配备了类属性 <code>$last_assigned_number</code>，这是一个在类内部用 <code>my</code> 关键字声明的整数值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Address {
    my Int $last_assigned_number = 0;
    has Int $.housenumber is rw;

    method assign_next() {
        $last_assigned_number++;
        $.housenumber = $last_assigned_number;
    }
}

class House {
    has Address $.address is rw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建 assign_next 方法以执行必要的操作以增加值 class 属性 $last_assigned_number 并将其分配给实例属性
$.housenumber。 让我们修改用于生成房屋数组的循环以使用 assign_next 方法:</p>
</div>
<div class="paragraph">
<p><code>assign_next</code> 方法的创建是为了使类属性 <code>$last_assigned_number</code> 的值递增，并将其赋值给实例属性 <code>$.houseenumber</code>。</p>
</div>
<div class="paragraph">
<p>让我们修改生成房屋数组的循环，使用 <code>assign_next</code> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @street;
for 1..10 {
    my $house = House.new(
        address =&gt; Address.new()
    );
    $house.address.assign_next();
    push @street, $house;
}

say $_.address.housenumber for @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序打印出了从 1 到 10 的 10 个数字。如你所见，我们需要做的就是在 Address 对象上调用方法。现在所有的计算都是由方法来完成的，而不是使用类的代码。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类方法">8.5. 类方法</h3>
<div class="paragraph">
<p>在前面的例子中，我们使用类属性来保存类的所有实例之间共享的数据。我们使用的是一个方法，它是用这个属性来工作的。</p>
</div>
<div class="paragraph">
<p>类属性的概念也可以投射到方法上。在 Raku 中，类可以包含类方法，这些方法是使用 <code>sub</code> 关键字定义的。这样的方法可以访问所有的类属性，但不接受对该对象的隐式自引用。考虑一个有两个类的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Address {
    my Int $last_assigned_number = 0;
    has Int $.housenumber is rw;

    our sub get_next() {
        return ++$last_assigned_number;
    }
}

class House {
    has Address $.address is rw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>get_next</code> 类方法也是使用 <code>our</code> 关键字声明的。这是必要的，因为我们想从外部代码中访问这个方法。默认情况下，作用域将只限于这个类。</p>
</div>
<div class="paragraph">
<p>现在，进行循环设计的下一次迭代以生成街道:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @street;
for 1..10 {
    my $house = House.new(
        address =&gt; Address.new()
    );
    $house.address.housenumber = Address::get_next();
    push @street, $house;
}

say $_.address.housenumber for @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的主要区别在于我们分配门牌号的方式。<code>get_next</code> 方法不能在 <code>Address</code> 类的实例上调用，因此编译器不接受表达式 <code>$house.address.get_next</code>。对称的是，你不能在方法内部访问自变量。</p>
</div>
<div class="paragraph">
<p><code>get_next</code> 方法必须使用类名-<code>Address::get_next()</code> 来调用。它改变了 <code>$last_assigned_number</code> 计数器的值。计数器也是一个不属于 <code>Address</code> 类的任何特定实例的变量。实际上，即使在创建任何对象之前，<code>Address:::get_next()</code> 方法也可以被调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Address::get_next(); # 1
say Address::get_next(); # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在是时候详细了解一下 Raku 中的面向对象设施了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_继承">8.6. 继承</h3>
<div class="paragraph">
<p>面向对象编程的下一个特性是继承。在这一节中，我们讨论继承和Raku 中的相关主题。</p>
</div>
<div class="sect3">
<h4 id="_从类中继承">8.6.1. 从类中继承</h4>
<div class="paragraph">
<p>在 OOP 中继承意味着创建一个新类，它扩展了另一个已经存在的类。 最简单的继承形式是两个类的子类-父类对继承。</p>
</div>
<div class="paragraph">
<p>在前面的章节中，我们创建了 <code>House</code> 类。让我们用它作为另一个概念的父类。我们将创建一个 <code>ModernHouse</code> 类，它是一个带有太阳能屋顶板的 <code>House</code>。我们在本章前面创建的裸的 <code>House</code>，包含四个属性&#8212;&#8203;房间数、面积、高度和地址。在我们前面的例子中，地址属性是一个 <code>Address</code> 对象，但在这一节中，我们将保持简单，假设地址是一个字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.rooms;
    has $.area;
    has $.height;
    has $.address;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 <code>ModernHouse</code> 来说，另一个属性, 就是太阳能电池板所产生的功率:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class ModernHouse is House {
    has $.power;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在的 <code>ModernHouse</code> 有 5 个属性，其中 4 个来自于 <code>House</code> 类, 还有一个是 <code>ModernHouse</code> 定义中添加的属性。从用户的角度来看，<code>ModernHouse</code> 类的所有属性都是平等的，你初始化并使用这些属性, 就像下面的例子中清楚地看到的那样, 它们都是 <code>ModernHouse</code> 类中定义的属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = ModernHouse.new(
    rooms   =&gt; 5,
    area    =&gt; 150,
    height  =&gt; 5,
    address =&gt; '...',
    power   =&gt; 200,
);

say $house.area;  # 100
say $house.power; # 200</code></pre>
</div>
</div>
<div class="paragraph">
<p>在不同的编程语言中，对参与继承的类有不同的术语。<code>House</code> 类可以被称为基类、父类或超类。<code>ModernHouse</code> 类既可以是派生类，也可以是孩子类或者是子类。</p>
</div>
<div class="paragraph">
<p>在 Raku 的文档中，使用了父类和子类的术语。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用子类实例作为基类的对象">8.6.2. 使用子类实例作为基类的对象</h4>
<div class="paragraph">
<p><code>ModernHouse</code> 类型的对象也是 <code>House</code>。考虑一个函数 f, 它接收一个参数并认为它是 <code>House</code> 类型的对象。函数的签名对该参数施加了一个限制:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f(House $h) {
    say "There are {$h.rooms} rooms in this house.";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，让我们创建两个不同的房子, 用它们来调用函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(rooms =&gt; 2);
my $modern_house = ModernHouse.new(rooms =&gt; 3, power =&gt; 100);

f($house);
f($modern_house);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码可以完美地工作, 并打印出预期的字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">There are 2 rooms in this house.
There are 3 rooms in this house.</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个函数只使用了在父类中定义的属性，因此可以很容易地处理子类的对象，因为它也包含了所需的属性。</p>
</div>
<div class="paragraph">
<p>如果我们反其道而行之-创建一个期望子类对象的函数，并传递一个基类的对象给它呢?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f2(ModernHouse $h) {
    say "This house generates {$h.power} kWh.";
}

f2($modern_house);</code></pre>
</div>
</div>
<div class="paragraph">
<p>到目前为止，它起作用，因为对象的类型没有区别:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">This house generates 100 kWh.</code></pre>
</div>
</div>
<div class="paragraph">
<p>f2 函数正在访问 <code>$.power</code> 属性，在 <code>House</code> 类中没有这个属性。如果你调用该函数并将 <code>$house</code> 变量传递给它，会出现错误。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Type check failed in binding to parameter '$h'; expected ModernHouse but got House (House.new(rooms =&gt; 2,...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>考虑另一个使用类型化变量的例子。在下一个例子中，<code>@street</code> 数组是一个 <code>House</code> 类型的对象的数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my House @street;
push @street, ModernHouse.new(rooms =&gt; 3, power =&gt; 100);
push @street, House.new(rooms =&gt; 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这两个房子都成功地被添加到了 <code>@street</code> 数组中，因为它们都与 <code>House</code> 类型兼容。如果循环遍历，就可以读取 <code>House</code> 类的属性，这些属性也会在 <code>ModernHouse</code> 类型的对象中出现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">f($_) for @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果对 <code>@street</code> 数组进行更严格的声明，即如果我们使用 <code>ModernHouse</code> 类型作为数组元素的类型，那么编译器将不接受 <code>House</code> 类型的对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my ModernHouse @street;
push @street, ModernHouse.new(rooms =&gt; 3, power =&gt; 100);
# push @street, House.new(rooms =&gt; 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果取消注释最后一行，程序会类型检查错误停止:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Type check failed in assignment to @street; expected ModernHouse but got House (House.new(rooms =&gt; 2,...)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_重写方法">8.6.3. 重写方法</h4>
<div class="paragraph">
<p>在很多情况下，子类的方法应该和父类中的方法有不同的反应。这里我们来谈谈重新定义或重写方法的重要概念。</p>
</div>
<div class="paragraph">
<p>让我们继续以 <code>House</code> 和 <code>ModernHouse</code> 为例, 实现计算取暖所需的电费的方法。为了突出主题, 我们简化了类和计算成本的方法，假设成本与房子的面积成正比,
我们将其简化为类和方法。</p>
</div>
<div class="paragraph">
<p>在这两个类中, 我们定义了一个名为 <code>energy_cost</code> 的方法，每个类的计算方法都是不同的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.area;

    method energy_cost() {
        return 0.8 * $!area;
    }
}

class ModernHouse is House {
    has $.power;

    method energy_cost() {
        return 0.3 * $.area;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意使用面积值的微小区别。在 <code>House</code> 类中，可以用 <code>$!area</code> 语法将其引用为本地属性。而在 <code>ModernHouse</code> 类中，我们必须使用生成的 getter <code>$.area</code>。</p>
</div>
<div class="paragraph">
<p>现在，创建两个实例, 并打印出成本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(area =&gt; 100);
my $modern_house = ModernHouse.new(area =&gt; 100, power =&gt; 150);

say $house.energy_cost();        # 80
say $modern_house.energy_cost(); # 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个对象都使用了自己的 <code>energy_cost</code> 方法变体, 这并不奇怪。</p>
</div>
<div class="paragraph">
<p>当我们在同一个集合中保留不同类型的房屋时，这种行为就更加有趣了。在下一个例子中，我们把两个不同的房子放入 <code>@street</code> 数组中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my House @street;

push @street, House.new(area =&gt; 100);
push @street, ModernHouse.new(area =&gt; 100, power =&gt; 150);</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们对数组进行迭代, 并在循环变量上调用 <code>energy_cost</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $_.energy_cost() for @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序打印出来的输出与前一个程序完全相同。这意味着我们面对的是多态行为&#8212;&#8203;每个对象都知道自己属于哪个类，并调用正确的方法。</p>
</div>
<div class="paragraph">
<p>多态行为可能更加复杂。让我们重新组织一下上一个例子的代码，引入 <code>tariff_coef</code> 方法，这个方法将用于计算成本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.area;

    method tariff_coef() {
        return 0.8;
    }

    method energy_cost() {
        return self.tariff_coef() * $!area;
    }
}

class ModernHouse is House {
    has $.power;

    method tariff_coef() {
        return 0.3;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，<code>energy_cost</code> 方法只在基类中定义了。所以，<code>ModernHouse</code> 类的一个实例将使用该方法。但是，在 <code>energy_cost</code> 方法里面是调用 <code>tarif_coef</code> 方法，Raku 会根据对象的类型找到正确的实现。这在下面的代码中得到了证明。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $house = House.new(area =&gt; 100);
my $modern_house = ModernHouse.new(area =&gt; 100, power =&gt; 150);

say $house.energy_cost();        # 80
say $modern_house.energy_cost(); # 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次，方法解析的行为表明，它的工作原理与预期的一样。</p>
</div>
<div class="paragraph">
<p>请注意，方法 <code>energy_cost</code> 必须是一个公共方法，否则不会被继承。</p>
</div>
</div>
<div class="sect3">
<h4 id="_子方法">8.6.4. 子方法</h4>
<div class="paragraph">
<p>我们已经看到，一个子类会接收基类定义的所有公共方法。在某些情况下，这并不是我们所希望的。将方法私有化也不一定是一个解决方案，因为你可能想在基类的对象上调用它。</p>
</div>
<div class="paragraph">
<p>Raku 允许使用所谓的子方法。它们是不继承的。让我们通过一个小例子来了解一下它们。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Parent {
    method meth() {
        say 'meth()';
    }

    submethod submeth() {
        say 'submeth()';
    }
}

class Child is Parent {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，创建两个对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $o1 = Parent.new;
my $o2 = Child.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Parent 类中，可以在该类型的对象上调用两种方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$o1.meth(); # meth()
$o1.submeth(); # submeth()</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>Child</code> 类中，只有 <code>meth</code> 方法可用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$o2.meth(); #meth()</code></pre>
</div>
</div>
<div class="paragraph">
<p>禁止调用 <code>submeth</code> 的子方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">No such method 'submeth' for invocant of type 'Child'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_多重继承">8.6.5. 多重继承</h4>
<div class="paragraph">
<p>在 Raku 中，允许多重继承。多重继承意味着子类是由一个以上的父类派生出来的。请看下面的骨架示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class P1 {
    method p1() {
        say 'p1()';
    }
}

class P2 {
    method p2() {
        say 'p2()';
    }
}

class C is P1 is P2 {
    method c() {
        say 'c()';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>两个父类 <code>P1</code> 和 <code>P2</code>，定义了方法 <code>p1</code> 和 <code>p2</code>。子类 <code>C</code> 是由 <code>P1</code> 和 <code>P2</code> 两个父类派生出来的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class C is P1 is P2 { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着 <code>C</code> 类的实例接收到了三个类中任何一个类的所有方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = C.new;
$c.p1();
$c.p2();
$c.c();</code></pre>
</div>
</div>
<div class="paragraph">
<p>多重继承是一种强大的技术，但它也会给出隐藏的名称冲突。设想一下，在前面的例子中，有另一个类 <code>P</code>，它是 P1 和 P2 的基类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class P {
    has $!count;
    method get_count() {
        return $!count++;
    }
}

class P1 is P {
    method p1() {
        say 'p1()';
    }
}

class P2 is P {
    method p2() {
        say 'p2()';
    }

    method get_count() {
        return -1;
    }
}

Class C is P1 is P2 {
    method c() {
        say 'c()';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>P</code> 类和 <code>P2</code> 类都有自己的 <code>get_count</code> 方法的实现。在 <code>P</code> 类中，这个方法使用的是属性，每次调用时返回一个递增的数字，在 <code>P2</code> 类中，返回值总是 -1。</p>
</div>
<div class="paragraph">
<p>当 <code>C</code> 类对象从 <code>P1</code> 和 <code>P2</code> 派生出来，间接从 <code>P</code> 类中调用 <code>get_count</code> 方法时，会发生什么情况呢？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = C.new;
say $c.get_count();
say $c.get_count();
say $c.get_count();</code></pre>
</div>
</div>
<div class="paragraph">
<p>一方面，<code>C</code> 类中的 <code>get_count</code> 方法是通过 <code>P1</code> 从 <code>P</code> 类派生出来的。另一方面，同名的方法是通过 <code>P2</code> 派生出来的。Raku 选择从 <code>P2</code> 派生的方法，因为它更接近 <code>C</code> 类，所以程序打印 <code>-1</code> 三次。</p>
</div>
<div class="paragraph">
<p>如果你想了解更多关于 Raku 在多重继承中解决名称冲突的方法，可以参考 C3 线性化方法解析顺序-<a href="https://en.wikipedia.org/wiki/C3_linearization" class="bare">https://en.wikipedia.org/wiki/C3_linearization</a>。</p>
</div>
<div class="paragraph">
<p>到此为止，我们已经走过了经典的面向对象编程的主要概念。Raku 还支持角色这个新概念，我们接下来要讲的是角色这个新概念。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用角色添加对象和类">8.7. 使用角色添加对象和类</h3>
<div class="paragraph">
<p>角色是现代 OOP 中的另一种机制。角色就像类的一个外部部分，它被附加到现有的对象或类中，提供一些额外的属性和方法。在一些编程语言中，角色与接口非常接近。</p>
</div>
<div class="paragraph">
<p>让我们拿一个房子来做一个浮动的房子。为了简单起见，<code>House</code> 类只有一个属性，即房子的面积。<code>Floating</code> 角色有一个属性，可以保存浮动房子的重量，如果房子太重，会下沉，则返回一个布尔值的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.area is rw;
}

role Floating {
    has $.weight is rw;

    method is_sinking() {
        return $!weight &gt; 500 * $.area;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在语法上，创建角色的唯一区别是用关键字 <code>role</code> 来代替关键字 <code>class</code>。</p>
</div>
<div class="paragraph">
<p>从现在开始，有两种方法来应用角色。首先，让我们接收一个已经存在的房子，并对其应用一个角色。在这个例子中，使用构造函数 <code>House.new</code> 创建了房子，并使用 <code>does</code> 关键字附加了一个角色:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $floating_house = House.new does Floating;
$floating_house.area = 100;
$floating_house.weight = 10_000;

say $floating_house.is_sinking(); # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你所看到的，<code>$.weight</code> 属性和 Floating 角色中的 <code>is_sinking</code> 方法都成为了 <code>$floating_house</code> 对象的可用方法。</p>
</div>
<div class="paragraph">
<p>该对象得到一个复合类型 <code>House+{Floating}</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $floating_house.WHAT; # (House+{Floating})</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第二种方法中，先创建一个新的类。<code>FloatingHouse</code> 类是从 <code>House</code> 派生出来的，并导入 <code>Floating</code> 角色。要连接一个角色，同样使用 <code>does</code> 关键字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class FloatingHouse is House does Floating {
}

my $floating_house = FloatingHouse.new;
$floating_house.area = 100;
$floating_house.weight = 100_000;

say $floating_house.is_sinking(); # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序的行为与前一例相同，但对象的类型不同，不包含任何角色的痕迹:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $floating_house.WHAT; # (FloatingHouse)</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用角色在某些方面与类继承非常接近。在某些情况下，这两种方法可能同样有效。下面是在继承和角色之间选择的经验法则。</p>
</div>
<div class="paragraph">
<p>当你可以说 <code>A is B</code> 的时候，你就从 <code>B</code> 继承 <code>A</code>；当你可以说 <code>A does B</code> 的时候，你就应用角色。</p>
</div>
<div class="paragraph">
<p>例如，狗是一种动物，所以你从 <code>Animal</code> 继承 <code>Dog</code>。但狗会叫，所以你应用了角色 <code>Bark</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Dog is Animal does Bark { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>考虑另一个例子，可以使用上面定义的 Floating 角色。我们是创建一个浮动的餐厅。餐厅也是一个房子，它也是浮动的。所以，层次结构可能是这样做的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.area is rw;
}

class Restaurant is House {
    has $.seats is rw;
}

role Floating {
    has $.weight is rw;
    method is_sinking() {
        return $!weight &gt; 500 * $.area;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，Floating 角色和我们在上一个例子中用的浮动房屋的角色完全一样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $restaurant = Restaurant.new does Floating;
$restaurant.seats = 30;
$restaurant.area = 100;
$restaurant.weight = 10_000;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在 <code>$restaurant</code> 变量是 <code>Restaurant+{Floating}</code> 类型的对象，可以使用 <code>is_sinking</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $restaurant.is_sinking(); # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们就不说创建类的层次结构和应用角色了，看看 Raku 是如何帮助考察这些对象的内部结构的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用内省学习更多">8.8. 使用内省学习更多</h3>
<div class="paragraph">
<p>Raku 对象系统有一个内置的内省机制，通过这个机制，你可以看到手中的这个特定对象可以做什么，它实现了哪些类，可以使用哪些方法等等。</p>
</div>
<div class="paragraph">
<p>在前几章中，我们已经使用了内省机制之一-<code>WHAT</code> 方法。它返回的类型对象，包含了现在位于容器中的对象的类型信息。我们在这一章中讨论了内省，但是你应该记住，在 Raku 中，很多其他的简单变量，比如字符串或整数，也是对象。</p>
</div>
<div class="paragraph">
<p>例如，你可以这样看一个字符串和一个整数的类型。程序会打印出字符串化的 <code>WHAT</code> 方法所返回的内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'string'.WHAT; # (Str)
say 42.WHAT;       # (Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于用户定义的类，<code>WHAT</code> 方法给出了该类的名称:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class C {
}
my $c = C.new;
say $c.WHAT; # (C)</code></pre>
</div>
</div>
<div class="paragraph">
<p>HOW 方法返回一个 <code>Perl6::Metamodel::ClassHOW</code> 类的对象。这是 Raku 中所谓的元对象模型的一部分，它负责处理 Raku 中的对象及其属性和行为。我们在此不再深入学习元对象协议(MOP)，只看一下它提供的两个有用的方法-<code>name</code> 和 <code>mro</code>。</p>
</div>
<div class="paragraph">
<p><code>name</code> 方法返回的是类的名称。注意，<code>WHAT</code> 方法返回的是一个类型对象，当我们打印出来的时候，它是以 <code>(ClassName)</code> 的格式字符串化的，而 <code>Perl6::Metamodel::ClassHOW</code> 类的 <code>name</code> 方法返回的是一个字符串。这就是 <code>name</code> 方法的调用方式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $c.HOW.name($c); # C</code></pre>
</div>
</div>
<div class="paragraph">
<p>在给定的变量 <code>$c</code> 上，方法 <code>HOW</code> 被调用。它返回一个对象，在这个对象上调用 <code>name</code> 方法，并将变量 <code>$c</code> 作为参数。这种冗余是在 Raku 开发者考虑到未来的一些计划而做的。为了实用的目的，使用另一种更简单的语法比较容易。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $c.^name; # C</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>HOW.mro</code>，简称 <code>^mro</code>，方法（名字代表方法解析顺序）返回一个显示类层次结构的列表。它可以用来了解如何解决名称冲突。</p>
</div>
<div class="paragraph">
<p>例如，这里有几个类的子类-父类关系:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {}
class B is A {}
class C is A {}
class D {}
class E is D is B is C {}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>^mro</code> 方法可以在类名和类的对象上调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say E.^mro;

my $e = E.new;
say $e.^mro;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下，将打印以下字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">((E) (D) (B) (C) (A) (Any) (Mu))</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在复杂的层次结构中出现困难的关系，可以调用这个方法，看看 Raku 内部是怎么看的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_方法后缀运算符">8.9. 方法后缀运算符</h3>
<div class="paragraph">
<p>在第四章《使用运算符》中，我们并没有涉及到特殊的后缀运算符集，这与面向对象编程有关。现在是时候填补这个空白了。本节中描述的运算符是语法结构，但它们都可以被认为是后缀运算符。</p>
</div>
<div class="paragraph">
<p>在对象上调用一个方法时，会用到点运算符。我们在本章中已经多次使用过它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    method m() {
        return 42;
    }
}

my $o = A.new; # calling the 'new' method
say $o.m();    # calling the 'm' method</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果该方法不存在，比如说，如果你调用 <code>$o.n()</code>，则调用失败:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">No such method 'n' for invocant of type 'A'</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了防止异常的产生，<code>.?</code> 形式的方法调用运算符可以提供帮助:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $o.?m(); # 42
say $o.?n(); # Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个现有的方法像往常一样被调用，而非现有的方法的调用则返回 <code>Nil</code>，程序继续进行。</p>
</div>
<div class="paragraph">
<p><code>.+</code> 和 <code>.*</code> 操作符用于调用所有给定名称的方法。当你有一个类的层次结构时，这可能很有用。考虑一下下面的程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    method m() {
        return 'A::m';
    }
}

class B is A {
    method m() {
        return 'B::m';
    }
}

my $o = B.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>m</code> 方法在父类和子类中都有定义，所以 <code>$o.m()</code> 的调用被路由到 <code>B</code> 类的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $o.m(); # B::m</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.+</code> 方法调用所有的方法, 并返回一个结果列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @result = $o.+m();
say @result; # [B::m A::m]</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你所看到的，调用 <code>$o.+m()</code> 会导致按 <code>$o.^mro</code> 的顺序调用 <code>m</code> 个方法（详见上一节《内省》）。</p>
</div>
<div class="paragraph">
<p>如果方法名称未知，就会发生异常。例如，不能调用 <code>$o.+n()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">No such method 'n' for invocant of type 'B'</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.*</code> 操作符的工作原理类似于 <code>.+</code> 操作符，但允许尝试调用一个不存在的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $o.*m(); # (B::m A::m)
say $o.*n(); # ()</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 <code>n</code> 方法，会返回一个空的结果列表。为了记住这些操作符，你可以将 <code>+</code> 和 <code><strong></code> 与正则表达式中使用的相应的量词的语义进行比较(参见第十一章，Regexes)。 <code>+</code> 表示至少应该有一个带这个名字的方法，而 <code></strong></code> 允许任意数量的方法，包括 0。</p>
</div>
<div class="paragraph">
<p>现在让我们看看在同一个例子中，我们如何从基类中调用方法。有一个 <code>.::</code> 操作符，可以用来完全限定调用方法的名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $o.A::m(); # A::m</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，<code>$o</code> 变量是 <code>B</code> 类的一个对象，但在 <code>.::</code> 操作符的帮助下，父类的方法 <code>A::m</code> 被调用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_9">8.10. 总结</h3>
<div class="paragraph">
<p>在本章中，我们学习了 Raku 中的面向对象支持。我们经历了创建一个类，为其添加属性和方法，以及使方法和类数据为公共或私有。然后，我们讨论了类的层次结构和使用角色的另一种方法，以及如何使用 Raku 的内置设施来内省对象。在一组例子中，我们考察了许多处理复杂对象的技巧。最后，我们还列出了后缀方法操作符，利用这些操作符，你可以创建更多的通用和健壮的程序。</p>
</div>
<div class="paragraph">
<p>在下一章中，我们将介绍异常。在 Raku 中，它们是以类为基础的，所以本章的知识对更好地理解异常会有很大的帮助。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_输入和输出">9. 输入和输出</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章专门介绍输入和输出，主要基于 Raku 中的 <code>IO::Handle</code> 类。计算机程序通常与用户通信。它可能是控制台应用程序中的输入和输出，或读取配置文件或保存
结果到磁盘上的文件。在本章中，我们将讨论 Raku 中的输入和输出设施。</p>
</div>
<div class="paragraph">
<p>本章将介绍以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>标准输入和输出</p>
</li>
<li>
<p>使用文件</p>
</li>
<li>
<p>分析文件和目录的属性</p>
</li>
<li>
<p>读取输入流的方法</p>
</li>
<li>
<p>写到输出流的方法</p>
</li>
<li>
<p>格式化输出</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_从流中读取">9.1. 从流中读取</h3>

</div>
<div class="sect2">
<h3 id="_写出到流">9.2. 写出到流</h3>

</div>
<div class="sect2">
<h3 id="_标准输入和输出">9.3. 标准输入和输出</h3>
<div class="paragraph">
<p>在前面的章节中，我们创建了许多可以打印到控制台并从控制台读取的程序。让我们刷新一些第二章中编写代码的知识，并创建一个询问用户的名字并问候他们程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = prompt 'What is your name? ';
say "Hello, $name!";
note "Greeted $name at " ~ time;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，<code>prompt</code> 函数打印消息并等待用户输入字符串。该字符串被保存在 <code>$name</code> 变量中，稍后被插值到双引号字符串中。<code>note</code> 函数打印调试消息并记录受到欢迎的时间。</p>
</div>
<div class="paragraph">
<p>在这个程序中，Raku 使用两个标准通信通道，即标准输入流(简称 stdin)和标准输出流(stdout)。这些是接收用户输入并接受程序打印内容的默认流。另一个通道，我们在第二章的编写代码中已经提到过，是打印错误消息和警告的流，即标准错误输出(stderr)。</p>
</div>
<div class="paragraph">
<p>在 Linux 系统上，POSIX 标准确定文件描述符编号为数字 0, 1 和 2 分别是 stdout，stdin 和 stderr。在 Raku 中，有三个具有动态作用域的特殊变量，<code>$*OUT</code>，<code>$*IN</code> 和 <code>$*ERR</code>， 它们默认附加到这些通道上。</p>
</div>
<div class="paragraph">
<p><code>print</code> 和 <code>warn</code> 等内置函数使用 <code>$*OUT</code>，<code>$*IN</code> 和 <code>$*ERR</code> 的值。 下表显示了函数和通道之间的对应关系:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">函数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">输入或输出方向</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">输入或输出流</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">print</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">output</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*OUT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">say</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">output</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*OUT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">prompt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">output</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*OUT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">prompt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">input</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*IN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">note</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">output</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*ERR</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">warn</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">output</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*ERR</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><code>$*OUT</code>，<code>$*IN</code> 和 <code>$*ERR</code> 变量是 <code>IO::Handle</code> 类的实例。让我们来探索它。</p>
</div>
<div class="paragraph">
<p><code>IO::Handle</code> 类表示打开的文件或输入/输出流。在 Raku 中，这个类实现了 <code>IO</code> 角色。在本节中，我们将讨论 <code>IO::Handle</code> 类和 <code>IO</code> 角色赋予程序员的最有用的方法。</p>
</div>
<div class="paragraph">
<p>我们将学习的内容适用于标准输入/输出流和使用文件。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用文件和目录">9.4. 使用文件和目录</h3>
<div class="paragraph">
<p>和很多其它语言一样，在 Raku 中使用文件是通过文件句柄来完成的。 打开文件后立即获得文件句柄; 稍后，你使用该句柄写入文件或者从中读取。所有其他操作，例如刷新缓冲区或关闭文件，也都是通过句柄执行的。</p>
</div>
<div class="sect3">
<h4 id="_打开文件">9.4.1. 打开文件</h4>
<div class="paragraph">
<p>要打开文件，请使用 <code>open</code> 函数(它由 <code>IO</code> 角色提供，但可以用作简单的内置函数)。它接收一个文件路径和许多可选参数。 返回值是文件句柄，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open '/etc/passwd';</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，文件以只读模式打开。可以显式地使用命名参数传递模式名称。以上示例等同于以下代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open '/etc/passwd', :r;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下表列出了打开文件的可能模式:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">参数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:r</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">只读模式。这是默认模式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">只写模式。文件不存在则创建，文件存在则覆盖。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:rw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可读可写模式。文件不存在则创建，文件存在则覆盖。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">追加模式。文件不存在则创建，文件存在把数据追加到现有文件的末尾。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>根据打开文件的模式，<code>IO::Handle</code> 类中的一组方法将可用。例如，你无法写入使用 <code>:r</code> 选项打开的文件，即使文件句柄仍然是通用的 <code>IO::Handle</code> 类的实例。在这种情况下将抛出 <code>X::AdHoc</code> 异常:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open '/etc/passwd', :r;
try {
    $fh.say('Hello'); # Attempt to write to a read-only file
}
say $!.^name;         # X::AdHoc, see details in Chapter 10, Exceptions</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>open</code> 函数还接受一些配置参数，如下表所示:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">参数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:bin</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">以二进制模式打开文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:enc('encoding')</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">给文件关联给定的编码。查看写入到流一节中的例子。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:chomp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果 :chomp 被设置为真，那么按行读取时，新行符会被截断(请参阅从流中读取一节)</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_关闭文件">9.4.2. 关闭文件</h4>
<div class="paragraph">
<p>要关闭文件，请在文件句柄上调用 <code>close</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open '/etc/passwd';
# .... read from file
$fh.close;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_测试文件和目录属性">9.4.3. 测试文件和目录属性</h4>
<div class="paragraph">
<p><code>IO</code> 角色提供了许多单字母方法来检查文件和目录的不同指标。返回值是布尔值。下表中列出了这些方法:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">e</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查路径是否存在</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查路径是否为已存在的目录</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">f</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查路径是否为已存在的文件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">l</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查路径是否为符号链接</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">r</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查路径是否可访问(因此，已设置读取位)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查路径是否可写(已设置写位)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查路径是否可执行(已设置执行位)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查路径是否可读和可写</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rwx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查是否为路径设置了所有 r，w 和 x 位</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查文件是否为非空</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">z</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查文件大小是否为零</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>将这些方法视为示例。由于方法是在 <code>IO</code> 角色中定义的，我们必须首先在可以表示路径的变量上调用 <code>IO</code> 方法来访问它们。例如，它可以是文字字符串或包含文件或目录路径的变量。还有，你可以在文件句柄上调用 <code>IO</code> 方法。</p>
</div>
<div class="paragraph">
<p>我们来看几个例子。检查文件是存在:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $path = '/etc/passwd';
say "File $path exists" if $path.IO.e;</code></pre>
</div>
</div>
<div class="paragraph">
<p>检查目录是否存在:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if '/Users'.IO.d {
    say '/Users is a directory';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>d</code> 方法仅适用于目录。如果路径存在但它是一个文件，那么该方法返回 <code>False</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Not a directory' unless '/etc/passwd'.IO.d;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要检查路径是否存在，请使用 <code>e</code> 方法。结果不取决于路径是目录还是文件:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'File or directory exists' if '/'.IO.e;</code></pre>
</div>
</div>
<div class="paragraph">
<p>用于测试文件和目录属性的所有上述方法都可以与使用智能匹配运算符和以冒号开头的副词结构的不同语法一起使用，例如 <code>:e</code>。以下示例介绍了如何执行此操作; 两行代码都是一样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Exists' if 'data.txt'.IO.e;
say 'Exists' if 'data.txt'.IO ~~ :e;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_操纵文件">9.4.4. 操纵文件</h4>
<div class="paragraph">
<p>可用于 <code>IO::Handle</code> 类型的对象的 <code>path</code> 方法返回 <code>IO::Path</code> 对象，这对于处理磁盘上的物理文件很方便。<code>IO::Path</code> 类为程序员提供了一些重命名，移动或删除文件的方法。这些方法也作为内置函数存在，因此你无需获取或创建 <code>IO::Path</code> 对象来操纵磁盘上的文件。成功后，他们会返回 <code>True</code> 值。如果有错误， 可能会抛出异常。</p>
</div>
<div class="paragraph">
<p>在下表中，我们总结了操纵路径最常用的函数:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">函数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">例子</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">copy</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">复制文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">copy 'data.txt', 'data-copy.txt';</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rename</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">重命名文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">rename 'old.txt', 'new.txt';</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">move</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">移动文件(将文件复制为新文件然后删除原文件)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">move '/old/path/to/file', '/new/path/to/file';</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">unlink</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">删除文件(不像move，它不复制文件)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unlink 'secret.txt';</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">symlink</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">创建符号链接</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">symlink 'target.txt', 'existing-file.txt';</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">chmod</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">更改文件权限</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">chmod 0o755, 'prog.pl'; Notice the octal notation</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>拥有 <code>IO</code> 对象后，你可能会获得该文件的许多特征。我们来简单地看看。</p>
</div>
<div class="paragraph">
<p><code>mode</code> 方法返回路径的访问模式位。考虑一个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '/etc/passwd'.IO.mode;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码打印诸如 <code>0644</code> 之类的值。请注意，此方法返回 <code>IntStr</code> 类型的对象，到目前为止我们没有在本书中介绍过这种类型。这是一个双重值，在
字符串上下文中它包含八进制值 "0644" 的字符串表示形式，而在整数上下文它是一个整数值 420，如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '/etc/passwd'.IO.mode.Str; # 0644
say '/etc/passwd'.IO.mode.Int; # 420</code></pre>
</div>
</div>
<div class="paragraph">
<p>其他三种方法，<code>modified</code>，<code>accessed</code> 和 <code>changed</code>，返回相应路径的时间属性。返回值是 <code>Instant</code> 类型的对象。得到纪元值或 <code>Date</code> 对象，另外调用 <code>Int</code> 或 <code>Date</code> 方法，如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '/etc/passwd'.IO.modified;      # Instant:1383139040
say '/etc/passwd'.IO.modified.Int;  # 1383139040
say '/etc/passwd'.IO.modified.Date; # 2013-10-30</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用目录">9.4.5. 使用目录</h4>
<div class="paragraph">
<p><code>IO::Path</code> 类有一些处理目录的方法。我们将在这一节中讨论它们。同样，例程可以作为方法和独立子例程访问。</p>
</div>
<div class="paragraph">
<p><code>chdir</code> 函数更改当前工作目录。可以从 <code>$*CWD</code> 变量读取当前路径。该值是 <code>IO</code> 类型。要获取字符串，请使用 <code>Str</code> 方法或添加 <code>~</code> 前缀将其字符串化，如下面的代码所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $*CWD.Str; # /Users/ash/code, for example
chdir '/tmp';
say ~$*CWD;    # /tmp</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建和删除目录是通过 <code>mkdir</code> 和 `rmdir 例程完成的。创建目录时，可以传递可选参数以设置权限模式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">mkdir 'data';
mkdir 'data/secret', 0o400;</code></pre>
</div>
</div>
<div class="paragraph">
<p>目录为空时 <code>rmdir</code> 例程才有效。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">mkdir 'temp';
# ... do something
rmdir 'temp';</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>dir</code> 函数将目录的内容作为 <code>IO</code> 对象的列表返回。这是你列出当前的工作目录的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @dir = dir;
say $_.Str for @dir;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要指定目录的路径，请将其作为参数传递，或者在字符串上创建 <code>IO</code> 对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @root_dir = dir('/');
my @temp_dir = '/tmp'.IO.dir;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们知道如何使用文件和目录，我们移到读写数据的方法。</p>
</div>
<div class="paragraph">
<p>在下一节中，我们将讨论 <code>IO::Handle</code> 类中读写数据的方法。为简单起见，许多代码示例都使用标准输入和输出。虽然，它们将使用 <code>open</code> 函数返回的 <code>$fh</code> 文件句柄。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_从流中读取_2">9.5. 从流中读取</h3>
<div class="paragraph">
<p><code>IO::Handle</code> 类提供了许多不同的方法供我们读取流。我们已经在第二章的编写代码中的简单的输入和输出一节中看到过一些。在这里，我们将详细讨论它们并查看其他替代方案。</p>
</div>
<div class="sect3">
<h4 id="_读取一行">9.5.1. 读取一行</h4>
<div class="paragraph">
<p>我们从 <code>get</code> 方法开始，该方法从输入流中读取一行。例如，从标准输入读取一行，在 <code>$*IN</code> 实例上调用方法，如下面的例子所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = $*IN.get;
say $line;</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序等待你输入一些文本。该行完成并按下 'Enter' 键后，<code>get</code> 方法将控制返回给程序，然后将行打印到屏幕。或者，你可以使用命令行解释程序的基础设施来重定向输入流并将文件的内容传递给程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku get.pl &lt; get.pl
my $line = $*IN.get;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这次，程序打印出程序自身的第一行。</p>
</div>
<div class="paragraph">
<p>代码中的 <code>$*IN.get</code> 构造等同于 <code>get</code> 的裸调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $line = get;
say $line;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用文件时，请以与我们刚刚使用 <code>$*IN</code> 相同的方式打开文件句柄:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open 'data.txt', :r;
my $line = $fh.get;
say $line;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在运行此程序之前，请创建一个新文件 <code>data.txt</code> 并在其中放入一些文本。如果是文件不存在，<code>$fh</code> 句柄将被设置为 <code>Failure</code> 对象，并且 <code>get</code> 方法的以下调用会引发错误(请在第十章的使用异常中查看更多关于异常和失败的错误):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Failed to open file /Users/ash/code/data.txt: no such file or directory
  in block &lt;unit&gt; at open.pl line 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_读取字符">9.5.2. 读取字符</h4>
<div class="paragraph">
<p>要获取单个字符，请使用 <code>getc</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $ch = $*IN.getc;
say $ch;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>getc</code> 方法阻止程序执行，直到字符出现在流中。如果流中没有剩余字符，则返回空值 <code>Any</code>。在布尔值上下文中，它是假的，所以它可以用在循环条件中。让我们创建一个按字符读取其输入字符的程序，并在单独的行上打印它们。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">while my $ch = $*IN.getc {
    say $ch;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当处理 Unicode 字符时，<code>getc</code> 方法非常智能。为了展示这个行为，让我们创建一个文本文件 <code>text.txt</code>，并在其中放入一个 <code>u</code> 字符。然后， 将文件传递给程序并读取字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku getc.pl &lt; text.txt
u</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个带有 ASCII 子空间字符的单字节。现在，让我们使用另一种字符，比方说，拉脱维亚语你(u)上面有一个横线: ū。在 Unicode 中，此字符称为 <code>LATIN SMALL LETTER U WITH MACRON</code>，其码位号为 <code>0x016B</code>。在 UTF-8 编码中，该字符由两个字节组成: <code>0xC5</code> 和 <code>0xAB</code>。所以，如果你把该字符保存在文件中，它的大小将是两个字节。现在针对此文件运行程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku getc.pl &lt; text.txt
ū</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们所见，Raku 设法理解这个以两个字节表示开头单个 UTF-8 字符的文件。</p>
</div>
<div class="paragraph">
<p>现在，<code>getc</code> 的任务有点复杂。这次我们将使用该字符的分解版本。在 UTF 编码中，诸如 ū 之类的字符可以被替代地存储为两个元素的序列: 代码位为 <code>0x0075</code>(与在 ASCII 中相同)的 <code>LATIN SMALL LETTER U</code>，和 <code>COMBINING MACRON</code>(0x0304)。</p>
</div>
<div class="paragraph">
<p>我们将它保存在一个文件中。其中一种方法是使用 Raku，打印相应的字节，并将输出重定向到文件。这就是你用单行做的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku -e'print "u"; print 0x0304.chr' &gt; text.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>要打印字符而不是整数值，请调用 <code>chr</code> 方法: <code>0x0304.chr</code>。 该文件现在包含三个字节: <code>75 CC 84</code>。将其传递给我们的程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku getc.pl &lt; text.txt
ū</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序中只有一次 <code>getc</code> 调用，它会打印出正确的字符。Raku 在它看到一个有效的 ASCII 字符后不立即停止，但试图验证后面的字节是否仍然是组合字符的 Unicode 表示的一部分。</p>
</div>
<div class="paragraph">
<p>现在，我们让这项工作变得更加复杂，并构建一个不存在的字符， 假设 u 上面有一个双重波浪号，下面是一个“逗号”。此字符在 Unicode 中没有代码点，但它仍然可以用三个元素构造 - <code>COMBINING ALMOST EQUAL TO ABOVE (0x034C)</code> 和 <code>COMBINING CEDILLA (0x0327)</code>。准备文本文件:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku -e'print "u"; print 0x034C.chr; print 0x0327.chr' &gt; text.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>这三个元素现在位于 UTF-8 编码-<code>75 CD 8C CC A7</code> 中的五个字节中。仍然，Raku 将其作为单个字符读取，因为你可以再次通过运行程序来验证:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku getc.pl &lt; text.txt
u̧͌</code></pre>
</div>
</div>
<div class="paragraph">
<p>要一次读取多个字符，请使用 <code>readchars</code> 方法。它的工作原理类似于 <code>getc</code> 方法但返回一个包含字符的字符串。要读取的最大字符数作为参数传递:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = $*IN.readchars(12); # read 12 characters from standard input
say $str;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，要重现本节中的示例，你需要一个支持的 Unicode 的终端。</p>
</div>
</div>
<div class="sect3">
<h4 id="_惰性读取">9.5.3. 惰性读取</h4>
<div class="paragraph">
<p><code>IO::Handle</code> 类定义了一些惰性读取的方法。这里的惰性意味着，当程序确实需要另一部分时，Raku 才实际执行读取数据。所以它不应该立即读取整个文件。</p>
</div>
<div class="paragraph">
<p><code>lines</code> 方法返回一个行列表。这是一个把输入复制为输出的短程序的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for lines;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可以使用更传统的语法以不同的形式重写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $*IN.lines -&gt; $line {
    say $line;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$*IN.lines</code> 的调用返回一个输入行的数组。我们可以直接将它保存在变量中，并用于打印:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @lines = $*IN.lines;
.say for @lines;</code></pre>
</div>
</div>
<div class="paragraph">
<p>重要的是 <code>lines</code> 方法删除末尾的换行符。因此，如果你需要重现它，请使用 <code>say</code> 函数在输出的结尾打印换行。</p>
</div>
<div class="paragraph">
<p><code>lines</code> 方法接受一个整数参数来指示要读取的最大行数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for $*IN.lines(3); # prints the first 3 lines from input</code></pre>
</div>
</div>
<div class="paragraph">
<p>从输入流中读取逻辑数据的另一种方法是使用 <code>words</code> 方法。它类似于前面描述的 <code>lines</code> 方法，但是将输入拆分为单词而不是行。分隔符是一系列空格。考虑一个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for $*IN.words;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序在单独的行上打印输入中的每个单词。</p>
</div>
<div class="paragraph">
<p><code>split</code> 方法概括了一种读取逻辑元素的方法，并允许我们指定一个用于分隔元素的拆分器。例如，下面这段代码教你如何用冒号分隔输入:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for $*IN.split(':');</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，例如，从 <code>/etc/passwd</code> 文件提供一行，程序会将它的各个部分打印出来:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ cat /etc/passwd | grep nobody | raku split.pl
nobody
*
-2
-2
Unprivileged User
/var/empty
/usr/bin/false</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>comb</code> 方法返回它在输入流中找到的所有匹配项的列表。对于匹配，使用正则表达式。我们将在第十一章的正则表达式一节中讨论正则，但这是一个从输入中提取所有数字的简单示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @numbers = $*IN.comb(/\d+/);
say @numbers.join(', ');</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下输入演示了此程序的工作原理。输入文本后，程序打印它找到的以逗号分隔的整数列表。粗体的行是你的输入:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku comb.pl
There are 3 points in a triangle, 4 points in a square,
and 5 points in a star.
3, 4, 5</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_eof_方法">9.5.4. eof 方法</h4>
<div class="paragraph">
<p>只有当数据存在时，才能从文件中读取数据。检查文件或流是否仍然包含数据，请使用 <code>eof</code> 方法，当到达文件结尾时返回 <code>False</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open 'data.txt';
if $fh &amp;&amp; !$fh.eof { # Only if file exists and has something to read
    my $line = $fh.get;
    say $line;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_写入流">9.6. 写入流</h3>
<div class="paragraph">
<p>在本节中，我们将研究 <code>IO::Handle</code> 类为写入流提供的方法。</p>
</div>
<div class="sect3">
<h4 id="_print_函数">9.6.1. print 函数</h4>
<div class="paragraph">
<p>我们将从简单的 <code>print</code> 函数开始。基本上，它的用法很明显。它把文本打印到流。在标准输出的情况下，使用裸的 <code>print</code> 函数或 <code>$*IN.print</code> 方法。如果使用文件，请使用其文件句柄。</p>
</div>
<div class="paragraph">
<p>以下程序创建一个名为 <code>hello.txt</code> 的文件，并写入字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open 'hello.txt', :w; # Open a file for writing
$fh.print('Hello, World');     # Print to the file
$fh.close;                     # Close the file so that the data is saved</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果文件已存在，则将重写该文件，之前的所有内容都将丢失。如果需要将新输出附加到现有文件，则使用 <code>:a</code> 追加模式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open 'hello.txt', :a; # Open in append mode
$fh.print('!');                # Now the file contains 'Hello, World!'
$fh.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>close</code> 方法关闭文件。实际上，不需要手动关闭文件，因为一旦文件句柄超出其作用域，Raku 将立即关闭该文件。</p>
</div>
<div class="paragraph">
<p><code>open</code> 函数的 <code>:enc</code> 命名参数设置文件的编码。考虑一下以下代码。它打开两个文件并打印相同的字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = 'ä';

my $fh1 = open 'enc-latin1.txt', :w, enc =&gt; 'Latin1';
$fh1.print($str);
$fh1.close;

my $fh2 = open 'enc-utf-8.txt', :w, enc =&gt; 'UTF-8';
$fh2.print($str);
$fh2.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，查看该程序创建的文件的文件大小:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ ls -la enc-*.txt
-rw-r--r-- 1 ash ash 1 Mar 16 07:59 enc-latin1.txt
-rw-r--r-- 1 ash ash 2 Mar 16 07:59 enc-utf-8.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如所料，其中一个文件是用 Latin-1 编码编写的。ä 字符很适合这种编码，所以文件内容是一个带有字符代码的单字节:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ hexdump enc-latin1.txt
0000000 e4
0000001</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二个文件使用 UTF-8 编码，同一个字符需要两个字节:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ hexdump enc-utf-8.txt
0000000 c3 a4
0000002</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，两种编码都能够表示写入到文件的字符。如果所选编码不支持，则会发生运行时错误。在下一个程序中，我们尝试将 Unicode 笑脸以 Latin-1 编码写入打开的文件中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open 'smiley.txt', :w, :enc('Latin1');
$fh.print(0x263a.chr); # The WHITE SMILING FACE character
$fh.close;
say 'OK?';</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序在尝试写入文件时退出，而程序的其余部分则不会执行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Error encoding Latin-1 string: could not encode codepoint 9786
  in block &lt;unit&gt; at enc2.pl line 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在之前的程序中，使用了两种不同的语法选项来为函数的命名参数传递值-<code>enc &#8658; 'UTF-8'</code> 和 <code>:enc('Latin1')</code>。 两种形式都是等同的; 你可以选择你喜欢的那个。</p>
</div>
</div>
<div class="sect3">
<h4 id="_say_方法">9.6.2. say 方法</h4>
<div class="paragraph">
<p>乍一看，<code>say</code> 方法与 <code>print</code> 方法类似，并在末尾添加一个换行符。但这不是全部的真相。在内部，<code>say</code> 在对象上调用 <code>gist</code> 方法以获得它的文本表示。</p>
</div>
<div class="paragraph">
<p>对于字符串和整数等数据类型，它们的文本形式很简单。在下面的例子中，<code>print</code> 和 <code>say</code> 的输出没有区别:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = 'String';
print $str, "\n";
say $str;

my $int = 42;
print $int, "\n";
say $int;</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于更复杂的数据结构，这两种方法的行为是不同的。该程序的输出显示在注释中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array = &lt;10 20 30&gt;;
print @array, "\n"; # 10 20 30
say @array;         # [10 20 30]

my %hash = alpha =&gt; 1, beta =&gt; 2, gamma =&gt; 3;
print %hash, "\n";  # alpha   1
                    # beta 2
                    # gamma   3
say %hash;          # {alpha =&gt; 1, beta =&gt; 2, gamma =&gt; 3}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用_gist_方法的示例">9.6.3. 使用 gist 方法的示例</h4>
<div class="paragraph">
<p>对于用户定义的类，可以创建一个准备按预期输出的 <code>gist</code> 方法。让我们在下面的例子中尝试这个。</p>
</div>
<div class="paragraph">
<p>我们创建了一个用于存储化学公式的类。目标是允许以纯 ASCII 格式制造化学公式，然后打印它，以使数字索引显示为下标。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Chemical {
    has $.formula;
    method gist {
        my $output = $!formula;
        $output ~~ s:g/(&lt;[0..9]&gt;)/{(0x2080+$0).chr}/;
        $output;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Chemical</code> 类有一个数据成员 <code>$.formula</code>，它将原始 ASCII 公式保留为字符串。<code>gist</code> 方法将其转换为带有下标的字符串。我们用正则表达式做替换。正则表达式在第十一章的正则表达式一节中有详细介绍。现在，只需知道以下代码行将从 0 到 9 的数字替换为其下标版本就足够了。要获取下标数字的代码值，用公式中数字值加上 <code>SUBSCRIPT ZERO</code> Unicode 字符的代码点值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$output ~~ s:g/(&lt;[0..9]&gt;)/{(0x2080+$0).chr}/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，是时候使用这个类了。在循环中，创建了几个实例来测试不同的情况: 简单的公式，带括号的公式和带两位数字索引的公式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt; H2O Al2(SO4)3 Al6O13Si2 &gt; {
    my $chem = Chemical.new(formula =&gt; $_);
    say $chem;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序给出以下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你使用 <code>print</code> 函数而不是 <code>say</code>，那么输出将是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Chemical<i class="conum" data-value="140226845929544"></i><b>(140226845929544)</b>
Chemical<i class="conum" data-value="140226845929664"></i><b>(140226845929664)</b>
Chemical<i class="conum" data-value="140226845929704"></i><b>(140226845929704)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>此输出包含类的名称和内存中变量位置的地址。要使输出对最终用户更有用，请为其类定义 <code>gist</code> 方法并使用 <code>say</code> 函数来 'print' 对象。</p>
</div>
</div>
<div class="sect3">
<h4 id="_printf_方法">9.6.4. printf 方法</h4>
<div class="paragraph">
<p><code>printf</code> 方法以给定格式打印值。它大部分都与来自 C 和 C++ 标准库的 <code>printf</code> 函数相同。这个方法的第一个参数是描述格式的字符串，其余参数是将要替换为指令的值
，从格式字符串中的 <code>%</code> 字符开始。</p>
</div>
<div class="paragraph">
<p>在许多情况下，可以通过字符串插值来实现格式化。例如，以下两行产生相同的输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $temperature = 25.6;
printf("Temperature is %g °C\n", $temperature);
say "Temperature is $temperature °C";</code></pre>
</div>
</div>
<div class="paragraph">
<p>在下表中，列出了主要的格式化指令。</p>
</div>
</div>
<div class="sect3">
<h4 id="_字符和字符串">9.6.5. 字符和字符串</h4>
<div class="paragraph">
<p>我们从打印文本数据开始:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">指令</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%%</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">% 字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%c</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个 字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个字符串</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>下面是一些上述表格中的指令的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">printf "The percent sign: %%\n";
printf "Character %c\n", 167;
printf "String %s\n", 'Hello, World';</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序打印如下行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The percent sign: %
Character §
String Hello, World</pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>%c</code> 指令把对应的参数当作字符, 而不是当作整数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_整数">9.6.6. 整数</h4>
<div class="paragraph">
<p>有几个用于以不同格式打印整数的不同指令:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">指令</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">二进制表示的整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%d 或 %i</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">有符号十进制整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%u</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无符号十进制整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%o</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">八进制格式的整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">十六进制格式的无符号整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与 %x 相同但是以大写字母表示</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>让我们以不同的格式打印相同的数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">printf "Binary: %b, decimal: %d, octal: %o\n", 10, 10, 10;
printf "Hexadecimal: %x, uppercased: %X\n", 10, 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序的输出看起来像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Binary: 1010, decimal: 10, octal: 12
Hexadecimal: a, uppercased: A</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>%u</code> 指令需要一个无符号整数，因此如果看到一个负数，编译器则会引发错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">$ raku -e'printf "%u", -10'
negative value '-10' for %u in sprintf
Directive u not applicable for type Int</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_浮点数字">9.6.7. 浮点数字</h4>
<div class="paragraph">
<p>对于浮点数，请使用以下格式之一:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">指令</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%e</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">以科学计数法表示的浮点数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">和 %e 相同但是大写字母 E 表示指数部分</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%f</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个浮点数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%g</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">%e 或 %f(以较好者为准)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在以下示例中，<code>pi</code> 的值以不同的格式打印:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">printf "%e, %E\n", pi, pi;
printf "%f, %g\n", pi, pi;</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果是这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">3.141593e+00, 3.141593E+00
3.141593, 3.14159</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>%g</code> 格式是最“人性化”的 - 它显示精度有限的浮点数，切换到非常大和非常小的科学记数法数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">printf "%g\n", 0.000001; # 1e-06
printf "%g\n", 0.1;      # 0.1
printf "%g\n", 1;        # 1
printf "%g\n", 10;       # 10
printf "%g\n", 10000000; # 1e+07</code></pre>
</div>
</div>
<div class="paragraph">
<p>格式化字符串后传递的参数数量必须与其指令的数量一致 。否则会发生 <code>X::Str::Sprintf::Directives::BadType</code> 异常:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku -e'printf "%c", 1, 2'
Your printf-style directives specify 1 argument, but 2 arguments were
supplied</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关格式化字符串的详细说明，请参阅以下文档页面的内容: docs.raku.org/type/Str#sub_sprintf。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_10">9.7. 总结</h3>
<div class="paragraph">
<p>在本章中，我们讨论了 Raku 中提供的输入和输出功能。 <code>IO::Handle</code> 类提供了使用标准输入和输出流的通用方法以及使用相同接口的文件。我们讨论了如何创建文件和
如何测试文件和目录的不同属性并检查各种读写方法。</p>
</div>
<div class="paragraph">
<p>处理文件时，你有时可能会遇到异常情况; 我们已经在本章中看到了一些例子。在下一章中，我们将详细地讨论 Raku 中的异常。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_异常">10. 异常</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在前两章中，我们讨论了面向对象的编程和关于 输入和输出，使用对象实现。在本章中，我们将继续努力 与对象和将讨论Raku中的另一个领域，其实现广泛使用 类和具有庞大的层次结构。</p>
</div>
<div class="paragraph">
<p>例外情况是程序进入无法进一步运行的状态。 一些例外是由程序设计中的缺陷引起的，其他例外是​​由于
外部因素，例如磁盘故障或与数据库的连接断开。在这种情况下，一个
异常并不是一种非常特殊的东西，它必须停止程序，而是一种处理方式
错误并继续执行。
在本章中，我们将讨论程序可能面临的异常情况。
此外，我们还将看到程序员可以预防后果的方法
特殊时刻。
本章将介绍以下主题:
试块 使用CATCH阶段块捕获异常 异常类
投掷和重新抛出异常 Failure类和软故障 使用类型化异常 创建自定义例外</p>
</div>
<div class="sect2">
<h3 id="_try_块">10.1. try 块</h3>

</div>
<div class="sect2">
<h3 id="_catch_phaser">10.2. CATCH phaser</h3>

</div>
<div class="sect2">
<h3 id="_exception_对象">10.3. Exception 对象</h3>

</div>
<div class="sect2">
<h3 id="_failure_对象">10.4. Failure 对象</h3>

</div>
<div class="sect2">
<h3 id="_创建自定义异常">10.5. 创建自定义异常</h3>

</div>
<div class="sect2">
<h3 id="_总结_11">10.6. 总结</h3>
<div class="paragraph">
<p>试块
让我们从一个最简单的例外开始，除以零。运行以下一项 - 衬垫:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序中断并打印以下错误消息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们不能除以零。请注意，错误消息还包含堆栈跟踪
程序。由于我们不使用任何模块或具有任何函数调用，因此堆栈跟踪很短。
现在，让我们在除法之前和之后做一些其他操作，这会失败:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于零除零的异常在运行时发生。所以，程序执行
第一行并打印第一条消息。然后，发生异常和程序
终止。将不会执行任何其他操作，并且永远不会到达最后一行。</p>
</div>
<div class="paragraph">
<p>现在让我们通过从外部输入值来更改内置值。让用户输入
划分的数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你运行这个程序，它将要求两个数字并打印他们的部门的结果。
尝试使用一些非零值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用例外 现在尝试输入零作为除数。马上，你得到一个异常:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>此行为可能不是该计划最期望的结果。我们应该做到
程序更稳定，因此它不依赖于来自外部的错误数字。
在Raku中，代码中有问题的部分可以放在try块中。在我们的例子中， 这部分代码是除法操作的行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们将其与打印结果的行一起放在try块中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，我们在此程序中的try块之后有一些代码。 使用与以前相同的输入值运行它。首先，非零数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>完成。
该程序的行为与引入try块之前的行为完全相同。 现在，尝试零:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>而已。这里有三件事需要注意。首先，我们没有看到有关的错误消息 非法分裂。二，字符串&#8230;&#8203;&#8230;&#8203;的结果不打印。三，代码 在执行块之后执行并打印。</p>
</div>
<div class="paragraph">
<p>这里发生了什么?在try块内部，异常发生，但事实并非如此 停止执行程序。try块隐藏了我们的例外事实。的 当然，我们输掉了结果，但我们保留了继续使用的能力 程序。</p>
</div>
<div class="paragraph">
<p>$!变量</p>
</div>
<div class="paragraph">
<p>现在让我们看看如果发生了错误，我们怎么能理解。在Raku中，有 一个特殊的变量$!，称为错误变量。如果它发生，它包含一个例外。让 我们用它来检查一切是否正常:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果$!我们添加了测试。它对待$!布尔上下文中的变量。实际上，价值 存在异常时变量的值是Exception类型的值。我们会看到 它将在本章后面的The Exception对象部分中介绍。现在，知道这一点就足够了 在布尔上下文中，Exception给出True值。如果没有例外，那就是
$!变量将包含Any类型的对象，在布尔上下文中为False。
如果你运行更新的程序并传递零作为除数，程序将打印出
失败!信息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>软故障</p>
</div>
<div class="paragraph">
<p>在前面的示例中，try块包含两个数学计算的指令 并打印结果。在实际程序中，这些操作通常是分开的。让我们重新写一下 程序，以便它将数字分成一个单独的子程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在危险的动作发生在calculate函数内部并且使用了结果
在它之外。
使用应导致异常的值运行程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>仔细检查输出。在异常消息之前，行就绪了
打印出现在屏幕上。在打印时，已经进行了计算
完成后，非法分区已经发生，但该计划仍然存在
仅在结果即将打印时失败。
发生这种情况是因为Raku允许轻柔失败。一个软故障是unthrown例外。 除法的结果仅用于打印$ c值的行。在那之前， 什么都没有停止程序，它打印消息，好像没有发生错误。</p>
</div>
<div class="paragraph">
<p>理解软故障会导致我们得出以下结论。如果你使用try块来 防止程序终止，你应该把它放在那里的地方 即将使用不可能的结果(例如使用say函数)。下列 修改将完成工作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>围绕分区本身是不够的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，尝试块后，$!变量包含Any对象，因为失败没有 发生了。
CATCH移相器 在本章的前面，我们使用try块来捕获异常。如果发生异常
在try块内，它设置$!变量，您可以稍后检查。
在Raku中，这不是处理异常的唯一方法。让我们回到上一个
程序，但这次我们将使用CATCH块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>运行程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>抓住了异常! 尝试使用div将10除以零</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦除零发生并使用其结果，就会触发CATCH块。 CATCH块是Raku中的一个相位器，我们在第2章中讨论过它， 写作 码。当发生异常时，编译器将执行传递给此块，而没有人 到目前为止已经处理过了。
再次注意，异常不是在除零的时刻发生的，而是在
结果将打印到控制台。
如果我们将有问题的代码放在try块中，则不会按原样运行CATCH块 在我们的程序的以下变体中看到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在该程序中，来自CATCH块的消息和异常消息都不会 打印。try块隐藏了异常并设置了$!变量。CATCH块是 没有启动，因为已经处理了异常。
到目前为止，我们已经介绍了处理异常的基本方法。现在是时候潜水了 更深入一点，看看Raku如何使用Exception类实际操作异常。
异常对象
Raku中的异常是通过派生自的类的对象来处理的 异常类。这些对象包含有关的所有必要信息
异常，包括一些文本描述和堆栈跟踪(在Raku中，它被称为回溯)。</p>
</div>
<div class="paragraph">
<p>当出现异常时，Raku会创建一个异常对象。我们已经看到了一个例子 本章前面的这种情况 - 在尝试打印时错误变得明显 非法数学运算的结果。现在，让我们自己制作一个例外</p>
</div>
<div class="paragraph">
<p>使用die关键字。
die关键字抛出致命异常并终止程序。典型的用法是 如果程序无法打开文件或加载对其余部分至关重要的资源，请停止该程序 程序，例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有这样的文件，则布尔上下文中的$ fh变量为false，第二个分支
将执行或运算符。
die函数接受文本消息。考虑一个示例，其中调用die 无条件的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个简短的程序打印如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，它可以正常工作，直到异常发生并在它之后停止工作。模具功能
获取与回溯信息一起打印的文本消息。这是个
程序员如何生成自己的错误消息的示例。提供错误
有良好的描述有助于理解出错的原因。
要处理此异常，请使用try或CATCH块。try块抑制了 错误消息，但允许程序继续:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用例外 使用CATCH块，我们捕获异常，但程序终止:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>该计划的输出如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>开始 抓住 错误信息</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是我们之前看到的，但这里涉及的内容还有很多，我们将会这样做检查他们。</p>
</div>
<div class="paragraph">
<p>进入CATCH块时，Raku将异常对象放入默认变量 <code>$_</code>。 用它来分析原因并做出相应的反应。让我们打印一些调试 信息，以便我们看到$ _和$发生了什么!变量。在下面的 代码，^ name方法返回变量类的名称:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>该计划的结果揭示了一些有趣的细节:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>$_</code> 中的对象是X </dt>
<dd>
<p>AdHoc类的一个实例。特殊例外是一个例子 从Exception类派生的类型。Raku创建了这样一个对象来响应 召唤死亡。惯例使用X ::名称空间作为异常类。
然后，当我们通过将$ _变量传递给say函数来打印它时，实际的错误 消息打印:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意$的事实!变量为空 - 它包含Nil值。 最后，编译器从CATCH块打印消息，打印错误消息
连同回溯信息，并终止程序。
抛出异常
现在我们可以开始检查异常对象了。Exception基类定义了 throw方法，可用于抛出异常。为简单起见，让我们开始吧
X :: AdHoc例外。 在以下程序中，使用新方法显式创建异常
立即抛出throw方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序的输出对我们来说很熟悉:
开始
抓住 原因不明的错误</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们没有提供任何错误消息，程序打印默认值
string-Unexplained错误。 要使用消息，请在创建异常对象时使用有效负载命名参数:
X :: AdHoc.new(payload &#8658;'我的错误消息')。throw;
从例外中恢复
如我们所见，CATCH块停止执行程序。这并非总是如此 最佳策略。在Raku中，异常对象(类型派生自的对象)
异常类)可以将控制权返回给发生错误的代码中的位置。
为此，请在异常对象上调用resume方法，如下所示 例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.resume</code> 行调用默认变量$ _上的方法。它相当于一个明确的
叫$ _。resume。 这一次，程序不会退出，而是在异常后继续工作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，将不会打印错误消息，类似于它与try一起使用的方式 块。例如，从不存在的文件恢复读取没有意义。在 另一方面，当进行一系列计算时，即使其中一个计算也可能有用 他们除以零。
键入的例外</p>
</div>
<div class="paragraph">
<p>在Raku中预定义的X ::名称空间中还有更多类。要查看完整列表 内置异常，请访问以下页面 - docs.raku.org/type-exceptions.html。您 可以为您的特定异常创建自己的类。我们先来看看如何 区分CATCH块中不同类型的异常。
让我们创建一个程序，尝试将当前工作目录更改为不存在 一。在Raku中，您可以使用chdir函数来更改目录:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出显示以下错误消息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，让我们通过调用$ _变量上的^ name方法来查看异常的类型
在CATCH块内:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>它将告诉我们 <code>$_</code> 变量包含 <code>X::IO::Chdir</code> 类的对象。
现在，让我们利用这些知识做出不同的行动以应对不同的例外
案例。让我们构建程序，首先更改目录，然后抛出一个
临时例外。
要分隔不同异常的路径，我们将使用when关键字 匹配给定类型的$ _变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>运行此程序并确认两个异常都被正确捕获:
不存在的目录 临时例外</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在CATCH块中，有两个分支，每个异常类型一个，我们想要的 处理。重要的是要意识到，在找到并执行了when块之后，
CATCH块返回控制并忽略该点之后的所有代码。这就是为什么 恢复方法放在块中。如果你把它放在整个CATCH的末尾
阻止，只有在其他类型的异常发生且没有异常时才会到达该代码
什么时候块满意。
重新抛出异常
有时，异常处理程序无法处理异常。在这种情况下，它 可以通过调用rethrow方法再次抛出它。该异常将被捕获 默认异常处理程序
请考虑以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，尝试打印后捕获 <code>X::Numeric::DivideByZero</code> 异常 除法的结果为1 / 0.然后重新抛出异常，Raku打印出 适当的错误消息并终止程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>Failure对象 让我们创建一个程序，尝试打开一个不存在的文件并从中读取第一行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序将引发异常:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，只有在尝试读取文件后才会发生异常。只是
打开文件不会产生错误，它只将$ f文件处理程序设置为Failure对象。 失败对象是Exception对象的包装器。例外本身就是
可通过异常方法访问:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在布尔上下文中测试失败对象，例如，在打开后立即测试
一份文件:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>要查看是否已处理故障，请使用已处理的方法。在以下示例中， 这个方法被调用两次 - 在try块之前和之后围绕着引发的方法 例外:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦程序流离开try块，异常的状态就会变为
处理。
创建自定义例外
在前面的部分中，我们已经看到Raku中的异常使用面向对象 方法，特别是有助于区分不同的例外
CATCH块。
在本节中，我们将创建一个集成到Raku系统中的自定义异常
像X ::名称空间中的任何其他内置类一样顺利。如果你没有任何特别之处 要求，在同一名称空间中创建自定义异常类。
例如，让我们与X :: Lift :: Overload异常一起创建Lift类， 当太多人进入电梯时会触发:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们不需要Lift类之外的异常类，因此最好限制范围 并在主类中定义异常。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">X </dt>
<dd>
<p>Lift :: Overload类扩展了Exception类，并且必须至少提供
message方法，以便异常处理程序可以打印错误消息。
在List类中，有两个数据成员，$ .capacity和$!people，用于保存 电梯的默认容量和实际人数。enter方法增加了 编号并检查是否已达到容量。如果有更多的人进来，一个 抛出异常。
现在，让我们创建一个Lift类的实例，让一些人进入电梯:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">第三次进入后，将有五个人在电梯中，最大容量为 四强。因此，引发X </dt>
<dd>
<p>Lift :: Overload异常并且程序退出 以下错误消息:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_12">10.7. 总结</h3>
<div class="paragraph">
<p>在本章中，我们学习了如何在Raku中处理异常。我们详细研究过 通过使用不同的机制来抛出，捕获和隐藏异常的方法 语言尝试块和CATCH移相器。我们谈到了软故障 推迟的异常只有在真的不可避免时才被抛出。我们也是 演示了如何使用面向对象的方法来处理不同的异常 类型以及如何创建自定义异常。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_正则表达式">11. 正则表达式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>正则表达式是 Perl 中最有价值的功能之一。在 Raku 中, 正则表达式被重新设计, 使其更加规范和强大。这个术语也发生了变化, 正则表达式现在更多的时候被称为<strong>regexes</strong>。在这一章当中,  我们将对 regexes 的语法元素进行全面的梳理。</p>
</div>
<div class="paragraph">
<p>本章将涉及以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>与正则表达式匹配</p>
</li>
<li>
<p>字面量</p>
</li>
<li>
<p>字符类</p>
</li>
<li>
<p>量词</p>
</li>
<li>
<p>锚</p>
</li>
<li>
<p>备选</p>
</li>
<li>
<p>分组</p>
</li>
<li>
<p>捕获和命名捕获</p>
</li>
<li>
<p>命名正则表达式</p>
</li>
<li>
<p>Match 对象</p>
</li>
<li>
<p>断言</p>
</li>
<li>
<p>副词</p>
</li>
<li>
<p>替换</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_与正则表达式匹配">11.1. 与正则表达式匹配</h3>
<div class="paragraph">
<p>正则表达式描述了文本的模式。它们为我们提供了一种语言, 我们可以在其中表达文本的结构。</p>
</div>
<div class="paragraph">
<p>请看一个例子。电话号码是一个数字序列。<strong>sequence of digits</strong> 这个短语可以写成 <code>\d+</code>。如果我们考虑到电话号码可以用空格和破折号来写, 那么我们不得不说, 电话号码是用空格或破折号分隔的数字序列。这已经是一个比较复杂的正则表达式了, 可以有不同的写法, 根据我们的严格程度, 比如说我们是否允许两个空格写在一起, 或者破折号后面可以跟一个空格, 或者一组数字可以由一个数字组成。</p>
</div>
<div class="paragraph">
<p>让我们把它形式化为 (\d || \s || \-), 也就是不止一个数字(<code>\d</code>)或空格(<code>\s</code>)或破折号(<code>\-</code>)。这里的双竖直条在这里代表"<strong>或</strong>", <code>+</code> 意味着<strong>不止一个</strong>。最后, 国际电话号码可以用 <code>+</code> 号作为前缀, 这个是可选的。所以, 我们最终的电话号码的正则表达式是 \+? (\d || \s || \-)。</p>
</div>
<div class="paragraph">
<p>这个正则表达式并不完美。在本章的后面, 我们将努力使它变得更好, 更稳健。但是, 让我们从这个开始, 进行第一次<strong>匹配</strong>。在 Perl 中, 字符串与正则表达式相比较被称为匹配。要与一个正则表达式进行匹配, 需要使用双波浪线运算符。正则表达式本身被放置在一对斜线中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'OK' if '+31 645-23-10' ~~ /\+? (\d || \s || \-)+/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序打印出 OK, 这意味着带有电话号码的字符串与该正则表达式匹配。让我们尝试一些文本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'OK' if 'phone' ~~ /\+? (\d || \s || \-)+/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个字符串中, 没有正则表达式需要的任何字符, 程序也没有打印出任何字符。此正则表达式不匹配。</p>
</div>
<div class="paragraph">
<p>字符串和正则表达式都可以放在变量中, 这两个变量将被相互匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $phone = '+31 645-23-10';
my $re = /\+? (\d || \s || \-)+/;
say 'OK' if $phone ~~ $re;</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了 <code>/ &#8230;&#8203; /</code> 之外, 正则表达式可以使用其他围绕的符号。如果正则表达式包含许多斜线, 例如用于解析 URL 的正则表达式, 这可能很有用。在这种情况下, 你需要在正则表达式之前加上前缀字符 <code>m</code> 或 <code>rx</code> 。下面的例子都是等效的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ \d+ /
m/ \d+ /
m{ \d+ }
m| \d+ |</code></pre>
</div>
</div>
<div class="paragraph">
<p>要创建一个将被放入变量中的正则表达式, 请使用 <code>rx</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $phone = '+31 65 253-45-93';
my $re = rx/\+? (\d || \s || \-)+/;
say 'OK' if $phone ~~ $re;</code></pre>
</div>
</div>
<div class="paragraph">
<p>分隔符可以不一样, 例如, 一对花括号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $re = rx{\+? (\d || \s || \-)+};</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>m</code> 或 <code>rx</code> 创建一个直接在匹配中使用的正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Not OK' unless 'phone' ~~ m/\+? (\d || \s || \-)+/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了否定匹配的结果, Raku 提供了一个不同的运算符, <code>!~~</code>。请选择一个更容易理解的运算符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Not OK' if 'phone' !~~ rx/\+? (\d || \s || \-)+/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>从前两个例子可以看到, <code>unless</code> 和 <code>~~</code> 的组合相当于 <code>if</code> 和 <code>!~~</code>。</p>
</div>
<div class="paragraph">
<p>现在, 既然我们知道了如何将字符串与正则表达式匹配, 并制作了我们的第一个正则表达式, 让我们详细学习一下正则表达式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_字面量">11.2. 字面量</h3>
<div class="paragraph">
<p>正则表达式的语法是 Raku 中的一种小语言。由于要表达的东西很多, 所以它使用一些字符来传达意思。字母、数字和下划线代表它们自身, 没有任何特殊意义。这些字符可以按原样使用, 如下面的例子所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = 'John';
say 'OK' if $name ~~ /John/; # OK

my $id = 534;
say 'OK' if $id ~~ /534/; # OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果正则表达式中的字符串包含其他字符, 比如说空格, 则应该小心处理。其中一种可能是引用整个字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = 'Smith Jr.' ;
say 'Junior' if $last-name ~~ /' Jr'/; # Junior</code></pre>
</div>
</div>
<div class="paragraph">
<p>正则表达式中的文字字符串 <code>' Jr'</code> 包含一个必须存在于变量 <code>$name</code> 中的空格。</p>
</div>
<div class="paragraph">
<p>另一种方法是使用特殊字符, 用反斜线作为前缀。使用 <code>\s</code> 匹配空格:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = 'Smith Jr.' ;
say 'Junior' if $name ~~ /\sJr/; # Junior</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 中的空格在默认情况下是被忽略的。这个事实可以被利用来为正则表达式添加一些<strong>空气</strong>。对比一下我们之前使用的不使用空格的正则表达式, 和使用空格的正则表达式的等价物:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">原始正则表达式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">带空格的正则表达式</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/John/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ John /</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/' Jr'/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ 'Jr' /</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/\sJr/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ \s Jr /</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/\+?(\d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\s</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\-)+/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ \+? (\d</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\-)+ /</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_字符类">11.3. 字符类</h3>
<div class="paragraph">
<p>正则表达式中的字符类是一个特殊的序列, 它可以匹配某些给定的字符集中的字符。例如, 在上一节中, 我们已经使用了一个字符类 <code>\s</code>, 它与 ASCII 空格以及其一些其他的空白字符(例如制表符)匹配。让我们来探讨一下 Raku 正则表达式中的字符类。</p>
</div>
<div class="sect3">
<h4 id="_点字符">11.3.1. .(点)字符</h4>
<div class="paragraph">
<p>一个非常简单的字符, 只是一个点, 可以和字符串中的任何字符匹配。当你不关心两个部分之间的某些字符时, 通常会使用这种方法。例如, 下面的代码将与一个字符串中 a 和 d 之间有任意两个字符的字符串进行匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'OK' if 'abcd' ~~ / a . . d /; # OK
say 'OK' if 'aefd' ~~ / a . . d /; # OK
say 'OK' if 'a*^d' ~~ / a . . d /; # OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前两个例子中, 每个点都与其中一个字母匹配。在第三个例子中, 两个点都匹配一个空白字符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_反斜线字符类">11.3.2. 反斜线字符类</h4>
<div class="paragraph">
<p>有一组预定义的字符类, 它们以反斜线开头, 后跟一个小写或大写的字母。大写字母的版本与小写字母语义相反, 并且否定了与字符类匹配的字符集。下表包含了反斜线字符类的概述:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">否定</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\S</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空白</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\t</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">制表</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\h</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\H</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">水平空白</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\v</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\V</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">垂直空白</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\n</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">换行</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数字</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\W</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单词字符</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>现在我们就来详细考察一下所有的字符类。</p>
</div>
</div>
<div class="sect3">
<h4 id="_s_和_s_字符">11.3.3. \s 和 \S 字符</h4>
<div class="paragraph">
<p>我们已经看到了这个字符类的一个例子- <code>\s</code>, 用于匹配空格字符。它的大写字母对应的字符类, <code>\S</code>, 则与之相反 - 它与除了空格以外的任何字符匹配。 让我们来看一个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = 'Hello, World!';
say 'OK' if $str ~~ / \s World /; # OK
say 'OK' if $str ~~ / Hello\S /;  # OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>两个正则表达式都是匹配的。第一个例子中的 <code>\s</code> 与单词之间的空格匹配。第二个例子中的 <code>\S</code> 与逗号匹配。</p>
</div>
<div class="paragraph">
<p>字符类 <code>\s</code> 是其它空格字符类的组合 - <code>\h</code> 和 <code>\v</code> 组合而成的, 在下面的章节中会介绍。这些字符类还包括单个字符, 如 <code>\t</code> (水平制表符, 0x09)或 <code>\r</code>(换行, 0x0A)。</p>
</div>
</div>
<div class="sect3">
<h4 id="_t_和_t_字符">11.3.4. \t 和 \T 字符</h4>
<div class="paragraph">
<p><code>\t</code> 和 <code>\T</code> 分别与制表符和非制表符匹配。想象一下， 你有一行用制表符分隔的数据, 你想把它放到一个数组中。下面的代码可以帮你完成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $data = "John\tSmith\t1970";
my @data = $data.split(/\t/);

print qq:to/OUT/
Name          = @data[0]
Last name     = @data[1]
Year of birth = @data[2]
OUT</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, 我们在 <code>$data</code> 字符串上调用 <code>split</code> 方法, 并传递给它一个包含单个 <code>\t</code> 字符类的正则表达式, 它应该与制表符匹配。这样, 它将源数据行分成三部分, 并把它们放到 <code>@data</code> 数组中。</p>
</div>
<div class="paragraph">
<p><code>qq:to/OUT/</code> 构造是 heredoc 的开始, 它在第二次出现的标签 <code>OUT</code> 处结束。双 <code>qq</code> 需要在 heredoc 内部进行变量插值。 这种方法可以更容易地准备模板, 以便按照所需的布局输出数据:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">$ raku name-split.pl
Name          = John
Last name     = Smith
Year of birth = 1970</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_h_和_h_字符">11.3.5. \h 和 \H 字符</h4>
<div class="paragraph">
<p>这些字符类的小写版本与水平空格相匹配(大写版本分别否定匹配结果)。</p>
</div>
<div class="paragraph">
<p>在常见的空格和制表字符中, 还有许多其他的水平空格, 例如, 在 HTML 中被标记为 <code>&nbsp;</code> 的非换行空格。</p>
</div>
<div class="paragraph">
<p>下表列出了当前定义的所有属于该字符类的字符:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unicode 代码点</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符名</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHARACTER TABULATION</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xA0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NO-BREAK SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x1680</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OGHAM SPACE MARK</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x180E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MONGOLIAN VOWEL SEPARATOR</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EN QUAD</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2001</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EM QUAD</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2002</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EN SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2003</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EM SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2004</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">THREE-PER-EM SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2005</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FOUR-PER-EM SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2006</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SIX-PER-EM SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2007</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FIGURE SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2008</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUNCTUATION SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2009</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">THIN SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x200A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HAIR SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x202F</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NARROW NO-BREAK SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x25F</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MEDIUM MATHEMATICAL SPACE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x3000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IDEOGRAPHIC SPACE</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>这张表中有很多字符, 你可能从来没有用过, 但看了这张表, 你可以想象到 Raku 对于 Unicode 和空格的要求是多么严格。</p>
</div>
</div>
<div class="sect3">
<h4 id="_v_和_v_字符">11.3.6. \v 和 \V 字符</h4>
<div class="paragraph">
<p>\v 和 \V 字符类代表了垂直空格和非垂直空格的字符。与水平空格集相比, Raku 知道的垂直空格要少得多, 但它仍然涵盖了整个不同的 Unicode 符号, 如下列所示:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unicode 代码点</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符名</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LINE FEED</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LINE TABULATION</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FORM FEED</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CARRIAGE RETURN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x85</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NEXT LINE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2028</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LINE SEPARATOR</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2029</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PARAGRAPH SEPARATOR</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_n_和_n_字符">11.3.7. \n 和 \N 字符</h4>
<div class="paragraph">
<p><code>\n</code> 字符与逻辑上的新行匹配。<code>\N</code> 字符则相反, 它与任何不是新行的字符匹配。</p>
</div>
<div class="paragraph">
<p>匹配新行是很棘手的, 因为在不同的操作系统中, 不同的逻辑行之间有不同的约定。在类 Unix 系统中, 行之间由单个 <code>\r</code> 字符(代码为0x0A)分隔。在 Windows 中创建的文件中, 新行分隔符是 CARRIAGE RETURN(0x0A) 和 LINE FEED(0x0D) 两个字符的组合。Raku 的 <code>\n</code> 字符可以匹配其中的任何一个。</p>
</div>
<div class="paragraph">
<p>让我们通过下面的例子来证明这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $unix-str = "Hello,\rWorld!";
my $windows-str = "Hello,\r\nWorld!";

my @unix-lines = $unix-str.split(/\n/);
my @windows-lines = $windows-str.split(/\n/);

say @unix-lines.join('//');
say @windows-lines.join('//');</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里, 有两个带有不同新行分隔符的字符串。然后, 我们用相同的正则表达式 <code>/\n/</code> 将这两行拆分开。程序的输出结果显示, 这两行被分割成了相同的部分:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Hello,//World!
Hello,//World!</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_d_和_d_字符">11.3.8. \d 和 \D 字符</h4>
<div class="paragraph">
<p><code>\d</code> 字符类与一个数字匹配。这里的数字被理解为 <code>Number</code> 类别中 Unicode 字符。在传统的阿拉伯数字 <code>0-9</code> 中, 还有来自其他字母和脚本的数字。这些字符的整个列表是详尽的, 但让我们举几个其他数字的例子:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>阿拉伯文-印度文: ٠ ١ ٢ ٣ ٤ ٥ ٦</p>
</li>
<li>
<p>Nko (来自西非的从右到左的字母): 梵文 (印度和尼泊尔): ० १ २ ३ ४</p>
</li>
<li>
<p>孟加拉语: ০ ১ ২ ৩ ৪</p>
</li>
<li>
<p>数学粗体: 𝟎 𝟏 𝟐 𝟑 𝟒</p>
</li>
<li>
<p>数学双倍体: 𝟘 𝟙 𝟚 𝟛 𝟜</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些数字中的任何一个数字都会与 <code>\d</code> 匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">$ raku -e'say "OK" if "   " ~~ /\d/'
OK</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_w_和_w_字符">11.3.9. \w 和 \W 字符</h4>
<div class="paragraph">
<p><code>\w</code> 字符类与可以作为单词的一部分的字符匹配, 即字母、数字和下划线符号匹配。<code>\W</code> 与其他所有除字面、数字和下划线的字符匹配。这里的字母在是在 Unicode 意义上理解的 - 这些是 <code>Letter</code> 类别中的字符。</p>
</div>
<div class="paragraph">
<p>例如, <code>\w</code> 总是与任何希腊字母匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku -e'say "OK" if "λ" ~~ /\w/'
OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>就像我们在上一节中提到的数字一样, 你必须准备好 <code>\w</code> 将与你所熟悉的语言中的许多字符匹配。</p>
</div>
</div>
<div class="sect3">
<h4 id="_字符类_2">11.3.10. 字符类</h4>
<div class="paragraph">
<p>字符类是一种请求与给定字符列表进行匹配的机制。例如, 要匹配十六进制数字, 我们需要匹配一个十进制数字 0 到 9 和六个字母 a 到 f(也包括它们的大写变体 A 到 F)的字符。</p>
</div>
<div class="paragraph">
<p>在 Raku 的正则表达式中, 这可以写成一个字符类 &lt;[0..9 a..f A..F]&gt;。让我们把这个正则表达式应用到大写的拉丁字母列表中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 'A'..'Z' {
    .print if /&lt;[0..9 a..f A..F]&gt;/;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将打印出字符串 <code>ABCDEF</code>, 其中包含与给定的正则表达式匹配的字母。</p>
</div>
<div class="paragraph">
<p>字符类也可以包括反斜线序列。在电话号码正则表达式中, 我们可以使用一个字符类来匹配数字、空格或连字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ \+? &lt;[\d\s\-]&gt;+ /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们继续 Raku 正则表达式引擎中内置的其他字符类。</p>
</div>
</div>
<div class="sect3">
<h4 id="_预定义的子规则">11.3.11. 预定义的子规则</h4>
<div class="paragraph">
<p>Raku 中的正则表达式包括一些预定义的<strong>子规则</strong>, 这些子规则也是字符类, 并与反斜线字符类部分相交。语法上, 子规则是角括号中的名字。下表总结了这些子规则:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">子规则</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">意义</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;alpha&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字母符号和_</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;alnum&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与 \w 相同</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;digit&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与 \d 相同</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;lower&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小写字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;upper&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大写字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;space&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空格, 与 \s 相同</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;blank&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">水平空格, 与 \h 相同</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;cntrl&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;punct&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标点符号</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;graph&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与 &lt;alnum&gt; + &lt;punct&gt; 相同</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;print&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可打印字符, 与 &lt;alnum&gt; + &lt;space&gt; 相同, 不带 &lt;punct&gt;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在 Raku 中, 预定义子规则是正则表达式的有效部分, 可以和其他字面量字符类一起使用在正则表达式的任何地方。在下面的例子中, 我们检查字符串是否包含一个数字后跟一个字母:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $regex = / &lt;digit&gt; &lt;alpha&gt; /;

say 'Match'    if '3a' ~~ $regex;    # Match
say 'No match' if 'abcd' !~~ $regex; # No match
say 'No match' if 678 !~~ $regex;    # No match</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面提到的命名子规则并不是唯一根据 Unicode 属性选择字符的方法 。在下一节中, 我们将看到如何直接使用 Unicode 类别。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用_unicode_属性">11.3.12. 使用 Unicode 属性</h4>
<div class="paragraph">
<p>Unicode 中的字符属于不同的类别, 例如字母或数字或标点符号。类别可以有额外的细化级别, 例如字母可以是小写或大写。</p>
</div>
<div class="paragraph">
<p>Raku 中的正则表达式为我们提供了一个基于 Unicode 类别的字符类机制 。要创建这样的一个类, 请使用一对包含冒号的角括号, 后面是类别名称的大写字母。要指定子类别, 请添加相应的小写字母。</p>
</div>
<div class="paragraph">
<p>例如, 匹配字母的字符类是 <code>&lt;:L&gt;</code>, 而匹配大写字母的字符类是 <code>&lt;:Lu&gt;</code>。在下面的例子中, 我们用这些字符类来匹配几个字母:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;A a B b Ω ω 1 2 * ^ &gt; -&gt; $char {
    say "$char ~~ &lt;:L&gt;"  if $char ~~ / &lt;:L&gt; /;
    say "$char ~~ &lt;:Lu&gt;" if $char ~~ / &lt;:Lu&gt; /;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码循环遍历一个有不同字符的列表, 并报告它们是否匹配 <code>&lt;:L&gt;</code> 或 <code>&lt;:Lu&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">A ~~ &lt;:L&gt;
A ~~ &lt;:Lu&gt;
a ~~ &lt;:L&gt;
B ~~ &lt;:L&gt;
B ~~ &lt;:Lu&gt;
b ~~ &lt;:L&gt;
Ω ~~ &lt;:L&gt;
Ω ~~ &lt;:Lu&gt;
ω ~~ &lt;:L&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>从输出中可以看到, 所有的字母都通过了 <code>&lt;:L&gt;</code> 过滤器, 大写字母与 <code>&lt;:Lu&gt;</code> 字符类相匹配, 非字母字符在两个测试中都不匹配。</p>
</div>
<div class="paragraph">
<p>在 Raku 中, 与 Unicode 相关的字符类有两个名称, 分别是短名称和长名称, 可以互换。可以像这样使用长名称编写相同的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;A a B b Ω ω 1 2 * ^ &gt; -&gt; $char {
    say "$char ~~ &lt;:L&gt;"  if $char ~~ / &lt;:Letter&gt; /;
    say "$char ~~ &lt;:Lu&gt;" if $char ~~ / &lt;:Uppercase_Letter&gt; /;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下表列出了所有与 Unicode 类别对应的字符类。在此表中, 单字母类别后面是两个字母的子类别。请注意, 有些字母组合不能直接从类别名称中扣除; 例如, Unicode 中的 <code>Punctuation</code> 字符类, <code>Open</code> 类别的字符类被称为 <code>Ps</code>, 因此它在 Raku 中是 <code>&lt;:Ps&gt;</code>:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Short name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Category</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Comment</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼&lt;:L&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Letter&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼￼Letter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Ll&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Lowercase_Letter&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Letter, lowercase</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a, b 等等
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Lu&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Uppercase_Letter&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Letter, uppercase</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A, B 等等
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Lt&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Titlecase_Letter&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Letter, titlecase</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ligatures such as Lj
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Lm&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Modifier_Letter&gt;￼￼￼￼￼</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Letter, modifier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">某些变音符号, 例如  ̃
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Lo&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Other_Letter&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Letter, other</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">来自希伯来语, 例如 ݢ 或阿拉伯语, 例如 א, 的字母
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:M&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Mark&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mark</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼￼&lt;:Mn&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Nonspacing_Mark&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mark, nonspacing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">重音符, 例如  ̀ 或  ́</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼ &lt;:Mc&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Spacing_Mark&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mark, spacing combining</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">某些组合字符
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Me&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Enclosing_Mark&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mark, enclosing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">符号, 围绕其他符号, 如旧的西里尔标志 1000: ҈
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:N&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Number&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Nd&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Decimal_Number&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number, decimal digit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0, 1, 2 等等
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Nl&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Letter_Number&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number, letter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">例如, 罗马数字(像 VIII 那样的单独字符)
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:No&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Other_Number&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number, other</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">其他与数字相关的字符, 如 1⁄4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼ &lt;:P&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Punctuation&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Punctuation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Pc&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Connector_Punctuation&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Punctuation, connector</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">例如, 字母上方的圆弧: ⁀
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Pd&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Dash_Punctuation&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼￼￼Punctuation, dash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">像破折号这样的符号: —
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Ps&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Open_Punctuation&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Punctuation, open</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">开口符号对, 例如 [ 或 (, 等等
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Pe&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Close_Punctuation&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Punctuation, close</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">闭合符号对, 例如 ] 或 ), 等等
￼￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Pi&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Initial_Punctuation&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Punctuation, initial quote</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">￼起始引号字符, 如 «
￼</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Pf&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Final_Punctuation&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Punctuation, final quote</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">闭合引号字符, 如 »</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Po&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Other_Punctuation&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Punctuation, other</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">许多传统的标点字符如 ! 或 ?</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:S&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Symbol&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Symbol</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Sm&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Math_Symbol&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Symbol, math</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数学符号: +, ±, × 等等</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Sc&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Currency_Symbol&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Symbol, currency</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">货币符号: ¤, €, $ 等等</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Sk&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Modifier_Symbol&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Symbol, modifier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">变音符号, 例如  ̧ 或  ̈</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:So&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Other_Symbol&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Symbol, other</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不属于其他类别的符号:  ©, ® 等等</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Z&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Separator&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Separator</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Zs&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Space_Separator&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Separator, space</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">各种类型的空白</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Zl&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Line_Separator&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Separator, line</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">行分隔符的唯一符号, 代码为 0x8232</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Zp&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Paragraph_Separator&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Separator, paragraph</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">段落分割符的唯一符号, 代码为 0x2029</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:C&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Other&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Other</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Cc&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Control&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Other, control</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制字符, 例如 BELL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Cf&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Format&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Other, format</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不同的格式字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Cs&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Surrogate&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Surrogate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">少量代理字符</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_字符类算术">11.3.13. 字符类算术</h4>
<div class="paragraph">
<p>Raku 提供了强大的功能, 允许你使用集合运算创建新的字符类。这些是 - 用于并集的 <code>+</code> 或 <code>|</code>,  用于差集的 <code>-</code>, 用于交集的 <code>&amp;</code>, 用于异或运算的 <code>^</code>。此外, 还可以使用 <code>-</code> 或 <code>!</code> 来否定字符类。</p>
</div>
<div class="paragraph">
<p>让我们来看一些例子。首先, 创建一个同时匹配小写字母和数字的合并类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;a A 3&gt; -&gt; $char {
    say "$char is a lowercase letter or a digit"
        if $char ~~ / &lt;:Ll + :Nd&gt; /;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序打印匹配的字符 <code>a</code> 和 <code>3</code>。大写的 A 不匹配, 因为它既不是小写字母也不是数字。</p>
</div>
<div class="paragraph">
<p>在另一个例子中, 我们通过从所有字母的集合中减去小写字母来重新发明大写字母:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;a A 3&gt; -&gt; $char {
    say "$char is an uppercase letter" if $char ~~ / &lt;:L - :Ll&gt; /;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 取所有的小写字母并去掉所有的元音:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 'a'..'z' -&gt; $char {
    say "$char is consonant" if $char ~~ / &lt;:Ll - [aoeiu]&gt; /;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>(如果你想用其他语言做实验, 请小心这个方法, 因为 <code>&lt;:Ll&gt;</code> 包括了英文字母以外的字母。)</p>
</div>
<div class="paragraph">
<p>如果你需要匹配除给定字符以外的任何字符, 减法就很有用了。例如, 这就是你如何匹配英语字母表中, 不是原始拉丁语, 不包含一些现代英文字母的任何内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 'A'..'Z' -&gt; $char {
    say "$char is pure Roman" if $char ~~ / &lt;[A .. Z] - [GJUWY]&gt; /;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要否定一个字符类, 在其前面加上一个减号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'OK' if 'x' ~~ / &lt;-[abcdef]&gt;/; # OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用感叹号来否定 Unicode 预定义字符类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'OK' if 'x' ~~ / &lt;:!Lu&gt;/; # OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>字符类本身匹配单个字符。为了使正则表达式更强大, 让我们研究一下量词。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用量词创建可重复模式">11.4. 使用量词创建可重复模式</h3>
<div class="paragraph">
<p>量词修饰它前面的原子并要求特定次数的重复。<strong>原子</strong>是一个字符或字符类, 或字符串字面量或组(我们稍后将在本章的"使用捕获提取子字符串”一节中讨论组)。</p>
</div>
<div class="paragraph">
<p><code>+</code> 量词允许前一个原子被重复一次或多次。例如, 正则表达式 <code>/a+/</code> 可以与单个字符 a 匹配, 也可以与包含两个字符 aa, 或三个字符 aaa 或更多的字符 aaaaaa 的字符串匹配。但是, 它不会与完全不包含 a 字符的字符串匹配。</p>
</div>
<div class="paragraph">
<p>* 量词允许任意数量的重复, 包括零次。因此, /a*/ 正则表达式与诸如 bdef、abc 或 baad 等字符串匹配。当然, 单个 /a*/ 可能没有那么好用; <code>*</code> 量词的更自然的用例是在其他子字符串之间, 比如 <code>/ab*c/</code>。这个正则表达式与 ac、abc 或 abbc 匹配。</p>
</div>
<div class="paragraph">
<p><code>?</code> 量词要求一个原子要么出现一次, 要么不出现。考虑正则表达式 <code>/colou?r/</code>, 它与英式和美式拼写中的单词 colour 和 color 相匹配。</p>
</div>
<div class="paragraph">
<p>也可以使用后面跟着重复次数或范围的 ** 量词来要求给定的重复次数。例如, <code>/'a' 'b' ** 3..4 'c' /</code> 匹配包含 bbb 或 bbbb 的子字符串, 例如, abbbc 匹配, 但不匹配 abbc 或 abbbbbbbc。在 <code>^</code> 的帮助下, 可以排除范围的边缘 - /'a' 'b' ** 3..^10 'c'/ 将与包含 3 到 9 个后续字母 a 的子字符串匹配。开区间, 例如 b ** ^10(0 到 9 个 b)或 b ** 3..* (三次或三次以上) 也是允许的。</p>
</div>
<div class="paragraph">
<p>还有另一对量词, <code>%</code> 和 <code>%%</code>, 它们的使用方式有点不同。他们与 <code>+</code>, <code>?</code>, * 和 ** 量词一起工作, 并要求在重复的序列中用一个分隔符来分隔, 分隔符出现在 <code>%</code> 或 <code>%%</code> 的右边。在 <code>%%</code> 的情况下, 分隔符也可以出现在最后一个重复元素之后。请看下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1 if 'a,b,c,d' ~~ / \w+ % ',' /;
say 1 if 'a,b,c,d' ~~ / \w ** 2..3 % ',' /;
say 1 if 'a,b,c,d' ~~ / \w ** 2..3 %% ',' /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该代码与第一种情况下的所有四个字母-a, b, c, d 匹配, 与第二种情况下的前三个字母-a,b,c 匹配。在最后一种情况下, 只匹配三个字母, 但是 c 和 d 之间的逗号也会被消耗掉-<code>a,b,c,</code>。</p>
</div>
<div class="sect3">
<h4 id="_贪婪">11.4.1. 贪婪</h4>
<div class="paragraph">
<p>上面描述的量词默认情况下是<strong>贪婪的</strong>。这意味着他们会尽可能多地匹配源字符串中的字符。例如, 在匹配 <code>'bbb' ~~ /b*/</code> 中, 所有的三个字符都会被正则表达式消耗掉。同样的, <code>+</code> 量词也会尽可能多的消耗重复字符。</p>
</div>
<div class="paragraph">
<p>有时候这种行为并不理想。考虑一个用于从 HTML 标签中选择属性的正则表达式。从给定的字符串 <code>&lt;a href="index.html" class="menu"&gt;</code> 中, 我们要提取属性的值, 即引号内的字符串。试图创建这样一个正则表达式, 如 / \" .* \" / 将提取第一个引号和最后一个引号之间的整个子串- 即 <code>"index.html" class="menu"</code>。这是因为 <code>*</code> 量词不想在第一个属性值的末尾停止, 而是继续消耗字符。</p>
</div>
<div class="paragraph">
<p>它更进一步, 甚至通过最后一个引号和闭合角括号。在这之后, 就不会剩下任何字符了, 但正则表达式希望与双引号匹配。所以, 正则表达式引擎会执行回溯, 将消耗的字符<strong>返回</strong>到字符串中, 直到正则表达式被满足或者失败。</p>
</div>
<div class="paragraph">
<p>为了防止量词的贪婪性, 请在其后添加一个问号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ \" .*? \" /</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 它只匹配第一个属性值(包括引号) - <code>"index.html"</code>。</p>
</div>
<div class="paragraph">
<p>注意, 在正则表达式中, " 字符应该被转义 - \"。正如我们在*字面量*一节中学到的那样, 只有字母数字字符和下划线符号与他们自身匹配。另外, 我们也可以通过在一对单引号内放入双引号来创建一个引号字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ '"' .*? '"' /</code></pre>
</div>
</div>
<div class="paragraph">
<p>反贪婪行为可以应用于任何量词, 甚至可以应用于 <code>?</code>。在这种情况下, 如果可能的话, 修改后的量词 <code>??</code> 将尝试不匹配任何东西。因此, 如果是字符串 abc 针对 <code>/ab?/</code> 正则表达式进行测试, 那么它的子串 ab 将被匹配。对于非贪婪的 <code>/ab??/</code> 正则表达式, 只有 <code>a</code> 会匹配。当然, 如果我们修改正则表达式, 使 <code>b??</code> 必须与某些东西匹配, 就像 <code>/ab??c/</code> 那样, 那么它就会这样做。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用捕获提取子字符串">11.5. 使用捕获提取子字符串</h3>
<div class="paragraph">
<p>只匹配正则表达式还不够。如果没有提取出与正则表达式模式一致的子字符串的能力, 那么正则表达式的真正力量不完整的。 将字符串的一部分保存在特殊变量中, 这就是所谓的<strong>捕获</strong>。</p>
</div>
<div class="sect3">
<h4 id="_捕获组">11.5.1. 捕获组</h4>
<div class="paragraph">
<p>在 Raku 中, 捕获是通过将正则表达式的一部分放到圆括号中来实现的。圆括号在正则表达式中具有双重含义。我们已经看到了在电话号码中用括号来分组的用法。</p>
</div>
<div class="paragraph">
<p>让我们继续以提取 HTML 属性的值为例。我们现在要打印出这些值。所以, 我们需要创建一个正则表达式并标记出我们想要提取的数据的边界。将捕获的数据被放入变量 <code>$0</code>, <code>$1</code> 等变量中。数字索引从零开始, 对应于正则表达式中捕获括号的顺序编号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = q{&lt;a href="index.html" class="menu"&gt;};
$str ~~ / \" (.*?) \" .* \" (.*?) \" /;
say $0;
say $1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行这段代码, 看看它打印出了什么:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">⌈index.html⌋
⌈menu⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>的确, 我们得到了我们想要的 HTML 属性的值。它们包含了 <code>$str</code> 变量的子字符串, 这些子字符串与圆括号中的正则表达式 - <code>(.*?)</code> 中的部分相匹配。因为它们出现了两次, 所以有两个变量被填充了。</p>
</div>
<div class="paragraph">
<p>作为一个侧面的说明, 此时我们可以说, 非贪婪量词并不总是唯一的表达方式。而不是说"在双引号前尽量少取一些字符", 我们可以要求"尽量夺取一些不是引号的字符", 并使用否定字符类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = q{&lt;a href="index.html" class="menu"&gt;};
$str ~~ / \" (&lt;-[\"]&gt;+) \" .* \" (&lt;-[\"]&gt;+) \" /;
say $0;
say $1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样, 即使是在字符类内部, 引号也必须转义。</p>
</div>
</div>
<div class="sect3">
<h4 id="_match_对象">11.5.2. Match 对象</h4>
<div class="paragraph">
<p>你可能已经注意到, 在前面的例子的输出中, 真实的子字符串显示在一对方角括号之间。这是因为变量 <code>$0</code> 和 <code>$1</code> 的内容不是一个裸字符串, 而是一个 <strong>Match</strong> 类型的对象。在使用 <code>say</code> 或 <code>print</code> 函数打印时, <strong>Match</strong> 对象也是以这种方式格式化的。</p>
</div>
<div class="paragraph">
<p><code>$0</code>, <code>$1</code> 等变量实际上是完整形式 <code>$/[0]</code>, <code>$/[1]</code> 等快捷方式的变体。<code>$/</code> 变量就是 <strong>Match 对象</strong>。它是接收正则表达式匹配结果的默认变量。它包含了所有的捕获字符串, 以及与整个正则表达式匹配的子字符串。要获取单独的捕获, 需要使用诸如 <code>$/[1]</code> 或 <code>$1</code> 的索引。</p>
</div>
<div class="paragraph">
<p>那么, 让我们打印上一个例子中 <code>$/</code> 的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = q{&lt;a href="index.html" class="menu"&gt;};
$str ~~ / \" (.*?) \" .* \" (.*?) \" /;
say $/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将得到以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">⌈"index.html" class="menu"⌋
 0 =&gt; ⌈index.html⌋
 1 =&gt; ⌈menu⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一部分 ⌈"index.html" class="menu"⌋ 包含了正则表达式匹配的整个子字符串。接下来是一些与捕获圆括号相匹配的索引元素。</p>
</div>
<div class="paragraph">
<p>当匹配对象在字符串内插值时, 打印时不加括号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'April 2017' ~~ / (\d+) /;
say "Year is $0";</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, <code>$0</code> 将被字符串化, 输出将是 <code>Year is 2017</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_命名捕获">11.5.3. 命名捕获</h4>
<div class="paragraph">
<p>当正则表达式有一个或两个以上的捕获组, 并且如果正则表达式中存在着其他的备选项时, 那么捕获就会变得更加棘手。例如, 考虑以下正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $re = rx/ (&lt;[a..z]&gt;+) || (&lt;[A..Z]&gt;) (\d) /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它包含两个备选项, 但每个分支中的捕获组的编号是不同的。(下一节将详细描述备选分支。)</p>
</div>
<div class="paragraph">
<p>现在, 提供与 <code>&lt;[a..z]+&gt;</code> 或与 <code>&lt;[A..Z]&gt;\d</code> 正则表达式匹配的字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'letter' ~~ $re;
'A5'     ~~ $re;</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一次匹配后, 将只定义 <code>$0</code>。打印 <code>$1</code> 将得到 <code>Nil</code>。在第二例子中, 两个变量都会将包含一个值。也不容易推断出每种情况下正则表达式匹配的是哪一部分。如果两个备选项的捕获数量相同, 那么直接检查有定义的变量的数量的方法就不起作用了。</p>
</div>
<div class="paragraph">
<p>Raku 允许你给捕获起名字。下面的例子显示了用于命名捕获的语法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $re = rx/ $&lt;type&gt;=(&lt;[a..z]&gt;+) ||
             $&lt;letter&gt;=(&lt;[A..Z]&gt;) $&lt;size&gt;=(\d)
           /;

'letter' ~~ $re;
say $/;

'A5' ~~ $re;
say $/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中, 我们还看到了格式化长正则表达式的方法, 使其更容易阅读, 更符合逻辑。</p>
</div>
<div class="paragraph">
<p>检查一下输出结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">⌈letter⌋
 type =&gt; ⌈letter⌋
⌈A5⌋
 letter =&gt; ⌈A⌋
 size =&gt; ⌈5⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以看到, <strong>Match</strong> 对象现在有了命名对, 而不是数字索引。这些名称也可以像把 <code>$/</code> 变量当作散列一样使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'letter' ~~ $re;
say $&lt;type&gt;;

'A5' ~~ $re;
say $&lt;letter&gt;;
say $&lt;size&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&lt;$name&gt;</code> 记法是 <code>$/&lt;name&gt;</code> 的简写。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_在正则表达式中使用备选项">11.6. 在正则表达式中使用备选项</h3>
<div class="paragraph">
<p>让我们再次看看我们原生的匹配电话号码的正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rx/ \+? (\d || \s || \-)+ /</code></pre>
</div>
</div>
<div class="paragraph">
<p>圆括号内的竖直条将组内的不同变体分开。它可以是 <code>\d</code>, 或者是 <code>\s</code>, 或者是 <code>\-</code> 。在正则表达式上下文中, 这就是所谓的<strong>备选</strong>。相应地, 不同的变体也被称为<strong>备选项</strong>。</p>
</div>
<div class="paragraph">
<p>在 Raku 中, 正则表达式中有两种形式的备选分隔符-单个竖直条 <code>|</code> 和双竖直条 <code>||</code>。使用单个竖直条, 最长的变体总是获胜。在双竖直条中, 第一个匹配的备选项获胜。</p>
</div>
<div class="paragraph">
<p>在电话号码的例子中, 每个备选项的长度正好是一个符号。所以, 在这里, <code>|</code> 和 <code>||</code> 之间没有任何区别。在其他情况下, 运算符的选择可能会大大改变结果。</p>
</div>
<div class="paragraph">
<p>例如, 拿下面的例子中的两个正则表达式为例, 将形容词 <code>big</code> 的形式与它们进行匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;big bigger biggest&gt; -&gt; $form {
    say "Testing '$form'";

    $form ~~ / big | bigger | biggest /;
    say $/;

    $form ~~ / big || bigger || biggest /;
    say $/;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序的输出是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Testing 'big'
⌈big⌋
⌈big⌋
Testing 'bigger'
⌈bigger⌋
⌈big⌋
Testing 'biggest'
⌈biggest⌋
⌈big⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>分析输出, 我们可以看到, 使用单个竖直条的正则表达式, 每次都选择最长的备选项 - big、bigger、biggest。使用另一个带双竖条的正则表达式, 第一个匹配的总是胜出 - <code>big</code>, 其他所有的变体都没有尝试过。你可以玩一个这个代码, 改变正则表达式中备选项的顺序, 看看它是如何改变这个程序的行为的。</p>
</div>
<div class="paragraph">
<p>例如, 如果你把变体按长度的相反顺序列出, 那么两个正则表达式的输出都是类似的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$form ~~ / big | bigger | biggest /;
say $/;

$form ~~ / biggest || bigger || big /;
say $/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>备选项通常只是正则表达式的一部分。在我们的例子中, 有一个序列 <code>\+?</code> 用于匹配电话号码中的可选加号。这并不属于备选项列表的一部分。为了标记备选的边界, 请使用括号。</p>
</div>
<div class="paragraph">
<p>括号也会创建一个原子, 这个原子随后被 <code>+</code> 量词修饰, 它被应用于括号内的正则表达式的整个部分。</p>
</div>
<div class="paragraph">
<p>当括号只用于分组而不需要捕获时, 请使用方括号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $phrase = 'Eat an apple, please';

$phrase ~~ / ( apple || pear ) /;
say $0;

say 'Healthy' if $phrase ~~ / [ apple || pear ] /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, 第一个例子提取了 <code>$parse</code> 中提到的水果, 而第二个匹配只检查字符串中是否包含两个想要的单词中的一个, 并不保存在任何地方。在第二个匹配之后, <code>$0</code> 变量将包含 <code>Nil</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_用锚点定位正则表达式">11.7. 用锚点定位正则表达式</h3>
<div class="paragraph">
<p>在许多情况下, 必须在字符串中应用一个正则表达式, 使其开头与字符串的开头重合。例如, 如果电话号码中包含 <code>+</code> 字符, 它只能出现在第一个位置。</p>
</div>
<div class="paragraph">
<p>Raku 正则表达式具有所谓的锚点-特殊字符, 它可以将正则表达式锚定到字符串或逻辑行的开头或结尾。</p>
</div>
<div class="sect3">
<h4 id="_匹配行或字符串的开头和末尾">11.7.1. 匹配行或字符串的开头和末尾</h4>
<div class="paragraph">
<p>让我们修改一下电话号码的正则表达式, 使其与包含潜在电话号码的整个字符串匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ ^ \+? &lt;[\d\s\-]&gt;+ $ /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里, <code>^</code> 是匹配字符串开头的锚点, 它不会消耗任何字符。在正则表达式的另一端, <code>$</code> 要求正则表达式的结尾与字符串的结尾匹配。因此, 一个有效的电话号码, 比如说 <code>+49 20 102-14-25</code> 会通过过滤器,  而像 <code>124 + 35 - 36</code> 这样的数学表达式则不会。</p>
</div>
<div class="paragraph">
<p>为了提高可见性, 可以在代码中把锚点写在单独的行中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $rx = /
    ^
        \+?
        &lt;[\d\s\-]&gt;+
    $
/;

say 'OK'     if '+49 20 102-14-25' ~~ $rx; # OK
say 'Not OK' if '124 + 35 - 36'   !~~ $rx; # Not OK</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>^</code> 和 <code>$</code> 都匹配字符串的边界(字符串作为变量)。如果你需要匹配逻辑行(如果字符串中包含几行由 <code>\n</code> 分隔的行), 请使用另一对锚点 - <code>^^</code> 和 <code>$$</code>。</p>
</div>
<div class="paragraph">
<p>在下一个例子中, 我们要选择一个菠萝的颜色:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fruits = "yellow banana\ngreen pineapple\nred apple";

$fruits ~~ / (\w+) \s pineapple $$ /;
say $0;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个代码打印 <code>green</code>, 因为 <code>(\w+)</code> 与菠萝行中的那个单词匹配。行尾锚点 <code>` 匹配到了那一行的末尾。这个结果不取决于水果清单中的行的顺序。如果使用单个 `$` 而不是 `</code>, 那么只有当 <code>green pineapple</code> 位于整个字符串的末尾时, 正则表达式才会匹配。</p>
</div>
</div>
<div class="sect3">
<h4 id="_匹配单词边界">11.7.2. 匹配单词边界</h4>
<div class="paragraph">
<p>要匹配单词边界, 请使用以下锚点之一:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">锚点</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">w&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何单词边界</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;&lt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">单词的开头</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&gt;&gt;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>这些锚点匹配单词的边界, 不消耗字符。例如, <code>/&lt;|w&gt; apple /</code> 匹配 <code>apple</code> 但是不匹配 <code>pineapple</code>。</p>
</div>
<div class="paragraph">
<p><code>&lt;|w&gt;</code> 锚点有一个与之相反的对, <code>&lt;!|w&gt;</code>, 它与任何不是单词边界的东西匹配。这个锚点也不消耗字符, 所以 <code>/ o &lt;!|w&gt; p /</code> 匹配 <code>opera</code>。</p>
</div>
<div class="paragraph">
<p>要更精确地指定边界, 可以使用 <code>&lt;&lt;</code> 或 <code>&gt;&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @words = 'fourty-four' ~~ m:g/ &lt;&lt; four /;
say +@words;

@words = 'fourty-four' ~~ m:g/ four &gt;&gt; /;
say +@words;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这些例子中, 第一个匹配会找到两个单词, 而在第二个尝试中, 只找到一个以 <code>four</code> 结尾的单词。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用断言进行向前查看和向后查看">11.8. 使用断言进行向前查看和向后查看</h3>
<div class="paragraph">
<p>操纵正则表达式流的另一个主题是<strong>断言</strong>。在匹配过程中, 该模式不消耗源字符串中的字符。断言有助于在当前位置做一些检查, 而不会吃掉字符。</p>
</div>
<div class="paragraph">
<p>在 Raku 的正则表达式中有两种类型的断言 - <strong>向前查看</strong>和<strong>向后查看</strong>。每一种断言都可以被否定。在下面的表格中, 列出了所有可能的组合:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">正向断言</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">否定断言</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">向前查看</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;?before X&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;!before X&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">向后查看</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;?after X&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;!after X&gt;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>被放置在正则表达式中, 向前查看断言 <code>&lt;?before X&gt;</code> 检查在这个位置后面跟着的字符是否是 <code>X</code>。如果是这样, 那么断言就成功了, 正则表达式引擎继续工作。其他断言的行为遵循相同的逻辑考虑, 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'Etiquette' ~~ / (.*?) &lt;?after 'qu'&gt; (e .*) /;
say $/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印出这个结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">⌈Etiquette⌋
 0 =&gt; ⌈Etiqu⌋
 1 =&gt; ⌈ette⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>讨论中的单词被拆成两部分。该规则在 <code>e</code> 处分开, 其后是 <code>qu</code>。 <code>qu</code> 这两个字符已被第一个 <code>.*?</code> 捕获块消耗掉了, 但向前查看断言仍然能够查看源字符串中是否有 <code>qu</code> 这个序列存在。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用副词修饰正则表达式">11.9. 使用副词修饰正则表达式</h3>
<div class="paragraph">
<p><strong>副词</strong>是正则表达式修饰符。它们是冒号前缀字母, 可以改变正则表达式的行为。</p>
</div>
<div class="paragraph">
<p>副词以两种形式存在 - <strong>短形式</strong>和<strong>长形式</strong> - 并出现在正则表达式的前面, 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'OK' if 'ABCD' ~~ m:i/ abcd /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, 在这个例子中, 当副词应用于整个正则表达式时, 需要使用 <code>m</code> 或 <code>rx</code>。另外, 副词可以放在正则表达式里面。在这种情况下, 它从它出现的位置开始起作用。这在下一节中关于 <code>:i</code> 副词的例子中得到了证明。</p>
</div>
<div class="paragraph">
<p>下表列出了所有的副词:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">短形式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">长形式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:i</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ignorecase</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配字符是大小写不敏感的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:sigspace</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空白是重要的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:p(N)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:pos(N)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从位置 N 开始</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:g</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:global</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">全局匹配</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:c</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:continue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在前一个匹配之后继续</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:r</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ratchet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">禁用回溯</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ov</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:overlap</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">重叠匹配</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:exhaustive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">找到所有可能的匹配</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>让我们浏览列表并逐一检查每个副词。</p>
</div>
<div class="sect3">
<h4 id="_iignorecase">11.9.1. i(:ignorecase)</h4>
<div class="paragraph">
<p>这是最简单的正则表达式副词。它可以让正则表达式不区分大小写。因此, <code>m:i/X/</code> 和 <code>m:i/x/</code> 这两个正则表达式副词中的每一个都会成功地与 <code>x</code> 和 <code>X</code> 匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $rx = rx:i/hello/;
say 'Matches' if 'Hello, World!' ~~ $rx;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当 <code>:i</code> 副词在正则表达式里面时, 只有其后面的部分是不区分大小写的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'No match' if 'HeLLO, World!' !~~ /he :i llo/;
say 'Matches'  if 'HeLLO, World!'  ~~ /He :i llo/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要停掉该副词的行为, 请使用否定形式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Matches' if 'HeLLo, World!' ~~ /He :i ll :!i o/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>捕获括号和非捕获括号限制了副词的作用域:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Not OK' if $str !~~ / (:i hello)\, \s world /;
say 'OK' if $str ~~ / [:i hello]\, \s World /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这些例子中, <code>:i</code> 只影响第一个单词。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ssigspace">11.9.2. :s(:sigspace)</h4>
<div class="paragraph">
<p>我们已经多次看到, 在正则表达式中, 额外的空格会被忽略, 而且它们经常被用来使正则表达式更易读。但是在某些情况下, 特别是当正则表达式应该与带空格的字符串匹配时, 最好禁用这个特性, 要求空格按照字面意思匹配。</p>
</div>
<div class="paragraph">
<p>在下面的例子中, 我们从日期中提取出天、月份和年份这三个部分。由于原始的面向人的字符串中存在空格, 所以我们需要在正则表达式中对其进行处理。默认情况下, 空格是被忽略的, 在正则表达式中应该在预计有空格的地方包含 <code>\s</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $date = '19 April 2017';
$date ~~ / (\d+) \s (\w+) \s (\d+) /;

say "Year = $2, month = $1, day = $0";</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>:s</code> 副词, 正则表达式里面的字面值空格将与字符串匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $date = '19 April 2017';
$date ~~ m:s/ (\d+) (\w+) (\d+) /;

say "Year = $2, month = $1, day = $0";</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 的好处是(有些可能令人困惑), 正则表达式周围的空格仍然会被忽略。在上面的例子中, 我们看到第一个斜线之后和最后一个斜线之前都有空格。这些空格不需要匹配。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ppos">11.9.3. :p(:pos)</h4>
<div class="paragraph">
<p>带有 <code>:p</code> 或 <code>:pos</code> 副词的正则表达式从副词的参数指定的位置匹配字符串。从下面的例子中可以清楚地看到这个行为。</p>
</div>
<div class="paragraph">
<p>默认情况下, 正则表达式从字符串的开头开始匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'pineapple' ~~ / (\w+) /;
say $0; # pineapple</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <code>\w+</code> 的贪婪性, 整个字符串会被消耗掉并匹配。让我们试试跳过几个字符, 并将正则表达式应用到相同的字符串上:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'pineapple' ~~ m:p(4)/ (\w+) /;
say $0; # apple</code></pre>
</div>
</div>
<div class="paragraph">
<p>这次, 只匹配 <code>apple</code> 子串。</p>
</div>
<div class="paragraph">
<p><code>:p</code> 副词的索引也表现得像锚点。类似于 <code>^</code> 将正则表达式绑定到字符串的开头, <code>:p(N)</code> 副词将正则表达式绑定到给定的位置。比较下面的两个匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'pineapple' ~~ m:p(4)/ (a\w+) /;
'pineapple' ~~ m:p(3)/ (a\w+) /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中第一个成功了, 因为它在字符串的第四个位置找到了 <code>a</code>。第二个匹配, 当它在第三个位置看到 <code>e</code> 时立即失败了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_gglobal">11.9.4. :g(:global)</h4>
<div class="paragraph">
<p><code>:g</code> 副词用于全局匹配。正则表达式将被应用到字符串上几次, 每次从上一次匹配停止的位置开始。</p>
</div>
<div class="paragraph">
<p>例如, 让我们把一个句子分成单独的单词:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @words = 'Hello, World!' ~~ m:g/ (\w+) /;
say join ';', @words; # Hello;World</code></pre>
</div>
</div>
<div class="paragraph">
<p>还记得本章的 Match 对象一节中提取 HTML 属性的例子吗? 为了得到两个值, 这个正则表达式包含两个相同模式的副本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = q{&lt;a href="index.html" class="menu"&gt;};
$str ~~ / \" (.*?) \" .* \" (.*?) \" /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了避免这种情况, 并使正则表达式更通用, 可以使用全局匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = q{&lt;a href="index.html" class="menu"&gt;};
$str ~~ m:g/ \" .+? \" /;
say ~$/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序会打印出 "index.html" "menu", 它们是从字符串中提取的两个匹配元素。<code>~$/</code> 语法对 <strong>Match</strong> 对象进行了字符串化; 这个动作相当于在双引号字符串中对对象进行插值, 就像我们之前所做的那样。</p>
</div>
<div class="paragraph">
<p>与 <code>:i</code> 修饰符不同, 你不能把 <code>:g</code> 放在正则表达式里面。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ccontinue">11.9.5. :c(:continue)</h4>
<div class="paragraph">
<p><code>:c</code> 副词要求从上一个位置继续。</p>
</div>
<div class="paragraph">
<p>考虑一下上一节中关于 <code>:g</code> 副词的例子。我们可以只匹配几次, 而不是全局匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = q{&lt;a href="index.html" class="menu"&gt;};

$str ~~ m/ \" .+? \" /;
say ~$/;

$str ~~ m:c/ \" .+? \" /;
say ~$/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有 <code>:c</code>, 第二个匹配将从字符串的开头开始, 它会返回与第一个匹配相同的结果。如果有了 <code>:c</code>, 它将以相同的字符串继续匹配, 所以第二个属性将被捕获。</p>
</div>
<div class="paragraph">
<p>这个副词可以接收一个索引作为参数。在这种情况下, 相应的正则表达式匹配将从给定位置开始。这在下面的例子中得到了证明:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = q{&lt;div class="menu"&gt;&lt;div class="item"&gt;};
$str ~~ m:c(10)/ 'class="' .*? '"' /;
say ~$/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>正则表达式被应用于从第 10 个字符开始的字符串。在这种情况下, 第一个潜在的匹配被跳过, 程序找到第二个类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">class="item"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rracate">11.9.6. :r(:racate)</h4>
<div class="paragraph">
<p>这个副词在正则表达式中禁用回溯。在贪婪一节中, 我们已经看到, 当一个贪婪量词消耗了太多字符后, 正则表达式引擎是如何回滚的, 以便用更少的字符再做一次尝试。<code>:r</code> 副词不会让这种情况发生。它解释了 <code>:ratchet</code> 这个名字的含义 - 它只会往前走。</p>
</div>
<div class="paragraph">
<p>例如, 在下一个例子中, 创建的正则表达式是为了查找所有以 0 结尾的数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 1..100 {
    .say if / \d+ 0 /;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个代码打印出 10、20 等四舍五入的数字。如果使用 <code>:r</code>, 什么都不会被打印出来, 因为 <code>\d+</code> 会消耗掉数字中的所有数字, 而且 <code>:r</code> 没有留下与 0 匹配的空间。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ovoverlap">11.9.7. :ov(:overlap)</h4>
<div class="paragraph">
<p><code>:ov</code> 副词改变了正则表达式应用于字符串的方式, 这样, 所有重叠的、在每个位置上最长的匹配都会被找到。</p>
</div>
<div class="paragraph">
<p>让我们以查找 <code>pi</code> 的值内的所有以 1 开头和结尾的所有数字为例来说明这个问题:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pi =
   '3.1415926535897932384626433832795028841971693993751058209749445923078164';
my @a = $pi ~~ m:g/1.*?1/;
say ~@a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该代码打印的值如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">141 1971 10582097494459230781</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可能会注意到, 它在原始值的不同部分中找到了序列, 而且它们是不相交的。</p>
</div>
<div class="paragraph">
<p>现在, 让我们添加 <code>:ov</code> 副词。要在一个已经有副词的正则表达式中添加另一个副词, 只需将其附加到前一个副词上即可:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pi =
   '3.1415926535897932384626433832795028841971693993751058209749445923078164';
my @a = $pi ~~ m:g:ov/1.*?1/;
say ~@a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次的输出是不一样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">141 15926535897932384626433832795028841 1971 1693993751 10582097494459230781</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个下一个值与前一个值共享相同的字符 1。结果包含了前一个例子中的所有值, 但也包括介于两者之间的值, 这些值也匹配 <code>1.*?1</code> 模式。</p>
</div>
<div class="paragraph">
<p>如果我们去掉反贪婪量词, 那么 <code>:ov</code> 副词的性质就更加明显了。在这种情况下, 正则表达式 <code>m:g:ov/1.*1/</code> 在每一个位置都会返回最长的匹配, 在这里它看到的是 1。当它到达字符串的末尾时, 子匹配会越来越短:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">14159265358979323846264338327950288419716939937510582097494459230781 159265358979323846264338327950288419716939937510582097494459230781 19716939937510582097494459230781 16939937510582097494459230781 10582097494459230781</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们把模式改成这个模式呢?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = $pi ~~ m:g:ov/1.*?2/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>将它应用到 <code>$pi</code> 后, 程序打印出以下行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">141592 1592 19716939937510582 16939937510582 10582</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次, 重叠性更强 - 比如说 <code>1592</code> 这个字符串, 完全包含在第一个匹配 <code>141592</code> 中。</p>
</div>
</div>
<div class="sect3">
<h4 id="_exexhaustive">11.9.8. :ex(:exhaustive)</h4>
<div class="paragraph">
<p>这个副词尽会尽可能多的找到子串, 考虑到所有的可能性, 包括重叠值和不同长度的子串。这在一定程度上类似于 <code>:ov</code> 副词的正则表达式行为, 但并不选择最长的匹配。</p>
</div>
<div class="paragraph">
<p>让我们用同样的模式 <code>/1.*1/</code> 在 <code>pi</code> 值上测试这个副词(但这次我们将取一个较短的字符串):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $pi = '3.141592653589793238462643383279502884197169';
my @a = $pi ~~ m:g:ex/1.*1/;
say ~@a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了节省一点输出空间, 我们采取了一个较短的版本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1415926535897932384626433832795028841971 1415926535897932384626433832795028841 141 15926535897932384626433832795028841971 15926535897932384626433832795028841 1971</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为练习, 使用另一个具有非贪婪量词 <code>m:g:ex/1.*?1/</code> 的正则表达式尝试相同的值。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用正则表达式替换和修改字符串">11.10. 使用正则表达式替换和修改字符串</h3>
<div class="paragraph">
<p>使用正则表达式来匹配字符串, 通常可以从给定的数据中提取一些信息。另一个常见的任务是用不同的字符替换文本中的部分内容。在 Raku 中, <code>s</code> 内置函数就可以完成这个任务。</p>
</div>
<div class="paragraph">
<p>它需要两个参数, 即一个正则表达式和一个替换。将正则表达式应用于源字符串, 并且模式被匹配时, 匹配的字符串部分会被替换为第二个参数。</p>
</div>
<div class="paragraph">
<p>考虑一个简单的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = 'Its length is 10 mm';
$str ~~ s/&lt;&lt;mm&gt;&gt;/millimeters/;
say $str; # Its length is 10 millimeters</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的正则表达式 <code>/<a href="#mm">[mm]</a>/</code> 与单词 <code>mm</code> 匹配。第二部分告诉我们要用测量单位的全名来替换它。替换就地发生, 并且修改了原始字符串。</p>
</div>
<div class="paragraph">
<p>传统上, <code>s</code> 使用斜线作为分隔符, 但也可以使用不同的字符。请看前面的代码中的替换示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$str ~~ s|&lt;&lt;mm&gt;&gt;|millimeters|;
$str ~~ s;&lt;&lt;mm&gt;&gt;;millimeters;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第二个例子中, 最后两个分号的意思是不同的 - 其中一个是正则表达式和替换部分的分隔符, 而另一个是 Raku 表达式的分隔符。</p>
</div>
<div class="paragraph">
<p>在替换部分中, 替换文本可以使用变量插值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = 'Its length is 10 mm';
my $standard-length = 7;
$str ~~ s/\d+/$standard-length/;
say $str; # Its length is 7 mm;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>s///</code> 的第一部分中捕获的值也可用于替换:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $date = '20070419';
$date ~~ s/ (\d ** 4) (\d\d) (\d\d) /$2.$1.$0/;
say $date;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>s</code> 中的正则表达式将日期分割为年、月、日三部分, 并以不同的顺序组合成不同的替换模式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_13">11.11. 总结</h3>
<div class="paragraph">
<p>在本章中, 我们讨论了 Raku 中的正则表达式。它们与 Perl 5 中的正则表达式有许多共通之处, 但也提供了许多令人着迷的新东西。我们研究了构建正则表达式和匹配文本的方法, 学会了如何通过编写自定义字符类或内置字符类来扩展正则表达式引擎的功能。我们还研究了 Raku 在 Match 对象中存储结果的方法, 以及如何使用正则表达式在字符串中进行替换。</p>
</div>
<div class="paragraph">
<p>在下一章中, 我们会遇到一个更强大的工具, 它极大地扩展了正则表达式, 即 grammar。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_grammars">12. Grammars</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 带来了一个非常有用和强大的机制来实现正则表达式—grammar。</p>
</div>
<div class="paragraph">
<p>Grammar 是 Raku 中的一种迷你语言, 允许你描述其他语言的规则(包括 Raku 本身)。使用 grammar, 创建解析器、翻译器或领域特定语言(DSL)或编程语言的编译器, 甚至是人类语言的解析器都非常容易。</p>
</div>
<div class="paragraph">
<p>在本章中, 我们将通过为其创建 Raku 编译器的子集来学习 Raku 的 grammar。本章将介绍以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建 grammar</p>
</li>
<li>
<p>grammar 的元素 - rule 和 token</p>
</li>
<li>
<p>TOP 规则</p>
</li>
<li>
<p>空白处理</p>
</li>
<li>
<p>解析文本</p>
</li>
<li>
<p>使用 Action</p>
</li>
<li>
<p>使用抽象语法树(AST)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本章假定你熟悉正则表达式。如果你还没有读过第11章, 正则表达式, 现在正是这样做的合适时机。另外, 了解在 Raku 中组织类是必需的, 这包含在第8章面向对象的编程中。</p>
</div>
<div class="sect2">
<h3 id="_创建_grammar">12.1. 创建 grammar</h3>
<div class="paragraph">
<p>与正则表达式一样, grammar 定义了一些规则来从给定的文本中提取信息。正则表达式的一个典型应用是在文本块中找到片段, 并将其分分割成有意义的片段, 例如, 查找电子邮件或检查其格式是否正确。 Grammar 有一个更大的目标 - 他们的任务通常是阅读整个文本并理解所有的内容。例如, 如果将 grammar 应用于以某种编程语言编写的源代码 , grammar 必须检查其有效性, 并创建该程序的语法树。这种区别仍然是一种约定 - grammar 可以解析小的文本部分, 就像正则表达式可以用来分析大的文本部分一样。</p>
</div>
<div class="paragraph">
<p>Raku 中 grammar 的语法就像定义一个类一样。Grammar 从 <strong>grammar</strong> 关键字开始:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个 grammar 是空的, 无法应用到文本中。我们必须添加起始规则, 这将是 grammar 的入口点。</p>
</div>
<div class="paragraph">
<p>Grammar 包含了 <strong>rule</strong> 和 <strong>token</strong>。我们将在本章中详细讨论它们, 但目前我们需要创建主规则, 也就是 grammar 应用于文本的第一个规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
    rule TOP {
        .*
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见, 规则类似于类中的方法。与方法不同的是, 规则在其主体块中包含了正则表达式。此示例中的 <code>TOP</code> 规则匹配了模式 <code>.*</code>,  它实际上匹配了所有的东西。这就足够了, 首先我们要创建一个最小的 grammar, 看看如何将其应用到文本上。<code>TOP</code> 是一个预定义的名字, 你可以给 grammar 中的第一个规则起一个名字。</p>
</div>
<div class="paragraph">
<p>正如本章开头提到的, 我们将为Raku 的小型子集创建一个解析器(为了简单起见, 我们将忽略真正的 Raku grammar 中的一些边缘情况)。因此, 我们的第一个 grammar 要解析的文本可能是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $text = 'my $x;';</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用我们的 grammar <code>G</code> 来解析 <code>$text</code>, 可以调用 <code>parse</code> 方法对其进行解析:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result = G.parse($text);
say $result;</code></pre>
</div>
</div>
<div class="paragraph">
<p>其结果是一个复杂的 grammar 对象, 其中包含了被匹配的文本。在我们这个简单的例子中, <code>TOP</code> 规则消耗了整个文本, 字符串化的值看起来像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">「my $x」</code></pre>
</div>
</div>
<div class="paragraph">
<p>应用一个 grammar 至少有三个目标:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>检查源文本在文法上是否正确。</p>
</li>
<li>
<p>将文本分割成语法元素。</p>
</li>
<li>
<p>根据语言规则执行 action。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在本章中, 我们将对这三个部分进行编程, 但我们的第一个任务是学习如何检查文本是否与 grammar 匹配。</p>
</div>
<div class="sect3">
<h4 id="_匹配_grammar">12.1.1. 匹配 grammar</h4>
<div class="paragraph">
<p>我们的示例程序将在后面的章节中逐行解析, 看起来是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;
$x = 5;
say $x; # 5

my $y;
$y = $x;
say $y; # 5

my $z;
$z = $x + $y;
say $z; # 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个有效的 Raku 程序, 我们必须创建解析和执行这个程序的 grammar。</p>
</div>
<div class="paragraph">
<p>让我们把参考程序保存在一个单独的文件中, 比如说 <code>refer.pl</code>, 使用 <code>parsefile</code> 方法而不是 <code>parse</code> 方法来解析它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result = G.parsefile('refer.pl');
say $result;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序打印了整个文件的内容, 因为此 <code>TOP</code> 规则仍然匹配它得到的一切。为了确保 grammar 解析整个文件, 让我们添加锚点来绑定文本的开头和结尾:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> grammar G {
    rule TOP {
        ^ .* $
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以在规则中随意使用空格以使正则表达式更清晰:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    ^
        .*
    $
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一个子目标是分别解析每一行代码。准确地说, grammar 不应该解析源文本的行, 而应该解析用分号分隔的指令。解析器不应该依赖于代码中添加了多少个空格和换行符。</p>
</div>
<div class="paragraph">
<p>现在我们要用 grammar 来形式化刚才所说的内容。源程序是一个用分号分隔的语句列表。让我们修改一下 <code>TOP</code> 规则来表达:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    ^
        (.*? ';')*
    $
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们从最小的程序开始:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;
$x = 5;
say $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你查看打印 <code>$result</code> 的程序的输出, 你会看到整个文件的内容, 后面是像这样的单独指令:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">⌈my $x;
$x = 5;
say $x;⌋
 0 =&gt; ⌈my $x;⌋
 0 =&gt; ⌈
$x = 5;⌋
 0 =&gt; ⌈
say $x;⌋;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出结果有点乱, 但我们可以看到, 源文件中的每一条语句都被放到了 <code>$result</code> 中的一个单独的元素中, 这与 <strong>Match</strong> 对象是如何包含匹配字符串与正则表达式匹配的部分相似。</p>
</div>
<div class="paragraph">
<p>提取的片段包含了前导空格, 我们可以通过在 grammar 中允许它们的存在, 从而很容易地将其抑制:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    ^
        [\s* (.*? ';')]*
    $
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为避免不必要的捕获, 使用了方括号。现在的输出看起来更清晰了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">⌈my $x;
$x = 5;
say $x;⌋
 0 =&gt; ⌈my $x;⌋
 0 =&gt; ⌈$x = 5;⌋
 0 =&gt; ⌈say $x;⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>引用程序中的所有语句都被捕获了; 我们只需要让 grammar 忽略注释就可以了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
    ^
        [\s* (.*? ';') ['#' &lt;-[\n]&gt;* ]? ]*
    $
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>正则表达式的附加部分 ['#' &lt;-[\n]&gt;* ]? 可以找到以 <code>#</code> 字符开头的可选子字符串, 并一直到行尾(换句话说, 它们包含非 <code>\n</code> 字符)。</p>
</div>
<div class="paragraph">
<p><code>TOP</code> 规则的正则表达式越来越复杂, 所以是时候把它分成几个部分了, 以使整个 grammar 更具可读性和可维护性。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用_rule_和_token">12.2. 使用 rule 和 token</h3>
<div class="paragraph">
<p>Raku 中的 grammar 提供了一种非常有用的方法, 可以将 grammar 元素分成若干部分。让我们用它来说明 grammar 元素。</p>
</div>
<div class="paragraph">
<p>复杂的正则表达式 \s* (.*? ';') ['#' &lt;-[\n]&gt;* ]? 包含两个部分 - 提取语句的正则表达式和用于注释的正则表达式。我们将它们提取成单独的规则。 单个 <strong>rule</strong> 描述了 grammar 中的一小部分, 可以引用其他规则。请看下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
    rule TOP {
        ^
            [ &lt;statement&gt; \s* &lt;comment&gt;? ]*
        $
    }
    rule statement {
        .*? ';'
    }
    rule comment {
        '#' &lt;-[\n]&gt;*
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在 <code>TOP</code> 规则更加清晰了, 你马上就能看到程序是一连串的语句, 后面有可选的注释(我们的 grammar 不允许没有语句的注释)。</p>
</div>
<div class="paragraph">
<p>到目前为止, grammar 已经完全解析了 <code>refer.pl</code> 文件, 但我们可以更进一步。我们可以提取语句, 接下来的任务是理解它们。现在让我们逐行解析文件, 添加新的行和可以解析语句的 grammar 规则一起加入到文件中。 你可以通过将源文本嵌入到我们的主文件中来完成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $prog = q:to/END/;
my $x;
END

my $result = G.parse($prog);
say $result;</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一行 <code>my $x</code> 包含一个变量声明语句。由于我们从只能解析变量声明的 grammar 开始, 这里是修改后的 <code>statement</code> 规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule statement {
    &lt;variable-declaration&gt; ';'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>变量声明是由 <code>my</code> 关键字和变量组成的序列:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule variable-declaration {
    'my' &lt;variable&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个 <code>variable-declaration</code> 规则包含两个部分, 一个是字面字符串 <code>'my'</code>, 另一个是对规则 <code>&lt;variable&gt;</code> 的引用。我们没有明文规定这两部分之间的空格。Raku 中的规则会关心这些空格。因此, 规则可以解析在 <code>my</code> 和变量之间包含一个、两个或多个空格的变量声明。 即使是以下字符串也可以被正确解析 - <code>my$x</code>。</p>
</div>
<div class="paragraph">
<p>为了描述一个变量, 我们创建一个 <strong>token</strong>。token 就像 <strong>rule</strong> 一样, 但不允许元素之间有空格。所以一个有效的变量名应该是一个没有空格的字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token variable {
    &lt;sigil&gt; &lt;identifier&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>sigil 既可以是标量 sigil <code>$</code>, 也可以是数组 sigil <code>@</code>。虽然在本章开头的示例程序中我们没有数组, 但让我们在后面要用的 grammar 中先准备一下, 以便在以后的工作中使用这些标量和数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token sigil {
    '$' | '@'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后, 描述一个标识符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token identifier {
    &lt;alpha&gt; &lt;alnum&gt;*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个 grammar 描述的语言中, 标识符是以字母开头的字母数字字符序列。</p>
</div>
<div class="paragraph">
<p>使用前面列出的 <strong>rule</strong> 和 <strong>token</strong>, grammar 解析我们的引用程序的第一行, 它看起来长这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">⌈my $x;
⌋
 statement =&gt; ⌈my $x;
⌋
 variable-declaration =&gt; ⌈my $x⌋
  variable =&gt; ⌈$x⌋
   sigil =&gt; ⌈$⌋
    identifier =&gt; ⌈x⌋
     alpha =&gt; ⌈x⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出显示了这个程序的解析树。缩进有助于更好地理解结构。在最上层, 我们看到程序 <code>my $x</code> 包含了一个语句 <code>my $x</code>, 它是一个变量声明。变量是 <code>$x</code>, 它包括一个符号 <code>$</code> 和一个以字母 x 开头的标识符 <code>x</code>。</p>
</div>
<div class="paragraph">
<p>对于更长的变量名, 比如 <code>@array</code>, 解析树将包含所有与 <code>identifier</code> 规则中的 <code>&lt;alnum&gt;*</code> 部分匹配的字母:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">variable-declaration =&gt; ⌈my @array⌋
 variable =&gt; ⌈@array⌋
  sigil =&gt; ⌈@⌋
  identifier =&gt; ⌈array⌋
   alpha =&gt; ⌈a⌋
   alnum =&gt; ⌈r⌋
   alnum =&gt; ⌈r⌋
   alnum =&gt; ⌈a⌋
   alnum =&gt; ⌈y⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们解析文件的第二行, 其中包含了赋值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $prog = q:to/END/;
my $x;
$x = 100;
END</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>assignment</code> 也是一个 <code>statement</code>, 所以要解析它, <strong>statement</strong> 规则必须知道什么是 <strong>assignment</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule statement {
    [
        | &lt;variable-declaration&gt;
        | &lt;assignment&gt;
    ]
    ';'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>新的规则包含了由竖直条分隔的备选项列表; 一对方括号将备选项分组, 但不捕获文本。实际上, 第一个竖直条不是必须的, 但加上它可以使代码看起来更有条理。</p>
</div>
<div class="paragraph">
<p><code>assignment</code> 规则的第一种方法仅包括数值赋值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule assignment {
    &lt;variable&gt; '=' &lt;value&gt;
}
token value {
    &lt;number&gt;
}
token number {
    &lt;digit&gt;+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这时, grammar 解析的程序如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;
$x = 100;</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二个语句根据 grammar 进行解析, 形成了以下解析树:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">statement =&gt; ⌈$x = 100;
⌋
 assignment =&gt; ⌈$x = 100⌋
  variable =&gt; ⌈$x⌋
  sigil =&gt; ⌈$⌋
  identifier =&gt; ⌈x⌋
   alpha =&gt; ⌈x⌋
  value =&gt; ⌈100⌋
   number =&gt; ⌈100⌋
    digit =&gt; ⌈1⌋
    digit =&gt; ⌈0⌋
    digit =&gt; ⌈0⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序的第三行是 <code>say $x;</code>。让我们把这种语句称为 <code>say-function</code>,  并为它实现规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule say-function {
    'say' &lt;variable&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见, 这非常简单, 因为我们已经有了一个解析变量的规则。最后, 必须将这个新的规则添加到 <code>statement</code> 规则中的备选列表中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule statement {
    [
        | &lt;variable-declaration&gt;
        | &lt;assignment&gt;
        | &lt;say-function&gt;
    ]
    ';'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>语句被成功解析:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">statement =&gt; ⌈say $x;
⌋
 say-function =&gt; ⌈say $x⌋
  variable =&gt; ⌈$x⌋
   sigil =&gt; ⌈$⌋
   identifier =&gt; ⌈x⌋
    alpha =&gt; ⌈x⌋</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们休息一下, 让我们的编译器不仅可以解析程序, 还可以执行程序。这里, action 就应运而生了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_action">12.3. 使用 action</h3>
<div class="paragraph">
<p>Grammar 本身并不只是解析源文本还从中提取数据片段。要使程序执行代码, 需要 action。Grammar 中的 action 是 Raku 中的代码片段, 当 grammar 成功地解析了一条 rule 或一个 token 时, 就会触发 action。</p>
</div>
<div class="paragraph">
<p>让我们看一下 <code>variable-declaration</code> 规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule variable-declaration {
    'my' &lt;variable&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当 grammar 找到源文本中的序列 <code>my $x</code> 时, 该规则就满足了。这时, 你可以添加一个 action:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule variable-declaration {
    'my' &lt;variable&gt; {say 'Declaring a variable'}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>action 可以是这样的简单警报, 但它也可能是更复杂的代码, 作为对变量声明的反应而执行。</p>
</div>
<div class="paragraph">
<p>为了使 action 正常执行, 它需要知道变量的类型(是否包含 <code>$</code> 或 <code>@</code> 符号)和它的名称。Action 可以访问反应解析片段的当前状态的 <strong>Match</strong> 对象。可以在 <strong>Match</strong> 对象中通过名称找到命名子规则; 例如, <code>$&lt;variable&gt;</code> 返回字符串 <code>$x</code>。</p>
</div>
<div class="paragraph">
<p>要深入挖掘, 就拿 <strong>Match</strong> 对象中的嵌套元素来说吧:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule variable-declaration {
    'my' &lt;variable&gt; {
        say 'Declaring ' ~
            ($&lt;variable&gt;&lt;sigil&gt; eq '$'
             ?? 'a scalar variable'
             !! 'an array') ~
             '"' ~ $&lt;variable&gt;&lt;identifier&gt; ~ '"';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行带有两个变量声明的程序的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $prog = q:to/END/;
my $x;
my @array;
END

G.parse($prog);</code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印了以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Declaring a scalar variable "x"
Declaring an array "array"</code></pre>
</div>
</div>
<div class="paragraph">
<p>这证明了 grammar 理解了程序, action 得到了正确的变量名和变量类型。</p>
</div>
<div class="paragraph">
<p>只要我们能够区分标量和数组, 我们就可以把它们的值保存下来, 以便在未来使用。为此, 定义两个全局变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %scalar;
my %array;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些散列的键对应于变量名。我们将在 grammar 的 action 中填充存储:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule variable-declaration {
    'my' &lt;variable&gt; {
        given $&lt;variable&gt;&lt;sigil&gt; {
            when '$' {
                %scalar{$&lt;variable&gt;&lt;identifier&gt;} = 'undefined';
            }
            when '@' {
                %array{$&lt;variable&gt;&lt;identifier&gt;} = 'undefined';
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在程序结束之前, 我们先来打印一下变量存储的内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %scalar;
say %array;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出告诉我们变量被成功找到, 并在存储中为它们创建了插槽:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">{x =&gt; undefined}
{array =&gt; undefined}</code></pre>
</div>
</div>
<div class="paragraph">
<p>思考下一步的问题。自然, 把值赋给变量就好了。 在上面的代码中, 我们使用 <code>given/when</code> 选择器将标量代码和数组代码分开。如果我们想添加对散列的支持呢? 添加一个新的 <code>when</code> 分支是没问题的, 但是我们必须在所有与变量相关的 action 中添加类似的分支。</p>
</div>
<div class="paragraph">
<p>其中一个解决方案是要求 grammar 区分变量的类型:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token variable {
    | &lt;scalar-variable&gt;
    | &lt;array-variable&gt;
}
token scalar-variable {
    '$' &lt;identifier&gt;
}
token array-variable {
    '@' &lt;identifier&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个解决方案是把变量存储成为单个变量 <code>%var</code>, 并将其用作二维散列:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %var;
# .. .
rule variable-declaration {
    'my' &lt;variable&gt; {
        %var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;} =
            'undefined';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样, <code>%var</code> 容器将得到以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">{$ =&gt; {x =&gt; undefined}, @ =&gt; {array =&gt; undefined}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要给一个变量赋值, 应该写一个 action。Grammar 已经有了赋值规则, 因此添加一个 action 是一件很容易的事情:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule assignment {
    &lt;variable&gt; '=' &lt;value&gt; {
        %var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;} =
            ~$&lt;value&gt;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 action 内部赋值的左侧, 我们看到的代码和我们之前已经在 <code>%var</code> 存储中访问变量的代码一样。右侧的表达式需要额外注意。</p>
</div>
<div class="paragraph">
<p>目前裸的 <code>$&lt;value&gt;</code> 包含了 <code>G</code> 类型的对象。要使它成为字符串, 需要使用字符串强制操作符(前缀 <code>~</code>)。这样, 它将被字符串化, 变量得到我们想要保存在那里的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">{$ =&gt; {x =&gt; 100}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了确认一切正常, 让我们解析一个使用两个标量变量的程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $prog = q:to/END/;
my $alpha;
$alpha = 50;
say $alpha;

my $beta;
$beta = 60;
say $beta;
END

G.parse($prog);
say %var; # {$ =&gt; {alpha =&gt; 50, beta =&gt; 60}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 让我们把注意力转移到实现 <code>say</code> 函数上。这个任务应该不难, 因为我们已经在其他规则和 action 中拥有了所有的代码片段。只要把它们组合在一起就可以了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule say-function {
    'say' &lt;variable&gt; {
        say %var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;};
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 编译器理解了三种语法结构 - 声明一个变量, 给变量赋值, 以及打印标量变量的内容。作为功课, 你可以实现错误处理, 当程序想使用一个未声明的变量或仍然包含未定义的值的变量时, 能处理错误。</p>
</div>
<div class="paragraph">
<p>这个 grammar 已经相当完善了, 但要给它添加越来越多的功能并不是很困难。每个新功能通常需要修改现有规则和 action, 或者添加新的规则和 action。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用抽象语法树属性">12.4. 使用抽象语法树属性</h3>
<div class="paragraph">
<p>目前, <code>G</code> grammar 只有当整数值被赋值给一个变量时才会解析构造:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$x = 100;</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们来看看如何为下面的赋值添加支持:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$x = $y;</code></pre>
</div>
</div>
<div class="paragraph">
<p>像 <code>$x = 100</code> 这样的结构解析规则使用了以下规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule assignment {
    &lt;variable&gt; '=' &lt;value&gt; { . . . }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在等号的右侧, 我们看到一个 <code>value</code>, 我们可以用一个更一般的项, 即 <code>expression</code> 来代替。最后, 表达式可以是任何一种语言所能理解的表达式, 比如 <code>10</code>, <code>$x</code>, <code>10 + 3</code> 或者 <code>$x + $y</code> 等等。让我们一步一步地接近这一点。首先, 介绍一下 <code>expression</code> 规则。问题是, 我们要把表达式的值返回给进行赋值的 action。</p>
</div>
<div class="paragraph">
<p>为了保存临时值, Raku grammar 提供了<strong>抽象语法树(AST)的属性</strong>。要保存这个值, 可以使用 <code>$/.make</code> 方法。要获得该值, 请使用 <code>$/.made</code> 或 <code>$/.ast</code> 方法(他们是同义词):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule assignment {
    &lt;variable&gt; '=' &lt;expression&gt; {
        %var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;} =
            $&lt;expression&gt;.made;
    }
}
rule expression {
    | &lt;value&gt; {
          $/.make(~$&lt;value&gt;)
      }
    | &lt;variable&gt; {
          $/.make(%var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;})
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用 <code>$/.make</code> 方法传递的值是附加在解析树的节点上的属性。这些值不会在执行 action 后消失, 其他规则的 action 通过 <code>$/</code> 变量仍然可以访问该值。</p>
</div>
<div class="paragraph">
<p>例如, 在前面的代码中, <code>expression</code> 规则的第一个分支中解析的字符串化值被附加到相应的节点 - <code>$/.make(~$&lt;value&gt;)</code>。随后, 这个值被用于 <code>assignment</code> action <code>$&lt;expression&gt;.made</code> 中。我们在第 11 章"正则表达式"中已经看到, <code>$&lt;expression&gt;</code> 是完整表达式 <code>$/&lt;expression&gt;</code> 的简称。</p>
</div>
<div class="paragraph">
<p>当 grammar 遇到像 <code>$x = $y</code> 这样的赋值时, 表达式规则的第二个分支变为活动状态。在这种情况下, 它从 <code>%var</code> 存储中获取变量的值, 并将其放到 AST 属性中。这时, 我们的编译器可以处理下面的程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;
$x = 100;

my $y;
$y = $x;
say $y; # 100</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_处理表达式">12.4.1. 处理表达式</h4>
<div class="paragraph">
<p>在很多以解析不同编程语言的源代码为目的的 grammar 中, 其中一个核心部分就是处理表达式。我们已经介绍了 <code>expression</code> 规则, 它可以理解简单的表达式, 如 <code>100</code> 或 <code>$x</code>。</p>
</div>
<div class="paragraph">
<p>下面我们继续介绍表达式规则, 教编译器用 <code>+</code> 运算符来解析和计算表达式。我们先从一个简单的情况开始, 当两个操作数都是整数字面量时:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
    | &lt;value&gt; '+' &lt;value&gt; {
          $/.make($&lt;value&gt;[0].ast + $&lt;value&gt;[1].ast)
      }
    | &lt;value&gt; {
          $/.make(~$&lt;value&gt;)
      }
    | &lt;variable&gt; {
          $/.make(%var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;})
      }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该规则得到了一个新的分支 <code>&lt;value&gt; '+' &lt;value&gt;</code>, 它使用了两个同名的规则。在这个 action 中, 这两个操作数是从数组的两个元素 - <code>$&lt;value&gt;[0]</code> 和 <code>$&lt;value&gt;[1]</code> 的 <code>ast</code>(或 <code>make</code>)属性中提取出来的。</p>
</div>
<div class="paragraph">
<p>另一个变化应该是在 <code>value</code> token 中进行的。到现在为止, 我们还没有在 AST 中保存任何东西。如果不这样做的话, 那么进一步的解析将不得不处理复杂的结构而不是简单的值。所以直接把它添加到树上就可以了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token value {
    &lt;number&gt; {$/.make(+$&lt;number&gt;)}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的前缀 <code>+</code> 用于将值转换为数值类型。</p>
</div>
<div class="paragraph">
<p>下一步是允许变量, 这样我们就可以解析像 <code>3 + $x</code> 这样的表达式了。</p>
</div>
<div class="paragraph">
<p>正如我们之前看到的那样, <code>expression</code> 规则可以表示变量的值。所以, 让我们用它来代替 <code>expression</code> 规则中的第二个 <code>value</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
    | &lt;value&gt; '+' &lt;expression&gt; {
          $/.make($&lt;value&gt;.ast + $&lt;expression&gt;.ast)
      }
    | &lt;value&gt; {
          $/.make(~$&lt;value&gt;)
      }
    | &lt;variable&gt; {
          $/.make(%var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;})
      }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外, 更新 <code>variable</code> 规则以在 AST 中保存变量的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token variable {
    &lt;sigil&gt; &lt;identifier&gt; {
        $/.make(%var{$&lt;sigil&gt;}{$&lt;identifier&gt;})
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是将变量用作 <code>+</code> 运算符的第二个操作数所需的全部内容。现在的 grammar 是这样解析程序的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;
my $y;

$x = 3;
$y = 4 + $x;

say $y; # 7</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>+</code> 运算符左侧允许变量是比较困难的。问题是, 到目前为止, 我们在可能期待变量的地方使用了 <code>expression</code> 规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
    | &lt;value&gt; '+' &lt;expression&gt;
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>只将左侧的 <code>value</code> 更改为 <code>expression</code> 是不行的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
    | &lt;expression&gt; '+' &lt;expression&gt;
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种变化导致了无限递归 - 要了解表达式是什么, 你需要解析解析表达式, 它是表达式加表达式, 以此类推。一种可能的解决方案是隐式列出第一个可以是操作数的选项:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
    | &lt;value&gt; '+' &lt;expression&gt; {
          $/.make($&lt;value&gt;.ast + $&lt;expression&gt;.ast)
      }
    | &lt;variable&gt; '+' &lt;expression&gt; {
          $/.make($&lt;variable&gt;.ast + $&lt;expression&gt;.ast)
      }
    | &lt;value&gt; {
          $/.make(~$&lt;value&gt;)
      }
    | &lt;variable&gt; {
          $/.make(%var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;})
      }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>更好的方法是引入另一个规则, 即 <code>term</code>, 既可以是 <code>value</code> 也可以是 <code>variable</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
    | &lt;term&gt; '+' &lt;expression&gt; {
          $/.make($&lt;term&gt;.ast + $&lt;expression&gt;.ast)
      }
    | &lt;value&gt; {
          $/.make(~$&lt;value&gt;)
      }
    | &lt;variable&gt; {
          $/.make(%var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;})
      }
}
rule term {
    | &lt;value&gt; {$/.make($&lt;value&gt;.ast)}
    | &lt;variable&gt; {$/.make($&lt;variable&gt;.ast)}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>目前可以做些什么呢? 可以用 Raku 语言的微小子集中的(已经相当复杂的)程序进行解析和执行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;
my $y;

$x = 3;
$y = 4 + $x;
say $y; # 7

my $z;
$z = $x + $y;
say $z; # 10

my $a;
$a = $z + 5;
say $a; # 15</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为奖励, 该程序还可以解析涉及 <code>+</code> 运算符的复杂表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $b;
$b = $a + $x + $y + $z + 7;
say $b; # 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们没有做任何特别的事情来让这一点得以实现, 但 grammar 将表达式拆分成简单的表达式, 比如 <code>$a + $x</code>, 计算出值, 然后更进一步。每走一步, 就会执行具有两个操作数的简单运算。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用_action_类">12.5. 使用 action 类</h3>
<div class="paragraph">
<p>Grammar 越复杂, action 就越复杂。在我们目前的 grammar 中, 几乎每一个 <strong>rule</strong> 或 <strong>token</strong> 都有一个 action。即使大多数的 action 只是一两行代码, 但由于 Raku 的代码与 grammar 语言混合在一起, 使得阅读代码变得困难重重。对代码进行格式化也成为了一个难题, 因为你需要添加更多的空格来正确地缩进代码。在本节中, 我们将看看 Raku 提供了哪些方法来解决这个问题。</p>
</div>
<div class="paragraph">
<p>所有的 action 都可以移动到一个单独的类中。因此, 完整的 grammar 包含一个 grammar 本身和一个 action 类。Grammar 的 rule 与 token 之间的对应关系, 只需给 action 类的方法起相同的名字就可以实现。让我们将 grammar 转换为使用拆分的方法。</p>
</div>
<div class="paragraph">
<p>首先, 为 action 创建一个类, 并将其传递给解析器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> grammar G {
    ...
}
class A {
    ...
}
...

G.parse($prog, :actions(A));</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 将 action 代码从 grammar 的 rule 或 token 中移动到 action 类的单独方法中。</p>
</div>
<div class="paragraph">
<p>以 <strong>variable</strong> 规则为例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token variable {
    &lt;sigil&gt; &lt;identifier&gt; {
        $/.make(%var{$&lt;sigil&gt;}{$&lt;identifier&gt;})
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个代码应分成 grammar 规则和 action 两个部分:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
    ...
    token variable {
        &lt;sigil&gt; &lt;identifier&gt;
    }
    ...
}
class A {
    ...
    method variable($/) {
        $/.make(%var{$&lt;sigil&gt;}{$&lt;identifier&gt;})
    }
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于代码现在被放置在 grammar 之外, 我们必须传递 <code>$/</code> 变量作为方法的参数。这个参数可以使用任何其他的名称, 但 <code>$/</code> 似乎是最常见和最常规的选择。</p>
</div>
<div class="paragraph">
<p>用同样的方式, 其他的 action 也可以被提取出来并放到 action 类中。我们不会花时间来描述那些重复的代码变化(你可以在本章末尾看到最终的代码), 而是直接看一下具有备选项的规则。这个 grammar 中有两个这样的规则, 即 <code>expression</code> 和 <code>term</code>。</p>
</div>
<div class="paragraph">
<p>考虑一下 <strong>term</strong> 规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> rule term {
    | &lt;value&gt; {$/.make($&lt;value&gt;.ast)}
    | &lt;variable&gt; {$/.make($&lt;variable&gt;.ast)}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里我们有两个不同的 action, 但我们只能在 action 类中添加一个方法。</p>
</div>
<div class="paragraph">
<p>至少有三种解决方法。第一, 可以把这个规则拆分成两个规则, 从而产生两个不同的 action。第二, 我们可以分析 <code>$/</code> 变量的内容, 并执行其中的一个分支:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method term($/) {
    if $&lt;value&gt; {
        $/.make($&lt;value&gt;.ast)
    }
    elsif $&lt;variable&gt; {
        $/.make($&lt;variable&gt;.ast)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是 Raku 给了我们一个更好的选择 - 使用 <code>multi</code> 方法并使其对 <code>$/</code> 参数中的数据敏感:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method term($/ where $/&lt;value&gt;) {
    $/.make($&lt;value&gt;.ast)
}
multi method term($/ where $/&lt;variable&gt;) {
    $/.make($&lt;variable&gt;.ast)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在方法的签名中, 创建了一个子类型。<code>multi</code> 方法的每个变体都会根据不同分支的匹配规则来调用。我们在第 6 章的 Multi subs 中用了这个技巧。</p>
</div>
<div class="paragraph">
<p>在把所有的 action 移动单独的类中后, 把全局变量 <code>%var</code> 移到类中也是明智的做法。目前, 整个程序的骨架看起来是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
    ...
}

class A {
    my %var;
    ...
}

G.parse($prog, :actions(A));</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在的 <code>%var</code> 存储是类属性, 它属于类, 而不属于类的实例。 实际上, 我们并没有创建任何 <code>A</code> 的实例, <code>G.parse</code> 方法接收的是类的名字。这对于某些应用来说可能没有问题, 但是为了确保变量存储不保留之前运行的解析器的值, 最好是把 <code>%var</code> 作为私有属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    has %!var;
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>类需要先被实例化。否则, 就不会为 <code>%var</code> 属性分配内存。<code>parse</code> 方法也接受 <code>action</code> 类的实例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">G.parse($prog, :actions(A.new));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_完整的程序">12.6. 完整的程序</h3>
<div class="paragraph">
<p>通过学习 Raku 中的 grammar, 我们取得了很多收获。试想一下, 我们创建的程序可以解析另一个用 Raku 编写的程序!</p>
</div>
<div class="paragraph">
<p>虽然还有很多需要改进的地方, 但你一定能做到。例如, 你可以从实现对数组的支持开始。</p>
</div>
<div class="paragraph">
<p>以下是我们在本章中创建的编译器的完整代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
    rule TOP {
        ^
            [ &lt;statement&gt; \s* &lt;comment&gt;? ]*
        $
    }
    rule statement {
        [
            | &lt;variable-declaration&gt;
            | &lt;assignment&gt;
            | &lt;say-function&gt;
        ]
        ';'
    }
    rule comment {
        '#' &lt;-[\n]&gt;*
    }
    rule variable-declaration {
        'my' &lt;variable&gt;
    }
    token variable {
        &lt;sigil&gt; &lt;identifier&gt;
    }
    token sigil {
        '$' | '@'
    }
    token identifier {
        &lt;alpha&gt; &lt;alnum&gt;*
    }
    rule assignment {
        &lt;variable&gt; '=' &lt;expression&gt;
    }
    rule expression {
        | &lt;term&gt; '+' &lt;expression&gt;
        | &lt;value&gt;
        | &lt;variable&gt;
    }
    rule term {
        | &lt;value&gt;
        | &lt;variable&gt;
    }
    token value {
        &lt;number&gt;

    }
    token number {
        &lt;digit&gt;+
    }
    rule say-function {
        'say' &lt;variable&gt;
    }
}

class A {
    has %!var;
    method variable-declaration($/) {
        %!var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;} =
            'undefined';
    }
    method variable($/) {
        $/.make(%!var{$&lt;sigil&gt;}{$&lt;identifier&gt;})
    }
    method assignment($/) {
        %!var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;} =
            $&lt;expression&gt;.ast;
    }
    method value($/) {
        $/.make(+$&lt;number&gt;)
    }
    method say-function($/) {
        say %!var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;};
    }
    multi method term($/ where $/&lt;value&gt;) {
        $/.make($&lt;value&gt;.ast)
    }
    multi method term($/ where $/&lt;variable&gt;) {
        $/.make($&lt;variable&gt;.ast)
    }
    multi method expression($/ where $/&lt;term&gt;) {
        $/.make($&lt;term&gt;.ast + $&lt;expression&gt;.ast)
    }

    multi method expression($/ where $/&lt;value&gt;) {
        $/.make(~$&lt;value&gt;)
    }
    multi method expression($/ where $/&lt;variable&gt;) {
        $/.make(%!var{$&lt;variable&gt;&lt;sigil&gt;}{$&lt;variable&gt;&lt;identifier&gt;})
    }
}

my $prog = q:to/END/;
my $x;
$x = 5;
say $x;# 5
my $y;
$y = $x;
say $y; # 5
my $z;
$z = $x + $y;
say $z; # 10
my $sum;
$sum = 10 + 12 + $x + $y + $z;
say $sum; # 42
END

G.parse($prog, :actions(A.new));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_14">12.7. 总结</h3>
<div class="paragraph">
<p>在本章中, 我们讨论了 grammar, 这是 Raku 领先的新功能。Grammar 允许为自己的特定领域的语言构建解析器, 并且已经内置在语言中, 因此不需要外部模块就可以开始使用。</p>
</div>
<div class="paragraph">
<p>使用 Raku 子集的编译器的例子, 我们创建了一个 grammar, 并查看了它的元素 - rule 和 token。后来我们用 action 对 grammar 进行了更新, 最后将 action 移到一个单独的类中, 使代码更易于维护、更干净。</p>
</div>
<div class="paragraph">
<p>在接下来的章节中, 我们将讨论 Raku 中的并发, 反应式和函数式编程。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_并发编程">13. 并发编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 是一种完全在二十一世纪创造的语言。它自带对一些基本概念的内置支持并不奇怪, 这使得创建支持并行和并发编程的应用程序变得很容易。</p>
</div>
<div class="paragraph">
<p>在本章中, 我们将介绍以下内容。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Junction</p>
</li>
<li>
<p>线程</p>
</li>
<li>
<p>Promise</p>
</li>
<li>
<p>Channel</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_junction">13.1. Junction</h3>
<div class="paragraph">
<p>Junction 是 Raku 可以并行工作的最简单的例子之一。在编写本书时的 Rakudo 版本中, 这个功能还没有完全实现。</p>
</div>
<div class="paragraph">
<p>Junction 是一个可以同时保留许多值的值。考察一下下面的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $j = 1 | 3 | 5;
say 'OK' if $j == 3;
say 'Not OK' if $j != 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>变量 <code>$j</code> 是一个 junction, 它持有三个奇数, <code>1</code>, <code>3</code> 和 <code>5</code>。你可以将 <code>$j</code> 与整数进行比较, 如果该值是 junction 所存储的值之一, 那么可以得到布尔值 <code>True</code>。在与 3 进行比较时, 结果是 <code>True</code>, 而与 <code>2</code> 进行的第二个比较则失败了。</p>
</div>
<div class="sect3">
<h4 id="_自动线程化">13.1.1. 自动线程化</h4>
<div class="paragraph">
<p>现在尝试将 junction 传递给一个接收标量的函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($x) {
    say $x;
    return $x;
}

say 'OK' if f(1 | 3 | 5) == 3;
say 'Not OK' if f(1 | 3 | 5) != 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个行为很容易理解 - 分别对 junction 的每个值执行该函数。然后, 该函数的返回值将用作 junction 的值。</p>
</div>
<div class="paragraph">
<p>前面的代码的工作原理与下面的代码相同, 其中函数接收单个标量值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'OK' if f(1) | f(3) | f(5) == 3;
say 'Not OK' if f(1) | f(3) | f(5) != 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>把 junction 操作移动到函数参数之外, 称作<strong>自动线程化</strong>。从理论上讲, 上一个例子中的代码可以并行执行。</p>
</div>
<div class="paragraph">
<p>现在, 让我们进入下一个主题, 看看如何显式地创建线程。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_线程">13.2. 线程</h3>
<div class="paragraph">
<p>在 Raku 中, 有一个 <code>Thread</code> 类, 它负责创建和运行线程。要查看你现在在哪个线程中, 请使用 <code>$*THREAD</code> 伪常量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $*THREAD;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它返回一个 <code>Thread</code> 类的值, 并且它的默认字符串化表示是一个包含标识符和线程名称的字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Thread #1 (Initial thread)</code></pre>
</div>
</div>
<div class="paragraph">
<p>不要依赖线程标识符的特定值, 因为即使是主线程, 标识符也可能不一样。</p>
</div>
<div class="sect3">
<h4 id="_开启线程">13.2.1. 开启线程</h4>
<div class="paragraph">
<p>在本节和下面的章节中, 我们将研究 <code>Thread</code> 类的方法。不过, 我们将从 <code>start</code> 方法开始, 它创建一个线程并开始执行。</p>
</div>
<div class="paragraph">
<p>在下面的例子中, 我们创建了三个线程。每个线程都接收一个名称和一个代码块。代码块在每个线程中做同样的工作, 并且只打印 <code>$*THREAD</code> 变量的值, 这个变量的值在不同的线程中是不同的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $*THREAD;

my $t1 = Thread.start(name =&gt; 'Test 1', sub {say $*THREAD});
my $t2 = Thread.start(name =&gt; 'Test 2', sub {say $*THREAD});
my $t3 = Thread.start(name =&gt; 'Test 3', sub {say $*THREAD});

say $t1.WHAT;
say $t2.WHAT;
say $t3.WHAT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行该程序, 看看它打印出了什么。你的输出可能与下面的片段不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Thread #1 (Initial thread)
Thread #4 (Test 1)
Thread #5 (Test 2)
(Thread)
Thread #6 (Test 3)
(Thread)
(Thread)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见, 程序从四个不同的线程中打印 - <strong>初始线程 <code>#1</code></strong> 和我们创建的三个线程。他们得到标识符 <code>3</code>、<code>4</code> 和 <code>5</code>。Rakudo 开发人员告诉我, <strong>线程 <code>#2</code></strong> 可能是在启动时被虚拟机使用的。同样, 这些数字的主要属性是唯一的, 但不一定按顺序排列。</p>
</div>
<div class="paragraph">
<p>另外注意, 不同线程的输出是重叠的。多运行这个程序几次, 很可能会得到不同的结果。</p>
</div>
<div class="paragraph">
<p>线程是在 <code>Thread.start</code> 被调用的那一刻创建的, 然后执行时又回到主线程。最简单的查看方法是在用作线程代码块的子例程中嵌入不同的延迟。</p>
</div>
<div class="paragraph">
<p>在下面的程序中, 创建了三个匿名(意思是不保存在变量中)的线程。它们的名字不同, 以及它们的延迟和在它们的主体中产生的输出也不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $*THREAD;

Thread.start(
    name =&gt; 'Sleep 3 seconds',
    sub {
        say $*THREAD;
        sleep 3;
        say 1;
    }
);

Thread.start(
    name =&gt; 'Sleep 2 seconds',
    sub {
        say $*THREAD;
        sleep 2;
        say 2;
    }
);

Thread.start(
    name =&gt; 'Sleep 1 second',
    sub {
        say $*THREAD;
        sleep 1;
        say 3;
    }
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它, 这就是你将在控制台中得到的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Thread #1 (Initial thread)
Thread #4 (Sleep 3 seconds)
Thread #5 (Sleep 2 seconds)
Thread #6 (Sleep 1 second)
3
2
1</code></pre>
</div>
</div>
<div class="paragraph">
<p>在程序启动后, 立即打印了前四行, 而其余的延迟打印 - 每个数字在延迟 1 秒后打印。所以, <code>Thread.start</code> 创建一个线程并退出, 而该线程与主程序（以及其他线程）并行地执行。</p>
</div>
<div class="paragraph">
<p>由于线程是并行工作的, 所以无法预测它们会以何种顺序产生副作用(例如打印到控制台)。看看这个程序, 它创建了两个线程, 每个线程打印五个数字。第一个线程打印从 1 到 5 的数字, 而第二个线程打印从 11 到 15 的数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Thread.start(sub {
    .say for 1..5;
});

Thread.start(sub {
    .say for 11..15;
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这两个线程都是并行执行的。实际的实现, 无论是将代码分布到处理器的不同核上, 还是通过为线程分配专用的时间原子来初始化线程, 语言规范中都没有定义, 所以在 Raku 中创建线程时, 不应该指望这两种实现。</p>
</div>
<div class="paragraph">
<p>将这个程序运行几次, 可以看到每次结果都是不一样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">1
11
12
2
3
13
4
5
14
15</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二个线程也可能比第一个线程先开始打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">11
1
2
12
13
3
14
15
4
5</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>Thread.start</code> 方法很容易, 但在某些情况下, 你可能希望对线程的创建和运行有更精细的控制。</p>
</div>
</div>
<div class="sect3">
<h4 id="_创建并运行新线程">13.2.2. 创建并运行新线程</h4>
<div class="paragraph">
<p>要创建一个线程对象, 请使用 <code>Thread</code> 类的构造函数。它以相应的命名参数 <code>name</code> 和 <code>code</code> 接收线程名称和代码块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t = Thread.new(
    name =&gt; 'My thread',
    code =&gt; sub {
        say 'Hi there!';
    }
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>该线程现在已经创建, 但没有激活。要运行它, 必须调用 <code>run</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$t.run();</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行下面的例子, 检查一下屏幕上出现的行的顺序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t = Thread.new(
    name =&gt; 'My thread',
    code =&gt; sub {
        say 'Start';
        sleep 2;
        say 'End';
    }
);

say 'Before';
$t.run();
say 'After';</code></pre>
</div>
</div>
<div class="paragraph">
<p>线程一运行, 它就会打印出 <code>Start</code> 和 <code>End</code> 这两条消息, 间隔 2 秒的延迟:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Before
After
Start
End</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以将主程序推迟到线程完成工作后再进行。使用 <code>finish</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Before';
$t.run();
$t.finish();
say 'After';</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序会等到线程代码块完成工作后, 才从下一条指令开始继续执行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Before
Start
End
After</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>finish</code> 方法有一个同义词 <code>join</code> - <code>$t.join()</code>, 它的作用与 <code>$t.finish()</code> 完全相同。</p>
</div>
</div>
<div class="sect3">
<h4 id="_id_和_name_方法">13.2.3. id 和 name 方法</h4>
<div class="paragraph">
<p>在《启动新线程》一节中, 我们已经看到了一些关于如何给新线程分配标识符的例子。在 <code>Thread</code> 类中, 有一个方法可以返回 <code>id</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $*THREAD;

my $t1 = Thread.start(sub {});
my $t2 = Thread.start(sub {});
my $t3 = Thread.start(sub {});

say $t1.id();
say $t2.id();
say $t3.id();</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序可能的输出之一是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">3
4
5</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想在主线程中保留一些跟踪信息, 比如说, 可以使用线程标识符。</p>
</div>
<div class="paragraph">
<p>另一种识别线程的方法是使用名称。名称是你在创建线程时通过 <code>name</code> 参数给线程分配的字符串标签:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t1 = Thread.start(name =&gt; 'My thread one', sub {});
my $t2 = Thread.start(name =&gt; 'My thread two', sub {});
my $t3 = Thread.start(name =&gt; 'My thread three', sub {});

say $*THREAD.name();
say $t1.name();
say $t2.name();
say $t3.name();</code></pre>
</div>
</div>
<div class="paragraph">
<p>主线程的名称是 <code>Initial thread</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Initial thread
My thread one
My thread two
My thread three</code></pre>
</div>
</div>
<div class="paragraph">
<p>名称不需要是唯一的, 所以你可以自由选择任何你想要的任何名称。</p>
</div>
</div>
<div class="sect3">
<h4 id="_将线程对象打印为字符串">13.2.4. 将线程对象打印为字符串</h4>
<div class="paragraph">
<p><code>Thread</code> 类的 <code>Str</code> 方法通过 <code>say</code> 函数定义了当线程对象被打印时的行为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t1 = Thread.start(name =&gt; 'My thread one', sub {});
my $t2 = Thread.start(name =&gt; 'My thread two', sub {});
my $t3 = Thread.start(name =&gt; 'My thread three', sub {});

say $*THREAD;
say $t1;
say $t2;
say $t3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认字符串包含线程的编号及其名称(如果定义了的话)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Thread #1 (Initial thread)
Thread #3 (My thread one)
Thread #4 (My thread two)
Thread #5 (My thread three)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中, 所有的线程都有不同的 ID(它们总是不同的)和不同的名称(这是由程序员定义的)。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_终身线程">13.3. 终身线程</h3>
<div class="paragraph">
<p>在创建一个新线程时, 可以设置 <code>app_lifetime</code> 属性, 要求该线程活到主程序结束。否则, 它会在其主体执行完后被终止。要添加这个标志, 可以将其添加为 <code>:app_lifetime</code> 或者通过显式传递 <code>True</code> 值给构造函数-<code>app_lifetime &#8658; True</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Thread.new(
    name =&gt; 'Long thread',
    code =&gt; sub {
        say 'OK';
    },
    :app_lifetime,
).run().join();

say 'Done';</code></pre>
</div>
</div>
<div class="paragraph">
<p>重要的是等待线程(使用 <code>finish</code> 或 <code>join</code> 方法)。否则, 主线程可能会在该线程返回之前停止执行。</p>
</div>
<div class="sect3">
<h4 id="_在_raku_中使用锁">13.3.1. 在 Raku 中使用锁</h4>
<div class="paragraph">
<p>Raku 提供了一种机制, 确保代码的特定部分只由单个线程执行。如果有其他线程想从这段代码中访问变量, 应该等到它被解锁后再执行。</p>
</div>
<div class="paragraph">
<p>要封存关键代码, 请使用 <code>Lock</code> 类的 <code>protect</code> 方法。请看下面这个 Raku 文档中的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 0;
my $l = Lock.new;
await (^10).map: {
    start {
        $l.protect({ $x++ });
    }
}
say $x; # OUTPUT: «10␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将在本章后面的工厂方法一节中讲到 <code>await</code> 函数。</p>
</div>
<div class="paragraph">
<p>关键代码的保护方式是, 每次只能有一个线程访问 <code>$x</code> 计数器。</p>
</div>
<div class="paragraph">
<p>不建议直接使用锁, 因为它们提供了太低级的接口。 相反, 使用 Promise、Channel 和 Supply。我们会在本章后面讨论前两个概念, 而 Supply 将在第十五章的《反应式编程》中讨论。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_promise">13.4. Promise</h3>
<div class="paragraph">
<p>在上一节中, 我们创建了一些并行运行的代码块。 <code>Promise</code> 有助于查看这些代码块的完成状态。在 Raku 中, 承诺是由 <code>Promise</code> 类处理的。</p>
</div>
<div class="sect3">
<h4 id="_创造一个承诺">13.4.1. 创造一个承诺</h4>
<div class="paragraph">
<p>要创建一个承诺, 只需调用 <code>Promise</code> 类的构造函数即可:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.new();</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建好的对象什么也还没有做。在本章后面的工厂方法一节中, 我们将看到如何创建一个执行一些代码的承诺。同时, 让我们看看承诺所拥有的属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_承诺的状态">13.4.2. 承诺的状态</h4>
<div class="paragraph">
<p>承诺的力量在于, 它们既可以被遵守, 也可以或破坏, 你可以跟踪他们。通过调用 <code>Promise.new</code> 创建的新承诺, 既不会被遵守也不会被破坏。它的状态是 <code>Planned</code>。要查看状态, 请调用 <code>status</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.new();
say $promise.status(); # Planned</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Promise</code> 类还为我们提供了一对方法, <code>keep</code> 和 <code>break</code>, 可以把承诺的状态更改为 <code>Kept</code> 或 <code>Broken</code>。这在下面的例子中得到了证明, 其中一个承诺被标记为 <strong>Kept</strong>, 而第二个承诺被强制为 <strong>Broken</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise1 = Promise.new();
my $promise2 = Promise.new();

$promise1.keep();
$promise2.break();

say $promise1.status();
say $promise2.status();</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Kept
Broken</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 在我们知道如何改变承诺的状态以及如何读取状态之后, 我们要用承诺来并行地执行代码。</p>
</div>
</div>
<div class="sect3">
<h4 id="_工厂方法">13.4.3. 工厂方法</h4>
<div class="paragraph">
<p>让我们从一个简单的程序开始, 用一个代码块创建一个承诺，打印出一些东西并退出。<code>Promise.start</code> 方法创建了一个代码块并返回一个承诺。 注意, 返回的值是一个承诺, 而不是一个线程。使用 <code>await</code> 函数等待直到该承诺的代码块完成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.start({
    say 'I am a promise';
});
await $promise;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序会等待, 直到代码块打印出消息,然后退出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">I am a promise</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的例子中, <code>start</code> 例程作为 <code>Promise</code> 类的一个方法被调用。 另外, 也可以通过一个独立的 <code>start</code> 函数来创建承诺:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = start {
    say 'I am a promise';
};
await $promise;</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, 代码块周围没有圆括号。</p>
</div>
<div class="paragraph">
<p>让我们修改一下前面的例子, 创建一个只是休眠一秒钟的承诺。承诺被创建后, 首次立即打印其状态。这里的一秒延迟是很重要的, 以确保在我们在下一行检查承诺的状态之前, 承诺没有完成它的工作。</p>
</div>
<div class="paragraph">
<p>然后, <code>await</code> 等待, 直到承诺的代码完成后, 第二次检查承诺的状态:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.start({
    sleep 1;
});

say $promise.status;
await $promise;
say $promise.status;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是程序打印的内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Planned
Kept</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于时间的处理, 有另一个工厂方法, <code>Promise.in</code>, 可以用它来代替 <code>start</code> 和 <code>sleep</code> 的组合。它创建了一个承诺, 在给定的秒数之后, 这个承诺的状态就变为保留:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.in(2);
await $promise;
say 'Done';
say $promise.status; # Kept</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序创建并等待一个承诺。2 秒后, 承诺状态变为保留, 程序继续运行。之后, 承诺的状态就会变成 <code>Kept</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_承诺的结果">13.4.4. 承诺的结果</h4>
<div class="paragraph">
<p>承诺的另一个有趣的特性是, 它们可以返回一个结果。这个结果是由代码块计算出来的, 最后计算出来的值就是返回的结果。考虑一下下面的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.start({
    sleep 1;
    'Result'; # no return keyword!
});

await $promise;
say $promise.result;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里, 代码块返回一个字符串, 即 <code>Result</code>, 然后在 <code>$promise</code> 变量上调用 <code>result</code> 打印出承诺的结果。</p>
</div>
<div class="paragraph">
<p>从逻辑上讲, 只有在承诺被遵守后, 结果才是可用的。在前面的例子中, 使用了显式的 <code>await</code>。实际上, 这是多余的, 因为 <code>result</code> 方法要等到代码完成后再调用。因此, 代码可以简化成下面这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.start({
    sleep 1;
    'Result';
});

say $promise.result; # waits</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_组合承诺">13.4.5. 组合承诺</h4>
<div class="paragraph">
<p>在实际的程序中, 可以使用不止一个承诺。将不同的承诺组合在一起, 可以给出非常有表现力的方式来编码不同部分代码之间的复杂关系。</p>
</div>
<div class="paragraph">
<p>让我们从一个简单的例子开始, 使用独立的 <code>start</code> 函数创建三个承诺:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Start';
await
    start {sleep 2; say 2;},
    start {sleep 3; say 3;},
    start {sleep 1; say 1;};
say 'Done';</code></pre>
</div>
</div>
<div class="paragraph">
<p>目标是暂停程序, 直到所有的承诺都被遵守。从这个例子中可以看到, <code>await</code> 函数接受一个承诺列表, 然后等待, 直到所有的承诺都完成。程序的输出看起来是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Start
1
2
3
Done</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个承诺都会创建一个单独的线程, 通过打印 <code>$*THREAD</code> 变量可以清楚地看到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">await
    start {say $*THREAD;},
    start {say $*THREAD;},
    start {say $*THREAD;};</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个 <code>start</code> 都创建了它自己的线程:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Thread #3
Thread #5
Thread #4</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_承诺被遵守或被破坏后执行代码">13.4.6. 承诺被遵守或被破坏后执行代码</h4>
<div class="paragraph">
<p><code>Promise</code> 类有 <code>then</code> 方法, 可以用来绑定承诺被遵守或被破坏后要执行的代码。实际上, 这种方法会创建并返回一个新的承诺, 在初始承诺状态改变后, 这个新的承诺会被运行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.in(1);
my $next = $promise.then({
    say 'Done';
});
await $next;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序在启动 1 秒后打印出 <code>Done</code>。第一个承诺, 保存在 <code>$promise</code> 变量中, 在给定的时间延迟后状态变为保留。然后, <code>then</code> 创建另一个承诺, 它保存在 <code>$next</code> 变量中。要加入到主程序中, 需要等待 <code>$next</code> 打印输出, 这样就完成了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_anyof_和_allof_方法">13.4.7. anyof 和 allof 方法</h4>
<div class="paragraph">
<p><code>Promise</code> 类中的两个方法, <code>anyof</code> 和 <code>allof</code>, 在任何一个承诺被遵守或全部被遵守时, 都会创建一个新的承诺。这两个方法接受一个承诺列表。</p>
</div>
<div class="paragraph">
<p>让我们用下面的例子来说明一下 <code>anyof</code> 方法的工作, 该方法是检查长期运行的代码是否执行时间过长:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $timeout = Promise.in(2).then({
       say 'Timeout'
});
my $long_code = start {
    sleep 3;
    say 'Work done';
};

await Promise.anyof($timeout, $long_code);
say 'Continuing';</code></pre>
</div>
</div>
<div class="paragraph">
<p>这创造了两个承诺。<code>$timeout</code> 这个在创建承诺 2 秒后被遵守。<code>$long_code</code> 模仿慢的那部分代码, 执行时间比计时器能等待的时间更长。然后, 这两个承诺会被传递给 <code>Promise.anyof</code> 方法, 该方法会返回另一个承诺, 在发生超时或执行长时间运行的代码时, 这个承诺会被遵守。</p>
</div>
<div class="paragraph">
<p>用不同的延迟组合运行这个程序, 看看这个程序的不同结果。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_channel">13.5. Channel</h3>
<div class="paragraph">
<p><code>Channel</code> 是一种通信手段，可以用来将数据从一段代码传递给另一段代码。Channel 的好处在于它是线程兼容的，因此不同的线程之间可以相互对话。在本节中，我们将学习如何在 Raku 中使用 Channel。</p>
</div>
<div class="sect3">
<h4 id="_基本用例">13.5.1. 基本用例</h4>
<div class="paragraph">
<p>Channel 是由 <code>Channel</code> 类定义的。要创建新的通道变量, 请调用构造函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们可以用 <code>send</code> 方法向通道发送数据, 用 <code>receive</code> 方法接收数据:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new;
$channel.send(42);

my $value = $channel.receive();
say $value;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序做了一件小事 - 它把值发送到通道中, 并立即读取它。该程序打印出了通过通道的值 <code>42</code>。</p>
</div>
<div class="paragraph">
<p>现在, 让我们修改一下程序, 在程序中引入第二个线程, 这样, 通道被填充到这个线程中, 结果在主程序中读取:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new();
start {
    $channel.send(42);
};

my $value = $channel.receive;
say $value;</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行的结果和以前一样, 打印出了 42, 而传递值的逻辑完全不同。</p>
</div>
<div class="paragraph">
<p><code>receive</code> 方法一直等待, 直到通道有足够的数据可以读取。如果我们给线程代码添加一个延迟, 那么程序将暂停, 直到线程向通道发送数据:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new();
start {
    sleep 1;
    $channel.send(42);
};

my $value = $channel.receive;
say $value;</code></pre>
</div>
</div>
<div class="paragraph">
<p>上两个例子的唯一区别在于调用 <code>$channel.send</code> 方法之前的延迟。</p>
</div>
</div>
<div class="sect3">
<h4 id="_等还是不等">13.5.2. 等还是不等?</h4>
<div class="paragraph">
<p>我们在上一节中已经看到, 如果通道中没有数据, 那么 <code>Channel</code> 类的 <code>receive</code> 方法就会停滞。</p>
</div>
<div class="paragraph">
<p><code>poll</code> 方法也从通道中读取数据, 但不会阻塞程序的执行。如果没有任何数据可读取, 那么它就会立即返回一个空值。让我们再修改下上一个例子, 从通道中读取 5 次, <code>poll</code> 调用之间有 1 秒的延迟:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new();

start {
    sleep 3;
    $channel.send(42);
};

for 1..5 {
    my $value = $channel.poll;
    say $value;
    sleep 1;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序打印出以下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(Any)
(Any)
(Any)
42
(Any)</code></pre>
</div>
</div>
<div class="paragraph">
<p>前三次尝试无法获得任何值, 因为之前有一个 3 秒的延迟, 所以没有任何值被发送到 <code>$channel</code>。在第四次迭代时, 值是可用的, 可以被读取。在被读取之后, 该值被从通道中删除, 因此下一次的 <code>poll</code> 调用再次返回一个空值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_关闭通道">13.5.3. 关闭通道</h4>
<div class="paragraph">
<p><code>close</code> 方法关闭一个通道。这意味着不会再向它添加任何数据。要检查通道是否关闭, 请调用 <code>close</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new();
say 'Open' unless $channel.closed(); # Open

$channel.close();
say 'Closed' if $channel.closed();   # Closed</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>close</code> 方法的返回值不是布尔值。相反, 该方法返回一个承诺, 在通道关闭后, 这个承诺会被遵守:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new();
say $channel.closed().status(); # Planned

$channel.close();
say $channel.closed().status(); # Kept</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如, 可以使用承诺来运行一些响应于关闭通道的代码, 如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new();

my $promise = $channel.closed();
$promise.then({
    say 'Channel is closed';
});

say 'Before calling close()';
$channel.close();
say 'After calling close()';</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行这个程序的输出可能是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Before calling close()
After calling close()
Channel is closed</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为承诺是在一个单独的线程中执行的, 所以可能会不可预知地以不同的顺序打印行。如果我们在主线程中打印字符串之前添加一个小的延迟, 就可以看到这一点了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Before calling close()';
$channel.close();
sleep 1;
say 'After calling close()';</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下, <code>$promise</code> 的代码将在第二个 <code>say</code> 指令之前完成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Before calling close()
Channel is closed
After calling close()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_通道作为队列">13.5.4. 通道作为队列</h4>
<div class="paragraph">
<p>当多个值被送入通道时, 它们实际上成为队列。所以第一个添加到通道中的值将是从通道中接收到的第一个值。</p>
</div>
<div class="paragraph">
<p>由于通道是线程安全的, 所以没有人限制我们要向通道写入或从通道中读取的线程数量。下面的例子演示了通道是如何在几个线程之间共享的。</p>
</div>
<div class="paragraph">
<p>该程序打印出从 0 到 10 的数字的平方。这些数字首先被发送到通道中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new();
$channel.send($_) for 0..10;
$channel.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>发送完所有数字之后, 通道就关闭了。在下一阶段, 通过调用 <code>start</code> 函数创建三个线程(别忘了, 这个函数通过创建一个承诺间接创建一个线程)。在每个线程中, 无限循环尝试从同一个通道中接收值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @readers;
for 1..3 {
    push @readers, start {
        while 1 {
            my $value = $channel.poll;
            last if $value === Any;
            say "$value2 = " ~ $value * $value;
        }
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里使用的是非阻塞的 <code>poll</code> 方法, 从通道读取值。如果队列被消费掉, 返回的值为空, 则循环被打破, 线程完成。</p>
</div>
<div class="paragraph">
<p>在退出主程序之前, 我们必须等待所有的承诺都被遵守:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">await @readers;</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个线程都会计算出它能从通道中读取的值的平方:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">0² = 0
2² = 4
1² = 1
3² = 9
5² = 25
4² = 16
6² = 36
7² = 49
8² = 64
10² = 100
9² = 81</code></pre>
</div>
</div>
<div class="paragraph">
<p>将程序程序几次, 看看它产生的输出值是否不同。当然, 每次运行时计算出的数值都是一样的, 但输出行的顺序可能会有所不同。该通道以和我们将数字发送给它的相同的顺序返回数字。线程是并发的, 所以有些线程会先于其他线程打印出结果，并选取下一个值。 尽管线程的工作顺序不同, 但该通道只打印出数字一次。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_15">13.6. 总结</h3>
<div class="paragraph">
<p>在这一章中, 我们简要地讨论了 junction 的并行性, 其余的时间我们深入研究了线程、承诺和通道 - Raku 中实现并行和并发特性的机制。使用它们对于开发人员是相当容易的, 并且不需要手动操作底层机制来确保线程执行时不会发生冲突。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_函数式编程">14. 函数式编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 是一种多范式编程语言。在前几章中, 我们主要使用了传统的命令式编程。在这一章中, 我们将讨论 Raku 的函数式编程风格。</p>
</div>
<div class="paragraph">
<p>本章将介绍这些主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>函数式编程原理</p>
</li>
<li>
<p>使用递归重写传统程序</p>
</li>
<li>
<p>化简操作</p>
</li>
<li>
<p>高阶函数, lambda 和 whatever 代码块</p>
</li>
<li>
<p>使用 Feed 运算符管道输送数据</p>
</li>
<li>
<p>闭包、柯里化和动态作用域</p>
</li>
<li>
<p>惰性列表和无限列表以及序列生成器</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在详细介绍之前, 我们先谈谈什么是函数式编程。</p>
</div>
<div class="sect2">
<h3 id="_什么是函数式编程">14.1. 什么是函数式编程</h3>
<div class="paragraph">
<p>函数式编程是使用一系列函数进行计算的方式。这里所说的函数是指从数学意义上的函数, 而不是 Raku 中的子例程。函数式编程的一个非常重要的原则是, 函数必须没有副作用。特别是, 这意味着变量必须是不可变的 - 禁止指定一个新的值。</p>
</div>
<div class="paragraph">
<p>本章中我们将讨论的所有主题都是前面的限制的结果。重要的是要认识到, 比如说, lambda 函数并不是函数式编程的核心本质, 它只是遵循无副作用这一主要原则的方式之一, 比如说改变一些影响函数结果的全局变量。</p>
</div>
<div class="paragraph">
<p>让我们取一个函数 <code>f($x)</code>, 用同样的参数调用它两次。第二次调用会不会和第一次调用的结果相同一样呢? 在函数式编程中, 要求一个函数如果用相同的参数调用, 总是返回相同的结果。</p>
</div>
<div class="paragraph">
<p>下面是这样一个函数的例子, 返回 <code>$x + 1</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($x) {
    return $x + 1;
}

say f(5); # 6
say f(5); # 6

say f(5) == f(5); # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>两个调用都返回相同的结果。同时, 比较 <code>f(5) == f(5)</code> 结果为 <code>True</code>。这个程序可能已经被认为是用函数式风格编写的程序。</p>
</div>
<div class="paragraph">
<p>引入一个变量并不违背原则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($x) {
    return $x + 1;
}

my $a = 5;

say f($a); # 6
say f($a); # 6

say f($a) == f($a); # True</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$a</code> 变量在初始化期间只获得一次值。之后就再也不会改变。</p>
</div>
<div class="paragraph">
<p>现在, 让我们修改函数的参数(你需要使用 <code>is rw</code> trait):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($x is rw) {
    $x += 1;
    return $x;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一次调用具有相同原始值 <code>$a</code> 的函数将返回与以前相同的结果。虽然在函数调用后, <code>$a</code> 的值发生了变化, 第二次调用 <code>f($a)</code> 无法返回相同的结果。 条件 <code>f($a) == f($a)</code> 已经不再是 True 了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 5;

say f($a); # 6
say f($a); # 7

say f($a) == f($a); # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, 函数产生了一个修改参数的副作用, 这是由于它被声明为可读可写的参数, 改变了主代码中变量的值。</p>
</div>
<div class="paragraph">
<p>另一种产生副作用的方法是在函数内部使用全局变量。考察下面这个函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $step = 0;

sub f($x) {
    $step++;
    return $x + $step;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在函数的参数没有变化, 但是函数被调用两次后, 返回的结果不一样。</p>
</div>
<div class="paragraph">
<p>现在, 仔细看一下 <code>f</code> 函数的三个变体。在第一个变体中, 函数的主体没有涉及到赋值。在第二个和第三个例子中, 函数参数或全局变量被重新赋值了。虽然没有显式地使用 <code>=</code> 运算符, 但 <code>$x += 1</code> 和 <code>$step++</code> 结构相当于下面的赋值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$x = $x + 1;
$step = $step + 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下, 这就是打破 <code>f($a) == f($a)</code> 条件的根源。</p>
</div>
<div class="paragraph">
<p>函数本身不一定会改变一个全局值。在函数的两次调用之间, 全局值可以被其他代码修改:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $step = 1;

sub f($x) {
    return $x + $step;
}

say f(5); # 6
$step = 2;
say f(5); # 7</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然函数似乎是可预测的, 但它的工作环境影响着它的工作。从某种意义上说, 变量重新赋值在程序中引入了时间的概念。在不同时间里, 同样的调用 <code>f(5)</code> 会返回不同的结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t1 = f(5);
$step = 2;
my $t2 = f(5);

say $t1 == $t2; # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 并不禁止设置变量的新值, 但在用函数式编程风格编写程序时, 应该只对变量进行一次初始化, 并应避免任何新的赋值。在下一节中, 你将看到如何修改传的统程序, 以遵循函数式编程的原则。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用递归">14.2. 使用递归</h3>
<div class="paragraph">
<p>本章中我们的下一个程序是一个简单的循环, 可以打印从 10 到 15 的数字并计算出他们的总和。我们先打印一下数字。正如我们在第 5 章《控制流》中看到的那样, 在 Raku 中, 有不同的循环方式。在它们之间进行选择, 可以把我们已经引导到函数式编程的方向上了。</p>
</div>
<div class="paragraph">
<p><code>loop</code> 循环需要一个 <code>loop</code> 计数器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum = 0;
loop (my $n = 10; $n &lt;= 15; $n++) {
    $sum += $n;
}
say $sum; # 75</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个程序中, 有两个变量会改变它们的值 - <code>$n</code> 和 <code>$sum</code>。很容易摆脱 <code>$n</code> 计数器, 从而给它重新分配一个值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum = 0;
for 10..15 {
    $sum += $_;
}
say $sum;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 我们使用 <code>$_</code> 变量代替 <code>$n</code>, 实际上 <code>for</code> 循环可以使用显式循环变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum = 0;
for 10..15 -&gt; $n {
    $sum += $n;
}
say $sum;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码和带 <code>loop</code> 的程序的区别在于, 现在变量 <code>$n</code> 只存在于一次循环迭代中。它在进入循环主体之前被赋值, 在循环运行后被撤回。在第一个例子中, 它在每一次迭代中都在递增。</p>
</div>
<div class="paragraph">
<p>其中一项赋值消失了。那么我们如何避免修改 <code>$sum</code> 变量呢? 由于它的性质, 它看起来是不可避免的-它应该在循环数字的同时累积总和。答案是 - 使用递归。递归给我们提供了和我们刚才看到的 <code>$n</code> 变量一样的技巧。与其使用一个单一的全局 <code>$sum</code> 变量来保存程序的状态, 不如在每次改变总和的时候创建一个新的变量。更有甚者, 还可以完全去掉那个变量, 如下面的例子所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub sum($min, $max) {
    if ($min == $max - 1) {
        return $min + $max;
    }
    else {
        return $min + sum($min + 1, $max);
    }
}

say sum(10, 15); # 75</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们仔细看一下这个程序。首先, 这里没有保存状态的变量 - 没有循环计数器 <code>$n</code>, 也没有保存中间结果的 <code>$sum</code> 变量。我们不创建一个关于如何计算和的指令-从这个数字开始, 而是假设这是一个和；递增这个数字, 把它加到之前的和上；我们描述一下和的实际含义-和就是当前的数字加上之前所有数字的总和。</p>
</div>
<div class="paragraph">
<p><code>sum</code> 函数调用自身, 每次调用的参数都不一样。当然, 在某个时候停止递归是很重要的, 这就是为什么有测试 <code>$min == $max - 1</code>, 当值是我们想要相加的最后两个值时, 它就变成了 True。这个程序已经是一个函数式的程序了：它对和的定义进行了编码, 它不保留状态, 它使用函数来实现目标。</p>
</div>
<div class="paragraph">
<p>最后, 让我们使用一些 Raku 的语法元素, 使程序更加紧凑:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub sum($min, $max) {
    return $min == $max - 1
        ?? $min + $max
        !! $min + sum($min + 1, $max);
}

say sum(10, 15);</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外, 这里不需要 <code>return</code> 关键字, 因为 Raku 会取函数中的最后一个计算值。最后一个分号也可以省略:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub sum($min, $max) {
    $min == $max - 1
        ?? $min + $max
        !! $min + sum($min + 1, $max)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个转换是将相似的部分从两个表达式中移出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub sum($min, $max) {
    $min + ($min == $max - 1 ?? $max !! sum($min + 1, $max))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们就此打住, 看看 Raku 还能给我们带来哪些令人着迷的选择。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用化简">14.3. 使用化简</h3>
<div class="paragraph">
<p>在上一节中, 我们计算了 10 到 15 之间的数字之和。这个程序, 经过一些变换, 就变成了下面这个程序的等价物:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 + (11 + (12 + (13 + (14 + 15))));</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的每一对括号对应于 <code>sum</code> 函数的递归调用。函数的调用在这里用它的实现来代替。这也是无状态方法限制的后果之一。如果函数依赖于程序的状态, 那么在不知道反射不同时刻的状态值的情况下, 就不可能用函数调用替换成它的实现。</p>
</div>
<div class="paragraph">
<p>因为这里的括号不会改变任何执行顺序, 所以我们把它们去掉:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 + 11 + 12 + 13 + 14 + 15;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们在这里看到的是一个由 <code>+</code> 运算符分隔的 10 到 15 之间的所有值的列表。我们已经在第四章《使用运算符》中的化简元运算符一节中见过了。整个结构可以用下面这个简单的代码来代替:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [+] 10..15;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也是一个函数式风格的程序。比较一下它和前文中的一个例子的大小。</p>
</div>
<div class="paragraph">
<p>化简运算符 <code>[+]</code> 在任意数组中也能完美地工作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 10, 11, 100, 101, 1000, 1001;
say [+] @a; # 2223</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 我们已经接近了函数式编程中的另一个重要概念-高阶函数。</p>
</div>
</div>
<div class="sect2">
<h3 id="_高阶函数和_lambda">14.4. 高阶函数和 lambda</h3>
<div class="paragraph">
<p>刚才我们在上一节中看到的 <code>[+]</code> 化简运算符就是根据需要执行 <code>+</code> 运算符的动作, 将提供的数据中的所有元素加相加。</p>
</div>
<div class="paragraph">
<p>在 Raku 中, 有另外一种进行化简操作的方法。有一个内置的函数 <code>reduce</code>, 期望有一个代码块来执行这个操作。首先, 我们将使用我们在第二章《编写代码》中所创建的函数 <code>add($a, $b)</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add($a, $b) {
    return $a + $b;
}

say reduce &amp;add, 10..15;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>reduce</code> 函数将函数的引用作为第一个参数, 并展平值的列表。在 <code>&amp;add</code> 中, 函数名称前面的 <code>&amp;</code> 符号告诉 Raku 这不是函数调用, 而是对函数的代码引用。</p>
</div>
<div class="paragraph">
<p><code>reduce</code> 函数是高阶函数的一个例子。它的一个参数是另一个函数。在 Raku 中, 函数是一等对象, 这意味着可以像常规变量一样, 将其作为参数传递给其他函数, 就像你用常规变量一样简单。从高阶函数中调用的函数有时也称为回调函数。</p>
</div>
<div class="paragraph">
<p>由于 <code>add</code> 函数只在 <code>reduce</code> 函数中使用, 所以可以内联, 直接在需要它的地方创建它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say reduce sub add($a, $b) {return $a + $b}, 10..15;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在很明显的是, <code>add</code> 的名称没有添加任何值, 可以省略, 从而使该函数成为匿名函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say reduce sub ($a, $b) {return $a + $b}, 10..15;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下, 匿名函数也被称为 lambda 函数。它具有普通子例程的所有属性, 只是它既没有名字, 也不能从程序中的其它地方调用。整个函数的定义是内联的。</p>
</div>
<div class="paragraph">
<p>现在让我们看看 Raku 如何在语法上帮助简化创建 lambda。 首先, <code>sub</code> 块可以用尖号块来代替:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say reduce -&gt; $a, $b {$a + $b}, 10..15;</code></pre>
</div>
</div>
<div class="paragraph">
<p>匿名函数的参数列在 <code>&#8594;</code> 箭头之后列出, 你不需要用括号括起来。另外要注意的是, 使用尖号块时, 不能使用 <code>return</code> 关键字(编译器会产生一个错误: Attempt to return outside of any Routine)。实际上, 根本不需要 <code>return</code>, 因为函数要做的就是计算一个表达式, 其结果就是函数的结果。</p>
</div>
<div class="paragraph">
<p>此外, 即使是参数也不是这种函数的必要元素。它们可以用花括号内的占位符变量来代替(参见第六章《子例程》中的参数占位符一节):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say reduce {$^a + $^b}, 10..15;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中, 有更多的内置函数可以作为高阶函数。这些函数有 <code>map</code>、<code>grep</code> 和 <code>sort</code>。它们中的每个函数都可以接收一个可选的代码块或对现有函数的引用作为第一个参数。让我们来看几个例子。</p>
</div>
<div class="paragraph">
<p><code>map</code> 函数为序列中的每个元素发起一个回调。其结果是一个新的列表, 其中包含了使用回调函数的代码对每个元素的单独映射:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say map {.uc}, 'a'..'d'; # (A B C D)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>grep</code> 函数也为每个元素调用它的回调, 但只复制那些回调函数返回 <code>True</code> 值的元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say grep {$_ &gt; 10}, 1..15; # (11 12 13 14 15)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两个例子中, 都使用了 $_ 变量: 对于 <code>map</code>, 它是隐式的, 因为为 <code>.uc</code> 是 <code>$_.uc</code> 的快捷方式。</p>
</div>
<div class="paragraph">
<p>对于 <code>sort</code> 函数, 就有点复杂了, 因为回调函数需要两个参数。最简单的方法是使用占位符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say sort {$^b &lt;=&gt; $^a}, 10..15; # (15 14 13 12 11 10)</code></pre>
</div>
</div>
<div class="paragraph">
<p>该代码块允许将数字按相反的顺序进行排序。</p>
</div>
<div class="sect3">
<h4 id="_whatevercode_块">14.4.1. WhateverCode 块</h4>
<div class="paragraph">
<p>现在, 既然我们已经使用了 <code>sort</code>, <code>grep</code>, <code>map</code> 和 <code>reduce</code> 等代码块, 那么现在是时候使用 Raku 中所谓的 <code>WhateverCode</code> 类型了。它涉及到了(<code>*</code>)星号并创建一个代码块, 可以和我们之前使用的任何代码块一样使用。</p>
</div>
<div class="paragraph">
<p>例如, 您可以编写 <code>*.uc</code> 代替 <code>{.uc}</code>。下面的两行代码是等价的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say map {.uc}, 'a'..'d'; # (A B C D)
say map *.uc, 'a'..'d';  # (A B C D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>同理, 这就是 <code>WhateverCode</code> 块可以用来替换 <code>grep</code> 和 <code>sort</code> 示例中的匿名代码的方式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say grep * &gt; 10, 1..15; # (11 12 13 14 15)

say sort * &lt;=&gt; *, &lt;11 12 10 13 15 14&gt;; # (10 11 12 13 14 15)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第二个例子中, 有两个星号, 分别对应于前面使用的 <code>$^a</code> 和 <code>$^b</code> 占位符参数。使用 <code>*</code> 时, 不需要用花括号来创建一个块。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_管道数据和_feed_运算符">14.5. 管道数据和 feed 运算符</h3>
<div class="paragraph">
<p><code>grep</code>, <code>map</code>, <code>reduce</code> 和 <code>sort</code> 函数是如此的强大和简单易用, 以至于(和其他类似的用户定义的高阶函数一起), 它们可以在传统的命令式编程中通过循环来组织的领域中处理许多实际任务。</p>
</div>
<div class="paragraph">
<p>通常情况下, 你需要在另一个函数返回的结果上调用其中的一个函数。考虑一个例子, 用街道上的房屋列表来举例。其中有些房子需要粉刷, 但你只需要选择那些在街道的偶数一侧的房子, 这些房子的外墙是红色的, 是五年前装修过的。这个任务就是要知道自己需要多少油漆。</p>
</div>
<div class="paragraph">
<p>让我们假设房子的属性信息都包含在这样的数据结构中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @street = (
       {
           number          =&gt; 1,
           renovation_year =&gt; 2000,
           storeys         =&gt; 4,
           colour          =&gt; 'green',
           width           =&gt; 20,
       },
       {
           number          =&gt; 2,
           renovation_year =&gt; 2014,
           storeys         =&gt; 6,
           colour          =&gt; 'red',
           width           =&gt; 10,
       },

       # . . .
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>很明显, 应该创建某种过滤器。要么它应该检查每一栋房子, 并决定它是否通过了所有的条件, 要么它可以一步一步地筛选出符合条件的房子。比如说, 让我们从所选取的双数边的房子开始:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @houses-to-paint = grep {$_&lt;number&gt; %% 2}, @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>grep</code> 函数逐一接收 <code>@street</code> 数组中的所有元素。在每次迭代中, 元素可以通过 $_ 主题变量访问。只有那些在计算 <code>$_&lt;number&gt; %% 2</code> 条件后返回非零结果的元素才会被传递给 <code>@houses-to-paint</code> 数组。</p>
</div>
<div class="paragraph">
<p>同样, 可以添加基于颜色和装修年份的过滤:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @houses-to-paint =
    grep {$_&lt;renovation-year&gt; &lt; 2012},
    grep {$_&lt;colour&gt; eq 'red'},
    grep {$_&lt;number&gt; %% 2},
    @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不要被第一个 <code>grep</code> 中的巧合对 <code>&gt; &lt;</code> 所迷惑。每个角括号都有自己的功能, 编译器完全可以理解。</p>
</div>
<div class="paragraph">
<p>最后, 我们需要计算出表面积, 以了解需要多少油漆。假设每平方米需要 0.7 升油漆, 每层楼高 3 米:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $paint-volume = 0.7 * [+] map {$_&lt;width&gt; * $_&lt;storeys&gt; * 3}, @houses-to-paint;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里用 <code>map</code> 函数来换算房子的表面积。用 <code>[+]</code> 化简运算符将所有的值相加, 得到总的结果。</p>
</div>
<div class="paragraph">
<p>现在我们可以把所有的代码合并到一条语句中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say
    0.7 *
    [+]
        map  {$_&lt;width&gt; * $_&lt;storeys&gt; * 3},
        grep {$_&lt;renovation-year&gt; &lt; 2013},
        grep {$_&lt;colour&gt; eq 'red'},
        grep {$_&lt;number&gt; %% 2},
    @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以在这里提出自己的缩进方式。</p>
</div>
<div class="paragraph">
<p>如果房子是用对象来存储, 而不是用散列来存储, 那就更好了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class House {
    has $.number;
    has $.renovation-year;
    has $.storeys;
    has $.colour;
    has $.width;
    method area {
        return $!width * $!storeys;
    }
}

my @street = (
    House.new(
           number          =&gt; 1,
           renovation_year =&gt; 2000,
           storeys         =&gt; 4,
           colour          =&gt; 'green',
           width           =&gt; 20),
    House.new(
           number          =&gt; 2,
           renovation_year =&gt; 2014,
           storeys         =&gt; 6,
           colour          =&gt; 'red',
           width           =&gt; 10),

       # . . .
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下, <code>map</code> 和 <code>grep</code> 函数的代码块可能看起来更简单:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say
    0.7 *
    [+]
        map  {.area * 3},
        grep {.renovation-year &lt; 2013},
        grep {.colour eq 'red'},
        grep {.number %% 2},
    @street;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在看起来已经大功告成了。一会儿我们会把它做得更好, 但现在要再次注意, 没有任何赋值操作符可以改变变量的值。实际上, 整个程序中的变量并不多。</p>
</div>
<div class="paragraph">
<p>上一个例子中的数据流是由下而上的链式 <code>map</code> 和 <code>grep</code>。 首先, <code>@street</code> 被过滤, 找到双数的房子, 然后挑选红色的房子, 然后只挑选老房子, 然后计算他们的表面积。Raku 允许我们用 <code>=&#8658;</code> 和 <code>&#8656;=</code> 运算符以从上到下的方式来组织代码。在第四章《使用运算符》中的数据管道运算符一节中简要介绍了 feed 运算符。这是你如何使用它们重写链的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 0.7 * (@street ==&gt;
    grep {.number %% 2} ==&gt;
    grep {.colour eq 'red'} ==&gt;
    grep {.renovation-year &lt; 2013} ==&gt;
    map  {.area * 3} ==&gt;
    reduce {$^a + $^b});</code></pre>
</div>
</div>
<div class="paragraph">
<p>反向 <code>&#8656;=</code> 运算符改变了数据的流向。</p>
</div>
<div class="paragraph">
<p>在这个例子中, 链的结果是一个数。如果你得到数组, 你甚至可以在链的末端定义变量。例如, 代替传统的赋值(这里需要圆括号):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @even-red-houses =
    (@street ==&gt; grep {.number %% 2} ==&gt; grep {.colour eq 'red'});</code></pre>
</div>
</div>
<div class="paragraph">
<p>把 <code>my</code> 声明放在末尾:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@street ==&gt; grep {.number %% 2} ==&gt;
grep {.colour eq 'red'} ==&gt; my @even-red-houses;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了减少花括号的数量, 可以使用 <code>Whatever</code> 块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@street ==&gt; grep *.number %% 2 ==&gt;
grep *.colour eq 'red' ==&gt; my @even-red-houses;</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们已经看到的那样, Raku 提供了许多不同的方法来尽可能地表达你的想法。</p>
</div>
<div class="paragraph">
<p>再次, 你看到没有涉及到变量, 但这并不意味着函数式编程中禁止使用变量。所不希望的只是修改它们。在下一节中, 我们将谈一谈我们还能用变量做什么。</p>
</div>
</div>
<div class="sect2">
<h3 id="_操作作用域">14.6. 操作作用域</h3>
<div class="paragraph">
<p>在本节中, 我们将学习三种可以改变变量作用域的技术。它们是闭包、柯里化和动态作用域。</p>
</div>
<div class="sect3">
<h4 id="_闭包">14.6.1. 闭包</h4>
<div class="paragraph">
<p>在 Raku 中, 词法变量存在于其作用域内。闭包是可以扩展这个作用域的函数, 让你访问词法值, 而这些值在定义闭包的地方是可用的。让我们考虑一个将当前状态保存在变量中的计数器的例子。</p>
</div>
<div class="paragraph">
<p>首先, 不涉及闭包。计数器的值被保存在一个全局变量中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $counter = 0;

sub next-number() {
    return $counter++;
}

say next-number(); # 0
say next-number(); # 1
say next-number(); # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>每次调用 <code>next-number</code> 函数时, 都会返回一个递增的整数。</p>
</div>
<div class="paragraph">
<p>现在, 我们的目标是隐藏 <code>$counter</code> 变量, 使其不能直接被 <code>next-number</code> 的用户访问。这就有了闭包。首先, 将变量和函数都放在另一个函数里面, 这样就为它们创建了一个词法作用域:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub new-counter() {
    my $counter = 0;

    sub next-number() {
        return $counter++;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在不能在 <code>new-counter</code> 函数之外访问 <code>$counter</code>, 而在 <code>next-number</code> 子例程中仍然可以访问。<code>$counter</code> 变量和 <code>next-number</code> 子例程都是本地的, 它们的作用域等于 <code>new-counter</code> 的主体。</p>
</div>
<div class="paragraph">
<p>虽然, <code>new-counter</code> 子例程返回的是 <code>next-number</code> 子例程, 并且它可以保存在一个变量中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = new-counter();</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>$c</code> 中存储的内容的类型是 <code>Sub</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $c.WHAT; # (Sub)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着 <code>$c</code> 是可调用的并且可以用作函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $c(); # 0
say $c(); # 1
say $c(); # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>每次调用都会改变闭包内捕获的 <code>$counter</code> 变量, 因此 <code>$c()</code> 的调用会像预期的那样返回递增的数字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = new-counter();
my $b = new-counter();

say $b(); # 0
say $b(); # 1
say $a(); # 0
say $b(); # 2
say $a(); # 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以创建另一个独立的计数器, 它的内部将包含另一个容器, 为它的 <code>$counter</code> 提供另一个容器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = new-counter();
say $c;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见, <code>$a</code> 和 <code>$b</code> 计数器保存调用之间的状态, 互不影响。</p>
</div>
<div class="paragraph">
<p>在前面的代码中, 子例程被保存在标量变量中, 前缀为 <code>$</code> sigil。如果这样做, 总是要添加圆括号来表示函数调用。如果不带圆括号, 就会打印内存中的函数地址:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub next-number () { #`(Sub|140645269514272) ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是你在输出中得到的结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub next-number () { #`(Sub|140645269514272) ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>大家都知道, 对于普通函数可以省略空括号, 比如说 <code>new-counter</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $cntr = new-counter;
say $cntr(); # 0
say $cntr(); # 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 有一个单独的 sigil, <code>&amp;</code>, 用于保存实现 <code>Callable</code> 接口的值的容器。这里就不细说了, 如果你有兴趣, 请参考 <a href="https:/​/​docs.​raku.​org/​type/​Callable">文档</a>。编译器会把带有 <code>&amp;</code> sigil 的变量被当作可以调用的对象来处理, 所以空的圆括号甚至是 sigil 本身都可以省略掉, 如下一个程序所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;d = new-counter();
say &amp;d(); # 0
say d();  # 1
say d;    # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>裸的 <code>d</code> 和 <code>d()</code> 和完整形式的 <code>&amp;d()</code> 都是一样的调用。</p>
</div>
<div class="paragraph">
<p>最后要说明的是关于 <code>new-counter</code> 函数中的子例程是如何返回的。说得更严格一点, 可以用引用隐式返回, 如下面的片段所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub new-counter() {
    my $counter = 0;
    sub next-number() {
        return $counter++;
    }

    return &amp;next-number;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里使用的 <code>&amp;</code> 符表示这不是函数调用而是 <code>sub</code> 本身。</p>
</div>
</div>
<div class="sect3">
<h4 id="_柯里化">14.6.2. 柯里化</h4>
<div class="paragraph">
<p>柯里化是一种减少函数参数数量的技术, 它通过创建一个封装函数来代替原来函数的一些预定义值来减少函数的参数数量。</p>
</div>
<div class="paragraph">
<p>让我们看看一个简单函数的例子, 这个函数带有两个参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub greet($type, $name) {
    return "$type, $name!";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设现在我们要选择一个默认的问候语; 函数调用将包含重复的参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say greet('Hello', 'Liza');
say greet('Hello', 'John');
say greet('Hello', 'Carl');</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以通过创建一个单独的函数 <code>hello</code> 来解决这个问题, 只需调用需要的参数 <code>greet</code> 即可:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub hello($name) {
    return greet('Hello', $name);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 为我们提供了简单的语法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;hello = &amp;greet.assuming('Hello');</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>assuming</code> 方法创建了一个新的可调用子例程, 实际上是一个带有给定的第一个参数的 <code>greet</code> 子例程。现在, <code>hello</code> 是一个新的可调用对象的名称, 它接受一个参数, 可以作为函数使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say hello('Liza');
say hello('John');
say hello('Carl');</code></pre>
</div>
</div>
<div class="paragraph">
<p>柯里化在某种程度上类似于使用子例程的默认参数, 但有两个主要区别。首先, 默认参数只能出现在签名的末尾。第二, 使用柯里化, 可以创建多个默认参数。例如, 可以从同一个 <code>greet</code> 函数中创建另一个替代问候语:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;hi = &amp;greet.assuming('Hi');

say hi('Liza');
say hi('John');
say hi('Carl');</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在让我们来看看如何处理一个带有命名参数的函数。下面是一个修改后的 <code>greet</code> 函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub greet(:$type, :$name) {
    return "$type, $name!";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建特定的 <code>hello</code> 版本很容易:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub hello($name) {
    return greet(:type('Hello'), :$name);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此, <code>:$type</code> 参数得到预定义的值-<code>:type('Hello')</code>, 而第二个参数 <code>:$name</code> 则直接使用其原始名称传递。结果是一个连接了问候语的字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say hello('John'); # Hello, John!</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后, 让我们再来看看另一种扩展变量作用域的方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_动态作用域">14.6.3. 动态作用域</h4>
<div class="paragraph">
<p>动态作用域使用 <code>*</code> twigil, 例如, 动态标量变量 <code>$*a</code>。与普通的局部变量不同, 动态变量可以在函数中使用, 它可以从变量的当前作用域中调用。看下面这个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f() {
    $*a++;
}

my $*a = 1;
f();
say $*a; # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里, <code>$*a</code> 是主程序中的一个动态变量。它的初始化值为 1。 当 <code>f</code> 函数被调用时, 会改变同一个变量的值, 因此该程序打印出 2。问题是 <code>$*a</code> 并没有在 <code>f</code> 函数内部声明。编译器会在函数被调用的作用域中搜索这个名称。</p>
</div>
<div class="paragraph">
<p>在前面的例子中, 可以用一个简单的全局变量来代替动态变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 1;
f();
say $a;

sub f() {
    $a++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用动态变量, 你可以在不同的上下文中访问不同的容器。例如, 如果从另一个函数中调用 <code>f</code> 函数怎么办?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub g() {
    my $*a = 10;
    f();
    say $*a; # 21
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下, <code>f</code> 将修改在 <code>g</code> 中初始化的变量。同样的情况也会发生在该作用域内包含动态变量的任何其他调用上:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f() {
    $*a++;
}

sub g() {
    my $*a = 10;
    f();
    say $*a;
}

sub h() {
    my $*a = 20;
    f();
    say $*a;
}

g(); # 11
h(); # 21
g(); # 11</code></pre>
</div>
</div>
<div class="paragraph">
<p>在下一节中, 我们将讨论创建更高级的函数, 例如迭代器。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_创建并使用迭代器">14.7. 创建并使用迭代器</h3>
<div class="paragraph">
<p>迭代器是一种强大的技术, 可按需提供数据, 避免手动计数。这些函数每次调用时, 都会返回某个序列的下一个元素。在上一节中, 我们已经创建了迭代器 <code>new-counter</code>, 它可以生成递增的整数。让我们做一个更复杂的东西:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub make-iter(@data) {
    my $index = 0;
    sub {
        return @data[$index++];
    }
}

my &amp;iter = make-iter(&lt;red green blue orange&gt;);

say iter; # red
say iter; # green
say iter; # blue
say iter; # orange</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>make-iter</code> 函数得到一个数组, 将 <code>$index</code> 位置安装为 0, 并返回一个子例程作为迭代器。下次调用 <code>iter</code> 对象时, 它返回当前位置的值, 并将内部指针移动到下一个元素。当数据用完后, 会返回 <code>Nil</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub make-factorial-iter() {
    my $n = 1;
    my $f = 1;

    sub {
        $f *= $n++;
        return $f;
    }
}

my &amp;iter = make-factorial-iter();
say iter for 1..5;</code></pre>
</div>
</div>
<div class="paragraph">
<p>迭代器也可以根据一定的规则生成序列。例如, 这里有一个迭代器, 每次调用它时, 都会返回下一个阶乘数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub make-factorial-iter() {
    my $n = 1;
    my $f = 1;

    sub {
        $f *= $n++;
        return $f;
    }
}

my &amp;iter = make-factorial-iter();
say iter for 1..5;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序会打印出 5 个数字 - 1 到 5 的阶乘数。注意, 该算法没有使用递归或循环, 只需要最少的必要操作来计算下一个值。它总是使用之前计算出的 <code>$n - 1</code> 的值。</p>
</div>
<div class="paragraph">
<p>现在我们再来说说另一个话题, 惰性计算的数据。</p>
</div>
</div>
<div class="sect2">
<h3 id="_惰性和无限列表">14.8. 惰性和无限列表</h3>
<div class="paragraph">
<p>这个带阶乘的例子, 只要计算机的内存限制允许, 就可以生成数字。虽然我们可能想计算, 比如说 100 的阶乘, 但程序会在我们真正需要这个值的时候才会进行计算。如果结果还不需要, 就不会花费任何计算资源。这就是惰性计算背后的思想。</p>
</div>
<div class="paragraph">
<p>在 Raku 中, <code>&#8230;&#8203;</code> 操作符可以创建一个序列。最简单的情况看起来与创建序列的方法类似。在下一个例子中, 我们将创建一个普通的数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1...100;
say @a.elems;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@a</code> 数组被立即创建, 它得到了所有的 100 个元素, 即从 1 到 100 的整数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @a[0];  # 1
say @a[1];  # 2

say @a[98]; # 99
say @a[99]; # 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反, 使用 <code>lazy</code> 关键字创建的惰性序列, 不会填充数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @b = lazy 1...100;</code></pre>
</div>
</div>
<div class="paragraph">
<p>试图通过调用 <code>@b.elems</code> 来获取它的大小, 会产生一个错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Cannot .elems a lazy list</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然可以获取这个数组的元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @b[0]; # 1
say @b[1]; # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>在数组末尾请求元素也会生成相应的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @b[98]; # 99
say @b[99]; # 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后, 当数组结束, 请求一个额外的元素时, 返回空值 <code>Any</code>。此时, 数组不再是惰性的, <code>elems</code> 方法返回数组的大小。要检查一个数组是否是惰性的, 可以使用 <code>is-lazy</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @b.is-lazy; # True

say @b[100];    # (Any)
say @b.elems;   # 100
say @b.is-lazy; # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 还允许我们创建序列, 其上边界是无限的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @c = 1 ... Inf; # or 1 ... ∞

say @c[0];    # 1
say @c[1000]; # 1001</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于无法到达这样的序列的末尾, 所以 <code>@c.is-lazy</code> 将始终保持为 <code>True</code>。</p>
</div>
<div class="paragraph">
<p>当你给它提供一个算术或几何级数的例子时, <code>&#8230;&#8203;</code> 序列运算符可以生成更复杂的序列:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @arithm = 1, 3 ... 11;
say @arithm; # [1 3 5 7 9 11]

my @geom = 2, 4, 8 ... 256;
say @geom; # [2 4 8 16 32 64 128 256]

my @float = 3.14, 3.15 ... 3.19;
say @float; # [3.14 3.15 3.16 3.17 3.18 3.19]</code></pre>
</div>
</div>
<div class="paragraph">
<p>要创建一个无限序列, 请使用 <code>Inf</code> 或 <code>*</code> 作为序列的右端:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @inf = 1, 2 ... Inf;
say @inf[0..5]; # (1 2 3 4 5 6)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序立即打印出结果, 而不需要等到数组被无限列表填满。</p>
</div>
<div class="paragraph">
<p>最后, 可以使用自定义的生成器来计算下一个值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @cubes = {state $n; $n++; $n ** 3} ... Inf;
say @cubes[0..5]; # (1 8 27 64 125 216)</code></pre>
</div>
</div>
<div class="paragraph">
<p>生成代码块是利用 <code>state</code> 变量来记录生成的数字的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_16">14.9. 总结</h3>
<div class="paragraph">
<p>在本章中, 我们讨论的是函数式编程。Raku, 虽然不是函数式编程语言, 但它包括的元素可以实现这类语言的许多特性。我们讨论了递归和化简, 讨论了高阶函数、lambda 函数和 WhateverCode 代码块(那些使用 <code>*</code> 来要求 Raku 做你想要的事情的代码块)。我们创建了一些使用使用数据管道、闭包、柯里化和动态作用域的例子。最后, 我们谈到了无限列表和惰性列表, 以及如何生成它们。</p>
</div>
<div class="paragraph">
<p>下一章的主题是反应式编程, 这是 Raku 支持的另一种编程范式。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_反应式编程">15. 反应式编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在上一章中, 我们讨论了函数式编程。Raku 是一种多范式的语言, 它内置了对这方面的支持。在这一章中, 我们讨论了反应式编程, 也称为函数反应式编程或事件驱动编程。 同样, Raku 的内核也支持这种风格的编程, 开箱即用。</p>
</div>
<div class="paragraph">
<p>本章将讨论以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>反应式编程的概念</p>
</li>
<li>
<p>按需供应和实时供应</p>
</li>
<li>
<p>过滤和转换数据流</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_什么是反应式编程">15.1. 什么是反应式编程</h3>
<div class="paragraph">
<p>在过程式编程中, 程序列出了变量的指令, 当变量得到一个特定的值, 或者说当一个代码块被执行时, 程序就会列出指令。例如, 一个变量将另外两个整数变量值的和作为它的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$z = $x + $y;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <code>$x</code> 或 <code>$y</code> 在这个赋值后被改变, 那么 <code>$z</code> 的值就不会改变。另一个例子 - 函数返回值被赋值给一个变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$area = area-of-circle($r);</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然从代码中可以清楚地看到, 它计算出了给定半径的圆的面积, 但如果改变了 <code>$r</code> 变量, 就必须手动更新 <code>$area</code> 的值。</p>
</div>
<div class="paragraph">
<p>而反应式编程的目的就是要改变这种依赖值的"静态"行为。许多计算机程序和网页的交互式界面就是反应式编程的很好的例子。想象一下一个在线计算器, 你输入两个值, 在页面上的另一个地方立即得到结果。或者, 你输入一个半径, 圆的面积就会被重新计算并显示出来。让我们看看 Raku 是如何处理这个问题的。</p>
</div>
<div class="paragraph">
<p>有两个主类可以处理大部分你所需要的反应式编程所需要的东西-<code>Supply</code>, 这是一个异步数据流, 以及 <code>Supplier</code>, 这是一个工厂, 用于供应的变体之一, 即实时供应(<strong>live supplies</strong>)。还存在- 按需供应(<strong>on-demand supplies</strong>), 我们先来介绍一下。</p>
</div>
</div>
<div class="sect2">
<h3 id="_按需供应">15.2. 按需供应</h3>
<div class="paragraph">
<p>供应的数据流包含两个部分 - 发出数据的供应者和接收数据的阀门。Raku 的反应式编程模型是一个线程安全的观察者设计模式实现。</p>
</div>
<div class="paragraph">
<p>让我们使用 <code>supply</code> 关键字创建第一个按需供应:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">supply {
    emit($_) for 'a'..'e';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里有 <code>supply</code>, 但它还没有发出任何数据, 因为没有需求。如果你在循环中添加一条打印指令, 就可以很容易看到这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">supply {
    for 'a'..'e' {
        emit($_);
        say "Emitted $_";
    }
}
sleep 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序在 2 秒后就默默地退出了。</p>
</div>
<div class="paragraph">
<p>为了使供应者产生数据, 我们需要创建一个 <code><strong>tap</strong></code>。<code>supply</code> 块返回一个 <code>Supply</code> 类型的值, 你可以在上面调用 <code>tap</code> 方法来传递响应于发出的数据将被执行的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">supply {
    emit($_) for 'a'..'e';
}.tap({
    .say;
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次, 程序打印出了几行从 <code>a</code> 到 <code>e</code> 的字母。让我们在"调试器"程序中打开一个阀门, 看到它是否真的执行了发射块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">supply {
    for 'a'..'e' {
        say "Emitting $_";
        emit($_);
    }
}.tap({
    say "Tap received $_";
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>实际上, 现在两个 <code>say</code> 函数都被调用了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Emitting a
Tap received a
Emitting b
Tap received b
Emitting c
Tap received c
Emitting d
Tap received d
Emitting e
Tap received e</code></pre>
</div>
</div>
<div class="paragraph">
<p>在一个供应者上连接一个以上的分接头是没有问题的。每一个分接头都能接收到相同的数据:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = supply {
    emit($_) for 'a'..'e';
}

$supply.tap({
    say "Tap 1 got $_";
});

$supply.tap({
    say "Tap 2 got $_";
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>与通道不同(见第十三章,《并发编程》), 分接头不会竞争获得发送的值。根据需要, 供应者可以提供任意数量的分接头。注意, 这也意味着分接头不作为并行进程工作。如果给第一个分接头添加一个小的延迟, 就可以清楚地看到这一点了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$supply.tap({
    say "Tap 1 got $_";
    sleep 0.5;
});
$supply.tap({
    say "Tap 2 got $_";
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在输出中你会看到, 从 a 到 e 的所有值将会先到达第一个分接头, 然后再送达第二个分接头:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Tap 1 got a
Tap 1 got b
Tap 1 got c
Tap 1 got d
Tap 1 got e
Tap 2 got a
Tap 2 got b
Tap 2 got c
Tap 2 got d
Tap 2 got e</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_用_suppile_生成数据">15.2.1. 用 suppile 生成数据</h4>
<div class="paragraph">
<p>在上一节中, 使用 <code>emit</code> 方法将值发送到供应。对于每一个数据项, 都要进行单独的调用。供应可以自己生成数据。<code>Supply</code> 类的 <code>interval</code> 方法会以给定的时间间隔发出数据。在下面的例子中, 它每隔 300 毫秒就会生成一个不断递增的数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Supply.interval(0.3).tap({
    say $_;
});
sleep 5;</code></pre>
</div>
</div>
<div class="paragraph">
<p>每当触发一个分接时, 都会得到一个不断递增的整数。第一个值是 0。因此, 上面的程序将打印出从 0 到 16 的数字。</p>
</div>
<div class="paragraph">
<p>这里需要调用 <code>sleep</code> 函数, 可以看到分接接收到的头几个结果。如果不调用它, 程序就会立即停止。</p>
</div>
<div class="paragraph">
<p>顺便说一下, 如果你想用一个命名变量代替 $_, 就用一个带参数的尖号块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Supply.interval(0.5).tap( -&gt; $x {say $x});
sleep 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>interval</code> 方法也接受第二个参数, 即第一个数据项发出前的延迟, 单位为秒:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Supply.interval(1, 2).tap({
    .say;
});
sleep 4;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在程序在 2 秒后开始打印数字。初始延迟并不影响供应产生的序列。这个程序也是从 0 开始打印(并以 1 结束, 因为当程序有一个工作的分接时, <code>sleep</code> 函数允许 2 秒的休眠)。</p>
</div>
<div class="paragraph">
<p>分接可以随时关闭。分接是 <code>Tap</code> 类的对象, 它具有 <code>close</code> 方法。它的用法在下面的程序中可以证明:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval(0.3);
my $tap = $supply.tap({
    .say;
});

sleep 1;
$tap.close;
sleep 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第一秒内打印完前几个数字后, 分接被关闭, 之后该程序只需再等待几秒钟, 就什么也不打印了。</p>
</div>
<div class="paragraph">
<p>如果没有分接, 则供应不会产生新的数据。让我们在下面的例子中创建分接之前暂停, 以查看其中的行为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval(0.3);

sleep 2;
my $tap = $supply.tap({
    .say;
});
sleep 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>分接连接前的延迟比潜在数据生成的间隔时间长。在 2 秒内, 可能会生成一些数字, 但程序仍然打印出从 0 开始的数字。</p>
</div>
<div class="paragraph">
<p>当一个分接连接到已经在为另一个分接生成数据的供应上时, 这个原理也是有效的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval(0.5);

say "Tap 1\t| Tap 2";
say '_' x 15;

$supply.tap({
    say "$_\t|";
});

sleep 2;

$supply.tap({
    say "\t| $_";
});

sleep 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的两个分接器是独立工作的。这就是程序输出的样子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Tap 1 | Tap 2
_______________
0     |
1     |
2     |
3     |
      | 0
4     |
      | 1
5     |
      | 2
6     |
      | 3
7     |
      | 4
8     |
      | 5
9     |</code></pre>
</div>
</div>
<div class="paragraph">
<p>这两个分接器都接收从零开始的序列。 <code>interval</code> 方法是一种创建按需供应的工厂方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval(10);
say $supply.WHAT; # (Supply)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在创建供应时, 有一个替代的语法 - 我们将在下一节讨论。</p>
</div>
</div>
<div class="sect3">
<h4 id="_react_和_whenever_关键字">15.2.2. react 和 whenever 关键字</h4>
<div class="paragraph">
<p>在 Raku 中, 有一些特殊的关键字用于按需供应。不用显式地创建 <code>Supply</code> 类的对象, 而是使用  <code>react</code> 关键字。在这种情况下, 用 <code>whenever</code> 块来代替创建分接器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    whenever Supply.interval(0.5) {
        .say;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序每隔 0.5 秒打印一次数字。注意到与前面的例子的主要区别。使用 <code>react</code>, 在创建一个分接器后, 不需要调用 <code>sleep</code> 或以某种方式控制程序的生命周期。该程序会无限运行, 直到你用 <code>Ctrl + C</code> 退出。</p>
</div>
<div class="paragraph">
<p>要以编程的方式打破循环, 可以调用 <code>done</code> 函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    whenever Supply.interval(0.5) {
        .say;
        done if $_ &gt; 3;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这次, 程序只打印出几秒钟的数字。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用列表作为_supply_数据的来源">15.2.3. 使用列表作为 supply 数据的来源</h4>
<div class="paragraph">
<p><code>Supply</code> 类提供了一个特殊的方法, <code>from-list</code>, 它接收一个列表, 并从该列表中发送元素作为发出的数据项:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.from-list('a'..'e');
$supply.tap({
    .say;
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者, 可以使用 <code>react-whenever</code> 结构:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    whenever Supply.from-list('a'..'e') {
        .say;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下, 程序会立即将所有的元素流向分接器, 由分接器打印出这些元素。</p>
</div>
<div class="paragraph">
<p>与 <code>interval</code> 方法类似, <code>from-list</code> 创建了一个供应对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.from-list(1..10);
say $supply.WHAT; # (Supply)</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在是时候说说另一种类型的供应了, 即实时供应。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_实时供应">15.3. 实时供应</h3>
<div class="paragraph">
<p>无论有多少个分接器, 实时供应都会产生数据。与按需供应不同的是, 如果没有打开的分接器, 发射的数据仍然会产生, 只是它会消失。只要打开分接器, 它就会从那一刻开始接收数据; 所有的历史记录都会丢失。</p>
</div>
<div class="paragraph">
<p>要创建一个实时供应, 请调用 <code>Supplier</code> 类的构造函数。必须在供应上连接一个分接器, 由 <code>Supply</code> 工厂方法返回。这些都在下面的例子中显示了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supplier = Supplier.new;

$supplier.Supply.tap({
    say $_;
});

$supplier.emit($_) for 'a'..'e';</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能会对 <code>Supply</code> 和 <code>Supplier</code> 类的存在感到困惑。<code>Supplier</code> 类是生产实时供应的工厂。</p>
</div>
<div class="paragraph">
<p>让我们看看实时供应是如何流式传输数据的, 以及在没有打开分接器的情况下会发生什么。在下面的程序中, 实时供应在由 <code>start</code> 关键字创建的独立线程中生成数据。实际上, <code>start</code> 创造了一个承诺(见第十三章, 《并发编程》), 因此它伴随着 <code>await</code> 关键字等待, 直到全部完成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supplier = Supplier.new;

my $emitter = start {
    for 'a'..'e' {
        sleep 1;
        $supplier.emit($_);
    }
}

sleep 3;
$supplier.Supply.tap({
    say $_;
});

await $emitter;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$emitter</code> 承诺在程序开始后每隔一秒就会发布一次从 'a'&#8230;&#8203;'e' 范围的数据。3 秒后, 分接器被创建。从那一刻起, 分接开始从供应中获取值, 程序打印出 c、b 和 e。前三个数据片丢失了(没有打开的分接器接收它们)。请注意, 无论是供应还是分接器都没有排队记录历史数据。</p>
</div>
<div class="paragraph">
<p>如果有一个以上的分接器连接, 实时供应和按需供应都会平均分配数据:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supplier = Supplier.new;
my $supply = $supplier.Supply;

$supply.tap({
    say "Tap 1 got $_";
});

$supply.tap({
    say "Tap 2 got $_";
});

$supplier.emit(10.rand);
$supplier.emit(10.rand);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序发出两个随机数, 这两个随机数都会落在这两个分接器中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Tap 1 got 3.49754022030442
Tap 2 got 3.49754022030442
Tap 1 got 0.196464185630715
Tap 2 got 0.196464185630715</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 中的反应式编程是线程安全的。例如, 让我们创建一个程序, 在这个程序中, 所有的供应和分接器都在各自的线程中执行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supplier = Supplier.new;

start {
    $supplier.Supply.tap({
        say "Tap 1 got $_";
    })
}

start {
    $supplier.Supply.tap({
        say "Tap 2 got $_";
    })
}

start {
    sleep 1;
    $supplier.emit(42);
}

sleep 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它完美地工作 - 两个分接器都接收到供应发出的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Tap 2 got 42
Tap 1 got 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要我们有线程, 并且它们并行地工作, 那么程序的输出可能会有所不同, 这取决于哪个分接器先得到数据:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Tap 2 got 42
Tap 1 got 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>要了解更多关于 <code>Supply</code> 和 <code>Supplier</code> 类方法的信息, 请参阅 <a href="docs.raku.org" class="bare">docs.raku.org</a> 网站的文档。</p>
</div>
<div class="sect3">
<h4 id="_过滤和转换数据流">15.3.1. 过滤和转换数据流</h4>
<div class="paragraph">
<p><code>Supply</code> 类的对象具有 <code>grep</code> 和 <code>map</code> 方法, 可以用来过滤流中的数据, 类似于同名的内置函数。<code>grep</code> 和 <code>map</code> 方法都会创建一个新的 <code>Supply</code> 对象, 你可以在它上面连接分接器。</p>
</div>
<div class="paragraph">
<p>请考虑以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval(0.3);

my $filtered = $supply.grep(* %% 2);

$filtered.tap({
    .say;
});

sleep 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们在前面的按需供应一节中有一个类似的程序。这一次, 另一个供应, <code>$filtered</code>, 被嵌入到数据流中。它是由在原始的 <code>$supply</code> 上调用的 <code>grep</code> 方法创建的。</p>
</div>
<div class="paragraph">
<p>过滤器本身是由 <code>WhateverCode</code> 块 <code>* %% 2</code> 实现的。现在只有奇数才会从 <code>$supply</code> 传递到 <code>$filtered</code>。</p>
</div>
<div class="paragraph">
<p>对于其他的, <code>$supply</code> 和 <code>$filtered</code> 对象都是常规的按需供应, 你可以根据需要给它们附加任意数量的分接器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval(0.3);
my $filtered = $supply.grep(* %% 2);

$supply.tap({
    "Unfiltered tap got $_".say;
});

$filtered.tap({
    "Filtered tap 1 got $_".say;
});

$filtered.tap({
    "Filtered tap 2 got $_".say;
});

sleep 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序会生成以下输出, 其中包含所有三个分接器的反应:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Filtered tap 1 got 0
Unfiltered tap got 0
Filtered tap 2 got 0
Unfiltered tap got 1
Unfiltered tap got 2
Filtered tap 1 got 2
Filtered tap 2 got 2
Unfiltered tap got 3
Unfiltered tap got 4
Filtered tap 1 got 4
Filtered tap 2 got 4
Unfiltered tap got 5
Unfiltered tap got 6
Filtered tap 1 got 6
Filtered tap 2 got 6
Unfiltered tap got 7
Unfiltered tap got 8
Filtered tap 1 got 8
Filtered tap 2 got 8
Unfiltered tap got 9</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你所看到的, 发出的数字是递增的, 而过滤后的供应只接收偶数值。</p>
</div>
<div class="paragraph">
<p>另一个方法是 <code>map</code>, 对数据进行变换, 并返回变换后的流的新供应。考虑一下下面的例子, 将 <code>interval</code> 供应所生成的所有数字都转换为2次方:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Supply.interval(0.3).map(* ** 2).tap(*.say);
sleep 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里, 为了简洁起见, 使用了两个 <code>*</code>。如果你喜欢更冗长的风格, 可以使用 <code>$_</code> 变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Supply.interval(0.3).map({
    $_ ** 2
}).tap({
    .say
});

sleep 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序会按预期的那样, 打印出前几个整数的平方。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_17">15.4. 总结</h3>
<div class="paragraph">
<p>在本章中, 我们讨论了 Raku 中的反应式编程。这种范式在语言核心中得到了支持, 所以不需要外部模块就可以开始编程。供应是本章的主角 - 我们涵盖了两种不同类型的供应, 按需供应和实时供应。我们有许多将分接器连接到供应上的例子, 看到了数据流是如何组织的, 也看到了数据流是如何过滤的。</p>
</div>
<div class="paragraph">
<p>这是本书的最后一章。在十五章中, 我们从最基础 Raku 知识出发, 通过面向对象的方法和并发编程到更高阶的功能, 例如函数式编程和反应式编程。Raku 自然地嵌入了所有这些范式。毫无疑问, 15 年多的发展历程, 为整个语言的质量和成熟度增加了不少价值。</p>
</div>
<div class="paragraph">
<p>本书大约花费了半年时间, Rakudo 发布了 3 个主要的版本。不得不承认, 编译器的质量非常高, 在过去的2到3年时间里, 我从来没遇到过崩溃或怪异的行为。在和各种 Perl 会议的与会者聊天时, 我发现越来越多的人对 Raku 感兴趣, 说现在一切都好用了。你可以下载编译器, 它开箱即用, 提供了 Raku 所拥有的大量功能。</p>
</div>
<div class="paragraph">
<p>现在语言本身的版本是 6.c. 字母 c 在这里代表圣诞节。有很长一段时间, 有人宣布 Raku 将在圣诞节前完成, 但没有提到具体的年份。终于, 6.c 标准在 2015 年的圣诞节前成为了现实。2017 年晚些时候或 2018 年初, 新版本的语言将发布。你可以在 Larry Wall 在 2017年8月阿姆斯特丹 Perl 大会上发表的主题演讲中找到更多细节 - <a href="https://youtube/E5t8qaAGw9w" class="bare">https://youtube/E5t8qaAGw9w</a>。</p>
</div>
<div class="paragraph">
<p>作为本书的作者, 我希望我的读者能喜欢这门语言, 并开始在实践中使用这门语言。你使用这门语言越多, 你就越了解它的潜力是多么巨大。现在, 我们正处于 Raku 新时代的开端。</p>
</div>
</div>
</div>
</div>

</article>


    

  </main><section class="site__search">
    <label class="site__form">
        <p class="form__label">Search around the site</p> 
        <input class="site__search-bar form__input" type="text">
    </label>
    <div class="site__search-bar-results"></div>
</section>
  
  <footer class="site__footer">
    
    
    <p class="footer__sign">© 2020 ohmyraku</p></footer>
    

    
    <script>
        window.addEventListener("load", function () {
            const script = document.createElement("script");
            script.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
            script.async = true

            document.head.appendChild(script);
        })
    </script>





<script defer type="text/javascript" src="https://ohmyraku.github.io/js/script.14164ab553b19613ce98aadb54b1ed9a89ae5b056c72b99a4c672e37954f33d67bebe1452b0279025ba889964b51bdf8ec69683933cf427ae67c08ac2cdda7b1.js" integrity="sha512-FBZKtVOxlhPOmKrbVLHtmomuWwVscrmaTGcuN5VPM9Z76&#43;FFKwJ5AluoiZZLUb347GloOTPPQnrmfAisLN2nsQ=="></script>



</body>
</html>