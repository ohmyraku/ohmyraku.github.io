<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Raku 基础 :: 山川异域, 风月同天</title>

<meta name="author" content="ohmyraku">
<meta name="application-name" content="山川异域, 风月同天">
<meta name="description" content="Table of Contents 1. 什么是 Raku 1.1. Perl5, 老天鹅 1.2. 库的可用性 1.3. 我为什么要使用 Raku? 1.4. 总结   2. 运行 Raku 2.1. 安装器 2.2. Docker 2.3. 从源代码创建 2.4. 测试你的 Rakudo Star 安装 2.5. 文档 2.6. 总结   3. 格式化数独字谜 3.1. 让数独变得可玩 3.2. 捷径、常量和更多的捷径 3.3. IO 和其它悲剧 3.4. 获得创造性 3.5. 总结   4. 日期时间转换命令行 4.1. 使用库 4.2. DateTime 格式化 4.3. 寻找其他途径 4.4. 处理时间 4.5. 系好你的安全带 4.6. MAIN 魔法 4.7. 自动化测试 4.">
<meta name="robots" content="noodp"/>
<meta name="generator" content="Hugo 0.63.2" />
<meta name="referrer" content="no-referrer" />
<meta name="format-detection" content="telephone=no">

<link rel="canonical" href="https://ohmyraku.github.io/raku-by-example/" />


<link rel="icon" href="https://ohmyraku.github.io/logo.png" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Raku 基础" />
<meta name="twitter:description" content="Table of Contents 1. 什么是 Raku 1.1. Perl5, 老天鹅 1.2. 库的可用性 1.3. 我为什么要使用 Raku? 1.4. 总结   2. 运行 Raku 2.1. 安装器 2.2. Docker 2.3. 从源代码创建 2.4. 测试你的 Rakudo Star 安装 2.5. 文档 2.6. 总结   3. 格式化数独字谜 3.1. 让数独变得可玩 3.2. 捷径、常量和更多的捷径 3.3. IO 和其它悲剧 3.4. 获得创造性 3.5. 总结   4. 日期时间转换命令行 4.1. 使用库 4.2. DateTime 格式化 4.3. 寻找其他途径 4.4. 处理时间 4.5. 系好你的安全带 4.6. MAIN 魔法 4.7. 自动化测试 4." />
<meta name="twitter:site" content="https://ohmyraku.github.io" />
<meta name="twitter:creator" content="ohmyraku" />
<meta name="twitter:image" content="https://ohmyraku.github.io/logo.png">
<meta property="og:type" content="article" />
<meta property="og:locale" content="en" />
<meta property="og:name" content="ohmyraku" />
<meta property="og:title" content="Raku 基础" />
<meta property="og:url" content="https://ohmyraku.github.io" />
<meta property="og:site_name" content="山川异域, 风月同天" />
<meta property="og:description" content="Table of Contents 1. 什么是 Raku 1.1. Perl5, 老天鹅 1.2. 库的可用性 1.3. 我为什么要使用 Raku? 1.4. 总结   2. 运行 Raku 2.1. 安装器 2.2. Docker 2.3. 从源代码创建 2.4. 测试你的 Rakudo Star 安装 2.5. 文档 2.6. 总结   3. 格式化数独字谜 3.1. 让数独变得可玩 3.2. 捷径、常量和更多的捷径 3.3. IO 和其它悲剧 3.4. 获得创造性 3.5. 总结   4. 日期时间转换命令行 4.1. 使用库 4.2. DateTime 格式化 4.3. 寻找其他途径 4.4. 处理时间 4.5. 系好你的安全带 4.6. MAIN 魔法 4.7. 自动化测试 4." />
<script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "Article",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https:\/\/ohmyraku.github.io\/raku-by-example\/"
      },
      "headline": "Raku 基础",
      
      "datePublished": "2020-02-05",
      "dateModified": "2020-02-05 15:26:52 \x2b0800 CST",
      "author": {
        "@type": "Person",
        "name": "ohmyraku"
      },
      "description": "Table of Contents 1. 什么是 Raku 1.1. Perl5, 老天鹅 1.2. 库的可用性 1.3. 我为什么要使用 Raku? 1.4. 总结   2. 运行 Raku 2.1. 安装器 2.2. Docker 2.3. 从源代码创建 2.4. 测试你的 Rakudo Star 安装 2.5. 文档 2.6. 总结   3. 格式化数独字谜 3.1. 让数独变得可玩 3.2. 捷径、常量和更多的捷径 3.3. IO 和其它悲剧 3.4. 获得创造性 3.5. 总结   4. 日期时间转换命令行 4.1. 使用库 4.2. DateTime 格式化 4.3. 寻找其他途径 4.4. 处理时间 4.5. 系好你的安全带 4.6. MAIN 魔法 4.7. 自动化测试 4.",
      "publisher": {
        "@type": "Organization",
        "name": "https:\/\/ohmyraku.github.io",
        "logo": {
          "@type": "ImageObject",
          "url": "https:\/\/ohmyraku.github.io\/logo.png"
        }
      }
    }
</script><link rel="stylesheet" href="https://ohmyraku.github.io/scss/main.min.84f71d25d375c522a861bb4719728ce6839cf3635b15ca0c7a1b4d799c2dc3399a1d6cb46058a9d8fdbebe9156a8857279cfdeb70aa3862e629de234b5a41fa1.css" integrity="sha512-hPcdJdN1xSKoYbtHGXKM5oOc82NbFcoMehtNeZwtwzmaHWy0YFip2P2&#43;vpFWqIVyec/etwqjhi5ineI0taQfoQ==">
<script>

const theme = window.localStorage.getItem('theme'); 
if (theme && theme !== "1") {
    document.documentElement.classList.add('theme-' + theme);
}
</script>


</head>
<body>
  <main class="site__content">
    <div class="site__page">
  <nav class="site__breadcrumbs">
    <a class="site__breadcrumb" href="https://ohmyraku.github.io/">山川异域, 风月同天</a><a class="site__breadcrumb--active" href="https://ohmyraku.github.io/raku-by-example/">Raku 基础</a>
</nav>

<h1 class="page__title">Raku 基础</h1>
  <div class="page__meta">
    <p>
    
    <span class="page__date">
    on <time datetime="2020-02-05T15:26:52&#43;08:00">2020-02-05</time>
    
    </span>
    </p>

    

    
    </div>
</div>


</div>

<article class="page__content" ><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_什么是_raku">1. 什么是 Raku</a>
<ul class="sectlevel2">
<li><a href="#_perl5_老天鹅">1.1. Perl5, 老天鹅</a></li>
<li><a href="#_库的可用性">1.2. 库的可用性</a></li>
<li><a href="#_我为什么要使用_raku">1.3. 我为什么要使用 Raku?</a></li>
<li><a href="#_总结">1.4. 总结</a></li>
</ul>
</li>
<li><a href="#_运行_raku">2. 运行 Raku</a>
<ul class="sectlevel2">
<li><a href="#_安装器">2.1. 安装器</a></li>
<li><a href="#_docker">2.2. Docker</a></li>
<li><a href="#_从源代码创建">2.3. 从源代码创建</a></li>
<li><a href="#_测试你的_rakudo_star_安装">2.4. 测试你的 Rakudo Star 安装</a></li>
<li><a href="#_文档">2.5. 文档</a></li>
<li><a href="#_总结_2">2.6. 总结</a></li>
</ul>
</li>
<li><a href="#_格式化数独字谜">3. 格式化数独字谜</a>
<ul class="sectlevel2">
<li><a href="#_让数独变得可玩">3.1. 让数独变得可玩</a></li>
<li><a href="#_捷径常量和更多的捷径">3.2. 捷径、常量和更多的捷径</a></li>
<li><a href="#_io_和其它悲剧">3.3. IO 和其它悲剧</a></li>
<li><a href="#_获得创造性">3.4. 获得创造性</a></li>
<li><a href="#_总结_3">3.5. 总结</a></li>
</ul>
</li>
<li><a href="#_日期时间转换命令行">4. 日期时间转换命令行</a>
<ul class="sectlevel2">
<li><a href="#_使用库">4.1. 使用库</a></li>
<li><a href="#_datetime_格式化">4.2. DateTime 格式化</a></li>
<li><a href="#_寻找其他途径">4.3. 寻找其他途径</a></li>
<li><a href="#_处理时间">4.4. 处理时间</a></li>
<li><a href="#_系好你的安全带">4.5. 系好你的安全带</a></li>
<li><a href="#_main_魔法">4.6. MAIN 魔法</a></li>
<li><a href="#_自动化测试">4.7. 自动化测试</a></li>
<li><a href="#_总结_4">4.8. 总结</a></li>
</ul>
</li>
<li><a href="#_测试_say">5. 测试 say</a>
<ul class="sectlevel2">
<li><a href="#_总结_5">5.1. 总结</a></li>
</ul>
</li>
<li><a href="#_silent_cron_一个_cron_包裹器">6. Silent-Cron, 一个 Cron 包裹器</a>
<ul class="sectlevel2">
<li><a href="#_异步运行命令">6.1. 异步运行命令</a></li>
<li><a href="#_实现超时">6.2. 实现超时</a></li>
<li><a href="#_更多关于承诺的信息">6.3. 更多关于承诺的信息</a></li>
<li><a href="#_可能的扩展">6.4. 可能的扩展</a></li>
<li><a href="#_重构和自动化测试">6.5. 重构和自动化测试</a></li>
<li><a href="#_总结_6">6.6. 总结</a></li>
</ul>
</li>
<li><a href="#_有状态的_silent_cron">7. 有状态的 Silent Cron</a>
<ul class="sectlevel2">
<li><a href="#_持久化存储">7.1. 持久化存储</a></li>
<li><a href="#_开发存储后端">7.2. 开发存储后端</a></li>
<li><a href="#_使用存储后端">7.3. 使用存储后端</a></li>
<li><a href="#_扩展空间">7.4. 扩展空间</a></li>
<li><a href="#_总结_7">7.5. 总结</a></li>
</ul>
</li>
<li><a href="#_回顾_raku_基础知识">8. 回顾 Raku 基础知识</a>
<ul class="sectlevel2">
<li><a href="#_变量和作用域">8.1. 变量和作用域</a></li>
<li><a href="#_子例程">8.2. 子例程</a></li>
<li><a href="#_类和对象">8.3. 类和对象</a></li>
<li><a href="#_并发">8.4. 并发</a></li>
<li><a href="#_展望">8.5. 展望</a></li>
<li><a href="#_正则表达式基础">8.6. 正则表达式基础</a></li>
<li><a href="#_解析_ini_原语">8.7. 解析 INI 原语</a></li>
<li><a href="#_把东西组装起来">8.8. 把东西组装起来</a></li>
<li><a href="#_回溯">8.9. 回溯</a></li>
<li><a href="#_grammars">8.10. Grammars</a></li>
<li><a href="#_从匹配中提取数据">8.11. 从匹配中提取数据</a></li>
<li><a href="#_生成好的错误信息">8.12. 生成好的错误信息</a></li>
<li><a href="#_编写你自己的_grammars">8.13. 编写你自己的 Grammars</a></li>
<li><a href="#_总结_8">8.14. 总结</a></li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_什么是_raku">1. 什么是 Raku</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 是一种编程语言。它以自然语言为灵感，设计成易学、易读、易写的语言。它让初学者可以编写 "婴儿Perl"，同时也让有经验的程序员可以自由表达，从简练到诗意。</p>
</div>
<div class="paragraph">
<p>Raku 是渐近类型的。它主要遵循了动态类型化语言的范式，即接受那些在编译过程中无法保证类型安全的程序。然而，与许多动态语言不同的是，它接受并执行类型约束。在可能的情况下，编译器使用类型注解来在编译时做出决定，否则只有在运行时才有可能。</p>
</div>
<div class="paragraph">
<p>许多编程范式都影响了 Raku 。你可以在 Raku 中编写命令式、面向对象和函数式的程序。声明式编程的功能，如多重分派、子类型、regex 和 grammar 引擎等，都支持声明式编程。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，大部分的查询都是词法查询，而且语言避免了全局状态。这使得程序的并行和并发执行更加容易，Raku 对高级并发原语的关注也是如此。当你不希望被限制在一个 CPU 内核上时，你会考虑 Promise 和消息队列, 而不是考虑线程和锁。</p>
</div>
<div class="paragraph">
<p>Raku 作为一门语言，对于 Raku 程序应该被编译还是被解释的问题，Raku 是没有主见的。Raku 作为一种主要的实现, 可以快速编译模块并解释脚本。</p>
</div>
<div class="sect2">
<h3 id="_perl5_老天鹅">1.1. Perl5, 老天鹅</h3>
<div class="paragraph">
<p>在 2000 年左右，Perl 5 的发展面临着巨大的压力，面临着既要发展又要保持向后兼容的矛盾。</p>
</div>
<div class="paragraph">
<p>Raku 是释放这种压力的阀门。所有需要打破向后兼容性的扩展建议都被引导到了 Raku 中，使其处于梦幻般的状态，一切皆有可能，没有任何东西是固定的。经过几年的努力，Raku 才进入了一个比较稳固的状态。</p>
</div>
<div class="paragraph">
<p>在这段时间里，Perl 5 也在不断发展，这两种语言的差异性足够大，以至于大多数 Perl 5 的开发者不再认为 Raku 是一条自然的升级之路，以至于 Raku 并没有试图让 Perl 5 过时（至少不会比它试图让任何其他编程语言过时的程度更高：-），2015 年第一次稳定发布的 Raku 并没有表明对 Perl 5 的支持失效。</p>
</div>
<div class="paragraph">
<p>Perl 5 是由一个独立的爱好者社区开发的，他们一直关注着 Raku，寻找值得采纳到 Perl 5 中的功能，所以虽然 Perl 5 和 Raku 社区有一定的重叠和交流，但两者都是独立发展的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_库的可用性">1.2. 库的可用性</h3>
<div class="paragraph">
<p>作为一种相对年轻的语言，Raku 缺乏像 Perl 5 和 Python 这样的语言所提供的成熟的模块生态系统。</p>
</div>
<div class="paragraph">
<p>为了弥补这个差距，就有了接口，你可以调用用 C、Python、Perl 5 和 Ruby 编写的库。Perl 5 和 Python 的接口足够复杂，你可以编写一个 Raku 的类，它可以子类化用这两种语言编写的类，反之亦然。</p>
</div>
<div class="paragraph">
<p>因此，如果你喜欢某个特定的 Python 库，你可以通过 <code>Inline::Python</code> 模块将其加载到你的 Raku 程序中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_我为什么要使用_raku">1.3. 我为什么要使用 Raku?</h3>
<div class="paragraph">
<p>如果你喜欢动态类型化的编程语言所带来的快速原型开发体验，同时又希望有足够的安全功能来构建大型的、可靠的应用程序，那么 Raku 是个不错的选择。它的渐进式类型让你可以在没有完全了解所涉及的类型的情况下编写代码，以后还可以引入类型约束，防止将来内部和外部 API 被滥用。</p>
</div>
<div class="paragraph">
<p>Perl 在通过正则表达式(regexes)来处理文本的历史悠久，但比较复杂的 regexes 却有一个很难读和维护的名声。Raku 解决了这一问题，它将 regex 与代码放在同一层次上，允许你把它们像子程序一样命名，甚至可以使用类继承和角色组成等面向对象的特性来管理代码和 regex 重用。由此产生的 grammar 非常强大，也很容易读懂。事实上，Raku 编译器就是用 Raku 的 grammar 来解析 Raku 的源码的!</p>
</div>
<div class="paragraph">
<p>说到文本，Raku 有惊人的 Unicode 支持。如果你要求用户输入一个数字，而他们输入的数字不是 ASCII 范围内的阿拉伯数字，那么 Raku 仍然可以满足你的要求。如果你处理的是不能用一个单一的 Unicode 代码点来表示的字素，Raku 仍然可以将其作为一个单一的字符来表示。</p>
</div>
<div class="paragraph">
<p>有更多的技术优势，我可以列举出来，但更重要的是，这套语言的设计是为了让用户使用起来更有趣。其中一个重要的方面就是良好的错误信息。你是否曾对 Python 感到恼火过，因为当出现错误时，通常只给出了 SyntaxError: invalid syntaxError: invalid syntax 语法。例如，这个错误可能来自于忘记了结尾的括号。在这种情况下，Raku 编译器会打印出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Unable to parse expression in argument list; couldn't find final ')'</code></pre>
</div>
</div>
<div class="paragraph">
<p>这实际上告诉你什么是错的。但这只是冰山一角。编译器可以捕捉到常见的错误，并指出可能的解决方案，甚至还建议对拼写错误进行修复。Raku 社区认为那些 <strong>less than awesome,</strong> 的错误信息，即 LTA，是值得报告的错误信息，并在提高错误信息的标准上花了很多精力。</p>
</div>
<div class="paragraph">
<p>最后，Raku 给了你自由，可以用不同的方式和不同的编程范式来表达你的问题域和解决方案。如果核心语言提供的选项还不够多，那么它在设计时就考虑到了可扩展性，让你既可以引入新的面向对象代码的语义，也可以引入新的语法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结">1.4. 总结</h3>
<div class="paragraph">
<p>Raku 是一种灵活的编程语言，它为初学者和专家提供了许多酷炫而方便的功能。它提供了灵活性，类型检查，以及强大的 Unicode 和文本处理支持。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_运行_raku">2. 运行 Raku</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在我们开始探索 Raku 之前，你应该先有一个环境，在这个环境中你可以运行 Raku 代码。所以你需要安装 Raku，这是目前唯一一个积极开发的 Raku 编译器。或者更好的方法是安装 Rakudo Star，这是一个包含 Rakudo 本身、一些有用的模块和一个可以帮助你安装更多模块的工具的发行版。</p>
</div>
<div class="paragraph">
<p>安装 Rakudo 本身只给你提供了编译器。它遵循每月发布周期，所以它可以让你跟上最新的发展。当你选择安装 Rakudo Star 时，通常每隔一段时间就会发布一次。三个月后，你会得到一个比较稳定的开发基础，还有一些工具，比如调试器和模块安装程序。您可以使用模块安装程序来利用预装的软件库，这些库既不包含在 Rakudo 本身，也不包含在 Rakudo Star 中。</p>
</div>
<div class="paragraph">
<p>下面的章节将讨论安装 Rakudo Star 的几个选项。选择任何适合你的方法。</p>
</div>
<div class="paragraph">
<p>本书中的示例使用 Rakudo 2017.04.03 或 Rakudo Star 2017.04（Rakudo Star 2017.04.03 是建立在 Rakudo 2017.04.03 的基础上），只要它支持 Raku 版本 6.c，就应该与此版本或任何更新的 Rakudo 版本一起工作。</p>
</div>
<div class="sect2">
<h3 id="_安装器">2.1. 安装器</h3>
<div class="paragraph">
<p>你可以从 <a href="https://rakudo.org/downloads" class="bare">https://rakudo.org/downloads</a> 下载安装程序，用于 Mac OS(.dmg) 和 Windows(.msi)。下载后，你可以启动它们，它们会引导你完成安装过程。</p>
</div>
<div class="paragraph">
<p>预建的 Linux 软件包可以从 <a href="https://github.com/nxadm/rakudo-pkg/releases/" class="bare">https://github.com/nxadm/rakudo-pkg/releases/</a> 中获得，用于 Debian、Ubuntu、CentOS 和 Fedora 等等。在这两种情况下，请使用 2017.04 版本，以获得与本书中使用的示例的最佳兼容性。</p>
</div>
<div class="paragraph">
<p>注意，Rakudo 是不可移动的，这意味着你必须安装到安装程序的创建者决定的固定位置。将安装程序移动到不同的目录是不可能的。</p>
</div>
<div class="paragraph">
<p>在 Windows 上，安装程序（图 2-1）提供了将 <code>C:\rakudo\share\bin</code> 和 <code>C:\rakudo\share</code> 添加到你的 PATH 环境中。你应该选择这个选项，因为它允许你执行 Rakudo raku (和模块安装程序代表你安装的程序)，而不需要指定完整的路径。</p>
</div>
</div>
<div class="sect2">
<h3 id="_docker">2.2. Docker</h3>
<div class="paragraph">
<p>在支持 Docker 的平台上，您可以从 docker hub 中拉取一个现有的 Docker 容器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ docker pull rakudo-star</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以使用这个命令获取一个交互式的 Rakudo shell：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ docker run -it rakudo-star raku:2017.04</code></pre>
</div>
</div>
<div class="paragraph">
<p>但仅靠这个命令是无法执行脚本的，因为容器有自己独立的文件系统。要使容器内的脚本可用，你需要告诉 Docker 使当前的目录对容器可用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ docker run -v $PWD:/raku -w /raku -it rakudo-star raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>选项 <code>-v $PWD:/raku</code> 指示 Docker 将当前的工作目录(<code>$PWD</code>) 挂载到容器中，在那里它将作为 <code>/raku</code> 可用。为了使相对路径起作用，<code>-w /raku</code> 指示 Docker 将 Rakudo 进程的工作目录设置为 <code>/raku</code>。</p>
</div>
<div class="paragraph">
<p>由于这条命令行开始变得笨重，所以我创建了一个别名（这是 Bash 语法，其他的 shell 可能会有稍微不同的别名机制）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">alias p6d='docker run -v $PWD:/raku -w /raku -it rakudo-star raku'</code></pre>
</div>
</div>
<div class="paragraph">
<p>我把这一行放到了我的 <code>~/.bashrc</code> 文件中，所以新的 shell 实例有一个 p6d 命令，简称 "Raku docker"。</p>
</div>
<div class="paragraph">
<p>作为一个简短的测试，看看它是否有效，你可以运行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ p6d -e 'say "hi"'
hi</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你使用 Docker 路由，请使用 p6d 别名而不是 raku 来运行脚本。</p>
</div>
</div>
<div class="sect2">
<h3 id="_从源代码创建">2.3. 从源代码创建</h3>
<div class="paragraph">
<p>要从源码构建 Rakudo Star，你需要安装 make，GNU C 编译器<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup> (GCC)，或者 clang 和 Perl 5。这个例子安装到 <code>$HOME/opt/rakudo-star</code> 中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ wget https://rakudo.org/dl/star/rakudo-star-2017.04.tar.gz
tar.gz
$ tar xzf rakudo-star-2017.04.tar.gz
$ cd rakudo-star-2017.04/
$ perl Configure.pl --prefix=$HOME/opt/rakudo-star --gen-moar
$ make install</code></pre>
</div>
</div>
<div class="paragraph">
<p>你应该有大约 2GB 的内存来做最后一步；构建编译器是一项资源密集型的工作。</p>
</div>
<div class="paragraph">
<p>你需要在你的 PATH 环境变量中添加到两个目录的路径，一个是 Rakudo 本身，一个是模块安装程序安装的程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">PATH=$PATH:$HOME/opt/rakudo-star/bin/:$HOME/opt/rakudo-star/share/raku/site/bin</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你是 Bash 用户，你可以把这一行放到你的 <code>∼/.bashrc</code> 文件中，让它在新的 Bash 进程中可用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_测试你的_rakudo_star_安装">2.4. 测试你的 Rakudo Star 安装</h3>
<div class="paragraph">
<p>现在你应该可以在命令行中运行 Raku 程序，并询问 Rakudo 的版本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku --version
This is Rakudo version 2017.04.2 built on MoarVM version 2017.04
implementing Raku.c.

$ raku -e "say &lt;hi&gt;"
hi</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果所有这些方法都无法产生一个可用的 Rakudo 安装，你应该向友好的 Raku 社区描述你的问题，他们通常可以提供一些帮助。<a href="https://raku.org/community/" class="bare">https://raku.org/community/</a>  描述了与社区互动的方式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_文档">2.5. 文档</h3>
<div class="paragraph">
<p>Rakudo 本身没有什么文档，因为大部分有趣的资料都是关于 Raku 语言的。但 Rakudo 确实有一个命令行选项的摘要，你可以通过调用 raku --help 来访问。</p>
</div>
<div class="paragraph">
<p>Raku 语言文档的官方网址是 <a href="https://docs.raku.org/" class="bare">https://docs.raku.org/</a>，它的目的是提供参考和教程式的资料。其他的好资源可以在 <a href="https://raku.org/resources/" class="bare">https://raku.org/resources/</a> 中找到，其中很多是由 Raku 社区的成员创建和维护的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_2">2.6. 总结</h3>
<div class="paragraph">
<p>在大多数平台上，您可以从预建的二进制安装程序中安装 Rakudo Star。如果无法使用，可以使用 Docker 映像。最后，Rakudo Star 可以从它的源码中构建 Rakudo Star。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_格式化数独字谜">3. 格式化数独字谜</h2>
<div class="sectionbody">
<div class="paragraph">
<p>作为 Raku 的温柔介绍，让我们考虑一下我最近在追求自己的一个爱好时遇到的一个小任务。</p>
</div>
<div class="paragraph">
<p>数独是在一个 9×9 的网格上玩的一种数字放置谜题，它被细分为 3×3 的方块（图3-1）。有的单元格里填上1到9的数字，有的单元格是空的。游戏的目的是填空单元格，使每一行、每一列和每一个 3×3 的单元格中，从1到9的每一个数字都刚好出现一次。</p>
</div>
<div class="paragraph">
<div class="title">未解的数独字谜</div>
<p>一个有效的数独的存储格式简单来说就是一个81个字符的字符串，0代表空单元格，数字1到9代表预填充单元格。我想解决的任务是把它变成一种更友好的格式。</p>
</div>
<div class="paragraph">
<p>输入的格式可以是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">000000075000080094000500600010000200000900057006003040001000023080000006063240000</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来是我们的第一个 Raku 程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># file sudoku.p6
use v6;
my $sudoku = '000000075000080094000500600010000200000900057006003040001000023080000006063240000';
for 0..8 -&gt; $line-number {
    say substr $sudoku, $line-number * 9, 9;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以这样运行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku sudoku.p6
000000075
000080094
000500600
010000200
000900057
006003040
001000023
080000006
063240000</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里面没有什么神奇的地方，但让我们逐行看一下代码。第一行，以 <code>#</code> 开头，是一个注释，一直延伸到行尾。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一行并不是严格意义上的必须，但也是很好的做法。它声明了你所使用的 Perl 版本，这里是 <code>v6</code>；换句话说，就是任何版本的  Raku  语言。我们可以说得更具体一些，使用 <code>v6.c</code> 来要求使用这里讨论的版本。如果你不小心用 Perl 5 运行了 Raku 程序，你会很高兴你包含了这一行，因为它会告诉你以下内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ perl sudoku.p6
Perl v6.0.0 required--this is only v5.22.1, stopped at sudoku.p6 line 1. BEGIN failed--compilation aborted at sudoku.p6 line 1.</code></pre>
</div>
</div>
<div class="paragraph">
<p>而不是更隐晦的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">syntax error at sudoku.p6 line 4, near "for 0"
Execution of sudoku.p6 aborted due to compilation errors.</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一行有趣的是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sudoku = '00000007500...';</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>my</code> 声明了一个词法变量，它从声明点到当前作用域的末尾都是可见的。它从声明点开始到当前作用域的末尾都是可见的，也就是说，它可以是当前区块的末尾，如果它在任何区块之外，则是文件的末尾，就像本例中的情况一样。</p>
</div>
<div class="paragraph">
<p>变量的开头是一个 sigil，这里是 <code>$</code>，sigil 是 Perl 的名词，它让 Perl 有了行噪声的名声，但噪声中也有信号。这个 <code>$</code> 看起来像一个 S，代表标量。如果你懂得一些数学知识，你会知道标量只是一个单一的值，而不是向量甚至是矩阵。</p>
</div>
<div class="paragraph">
<p>这个变量开始时并不是空的，因为在它的旁边有一个初始化。它开始时的值是一个字符串的字段，如引号所示。</p>
</div>
<div class="paragraph">
<p>需要注意的是，除了"它是一个标量"这个非常模糊的符号所暗示的"它是一个标量 "之外，我们不需要声明变量的类型。如果我们愿意，我们可以添加一个类型约束。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Str $sudoku = '00000007500...';</code></pre>
</div>
</div>
<div class="paragraph">
<p>但在快速原型设计时，我往往会放弃类型约束，因为我往往还不知道代码到底会如何运行。</p>
</div>
<div class="paragraph">
<p>实际的逻辑发生在接下来的几行中，通过迭代0到8的行数来实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 0..8 -&gt; $line-number {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>for 循环具有 ITERABLE BLOCK 的一般结构。这里的 iterable 是一个范围<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>，块是一个尖号块。该块以 <code>&#8594;</code> 开头，引入了一个签名。这个签名告诉编译器这个块期望有哪些参数，这里是一个单一的标量，叫做 <code>$line-number</code>。</p>
</div>
<div class="paragraph">
<p>Raku 允许使用破折号 <code>-</code> 或单引号 <code>'</code> 将多个简单的标识符连接成一个大的标识符。这意味着只要下面的字符是字母或下划线，就可以在标识符中使用。</p>
</div>
<div class="paragraph">
<p>同样，类型约束是可选的。如果你选择了包含它们，它会是 <code>for 0..8 &#8594; Int $line-number { &#8230;&#8203; }</code>。</p>
</div>
<div class="paragraph">
<p><code>$line-number</code> 又是一个词法变量，在签名后的块中可见。块由大括号分隔。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say substr $sudoku, $line-number * 9, 9;</code></pre>
</div>
</div>
<div class="paragraph">
<p>say<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup> 和 substr<sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup> 都是 Raku 标准库提供的函数。</p>
</div>
<div class="paragraph">
<p><code>substr($string, $from, $num-chars)</code> 从 <code>$string</code> 中提取一个子字符串。它从一个基于零的索引 <code>$from</code> 开始，取 <code>$num-chars</code> 指定的字符数。哦，在 Raku 中，一个字符是真正的一个字符，即使它是由多个代码点组成的，比如重音罗马字母。</p>
</div>
<div class="paragraph">
<p><code>say</code> 然后打印出这个子字符串，然后是一个断行符。</p>
</div>
<div class="paragraph">
<p>从这个例子中可以看到，函数调用不需要括号，不过如果你想的话，可以加括号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say substr($sudoku, $line-number * 9, 9);</code></pre>
</div>
</div>
<div class="paragraph">
<p>或甚至:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say(substr($sudoku, $line-number * 9, 9));</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_让数独变得可玩">3.1. 让数独变得可玩</h3>
<div class="paragraph">
<p>就像我们现在的脚本输出一样，即使你把它印在纸上，也不能玩出数独的结果。所有这些讨厌的零都会妨碍你真正输入你精心推导出来的数字!</p>
</div>
<div class="paragraph">
<p>所以，让我们把每个0换成空白，这样你就可以解开谜题了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># file sudoku.p6
use v6;
my $sudoku = '000000075000080094000500600010000200000900057006003040001000023080000006063240000';
$sudoku = $sudoku.trans('0' =&gt; ' ');
for 0..8 -&gt; $line-number {
    say substr $sudoku, $line-number * 9, 9;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>trans<sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup> 是 Str 类中的一个方法，它的参数是一个 Pair<sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup>。创建一个 Pair 的方法是 <code>Pair.new('0', ' ')</code>，但是因为它很常用，所以有一个快捷方式，就是用胖箭头形式，<code>&#8658;</code>。方法 <code>trans</code> 将每一次出现的 pair 的键替换成 pair 的值，然后返回生成的字符串。</p>
</div>
<div class="paragraph">
<p>说到快捷方式，你还可以把 <code>$sudoku.trans(&#8230;&#8203;)</code> 缩短为 <code>$sudoku.=$sudoku.trans(&#8230;&#8203;)</code>。这是一个通用的模式，将返回结果的方法变成了 mutator。</p>
</div>
<div class="paragraph">
<p>用新的字符串替换，结果是可以玩的，但很难看。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku sudoku.p6
       75
     8 94
    5 6
   1  2
    9  57
   6 3 4
   1   23
   8    6
   6324</code></pre>
</div>
</div>
<div class="paragraph">
<p>一点点 ASCII 艺术让它变得可以忍受：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">+---+---+---+
|   | 1 |   |
|   |   |79 |
|  9|   |4  |
+---+---+---+
|   | 4 | 5 |
|   |   | 2 |
| 3 | 29|18 |
+---+---+---+
|  4| 87|2  |
|  7| 2 |95 |
| 5 | 3 | 8 |
+---+---+---+</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了得到垂直的分割线，我们需要将这些线细分为更小的块。而既然我们已经有了一次将字符串分成固定大小的小字符串的机会，那么我们就需要将其封装成一个函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub chunks(Str $s, Int $chars) {
    gather loop (my $idx = 0; $idx &lt; $s.chars; $idx += $chars) {
        take substr($s, $idx, $chars); }
    }

for chunks($sudoku, 9) -&gt; $line {
    say chunks($line, 3).join('|');
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku sudoku.p6
   |   | 75
   | 8 | 94
   |5  |6
 1 |   |2
   |9  | 57
  6|  3| 4
  1|   | 23
  8|   | 6
63 |24 |</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，它是怎么做到的呢？嗯，<code>sub (SIGNATURE) BLOCK</code> 声明了一个子例程，简称 sub。在这里我声明它要接收两个参数，由于我很容易混淆我调用函数的参数顺序，所以我添加了类型约束，使 Raku 很有可能为我捕捉到这个错误。</p>
</div>
<div class="paragraph">
<p><code>gather</code> 和 <code>take</code> 一起工作是为了创建一个列表， <code>gather</code> 是入口点，每执行一次 <code>take</code> 就会在列表中增加一个元素。所以:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">gather {
    take 1;
    take 2;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将返回列表 <code>1, 2</code>。这里 <code>gather</code> 作为语句前缀，意味着它收集了循环中的所有取值。</p>
</div>
<div class="paragraph">
<p><code>loop</code> 语句的形式为 <code>loop (INITIAL, CONDITION, POST) BLOCK</code>，其工作原理类似于 C 语言和相关语言中的 for 循环。它首先执行 INITIAL，然后在 CONDITION 为真时，先执行 BLOCK，然后执行 POST。</p>
</div>
<div class="paragraph">
<p>一个子例程返回最后一个表达式<sup class="footnote">[<a id="_footnoteref_7" class="footnote" href="#_footnotedef_7" title="View footnote.">7</a>]</sup>的值，这里是上面讨论的 <code>gather loop &#8230;&#8203;</code> 构造。</p>
</div>
<div class="paragraph">
<p>再回到程序中，现在的 for 循环看起来是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for chunks($sudoku, 9) -&gt; $line {
    say chunks($line, 3).join('|');
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，程序会将整个数独字符串切成 9 个字符的行，然后将每一行切成 3 个字符串，每个字符串的长度为 3 个字符。join<sup class="footnote">[<a id="_footnoteref_8" class="footnote" href="#_footnotedef_8" title="View footnote.">8</a>]</sup> 方法把它变成了一个字符串，但在块之间插入了管道符号。</p>
</div>
<div class="paragraph">
<p>在这一行的开头和结尾还缺少竖直条，这可以通过改变最后一行来很容易地进行硬编码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '|', chunks($line, 3).join('|'), '|';</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在输出是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">|   |   | 75|
|   | 8 | 94|
|   |5  |6  |
| 1 |   |2  |
|   |9  | 57|
| 6 | 3 | 4 |
| 1 |   | 23|
| 8 |   | 6 |
| 63|24 |   |</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 缺少的只是横线，这并不是太难添加:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $separator = '+---+---+---+';
my $index = 0;
for chunks($sudoku, 9) -&gt; $line {
    if $index++ %% 3 {
        say $separator;
    }
    say '|', chunks($line, 3).join('|'), '|';
}
say $separator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">+---+---+---+
|   |   | 75|
|   | 8 | 94|
|   |5  |6  |
+---+---+---+
| 1 |   |2  |
|   |9  | 57|
|  6|  3| 4 |
+---+---+---+
|  1|   | 23|
| 8 |   |  6|
| 63|24 |   |
+---+---+---+</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里有一些新的方面：<code>if</code> 条件，这在结构上很像 <code>for</code> 循环，还有整除运算符 <code>%%</code> 。在其他编程语言中，你可能知道 <code>%</code> 代表取模，但由于 <code>$number
% $divisor == 0</code> 是一个常见的模式，所以 <code>$number %% $divisor</code> 是 Raku 对它的快捷方式。</p>
</div>
<div class="paragraph">
<p>最后，你可能在 C 语言或 Perl 5 等编程语言中知道 <code>++</code> 后缀运算符，它可以将变量增量 1，但返回旧值，所以:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 0;
say $x++;
say $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先打印0然后打印1。</p>
</div>
</div>
<div class="sect2">
<h3 id="_捷径常量和更多的捷径">3.2. 捷径、常量和更多的捷径</h3>
<div class="paragraph">
<p>Raku是以人类语言为模型的，人类语言内置了某种压缩方案，常用的单词往往很短，常见的结构有快捷方式。
因此，有很多方法可以更简洁地编写代码。 第一个基本上是作弊，因为子块可以用Str类中的内置方法替换，comb：</p>
</div>
<div class="paragraph">
<p>Raku 是以人类语言为蓝本，人类语言内置了某种压缩方案，其中常用的单词往往比较短，常用的构造物也有快捷键。</p>
</div>
<div class="paragraph">
<p>因此，有很多方法可以把代码写得更简洁。第一种方法基本上是作弊，因为 <code>sub chunks</code> 可以用 Str 类中的内置方法 `comb`<sup class="footnote">[<a id="_footnoteref_9" class="footnote" href="#_footnotedef_9" title="View footnote.">9</a>]</sup> 代替：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># file sudoku.p6
use v6;

my $sudoku = '000000075000080094000500600010000200000900057006003040001000023080000006063240000';
$sudoku = $sudoku.trans('0' =&gt; ' ');
my $separator = '+---+---+---+';
my $index = 0;
for $sudoku.comb(9) -&gt; $line {
    if $index++ %% 3 {
        say $separator;
    }
    say '|', $line.comb(3).join('|'), '|';
}
say $separator;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>if</code> 条件可以作为语句后缀应用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $separator if $index++ %% 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了初始化之外，变量 <code>$index</code> 只使用一次，所以不需要给它起名字。是的，Raku 有匿名变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $separator = '+---+---+---+'; for $sudoku.comb(9) -&gt; $line {
say $separator if $++ %% 3;
    say '|', $line.comb(3).join('|'), '|';
}
say $separator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <code>$separator</code> 是常量，我们可以将它声明为：</p>
</div>
<div class="paragraph">
<p>如果你想降低线路噪声因子，你也可以放弃这个sigil，所以恒定的separator ='&#8230;&#8203;'。
最后，有一个带参数的方法调用的另一种语法：而不是$ obj.method（args），你可以说$ obj.method：args，它将我们带到了小型数独格式化程序的惯用形式：</p>
</div>
<div class="paragraph">
<p>因为 <code>$separator</code> 是一个常数，所以我们可以把它声明为一个常数。</p>
</div>
<div class="paragraph">
<p>如果你想降低行噪声系数，也可以放弃 sigil，所以常量 <code>separator='&#8230;&#8203;'</code>。</p>
</div>
<div class="paragraph">
<p>最后，对于带参数的方法调用，还有另一种语法：你可以使用 <code>$obj.method: args</code> 代替 <code>$obj.method(args)</code>，这就给我们引出了成语形式的数独格式化。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># file sudoku.p6
use v6;

my $sudoku = '000000075000080094000500600010000200000900057006003040 001000023080000006063240000';
$sudoku = $sudoku.trans: '0' =&gt; ' ';

constant separator = '+---+---+---+';
for $sudoku.comb(9) -&gt; $line {
    say separator if $++ %% 3;
    say '|', $line.comb(3).join('|'), '|';
}
say separator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些对 Raku 代码的修改，输出的内容没有变化。</p>
</div>
</div>
<div class="sect2">
<h3 id="_io_和其它悲剧">3.3. IO 和其它悲剧</h3>
<div class="paragraph">
<p>一个实用的脚本不会把输入作为硬编码的字符串字段，而是从命令行、标准输入或文件中读取。</p>
</div>
<div class="paragraph">
<p>如果你想从命令行读取数独，你可以声明一个叫 MAIN 的子程序，它可以获取所有传入的命令行参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># file sudoku.p6
use v6;

constant separator = '+---+---+---+';

sub MAIN($sudoku) {
    my $substituted = $sudoku.trans: '0' =&gt; ' ';

    for $substituted.comb(9) -&gt; $line {
        say separator if $++ %% 3;
        say '|', $line.comb(3).join('|'), '|';
    }
    say separator;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是它如何被调用的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku-m sudoku-format-08.p6 0000000750000800940005006000100002000009 00057006003040001000023080000006063240000</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">+---+---+---+
|   |   | 75|
|   | 8 | 94|
|   |5  |6  |
+---+---+---+
| 1 |   |2  |
|   |9  | 57|
|  6|  3| 4 |
+---+---+---+
|  1|   | 23|
| 8 |   |  6|
| 63|24 |   |
+---+---+---+</code></pre>
</div>
</div>
<div class="paragraph">
<p>而且，如果你用错了，甚至可以免费得到一个使用信息，比如省略了参数，就可以得到一个使用信息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku-m sudoku.p6
Usage:
  sudoku.p6 &lt;sudoku&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可能已经注意到，最后一个例子中的替换数独字符串使用了一个单独的变量。这是因为函数参数（签名中声明的变量）默认是只读的。与其创建一个新的变量，我还可以写成 <code>sub MAIN($sudoku is copy) { &#8230;&#8203;}</code>.</p>
</div>
<div class="paragraph">
<p>经典的 UNIX 程序，如 cat 和 wc，都遵循了从命令行中给出的文件名中读取输入的惯例，如果命令行中没有给出文件名，则从标准输入中读取。</p>
</div>
<div class="paragraph">
<p>如果你想让你的程序遵循这个惯例， <code>lines()</code> 提供了一个从这两个来源中的任何一个来源读取行的流。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># file sudoku.p6
use v6;

constant separator = '+---+---+---+';

for lines() -&gt; $sudoku {
    my $substituted = $sudoku.trans: '0' =&gt; ' ';

    for $substituted.comb(9) -&gt; $line {
        say separator if $++ %% 3;
        say '|', $line.comb(3).join('|'), '|';
    }
    say separator;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_获得创造性">3.4. 获得创造性</h3>
<div class="paragraph">
<p>你不会从书本上学习一门编程语言，你必须实际使用它，修修补补它。如果你想在前面讨论的例子基础上进行扩展，我鼓励你尝试用不同的输出格式来制作数独。</p>
</div>
<div class="paragraph">
<p>SVG<sup class="footnote">[<a id="_footnoteref_10" class="footnote" href="#_footnotedef_10" title="View footnote.">10</a>]</sup> 是一种基于文本的矢量图形格式，它提供了渲染数独所需的所有原语：矩形、线条、文本等等。如果你想用较少的精力获得相对较好的输出，你可以使用它。</p>
</div>
<div class="paragraph">
<p>这是一个数独的 SVG 文件的粗略骨架。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/ Graphics/SVG/1.1/DTD/svg11.dtd"&gt;
&lt;svg width="304" height="304" version="1.1" xmlns="http://www.w3.org/2000/svg"&gt;
&lt;line x1="0" x2="300" y1="33.3333" y2="33.3333" style="stroke:grey" /&gt;
&lt;line x1="0" x2="300" y1="66.6667" y2="66.6667" style="stroke:grey" /&gt;
&lt;line x1="0" x2="303" y1="100" y2="100" style="stroke:black; stroke-width:2"/&gt;
&lt;line x1="0" x2="300" y1="133.333" y2="133.333" style="stroke:grey" /&gt;
    &lt;!-- more horizontal lines here --&gt;
&lt;line y1="0" y2="300" x1="33.3333" x2="33.3333" style="stroke:grey" /&gt;
&lt;!-- more vertical lines here --&gt;
&lt;text x="43.7333" y="124.5"&gt; 1 &lt;/text&gt;
&lt;text x="43.7333" y="257.833"&gt; 8 &lt;/text&gt;
&lt;!-- more cells go here --&gt;
&lt;rect width="304" height="304" style="fill:none;stroke-width: 1;stroke:black;stroke-width:6"/&gt;
&lt;/svg&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你有 Firefox 或 Chrome 浏览器或专用的矢量图形程序如 Inkscape<sup class="footnote">[<a id="_footnoteref_11" class="footnote" href="#_footnotedef_11" title="View footnote.">11</a>]</sup>，你可以用它来打开 SVG 文件（图3-2）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_3">3.5. 总结</h3>
<div class="paragraph">
<p>第一个 Raku 的例子介绍了字素、变量和控制流。</p>
</div>
<div class="paragraph">
<p>你也看到了基本的输入和输出原语，以及 MAIN 子程序，它可以让你轻松地接受命令行参数。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_日期时间转换命令行">4. 日期时间转换命令行</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我偶尔会在工作中使用数据库，它将日期和时间存储为 UNIX 时间戳，也就是 1970-01-01 午夜后的秒数。与数据库的原作者和周围的代码不同，我无法在脑子里进行 UNIX 时间戳和人类可读的日期格式之间的转换，所以我为此写了一些工具。</p>
</div>
<div class="paragraph">
<p>我们这里的目标是写一个小工具，在 UNIX 时间戳和日期/时间之间来回转换。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ autotime 2015-12-24
1450915200
$ autotime 2015-12-24 11:23:00
1450956180
$ autotime 1450915200
2015-12-24
$ autotime 1450956180
2015-12-24 11:23:00
----</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_使用库">4.1. 使用库</h3>
<div class="paragraph">
<p>日期和时间算术是很难搞好的，同时又很无聊，所以我很乐意把这部分工作交给库来做。</p>
</div>
<div class="paragraph">
<p>Raku 的核心库中包含了 DateTime<sup class="footnote">[<a id="_footnoteref_12" class="footnote" href="#_footnotedef_12" title="View footnote.">12</a>]</sup> (有点受 Perl 5 的同名模块的启发)和 Date<sup class="footnote">[<a id="_footnoteref_13" class="footnote" href="#_footnotedef_13" title="View footnote.">13</a>]</sup> (主要是从 Perl 5 的 Date:::Simple 模块中偷来的)。这两个模块将处理实际的转换。我们的重点将是为转换的输入和输出创建一个友好的用户体验。</p>
</div>
<div class="paragraph">
<p>对于从 UNIX 时间戳到日期或时间的转换，<code>DateTime.new</code> 构造函数就派上了用场。它有一个变体，可以接受一个整数作为 UNIX 时间戳。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku -e "say DateTime.new(1480915200)"
2016-12-05T05:20:00Z</code></pre>
</div>
</div>
<div class="paragraph">
<p>看来我们这个方向就快结束了，对吧？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku
sub MAIN (Int $timestamp) {
    say DateTime.new($timestamp)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们来运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ autotime 1450915200
Invalid DateTime string '1450915200'; use an ISO 8601 timestamp (yyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+01:00) instead
  in sub MAIN at autotime line 2
  in block &lt;unit&gt; at autotime line 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>哦，不对，怎么了？似乎 <code>DateTime</code> 构造函数把参数看作是一个字符串，尽管 <code>sub MAIN</code> 的参数声明为 <code>Int</code>，怎么会这样呢？让我们来补充一些调试输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku
sub MAIN(Int $timestamp) {
    say $timestamp.^name;
    say DateTime.new($timestamp)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在用和之前一样的调用运行它，在错误之前多了一行输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">IntStr</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$thing.ˆname</code> 是对 <code>$thing</code> 的元类的一个方法的调用，<code>name</code> 请求它的名称（换句话说，就是类的名称）。IntStr<sup class="footnote">[<a id="_footnoteref_14" class="footnote" href="#_footnotedef_14" title="View footnote.">14</a>]</sup>是 Int 和 Str 的一个子类，这就是为什么 <code>DateTime</code> 构造函数合法地认为它是 Str 的原因。在命令行参数传递给 MAIN 之前，解析命令行参数的机制是将命令行中的字符串转换为 IntStr 而不是 Str，以避免在我们想把它当作字符串的时候丢失信息。</p>
</div>
<div class="paragraph">
<p>长话短说，我们可以通过加一个 <code>+</code> 前缀来强行将参数转化为"实数"整数，这是一般的数值转换机制。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku
sub MAIN(Int $timestamp) {
    say DateTime.new(+$timestamp)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>快速测试后发现，现在可以用了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ ./autotime-01.p6 1450915200
2015-12-24T00:00:00Z</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出的是 ISO 8601 时间戳格式<sup class="footnote">[<a id="_footnoteref_15" class="footnote" href="#_footnotedef_15" title="View footnote.">15</a>]</sup>，这可能不是最容易看懂的。对于一个日期（时、分、秒为零时），我们真的只需要日期。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku
sub MAIN(Int $timestamp) {
    my $dt = DateTime.new(+$timestamp);
    if $dt.hour == 0 &amp;&amp; $dt.minute == 0 &amp;&amp; $dt.second == 0 {
        say $dt.Date;
    }
    else {
        say $dt;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样看起来更好一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ ./autotime 1450915200
2015-12-24</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这个条件就有点笨拙了。真的，写三个和0进行比较的表达式吗？Raku 有一个很好的小功能，可以让你写得更紧凑。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if all($dt.hour, $dt.minute, $dt.second) == 0 {
    say $dt.Date;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>all(&#8230;&#8203;)</code> 创建了一个 Junction<sup class="footnote">[<a id="_footnoteref_16" class="footnote" href="#_footnotedef_16" title="View footnote.">16</a>]</sup>, 一个由其他几个值组成的复合值，它也存储了一个逻辑模式。当你将一个 Junction 与另一个值进行比较时，这个比较会自动应用到 Junction 中的所有值上。<code>if</code> 语句在布尔语境中对 Junction 进行求值，在这种情况下，只有当所有的比较都返回 <code>True</code> 时，才会返回 <code>True</code>。</p>
</div>
<div class="paragraph">
<p>其他类型的 Junction 还有：<code>any</code>、<code>all</code>、<code>none</code> 和 <code>one</code>。考虑到0是唯一一个在布尔语境中为 <code>false</code> 的整数，我们甚至可以把前面的语句写成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if none($dt.hour, $dt.minute, $dt.second) {
    say $dt.Date;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>很好，对吗？</p>
</div>
<div class="paragraph">
<p>但你不一定需要花哨的语言构造来写出简洁的程序。在这种情况下，从一个略微不同的角度来处理这个问题，会产生更短更清晰的代码。如果 <code>DateTime</code> 对象在不丢失信息的情况下往返转换到 <code>Date</code> 和返回到 <code>DateTime</code>，那它显然是一个 <code>Date</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $dt.Date.DateTime == $dt {
    say $dt.Date;
}
else {
    say $dt;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_datetime_格式化">4.2. DateTime 格式化</h3>
<div class="paragraph">
<p>对于一个没有解析为一整天的时间戳，我们的脚本的输出目前看起来像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">2015-12-24T00:00:01Z</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中的 "Z" 表示 UTC 或 "Zulu" 时区。相反，我希望它是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">2015-12-24 00:00:01</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DateTime</code> 类支持自定义格式化，所以我们来写一个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN(Int $timestamp) {
    my $dt = DateTime.new(+$timestamp, formatter =&gt; sub ($o) {
            sprintf '%04d-%02d-%02d %02d:%02d:%02d',
                    $o.year, $o.month,  $o.day,
                    $o.hour, $o.minute, $o.second,
    });
    if $dt.Date.DateTime == $dt {
        say $dt.Date;
    }
    else {
        say $dt.Str;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在输出看起来更好看了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">./autotime 1450915201
2015-12-24 00:00:01</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想以不同的格式输出，比如 <code>DD.MM.YYY</code>，你可以用你自己的格式字符串替换格式字符串。</p>
</div>
<div class="paragraph">
<p>语法 <code>formatter &#8658; &#8230;&#8203;</code> 在参数的上下文中表示一个命名的参数，这意味着名称而不是参数列表中的位置决定了要绑定到哪个参数。如果有一堆参数的话，这个很方便。</p>
</div>
<div class="paragraph">
<p>我不喜欢这样的代码了，因为 <code>formatter</code> 是在 <code>DateTime.new(&#8230;&#8203;)</code> 调用中内联的，我觉得不清楚。</p>
</div>
<div class="paragraph">
<p>让我们把这个作为一个单独的例程吧:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku
sub MAIN(Int $timestamp) {
    sub formatter($o) {
        sprintf '%04d-%02d-%02d %02d:%02d:%02d',
                $o.year, $o.month,  $o.day,
                $o.hour, $o.minute, $o.second,
    }
    my $dt = DateTime.new(+$timestamp, formatter =&gt; &amp;formatter);
    if $dt.Date.DateTime == $dt {
        say $dt.Date;
    }
    else {
        say $dt.Str;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>是的，你可以把一个子例程声明放在另一个子例程声明的正文中；子例程只是一个普通的词法符号，就像用 <code>my</code> 声明的变量一样。</p>
</div>
<div class="paragraph">
<p>在这行中，<code>my $dt = DateTime.new(+$timestamp, formatter &#8658; &amp;formatter);</code>，语法中的 <code>&amp;formatter</code> 指的是将子例程作为一个对象，而不是调用它。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，<code>formatter &#8658; &amp;formatter</code> 有一个快捷方式： <code>:&amp;formatter</code>。一般来说，如果你想填充一个命名参数，其名称是变量的名称，而其值是变量的值，你可以通过写 <code>:$variable</code> 来创建它。而引申一下，<code>:thing</code> 是 <code>thing &#8658; True</code> 的简写。</p>
</div>
</div>
<div class="sect2">
<h3 id="_寻找其他途径">4.3. 寻找其他途径</h3>
<div class="paragraph">
<p>现在，从时间戳到日期和时间的转换工作已经很顺利了，我们来看看另一个方向。我们的小工具需要对输入进行解析，并决定输入是时间戳还是日期，以及可选的时间。</p>
</div>
<div class="paragraph">
<p>无聊的方法就是使用条件转换。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN($input) {
    if $input ~~ / ^ \d+ $ / {
        # convert from timestamp to date/datetime
    }
    else {
        # convert from date to timestamp

    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但我讨厌无聊，所以我想看看更刺激（和可扩展）的方法。</p>
</div>
<div class="paragraph">
<p>Raku 支持多重分派。这意味着你可以有多个名字相同，但签名不同的子程序。而 Raku 会自动决定调用哪个子程序。你必须通过写`multi sub` 而不是 <code>sub</code> 来显式地启用这个功能，这样 Raku 就能为你捕获意外的重声明。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

multi sub MAIN(Int $timestamp) {
    sub formatter($o) {
        sprintf '%04d-%02d-%02d %02d:%02d:%02d',
                $o.year, $o.month,  $o.day,
                $o.hour, $o.minute, $o.second,
    }
    my $dt = DateTime.new(+$timestamp, :&amp;formatter);
    if $dt.Date.DateTime == $dt {
        say $dt.Date;
    }
    else {
        say $dt.Str;
    }
}


multi sub MAIN(Str $date) {
    say Date.new($date).DateTime.posix
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们来看看它的表现吧:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ ./autotime 2015-12-24
1450915200
$ ./autotime 1450915200
Ambiguous call to 'MAIN'; these signatures all match:
:(Int $timestamp)
:(Str $date)
  in block &lt;unit&gt; at ./autotime line 17</code></pre>
</div>
</div>
<div class="paragraph">
<p>不太符合我的设想。问题又来了，整数参数被自动转换为 IntStr，而 Int 和 Str multi（或候选）都接受这个参数。</p>
</div>
<div class="paragraph">
<p>要避免这个错误，最简单的方法是缩小 Str 候选者接受的字符串种类。经典的方法是使用一个可以大致验证传入参数的 regex。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN(Str $date where /^ \d+ \- \d+ \- \d+ $ /) {
    say Date.new($date).DateTime.posix
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上，它确实有效，但为什么要重复 <code>Date.new</code> 已经有的验证日期字符串的逻辑？如果你传递一个看起来不像日期的字符串参数，你会得到这样的错误。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Invalid Date string 'foobar'; use yyyy-mm-dd instead</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以用这种行为来约束 <code>MAIN multi</code> 候选者的字符串参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN(Str $date where { try Date.new($_) }) {
    say Date.new($date).DateTime.posix
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里额外的 <code>try</code> 是因为 <code>where</code> 后面的子类型约束不应该抛出一个异常，只是返回一个假值。</p>
</div>
<div class="paragraph">
<p>而现在它的工作原理和预期的一样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ ./autotime 2015-12-24;
1450915200
$ ./autotime 1450915200
2015-12-24</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_处理时间">4.4. 处理时间</h3>
<div class="paragraph">
<p>唯一需要实现的功能就是将日期和时间转换为时间戳。换句话说，我们要处理像 <code>autotime 2015-12-24 11:23:00</code> 这样的调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN(Str $date where { try Date.new($_) }, Str $time?) {
    my $d = Date.new($date);
    if $time {
        my ( $hour, $minute, $second ) = $time.split(':');
        say DateTime.new(date =&gt; $d, :$hour, :$minute, :$second).posix;
    }
    else {
        say $d.DateTime.posix;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为后面的 <code>?</code> 的存在, 新的第二个参数是可选的。我们在冒号上拆分时间字符串，得到小时、分钟和秒。在写这段代码的时候，我的第一直觉是使用更短的变量名, <code>my ($h, $m, $s) = $time.split(':')</code>, 但这样对 <code>DateTime</code> 构造函数的调用就会是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">DateTime.new(date =&gt; $d, hour =&gt; $h, minute =&gt; $m, second =&gt; $s);</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以，构造函数的命名参数让我选择了更多的自解释变量名。</p>
</div>
<div class="paragraph">
<p>所以，这样就成功了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">./autotime 2015-12-24 11:23:00
1450956180</code></pre>
</div>
</div>
<div class="paragraph">
<p>而且我们还可以检测它的往返:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ ./autotime 1450956180
2015-12-24 11:23:00</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_系好你的安全带">4.5. 系好你的安全带</h3>
<div class="paragraph">
<p>现在程序的功能已经完成了，我们应该努力去掉一些杂乱无章的东西，再去探索一下 Raku 的一些很棒的功能。</p>
</div>
<div class="paragraph">
<p>我想利用的第一个特性是隐式变量或主题的特性。快速演示一下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 1..3 {
    .say
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1
2
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有显式的迭代变量，所以 Raku 隐式地将循环的当前值绑定到一个叫 <code>$_</code> 的变量上。方法调用 <code>.say</code> 是 <code>$_.say</code> 的一个快捷方式。而且由于有一个子例程在同一个变量上调用了六个方法，所以在这里使用 <code>$_</code> 是一个很好的视觉优化:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub formatter($_) {
    sprintf '%04d-%02d-%02d %02d:%02d:%02d',
            .year, .month,  .day,
            .hour, .minute, .second,
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想在一个词法范围内设置 <code>$_</code>，而不需要借助于函数定义，你可以使用 <code>given VALUE BLOCK</code> 构造:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given DateTime.new(+$timestamp, :&amp;formatter) {
    if .Date.DateTime == $_ {
        say .Date;
    }
    else {
        .say;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而且 Raku 还提供了一个对 <code>$_</code> 变量的条件语句的快捷方式，可以作为一个通用的 <code>switch</code> 语句来使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given DateTime.new(+$timestamp, :&amp;formatter) {
    when .Date.DateTime == $_ { say .Date }
    default { .say }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你有一个只读变量或参数，你可以不用 <code>$</code> sigil， 虽然你必须在声明时使用反斜线:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN(Int \timestamp) {
    ...
    given DateTime.new(+timestamp, :&amp;formatter) {
    ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以现在完整的代码看起来是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

multi sub MAIN(Int \timestamp) {
    sub formatter($_) {
        sprintf '%04d-%02d-%02d %02d:%02d:%02d',
                .year, .month,  .day,
                .hour, .minute, .second,
    }
    given DateTime.new(+timestamp, :&amp;formatter) {
        when .Date.DateTime == $_ { say .Date }
        default { .say }
    }
}

multi sub MAIN(Str $date where { try Date.new($_) }, Str $time?) {
    my $d = Date.new($date);
    if $time {
        my ( $hour, $minute, $second ) = $time.split(':');
        say DateTime.new(date =&gt; $d, :$hour, :$minute, :$second).posix;
    }
    else {
        say $d.DateTime.posix;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_main_魔法">4.6. MAIN 魔法</h3>
<div class="paragraph">
<p>如果我们在调用 <code>sub MAIN</code> 的时候，如果我们用不符合任何 <code>multi</code> 参数的参数来调用它，那么调用 <code>sub MAIN</code> 的魔力也会给我们提供一个自动的使用信息；比如说调用时不提供参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ ./autotime
Usage:
  ./autotime &lt;timestamp&gt;
  ./autotime &lt;date&gt; [&lt;time&gt;]</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以通过在 <code>MAIN subs</code> 之前添加语义注释，为这些用法信息添加一个简短的描述:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

#| Convert timestamp to ISO date
multi sub MAIN(Int \timestamp) {
    ...
}

#| Convert ISO date to timestamp
multi sub MAIN(Str $date where { try Date.new($_) }, Str $time?) {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在用法信息变为了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ ./autotime
Usage:
  ./autotime &lt;timestamp&gt; -- Convert timestamp to ISO date
  ./autotime &lt;date&gt; [&lt;time&gt;] -- Convert ISO date to timestamp</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_自动化测试">4.7. 自动化测试</h3>
<div class="paragraph">
<p>我们已经看到一些代码经过了几次重构的迭代。没有自动测试的重构往往会让我感到不安，所以我其实有一个小的 shell 脚本，用几个不同的参数组合来调用正在开发的脚本，并将其与预期的结果进行比较。</p>
</div>
<div class="paragraph">
<p>现在让我们来看看在 Raku 本身中编写测试代码的方法。</p>
</div>
<div class="paragraph">
<p>在 Perl 社区中，将逻辑移到模块中，以便于使用外部测试脚本进行测试是很常见的。在 Raku 中，这仍然很常见，但对于像这样的小工具，我更喜欢用一个包含代码和测试的单一文件，并通过单独的测试命令来运行测试。</p>
</div>
<div class="paragraph">
<p>为了让测试更容易，我们先把 I/O 和应用逻辑分开:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env perl6
sub from-timestamp(Int \timestamp) {
    sub formatter($_) {
        sprintf '%04d-%02d-%02d %02d:%02d:%02d',
            .year, .month, .day,
            .hour, .minute, .second,
    }
    given DateTime.new(+timestamp, :&amp;formatter) {
        when .Date.DateTime == $_ { return .Date }
        default { return $_ }
    }
}

sub from-date-string(Str $date, Str $time?) {
    my $d = Date.new($date);
    if $time {
        my ( $hour, $minute, $second ) = $time.split(':');
        return DateTime.new(date =&gt; $d, :$hour, :$minute, :$second);
    } else {
        return $d.DateTime;
    }
}

#| Convert timestamp to ISO date
multi sub MAIN(Int \timestamp) {
    say from-timestamp(+timestamp);
}

#| Convert ISO date to timestamp
multi sub MAIN(Str $date where { try Date.new($_) }, Str $time?) {
    say from-date-string($date, $time).posix;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个小的重构没了，我们来补充一些测试:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| Run internal tests
multi sub MAIN('test') {
    use Test;
    plan 4;
    is-deeply from-timestamp(1450915200), Date.new('2015-12-24'), 'Timestamp to Date';

    my $dt = from-timestamp(1450915201);
    is $dt, "2015-12-24 00:00:01", 'Timestamp to DateTime with string formatting';
    is from-date-string('2015-12-24').posix, 1450915200, 'from-date-string, one argument';
    is from-date-string('2015-12-24', '00:00:01').posix, 1450915201, 'from-date-string, two arguments';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">./autotime test
1..4
ok 1 - Timestamp to Date
ok 2 - Timestamp to DateTime with string formatting
ok 3 - from-date-string, one argument
ok 4 - from-date-string, two arguments</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出格式是 Test Anything Protocol (TAP)<sup class="footnote">[<a id="_footnoteref_17" class="footnote" href="#_footnotedef_17" title="View footnote.">17</a>]</sup>，这是 Perl 社区中的实际标准<sup class="footnote">[<a id="_footnoteref_18" class="footnote" href="#_footnotedef_18" title="View footnote.">18</a>]</sup>， 但现在其他社区也在使用。对于较大的输出字符串，通过测试套件来运行测试是个好主意。对于我们的四行测试输出来说，这还不是必要的，但如果你想这样做，你可以使用 Perl 5 自带的 <code>prove</code> 程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ prove -e "" "./autotime test"
./autotime-tested.p6 test .. ok</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">All tests successful.
Files=1, Tests=4, 0 wallclock secs ( 0.02 usr 0.01 sys + 0.23 cusr 0.02 csys = 0.28 CPU)
Result: PASS</code></pre>
</div>
</div>
<div class="paragraph">
<p>在终端中，这甚至会将 "All tests successful" 输出的颜色标注为绿色，这样更容易被发现。而测试失败则用红色标记。</p>
</div>
<div class="paragraph">
<p>测试是如何工作的？第一行代码使用了一个我们还没有看到的新功能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN('test') {</code></pre>
</div>
</div>
<div class="paragraph">
<p>那是什么，在子程序签名中用字面值代替参数？</p>
</div>
<div class="paragraph">
<p>没错，就是这个。它是下面这段代码的简写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN(Str $anon where {$anon eq 'test'}) {</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了它没有声明变量 <code>$anon</code>。所以它是一个 <code>multi</code> 候选项，只能通过提供字符串 'test' 作为唯一参数来调用。</p>
</div>
<div class="paragraph">
<p>下一行，<code>use Test;</code>，加载 Raku 附带的测试模块<sup class="footnote">[<a id="_footnoteref_19" class="footnote" href="#_footnotedef_19" title="View footnote.">19</a>]</sup>。它还会将 <code>Test</code> 默认导出的所有符号导入到当前的词法作用域中。这包括后面要用到的函数 <code>plan</code>、<code>is</code>、和 <code>is-deeply</code>。</p>
</div>
<div class="paragraph">
<p><code>plan 4;</code> 声明我们要运行四个测试。这对于检测测试代码中的无计划、提前退出，或者测试代码中的循环逻辑错误导致运行的测试量比计划中的少，是很有用的。如果你不忍心提前计算测试，可以省去 <code>plan</code> 调用，而是在测试完成后再调用 <code>done-testing</code>。</p>
</div>
<div class="paragraph">
<p><code>is-deeply</code> 和 <code>is</code> 都是把要测试的值作为第一个参数，预期值作为第二个参数，第三个参数是可选的测试标签字符串。不同的是， <code>is</code> 是将前两个参数作为字符串进行比较，而 <code>is-deeply</code> 使用的是使用 <code>eqv</code> 操作符<sup class="footnote">[<a id="_footnoteref_20" class="footnote" href="#_footnotedef_20" title="View footnote.">20</a>]</sup>的深度相等比较逻辑。</p>
</div>
<div class="paragraph">
<p>还有更多的测试函数可以使用，比如 <code>ok()</code>，它对真参数成功，而 <code>nok()</code>，它对假参数的期望值是假的。你也可以用 <code>subtest</code> 来嵌套测试:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| Run internal tests
multi sub MAIN('test') {
    use Test; plan 2;

    subtest 'timestamp', {
        plan 2;
        is-deeply from-timestamp(1450915200), Date.new('2015-12-24'), 'Date';;

        my $dt = from-timestamp(1450915201);
        is $dt, "2015-12-24 00:00:01", 'DateTime with string formatting';
    };

    subtest 'from-date-string', {
        plan 2;
        is from-date-string('2015-12-24').posix, 1450915200, 'one argument';
        is from-date-string('2015-12-24', '00:00:01').posix, 1450915201, 'two arguments';
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每一次对 <code>subtest</code> 的调用都算作一次对外部测试运行的测试，所以 <code>plan 4;</code> 变成了 <code>plan 2;</code>。<code>subtest</code> 测试的调用本身就有一个测试标签，然后在一个 <code>subtest</code> 测试内部，你又有一个 <code>plan</code>，并调用测试函数，如下图所示。这在编写自定义测试函数时非常有用，因为它可以执行不同数量的单独测试。</p>
</div>
<div class="paragraph">
<p>嵌套测试的输出看起来是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">1..2
    1..2
    ok 1 - Date
    ok 2 - DateTime with string formatting
ok 1 - timestamp
    1..2
    ok 1 - one argument
    ok 2 - two arguments
ok 2 - from-date-string</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，测试套件只报告两个顶级测试的运行（和通过的）测试数量。是的，你可以在子测试中嵌套子测试，如果你真的想这么做的话。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_4">4.8. 总结</h3>
<div class="paragraph">
<p>我们已经看到了一些 Date 和 DateTime 的算术，但最精彩的部分是多重分派、命名参数、带 where 子句的子类型约束、 given/when 和隐式的 <code>$_</code> 变量，以及当涉及到 <code>MAIN</code> 子句时，一些严肃的魔法。</p>
</div>
<div class="paragraph">
<p>最后，我们学习了使用 Raku 自带的 <code>Test</code> 模块进行自动测试。</p>
</div>
<div class="paragraph">
<p>花点时间阅读一下你到目前为止使用过的文档。看看你是否能在你的代码中找到一个地方把 <code>if</code> 换成 <code>where</code> 语句<sup class="footnote">[<a id="_footnoteref_21" class="footnote" href="#_footnotedef_21" title="View footnote.">21</a>]</sup>。一定要利用好 <code>where</code> 引入的词法作用域。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_测试_say">5. 测试 say</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在上一章中，我修改了一些代码，让它不产生输出，而是在 MAIN 子例程中做了输出，方便的是没有测试。</p>
</div>
<div class="paragraph">
<p>改变代码以使其更容易测试是一种合理的做法。但如果你确实要测试通过调用 <code>say</code> 来产生输出的代码，有一个小技巧你可以使用：<code>say</code> 在一个文件句柄上工作，你可以把默认的文件句柄换掉，这个句柄是连接到标准输出的。你可以在它的位置上放一个假文件句柄来代替默认的文件句柄，捕捉向它发出的低级命令，并记录下来，供测试用。</p>
</div>
<div class="paragraph">
<p>这里有一个现成的模块，IO:::String<sup class="footnote">[<a id="_footnoteref_22" class="footnote" href="#_footnotedef_22" title="View footnote.">22</a>]</sup>,但为了学习的缘故，我们来看看它是如何工作的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6;

# function to be tested
sub doublespeak($x) {
    say $x ~ $x;
}

use Test;
plan 1;

my class OutputCapture {
    has @!lines;
    method print(\s) {
        @!lines.push(s);
    }
    method captured() {
        @!lines.join;
    }
}

my $output = do {
    my $*OUT = OutputCapture.new;
    doublespeak(42);
    $*OUT.captured;
};
is $output, "4242\n", 'doublespeak works';</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码的第一部分是我们要测试的函数 -  <code>sub doublespeak</code>。它用 <code>∼</code> 字符串连接运算符将其参数与自身进行连接。结果被传递给 <code>say</code>。</p>
</div>
<div class="paragraph">
<p>在引擎盖下，<code>say</code> 会做一些格式化处理，然后查找变量 <code>$<strong>OUT</code>。sigil 后面的 <code></strong></code> 标志着它是一个动态变量。对动态变量的查找会通过调用栈，在每个栈帧中查找变量的声明，并在每个栈帧中选择第一个找到的变量。</p>
</div>
<div class="paragraph">
<p>通常情况下，<code>$*OUT</code> 包含一个类型为 <code>IO:::Handle`<sup class="footnote">[<a id="_footnoteref_23" class="footnote" href="#_footnotedef_23" title="View footnote.">23</a>]</sup> 的对象，但 `say</code> 函数其实并不关心这个，只要能在这个对象上调用 <code>print</code> 方法就可以了。这就是所谓的鸭子类型化：我们其实并不关心对象的类型，只要它能像鸭子一样呱呱叫就可以了。或者在这个例子中，像鸭子一样打印。</p>
</div>
<div class="paragraph">
<p>然后是测试模块的加载<sup class="footnote">[<a id="_footnoteref_24" class="footnote" href="#_footnotedef_24" title="View footnote.">24</a>]</sup>，接下来就是声明要运行多少个测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Test;
plan 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以省略第二行，在测试之后调用 <code>one-testing</code>。但是，如果测试代码本身有可能出现 bug，没有运行它应该运行的测试，那么事先声明一下预期的测试数量是很好的，这样测试模块或者测试线束就可以抓住这样的错误。</p>
</div>
<div class="paragraph">
<p>接下来的例子是声明一个类型，我们可以用这个类型来模拟 <code>IO::Handle</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my class OutputCapture {
    has @!lines;
    method print(\s) {
        @!lines.append(s);
    }
    method captured() {
        @!lines.join;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>class</code> 引入了一个类，而 <code>my</code> 前缀使得名称在词法上有了作用域，就像在 <code>my $var</code> 声明中一样。</p>
</div>
<div class="paragraph">
<p><code>has @!</code> 行声明了一个属性，也就是说，对于类 <code>OutputCapture</code> 的每个实例来说，它是一个单独存在的变量。<code>!</code> 标志着它是一个属性。我们可以把它省略掉，但把它放在那里意味着当你读取一个大类时，你总是知道这个名字来自哪里。</p>
</div>
<div class="paragraph">
<p>属性 <code>@!</code> 行是以 <code>@</code> 开头的，而不是像我们到目前为止看到的其他变量那样以 <code>$</code> 开头。<code>@</code> 是数组变量的标志。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">符号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类型约束</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解释</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mu</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单个值和对象</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Positional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整数索引的组合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Associative</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符串或对象索引的组合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&amp;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Callable</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你可以调用的对象代码</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>你现在可能会看到一个趋势：变量或属性名称的第一个字符表示它的粗略类型（scalar、数组、<code>&amp;</code> 表示例程，稍后我们会了解到 <code>%</code> 表示散列），如果第二个字符不是字母，则表示它的范围。我们把这个第二个字符称为 twigil。到目前为止，我们已经看到了动态变量的 <code>*</code> 和属性的 <code>!</code>。还有更多:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Twigil</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">动态作用域变量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">!</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OO 领域的属性</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">^</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">隐式位置参数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">隐式命名参数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">编译器提供的常量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pod(文档)变量</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>我们的例子的倒数第二个块是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $output = do {
    my $*OUT = OutputCapture.new;
    doublespeak(42);
    $*OUT.captured;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>do { &#8230;&#8203; }</code> 只是执行大括号内的代码，并返回最后一条语句的值。和 Raku 中的所有代码块一样，它也引入了一个新的词法作用域。
新的作用域在下一行中派上了用场，<code>my $*OUT</code> 声明了一个新的动态变量 <code>$*OUT</code>，但是它只在块的作用域中有效。它是用 <code>OutputCapture.new</code> 来初始化的，它是前面声明的类的一个新实例。<code>new</code> 并不是什么神奇的东西，它只是从 <code>OutputCapture</code> 的超级类中继承过来的。我们没有声明一个，但默认情况下，类会得到类型为 Any<sup class="footnote">[<a id="_footnoteref_25" class="footnote" href="#_footnotedef_25" title="View footnote.">25</a>]</sup> 的超级类，它提供了（除此之外）方法 <code>new</code> 作为构造函数。</p>
</div>
<div class="paragraph">
<p>调用 <code>doublepeak</code> 调用 <code>say</code>，<code>say</code> 又会调用 <code>$*OUT.print</code>。而由于 <code>$*OUT</code> 是这个动态作用域中的 <code>OutputCapture</code> 的一个实例，所以传递给 <code>say</code> 的字符串会落在 <code>OutputCapture</code> 的属性 <code>@!line</code> 中，在这里 <code>$*OUT.captured</code> 可以再次访问它。</p>
</div>
<div class="paragraph">
<p>最后一行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">is $output, "4242\n", 'doublespeak works';</code></pre>
</div>
</div>
<div class="paragraph">
<p>调用测试模块中的 <code>is</code> 函数。</p>
</div>
<div class="paragraph">
<p>在良好的测试传统中，这将产生 TAP 格式的输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">1..1
ok 1 - doublespeak works</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_总结_5">5.1. 总结</h3>
<div class="paragraph">
<p>我们已经看到，<code>say()</code> 使用一个动态作用域变量 <code>$*OUT</code> 作为它的输出文件句柄。为了测试的目的，我们可以用一个我们自己制作的对象来代替，这让我们偶然发现了 Raku 中类是如何编写的。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_silent_cron_一个_cron_包裹器">6. Silent-Cron, 一个 Cron 包裹器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Linux 和类似 UNIX 的系统中，一个名为 cron<sup class="footnote">[<a id="_footnoteref_26" class="footnote" href="#_footnotedef_26" title="View footnote.">26</a>]</sup> 的程序会在后台定期执行用户定义的命令。它用于系统维护任务，如刷新或删除缓存、旋转和删除旧的日志文件等。</p>
</div>
<div class="paragraph">
<p>如果这样的命令产生任何输出，cron 通常会发送一封包含输出的电子邮件，以便管理员查看，判断是否需要采取一些行动。</p>
</div>
<div class="paragraph">
<p>但是，并不是所有的命令行程序都是为使用 cron 编写的。例如，它们可能在成功执行时也会产生输出，并通过非零的退出代码表示失败。或者它们可能会挂起，或者其他方面的错误行为。</p>
</div>
<div class="paragraph">
<p>为了处理这类命令，我们将开发一个名为 silent-cron 的小程序，它可以封装这类命令，并在退出代码为0时抑制输出。它还允许你指定一个超时，如果时间过长，就会杀死被包装的程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ silent-cron -- command-that-might-fail args
$ silent-cron --timeout=5 -- command-that-might-hang</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_异步运行命令">6.1. 异步运行命令</h3>
<div class="paragraph">
<p>当你想运行外部命令时，Raku 基本上给你两个选择：run<sup class="footnote">[<a id="_footnoteref_27" class="footnote" href="#_footnotedef_27" title="View footnote.">27</a>]</sup>,是一个简单的同步接口；Proc::Async<sup class="footnote">[<a id="_footnoteref_28" class="footnote" href="#_footnotedef_28" title="View footnote.">28</a>]</sup>,是一个异步的、稍微复杂一点的选项。尽管我们在第一次迭代中会省略超时，但我们需要注意的是，在异步接口中实现超时是比较容易的，所以我们将使用这个接口。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku
sub MAIN(*@cmd) {
    my $proc = Proc::Async.new(|@cmd);
    my $collector = Channel.new;
    for $proc.stdout, $proc.stderr -&gt; $supply {
        $supply.tap: { $collector.send($_) }
    }
    my $result = $proc.start.result;
    $collector.close;
    my $output = $collector.list.join;
    my $exitcode = $result.exitcode;
    if $exitcode != 0 {
        say "Program @cmd[] exited with code $exitcode";
        print "Output:\n", $output if $output;
    }
    exit $exitcode;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里面有一大块新的功能和概念，让我们一点一点地去看一下代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN(*@cmd) {</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先你应该注意的是 <code><strong>@cmd</code>。变量前面的 <code></strong></code> 表示的是一个 slurpy 参数<sup class="footnote">[<a id="_footnoteref_29" class="footnote" href="#_footnotedef_29" title="View footnote.">29</a>]</sup>，它之所以这样命名，是因为它可以吞噬任何数量的参数。这个 <code>*</code> 只需要在参数声明中使用。</p>
</div>
<div class="paragraph">
<p>所以 <code>*@cmd</code> 收集了所有的命令行参数，在数组变量 <code>@cmd</code> 中，第一个元素是要执行的命令，其他元素是传递给这个命令的参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $proc = Proc::Async.new(|@cmd);</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一行用传入的命令创建了一个新的 <code>Proc::Async</code> 实例，但还没有运行任何东西。<code>Proc::Async.new</code> 并不期望我们传送一个数组，但它希望我们传递任意数量的值作为参数。因此，我们在 <code>@cmd</code> 之前使用 <code>|</code> 竖条<sup class="footnote">[<a id="_footnoteref_30" class="footnote" href="#_footnotedef_30" title="View footnote.">30</a>]</sup>将数组扁平化，这样我们就可以向 <code>Proc::Async.new</code> 发送多个值，而不是一个数组值。</p>
</div>
<div class="paragraph">
<p>对于我们的程序，我们需要捕获来自 <code>$proc</code> 的所有输出；因此我们捕获 STDOUT 和 STDERR 流的输出（Linux上的文件句柄1和2），并将其合并为一个字符串。在异步 API 中，STDOUT 和 STDERR 被建模为 Supply 类型的对象<sup class="footnote">[<a id="_footnoteref_31" class="footnote" href="#_footnotedef_31" title="View footnote.">31</a>]</sup> ，因此是事件流。由于 Supplies 可以并行地发出事件，因此我们需要一个线程安全的数据结构来收集结果，而 Raku 为此提供了一个 Channel。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $collector = Channel.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了实际得到程序的输出，我们需要切入 STDOUT 和 STDERR 流:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $proc.stdout, $proc.stderr -&gt; $supply {
    $supply.tap: { $collector.send($_) }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个 <code>$supply</code> 都会对它接收到的每一个字符串执行块 <code>{ $collector.send($_) }</code>。这个字符串可以是一个字符、一行，如果流是缓冲的，也可以是更大的东西。我们所要做的就是通过 <code>send</code> 方法将字符串放入通道 <code>$collector</code> 中。</p>
</div>
<div class="paragraph">
<p>请注意，前面的代码相当于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$proc.stdout.tap: { $collector.send($_) }
$proc.stderr.tap: { $collector.send($_) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在运行一个简单的脚本时，你经常会看到正常输出和错误输出一起打印到终端上。我们的代码是将 STDOUT 和 STDERR 输出交错到 <code>$collector</code> 中，其方式基本相同。</p>
</div>
<div class="paragraph">
<p>现在这些数据流已经被分接出来，并连接到我们的收集器，我们可以启动程序，等待程序完成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result = $proc.start.result;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Proc::Async.start</code> 执行外部进程并返回一个 <code>Promise</code>。<sup class="footnote">[<a id="_footnoteref_32" class="footnote" href="#_footnotedef_32" title="View footnote.">32</a>]</sup> <code>Promise</code> 包装了一段可能在另一个线程上运行的代码，有一个状态(<code>Planned</code>、<code>Kept</code> 或 <code>Broken</code>)，一旦完成，就会有一个结果。访问结果会自动等待被包装的代码完成。这里的代码是运行外部程序的代码，结果是 Proc<sup class="footnote">[<a id="_footnoteref_33" class="footnote" href="#_footnotedef_33" title="View footnote.">33</a>]</sup> 类型的对象（恰好和同步接口中的 <code>run()</code> 函数一样）。</p>
</div>
<div class="paragraph">
<p>在这一行之后，我们可以确定外部命令已经终止，因此不会再有 <code>$proc.stdout</code> 和 <code>$proc.stderr</code> 的输出。因此，我们可以安全地关闭通道，并通过 <code>Channel.list</code> 访问它的所有元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$collector.close;
my $output = $collector.list.join;</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，是检查外部命令是否成功的时候了。</p>
</div>
<div class="paragraph">
<p>检查其退出代码 - 并以命令的退出代码退出包装程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $exitcode = $result.exitcode;
if $exitcode != 0 {
    say "Program @cmd[] exited with code $exitcode";
    print "Output:\n", $output if $output;
}
exit $exitcode;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在输出字符串内：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "Program @cmd[] exited with code $exitcode";</code></pre>
</div>
</div>
<div class="paragraph">
<p>变量 <code>$exitcode</code> 被内插，也就是说，它的名字在运行时被替换为其值。这在双引号字符串"&#8230;&#8203; "中会发生，但在单引号字符串'&#8230;&#8203;'中不会。只有标量变量在"&#8230;&#8203; "中才会被插值；其他变量（数组、哈希值、代码对象）只有在后面有某种括号结构时才会被插值。这就是为什么 <code>@cmd</code> 后面有 <code>[]</code> 的原因，我们称其为 Zen slice。返回多个值的数组或哈希索引一般称为切片；例如，<code>@cmd[0，1]</code> 返回前两个值。将索引留空则返回整个数组。</p>
</div>
<div class="paragraph">
<p>另一种实现插值的方法是在变量上添加一个以括号结尾的方法调用，所以也可以写成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "Program @cmd.join(' ') exited with code $exitcode";</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关"&#8230;&#8203; "插值的更多深入信息，请参见文档。<sup class="footnote">[<a id="_footnoteref_34" class="footnote" href="#_footnotedef_34" title="View footnote.">34</a>]</sup></p>
</div>
</div>
<div class="sect2">
<h3 id="_实现超时">6.2. 实现超时</h3>
<div class="paragraph">
<p>在 Raku 中实现超时的常用方法是使用 <code>Promise.anyof</code> 组合器和定时器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN(*@cmd, :$timeout) {
    my $proc = Proc::Async.new(|@cmd);
    my $collector = Channel.new;
    for $proc.stdout, $proc.stderr -&gt; $supply {
        $supply.tap: { $collector.send($_) }
    }

    my $promise = $proc.start;
    my $waitfor = $promise;
    $waitfor = Promise.anyof(Promise.in($timeout), $promise)
        if $timeout;
    await $waitfor;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$proc</code> 的初始化没有改变。但我们不访问 <code>$proc.start.result</code>，而是存储从 <code>$proc.start</code> 返回的承诺。如果用户指定了超时，我们运行这段代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$waitfor = Promise.anyof(Promise.in($timeout), $promise)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Promise.in($seconds)</code> 返回一个将在 <code>$seconds</code> 秒内实现的承诺，它基本上和 <code>start { sleep $seconds }</code> 是一样的，但是调度器可以更聪明一点，不要只分配一整条线程来休眠。</p>
</div>
<div class="paragraph">
<p><code>Promise.anyof($p1,$p2)</code> 返回一个承诺，只要其中一个参数(也应该是承诺)被实现，就会返回一个承诺。所以，我们要么等待外部程序完成，要么等待 <code>sleep</code> 承诺实现。</p>
</div>
<div class="paragraph">
<p>使用 <code>await $waitfor;</code> 程序等待承诺被实现（或被打破）。在这种情况下，我们不能像以前那样简单地访问 <code>$promise.result</code>，因为在超时的情况下，<code>$promise</code>(即外部程序的承诺)可能无法实现。所以我们必须先检查承诺的状态，只有这样我们才能安全地访问 <code>$promise.result</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if !$timeout || $promise.status ~~ Kept {
    my $exitcode = $promise.result.exitcode;
    my $output = $collector.list.join;

    if $exitcode != 0 {
        say "Program @cmd[] exited with code $exitcode";
        print "Output:\n", $output if $output;
    }
    exit $exitcode;
}
else {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>表达式 <code>$promise.status ~~ Kept</code> 使用智能匹配运算符来检查承诺状态是否与常数 <code>Kept</code> 的状态相同。智能匹配是一个非常通用的运算符，其语义取决于表达式的右侧。对于右侧的数，比较的是数值。对于右侧的类型，则是类型检查。更多内容请参考官方文档。<sup class="footnote">[<a id="_footnoteref_35" class="footnote" href="#_footnotedef_35" title="View footnote.">35</a>]</sup></p>
</div>
<div class="paragraph">
<p>在 <code>else { &#8230;&#8203; }</code> 分支中，我们需要处理超时的情况。这可能就像打印出一条超时的语句一样简单，当 silent-cron 之后立即退出时，这可能是可以接受的。但是我们可能将来要做更多的事情，所以我们应该杀死外部程序。而如果程序在发出友好的 <code>kill</code> 信号后没有终止，就应该收到一个 <code>kill(9)</code>，在 UNIX 系统中，这个 <code>kill(9)</code> 会强行终止程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">else { $proc.kill;
    say "Program @cmd[] did not finish after $timeout seconds";
    sleep 1 if $promise.status ~~ Planned;
    $proc.kill(9);
    await $promise;
    exit 2;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>await $promise</code> 返回承诺的结果；这里是一个 <code>Proc</code> 对象。Proc 内置了一个安全特性，如果命令返回的返回值为非零的退出代码，那么在 void 上下文中计算该对象会抛出一个异常。</p>
</div>
<div class="paragraph">
<p>由于我们在代码中显式处理了非零退出代码，所以我们可以通过将 <code>await</code> 的返回值分配给一个哑变量来抑制这个异常的产生:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $dummy = await $promise</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为我们不需要这个值，所以我们也可以把它分配给一个匿名变量代替:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ = await $promise</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_更多关于承诺的信息">6.3. 更多关于承诺的信息</h3>
<div class="paragraph">
<p>如果你在其他语言中处理过并发或并行程序，你可能会遇到线程、锁、mutexes 和其他低级构造。这些东西在 Raku 中也有，但不鼓励直接使用它们。</p>
</div>
<div class="paragraph">
<p>这些低级原语的问题在于它们不能很好地编译。你可以有两个使用线程的库，它们本身工作得很好，但在同一个程序中组合起来就会导致死锁。或者不同的组件可能会单独启动线程，当几个这样的组件在同一个进程中组合在一起时，可能会导致线程太多，内存消耗大。</p>
</div>
<div class="paragraph">
<p>Raku 提供了更高级别的原语。你可以使用 <code>start</code> 来异步地运行代码，而不是催生一个线程，由调度器决定在哪个线程上运行。如果有更多的 <code>start</code> 调用请求线程来调度的事情发生了，那么有些线程就会串行运行。</p>
</div>
<div class="paragraph">
<p>这里有一个非常简单的例子，就是在后台运行计算。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub count-primes(Int $upto) {
    (1..$upto).grep(&amp;is-prime).elems;
}

my $p = start count-primes 10_000;
say $p.status;
await $p;
say $p.result;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它给出如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Planned
1229</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以看到，在启动调用后，主线继续执行，<code>$p</code> 立即有一个值 - 承诺，状态为 <code>Planned</code>。</p>
</div>
<div class="paragraph">
<p>正如我们之前看到的那样，承诺有组合器，<code>anyof</code> 和 <code>allof</code>。你也可以使用 <code>then</code> 方法将动作链接到一个承诺上:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub count-primes(Int $upto) {
    (1..$upto).grep(&amp;is-prime).elems;
}

my $p1 = start count-primes 10_000;
my $p2 = $p1.then({ say .result });
await $p2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在异步执行代码内部抛出异常，那么承诺的状态就会变成 <code>Broken</code>，调用它的 <code>.result</code> 方法重抛出异常。</p>
</div>
<div class="paragraph">
<p>为了演示调度器分配任务，让我们考虑一个小的蒙特卡洛模拟来计算 π 的近似值，蒙特卡洛模拟只是一个程序，用随机数来探索一个可能值的空间，得出一个确定性的输出（图6-1）。</p>
</div>
<div class="paragraph">
<div class="title">在一个正方形中随机放置点时，四分之一圆内的点数与总点数的比值接近 π/4 时</div>
<p>我们生成一对0到1之间的随机数，将其解释为正方形中的点。一个半径为1的四分之一圆的面积为 π/4，因此，如果我们使用足够多的点，那么四分之一圆内随机放置的点与点的总数之比接近 π/4。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub pi-approx($iterations) {
    my $inside = 0;
    for 1..$iterations {
        my $x = 1.rand;
        my $y = 1.rand;
        $inside++ if $x * $x + $y * $y &lt;= 1;
    }
    return ($inside / $iterations) * 4;
}
my @approximations = (1..1000).map({ start pi-approx(80) });
await @approximations;

say @approximations.map({.result}).sum / @approximations;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序异步启动一千次计算，但如果你在运行的时候看一下系统监控工具，你会观察到只有 16 个线程在运行。这个神奇的数字来自于默认的线程调度器，我们可以通过在前面的代码上面提供自己的调度器实例来覆盖它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $*SCHEDULER = ThreadPoolScheduler.new(:max_threads(3));</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于像这种蒙特卡洛仿真这样的 CPU 绑定任务，将线程数大致限制在 CPU 内核的数量（可能是虚拟的）上是个好主意；如果很多线程被卡住等待 I/O，那么更高的线程数可以获得更好的性能。</p>
</div>
</div>
<div class="sect2">
<h3 id="_可能的扩展">6.4. 可能的扩展</h3>
<div class="paragraph">
<p>如果你想玩 silent-cron，可以增加一个重试机制。如果一个命令因为外部依赖（如API或NFS共享）而失败，那么这个外部依赖可能需要时间来恢复。因此，你应该添加一个二次幂或指数型的重试机制；也就是说，重试之间的等待时间应该以二次幂（1，2，4，9，16，16，&#8230;&#8203;）或指数型（1，2，4，8，16，32，&#8230;&#8203;）的方式增加。</p>
</div>
</div>
<div class="sect2">
<h3 id="_重构和自动化测试">6.5. 重构和自动化测试</h3>
<div class="paragraph">
<p>在我们在下一章中对 silent-cron 进行更多的扩展之前，是时候重构一下它，并为它写一些测试了。</p>
</div>
<div class="sect3">
<h4 id="_重构">6.5.1. 重构</h4>
<div class="paragraph">
<p>在此简单提醒一下，程序是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub MAIN(*@cmd, :$timeout) {
    my $proc = Proc::Async.new(|@cmd);
    my $collector = Channel.new;
    for $proc.stdout, $proc.stderr -&gt; $supply {
        $supply.tap: { $collector.send($_) }
    }
    my $promise = $proc.start;
    my $waitfor = $promise;
    $waitfor = Promise.anyof(Promise.in($timeout), $promise)
        if $timeout;
    $ = await $waitfor;
    $collector.close;
    my $output = $collector.list.join;
    if !$timeout || $promise.status ~~ Kept {
        my $exitcode = $promise.result.exitcode;
        if $exitcode != 0 {
            say "Program @cmd[] exited with code $exitcode";
            print "Output:\n", $output if $output;
        }
        exit $exitcode;
    }
    else {
        $proc.kill;
        say "Program @cmd[] did not finish after $timeout seconds";
        sleep 1 if $promise.status ~~ Planned;
        $proc.kill(9);
        $ = await $promise;
        exit 2;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里面有执行外部程序超时的逻辑，也有处理两种可能的结果的逻辑。从可测试性和未来扩展的角度来看，将外部程序的执行情况计入子程序中是有意义的。这段代码的结果不是一个单一的值，我们可能感兴趣的是它产生的输出，退出代码，以及是否超时。</p>
</div>
<div class="paragraph">
<p>我们可以写一个子例程，返回一个列表或者是这些值的哈希值，但是在这里我选择写一个小类来代替，新的子例程将返回:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class ExecutionResult {
    has Int $.exitcode = -1;
    has Str $.output is required;
    has Bool $.timed-out = False;
    method is-success {
        !$.timed-out &amp;&amp; $.exitcode == 0;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们以前见过类，但这个类有一些新的功能。用 <code>.twigil</code> 声明的属性会自动获得一个访问器方法，所以:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">has Int $.exitcode;</code></pre>
</div>
</div>
<div class="paragraph">
<p>大致等价于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">has Int $!exitcode;
method exitcode() { $!exitcode }</code></pre>
</div>
</div>
<div class="paragraph">
<p>它允许类的用户从外部访问属性中的值。作为奖励，你还可以从标准构造函数中初始化它，作为一个命名参数，<code>ExecutionResult.new( exitcode &#8658; 42 )</code>。退出代码并不是一个必须的属性，因为我们无法知道一个已经超时的程序的退出代码。所以我们给它一个默认值，如果属性还没有被初始化，我们就给它一个默认值。</p>
</div>
<div class="paragraph">
<p>输出是一个必填属性，所以我们用 <code>is required</code> 标记为必填属性。这就是一个 trait。trait 是修改其他事物的行为的代码，这里指的是属性的行为。它们会出现在很多地方，例如子程序签名（在参数上复制）、变量声明和类中。如果你试图调用 <code>ExecutionResult.new()</code> 而不指定输出，你会得到这样的错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">The attribute '$!output' is required, but you did not provide a value for it.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_模拟和测试">6.5.2. 模拟和测试</h4>
<div class="paragraph">
<p>现在我们有了一个从假设子例程中返回多个值的方便方法，让我们来看看这个子例程可能是什么样子的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub run-with-timeout(@cmd, :$timeout) {
    my $proc = Proc::Async.new(|@cmd);
    my $collector = Channel.new;
    for $proc.stdout, $proc.stderr -&gt; $supply {
        $supply.tap: { $collector.send($_) }
    }
    my $promise = $proc.start;
    my $waitfor = $promise;
    $waitfor = Promise.anyof(Promise.in($timeout), $promise)
        if $timeout;
    $ = await $waitfor;

    $collector.close;
    my $output = $collector.list.join;

    if !$timeout || $promise.status ~~ Kept {
        say "No timeout";
        return ExecutionResult.new(
            :$output,
            :exitcode($promise.result.exitcode),
        );
    }
    else {
        $proc.kill;
        sleep 1 if $promise.status ~~ Planned;
        $proc.kill(9);
        $ = await $promise;
        return ExecutionResult.new(
            :$output,
            :timed-out,
        );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Proc::Async<sup class="footnote">[<a id="_footnoteref_36" class="footnote" href="#_footnotedef_36" title="View footnote.">36</a>]</sup> 的用法没有变化，但例程不再是在错误发生时产生输出，而是返回 <code>ExecutionResult</code> 对象。</p>
</div>
<div class="paragraph">
<p>这大大简化了 MAIN 子例程:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN(*@cmd, :$timeout) {
    my $result = run-with-timeout(@cmd, :$timeout);
    unless $result.is-success {
        say "Program @cmd[] ",
            $result.timed-out ?? "ran into a timeout"
                              !! "exited with code $result.
                              exitcode()";

        print "Output:\n", $result.output if $result.output;
    }
    exit $result.exitcode // 2;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的一个新的语法特征是三元运算符，<code>CONDITION ?? TRUE-BRANCH !! FALSE-BRANCH</code>，你可能会从其他编程语言如 C 或 Perl5 中知道 <code>CONDITION ? TRUE-BRANCH : FALSE-BRANCH</code>。</p>
</div>
<div class="paragraph">
<p>最后，逻辑上的 defined-or 操作符 <code>LEFT // RIGHT</code>， 如果定义了，则返回 LEFT 边，如果没有，则运行 RIGHT 边并返回其值。它的工作原理与 <code>||</code> 和 <code>or</code> 中缀运算符一样，只是这些操作符会检查左边的布尔值，而不是检查它们是否被定义。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，我们区分了定义值和真值。默认情况下，所有的实例都是在布尔语境中，所有类型对象都是 true 和有定义的，而所有类型对象都是 false 和未定义的。</p>
</div>
<div class="paragraph">
<p>几个内置的类型覆盖了它们认为是真的东西。在布尔语境中，等于0的数字会被计算为 False，空字符串和空容器如数组、散列和集合也是如此。</p>
</div>
<div class="paragraph">
<p>另一方面，只有内置的 Failure<sup class="footnote">[<a id="_footnoteref_37" class="footnote" href="#_footnotedef_37" title="View footnote.">37</a>]</sup> 类型才会重写定义性。</p>
</div>
<div class="paragraph">
<p>你可以通过实现一个方法 Bool（应该返回 True 或 False），用定义的方法覆盖自定义类型的真值，用定义的方法覆盖定义性。</p>
</div>
<div class="paragraph">
<p>我们可以通过编写具有定义特性（输出、运行时间、退出代码）的自定义外部命令来开始测试 <code>sub run-with-timeout</code>，但这是相当繁琐的，要想以可靠的、跨平台的方式来做，那是相当麻烦的。因此，我想用一个模拟实现来代替 Proc::Async，并给子例程注入一个方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub run-with-timeout(@cmd, :$timeout, :$executer = Proc::Async) {
    my $proc = $executer.defined ?? $executer !! $executer.new(|@cmd);
    # rest as before</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过查看子例程 run-with-timeout，我们可以快速列出 Proc::Async 实现所需要的方法：<code>stdout</code>、<code>stderr</code>、<code>start</code> 和 <code>kill</code>。<code>stdout</code> 和 <code>stderr</code> 都需要返回一个 Supply.<sup class="footnote">[<a id="_footnoteref_38" class="footnote" href="#_footnotedef_38" title="View footnote.">38</a>]</sup> 最简单的方法就是返回一个只发出一个值的 Supply。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my class Mock::Proc::Async {
    has $.out = '';
    has $.err = '';
    method stdout {
        Supply.from-list($.out);
    }
    method stderr {
        Supply.from-list($.err);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Supply.from-list<sup class="footnote">[<a id="_footnoteref_39" class="footnote" href="#_footnotedef_39" title="View footnote.">39</a>]</sup> 返回一个 Supply，它将发出所有传递给它的参数；所以这里只是一个字符串。</p>
</div>
<div class="paragraph">
<p>最简单的 <code>kill</code> 实现，就是什么都不做:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method kill($?) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>签名中的 <code>$?</code> 是一个没有名字的可选参数（$foo?)</p>
</div>
<div class="paragraph">
<p>只剩下一个方法需要存根：<code>start</code>。它应该是返回一个 Promise，在定义的秒数后，返回一个 Proc 对象或其模拟对象。由于代码只调用 <code>exitcode</code> 方法，所以为它写一个存根很容易:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">has $.exitcode = 0;
has $.execution-time = 1;
method start {
    Promise.in($.execution-time).then({
        (class {
            has $.exitcode;
        }).new(:$.exitcode);
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为我们在其他地方不需要 mock Proc 类，我们甚至不需要给它起个名字。<code>class { &#8230;&#8203; }</code> 创建了一个匿名类，对它的 <code>.new</code> 调用会从它中创建一个新对象。</p>
</div>
<div class="paragraph">
<p>如前所述，当在 void 上下文中，或者我们在 Raku 中称其为 sink 上下文时，一个带有非零退出代码的 Proc 会抛出一个异常。我们可以通过扩展匿名类来模拟这种行为。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class {
    has $.exitcode;
    method sink() {
        die "mock Proc used in sink context";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这些准备工作，我们终于可以写一些测试了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN('test') {
    use Test;
    my class Mock::Proc::Async {
        has $.exitcode = 0;
        has $.execution-time = 0;
        has $.out = '';
        has $.err = ''; method kill($?) {}

        method stdout {
            Supply.from-list($.out);
        }
        method stderr {
            Supply.from-list($.err);
        }
        method start {
            Promise.in($.execution-time).then({
                (class {
                    has $.exitcode;
                    method sink() {
                        die "mock Proc used in sink context";
                    }
                }).new(:$.exitcode);
            });
        }
    }

    # no timeout, success
    my $result = run-with-timeout([],
        timeout =&gt; 2,
        executer =&gt; Mock::Proc::Async.new(
            out =&gt; 'mocked output',
        ),
    );
    isa-ok $result, ExecutionResult;
    is $result.exitcode, 0, 'exit code';
    is $result.output, 'mocked output', 'output';
    ok $result.is-success, 'success';

    # timeout
    $result = run-with-timeout([],
        timeout =&gt; 0.1,
        executer =&gt; Mock::Proc::Async.new(
            execution-time =&gt; 1,
            out =&gt; 'mocked output',
        ),
    );
    isa-ok $result, ExecutionResult;
    is $result.output, 'mocked output', 'output';
    ok $result.timed-out, 'timeout reported';
    nok $result.is-success, 'success';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将通过两种情况来运行，一种是配置了超时，但没有使用（因为模拟外部程序先退出），另一种是超时生效。</p>
</div>
</div>
<div class="sect3">
<h4 id="_提高可靠性和测定时间">6.5.3. 提高可靠性和测定时间</h4>
<div class="paragraph">
<p>依靠测试中的计时总是没有吸引力。如果时间太短（或一起太慢），你就有在慢的或重载的机器上出现零星测试失败的风险。如果你使用更保守的测试时间间隔，测试会变得非常慢。</p>
</div>
<div class="paragraph">
<p>有一个模块（不与 Rakudo 一起分发）可以减轻这种痛苦。Test::Scheduler<sup class="footnote">[<a id="_footnoteref_40" class="footnote" href="#_footnotedef_40" title="View footnote.">40</a>]</sup>提供了一个具有虚拟化时间的线程调度器，让你可以这样写测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Test::Scheduler;
my $*SCHEDULER = Test::Scheduler.new;
my $result = start run-with-timeout([],
    timeout =&gt; 5,
    executer =&gt; Mock::Proc::Async.new(
        execution-time =&gt; 2,
        out =&gt; 'mocked output',
    ),
);
$*SCHEDULER.advance-by(5); $result = $result.result;
isa-ok $result, ExecutionResult; # more tests here</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样安装了一个自定义的调度器，<code>$*SCHEDULER.advance-by(5)</code> 指示它将虚拟时间提前5秒，而不需要等待5秒的实际时间。在写这篇文章的时候（2016年12月）， <code>Test::Scheduler</code> 是一个相当新的模块，有一个 bug，导致第二个测试用例不能这样工作。<sup class="footnote">[<a id="_footnoteref_41" class="footnote" href="#_footnotedef_41" title="View footnote.">41</a>]</sup></p>
</div>
</div>
<div class="sect3">
<h4 id="_安装模块">6.5.4. 安装模块</h4>
<div class="paragraph">
<p>如果你想试用 <code>Test::Scheduler</code>，你需要先安装它。如果你运行 Rakudo Star，它已经为你提供了 zef 模块安装程序。你可以用它来下载并安装这个模块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ zef install Test::Scheduler</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您没有可用的 zef，可以下载，驱动并使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ git clone https://github.com/ugexe/zef.git
$ cd zef
$ raku -Ilib bin/zef install.
$ zef install Test::Scheduler</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_6">6.6. 总结</h3>
<div class="paragraph">
<p>我们已经看到了一个运行外部程序的异步 API，以及如何使用 Promises 来实现超时。我们还讨论了如何通过调度器将承诺分配给线程，让你可以启动任意数量的承诺，而不会让计算机超载。</p>
</div>
<div class="paragraph">
<p>在测试中，我们看到了属性与访问器、三元操作符和匿名类。对线程代码的测试，以及第三方模块的帮助方式也进行了讨论。最后，我们对模块安装程序zef有了一个非常小的窥视。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_有状态的_silent_cron">7. 有状态的 Silent Cron</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在上一章中，我们看了一下 <code>silent-cron</code>，它是一个包裹外部程序的封装器，可以在外部程序退出状态为零的情况下使其静音。但为了使其真正实用，它还应该对偶尔发生的故障进行静音。</p>
</div>
<div class="paragraph">
<p>外部 API 失败，网络拥塞，以及其他事情的发生会使作业无法成功，所以某种重试机制是可取的。如果是 cron 作业，cron 已经负责定期重试作业，所以 <code>silent-cron</code> 应该只是抑制偶尔的错误。另一方面，如果一个作业持续失败，这通常是管理员或开发人员应该研究的事情，所以这是一个值得报告的问题。</p>
</div>
<div class="paragraph">
<p>为了实现这个功能，<code>silent-cron</code> 需要在独立运行之间存储持久状态。它需要记录当前运行的结果，然后决定故障历史记录是否符合 "偶然性"。</p>
</div>
<div class="sect2">
<h3 id="_持久化存储">7.1. 持久化存储</h3>
<div class="paragraph">
<p>存储后端需要写入和检索结构化数据，并通过锁定保护状态文件的并发访问。对于这样的存储后端来说，一个很好的库是 SQLite，<sup class="footnote">[<a id="_footnoteref_42" class="footnote" href="#_footnotedef_42" title="View footnote.">42</a>]</sup>它是一个零维护的 SQL 引擎，以 C 语言库的形式提供。它是公共领域的软件，在大多数主流的浏览器、操作系统，甚至一些飞机上<sup class="footnote">[<a id="_footnoteref_43" class="footnote" href="#_footnotedef_43" title="View footnote.">43</a>]</sup>都有使用。</p>
</div>
<div class="paragraph">
<p>Raku 通过 DBIish<sup class="footnote">[<a id="_footnoteref_44" class="footnote" href="#_footnotedef_44" title="View footnote.">44</a>]</sup> 提供了 SQLite 的功能，它是一个通用的数据库接口，带有 SQLite、MySQL、PostgreSQL 和 Oracle DB 的后端驱动。要使用它，首先确保 SQLite3 已经安装好，包括头文件。例如，在基于 Debian 的 Linux 系统中，你可以通过 <code>apt-get install libsqlite3-dev</code> 来实现。如果你使用的是 Rakudo Star 发行版，DBIish 已经可用。如果不是，你可以使用其中一个模块安装程序来获取并安装它：<code>zef install DBIish</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use DBIish;
my $dbh = DBIish.connect('SQLite', :database('database-file.sqlite3'));</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用 DBIish 的 SQLite 后端，首先必须通过选择后端并提供连接信息来创建数据库句柄。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$dbh.do('INSERT INTO player (name) VALUES ?', 'John');</code></pre>
</div>
</div>
<div class="paragraph">
<p>SQL中的 <code>?</code> 是一个占位符，作为独立的参数传递给 <code>do</code> 方法的带外参数，这样可以避免 SQL 注入漏洞等潜在的错误。</p>
</div>
<div class="paragraph">
<p>查询的工作方式往往是先准备一个语句，返回一个语句句柄。你可以一次或多次执行一条语句，每次执行调用后都可以检索结果行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sth = $dbh.prepare('SELECT id FROM player WHERE name = ?');
my %ids;
for &lt;John Jack&gt; -&gt; $name {
    $sth.execute($name);
    %ids{ $name } = $sth.row[0];
}
$sth.finish;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_开发存储后端">7.2. 开发存储后端</h3>
<div class="paragraph">
<p>我们不应该把所有的存储处理代码都塞到子例程 MAIN 中，而是应该仔细考虑为存储后端创建一个有用的 API。起初，我们只需要两块功能：插入一个作业执行的结果，以及检索最近的结果。</p>
</div>
<div class="paragraph">
<p>因为 silent-cron 可以用来守护同一台机器上的多个 cron 作业，所以我们可能需要一些东西来区分不同的作业，以便其中一个成功的作业不会阻止一个不断失败的作业报错。为此，我们引入了一个作业名称，它可以默认为正在执行的命令（包括参数），但可以在命令行中明确设置。</p>
</div>
<div class="paragraph">
<p>存储后端的 API 可以看成是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $repo = ExecutionResultRepository.new(
    jobname =&gt; 'refresh cache',
    statefile =&gt; 'silent-cron.sqlite3',
);
$repo.insert($result);
my @last-results = $repo.tail(5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个 API 完全不是 SQLite 后端特有的，一个使用纯文本文件的存储后端也可以有完全相同的 API。</p>
</div>
<div class="paragraph">
<p>让我们来实现这个 API。首先我们需要类和两个属性，这两个属性在前面的使用示例中应该很明显。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class ExecutionResultRepository {
    has $.jobname is required;
    has $.statefile is required;
    # ... more code</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了实现 <code>insert</code> 方法，我们需要连接到数据库并创建相关的表，如果表还不存在的话，那么我们需要连接到数据库并创建相关的表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">has $!db; method !db() {
    return $!db if $!db;
    $!db = DBIish.connect('SQLite', :database($.statefile));
    self!create-schema();
    return $!db;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码使用一个私有属性 <code>$!db</code> 来缓存数据库句柄，如果还不存在，则使用一个私有方法 <code>!db</code> 来创建句柄。</p>
</div>
<div class="paragraph">
<p>私有方法的声明与普通方法一样，只是名称以感叹号开始。要调用一个方法，用方法调用点代替感叹号；换句话说，用 <code>self!db()</code> 代替 <code>self.db()</code>。</p>
</div>
<div class="paragraph">
<p><code>!db</code> 方法还调用下一个私有方法，即 <code>!create-schema</code>，它创建了存储表和一些索引。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant $table = 'job_execution';
method !create-schema() {
    $!db.do(qq:to/SCHEMA/);
        CREATE TABLE IF NOT EXISTS $table (
            id          INTEGER PRIMARY KEY,
            jobname     VARCHAR NOT NULL,
            exitcode    INTEGER NOT NULL,
            timed_out   INTEGER NOT NULL,
            output      VARCHAR NOT NULL,
            executed    TIMESTAMP NOT NULL DEFAULT (DATETIME('NOW'))
        );

    SCHEMA
    $!db.do(qq:to/INDEX/);
        CREATE INDEX IF NOT EXISTS {$table}_jobname_exitcode ON
        $table ( jobname, exitcode );
    INDEX
    $!db.do(qq:to/INDEX/);
        CREATE INDEX IF NOT EXISTS {$table}_jobname_executed ON
        $table ( jobname, executed );
    INDEX
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>多行字符串字符最好用 heredoc<sup class="footnote">[<a id="_footnoteref_45" class="footnote" href="#_footnotedef_45" title="View footnote.">45</a>]</sup>语法来写。  <code>qq:to/DELIMITER/</code> 告诉 Raku 要完成对当前行的解析，这样你仍然可以关闭方法调用的小括号，并添加语句结束分号。下一行开始字符串字面量，一直到 Raku 在一行上找到分界符为止。字符串字段的每一行的前导空格都会被剥去，缩进的分界符越多越好。</p>
</div>
<div class="paragraph">
<p>因此:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">print q:to/EOS/;
    Not indented
        Indented four spaces
    EOS</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Not indented
    Indented four spaces</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们有了一个工作的数据库连接，知道了数据库表的存在，插入一条新记录就变得简单了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method insert(ExecutionResult $r) {
    self!db.do(qq:to/INSERT/, $.jobname, $r.exitcode, $r.timed-out, $r.output);
        INSERT INTO $table (jobname, exitcode, timed_out, output)
        VALUES(?, ?, ?, ?)
    INSERT
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>选择最近的记录比较麻烦，部分原因是我们需要将表的行转换为对象。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method tail(Int $count) {
    my $sth = self!db.prepare(qq:to/SELECT/);
        SELECT exitcode, timed_out, output
          FROM $table
          WHERE jobname = ?
          ORDER BY executed DESC
          LIMIT $count
    SELECT
    $sth.execute($.jobname);
    $sth.allrows(:array-of-hash).map: -&gt; %h {
        ExecutionResult.new(
            exitcode  =&gt; %h&lt;exitcode&gt;,
            timed-out =&gt; ?%h&lt;timed_out&gt;,
            output    =&gt; %h&lt;output&gt;,
        );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>尾部方法中的最后一条语句值得注意一下。<code>$sth.allrows(:array-of-hash)</code> 将数据库中的记录生成为一个散列值列表。这个列表是惰性的，也就是说，它是按需生成的。懒人列表是一个非常方便的功能，因为它允许你用相同的 API 使用迭代器和列表。例如，当读取文件中的 <code>lines</code> 时，你可以写 <code>$handle.lines &#8594; $line { &#8230;&#8203; }</code>，行方法不需要将整个文件加载到内存中，而是可以在访问时读取一行。</p>
</div>
<div class="paragraph">
<p><code>$sth.allrows(&#8230;&#8203;)</code> 是惰性的，后面的 <code>.map</code> 调用也是惰性的，<code>map</code> 通过调用传递给它的代码对象来变换一个个元素。而这也是懒惰地完成的。所以 SQLite 只有在实际访问结果列表中的元素时，才会从数据库文件中检索行。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用存储后端">7.3. 使用存储后端</h3>
<div class="paragraph">
<p>有了存储 API，就该用了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN(*@cmd, :$timeout, :$jobname is copy,
               :$statefile='silent-cron.sqlite3', Int :$tries = 3) {
    $jobname //= @cmd.Str;
    my $result = run-with-timeout(@cmd, :$timeout);
    my $repo = ExecutionResultRepository.new(:$jobname, :$statefile);
    $repo.insert($result);

    my @runs = $repo.tail($tries);

    unless $result.is-success or @runs.grep({.is-success}) {
        say "The last @runs.elems() runs of @cmd[] all failed, the last execution ",
        $result.timed-out ?? "ran into a timeout"
                          !! "exited with code $result.exitcode()";

        print "Output:\n", $result.output if $result.output;
    }
    exit $result.exitcode // 2;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，一个作业如果连续成功几次，然后连续失败两次，就不会产生任何错误输出；只有连续第三次执行失败，才会产生输出。你可以在命令行中用 <code>--tries=5</code> 来覆盖。</p>
</div>
<div class="paragraph">
<p>MAIN 子例程使用构造 <code>$var //= EXPR</code>。 <code>//</code> 代表 <strong>defined-OR,</strong>，所以如果有定义的值，它会返回左侧的值。否则，它计算并返回 EXPR 的值。结合赋值运算符，只有在变量未定义的情况下，它才会对右边的值进行计算，然后将表达式的值存储在变量中。这是一个确保变量得到一个值的方便方法，甚至可以说是写缓存的一个简短方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_扩展空间">7.4. 扩展空间</h3>
<div class="paragraph">
<p>一个系统管理员如果要调查一个 cron 作业失败的原因，可能会对该作业的历史记录感兴趣。你可以实现一个命令，列出最后的作业运行情况、成功或失败、退出代码，或者可能是运行时间等等。</p>
</div>
<div class="paragraph">
<p>或者你可以研究一个不同的后端。如果你想把状态存储在 JSON 文件而不是 SQLite 中呢？或者两者都启用呢？(提示：你可以使用JSON::Tiny<sup class="footnote">[<a id="_footnoteref_46" class="footnote" href="#_footnotedef_46" title="View footnote.">46</a>]</sup>或JSON::Fast<sup class="footnote">[<a id="_footnoteref_47" class="footnote" href="#_footnotedef_47" title="View footnote.">47</a>]</sup>模块)。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_7">7.5. 总结</h3>
<div class="paragraph">
<p>我们已经讨论过 DBIish，这是一个具有可插拔后端的数据库 API，并探讨了用它和 SQLite 来存储持久化数据。在这个过程中，我们还接触到了惰性列表和一种新形式的字符串字库，叫做 heredocs。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_回顾_raku_基础知识">8. 回顾 Raku 基础知识</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在前面的章节中，我们讨论了一些与Raku机制相互交叉的例子，这些例子使它们起作用。 在这里，我想总结和深化我们迄今为止所涉及的Raku知识，从原始示例中删除。</p>
</div>
<div class="sect2">
<h3 id="_变量和作用域">8.1. 变量和作用域</h3>
<div class="paragraph">
<p>在Raku中，变量名由sigil，$，@，％或＆组成，后跟标识符。 sigil意味着类型约束，其中$是最常见的约束
（默认情况下没有限制），@表示数组，％表示哈希（关联数组/映射），＆表示代码对象。
标识符可以包含 - 和&#8217;字符，只要它后面的字符是字母。 标识符必须以字母或下划线开头。
用我声明的子程序和变量是词法范围的。 从声明到当前{} -enclosed块（或当前文件，如果声明在块外）的结尾，它们是可见的。 子程序参数在子程序的签名和块中可见。
在印记和标识符之间的可选树枝可以影响范围。 * twigil标记一个动态范围的变量; 因此，在当前调用堆栈中执行查找。！ 标记属性，即附加到对象的每实例变量。</p>
</div>
</div>
<div class="sect2">
<h3 id="_子例程">8.2. 子例程</h3>
<div class="paragraph">
<p>子程序或简称子程序是一段具有自己范围的代码，通常也是一个名称。 它有一个签名，指定在调用时必须传递的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub chunks(Str $s, Int $chars) {
#         ^^^^^^^^^^^^^^^^^^^^ signature
#   ^^^^^^ name
    gather for 0 .. $s.chars / $chars - 1 -&gt; $idx {
        take substr($s, $idx * $chars, $chars);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>签名中使用的变量称为参数，而我们调用您在参数中传递的值。
要在不调用子程序的情况下引用子程序，请在它前面放一个与号（＆），如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &amp;chunks.name; # Output: chunks</code></pre>
</div>
</div>
<div class="paragraph">
<p>要调用它，只需使用其名称，然后使用参数列表即可
可选择在括号中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say chunks 'abcd', 2; # Output: (ab cd)
say chunks('abcd', 2); # Output: (ab cd)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果某些其他构造会干扰子例程调用，则只需要括号。 因此，如果你打算写</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say chunks(join('x', 'ab', 'c'), 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>你遗漏了一对内括号</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say chunks(join 'x', 'ab', 'c', 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后所有参数都转到join函数，只剩下一个参数给chunks函数。 另一方面，可以省略外部括号并写入</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say chunks join('x', 'ab', 'c'), 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为这里没有歧义。
值得注意的一个案例是，如果你调用一个没有参数的子程序
if条件或for循环（或类似结构）的块，你必须包括括号，因为否则该块被解析为函数的参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub random-choice() {
    Bool.pick;
}

# right way:
if random-choice() {
    say 'You were lucky.';
}

# wrong way:
if random-choice {
    say 'You were lucky.';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你碰巧犯了这个错误，Raku编译器会非常努力地检测它。 在前面的例子中，它说</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Function 'random-choice' needs parens to avoid gobbling block</code></pre>
</div>
</div>
<div class="paragraph">
<p>当它试图解析if语句的块时，它找不到一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Missing block (apparently claimed by 'random-choice')</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你有一个名为MAIN的子程序时，Raku使用它的签名来解析命令行参数并将这些命令行参数传递给MAIN。
multi subs是几个具有相同名称但签名不同的子程序。 编译器在运行时根据参数和参数之间的最佳匹配来决定它调用哪个候选项。</p>
</div>
</div>
<div class="sect2">
<h3 id="_类和对象">8.3. 类和对象</h3>
<div class="paragraph">
<p>类声明遵循与子例程声明相同的语法模式：关键字class，后跟名称，后跟大括号中的主体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class OutputCapture {
    has @!lines;
    method print(\s) {
        @!lines.push(s);
    }
    method captured() {
        @!lines.join;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，类型名称的范围限定为当前名称空间; 但是，你可以通过在课堂前面添加一个我的词汇来限定词法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my class OutputCapture { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建新实例通常通过在类型对象上调用new方法来工作。 新方法继承自所有类型获得的隐式父类Any：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = OutputCapture.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个实例状态存储在属性中，这些属性使用has关键字声明，如前面的has @！行所示。 属性总是私有的，如下所示！twigil。 如果你使用点。 声明中的twigil相反，你有私有属性@！行和一个公共的只读访问器方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my class OutputCapture {
    has @.lines;
    method print(\s) {
         # the private name with ! still works
         @!lines.push(s);
    }
    method captured() {
        @!lines.join;
    }
}
my $c = OutputCapture.new;
$c.print('42');
# use the `lines` accessor method:
say $c.lines; # Output: [42]</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用点twigil声明属性时，还可以通过命名参数从构造函数初始化属性，如OutputCapture中所示。 new（lines &#8658; [42]）。
私人方法始于！并且只能从类体内部调用self！private-method。
方法基本上只是子程序，有两个不同之处。首先是
他们得到一个名为self的隐式参数，它包含调用该方法的对象（我们称之为调用者）。第二个是，如果调用子例程，编译器将在当前词法范围以及外部范围中搜索此子例程。另一方面，方法调用仅在对象及其超类的类中查找。
子例程查找可以在编译时进行，因为词法作用域在运行时是不可变的，因此编译器具有所有词法符号的知识。但是，即使存在类型约束，编译器也无法知道对象的类型是否可能是类型约束的子类型，这意味着必须将方法查找推迟到运行时。</p>
</div>
</div>
<div class="sect2">
<h3 id="_并发">8.4. 并发</h3>
<div class="paragraph">
<p>Raku为并发和并行执行提供了高级原语。 我们鼓励您使用start运行计算，而不是显式生成新线程，它返回Promise.1。这是一个承诺未来计算将产生结果的对象。 因此，状态可以是Planned，Kept或Broken。 您可以链接承诺，组合它们并等待它们。
在后台，调度程序将此类计算分发到操作系统级线程。 默认调度程序是一个线程池调度程序，其中包含可供使用的线程数的上限。
并行计算之间的通信应该通过线程安全的数据结构进行。 其中最重要的是Channel2（线程安全队列）和Supply3（Raku的Observer Pattern4实现）。 耗材非常强大，因为您可以使用诸如此类的方法对其进行转换
map，grep，throttle或者延迟，并使用他们的</p>
</div>
</div>
<div class="sect2">
<h3 id="_展望">8.5. 展望</h3>
<div class="paragraph">
<p>当您了解本章中讨论的主题并深入了解内置类型时，您应该熟悉Raku的基础知识并能够编写自己的程序。
接下来，我们将研究Raku的优势之一：解析，通过正则表达式和语法。
== 使用正则表达式和 Grammars 解析 INI 文件</p>
</div>
<div class="paragraph">
<p>你之前可能已经见过 <code>.ini</code> 文件; 它们在微软 Windows 平台上很常见, 但是在其它地方也有发现, 例如 ODBC 配置文件, <a href="http://docs.ansible.com/ansible/intro_inventory.html">Ansible 的清单文件</a>, 等等。</p>
</div>
<div class="paragraph">
<p>INI 文件看起来长这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">key1=value2

[section1]
key2=value2
key3 = with spaces
; comment lines start with a semicolon, and are ; ignored by the parser

[section2]
more=stuff</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 提供正则表达式用于解析, 还提供 grammars 用于组织和重用正则表达式。</p>
</div>
<div class="paragraph">
<p>你可以用<a href="https://modules.raku.org/dist/Config::INI">Config::INI</a>模块(用 <code>zef install Config::INI</code> 安装之后)来解析 INI 文件, 就像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Config::INI;
my %hash = Config::INI::parse($ini_string);</code></pre>
</div>
</div>
<div class="paragraph">
<p>它在底层使用了正则表达式和 grammars。这里我们会探索怎样写一个自己的 INI 解析器。</p>
</div>
</div>
<div class="sect2">
<h3 id="_正则表达式基础">8.6. 正则表达式基础</h3>
<div class="paragraph">
<p>正则表达式是一段代码，用作具有共同结构的字符串的模式。 它源于计算机科学概念中的正则表达式，但比纯正则表达式提供了更多的构造, 允许并扩展了一些功能，使它们更容易使用。</p>
</div>
<div class="paragraph">
<p>我们将使用命名正则表达式来匹配基元，然后使用调用这些命名正则表达式的正则表达式为 INI 文件构建解析器。 由于 INI 文件没有普遍接受的正式语法，我们必须一边进行, 一边制作东西。</p>
</div>
<div class="paragraph">
<p>让我们从解析值对开始，比如 <code>key1=value1</code>。 首先让我们考虑一下键。 它可能包含字母，数字和下划线 <code>_</code>。 有一个快捷方式来匹配这些字符，即 <code>\w</code>，并通过附加 <code>+</code> 字符匹配一个或多个字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6;

my regex key { \w+ }

multi sub MAIN('test') {
    use Test;
    ok 'abc'     ~~ /^ &lt;key&gt; $/, '&lt;key&gt; matches a simple identifier';
    ok  '[abc]' !~~ /^ &lt;key&gt; $/, '&lt;key&gt; does not match a  section header';
    done-testing;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>my regex key { \w+ }</code> 声明了一个词法（<code>my</code>）作用域的名为 <code>key</code> 的正则表达式，它匹配一个或多个单词字符。</p>
</div>
<div class="paragraph">
<p>编程语言有很长支持所谓的兼容 Perl 的正则表达式（PCRE）的传统。 许多编程语言支持与 PCRE 的一些偏差，包括 Perl 本身，但在大多数实现中仍然存在常见的语法元素。 Raku 仍支持其中一些元素，但在其他元素中存在很大差异。</p>
</div>
<div class="paragraph">
<p>这里的 <code>\w+</code> 和 PCRE 中的相同，但忽略了 <code>\w+</code> 周围的空白的事实。 在测试例程中，<code>'abc'~~ /^ &lt;key&gt; $/</code> 中的斜杠分隔了一个匿名正则表达式。 在这个正则表达式中，<code>^</code> 和 <code>$</code> 分别表示匹配字符串的开头和结尾，这是 PCRE 所熟悉的。 但是，与 PCRE 相反，<code>&lt;key&gt;</code> 子规则从前面调用命名正则表达式 <code>key</code>。 这是 Raku 的扩展。 在 PCRE 中，正则表达式中的 <code>&lt;</code> 匹配文字 <code>&lt;</code>。 在 Raku 的正则表达式中，它引入了一个子规则调用。</p>
</div>
<div class="paragraph">
<p>通常，所有非单词字符都保留用于“特殊”语法，你必须用引号引起它们或用反斜杠转义它们以获得其字面含义。 例如正则表达式中的 <code>\&lt;</code> 或 <code>'&lt;'</code> 匹配小于号。 引用可以应用于多个字符，因此正则表达式中的 <code>'a+b'</code> 与 a 匹配，后跟加号 <code>+</code>，后跟 b。单词字符（字母，数字和下划线）总是按字面意思匹配。</p>
</div>
<div class="sect3">
<h4 id="_字符类">8.6.1. 字符类</h4>
<div class="paragraph">
<p>除了文字之外，字符类是正则表达式的常见构建块。 有许多预定义的字符类，以反斜杠的形式后跟一个小写的单个字母; 例如，<code>\d</code> 匹配一个数字。 它的反转使用大写字母，所以`\D` 匹配任何不是数字的字符。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">否定</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个数字</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\W</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个单词字符(字母,数字,下划线)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\S</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空格,空白,换行,等等</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\h</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\H</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">水平空白</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\v</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\V</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">垂直空白</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\n</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">逻辑换行(回车,换行)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意字符</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>您还可以通过枚举字符或字符范围来构建自己的字符类：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">例子</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">枚举</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;[abc]&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a, b 或 c</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">否定</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8592;[abc]&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">除了 a, b 或 c 的任何东西</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">范围</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;[a..c]&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a, b 或 c</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_量词">8.6.2. 量词</h4>
<div class="paragraph">
<p>只匹配一个重复的东西很无聊，所以正则表达式提供量词。 量词表示前一个正则表达式必须匹配的频率。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">量词</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配多少个字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..Inf</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1..Inf</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">** 1..5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1..5</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>所以, 对于 <code>ab+</code> 这个例子来说, 它匹配字符串 ab, abb, aab, 但是不匹配 a。</p>
</div>
</div>
<div class="sect3">
<h4 id="_备选分支">8.6.3. 备选分支</h4>
<div class="paragraph">
<p>任何一个或者备选分支由垂直条分隔。 例如，<code>\d+ | x</code> 匹配一个或多个数字的序列或字符 x。</p>
</div>
<div class="paragraph">
<p>如果备选项有多个路径匹配，则 Raku 更喜欢最长匹配。 如果不需要这种行为，<code>||</code> 采取匹配的第一个匹配项。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_解析_ini_原语">8.7. 解析 INI 原语</h3>
<div class="paragraph">
<p>回到 INI 解析，我们必须考虑值内允许的字符。列出允许的字符似乎是徒劳的，因为我们很可能忘记一些。相反，我们应该考虑值中不允许的内容。换行当然不是，因为它们引入了下一个键/值对或节标题。也不允许使用分号，因为它们引入了注释。</p>
</div>
<div class="paragraph">
<p>我们可以将这个排除表示为否定的字符类：<code>&#8592;[ \n ; ]&gt;</code> 匹配既不是换行也不是分号的任何单个字符。请注意，在字符类中，几乎所有字符都失去了特殊含义。只有反斜杠，空格，两个圆点和闭合括号代表自己以外的任何东西。在字符类的内部和外部，<code>\n</code> 匹配单个换行符， <code>\s</code> 匹配单个空格。大写的字符类反转其语义，例如 <code>\S</code> 匹配任何不是空格的单个字符。</p>
</div>
<div class="paragraph">
<p>这导致我们使用正则表达式的版本来匹配 INI 文件中的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex value { &lt;-[ \n ; ]&gt;+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个正则表达式有一个问题：它还匹配前导和尾随空格，我们不想将其视为值的一部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex value { &lt;-[ \n ; ]&gt;+ }
if ' abc ' ~~ /&lt;value&gt;/ {
    say "matched '$/'"; # matched ' abc '
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 Raku 正则表达式仅限于计算机科学中的常规语言感觉，我们必须做这样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex value {
    # match a first non-whitespace character
    &lt;-[ \s ; ]&gt;
    [
        # then arbitrarily many that can contain whitespace
        &lt;-[ \n ; ]&gt;*
        # ... terminated by one non-whitespace
        &lt;-[ \s ; ]&gt;
    ]?  # and make it optional, in case the value is only
        # only one non-whitespace character
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而现在你知道为什么人们在提议用正则表达式解决问题时回答“现在你有两个问题”。 一个更简单的解决方案是匹配首先引入的值，然后引入一个约束，即第一个字符和最后一个字符都不是空格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex value { &lt;!before \s&gt; &lt;-[ \n ; ]&gt;+ &lt;!after \s&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>以及伴随的测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">is ' abc ' ~~ /&lt;value&gt;/, 'abc', '&lt;value&gt; does not match leading or trailing whitespace';
is ' a'    ~~ /&lt;value&gt;/, 'a',   '&lt;value&gt; matches single non-whitespace too';
ok "a\nb" !~~ /^ &lt;value&gt; $/,    '&lt;value&gt; does not match \n';</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&lt;!before regex&gt;</code> 是否定前瞻，即，以下文本必须与正则表达式不匹配，并且匹配时不会消耗文本。 不出所料，<code>&lt;!after regex&gt;</code> 是否定的后视，它试图匹配已经匹配的文本，并且必须不能成功完成整个匹配才能成功。</p>
</div>
<div class="paragraph">
<p>这是 Raku，当然还有另一种解决这个问题的方法。 如果你将需求表达为“一个值不能包含换行符或分号，并以非空格开头并以非空格结尾”，那么很明显，如果我们在正则表达式中只有一个AND运算符，这可能很容易。 它是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex value { &lt;-[ \n ; ]&gt;+ &amp; \S.* &amp; .*\S }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&amp;</code> 运算符分隔两个或多个必须的较小的正则表达式
all成功匹配相同的字符串，以使整个匹配成功。 <code>\S.*</code> 匹配任何以非空白字符（<code>\S</code>）开头的字符串，后跟任意数字（。）任意次数 <code>\*</code>。 同样 <code>.*\S</code> 匹配任何以非空白字符结尾的字符串。</p>
</div>
<div class="paragraph">
<p>谁会想到匹配一些看似简单的配置文件中的值可能如此复杂？ 幸运的是，匹配键/值对现在要简单得多，因为我们知道如何匹配每个键：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex pair { &lt;key&gt; '=' &lt;value&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要没有围绕平等的空白，这就很有效标志。 如果有，我们必须单独匹配它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex pair { &lt;key&gt; \h* '=' \h* &lt;value&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>\h</code> 匹配一个水平空格，即空格，制表符或任何其他奇特的空间类型的东西，我们为我们存储（例如，也是不间断的空格），但不是换行符。
说到换行符，在正则表达式对的末尾匹配换行符是个好主意，因为我们忽略空行，所以我们也匹配多个行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex pair { &lt;key&gt; \h* '=' \h* &lt;value&gt; \n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>是时候写一些测试了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">ok "key=value\n" ~~ /&lt;pair&gt;/, 'simple pair';
ok "key = value\n\n" ~~ /&lt;pair&gt;/, 'pair with blanks';
ok "key\n= value\n" !~~ /&lt;pair&gt;/, 'pair with newline before assignment';</code></pre>
</div>
</div>
<div class="paragraph">
<p>节标题是方括号中的字符串，因此字符串本身不应包含括号或换行符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex header { '[' &lt;-[ \[ \] \n ]&gt;+ ']' \n+ }
# and in multi sub MAIN('test'):
ok "[abc]\n"    ~~ /^ &lt;header&gt; $/, 'simple header';
ok "[a c]\n"    ~~ /^ &lt;header&gt; $/, 'header with spaces';
ok "[a [b]]\n" !~~ /^ &lt;header&gt; $/, 'cannot nest headers';
ok "[a\nb]\n"  !~~ /^ &lt;header&gt; $/, 'No newlines inside headers';</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后剩下的原语是注释</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex comment { ';' \N*\n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>\N</code> 匹配任何不是换行符的字符，因此注释只是一个分号，然后是直到行尾的任何东西。</p>
</div>
</div>
<div class="sect2">
<h3 id="_把东西组装起来">8.8. 把东西组装起来</h3>
<div class="paragraph">
<p>INI 文件的 <strong>section</strong> 是标题，后跟一些键/值对或注释行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex section {
    &lt;header&gt;
    [ &lt;pair&gt; | &lt;comment&gt; ]*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>[&#8230;&#8203;]</code> 将正则表达式的一部分分组，以便量词 <code>*</code> 应用于整个组，而不仅仅是最后一项。</p>
</div>
<div class="paragraph">
<p>整个 INI 文件可能包含一些初始键/值对或注释，后跟一些 section：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex inifile {
    [ &lt;pair&gt; | &lt;comment&gt; ]*
    &lt;section&gt;*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>狂热的读者注意到 <code>[ &lt;pair&gt; | &lt;comment&gt; ]*</code> 正则表达式的一部分已被使用了两次，因此最好将其提取为独立的正则表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex block   { [ &lt;pair&gt; | &lt;comment&gt; ]* }
my regex section { &lt;header&gt; &lt;block&gt; }
my regex inifile { &lt;block&gt; &lt;section&gt;* }</code></pre>
</div>
</div>
<div class="paragraph">
<p>是时候进行“终极”测试了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $ini = q:to/EOI/;
key1=value2

[section1]
key2=value2
key3 = with spaces

; comment lines start with a semicolon, and are
; ignored by the parser

[section2]
more=stuff
EOI

ok $ini ~~ /^&lt;inifile&gt;$/, 'Can parse a full INI file';</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_回溯">8.9. 回溯</h3>
<div class="paragraph">
<p>对许多程序员来说，正则表达式匹配似乎很神奇。 您只需说明模式，正则表达式引擎就会确定字符串是否与模式匹配。 虽然实现正则表达式引擎是一项棘手的业务，但基础知识并不难理解。
正则表达式引擎从左到右遍历正则表达式的各个部分，尝试匹配正则表达式的每个部分。 它跟踪到目前为止它在光标中匹配的字符串部分。 如果正则表达式的一部分找不到匹配项，则正则表达式引擎会尝试更改上一个匹配项以占用更少的字符，然后在新位置重试失败的匹配项。
例如，如果您执行正则表达式匹配</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'abc' ~~ /.* b/</code></pre>
</div>
</div>
<div class="paragraph">
<p>正则表达式引擎首先评估。*。的。匹配任何角色。 *量词是贪婪的，这意味着它尝试匹配尽可能多的字符。它最终匹配整个字符串，abc。然后正则表达式引擎尝试匹配b，这是一个文字。由于前一个匹配吞噬了整个字符串，因此将c与剩余的空字符串匹配失败。所以前面的正则表达式部分。*必须放弃一个字符。它现在匹配ab，b的文字匹配器比较b和c，并再次失败。所以有一个最后的迭代，其中。*再次放弃它匹配的一个字符，现在b文字可以匹配字符串中的第二个字符。
在正则表达式的各部分之间来回称为回溯。当您在字符串中搜索模式时，这是一个很棒的功能。但在解析器中，通常不可取。例如，如果正则表达式键与输入key2 = value2中的子字符串key2匹配，则不希望它匹配较短的子字符串，因为正则表达式的下一部分无法匹配。
您不希望这样做有三个主要原因。首先是它使调试更难。当人们思考文本的结构时，他们通常会很快地进行基本的标记化，例如单词或句子结束的地方。因此，回溯可能非常不直观。如果根据哪个正则表达式无法匹配生成错误消息，则回溯基本上总是导致错误消息非常无用。
第二个原因是回溯可能导致意外的正则表达式匹配。例如，您希望匹配两个单词，可选地用空格分隔，并尝试将其直接转换为正则表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "two words" ~~ /\w+\s*\w+/; # 「two words」</code></pre>
</div>
</div>
<div class="paragraph">
<p>这似乎有效：第一个\ w +匹配第一个单词，第二个匹配第二个单词，一切都很好。直到你发现它实际上也匹配一个单词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "two" ~~ /\w+\s*\w+/; # 「two」</code></pre>
</div>
</div>
<div class="paragraph">
<p>那是怎么发生的？好吧，第一个\ w +匹配整个单词，\ s *成功匹配空字符串，然后第二个\ w +失败，强制正则表达式的前两部分匹配不同。所以在第二次迭代中，第一个\ w +只匹配tw，\ s *匹配tw和o之间的空字符串，第二个\ w +匹配o。然后你就会意识到这一点
如果两个单词没有用空格分隔，你怎么知道一个单词的结尾和下一个单词的开头？禁用回溯后，正则表达式无法匹配而不是以非预期的方式进行匹配。
第三个原因是表现。当你禁用回溯时，正则表达式引擎必须只查看每个字符一次，或者对于每个分支，它可以在备选方案中查看。通过回溯，正则表达式引擎可能会卡在回溯循环中，随着输入字符串长度的增加，这种循环占用的时间会过长。
要禁用回溯，您只需在声明中使用令牌替换单词regex，或在正则表达式中使用：ratchet修饰符。
在INI文件解析器中，只有正则表达式值需要回溯（尽管前面讨论的其他公式不需要它）;所有其他正则表达式都可以安全地切换到令牌：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my token key     { \w+ }
my regex value   { &lt;!before \s&gt; &lt;-[\n;]&gt;+ &lt;!after \s&gt; }
my token pair    { &lt;key&gt; \h* '=' \h* &lt;value&gt; \n+ }
my token header  { '[' &lt;-[ \[ \] \n ]&gt;+ ']' \n+ }
my token comment { ';' \N*\n+ }
my token block   { [ &lt;pair&gt; | &lt;comment&gt; ]* }
my token section { &lt;header&gt; &lt;block&gt; }
my token inifile { &lt;block&gt; &lt;section&gt;* }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_grammars">8.10. Grammars</h3>
<div class="paragraph">
<p>这组解析INI文件的正则表达式并不是封装和可重用性的顶峰。
因此，我们将探索语法，一种将正则表达式组合成类结构的功能，以及如何从成功匹配中提取结构化数据。
语法是一个具有一些额外功能的类，使其适用于解析文本。 除了方法和属性，您还可以将正则表达式放入语法中。
这是INI文件解析器在表达为语法时的样子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar IniFile {
    token key     { \w+ }
    token value   { &lt;!before \s&gt; &lt;-[\n;]&gt;+ &lt;!after \s&gt; }
    token pair    { &lt;key&gt; \h* '=' \h* &lt;value&gt; \n+ }
    token header  { '[' &lt;-[ \[ \] \n ]&gt;+ ']' \n+ }
    token comment { ';' \N*\n+ }
    token block   { [&lt;pair&gt; | &lt;comment&gt;]* }
    token section { &lt;header&gt; &lt;block&gt; }
    token TOP     { &lt;block&gt; &lt;section&gt;* }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过调用使用的parse方法来使用它来解析一些文本
正则表达式或令牌TOP作为入口点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result = IniFile.parse($text);</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了标准化的入口点，语法提供了更多的优势。您可以像普通类一样继承它，从而为正则表达式带来更多的可重用性。您可以通过向语法添加方法将额外功能与正则表达式组合在一起。语法中还有一些机制可以使您作为开发人员的生活更轻松。
其中一个是处理空白。在INI文件中，水平空格通常被认为是无关紧要的，因为key = value和key = value导致应用程序的相同配置。到目前为止，我们通过将\ h *添加到令牌对来明确地处理了这个问题。但是有些地方我们还没有真正考虑过。例如，可以让评论不在行的开头。
语法提供的机制是您可以定义一个名为ws的规则，当您使用规则而不是令牌声明令牌（或通过：sigspace修饰符在regex中启用此功能）时，Raku会为您插入隐式&lt;ws&gt;调用正则表达式定义中有空格的地方：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar IniFile {
    token ws { \h* }
    rule pair { &lt;key&gt;    '='    &lt;value&gt; \n+ }
    # rest as before
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于需要解析空格的单个规则来说，这可能不值得付出努力，但是当有更多时，这确实可以通过在一个位置保持空格分析来获得回报。
请注意，您应该只解析令牌ws中无关紧要的空格。 对于INI文件，换行是重要的，因此ws不应与它们匹配。</p>
</div>
</div>
<div class="sect2">
<h3 id="_从匹配中提取数据">8.11. 从匹配中提取数据</h3>
<div class="paragraph">
<p>到目前为止，IniFile语法仅检查给定输入是否与语法匹配。 但是，当它匹配时，我们真的希望解析结果在一个易于使用的数据结构中。 例如，我们可以翻译这个示例INI文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">key1=value2

[section1]
key2=value2
key3 = with spaces
; comment lines start with a semicolon, and are
; ignored by the parser

[section2]
more=stuff</code></pre>
</div>
</div>
<div class="paragraph">
<p>进入嵌套哈希的数据结构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
_ =&gt; {
          key1 =&gt; "value2"
      },
      section1 =&gt; {
          key2 =&gt; "value2",
          key3 =&gt; "with spaces"
      },
      section2 =&gt; {
          more =&gt; "stuff"
      }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，任何部分外部的键/值对都显示在_顶级键中。
IniFile.parse调用的结果是一个Match5对象，它具有（几乎）提取所需匹配所需的所有信息。 如果将Match对象转换为字符串，它将成为匹配的字符串。 但还有更多。 您可以像散列一样使用它来从命名子匹配中提取匹配项。 因此，如果顶级匹配来自</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token TOP { &lt;block&gt; &lt;section&gt;* }</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生一个Match对象 <code>$m</code>，然后 <code>$m&lt;block&gt;</code> 再次成为一个 Match 对象，这一个来自对象块的调用匹配。 <code>$m&lt;section&gt;</code> 是重复调用令牌部分的 Match 对象列表。 所以匹配实际上是一个匹配树（图9-1）。</p>
</div>
<div class="paragraph">
<p>我们可以使用此数据结构来提取嵌套的哈希值。 标头标记匹配像“[section1] \ n”这样的字符串，我们只对“section1”感兴趣。 为了到达内部部分，我们可以通过在我们感兴趣的匹配的子规则周围插入一对括号来修改标题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token header { '[' ( &lt;-[ \[ \] \n ]&gt;+ ) ']' \n+ }
#                   ^^^^^^^^^^^^^^^^^^^^ a capturing group</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个捕获组，我们可以通过使用头部的顶级匹配作为数组并访问其第一个元素来获得匹配。 这导致我们完整的INI解析器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub parse-ini(Str $input) {
    my $m = IniFile.parse($input);
    unless $m {
        die "The input is not a valid INI file.";
    }

    sub block(Match $m) {
        my %result;
        for $m&lt;block&gt;&lt;pair&gt; -&gt; $pair {
            %result{ $pair&lt;key&gt;.Str } = $pair&lt;value&gt;.Str;
        }
        return %result;
    }

    my %result;
    %result&lt;_&gt; = block($m);
    for $m&lt;section&gt; -&gt; $section {
        %result{ $section&lt;header&gt;[0].Str } = block($section);
    }
    return %result;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种自上而下的方法有效，但它需要非常仔细地理解语法的结构。这意味着如果在维护期间更改结构，则很难确定如何更改数据提取代码。
Raku也提供自下而上的方法。它允许您为每个正则表达式，标记或规则编写数据提取或操作方法。语法引擎将匹配对象作为单个参数传递，action方法可以调用例程make将结果附加到匹配对象。结果可通过匹配对象上的.made方法获得。
一旦正则表达式成功匹配，就会执行此操作方法的执行;因此，正则表达式的动作方法可以依赖于子规则调用的动作方法已经运行的事实。例如，当正在执行规则对{&lt;key&gt;'='&lt;value&gt; \ n +}时，第一个令牌密钥成功匹配，其操作方法立即运行。然后，令牌值匹配，其操作方法也运行。最后，规则对本身可以成功匹配，因此其操作方法可以依赖于$ m &lt;key&gt; .made和$ m &lt;value&gt;。假设匹配结果存储在变量$ m中，则可用。</p>
</div>
<div class="paragraph">
<p>说到变量，正则表达式匹配隐式地将其结果存储在特殊变量$ /中，并且习惯上使用$ /作为动作方法中的参数。 还有一个访问命名子匹配的快捷方式：您可以编写$ &lt;key&gt;而不是编写$ / &lt;key&gt;。 考虑到这种约定，动作类就变成了</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class IniFile::Actions {
    method key($/) { make $/.Str }
    method value($/) { make $/.Str }
    method header($/) { make $/[0].Str }
    method pair($/) { make $&lt;key&gt;.made =&gt; $&lt;value&gt;.made }
    method block($/) { make $&lt;pair&gt;.map({ .made }).hash }
    method section($/) { make $&lt;header&gt;.made =&gt; $&lt;block&gt;.made }
    method TOP($/) {
        make {
            _ =&gt; $&lt;block&gt;.made,
            $&lt;section&gt;.map: { .made },
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前两种动作方法非常简单。键或值匹配的结果只是匹配的字符串。对于标题，它只是括号内的子字符串。恰好，一对返回一个Pair6对象，由key和value组成。块方法从块中的所有行构造散列
通过迭代每对子匹配并提取已经连接的Pair对象。比匹配树高一级，该部分获取该哈希并将其与段的名称配对，从$ &lt;header&gt; .made中提取。最后，顶级操作方法收集key _以及所有部分下的无段键/值对，并以散列形式返回它们。
在动作类的每个方法中，我们只依赖于直接从正则表达式调用的第一级正则表达式的知识，这些正则表达式对应于动作方法和它们所制作的数据类型。因此，当您重构一个正则表达式时，您还必须仅更改相应的操作方法。没有人需要了解语法的全局结构。
现在我们只需告诉Raku实际使用action类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub parse-ini(Str $input) {
    my $m = IniFile.parse($input, :actions(IniFile::Actions));
    unless $m {
        die "The input is not a valid INI file.";
    }

    return $m.made
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要使用与TOP不同的规则（例如，您可能希望在测试中执行）开始解析，则可以将命名参数规则传递给方法解析：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub parse-ini(Str $input, :$rule = 'TOP') {
    my $m = IniFile.parse($input,
        :actions(IniFile::Actions),
        :$rule,
    );
    unless $m {
        die "The input is not a valid INI file.";
    }

    return $m.made
}

say parse-ini($ini).perl;

use Test;

is-deeply parse-ini("k = v\n", :rule&lt;pair&gt;), 'k' =&gt; 'v',
    'can parse a simple pair';
done-testing;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了更好地封装语法中的所有解析功能，我们可以将parse-ini转换为方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar IniFile {
    # regexes/tokens unchanged as before

    method parse-ini(Str $input, :$rule = 'TOP') {
        my $m = self.parse($input,
            :actions(IniFile::Actions),
            :$rule,
        );
    unless $m {
        die "The input is not a valid INI file.";
    }

    return $m.made
    }
}

# Usage:

my $result = IniFile.parse-ini($text);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">为了使这项工作，IniFile </dt>
<dd>
<p>Actions类必须在语法之前声明，或者需要在文件顶部使用类IniFile :: Action {&#8230;&#8203;}预先声明（使用文字三个点来标记 它作为前瞻性声明）。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_生成好的错误信息">8.12. 生成好的错误信息</h3>
<div class="paragraph">
<p>良好的错误消息对任何产品的用户体验都至关重要。 解析器也不例外。 考虑第5行的消息Square括号[在第3行用花括号封闭}，而不是Python的惰性和泛型SyntaxError：无效语法。
除了文本消息之外，了解解析错误的位置有助于找出错误的原因。
我们将使用我们的INI文件解析器作为示例，探索如何从Raku语法生成更好的解析错误消息。</p>
</div>
<div class="sect3">
<h4 id="_failure_is_normal">8.12.1. Failure Is Normal</h4>
<div class="paragraph">
<p>在我们开始之前，重要的是要意识到在基于语法的解析器中，正则表达式无法匹配是正常的，即使在整体成功的解析中也是如此。
让我们回想一下解析器的一部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token block   { [&lt;pair&gt; | &lt;comment&gt;]* }
token section { &lt;header&gt; &lt;block&gt; }
token TOP     { &lt;block&gt; &lt;section&gt;* }</code></pre>
</div>
</div>
<div class="paragraph">
<p>当这个语法与字符串匹配时</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">key=value
[header]
other=stuff</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后TOP调用block，调用pair和comment。 对匹配成功，评论匹配失败。 没什么大不了。 但由于令牌块中有*量词，它会再次尝试匹配对或注释。 两者都没有成功，但令牌块的整体匹配仍然成功。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">可视化传递和失败子匹配的一种好方法是安装Grammar </dt>
<dd>
<p>Tracer模块（zef install Grammar :: Tracer），并在语法定义之前简单地添加语句使用Grammar :: Tracer。这会生成调试输出，显示哪些规则匹配，哪些不匹配：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">TOP
|  block
|  |  pair
|  |  |  key
|  |  |  * MATCH "key"
|  |  |  ws
|  |  |  * MATCH ""
|  |  |  ws
|  |  |  * MATCH ""
|  |  |  value
|  |  |  * MATCH "value"
|  |  |  ws
|  |  |  * MATCH ""
|  |  |  ws
|  |  |  * MATCH ""
|  |  * MATCH "key=value\n"
|  |  pair
|  |  |  key
|  |  |  * FAIL
|  |  * FAIL
|  |  comment
|  |  * FAIL
|  * MATCH "key=value\n"
|  section
...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_检测有害失败">8.12.2. 检测有害失败</h4>
<div class="paragraph">
<p>要生成良好的解析错误消息，您必须区分预期和意外的解析失败。 如前所述，单个正则表达式或令牌的匹配失败通常不表示输入格式错误。 但是你可以找到你知道的点，一旦正则表达式引擎到达这一点，其余的匹配必须成功。
如果你记得对：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule pair { &lt;key&gt; '=' &lt;value&gt; \n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们知道如果解析了一个键，我们真的希望下一个字符是一个等号。 如果不是，则输入格式不正确。
在代码中，这样写的如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule pair {
    &lt;key&gt;
    [ '=' || &lt;expect('=')&gt; ]
    &lt;value&gt; \n+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>|| 是一个顺序替代，它首先尝试匹配左侧的子规则，如果失败则只执行右侧。
所以现在我们必须定义expect：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method expect($what) {
    die "Cannot parse input as INI file: Expected $what";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>是的，您可以像正则表达式一样调用方法，因为正则表达式实际上是方法。 die会抛出异常，所以现在格式错误的输入会产生错误</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot parse input as INI file: Expected =</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后是回溯。 这已经比“无效语法”更好了，尽管这个位置仍然缺失。 在方法期望中，我们可以通过方法pos找到当前的解析位置，该方法由语法声明带来的隐式父类Grammar7提供。
我们可以使用它来改进错误消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method expect($what) {
    die "Cannot parse input as INI file: Expected $what at character
    {self.pos}";
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_提供上下文">8.12.3. 提供上下文</h4>
<div class="paragraph">
<p>对于较大的输入，我们确实要打印行号。 为了计算，我们
需要获取目标字符串，该字符串可通过方法目标获得：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method expect($what) {
    my $parsed-so-far = self.target.substr(0, self.pos);
    my @lines = $parsed-so-far.lines;
    die "Cannot parse input as INI file: Expected $what at line
    @lines.elems(), after '@lines[*-1]'";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这使我们从错误信息的“meh”领域变得非常好。 从而，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">IniFile.parse(q:to/EOI/);
key=value
[section]
key_without_value
more=key
EOI</code></pre>
</div>
</div>
<div class="paragraph">
<p>now dies with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot parse input as INI file: Expected = at line 3, after
'key_without_value'</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过在解析失败位置之前和之后提供上下文来进一步细化expect方法。 当然，你必须申请
[东西|| &lt;expect（'thing'）&gt;]模式在正则表达式中的更多位置以获得更好的错误消息。
最后，您还可以提供不同类型的错误消息。 例如，在解析节标题时，一旦初始[解析，您可能不希望出现错误消息“预期的节标题”，而是“格式错误的节标题，在行&#8230;&#8203;”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule pair {
    &lt;key&gt;
    [ '=' || &lt;expect('=')&gt; ]
    [ &lt;value&gt; || &lt;expect('value')&gt;]
    \n+
}
token header {
    '['
     [ ( &lt;-[ \[ \] \n ]&gt;+ )    ']'
         || &lt;error("malformed section header")&gt; ]
}
...
method expect($what) {
    self.error("expected $what");
}

method error($msg) {
    my $parsed-so-far = self.target.substr(0, self.pos);
    my @lines = $parsed-so-far.lines;
    die "Cannot parse input as INI file: $msg at line @lines.
    elems(), after '@lines[*-1]'";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于Rakudo Raku使用语法来解析Raku输入，因此您可以使用Rakudo自己的语法8作为灵感来源，以获得更好的错误报告方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解析匹配对的缺点">8.12.4. 解析匹配对的缺点</h4>
<div class="paragraph">
<p>由于它是如此常见的任务，Raku语法具有特殊的目标匹配语法，用于将一对分隔符与它们之间的某些内容进行匹配。 在INI文件示例中，这是一对括号，它们之间有一个节头。
我们可以改变</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token header { '[' ( &lt;-[ \[ \] \n ]&gt;+ ) ']' \n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>来读取</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token header { '[' ~ ']' ( &lt;-[ \[ \] \n ]&gt;+ ) \n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这不仅具有将匹配分隔符放在一起的美学优势，如果除了结束分隔符之外的所有内容都匹配，它还会为我们调用方法FAILGOAL。 我们可以使用它来为匹配对的解析失败生成更好的错误消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method FAILGOAL($goal) {
    my $cleaned-goal = $goal.trim;
    $cleaned-goal = $0 if $goal ~~ / \' (.+) \' /;
    self.error("Cannot find closing $cleaned-goal");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>传递给FAILGOAL的参数是正则表达式源代码的字符串，它无法匹配结束分隔符，此处为']'（带有尾随空格）。 从那里我们想要为错误消息提取文字]，因此在方法中间的正则表达式匹配。 如果该正则表达式成功匹配，则文字位于$ / [0]中，其中$ 0是快捷方式。
使用〜的所有解析构造都可以从这样的方法FAILGOAL中受益，因此在一个语法中写一个是值得的，它可以解析几个不同的引用或包围结构。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_编写你自己的_grammars">8.13. 编写你自己的 Grammars</h3>
<div class="paragraph">
<p>解析是一项必须学习的技能，大多与您的普通编程技能不同。 所以我鼓励你从一些小的东西开始，比如CSV的解析器或逗号分隔的值.9很容易一次性写出一个完整的语法，但我建议从解析一些原子开始（就像一个单元格的 两个逗号之间的数据），测试它，然后才进入下一个逗号。
即使在像CSV这样看似简单的东西中，也会出现一些复杂性。 例如，您可以允许引用的字符串本身可以包含分隔符，以及一个转义字符，允许您在引用的字符串中使用引号字符。
如果您对正则表达式的深层处理感兴趣，我强烈推荐Jeffrey E. F. Friedl掌握正则表达式（O&#8217;Reilly Media，2008）。 它不处理Raku正则表达式，但这些概念很好地转换为Raku正则表达式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_8">8.14. 总结</h3>
<div class="paragraph">
<p>Raku允许正则表达式重用，将它们视为一等公民，允许它们像普通例程一样被命名和调用。 通过允许正则表达式内的空白来消除进一步的混乱。
这些功能允许您编写正则表达式来解析正确的文件格式甚至编程语言。 语法允许您构建，重用和封装正则表达式。
正则表达式匹配的结果是Match对象，它实际上是一个树，每个命名子匹配和每个捕获组都有节点。 操作方法可以轻松地将解析与数据提取分离。
要从解析器生成良好的错误消息，您需要区分预期和意外匹配失败。 顺序替代|| 是一个工具，您可以通过从备选方案的第二个分支引发异常来将意外匹配失败转换为错误消息。
You bought a shiny new 2TB disk just a short while ago and you’re already getting low disk space warnings. What’s taking up all that space?
To answer this question, and experiment a bit with data visualization, let’s write a small tool that visualizes which files use up how much disk space. We also get to explore some functional programming concepts in the process.
10.1 Reading File Sizes
To visualize file usage, we must first recursively read all directories and files in a given directory, and record their sizes. To get a listing of all elements in a directory, we can use the dir1 function, which returns a lazy list of IO::Path2 objects.
We distinguish between directories, which can have child entries, and files, which can’t. Both can have a direct size, and in the case of directories also a total size, which includes files and subdirectories, recursively:
class File { has $.name;
has $.size;
method total-size() { $.size } }</p>
</div>
<div class="paragraph">
<p>class Directory { has $.name; has $.size;
has @.children;
has $!total-size; method total-size() {
        $!total-size //= $.size + @.children.map({.total-size}).sum;
    }
}
sub tree(IO::Path $path) { if $path.d {
return Directory.new(
            name     &#8658; $path.basename,
            size     &#8658; $path.s,
            children &#8658; dir($path).map(&amp;tree),
); }
else {
return File.new(
            name &#8658; $path.Str,
            size &#8658; $path.s,
        );
} }
The code for reading a file tree recursively uses the d and s methods on IO::Path. d returns True for directories and False for files. s returns the size.3
Just to check that we’ve got a sensible data structure, we can write a short routine that prints it recursively, with indentation to indicate nesting of directory entries:
sub print-tree($tree, Int $indent = 0) {
say ' ' x $indent, format-size($tree.total-size), ' ', $tree.name;
if $tree ~~ Directory {
print-tree($_, $indent + 2) for $tree.children }
}</p>
</div>
<div class="paragraph">
<p>sub format-size(Int $bytes) {
my @units = flat '', &lt;k M G T P&gt;;
my @steps = (1, { $_ * 1024 } &#8230;&#8203; *).head(6); for @steps.kv &#8594; $idx, $step {
my $in-unit = $bytes / $step; if $in-unit &lt; 1024 {
return sprintf '%.1f%s', $in-unit, @units[$idx]; }
} }
sub MAIN($dir = '.') { print-tree(tree($dir.IO));
}</p>
</div>
<div class="paragraph">
<p>The subroutine print-tree is pretty boring, if you’re used to recursion.
It prints out the name and size of the current node and, if the current node is
a directory, recurses into each children with an increased indentation. The indentation is applied through the x string repetition operator, which when called as $string x $count repeats the $string $count times. It uses the ∼∼ smart matching operator to perform a type check; it tests if $tree is a Directory.
To get a human-readable representation of the size of a number, format- size knows a list of six units: the empty string for one, k (kilo) for 1024, M (mega) for 1024×1024, and so on. This list is stored in the array @units. The multiple associated with each unit is stored in @steps, which is initialized through the series operator &#8230;&#8203;. Its structure is INITIAL, CALLABLE &#8230;&#8203; LIMIT, where it applies CALLABLE first to the initial value, and then to the next value generated, and so on, until it hits LIMIT. The limit here is *, a special term called Whatever, which means it’s unlimited. Thus, the sequence operator returns a lazy, potentially infinite, list and the trailing .head(6) call limits it to six values.
To find the most appropriate unit to print with the size, we have to iterate over both the values and the indices of the array, which for @steps.kv &#8594; $idx, $step { .. } accomplishes. sprintf, known from other programming languages, does the actual formatting to one digit after the dot and appends the unit.
10.2 Generating a Tree Map
One possible visualization of file and directory sizes is a tree map, which represents each directory as a rectangle and each file inside it as a rectangle within the directory’s rectangle. The size of each rectangle is proportional to the size of the file or directory it represents.</p>
</div>
<div class="paragraph">
<p>We’ll generate an SVG file containing all those rectangles. Modern browsers support displaying such files and also show mouse-over texts for each rectangle. This alleviates the burden of actually labeling the rectangles, which can be quite a hassle.
To generate the SVG, we’ll use the SVG module, which you can install with $ zef install SVG
This module provides a single static method, into which you pass nested pairs. Pairs whose values are arrays are turned into XML tags; other pairs are turned into attributes. As an example, this Raku script
use SVG;
print SVG.serialize(
    :svg[
        width &#8658; 100,
        height &#8658; 20,
        title &#8658; [
'example', ]
], );
produces this output:
&lt;svg xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="100"
height="20"&gt; &lt;title&gt;example&lt;/title&gt;
&lt;/svg&gt;</p>
</div>
<div class="paragraph">
<p>(without the indentation). The xmlns-tags are helpfully added by the SVG module and are necessary for programs to recognize the file as SVG.
Returning to the tree maps (Figure 10-1), a very simple way to lay out the rectangle is to recurse into areas and for each area subdivide it either horizontally or vertically, depending upon which axis is longer:
sub tree-map($tree, :$x1!, :$x2!, :$y1!, :$y2) {
# do not produce rectangles for small files/dirs return if ($x2 - $x1) * ($y2 - $y1) &lt; 20;
    # produce a rectangle for the current file or dir</p>
</div>
<div class="paragraph">
<p>take 'rect' &#8658; [
x &#8658; $x1,
y &#8658; $y1,
        width  &#8658; $x2 - $x1,
        height &#8658; $y2 - $y1,
        style  &#8658; "fill:" ~ random-color(),
        title  &#8658; [$tree.name],
];
return if $tree ~~ File;
if $x2 - $x1 &gt; $y2 - $y1 {
# split along the x-axis
my $base = ($x2 - $x1) / $tree.total-size; my $new-x = $x1;
for $tree.children &#8594; $child {
my $increment = $base * $child.total-size; tree-map(
                $child,
                x1 &#8658; $new-x,
                x2 &#8658; $new-x + $increment,
                :$y1,
                :$y2,
);
            $new-x += $increment;
        }
}
else {
         # split along the y-axis
my $base = ($y2 - $y1) / $tree.total-size; my $new-y = $y1;
for $tree.children &#8594; $child {
my $increment = $base * $child.total-size; tree-map(
                 $child,
                 :$x1,
                 :$x2,
                 y1 &#8658; $new-y,
                 y2 &#8658; $new-y + $increment,
);
             $new-y += $increment;
         }
} }</p>
</div>
<div class="paragraph">
<p>sub random-color {
return 'rgb(' ~ (1..3).map({ (^256).pick }).join(',') ~ ')';
}
sub MAIN($dir = '.') {
my $tree = tree($dir.IO); use SVG;
my $width = 1024;
my $height = 768;
say SVG.serialize(
        :svg[
            :$width,
:$height,
| gather tree-map $tree, x1 &#8658; 0, x2 &#8658; $width, y1 &#8658; 0, y2 &#8658; $height
] );
}</p>
</div>
<div class="paragraph">
<p>The generated file is not pretty, due to the random colors and due to some files being identified as very narrow rectangles. But it does make it obvious that there are a few big files and many mostly small files in a directory (which happens to be the .git directory of a repository). Viewing a file in a browser shows the name of the file on mouse-over.
How did we generate this file?
Sub tree-map calls take to add elements to a result list, so it must be called in the context of a gather statement. gather { take 1; take 2 } returns a lazy list of two elements, 1, 2. But the take calls don’t have to occur in the lexical scope of the gather; they can be in any code that’s directly or indirectly called from the gather. We call that the dynamic scope.
The rest of sub tree-map is mostly straightforward. For each direction in which the remaining rectangle can be split, we calculate a base unit that signifies how many pixels a byte should occupy. This is used to split up the current canvas into smaller ones and use those to recurse into tree-map.
The random color generation uses ˆ256 to create a range from 0 to 256 (exclusive) and .pick returns a random element from this range. The result is a random CSS color string like rgb(120,240,5).
In sub MAIN, the gather returns a list, which would normally be nested inside the outer array. The pipe symbol | in :svg[ &#8230;&#8203;, | gather &#8230;&#8203; ] before the gather prevents the normal nesting and flattens the list into the outer array.
10.3 Flame Graphs
The disadvantage of tree maps as generated in the preceding is that the human brain isn’t very good at comparing the sizes of rectangles with different aspect ratios, especially if their widths are very different from their heights (i.e., very tall or very flat rectangles). Flame graphs prevent this perception error by showing file sizes as horizontal bars. The vertical arrangement indicates the nesting of directories and files inside other directories. The disadvantage is that less of the available space is used for visualizing the file sizes.
It is easier to generate flame graphs than tree maps, because you only need to subdivide in one direction, whereas the height of each bar is fixed. Here it is set to 15 pixels:
sub flame-graph($tree, :$x1!, :$x2!, :$y!, :$height!) { return if $y &gt;= $height;
take 'rect' &#8658; [
x &#8658; $x1,
y &#8658; $y,
width &#8658; $x2 - $x1,
height &#8658; 15,
style &#8658; "fill:" ~ random-color(),
title &#8658; [$tree.name ~ ', ' ~ format-size($tree.total-size)],
];</p>
</div>
<div class="paragraph">
<p>return if $tree ~~ File;
my $base = ($x2 - $x1) / $tree.total-size; my $new-x = $x1;
for $tree.children &#8594; $child {
my $increment = $base * $child.total-size; flame-graph(
            $child,
            x1 &#8658; $new-x,
            x2 &#8658; $new-x + $increment,
            y &#8658; $y + 15,
            :$height,
);
        $new-x += $increment;
    }
}
We can add a switch to sub MAIN to call either tree-map or flame-graph,
depending on a command-line option:
sub MAIN($dir = '.', :$type="flame") { my $tree = tree($dir.IO);
use SVG;
my $width = 1024;
my $height = 768;
my &amp;grapher = $type eq 'flame'
?? { flame-graph $tree, x1 &#8658; 0, x2 &#8658; $width, y &#8658; 0, :$height }
            !! { tree-map    $tree, x1 &#8658; 0, x2 &#8658; $width, y1 &#8658; 0,
                 y2 &#8658; $height }
    say SVG.serialize(
        :svg[
:$width,
:$height,
| gather grapher()
] );
}</p>
</div>
<div class="paragraph">
<p>Since SVG’s coordinate system places the zero of the vertical axis at the top, this actually produces an inverted flame graph, sometimes called an icicle graph (Figure 10-2):</p>
</div>
<div class="paragraph">
<p>Figure 10-2. Inverted flame graph, where the width of each bar represents a file/ directory size and the vertical position the nesting inside a directory
This graph was generated by calling dirstat --type=flame src/ rakubook/.
10.4 Functional Refactorings
There’s a pattern that occurs three times in the code for generating tree maps and flame graphs: dividing an area based on the size of the files and directories in the tree associated with the area.
Extracting such common code into a function is a good idea, but it’s slightly hindered by the fact that there is custom code inside the loop that’s part of the common code. Functional programming offers a solution: put the custom code inside a separate function and have the common code call it.
Applying this technique to the tree graph flame graph looks like this:
sub subdivide($tree, $lower, $upper, &amp;todo) {
my $base = ($upper - $lower ) / $tree.total-size; my $var = $lower;
for $tree.children &#8594; $child {
my $incremented = $var + $base * $child.total-size; todo($child, $var, $incremented);
$var = $incremented,
} }
sub flame-graph($tree, :$x1!, :$x2!, :$y!, :$height!) { return if $y &gt;= $height;
take 'rect' &#8658; [
x &#8658; $x1,
y &#8658; $y,
        width  &#8658; $x2 - $x1,
Chapter 10 ■ a File and direCtory Usage graph
 103
Chapter 10 ■ a File and direCtory Usage graph
height &#8658; 15,
style &#8658; "fill:" ~ random-color(),
title &#8658; [$tree.name ~ ', ' ~ format-size($tree.total-size)],
];
return if $tree ~~ File;
subdivide( $tree, $x1, $x2, &#8594; $child, $x1, $x2 {
    flame-graph( $child, :$x1, :$x2, :y($y + 15), :$height );
});
}
sub tree-map($tree, :$x1!, :$x2!, :$y1!, :$y2) { return if ($x2 - $x1) * ($y2 - $y1) &lt; 20; take 'rect' &#8658; [
x &#8658; $x1,
y &#8658; $y1,
        width  &#8658; $x2 - $x1,
        height &#8658; $y2 - $y1,
        style  &#8658; "fill:" ~ random-color(),
        title  &#8658; [$tree.name],
];
return if $tree ~~ File;
if $x2 - $x1 &gt; $y2 - $y1 {
# split along the x-axis
subdivide $tree, $x1, $x2, &#8594; $child, $x1, $x2 {
            tree-map $child, :$x1, :$x2, :$y1, :$y2;
        }
}
else {
        # split along the y-axis
        subdivide $tree, $y1, $y2, &#8594; $child, $y1, $y2 {
            tree-map $child, :$x1, :$x2, :$y1, :$y2;
} }
}
The newly introduced subroutine subdivide takes a directory tree, a start and end point, and finally a code object &amp;todo. For each child of the directory tree it calculates the new coordinates and then calls the &amp;todo function.
The usage in subroutine flame-graph looks like this:
subdivide( $tree, $x1, $x2, &#8594; $child, $x1, $x2 {
    flame-graph( $child, :$x1, :$x2, :y($y + 15), :$height );
});
104</p>
</div>
<div class="paragraph">
<p>The code object being passed to subdivide starts with &#8594;, which introduces the signature of a block. The code block recurses into flame-graph, adding some extra arguments and turning two positional arguments into named arguments along the way.
This refactoring shortened the code and made it overall more pleasant
to work with. But there’s still quite a bit of duplication between tree-map
and flame-graph: both have an initial termination condition, a take of a rectangle, and then a call or two to subdivide. If we’re willing to put all the small differences into small, separate functions, we can unify it further.
If we were to pass all those new functions as arguments to each call, we would create an unpleasantly long argument list. Instead, we can use those functions to generate the previous functions flame-graph and tree-map:
sub svg-tree-gen(:&amp;terminate!, :&amp;base-height!, :&amp;subdivide-x!, :&amp;other!) {
sub inner($tree, :$x1!, :$x2!, :$y1!, :$y2!) { return if terminate(:$x1, :$x2, :$y1, :$y2); take 'rect' &#8658; [
x &#8658; $x1,
y &#8658; $y1,
            width  &#8658; $x2 - $x1,
            height &#8658; base-height(:$y1, :$y2),
            style  &#8658; "fill:" ~ random-color(),
            title  &#8658; [$tree.name ~ ', ' ~ format-size($tree.total-
            size)],
];
return if $tree ~~ File;
if subdivide-x(:$x1, :$y1, :$x2, :$y2) {
            # split along the x-axis
            subdivide $tree, $x1, $x2, &#8594; $child, $x1, $x2 {
                inner($child, :$x1, :$x2, :y1(other($y1)), :$y2);
} }
else {
# split along the y-axis
subdivide $tree, $y1, $y2, &#8594; $child, $y1, $y2 {
                inner($child, :x1(other($x1)), :$x2, :$y1, :$y2);
            }
} }
}
Chapter 10 ■ a File and direCtory Usage graph
105</p>
</div>
<div class="paragraph">
<p>Chapter 10 ■ a File and direCtory Usage graph
my &amp;flame-graph = svg-tree-gen
terminate &#8658; &#8594; :$y1, :$y2, | { $y1 &gt; $y2 }, base-height &#8658; &#8594; | { 15 },
subdivide-x &#8658; &#8594; | { True },
other &#8658; &#8594; $y1 { $y1 + 15 },
;
my &amp;tree-map = svg-tree-gen
terminate &#8658; &#8594; :$x1, :$y1, :$x2, :$y2 { ($x2 - $x1) * ($y2 - $y1) &lt; 20 },
base-height &#8658; &#8594; :$y1, :$y2 { $y2 - $y1 },
subdivide-x &#8658; &#8594; :$x1, :$x2, :$y1, :$y2 { $x2 - $x1 &gt; $y2 - $y1 }, other &#8658; &#8594; $a { $a },
;
Now we have a new function svg-tree-gen, which returns a function. The behavior of the returned function depends on the four small functions that svg-tree-gen receives as arguments.
The first argument, terminate, determines under what condition the inner function should terminate early. For tree-map, that’s when the area is below
20 pixels; for flame-graph, that&#8217;s when the current y-coordinate $y1 exceeds the height of the whole image (stored in $y2). svg-tree-gen always calls this function with the four named arguments x1, x2, y1, and y2, so the terminate function must ignore the x1 and x2 values. It does this by adding | as a parameter, which is an anonymous capture. Such a parameter can bind arbitrary positional and named arguments, and since it’s an anonymous parameter, it discards all the values.
The second configuration function, base-height, determines the
height of the rectangle in the base case. For flame-graph it’s a constant, so the configuration function must discard all arguments, again with a |. For tree-graph, it must return the difference between $y2 and $y1, as before the refactoring.
The third function determines when to subdivide along the x axis. Flame graphs always divide along the x axis, so &#8594; | { True } accomplishes that. Our simplistic approach to tree graphs divides along the longer axis, so only along the x axis if $x2 – $x1 &gt; $y2 – $y1.
The fourth and final function we pass to svg-tree-gen calculates the coordinate of the axis that isn’t being subdivided. In the case of flame-graph that’s increasing over the previous value by the height of the bars, and for tree-map it’s theunchangedcoordinate,sowepasstheidentityfunction&#8594; $a { $a }.
The inner function only needs a name because we need to call it from itself recursively; otherwise an anonymous function sub ($tree, :$x1!, :$x2!, :$y1!, :$y2!) { &#8230;&#8203; } would have worked fine.
106</p>
</div>
<div class="paragraph">
<p>This refactoring also unifies the names of the arguments to flame-graph and tree-map (previously, tree-map had :$y2 and flame-graph had :$height), so the call can now be simplified to
my &amp;grapher = $type eq 'flame' ?? &amp;flame-graph !! &amp;tree-map; say SVG.serialize(
    :svg[
        :$width,
:$height,
| do gather grapher $tree, x1 &#8658; 0, x2 &#8658; $width, y1 &#8658; 0, y2 &#8658; $height
] );
Now that we have very compact definitions of flame-graph and tree-map, it’s a good time to play with some of the parameters. Let’s introduce a bit of margin in the flame graph by having the increment in other greater than the bar height in base-height:
my &amp;flame-graph = svg-tree-gen base-height &#8658; &#8594; | { 15 },
other &#8658; &#8594; $y1 { $y1 + 16 }, # rest as before
Another knob to turn is to change the color generation to something more deterministic and make it configurable from the outside:
sub svg-tree-gen(:&amp;color=&amp;random-color, :&amp;terminate!, :&amp;base- height!,
:&amp;subdivide-x!, :&amp;other!) {
sub inner($tree, :$x1!, :$x2!, :$y1!, :$y2!) {
return if terminate(:$x1, :$x2, :$y1, :$y2); take 'rect' &#8658; [
x &#8658; $x1,
y &#8658; $y1,
            width  &#8658; $x2 - $x1,
            height &#8658; base-height(:$y1, :$y2),
            style  &#8658; "fill:" ~ color(),
            title  &#8658; [$tree.name ~ ', ' ~ format-size($tree.total-
}
];
# rest as before
size)],
Chapter 10 ■ a File and direCtory Usage graph
107</p>
</div>
<div class="paragraph">
<p>Chapter 10 ■ a File and direCtory Usage graph
We can, for instance, keep state within the color generator and return a
slightly different color during each iteration:
sub color-range(|) {
state ($r, $g, $b) = (0, 240, 120); $r = ($r + 5) % 256;
$g = ($g + 10) % 256;
$b = ($b + 15) % 256;
return "rgb($r,$g,$b)";
}
State variables keep their values between calls to the same subroutine
and their initialization runs only on the first call. Hence this function slightly increases the lightness in each color channel for each invocation, except when it reaches 256, where the modulo operator % resets it back to a small value.
If we plug this into our functions by passing color &#8658; &amp;color-range to the calls to svg-tree-gen, we get much less chaotic-looking output (Figures 10-3 and 10-4):
 Figure 10-3. Tree map with deterministic color generation
108</p>
</div>
<div class="paragraph">
<p>Figure 10-4. Flame graph with deterministic color generation and one pixel margin between bars
We could also pass in the coordinates to the &amp;color routine, which would make it possible to write a color generator that produces a nice gradient.
10.5 More Language Support for Functional Programming
As you’ve seen in the preceding examples, functional programming typically involves writing lots of small functions. Raku has some language features that make it very easy to write such small functions.
A common task is to write a function that calls a particular method on its argument, as we’ve seen here:
method total-size() {
$!total-size //= $.size + @.children.map({.total-size}).sum; # <sup>^</sup><sup>^</sup><sup>^</sup><sup>^</sup>^
}
This can be abbreviated to <strong>.total-size:
method total-size() {
$!total-size //= $.size + @.children.map(</strong>.total-size).sum;
}
This works for chains of method calls too, so you could write @.children. map(<strong>.total-size.round) if total-size returned a fractional number and you wanted to call the .round method on the result.
There are more cases where you can replace an expression with the “Whatever” star (</strong>) to create a small function. To create a function that adds 15 to its argument, you can write * + 15 instead of &#8594; $a { $a + 15 }.
If you need to write a function to just call another function, but pass more arguments to the second function, you can use the method assuming.4
4https://docs.raku.org/routine/assuming
Chapter 10 ■ a File and direCtory Usage graph
  109</p>
</div>
<div class="paragraph">
<p>Chapter 10 ■ a File and direCtory Usage graph
Forexample&#8594; $x { f(42, $x }canbereplacedwith&amp;f.assuming(42).This worksalsofornamedarguments,so&#8594; $x { f($x, height &#8658; 42 ) }canbe replacedwith&amp;f.assuming(height &#8658; 42).
10.6 More Improvements
The classes File and Directory have some common functionality, like the size and the name attributes, and the fact that they both have a method called total-size. A good way to factor out common behavior of classes is to put the common behavior into a role:
role Path {
has $.name;
has $.size;
method total-size() { &#8230;&#8203; } }
class File does Path {
method total-size() { $.size }
}
class Directory does Path { has @.children;
has $!total-size; method total-size() {
        $!total-size //= $.size + @.children.map(*.total-size).sum;
    }
}
A role looks structurally similar to a class, and using the does keyword in
the class declaration applies the role to the class. This role application copies attributes and methods into the target class, but with some additional compile- time checks. One such check is that a class must implement stubbed-out methods like method total-size, where the &#8230;&#8203; as the method body marked it as a stub. In addition, when you apply multiple roles to the same class, name clashes are detected and throw an error unless you implement the method in the class for disambiguation.
Roles are the preferred method of code reuse (apart from delegation) in Raku, because of the safety features mentioned previously.
Now that File and Directory have a common role, you can use that role as a type constraint for subroutines that expect one of these types, such as sub subdivide(Path $tree, $lower, $upper, &amp;todo).
110</p>
</div>
<div class="paragraph">
<p>Finally, the type argument to sub MAIN can have two possible values: flame for flame graphs or tree for tree maps. A data structure that models this behavior is an enum or enumeration:
enum GraphType &lt;flame tree&gt;;
sub MAIN($dir = '.', GraphType :$type=flame) {
my $tree = tree($dir.IO);
use SVG;
my $width = 1024;
my $height = 768;
my &amp;grapher = $type == flame ?? &amp;flame-graph !! &amp;tree-map; say SVG.serialize(
        :svg[
            :$width,
:$height,
| do gather grapher $tree, x1 &#8658; 0, x2 &#8658; $width, y1 &#8658; 0, y2 &#8658; $height
] );
}
The values of an enum are integers starting from zero, hence the comparison with == instead of eq. You can access the possible values of an enum either as short identifiers (flame) or through the namespace of the enum type, GraphType::flame.
Now if you obtain a help message from the script (by running it with the --help option), the type argument is automatically documented: --type=&lt;GraphType&gt; (flame tree).
10.7 Explore!
To get familiar with the functional programming concept, I encourage you to look through the code you’ve written so far and refactor near-duplicate code blocks into a common base and to swap out the code that differs into callbacks.
More importantly, try to find abstractions that make sense. In the visualization examples, the underlying principle is divide and conquer.5 Can you come up with a general divide and conquer implementation that is still useful?
5https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm
Chapter 10 ■ a File and direCtory Usage graph
 111</p>
</div>
<div class="paragraph">
<p>Chapter 10 ■ a File and direCtory Usage graph
Thinking back to the tree map and flame graphs, maybe you can separate
the logic for sizing rectangles from the logic for placing the rectangles?
10.8 Summary
Functional programming offers techniques for extracting common logic into separate functions. The desired differences in behavior can be encoded in more functions that you pass in as arguments to other functions.
Raku supports functional programming by making functions first class, so you can pass them around as ordinary objects. It also offers closures (access to outer lexical variables from functions) and various shortcuts that make it more pleasant to write short functions.</p>
</div>
<div class="paragraph">
<p>Every so often, I have to identify or research some Unicode characters. There’s a tool called uni1 in the Perl 5 distribution App::Uni,2 developed by Audrey Tang and Ricardo Signes.
Let’s reimplement its basic functionality in a few lines of Raku code and use that as an occasion to talk about Unicode support in Raku.
If you give it one character on the command line, it prints out a description of the following character:
$ uni њ
њ - U+0045a - CYRILLIC SMALL LETTER NJE
If you give it a longer string instead, it searches in the list of Unicode character names and prints out the same information for each character whose description matches the search string:
$ uni third|head -n3
1⁄3 - U+02153 - VULGAR FRACTION ONE THIRD 2⁄3 - U+02154 - VULGAR FRACTION TWO THIRDS ↉ - U+02189 - VULGAR FRACTION ZERO THIRDS
Each line corresponds to what Unicode calls a “code point,” which is usually a character on its own, but occasionally also something like U+00300-COMBINING GRAVE ACCENT, which, combined with a-U+00061-LATIN SMALL LETTER A makes the character à.
Raku offers a method uniname in both the classes Str and Int that produces the Unicode code point name for a given character, either in its direct character</p>
</div>
<div class="paragraph">
<p>form, or in the form of its code point number. With that, the first part of uni’s
desired functionality looks like this:
#!/usr/bin/env raku
use v6;
sub format-codepoint(Int $codepoint) { sprintf "%s - U+%05x - %s\n",
        $codepoint.chr,
        $codepoint,
        $codepoint.uniname;
}
multi sub MAIN(Str $x where .chars == 1) { print format-codepoint($x.ord);
}</p>
</div>
<div class="paragraph">
<p>Let’s look at it in action:</p>
</div>
<div class="paragraph">
<p>$ uni ø
ø - U+000f8 - LATIN SMALL LETTER O WITH STROKE
The chr method turns a code point number into the character and ord is the reverse: in other words, from character to code point number.
The second part, searching in all Unicode character names, works by brute- force enumerating all possible characters and searching through their uniname:
multi sub MAIN($search is copy) { $search.=uc;
for 1..0x10FFFF &#8594; $codepoint {
if $codepoint.uniname.contains($search) {
            print format-codepoint($codepoint);
        }
} }
Since all character names are in uppercase, the search term is first converted to uppercase with $search.=uc, which is short for $search = $search.uc. By default, parameters are read-only, which is why its declaration here uses is
copy to prevent that.
Instead of this rather imperative style, we can also formulate it in a more functional style. We could think of it as a list of all characters, which we whittle</p>
</div>
<div class="paragraph">
<p>down to those characters that interest us, to finally format them the way we
want :
multi sub MAIN($search is copy) { $search.=uc;
    print (1..0x10FFFF).grep(*.uniname.contains($search))
                       .map(&amp;format-codepoint)
.join;
}
To make it easier to identify (rather than search for) a string of more than one character, an explicit option can help disambiguate:
multi sub MAIN($x, Bool :$identify!) {
print $x.ords.map(&amp;format-codepoint).join;
}
Str.ords returns the list of code points that make up the string. With this
multi candidate of sub MAIN in place, we can do something like
$ uni --identify øre
ø - U+000f8 - LATIN SMALL LETTER O WITH STROKE
r - U+00072 - LATIN SMALL LETTER R
e - U+00065 - LATIN SMALL LETTER E</p>
</div>
<div class="paragraph">
<p>11.1 Code Points, Grapheme Clusters, and Bytes
As alluded to in the preceding, not all code points are fully fledged characters
on their own. Or put another way, some things that we visually identify as a single character are actually made up of several code points. Unicode calls such sequences of one base character and potentially several combining characters as a grapheme cluster.
Strings in Raku are based on these grapheme clusters. If you get a list
of characters in a string with $str.comb, or extract a substring with $str. substr(0, 4), match a regex against a string, determine the length, or do any other operation on a string, the unit is always the grapheme cluster. This best fits our intuitive understanding of what a character is and avoids accidentally tearing apart a logical character through a substr, comb, or similar operation:
my $s = "ø\c[COMBINING TILDE]"; say $s; # Output: ø̃
say $s.chars; # Output: 1</p>
</div>
<div class="paragraph">
<p>The Uni3 type is akin to a string and represents a sequence of codepoints. It is useful in edge cases, but doesn’t support the same wealth of operations as Str.4 The typical way to go from Str to a Uni value is to use one of the NFC, NFD, NFKC, or NFKD methods, which yield a Uni value in the normalization form of the same name.
Below the Uni level, you can also represent strings as bytes by choosing an encoding. If you want to get from the string to the byte level, call the encode5 method:
my $bytes = 'Raku'.encode('UTF-8'); # utf8:0x&lt;50 65 72 6c 20 36&gt;
UTF-8 is the default encoding and also the one Raku assumes when reading source files. The result is something that does the Blob6 role: you can access individual bytes with positional indexing, such as $bytes[0]. The decode method7 helps you convert a Blob to a Str.
If you print out a Blob with say(), you get a string representation of the bytes in hexadecimal. Accessing individual bytes produces an integer, and thus will typically be printed in decimal.
If you want to print out the raw bytes of a blob, you can use the write method of an I/O handle:
$*OUT.write('Raku'.encode('UTF-8'));</p>
</div>
<div class="paragraph">
<p>11.2 Numbers
Number literals in Raku aren’t limited to the Arabic digits we are so used to in the English-speaking part of the world. All Unicode code points that have the Decimal_Number (short Nd) property are allowed, so you can for example use Eastern Arabic numerals,8 or from many other scripts:
say ٤٢; # 42
The same holds true for string-to-number conversions:
say "٤٢".Int; # 42</p>
</div>
<div class="paragraph">
<p>For other numeric code points, you can use the unival method to obtain its
numeric value:
say "\c[TIBETAN DIGIT HALF ZERO]".unival;
which produces the output –0.5 and also illustrates how to use a codepoint by
name inside a string literal.
11.3 Other Unicode Properties
The uniprop method9 in type Str returns the general category by default: say "ø".uniprop; # Ll
say "\c[TIBETAN DIGIT HALF ZERO]".uniprop; # No
The return value needs some Unicode knowledge in order to make sense of it, or one could read Unicode’s Technical Report 4410 for the gory details. Ll stands for Letter_Lowercase, No is Other_Number. This is what Unicode calls the General Category, but you can ask the uniprop (or uniprop-bool method if you’re only interested in a boolean result) for other properties as well:
say "a".uniprop-bool('ASCII_Hex_Digit');
say "ü".uniprop-bool('Numeric_Type');
say ".".uniprop("Word_Break");
11.4 Collation
# True
# False
# MidNumLet
Sorting strings starts to become complicated when you’re not limited to ASCII characters. Raku’s sort method uses the cmp infix operator, which does a pretty standard lexicographic comparison based on the codepoint number.
If you need to use a more sophisticated collation algorithm, Rakudo 2017.02 and newer offer the Unicode Collation Algorithm11 as an experimental feature:
my @list = &lt;a ö ä Ä o ø&gt;;
say @list.sort; # (a o Ä ä ö ø)
use experimental :collation;
say @list.collate; # (a ä Ä o ö ø)</p>
</div>
<div class="paragraph">
<p>$*COLLATION.set(:tertiary(False));
say @list.collate; # (a Ä ä o ö ø)
The default sort considers any character with diacritics to be larger than ASCII characters, because that’s how they appear in the code point list. On the other hand, collate knows that characters with diacritics belong directly after their base character, which is not perfect in every language, but internally a good compromise.
For Latin-based scripts, the primary sorting criterion is alphabetic, the secondary is diacritics, and the third is case. $*COLLATION.set(:tertiary(False)) thus makes .collate ignore case, so it doesn’t force lowercase characters to come before uppercase characters anymore.
At the time of writing, language-specific collation has not yet been implemented in Raku.</p>
</div>
<div class="paragraph">
<p>11.5 Summary</p>
</div>
<div class="paragraph">
<p>Raku takes languages other than English very seriously, and goes to great lengths to facilitate working with them and the characters they use.
This includes basing strings on grapheme clusters rather than code points, support for non-Arabic digits in numbers, and access to large parts of the Unicode database through built-in methods.
Occasionally I come across git repositories where I want to know how active they are and who the main developers are.
Let’s develop a script that plots the commit history, and explore how to use Python modules in Raku.
12.1 Extracting the Stats
We want to plot the number of commits by author and date. We can get this information easily by passing some options to git log:
my $proc = run :out, &lt;git log --date=short --pretty=format:%ad!%an&gt;; my (%total, %by-author, %dates);
for $proc.out.lines &#8594; $line {
my ( $date, $author ) = $line.split: '!', 2; %total{$author}; %by-author{$author}{$date}; %dates{$date}++;
}
run executes an external command and :out tells it to capture the command’s output, making it available as $proc.out. The command is a list, with the first element being the actual executable and the rest being command-line arguments to this executable.
Here git log gets the options --date short --pretty=format:%ad!%an, whichinstructsittoproducelineslike2017-03-01!John Doe.Thislinecanbe parsedwithasimplecallto$line.split: '!', 2,whichsplitsonthe!and limitstheresulttotwoelements.Assigningittoatwo-elementlist( $date, $author )unpacksit.Wethenusehashestocountcommitsbyauthor(in %total), by author and date (%by-author), and finally by date. In the second case,</p>
</div>
<div class="paragraph">
<p>%by-author{$author} isn’t even a hash yet and we can still hash-index it. This is due to a feature called autovivification, which automatically creates (“vivifies”) objects where we need them. The use of ++ creates integers, {&#8230;&#8203;} indexing creates hashes, [&#8230;&#8203;] indexing, .push creates arrays, and so on.
To get from these hashes to the top contributors by commit count, we can sort %total by value. Since this sorts in ascending order, sorting by the negative value returns the list in descending order. The list contains Pair1 objects, where we only want the first five, and only their keys:
my @top-authors = %total.sort(-<strong>.value).head(5).map(</strong>.key);
For each author, we can extract the dates of their activity and their commit
counts like this:
my @dates = %by-author{$author}.keys.sort; my @counts = %by-author{$author}{@dates};
The last line uses slicing, that is, indexing a hash with a list to return a list of elements.
12.2 Plotting with Python
Matplotlib is a very versatile library for all sorts of plotting and visualization tasks. It is based on NumPy,2 a Python library for scientific and numeric computing.
Matplotlib3 is written in Python and for Python programs, but that won’t stop us from using it in a Raku program.
But first, let’s take a look at a basic plotting example that uses dates on the x axis:
import datetime
import matplotlib.pyplot as plt
fig, subplots = plt.subplots()
subplots.plot(
    [datetime.date(2017, 1, 5), datetime.date(2017, 3, 5),
    datetime.date(2017, 5, 5)],
    [ 42, 23, 42 ],
    label='An example',
)</p>
</div>
<div class="paragraph">
<p>subplots.legend(loc='upper center', shadow=True)
fig.autofmt_xdate()
plt.show()
To make this run, you have to install Python 2.7 and matplotlib.4 You can do this onDebian-basedLinuxsystemswithapt-get install -y python-matplotlib. The package name is the same on RPM-based distributions such as CentOS or SUSE Linux. MacOS users are advised to install Python 2.7 through homebrew or macportsandthenusepip2 install matplotliborpip2.7 install matplotlib to get the library. Windows installation is probably easiest through the conda5 package manager, which offers prebuilt binaries of both Python and matplotlib.
When you run this script with python2.7 dates.py, it opens a GUI window, showing the plot and some controls, which allow you to zoom, scroll, and write the plot graphic to a file (Figure 12-1):</p>
</div>
<div class="paragraph">
<p>12.3 Bridging the Gap
The Rakudo Raku compiler comes with a handy library for calling foreign functions6—called ‘NativeCall’—which allows you to call functions written in C, or anything with a compatible binary interface.
The Inline::Python7 library uses the native call functionality to talk to Python’s C API and offers interoperability between Raku and Python code. At the time of writing, this interoperability is still fragile in places, but can be worth using for some of the great libraries that Python has to offer.
To install Inline::Python, you must have a C compiler available, and then run
$ zef install Inline::Python
Now you can start to run Python 2 code in your Raku programs:
use Inline::Python;
my $py = Inline::Python.new;
$py.run: 'print("Hello, Raku")';
Besides the run method, which takes a string of Python code and executes it, you can also use call to call Python routines by specifying the namespace, the routine to call, and a list of arguments:
use Inline::Python;
my $py = Inline::Python.new;
$py.run('import datetime');
my $date = $py.call('datetime', 'date', 2017, 1, 31); $py.call('<em>builtin</em>', 'print', $date); # 2017-01-31
The arguments that you pass to call are Raku objects, such as the three Int objects in this example. Inline::Python automatically translates them into the corresponding Python built-in data structure. It translates numbers, strings, arrays, and hashes. Return values are also translated in the opposite direction, though since Python 2 does not distinguish properly between byte and Unicode strings, Python strings end up as buffers in Raku.</p>
</div>
<div class="paragraph">
<p>Objects that Inline::Python cannot translate are handled as opaque objects on the Raku side. You can pass them back into Python routines
(as shown with the preceding print call) and you can call methods on them:
say $date.isoformat().decode; # 2017-01-31
Raku exposes attributes through methods, so Raku has no syntax for accessing attributes from foreign objects directly. For instance, if you try to access the year attribute of datetime.date through the normal method call syntax, you get an error:
say $date.year;
dies with
'int' object is not callable
Instead, you have to use the getattr builtin:
say $py.call('<em>builtin</em>', 'getattr', $date, 'year');
12.4 Using the Bridge to Plot
We need access to two namespaces in Python, datetime and matplotlib.pyplot, so let’s start by importing them and writing some short helpers:
my $py = Inline::Python.new; $py.run('import datetime'); $py.run('import matplotlib.pyplot'); sub plot(Str $name, |c) {
    $py.call('matplotlib.pyplot', $name, |c);
}
sub pydate(Str $d) {
$py.call('datetime', 'date', $d.split('-').map(*.Int));
}
We can now call pydate('2017-03-01') to create a Python datetime. date object from an ISO-formatted string and call the plot function to access functionality from matplotlib:
my ($figure, $subplots) = plot('subplots'); $figure.autofmt_xdate();
my @dates = %dates.keys.sort;</p>
</div>
<div class="paragraph">
<p>$subplots.plot:
    $[@dates.map(&amp;pydate)],
    $[ %dates{@dates} ],
    label     &#8658; 'Total',
    marker    &#8658; '.',
    linestyle &#8658; '';
The Raku call plot('subplots') corresponds to the Python code fig, subplots = plt.subplots(). Passing arrays to Python functions needs a bit of extra work, because Inline::Python flattens arrays. Using an extra $ sigil in front of an array puts it into an extra scalar and thus prevents the flattening.
Now we can actually plot the number of commits by author, add a legend, and plot the result:
for @top-authors &#8594; $author {
my @dates = %by-author{$author}.keys.sort; my @counts = %by-author{$author}{@dates}; $subplots.plot:
        $[ @dates.map(&amp;pydate) ],
        $@counts,
        label     &#8658; $author,
        marker    &#8658;'.',
        linestyle &#8658; '';
}
$subplots.legend(loc&#8658;'upper center', shadow&#8658;True);
plot('title', 'Contributions per day');
plot('show');
When run in the zef git repository,8 it produces the plot shown in Figure 12-2:</p>
</div>
<div class="paragraph">
<p>12.5 Stacked Plots
I am not yet happy with the plot, so I want to explore using stacked plots for presenting the same information. In a regular plot, the y coordinate of each plotted value is proportional to its value. In a stacked plot, it is the distance to the previous value that is proportional to its value. This is nice for values that add up to a total that is also interesting.
Matplotlib offers a method called stackplot9 for this task. Contrary to multiple plot calls on a subplot object, it requires a shared x axis for all data series. Hence we must construct one array for each author of git commits, where dates with no value are set to zero.
This time we have to construct an array of arrays where each inner array has the values for one author:
my @dates = %dates.keys.sort;
my @stack = $[] xx @top-authors;
for @dates &#8594; $d {
for @top-authors.kv &#8594; $idx, $author {
        @stack[$idx].push: %by-author{$author}{$d} // 0;
    }
}</p>
</div>
<div class="paragraph">
<p>Now plotting becomes a simple matter of a method call, followed by the
usual commands to add a title and show the plot:
$subplots.stackplot($[@dates.map(&amp;pydate)], @stack);
plot('title', 'Contributions per day');
plot('show');
The result (again run on the zef source repository) is shown in Figure 12-3:</p>
</div>
<div class="paragraph">
<p>Comparing this to the previous visualization reveals a discrepancy: there were no commits in 2014, and yet the stacked plot makes it appear this way. In fact, the previous plots would have shown the same “alternative facts” if we had chosen lines instead of points. It comes from matplotlib (like nearly all plotting libraries) interpolating linearly between data points. But in our case, a date with no data points means zero commits happened on that date.
To communicate this to matplotlib, we must explicitly insert zero values for missing dates. This can be achieved by replacing
my @dates = %dates.keys.sort;</p>
</div>
<div class="paragraph">
<p>with the line
my @dates = %dates.keys.minmax;
The minmax method10 finds the minimal and maximal values, and returns them in a Range.11 Assigning the range to an array turns it into an array of all values between the minimal and the maximal value. The logic for assembling the @stack variable already maps missing values to zero.
The result looks a bit better, but still far from perfect (Figure 12-4):</p>
</div>
<div class="paragraph">
<p>Thinking more about the problem, contributions from separate days should not be joined together, because it produces misleading results. Matplotlib doesn’t support adding a legend automatically to stacked plots, so this seems to be to be a dead end.</p>
</div>
<div class="paragraph">
<p>Since a dot plot didn’t work very well, let’s try a different kind of plot that represents each data point separately: a bar chart, or more specifically, a stacked bar chart. Matplotlib offers the bar plotting method where the named parameter bottom can be used to generate the stacking:
my @dates = %dates.keys.sort;
my @stack = $[] xx @top-authors; my @bottom = $[] xx @top-authors;
for @dates &#8594; $d { my $bottom = 0;
for @top-authors.kv &#8594; $idx, $author { @bottom[$idx].push: $bottom;
my $value = %by-author{$author}{$d} // 0; @stack[$idx].push: $value;
$bottom += $value;
} }
We need to supply color names ourselves and set the edge color of the bars to the same color, otherwise the black edge color dominates the result:
my $width = 1.0;
my @colors = &lt;red green blue yellow black&gt;; my @plots;
for @top-authors.kv &#8594; $idx, $author { @plots.push: plot(
        'bar',
        $[@dates.map(&amp;pydate)],
        @stack[$idx],
        $width,
        bottom &#8658; @bottom[$idx],
        color &#8658; @colors[$idx],
        edgecolor &#8658; @colors[$idx],
); }
plot('legend', $@plots, $@top-authors);
plot('title', 'Contributions per day');
plot('show');</p>
</div>
<div class="paragraph">
<p>If you want to improve the result further, you could experiment with limiting the number of bars by lumping together contributions by week or month (or maybe $n-day period).
12.6 Idiomatic Use of Inline::Python
Now that the plots look informative and correct, it’s time to explore how to better emulate the typical Python APIs through Inline::Python.
12.6.1 Types of Python APIs
Python is an object-oriented language, so many APIs involve method calls, which Inline::Python helpfully automatically translates for us.
But the objects must come from somewhere and typically this is by calling a function that returns an object, or by instantiating a class. In Python, those two are really the same under the hood, since instantiating a class is the same as calling the class as if it were a function.</p>
</div>
<div class="paragraph">
<p>If you want to improve the result further, you could experiment with limiting the number of bars by lumping together contributions by week or month (or maybe $n-day period).
12.6 Idiomatic Use of Inline::Python
Now that the plots look informative and correct, it’s time to explore how to better emulate the typical Python APIs through Inline::Python.
12.6.1 Types of Python APIs
Python is an object-oriented language, so many APIs involve method calls, which Inline::Python helpfully automatically translates for us.
But the objects must come from somewhere and typically this is by calling a function that returns an object, or by instantiating a class. In Python, those two are really the same under the hood, since instantiating a class is the same as calling the class as if it were a function.</p>
</div>
<div class="paragraph">
<p>my (&amp;subplots, &amp;bar, &amp;legend, &amp;title, &amp;show)
= gen('matplotlib.pyplot', &lt;subplots bar legend title show&gt;); my ($figure, $subplots) = subplots();
# more code here
legend($@plots, $@top-authors);
title('Contributions per day');
show();
This makes the functions’ usage quite nice, but comes at the cost of duplicating their names. One can view this as a feature, because it allows the creation of different aliases, or as a source for bugs when the order is messed up, or a name misspelled.
How could we avoid the duplication should we choose to create wrapper functions?
This is where Raku’s flexibility and introspection abilities pay off. There are two key components that allow a nicer solution: the fact that declarations are expressions, and that you can introspect variables for their names.
The first part means you can write mysub my ($a, $b), which declares
the variables $a and $b, and calls a function with those variables as arguments. The second part means that $a.VAR.name returns a string '$a', the name of the variable.
Let’s combine this to create a wrapper that initializes subroutines for us:
sub pysub(Str $namespace, |args) { $py.run("import $namespace");
for args[0] &lt;&#8594; $sub {
my $name = $sub.VAR.name.substr(1); $sub = sub (|args) {
            $py.call($namespace, $name, |args);
        }
} }
pysub 'matplotlib.pyplot',
my (&amp;subplots, &amp;bar, &amp;legend, &amp;title, &amp;show);
131
Chapter 12 ■ plotting Using inline::python and Matplotlib
This avoids duplicating the name, but forces us to use some lower-level
Raku features in sub pysub. Using ordinary variables means that accessing their .VAR.name results in the name of the variable, not the name of the variable that’s used on the caller side. So we can’t use slurpy arguments as in
sub pysub(Str $namespace, *@subs)
Instead we must use |args to obtain the rest of the arguments in a Capture.12 This doesn’t flatten the list of variables passed to the function, so when we iterate over them, we must do so by accessing args[0]. By default, loop variables are read-only, which we can avoid by using &lt;&#8594; instead of &#8594; to introduce the signature. Fortunately, that also preserves the name of the caller side variable.
12.6.3 An Object-Oriented Interface
Instead of exposing the functions, we can also create types that emulate the method calls on Python modules. For that, we can implement a class with a method FALLBACK, which Raku calls for us when calling a method that is not implemented in the class:
class PyPlot is Mu { has $.py;
submethod TWEAK {
$!py.run('import matplotlib.pyplot');
}
method FALLBACK($name, |args) {
        $!py.call('matplotlib.pyplot', $name, |args);
    }
}
my $pyplot = PyPlot.new(:$py);
my ($figure, $subplots) = $pyplot.subplots; # plotting code goes here $pyplot.legend($@plots, $@top-authors);
$pyplot.title('Contributions per day');
$pyplot.show;</p>
</div>
<div class="paragraph">
<p>Class PyPlot inherits directly from Mu, the root of the Raku type hierarchy, instead of Any, the default parent class (which in turn inherits from Mu). Any introduces a large number of methods that Raku objects get by default, and since FALLBACK is only invoked when a method is not present, this is something to avoid.
The method TWEAK is another method that Raku calls automatically for us, after the object has been fully instantiated. All-caps method names are reserved for such special purposes. It is marked as a submethod, which means it is not inherited into subclasses. Since TWEAK is called at the level of each class, if it were a regular method, a subclass would call it twice implicitly. Note that TWEAK is only supported in Rakudo version 2016.11 and later.
There’s nothing specific to the Python package matplotlib.pyplot in class PyPlot, except the namespace name. We could easily generalize it to any namespace:
class PythonModule is Mu { has $.py;
has $.namespace; submethod TWEAK {
        $!py.run("import $!namespace");
    }
method FALLBACK($name, |args) { $!py.call($!namespace, $name, |args);
} }
my $pyplot = PythonModule.new(:$py, :namespace&lt;matplotlib.pyplot&gt;);
This is one Raku type that can represent any Python module. If instead we want a separate Raku type for each Python module, we could use roles, which are optionally parameterized:
role PythonModule[Str $namespace] is Mu { has $.py;
submethod TWEAK {
$!py.run("import $namespace");
}
method FALLBACK($name, |args) {
        $!py.call($namespace, $name, |args);
    }
}
my $pyplot = PythonModule['matplotlib.pyplot'].new(:$py);</p>
</div>
<div class="paragraph">
<p>Chapter 12  plotting Using inline::python and Matplotlib
Using this approach, we can create type constraints for Python modules in
Raku space:
sub plot-histogram(PythonModule['matplotlib.pyplot'], @data) { # implementation here
}
Passing in any wrapped Python module other than matplotlib.pyplot
results in a type error.
12.7 Summary
We’ve explored several ways to represent commit occurrence in plots and utilized Inline::Python to interface with a Python-based plotting library.
A bit of Raku metaprogramming allowed us to emulate different kinds of Python APIs pretty directly in Raku code, allowing a fairly direct translation of the original library’s documentation into Raku code.
If you got this far reading this book, you likely have a solid grasp on the basics of Raku by now.
The examples and discussions have touched on a wide variety of topics. We started with what Raku is, and how you can run Raku programs. Next up were the basic lexical structure of Raku programs, variables, control flow, and I/O. The more advanced topics include object orientation, persistence, regexes and grammars, Unicode support, concurrency, and finally the use of foreign libraries through Inline::Python.
But there’s more to writing successful Raku code than learning about the language itself. In this final chapter, I want to hint at some topics that you might want to pursue to help you keep your code base maintainable, and to get it successfully in front of users.
13.1 Scaling Your Code Base
When your code base grows, it is often advisable to split it into separate files. You can create modules that contain your logic, organized by namespace and functionality. The scripts then tend to become shallow entry points that parse the command-line arguments, load the modules, and then call a function or method from a method to do the actual work.
In this scenario, tests are written as separate scripts, usually in a directory named t, that load and test the same modules.
The official documentation at <a href="https://docs.raku.org/language/modules" class="bare">https://docs.raku.org/language/modules</a> explains how you can write modules, as well as the standard directory layout and metadata that the module installer zef (and other tooling) relies on.
As your code base grows, type annotations can help you to keep track
of what arguments routines accept, and what they return. I tend to use type annotations mostly in signatures that are part of a public API. With “public” I mean routines that can be accessed from outside the module they are in. Inside the routines, I tend to omit them for brevity and flexibility.</p>
</div>
<div class="paragraph">
<p>To make type constraints more reusable, you can define create subset types.
For example we’ve seen an example with an ad hoc–type constraint:
multi sub MAIN(Str $date where /^ \d+ \- \d+ \- \d+ $ /) { &#8230;&#8203; } Instead you could create a subset type, and use it several times:
subset DateStr of Str where /^ \d+ \- \d+ \- \d+ $ /; multi sub MAIN(DateStr $date) { &#8230;&#8203; }
sub parse-date(DateStr) returns Date { &#8230;&#8203; }
You can collect several of these types in a module, and import them
wherever you need them.
13.2 Packaging Your Application
In order to deploy your application to users, you typically put it in some kind of self-contained archive or package.
Independent of the desired distribution format, the starting point is always the directory layout and metadata that the zef module installer uses, which is described at <a href="https://docs.raku.org/language/modules" class="bare">https://docs.raku.org/language/modules</a>.
Raku packaging is still in active development, so instead of giving recipes, I want to briefly mention some options that you might find worth exploring.
13.2.1 Packaging as a Traditional Raku Module
Traditionally, Raku modules and software are distributed as tar archives1 that contain the source code and some metadata, like a META6.json file.
Users need to have a Raku binary and zef installed. They can then unpack the archive, go into the newly created directory, and install the software with zef install.
If your software is open source, you can add it to the official Raku ecosystem by sending a pull request against the Raku ecosystem git repository on GitHub.2 In this pull request, you simply add a link to your META6.json file by editing
the file META.list in said repository. After the pull request is accepted (which typically only takes a few hours or minutes), users can install your software through zef without having to download any package themselves.</p>
</div>
<div class="paragraph">
<p>13.2.2 Deploying with Docker
Traditional Raku module distribution relies on a preinstalled Rakudo Raku compiler, which might not be available on all platforms.
If you choose to distribute your application in a Docker image, you can base your image on the rakudo-star image, and simply zef install your application into the Docker container.
This is the most basic Dockerfile that builds on a preexisting image and installs that Raku application from the current working directory:
FROM rakudo-star:2017.04
COPY myapp /tmp/install
RUN zef install /tmp/install
ENTRYPOINT ["/usr/share/raku/site/bin/myapp"]
Running docker build -t myapp . creates a Docker image myapp, which you can then distribute, with all dependencies included.
13.2.3 Windows Installers
The module App::InstallerMaker::WiX3 can help you create a Windows .msi installer that creates a build of Rakudo, zef, and your application. It requires the Microsoft Visual C++ build tools and WiX.4 You create a YAML file that describes your application, and then run the script make-raku-wix-installer to create a stand-alone .msi file.
13.3 Closing Thoughts
Raku is a big language, embedded in an even bigger community and ecosystem. A book such as this one cannot cover everything, but hopefully it helped
you learn enough to perform most programming tasks in Raku, and more importantly, got you excited and motivated to explore, and to learn more.</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. <a href="http://gcc.gnu.org/" class="bare">http://gcc.gnu.org/</a>
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. <a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. <a href="https://docs.raku.org/routine/say#(IO)_sub_say" class="bare">https://docs.raku.org/routine/say#(IO)_sub_say</a>
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. <a href="https://docs.raku.org/type/Str#routine_substr" class="bare">https://docs.raku.org/type/Str#routine_substr</a>
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. <a href="https://docs.raku.org/type/Str.html#method_trans" class="bare">https://docs.raku.org/type/Str.html#method_trans</a>
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. <a href="https://docs.raku.org/type/Pair" class="bare">https://docs.raku.org/type/Pair</a>
</div>
<div class="footnote" id="_footnotedef_7">
<a href="#_footnoteref_7">7</a>. 也可以使用返回表达式来返回一个值，并立即退出子程序。
</div>
<div class="footnote" id="_footnotedef_8">
<a href="#_footnoteref_8">8</a>. <a href="https://docs.raku.org/type/List#routine_join" class="bare">https://docs.raku.org/type/List#routine_join</a>
</div>
<div class="footnote" id="_footnotedef_9">
<a href="#_footnoteref_9">9</a>. <a href="https://docs.raku.org/type/Str#routine_comb" class="bare">https://docs.raku.org/type/Str#routine_comb</a>
</div>
<div class="footnote" id="_footnotedef_10">
<a href="#_footnoteref_10">10</a>. <a href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics" class="bare">https://en.wikipedia.org/wiki/Scalable_Vector_Graphics</a>
</div>
<div class="footnote" id="_footnotedef_11">
<a href="#_footnoteref_11">11</a>. <a href="https://inkscape.org/" class="bare">https://inkscape.org/</a>
</div>
<div class="footnote" id="_footnotedef_12">
<a href="#_footnoteref_12">12</a>. <a href="https://docs.raku.org/type/DateTime" class="bare">https://docs.raku.org/type/DateTime</a>
</div>
<div class="footnote" id="_footnotedef_13">
<a href="#_footnoteref_13">13</a>. <a href="https://docs.raku.org/type/Date" class="bare">https://docs.raku.org/type/Date</a>
</div>
<div class="footnote" id="_footnotedef_14">
<a href="#_footnoteref_14">14</a>. <a href="https://docs.raku.org/type/IntStr" class="bare">https://docs.raku.org/type/IntStr</a>
</div>
<div class="footnote" id="_footnotedef_15">
<a href="#_footnoteref_15">15</a>. <a href="https://www.iso.org/iso-8601-date-and-time-format.html" class="bare">https://www.iso.org/iso-8601-date-and-time-format.html</a>
</div>
<div class="footnote" id="_footnotedef_16">
<a href="#_footnoteref_16">16</a>. <a href="https://docs.raku.org/type/Junction" class="bare">https://docs.raku.org/type/Junction</a>
</div>
<div class="footnote" id="_footnotedef_17">
<a href="#_footnoteref_17">17</a>. <a href="https://testanything.org/" class="bare">https://testanything.org/</a>
</div>
<div class="footnote" id="_footnotedef_18">
<a href="#_footnoteref_18">18</a>. <a href="http://testanything.org/testing-with-tap/perl.html" class="bare">http://testanything.org/testing-with-tap/perl.html</a>
</div>
<div class="footnote" id="_footnotedef_19">
<a href="#_footnoteref_19">19</a>. <a href="https://docs.raku.org/language/testing" class="bare">https://docs.raku.org/language/testing</a>
</div>
<div class="footnote" id="_footnotedef_20">
<a href="#_footnoteref_20">20</a>. <a href="https://docs.perl6.org/routine/eqv" class="bare">https://docs.perl6.org/routine/eqv</a>
</div>
<div class="footnote" id="_footnotedef_21">
<a href="#_footnoteref_21">21</a>. <a href="https://docs.perl6.org/language/control#with,_orwith,_without" class="bare">https://docs.perl6.org/language/control#with,_orwith,_without</a>
</div>
<div class="footnote" id="_footnotedef_22">
<a href="#_footnoteref_22">22</a>. <a href="http://modules.raku.org/dist/IO::String" class="bare">http://modules.raku.org/dist/IO::String</a>
</div>
<div class="footnote" id="_footnotedef_23">
<a href="#_footnoteref_23">23</a>. <a href="https://docs.raku.org/type/IO::Handle" class="bare">https://docs.raku.org/type/IO::Handle</a>
</div>
<div class="footnote" id="_footnotedef_24">
<a href="#_footnoteref_24">24</a>. <a href="https://docs.raku.org/language/testing.html" class="bare">https://docs.raku.org/language/testing.html</a>
</div>
<div class="footnote" id="_footnotedef_25">
<a href="#_footnoteref_25">25</a>. <a href="https://docs.raku.org/type/Any" class="bare">https://docs.raku.org/type/Any</a>
</div>
<div class="footnote" id="_footnotedef_26">
<a href="#_footnoteref_26">26</a>. <a href="https://en.wikipedia.org/wiki/Cron" class="bare">https://en.wikipedia.org/wiki/Cron</a>
</div>
<div class="footnote" id="_footnotedef_27">
<a href="#_footnoteref_27">27</a>. <a href="https://docs.raku.org/routine/run" class="bare">https://docs.raku.org/routine/run</a>
</div>
<div class="footnote" id="_footnotedef_28">
<a href="#_footnoteref_28">28</a>. <a href="https://docs.raku.org/type/Proc::Async" class="bare">https://docs.raku.org/type/Proc::Async</a>
</div>
<div class="footnote" id="_footnotedef_29">
<a href="#_footnoteref_29">29</a>. <a href="https://docs.raku.org/type/Signature#Slurpy_(A.K.A._variadic)_parameters" class="bare">https://docs.raku.org/type/Signature#Slurpy_(A.K.A._variadic)_parameters</a>
</div>
<div class="footnote" id="_footnotedef_30">
<a href="#_footnoteref_30">30</a>. <a href="https://docs.raku.org/type/Signature#index-entry-parameter_|-Capture_parameters" class="bare">https://docs.raku.org/type/Signature#index-entry-parameter_|-Capture_parameters</a>
</div>
<div class="footnote" id="_footnotedef_31">
<a href="#_footnoteref_31">31</a>. <a href="https://docs.raku.org/type/Supply" class="bare">https://docs.raku.org/type/Supply</a>
</div>
<div class="footnote" id="_footnotedef_32">
<a href="#_footnoteref_32">32</a>. <a href="https://docs.raku.org/type/Promise" class="bare">https://docs.raku.org/type/Promise</a>
</div>
<div class="footnote" id="_footnotedef_33">
<a href="#_footnoteref_33">33</a>. <a href="https://docs.raku.org/type/Proc" class="bare">https://docs.raku.org/type/Proc</a>
</div>
<div class="footnote" id="_footnotedef_34">
<a href="#_footnoteref_34">34</a>. <a href="https://docs.raku.org/language/quoting#Interpolation:_qq" class="bare">https://docs.raku.org/language/quoting#Interpolation:_qq</a>
</div>
<div class="footnote" id="_footnotedef_35">
<a href="#_footnoteref_35">35</a>. <a href="https://docs.raku.org/language/operators#infix_~~" class="bare">https://docs.raku.org/language/operators#infix_~~</a>
</div>
<div class="footnote" id="_footnotedef_36">
<a href="#_footnoteref_36">36</a>. <a href="https://docs.raku.org/type/Proc::Async" class="bare">https://docs.raku.org/type/Proc::Async</a>
</div>
<div class="footnote" id="_footnotedef_37">
<a href="#_footnoteref_37">37</a>. <a href="https://docs.raku.org/type/Failure" class="bare">https://docs.raku.org/type/Failure</a>
</div>
<div class="footnote" id="_footnotedef_38">
<a href="#_footnoteref_38">38</a>. <a href="https://docs.raku.org/type/Supply" class="bare">https://docs.raku.org/type/Supply</a>
</div>
<div class="footnote" id="_footnotedef_39">
<a href="#_footnoteref_39">39</a>. <a href="https://docs.raku.org/type/Supply#method_from-list" class="bare">https://docs.raku.org/type/Supply#method_from-list</a>
</div>
<div class="footnote" id="_footnotedef_40">
<a href="#_footnoteref_40">40</a>. <a href="https://github.com/jnthn/p6-test-scheduler" class="bare">https://github.com/jnthn/p6-test-scheduler</a>
</div>
<div class="footnote" id="_footnotedef_41">
<a href="#_footnoteref_41">41</a>. <a href="https://github.com/jnthn/p6-test-scheduler/issues/1" class="bare">https://github.com/jnthn/p6-test-scheduler/issues/1</a>
</div>
<div class="footnote" id="_footnotedef_42">
<a href="#_footnoteref_42">42</a>. <a href="https://www.sqlite.org/" class="bare">https://www.sqlite.org/</a>
</div>
<div class="footnote" id="_footnotedef_43">
<a href="#_footnoteref_43">43</a>. <a href="http://www.sqlite.org/famous.html" class="bare">http://www.sqlite.org/famous.html</a>
</div>
<div class="footnote" id="_footnotedef_44">
<a href="#_footnoteref_44">44</a>. <a href="https://github.com/perl6/DBIish/" class="bare">https://github.com/perl6/DBIish/</a>
</div>
<div class="footnote" id="_footnotedef_45">
<a href="#_footnoteref_45">45</a>. <a href="https://docs.raku.org/language/quoting#Heredocs:_:to" class="bare">https://docs.raku.org/language/quoting#Heredocs:_:to</a>
</div>
<div class="footnote" id="_footnotedef_46">
<a href="#_footnoteref_46">46</a>. <a href="https://github.com/moritz/json" class="bare">https://github.com/moritz/json</a>
</div>
<div class="footnote" id="_footnotedef_47">
<a href="#_footnoteref_47">47</a>. <a href="https://github.com/timo/json_fast" class="bare">https://github.com/timo/json_fast</a>
</div>
</div>

</article>


    

  </main><section class="site__search">
    <label class="site__form">
        <p class="form__label">Search around the site</p> 
        <input class="site__search-bar form__input" type="text">
    </label>
    <div class="site__search-bar-results"></div>
</section>
  
  <footer class="site__footer">
    
    
    <p class="footer__sign">© 2020 ohmyraku</p></footer>
    

    
    <script>
        window.addEventListener("load", function () {
            const script = document.createElement("script");
            script.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
            script.async = true

            document.head.appendChild(script);
        })
    </script>





<script defer type="text/javascript" src="https://ohmyraku.github.io/js/script.14164ab553b19613ce98aadb54b1ed9a89ae5b056c72b99a4c672e37954f33d67bebe1452b0279025ba889964b51bdf8ec69683933cf427ae67c08ac2cdda7b1.js" integrity="sha512-FBZKtVOxlhPOmKrbVLHtmomuWwVscrmaTGcuN5VPM9Z76&#43;FFKwJ5AluoiZZLUb347GloOTPPQnrmfAisLN2nsQ=="></script>



</body>
</html>