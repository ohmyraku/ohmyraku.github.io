<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Raku 基础 :: 山川异域, 风月同天</title>

<meta name="author" content="ohmyraku">
<meta name="application-name" content="山川异域, 风月同天">
<meta name="description" content="1. 什么是 Raku Raku 是一种编程语言。它以自然语言为灵感，设计成易学、易读、易写的语言。它让初学者可以编写 &#34;婴儿Perl&#34;，同时也让有经验的程序员可以自由表达，从简练到诗意。
 Raku 是渐近类型的。它主要遵循了动态类型化语言的范式，即接受那些在编译过程中无法保证类型安全的程序。然而，与许多动态语言不同的是，它接受并执行类型约束。在可能的情况下，编译器使用类型注解来在编译时做出决定，否则只有在运行时才有可能。
 许多编程范式都影响了 Raku 。你可以在 Raku 中编写命令式、面向对象和函数式的程序。声明式编程的功能，如多重分派、子类型、regex 和 grammar 引擎等，都支持声明式编程。
 在 Raku 中，大部分的查询都是词法查询，而且语言避免了全局状态。这使得程序的并行和并发执行更加容易，Raku 对高级并发原语的关注也是如此。当你不希望被限制在一个 CPU 内核上时，你会考虑 Promise 和消息队列, 而不是考虑线程和锁。
 Raku 作为一门语言，对于 Raku 程序应该被编译还是被解释的问题，Raku 是没有主见的。Raku 作为一种主要的实现, 可以快速编译模块并解释脚本。
 1.1. Perl5, 老天鹅 在 2000 年左右，Perl 5 的发展面临着巨大的压力，面临着既要发展又要保持向后兼容的矛盾。
 Raku 是释放这种压力的阀门。所有需要打破向后兼容性的扩展建议都被引导到了 Raku 中，使其处于梦幻般的状态，一切皆有可能，没有任何东西是固定的。经过几年的努力，Raku 才进入了一个比较稳固的状态。
 在这段时间里，Perl 5 也在不断发展，这两种语言的差异性足够大，以至于大多数 Perl 5 的开发者不再认为 Raku 是一条自然的升级之路，以至于 Raku 并没有试图让 Perl 5 过时（至少不会比它试图让任何其他编程语言过时的程度更高：-），2015 年第一次稳定发布的 Raku 并没有表明对 Perl 5 的支持失效。">
<meta name="robots" content="noodp"/>
<meta name="generator" content="Hugo 0.79.0" />
<meta name="referrer" content="no-referrer" />
<meta name="format-detection" content="telephone=no">

<link rel="canonical" href="https://ohmyraku.github.io/raku-by-example/" />


<link rel="icon" href="https://ohmyraku.github.io/logo.png" />

<link rel="stylesheet" href="https://ohmyraku.github.io/scss/main.min.84f71d25d375c522a861bb4719728ce6839cf3635b15ca0c7a1b4d799c2dc3399a1d6cb46058a9d8fdbebe9156a8857279cfdeb70aa3862e629de234b5a41fa1.css" integrity="sha512-hPcdJdN1xSKoYbtHGXKM5oOc82NbFcoMehtNeZwtwzmaHWy0YFip2P2&#43;vpFWqIVyec/etwqjhi5ineI0taQfoQ==">
<script>

const theme = window.localStorage.getItem('theme'); 
if (theme && theme !== "1") {
    document.documentElement.classList.add('theme-' + theme);
}
</script>


</head>
<body>
  <main class="site__content">
    <div class="site__page">
  <nav class="site__breadcrumbs">
    <a class="site__breadcrumb" href="https://ohmyraku.github.io/">山川异域, 风月同天</a><a class="site__breadcrumb--active" href="https://ohmyraku.github.io/raku-by-example/">Raku 基础</a>
</nav>

<h1 class="page__title">Raku 基础</h1>
  <div class="page__meta">
    <p>
    
    <span class="page__date">
    on <time datetime="2020-02-05T15:26:52&#43;08:00">2020-02-05</time>
    
    </span>
    </p>

    

    
    </div>
</div>


<div class="page__toc">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#_什么是_raku">1. 什么是 Raku</a>
      <ul>
        <li><a href="#_perl5_老天鹅">1.1. Perl5, 老天鹅</a></li>
        <li><a href="#_库的可用性">1.2. 库的可用性</a></li>
        <li><a href="#_我为什么要使用_raku">1.3. 我为什么要使用 Raku?</a></li>
        <li><a href="#_总结">1.4. 总结</a></li>
      </ul>
    </li>
    <li><a href="#_运行_raku">2. 运行 Raku</a>
      <ul>
        <li><a href="#_安装器">2.1. 安装器</a></li>
        <li><a href="#_docker">2.2. Docker</a></li>
        <li><a href="#_从源代码创建">2.3. 从源代码创建</a></li>
        <li><a href="#_测试你的_rakudo_star_安装">2.4. 测试你的 Rakudo Star 安装</a></li>
        <li><a href="#_文档">2.5. 文档</a></li>
        <li><a href="#_总结_2">2.6. 总结</a></li>
      </ul>
    </li>
    <li><a href="#_格式化数独字谜">3. 格式化数独字谜</a>
      <ul>
        <li><a href="#_让数独变得可玩">3.1. 让数独变得可玩</a></li>
        <li><a href="#_捷径常量和更多的捷径">3.2. 捷径、常量和更多的捷径</a></li>
        <li><a href="#_io_和其它悲剧">3.3. IO 和其它悲剧</a></li>
        <li><a href="#_获得创造性">3.4. 获得创造性</a></li>
        <li><a href="#_总结_3">3.5. 总结</a></li>
      </ul>
    </li>
    <li><a href="#_日期时间转换命令行">4. 日期时间转换命令行</a>
      <ul>
        <li><a href="#_使用库">4.1. 使用库</a></li>
        <li><a href="#_datetime_格式化">4.2. DateTime 格式化</a></li>
        <li><a href="#_寻找其他途径">4.3. 寻找其他途径</a></li>
        <li><a href="#_处理时间">4.4. 处理时间</a></li>
        <li><a href="#_系好你的安全带">4.5. 系好你的安全带</a></li>
        <li><a href="#_main_魔法">4.6. MAIN 魔法</a></li>
        <li><a href="#_自动化测试">4.7. 自动化测试</a></li>
        <li><a href="#_总结_4">4.8. 总结</a></li>
      </ul>
    </li>
    <li><a href="#_测试_say">5. 测试 say</a>
      <ul>
        <li><a href="#_总结_5">5.1. 总结</a></li>
      </ul>
    </li>
    <li><a href="#_silent_cron_一个_cron_包裹器">6. Silent-Cron, 一个 Cron 包裹器</a>
      <ul>
        <li><a href="#_异步运行命令">6.1. 异步运行命令</a></li>
        <li><a href="#_实现超时">6.2. 实现超时</a></li>
        <li><a href="#_更多关于承诺的信息">6.3. 更多关于承诺的信息</a></li>
        <li><a href="#_可能的扩展">6.4. 可能的扩展</a></li>
        <li><a href="#_重构和自动化测试">6.5. 重构和自动化测试</a></li>
        <li><a href="#_总结_6">6.6. 总结</a></li>
      </ul>
    </li>
    <li><a href="#_有状态的_silent_cron">7. 有状态的 Silent Cron</a>
      <ul>
        <li><a href="#_持久化存储">7.1. 持久化存储</a></li>
        <li><a href="#_开发存储后端">7.2. 开发存储后端</a></li>
        <li><a href="#_使用存储后端">7.3. 使用存储后端</a></li>
        <li><a href="#_扩展空间">7.4. 扩展空间</a></li>
        <li><a href="#_总结_7">7.5. 总结</a></li>
      </ul>
    </li>
    <li><a href="#_回顾_raku_基础知识">8. 回顾 Raku 基础知识</a>
      <ul>
        <li><a href="#_变量和作用域">8.1. 变量和作用域</a></li>
        <li><a href="#_子例程">8.2. 子例程</a></li>
        <li><a href="#_类和对象">8.3. 类和对象</a></li>
        <li><a href="#_并发">8.4. 并发</a></li>
        <li><a href="#_展望">8.5. 展望</a></li>
      </ul>
    </li>
    <li><a href="#_使用正则表达式和_grammar_解析_ini_文件">9. 使用正则表达式和 Grammar 解析 INI 文件</a>
      <ul>
        <li><a href="#_正则表达式基础">9.1. 正则表达式基础</a></li>
        <li><a href="#_解析_ini_原语">9.2. 解析 INI 原语</a></li>
        <li><a href="#_把东西组装起来">9.3. 把东西组装起来</a></li>
        <li><a href="#_回溯">9.4. 回溯</a></li>
        <li><a href="#_grammar">9.5. Grammar</a></li>
        <li><a href="#_从匹配中提取数据">9.6. 从匹配中提取数据</a></li>
        <li><a href="#_生成好的错误信息">9.7. 生成好的错误信息</a></li>
        <li><a href="#_编写你自己的_grammar">9.8. 编写你自己的 Grammar</a></li>
        <li><a href="#_总结_8">9.9. 总结</a></li>
      </ul>
    </li>
    <li><a href="#_文件和目录使用状态图">10. 文件和目录使用状态图</a>
      <ul>
        <li><a href="#_reading_file_sizes">10.1. Reading File Sizes</a></li>
        <li><a href="#_generating_a_tree_map">10.2. Generating a Tree Map</a></li>
        <li><a href="#_火焰图">10.3. 火焰图</a></li>
        <li><a href="#_functional_refactorings">10.4. Functional Refactorings</a></li>
        <li><a href="#_more_language_support_for_functional_programming">10.5. More Language Support for Functional Programming</a></li>
        <li><a href="#_more_improvements">10.6. More Improvements</a></li>
        <li><a href="#_explore">10.7. Explore!</a></li>
        <li><a href="#_summary">10.8. Summary</a></li>
      </ul>
    </li>
    <li><a href="#_unicode_搜索工具">11. Unicode 搜索工具</a>
      <ul>
        <li><a href="#_代码点字符集和字节">11.1. 代码点、字符集和字节</a></li>
        <li><a href="#_数字">11.2. 数字</a></li>
        <li><a href="#_其它_unicode_属性">11.3. 其它 Unicode 属性</a></li>
        <li><a href="#_排序">11.4. 排序</a></li>
        <li><a href="#_总结_9">11.5. 总结</a></li>
      </ul>
    </li>
    <li><a href="#_使用_inine_python_和_matplotlib_画图">12. 使用 Inine-Python 和 Matplotlib 画图</a>
      <ul>
        <li><a href="#_提取状态">12.1. 提取状态</a></li>
        <li><a href="#_plotting_with_python">12.2. Plotting with Python</a></li>
        <li><a href="#_bridging_the_gap">12.3. Bridging the Gap</a></li>
        <li><a href="#_using_the_bridge_to_plot">12.4. Using the Bridge to Plot</a></li>
        <li><a href="#_stacked_plots">12.5. Stacked Plots</a></li>
        <li><a href="#_idiomatic_use_of_inlinepython">12.6. Idiomatic Use of Inline::Python</a></li>
        <li><a href="#_idiomatic_use_of_inlinepython_2">12.7. Idiomatic Use of Inline::Python</a></li>
        <li><a href="#_总结_10">12.8. 总结</a></li>
      </ul>
    </li>
    <li><a href="#_接下来是什么">13. 接下来是什么</a>
      <ul>
        <li><a href="#_扩展你的代码库">13.1. 扩展你的代码库</a></li>
        <li><a href="#_打包你的应用">13.2. 打包你的应用</a></li>
        <li><a href="#_结尾感想">13.3. 结尾感想</a></li>
      </ul>
    </li>
    <li><a href="#_创建一个_web_服务和声明式_api">14. 创建一个 Web 服务和声明式 API</a>
      <ul>
        <li><a href="#_12_1_开始使用_cro">14.1. 12.1 开始使用 Cro</a></li>
        <li><a href="#_12_2_扩大服务范围">14.2. 12.2 扩大服务范围</a></li>
        <li><a href="#_12_3_测试">14.3. 12.3 测试</a></li>
        <li><a href="#_12_4_添加一个网页">14.4. 12.4 添加一个网页</a></li>
        <li><a href="#_12_5_声明式_api">14.5. 12.5 声明式 API</a></li>
        <li><a href="#_12_6_总结">14.6. 12.6 总结</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div>

</div>

<article class="page__content" >
<div class="sect1">
<h2 id="_什么是_raku">1. 什么是 Raku</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 是一种编程语言。它以自然语言为灵感，设计成易学、易读、易写的语言。它让初学者可以编写 &#34;婴儿Perl&#34;，同时也让有经验的程序员可以自由表达，从简练到诗意。</p>
</div>
<div class="paragraph">
<p>Raku 是渐近类型的。它主要遵循了动态类型化语言的范式，即接受那些在编译过程中无法保证类型安全的程序。然而，与许多动态语言不同的是，它接受并执行类型约束。在可能的情况下，编译器使用类型注解来在编译时做出决定，否则只有在运行时才有可能。</p>
</div>
<div class="paragraph">
<p>许多编程范式都影响了 Raku 。你可以在 Raku 中编写命令式、面向对象和函数式的程序。声明式编程的功能，如多重分派、子类型、regex 和 grammar 引擎等，都支持声明式编程。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，大部分的查询都是词法查询，而且语言避免了全局状态。这使得程序的并行和并发执行更加容易，Raku 对高级并发原语的关注也是如此。当你不希望被限制在一个 CPU 内核上时，你会考虑 Promise 和消息队列, 而不是考虑线程和锁。</p>
</div>
<div class="paragraph">
<p>Raku 作为一门语言，对于 Raku 程序应该被编译还是被解释的问题，Raku 是没有主见的。Raku 作为一种主要的实现, 可以快速编译模块并解释脚本。</p>
</div>
<div class="sect2">
<h3 id="_perl5_老天鹅">1.1. Perl5, 老天鹅</h3>
<div class="paragraph">
<p>在 2000 年左右，Perl 5 的发展面临着巨大的压力，面临着既要发展又要保持向后兼容的矛盾。</p>
</div>
<div class="paragraph">
<p>Raku 是释放这种压力的阀门。所有需要打破向后兼容性的扩展建议都被引导到了 Raku 中，使其处于梦幻般的状态，一切皆有可能，没有任何东西是固定的。经过几年的努力，Raku 才进入了一个比较稳固的状态。</p>
</div>
<div class="paragraph">
<p>在这段时间里，Perl 5 也在不断发展，这两种语言的差异性足够大，以至于大多数 Perl 5 的开发者不再认为 Raku 是一条自然的升级之路，以至于 Raku 并没有试图让 Perl 5 过时（至少不会比它试图让任何其他编程语言过时的程度更高：-），2015 年第一次稳定发布的 Raku 并没有表明对 Perl 5 的支持失效。</p>
</div>
<div class="paragraph">
<p>Perl 5 是由一个独立的爱好者社区开发的，他们一直关注着 Raku，寻找值得采纳到 Perl 5 中的功能，所以虽然 Perl 5 和 Raku 社区有一定的重叠和交流，但两者都是独立发展的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_库的可用性">1.2. 库的可用性</h3>
<div class="paragraph">
<p>作为一种相对年轻的语言，Raku 缺乏像 Perl 5 和 Python 这样的语言所提供的成熟的模块生态系统。</p>
</div>
<div class="paragraph">
<p>为了弥补这个差距，就有了接口，你可以调用用 C、Python、Perl 5 和 Ruby 编写的库。Perl 5 和 Python 的接口足够复杂，你可以编写一个 Raku 的类，它可以子类化用这两种语言编写的类，反之亦然。</p>
</div>
<div class="paragraph">
<p>因此，如果你喜欢某个特定的 Python 库，你可以通过 <code>Inline::Python</code> 模块将其加载到你的 Raku 程序中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_我为什么要使用_raku">1.3. 我为什么要使用 Raku?</h3>
<div class="paragraph">
<p>如果你喜欢动态类型化的编程语言所带来的快速原型开发体验，同时又希望有足够的安全功能来构建大型的、可靠的应用程序，那么 Raku 是个不错的选择。它的渐进式类型让你可以在没有完全了解所涉及的类型的情况下编写代码，以后还可以引入类型约束，防止将来内部和外部 API 被滥用。</p>
</div>
<div class="paragraph">
<p>Perl 在通过正则表达式(regexes)来处理文本的历史悠久，但比较复杂的 regexes 却有一个很难读和维护的名声。Raku 解决了这一问题，它将 regex 与代码放在同一层次上，允许你把它们像子程序一样命名，甚至可以使用类继承和角色组成等面向对象的特性来管理代码和 regex 重用。由此产生的 grammar 非常强大，也很容易读懂。事实上，Raku 编译器就是用 Raku 的 grammar 来解析 Raku 的源码的!</p>
</div>
<div class="paragraph">
<p>说到文本，Raku 有惊人的 Unicode 支持。如果你要求用户输入一个数字，而他们输入的数字不是 ASCII 范围内的阿拉伯数字，那么 Raku 仍然可以满足你的要求。如果你处理的是不能用一个单一的 Unicode 代码点来表示的字素，Raku 仍然可以将其作为一个单一的字符来表示。</p>
</div>
<div class="paragraph">
<p>有更多的技术优势，我可以列举出来，但更重要的是，这套语言的设计是为了让用户使用起来更有趣。其中一个重要的方面就是良好的错误信息。你是否曾对 Python 感到恼火过，因为当出现错误时，通常只给出了 SyntaxError: invalid syntaxError: invalid syntax 语法。例如，这个错误可能来自于忘记了结尾的括号。在这种情况下，Raku 编译器会打印出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Unable to parse expression in argument list; couldn&#39;t find final &#39;)&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这实际上告诉你什么是错的。但这只是冰山一角。编译器可以捕捉到常见的错误，并指出可能的解决方案，甚至还建议对拼写错误进行修复。Raku 社区认为那些 <strong>less than awesome,</strong> 的错误信息，即 LTA，是值得报告的错误信息，并在提高错误信息的标准上花了很多精力。</p>
</div>
<div class="paragraph">
<p>最后，Raku 给了你自由，可以用不同的方式和不同的编程范式来表达你的问题域和解决方案。如果核心语言提供的选项还不够多，那么它在设计时就考虑到了可扩展性，让你既可以引入新的面向对象代码的语义，也可以引入新的语法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结">1.4. 总结</h3>
<div class="paragraph">
<p>Raku 是一种灵活的编程语言，它为初学者和专家提供了许多酷炫而方便的功能。它提供了灵活性，类型检查，以及强大的 Unicode 和文本处理支持。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_运行_raku">2. 运行 Raku</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在我们开始探索 Raku 之前，你应该先有一个环境，在这个环境中你可以运行 Raku 代码。所以你需要安装 Raku，这是目前唯一一个积极开发的 Raku 编译器。或者更好的方法是安装 Rakudo Star，这是一个包含 Rakudo 本身、一些有用的模块和一个可以帮助你安装更多模块的工具的发行版。</p>
</div>
<div class="paragraph">
<p>安装 Rakudo 本身只给你提供了编译器。它遵循每月发布周期，所以它可以让你跟上最新的发展。当你选择安装 Rakudo Star 时，通常每隔一段时间就会发布一次。三个月后，你会得到一个比较稳定的开发基础，还有一些工具，比如调试器和模块安装程序。你可以使用模块安装程序来利用预装的软件库，这些库既不包含在 Rakudo 本身，也不包含在 Rakudo Star 中。</p>
</div>
<div class="paragraph">
<p>下面的章节将讨论安装 Rakudo Star 的几个选项。选择任何适合你的方法。</p>
</div>
<div class="paragraph">
<p>本书中的示例使用 Rakudo 2017.04.03 或 Rakudo Star 2017.04（Rakudo Star 2017.04.03 是建立在 Rakudo 2017.04.03 的基础上），只要它支持 Raku 版本 6.c，就应该与此版本或任何更新的 Rakudo 版本一起工作。</p>
</div>
<div class="sect2">
<h3 id="_安装器">2.1. 安装器</h3>
<div class="paragraph">
<p>你可以从 <a href="https://rakudo.org/downloads" class="bare">https://rakudo.org/downloads</a> 下载安装程序，用于 Mac OS(.dmg) 和 Windows(.msi)。下载后，你可以启动它们，它们会引导你完成安装过程。</p>
</div>
<div class="paragraph">
<p>预建的 Linux 软件包可以从 <a href="https://github.com/nxadm/rakudo-pkg/releases/" class="bare">https://github.com/nxadm/rakudo-pkg/releases/</a> 中获得，用于 Debian、Ubuntu、CentOS 和 Fedora 等等。在这两种情况下，请使用 2017.04 版本，以获得与本书中使用的示例的最佳兼容性。</p>
</div>
<div class="paragraph">
<p>注意，Rakudo 是不可移动的，这意味着你必须安装到安装程序的创建者决定的固定位置。将安装程序移动到不同的目录是不可能的。</p>
</div>
<div class="paragraph">
<p>在 Windows 上，安装程序（图 2-1）提供了将 <code>C:\rakudo\share\bin</code> 和 <code>C:\rakudo\share</code> 添加到你的 PATH 环境中。你应该选择这个选项，因为它允许你执行 Rakudo raku (和模块安装程序代表你安装的程序)，而不需要指定完整的路径。</p>
</div>
</div>
<div class="sect2">
<h3 id="_docker">2.2. Docker</h3>
<div class="paragraph">
<p>在支持 Docker 的平台上，你可以从 docker hub 中拉取一个现有的 Docker 容器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

$ docker pull rakudo-star</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，你可以使用这个命令获取一个交互式的 Rakudo shell：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ docker run -it rakudo-star raku:2017.04</code></pre>
</div>
</div>
<div class="paragraph">
<p>但仅靠这个命令是无法执行脚本的，因为容器有自己独立的文件系统。要使容器内的脚本可用，你需要告诉 Docker 使当前的目录对容器可用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ docker run -v $PWD:/raku -w /raku -it rakudo-star raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>选项 <code>-v $PWD:/raku</code> 指示 Docker 将当前的工作目录(<code>$PWD</code>) 挂载到容器中，在那里它将作为 <code>/raku</code> 可用。为了使相对路径起作用，<code>-w /raku</code> 指示 Docker 将 Rakudo 进程的工作目录设置为 <code>/raku</code>。</p>
</div>
<div class="paragraph">
<p>由于这条命令行开始变得笨重，所以我创建了一个别名（这是 Bash 语法，其他的 shell 可能会有稍微不同的别名机制）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">alias p6d=&#39;docker run -v $PWD:/raku -w /raku -it rakudo-star raku&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我把这一行放到了我的 <code>~/.bashrc</code> 文件中，所以新的 shell 实例有一个 p6d 命令，简称 &#34;Raku docker&#34;。</p>
</div>
<div class="paragraph">
<p>作为一个简短的测试，看看它是否有效，你可以运行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ p6d -e &#39;say &#34;hi&#34;&#39;
hi</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你使用 Docker 路由，请使用 p6d 别名而不是 raku 来运行脚本。</p>
</div>
</div>
<div class="sect2">
<h3 id="_从源代码创建">2.3. 从源代码创建</h3>
<div class="paragraph">
<p>要从源码构建 Rakudo Star，你需要安装 make，GNU C 编译器<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup> (GCC)，或者 clang 和 Perl 5。这个例子安装到 <code>$HOME/opt/rakudo-star</code> 中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ wget https://rakudo.org/dl/star/rakudo-star-2017.04.tar.gz
tar.gz
$ tar xzf rakudo-star-2017.04.tar.gz
$ cd rakudo-star-2017.04/
$ perl Configure.pl --prefix=$HOME/opt/rakudo-star --gen-moar
$ make install</code></pre>
</div>
</div>
<div class="paragraph">
<p>你应该有大约 2GB 的内存来做最后一步；构建编译器是一项资源密集型的工作。</p>
</div>
<div class="paragraph">
<p>你需要在你的 PATH 环境变量中添加到两个目录的路径，一个是 Rakudo 本身，一个是模块安装程序安装的程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">PATH=$PATH:$HOME/opt/rakudo-star/bin/:$HOME/opt/rakudo-star/share/raku/site/bin</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你是 Bash 用户，你可以把这一行放到你的 <code>∼/.bashrc</code> 文件中，让它在新的 Bash 进程中可用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_测试你的_rakudo_star_安装">2.4. 测试你的 Rakudo Star 安装</h3>
<div class="paragraph">
<p>现在你应该可以在命令行中运行 Raku 程序，并询问 Rakudo 的版本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku --version
This is Rakudo version 2017.04.2 built on MoarVM version 2017.04
implementing Raku.c.

$ raku -e &#34;say &lt;hi&gt;&#34;
hi</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果所有这些方法都无法产生一个可用的 Rakudo 安装，你应该向友好的 Raku 社区描述你的问题，他们通常可以提供一些帮助。<a href="https://raku.org/community/" class="bare">https://raku.org/community/</a>  描述了与社区互动的方式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_文档">2.5. 文档</h3>
<div class="paragraph">
<p>Rakudo 本身没有什么文档，因为大部分有趣的资料都是关于 Raku 语言的。但 Rakudo 确实有一个命令行选项的摘要，你可以通过调用 raku --help 来访问。</p>
</div>
<div class="paragraph">
<p>Raku 语言文档的官方网址是 <a href="https://docs.raku.org/" class="bare">https://docs.raku.org/</a>，它的目的是提供参考和教程式的资料。其他的好资源可以在 <a href="https://raku.org/resources/" class="bare">https://raku.org/resources/</a> 中找到，其中很多是由 Raku 社区的成员创建和维护的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_2">2.6. 总结</h3>
<div class="paragraph">
<p>在大多数平台上，你可以从预建的二进制安装程序中安装 Rakudo Star。如果无法使用，可以使用 Docker 映像。最后，Rakudo Star 可以从它的源码中构建 Rakudo Star。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_格式化数独字谜">3. 格式化数独字谜</h2>
<div class="sectionbody">
<div class="paragraph">
<p>作为 Raku 的温柔介绍，让我们考虑一下我最近在追求自己的一个爱好时遇到的一个小任务。</p>
</div>
<div class="paragraph">
<p>数独是在一个 9×9 的网格上玩的一种数字放置谜题，它被细分为 3×3 的方块（图3-1）。有的单元格里填上1到9的数字，有的单元格是空的。游戏的目的是填空单元格，使每一行、每一列和每一个 3×3 的单元格中，从1到9的每一个数字都刚好出现一次。</p>
</div>
<div class="paragraph">
<div class="title">未解的数独字谜</div>
<p>一个有效的数独的存储格式简单来说就是一个81个字符的字符串，0代表空单元格，数字1到9代表预填充单元格。我想解决的任务是把它变成一种更友好的格式。</p>
</div>
<div class="paragraph">
<p>输入的格式可以是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">000000075000080094000500600010000200000900057006003040001000023080000006063240000</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来是我们的第一个 Raku 程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

# file sudoku.p6
use v6;
my $sudoku = &#39;000000075000080094000500600010000200000900057006003040001000023080000006063240000&#39;;
for 0..8 -&gt; $line-number {
    say substr $sudoku, $line-number * 9, 9;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以这样运行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku sudoku.p6
000000075
000080094
000500600
010000200
000900057
006003040
001000023
080000006
063240000</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里面没有什么神奇的地方，但让我们逐行看一下代码。第一行，以 <code>#</code> 开头，是一个注释，一直延伸到行尾。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use v6;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一行并不是严格意义上的必须，但也是很好的做法。它声明了你所使用的 Perl 版本，这里是 <code>v6</code>；换句话说，就是任何版本的  Raku  语言。我们可以说得更具体一些，使用 <code>v6.c</code> 来要求使用这里讨论的版本。如果你不小心用 Perl 5 运行了 Raku 程序，你会很高兴你包含了这一行，因为它会告诉你以下内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ perl sudoku.p6
Perl v6.0.0 required--this is only v5.22.1, stopped at sudoku.p6 line 1. BEGIN failed--compilation aborted at sudoku.p6 line 1.</code></pre>
</div>
</div>
<div class="paragraph">
<p>而不是更隐晦的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">syntax error at sudoku.p6 line 4, near &#34;for 0&#34;
Execution of sudoku.p6 aborted due to compilation errors.</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一行有趣的是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $sudoku = &#39;00000007500...&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>my</code> 声明了一个词法变量，它从声明点到当前作用域的末尾都是可见的。它从声明点开始到当前作用域的末尾都是可见的，也就是说，它可以是当前区块的末尾，如果它在任何区块之外，则是文件的末尾，就像本例中的情况一样。</p>
</div>
<div class="paragraph">
<p>变量的开头是一个 sigil，这里是 <code>$</code>，sigil 是 Perl 的名词，它让 Perl 有了行噪声的名声，但噪声中也有信号。这个 <code>$</code> 看起来像一个 S，代表标量。如果你懂得一些数学知识，你会知道标量只是一个单一的值，而不是向量甚至是矩阵。</p>
</div>
<div class="paragraph">
<p>这个变量开始时并不是空的，因为在它的旁边有一个初始化。它开始时的值是一个字符串的字段，如引号所示。</p>
</div>
<div class="paragraph">
<p>需要注意的是，除了&#34;它是一个标量&#34;这个非常模糊的符号所暗示的&#34;它是一个标量 &#34;之外，我们不需要声明变量的类型。如果我们愿意，我们可以添加一个类型约束。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my Str $sudoku = &#39;00000007500...&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>但在快速原型设计时，我往往会放弃类型约束，因为我往往还不知道代码到底会如何运行。</p>
</div>
<div class="paragraph">
<p>实际的逻辑发生在接下来的几行中，通过迭代0到8的行数来实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

for 0..8 -&gt; $line-number {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>for 循环具有 ITERABLE BLOCK 的一般结构。这里的 iterable 是一个范围<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>，块是一个尖号块。该块以 <code>→</code> 开头，引入了一个签名。这个签名告诉编译器这个块期望有哪些参数，这里是一个单一的标量，叫做 <code>$line-number</code>。</p>
</div>
<div class="paragraph">
<p>Raku 允许使用破折号 <code>-</code> 或单引号 <code>&#39;</code> 将多个简单的标识符连接成一个大的标识符。这意味着只要下面的字符是字母或下划线，就可以在标识符中使用。</p>
</div>
<div class="paragraph">
<p>同样，类型约束是可选的。如果你选择了包含它们，它会是 <code>for 0..8 → Int $line-number { …​ }</code>。</p>
</div>
<div class="paragraph">
<p><code>$line-number</code> 又是一个词法变量，在签名后的块中可见。块由大括号分隔。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

say substr $sudoku, $line-number * 9, 9;</code></pre>
</div>
</div>
<div class="paragraph">
<p>say<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup> 和 substr<sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup> 都是 Raku 标准库提供的函数。</p>
</div>
<div class="paragraph">
<p><code>substr($string, $from, $num-chars)</code> 从 <code>$string</code> 中提取一个子字符串。它从一个基于零的索引 <code>$from</code> 开始，取 <code>$num-chars</code> 指定的字符数。哦，在 Raku 中，一个字符是真正的一个字符，即使它是由多个代码点组成的，比如重音罗马字母。</p>
</div>
<div class="paragraph">
<p><code>say</code> 然后打印出这个子字符串，然后是一个断行符。</p>
</div>
<div class="paragraph">
<p>从这个例子中可以看到，函数调用不需要括号，不过如果你想的话，可以加括号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

say substr($sudoku, $line-number * 9, 9);</code></pre>
</div>
</div>
<div class="paragraph">
<p>或甚至:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

say(substr($sudoku, $line-number * 9, 9));</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_让数独变得可玩">3.1. 让数独变得可玩</h3>
<div class="paragraph">
<p>就像我们现在的脚本输出一样，即使你把它印在纸上，也不能玩出数独的结果。所有这些讨厌的零都会妨碍你真正输入你精心推导出来的数字!</p>
</div>
<div class="paragraph">
<p>所以，让我们把每个0换成空白，这样你就可以解开谜题了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

# file sudoku.p6
use v6;
my $sudoku = &#39;000000075000080094000500600010000200000900057006003040001000023080000006063240000&#39;;
$sudoku = $sudoku.trans(&#39;0&#39; =&gt; &#39; &#39;);
for 0..8 -&gt; $line-number {
    say substr $sudoku, $line-number * 9, 9;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>trans<sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup> 是 Str 类中的一个方法，它的参数是一个 Pair<sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup>。创建一个 Pair 的方法是 <code>Pair.new(&#39;0&#39;, &#39; &#39;)</code>，但是因为它很常用，所以有一个快捷方式，就是用胖箭头形式，<code>⇒</code>。方法 <code>trans</code> 将每一次出现的 pair 的键替换成 pair 的值，然后返回生成的字符串。</p>
</div>
<div class="paragraph">
<p>说到快捷方式，你还可以把 <code>$sudoku.trans(…​)</code> 缩短为 <code>$sudoku.=$sudoku.trans(…​)</code>。这是一个通用的模式，将返回结果的方法变成了 mutator。</p>
</div>
<div class="paragraph">
<p>用新的字符串替换，结果是可以玩的，但很难看。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku sudoku.p6
       75
     8 94
    5 6
   1  2
    9  57
   6 3 4
   1   23
   8    6
   6324</code></pre>
</div>
</div>
<div class="paragraph">
<p>一点点 ASCII 艺术让它变得可以忍受：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

+---+---+---+
|   | 1 |   |
|   |   |79 |
|  9|   |4  |
+---+---+---+
|   | 4 | 5 |
|   |   | 2 |
| 3 | 29|18 |
+---+---+---+
|  4| 87|2  |
|  7| 2 |95 |
| 5 | 3 | 8 |
+---+---+---+</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了得到垂直的分割线，我们需要将这些线细分为更小的块。而既然我们已经有了一次将字符串分成固定大小的小字符串的机会，那么我们就需要将其封装成一个函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub chunks(Str $s, Int $chars) {
    gather loop (my $idx = 0; $idx &lt; $s.chars; $idx += $chars) {
        take substr($s, $idx, $chars); }
    }

for chunks($sudoku, 9) -&gt; $line {
    say chunks($line, 3).join(&#39;|&#39;);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku sudoku.p6
   |   | 75
   | 8 | 94
   |5  |6
 1 |   |2
   |9  | 57
  6|  3| 4
  1|   | 23
  8|   | 6
63 |24 |</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，它是怎么做到的呢？嗯，<code>sub (SIGNATURE) BLOCK</code> 声明了一个子例程，简称 sub。在这里我声明它要接收两个参数，由于我很容易混淆我调用函数的参数顺序，所以我添加了类型约束，使 Raku 很有可能为我捕捉到这个错误。</p>
</div>
<div class="paragraph">
<p><code>gather</code> 和 <code>take</code> 一起工作是为了创建一个列表， <code>gather</code> 是入口点，每执行一次 <code>take</code> 就会在列表中增加一个元素。所以:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

gather {
    take 1;
    take 2;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将返回列表 <code>1, 2</code>。这里 <code>gather</code> 作为语句前缀，意味着它收集了循环中的所有取值。</p>
</div>
<div class="paragraph">
<p><code>loop</code> 语句的形式为 <code>loop (INITIAL, CONDITION, POST) BLOCK</code>，其工作原理类似于 C 语言和相关语言中的 for 循环。它首先执行 INITIAL，然后在 CONDITION 为真时，先执行 BLOCK，然后执行 POST。</p>
</div>
<div class="paragraph">
<p>一个子例程返回最后一个表达式<sup class="footnote">[<a id="_footnoteref_7" class="footnote" href="#_footnotedef_7" title="View footnote.">7</a>]</sup>的值，这里是上面讨论的 <code>gather loop …​</code> 构造。</p>
</div>
<div class="paragraph">
<p>再回到程序中，现在的 for 循环看起来是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

for chunks($sudoku, 9) -&gt; $line {
    say chunks($line, 3).join(&#39;|&#39;);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，程序会将整个数独字符串切成 9 个字符的行，然后将每一行切成 3 个字符串，每个字符串的长度为 3 个字符。join<sup class="footnote">[<a id="_footnoteref_8" class="footnote" href="#_footnotedef_8" title="View footnote.">8</a>]</sup> 方法把它变成了一个字符串，但在块之间插入了管道符号。</p>
</div>
<div class="paragraph">
<p>在这一行的开头和结尾还缺少竖直条，这可以通过改变最后一行来很容易地进行硬编码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

say &#39;|&#39;, chunks($line, 3).join(&#39;|&#39;), &#39;|&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在输出是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">|   |   | 75|
|   | 8 | 94|
|   |5  |6  |
| 1 |   |2  |
|   |9  | 57|
| 6 | 3 | 4 |
| 1 |   | 23|
| 8 |   | 6 |
| 63|24 |   |</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 缺少的只是横线，这并不是太难添加:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $separator = &#39;+---+---+---+&#39;;
my $index = 0;
for chunks($sudoku, 9) -&gt; $line {
    if $index++ %% 3 {
        say $separator;
    }
    say &#39;|&#39;, chunks($line, 3).join(&#39;|&#39;), &#39;|&#39;;
}
say $separator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">+---+---+---+
|   |   | 75|
|   | 8 | 94|
|   |5  |6  |
+---+---+---+
| 1 |   |2  |
|   |9  | 57|
|  6|  3| 4 |
+---+---+---+
|  1|   | 23|
| 8 |   |  6|
| 63|24 |   |
+---+---+---+</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里有一些新的方面：<code>if</code> 条件，这在结构上很像 <code>for</code> 循环，还有整除运算符 <code>%%</code> 。在其他编程语言中，你可能知道 <code>%</code> 代表取模，但由于 <code>$number
% $divisor == 0</code> 是一个常见的模式，所以 <code>$number %% $divisor</code> 是 Raku 对它的快捷方式。</p>
</div>
<div class="paragraph">
<p>最后，你可能在 C 语言或 Perl 5 等编程语言中知道 <code>++</code> 后缀运算符，它可以将变量增量 1，但返回旧值，所以:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $x = 0;
say $x++;
say $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先打印0然后打印1。</p>
</div>
</div>
<div class="sect2">
<h3 id="_捷径常量和更多的捷径">3.2. 捷径、常量和更多的捷径</h3>
<div class="paragraph">
<p>Raku是以人类语言为模型的，人类语言内置了某种压缩方案，常用的单词往往很短，常见的结构有快捷方式。
因此，有很多方法可以更简洁地编写代码。 第一个基本上是作弊，因为子块可以用Str类中的内置方法替换，comb：</p>
</div>
<div class="paragraph">
<p>Raku 是以人类语言为蓝本，人类语言内置了某种压缩方案，其中常用的单词往往比较短，常用的构造物也有快捷键。</p>
</div>
<div class="paragraph">
<p>因此，有很多方法可以把代码写得更简洁。第一种方法基本上是作弊，因为 <code>sub chunks</code> 可以用 Str 类中的内置方法 `comb`<sup class="footnote">[<a id="_footnoteref_9" class="footnote" href="#_footnotedef_9" title="View footnote.">9</a>]</sup> 代替：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

# file sudoku.p6
use v6;

my $sudoku = &#39;000000075000080094000500600010000200000900057006003040001000023080000006063240000&#39;;
$sudoku = $sudoku.trans(&#39;0&#39; =&gt; &#39; &#39;);
my $separator = &#39;+---+---+---+&#39;;
my $index = 0;
for $sudoku.comb(9) -&gt; $line {
    if $index++ %% 3 {
        say $separator;
    }
    say &#39;|&#39;, $line.comb(3).join(&#39;|&#39;), &#39;|&#39;;
}
say $separator;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>if</code> 条件可以作为语句后缀应用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

say $separator if $index++ %% 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了初始化之外，变量 <code>$index</code> 只使用一次，所以不需要给它起名字。是的，Raku 有匿名变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $separator = &#39;+---+---+---+&#39;; for $sudoku.comb(9) -&gt; $line {
say $separator if $++ %% 3;
    say &#39;|&#39;, $line.comb(3).join(&#39;|&#39;), &#39;|&#39;;
}
say $separator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <code>$separator</code> 是常量，我们可以将它声明为：</p>
</div>
<div class="paragraph">
<p>如果你想降低线路噪声因子，你也可以放弃这个sigil，所以恒定的separator =&#39;…​&#39;。
最后，有一个带参数的方法调用的另一种语法：而不是$ obj.method（args），你可以说$ obj.method：args，它将我们带到了小型数独格式化程序的惯用形式：</p>
</div>
<div class="paragraph">
<p>因为 <code>$separator</code> 是一个常数，所以我们可以把它声明为一个常数。</p>
</div>
<div class="paragraph">
<p>如果你想降低行噪声系数，也可以放弃 sigil，所以常量 <code>separator=&#39;…​&#39;</code>。</p>
</div>
<div class="paragraph">
<p>最后，对于带参数的方法调用，还有另一种语法：你可以使用 <code>$obj.method: args</code> 代替 <code>$obj.method(args)</code>，这就给我们引出了成语形式的数独格式化。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

# file sudoku.p6
use v6;

my $sudoku = &#39;000000075000080094000500600010000200000900057006003040 001000023080000006063240000&#39;;
$sudoku = $sudoku.trans: &#39;0&#39; =&gt; &#39; &#39;;

constant separator = &#39;+---+---+---+&#39;;
for $sudoku.comb(9) -&gt; $line {
    say separator if $++ %% 3;
    say &#39;|&#39;, $line.comb(3).join(&#39;|&#39;), &#39;|&#39;;
}
say separator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些对 Raku 代码的修改，输出的内容没有变化。</p>
</div>
</div>
<div class="sect2">
<h3 id="_io_和其它悲剧">3.3. IO 和其它悲剧</h3>
<div class="paragraph">
<p>一个实用的脚本不会把输入作为硬编码的字符串字段，而是从命令行、标准输入或文件中读取。</p>
</div>
<div class="paragraph">
<p>如果你想从命令行读取数独，你可以声明一个叫 MAIN 的子程序，它可以获取所有传入的命令行参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

# file sudoku.p6
use v6;

constant separator = &#39;+---+---+---+&#39;;

sub MAIN($sudoku) {
    my $substituted = $sudoku.trans: &#39;0&#39; =&gt; &#39; &#39;;

    for $substituted.comb(9) -&gt; $line {
        say separator if $++ %% 3;
        say &#39;|&#39;, $line.comb(3).join(&#39;|&#39;), &#39;|&#39;;
    }
    say separator;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是它如何被调用的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku-m sudoku-format-08.p6 0000000750000800940005006000100002000009 00057006003040001000023080000006063240000</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">+---+---+---+
|   |   | 75|
|   | 8 | 94|
|   |5  |6  |
+---+---+---+
| 1 |   |2  |
|   |9  | 57|
|  6|  3| 4 |
+---+---+---+
|  1|   | 23|
| 8 |   |  6|
| 63|24 |   |
+---+---+---+</code></pre>
</div>
</div>
<div class="paragraph">
<p>而且，如果你用错了，甚至可以免费得到一个使用信息，比如省略了参数，就可以得到一个使用信息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku-m sudoku.p6
Usage:
  sudoku.p6 &lt;sudoku&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可能已经注意到，最后一个例子中的替换数独字符串使用了一个单独的变量。这是因为函数参数（签名中声明的变量）默认是只读的。与其创建一个新的变量，我还可以写成 <code>sub MAIN($sudoku is copy) { …​}</code>.</p>
</div>
<div class="paragraph">
<p>经典的 UNIX 程序，如 cat 和 wc，都遵循了从命令行中给出的文件名中读取输入的惯例，如果命令行中没有给出文件名，则从标准输入中读取。</p>
</div>
<div class="paragraph">
<p>如果你想让你的程序遵循这个惯例， <code>lines()</code> 提供了一个从这两个来源中的任何一个来源读取行的流。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

# file sudoku.p6
use v6;

constant separator = &#39;+---+---+---+&#39;;

for lines() -&gt; $sudoku {
    my $substituted = $sudoku.trans: &#39;0&#39; =&gt; &#39; &#39;;

    for $substituted.comb(9) -&gt; $line {
        say separator if $++ %% 3;
        say &#39;|&#39;, $line.comb(3).join(&#39;|&#39;), &#39;|&#39;;
    }
    say separator;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_获得创造性">3.4. 获得创造性</h3>
<div class="paragraph">
<p>你不会从书本上学习一门编程语言，你必须实际使用它，修修补补它。如果你想在前面讨论的例子基础上进行扩展，我鼓励你尝试用不同的输出格式来制作数独。</p>
</div>
<div class="paragraph">
<p>SVG<sup class="footnote">[<a id="_footnoteref_10" class="footnote" href="#_footnotedef_10" title="View footnote.">10</a>]</sup> 是一种基于文本的矢量图形格式，它提供了渲染数独所需的所有原语：矩形、线条、文本等等。如果你想用较少的精力获得相对较好的输出，你可以使用它。</p>
</div>
<div class="paragraph">
<p>这是一个数独的 SVG 文件的粗略骨架。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version=&#34;1.0&#34; standalone=&#34;no&#34;?&gt;
&lt;!DOCTYPE svg PUBLIC &#34;-//W3C//DTD SVG 1.1//EN&#34; &#34;http://www.w3.org/ Graphics/SVG/1.1/DTD/svg11.dtd&#34;&gt;
&lt;svg width=&#34;304&#34; height=&#34;304&#34; version=&#34;1.1&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;
&lt;line x1=&#34;0&#34; x2=&#34;300&#34; y1=&#34;33.3333&#34; y2=&#34;33.3333&#34; style=&#34;stroke:grey&#34; /&gt;
&lt;line x1=&#34;0&#34; x2=&#34;300&#34; y1=&#34;66.6667&#34; y2=&#34;66.6667&#34; style=&#34;stroke:grey&#34; /&gt;
&lt;line x1=&#34;0&#34; x2=&#34;303&#34; y1=&#34;100&#34; y2=&#34;100&#34; style=&#34;stroke:black; stroke-width:2&#34;/&gt;
&lt;line x1=&#34;0&#34; x2=&#34;300&#34; y1=&#34;133.333&#34; y2=&#34;133.333&#34; style=&#34;stroke:grey&#34; /&gt;
    &lt;!-- more horizontal lines here --&gt;
&lt;line y1=&#34;0&#34; y2=&#34;300&#34; x1=&#34;33.3333&#34; x2=&#34;33.3333&#34; style=&#34;stroke:grey&#34; /&gt;
&lt;!-- more vertical lines here --&gt;
&lt;text x=&#34;43.7333&#34; y=&#34;124.5&#34;&gt; 1 &lt;/text&gt;
&lt;text x=&#34;43.7333&#34; y=&#34;257.833&#34;&gt; 8 &lt;/text&gt;
&lt;!-- more cells go here --&gt;
&lt;rect width=&#34;304&#34; height=&#34;304&#34; style=&#34;fill:none;stroke-width: 1;stroke:black;stroke-width:6&#34;/&gt;
&lt;/svg&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你有 Firefox 或 Chrome 浏览器或专用的矢量图形程序如 Inkscape<sup class="footnote">[<a id="_footnoteref_11" class="footnote" href="#_footnotedef_11" title="View footnote.">11</a>]</sup>，你可以用它来打开 SVG 文件（图3-2）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_3">3.5. 总结</h3>
<div class="paragraph">
<p>第一个 Raku 的例子介绍了字素、变量和控制流。</p>
</div>
<div class="paragraph">
<p>你也看到了基本的输入和输出原语，以及 MAIN 子程序，它可以让你轻松地接受命令行参数。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_日期时间转换命令行">4. 日期时间转换命令行</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我偶尔会在工作中使用数据库，它将日期和时间存储为 UNIX 时间戳，也就是 1970-01-01 午夜后的秒数。与数据库的原作者和周围的代码不同，我无法在脑子里进行 UNIX 时间戳和人类可读的日期格式之间的转换，所以我为此写了一些工具。</p>
</div>
<div class="paragraph">
<p>我们这里的目标是写一个小工具，在 UNIX 时间戳和日期/时间之间来回转换。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ autotime 2015-12-24
1450915200
$ autotime 2015-12-24 11:23:00
1450956180
$ autotime 1450915200
2015-12-24
$ autotime 1450956180
2015-12-24 11:23:00
----</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_使用库">4.1. 使用库</h3>
<div class="paragraph">
<p>日期和时间算术是很难搞好的，同时又很无聊，所以我很乐意把这部分工作交给库来做。</p>
</div>
<div class="paragraph">
<p>Raku 的核心库中包含了 DateTime<sup class="footnote">[<a id="_footnoteref_12" class="footnote" href="#_footnotedef_12" title="View footnote.">12</a>]</sup> (有点受 Perl 5 的同名模块的启发)和 Date<sup class="footnote">[<a id="_footnoteref_13" class="footnote" href="#_footnotedef_13" title="View footnote.">13</a>]</sup> (主要是从 Perl 5 的 Date:::Simple 模块中偷来的)。这两个模块将处理实际的转换。我们的重点将是为转换的输入和输出创建一个友好的用户体验。</p>
</div>
<div class="paragraph">
<p>对于从 UNIX 时间戳到日期或时间的转换，<code>DateTime.new</code> 构造函数就派上了用场。它有一个变体，可以接受一个整数作为 UNIX 时间戳。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku -e &#34;say DateTime.new(1480915200)&#34;
2016-12-05T05:20:00Z</code></pre>
</div>
</div>
<div class="paragraph">
<p>看来我们这个方向就快结束了，对吧？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku
sub MAIN (Int $timestamp) {
    say DateTime.new($timestamp)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们来运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ autotime 1450915200
Invalid DateTime string &#39;1450915200&#39;; use an ISO 8601 timestamp (yyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+01:00) instead
  in sub MAIN at autotime line 2
  in block &lt;unit&gt; at autotime line 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>哦，不对，怎么了？似乎 <code>DateTime</code> 构造函数把参数看作是一个字符串，尽管 <code>sub MAIN</code> 的参数声明为 <code>Int</code>，怎么会这样呢？让我们来补充一些调试输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku
sub MAIN(Int $timestamp) {
    say $timestamp.^name;
    say DateTime.new($timestamp)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在用和之前一样的调用运行它，在错误之前多了一行输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">IntStr</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$thing.ˆname</code> 是对 <code>$thing</code> 的元类的一个方法的调用，<code>name</code> 请求它的名称（换句话说，就是类的名称）。IntStr<sup class="footnote">[<a id="_footnoteref_14" class="footnote" href="#_footnotedef_14" title="View footnote.">14</a>]</sup>是 Int 和 Str 的一个子类，这就是为什么 <code>DateTime</code> 构造函数合法地认为它是 Str 的原因。在命令行参数传递给 MAIN 之前，解析命令行参数的机制是将命令行中的字符串转换为 IntStr 而不是 Str，以避免在我们想把它当作字符串的时候丢失信息。</p>
</div>
<div class="paragraph">
<p>长话短说，我们可以通过加一个 <code>+</code> 前缀来强行将参数转化为&#34;实数&#34;整数，这是一般的数值转换机制。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku
sub MAIN(Int $timestamp) {
    say DateTime.new(+$timestamp)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>快速测试后发现，现在可以用了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ ./autotime-01.p6 1450915200
2015-12-24T00:00:00Z</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出的是 ISO 8601 时间戳格式<sup class="footnote">[<a id="_footnoteref_15" class="footnote" href="#_footnotedef_15" title="View footnote.">15</a>]</sup>，这可能不是最容易看懂的。对于一个日期（时、分、秒为零时），我们真的只需要日期。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku
sub MAIN(Int $timestamp) {
    my $dt = DateTime.new(+$timestamp);
    if $dt.hour == 0 &amp;&amp; $dt.minute == 0 &amp;&amp; $dt.second == 0 {
        say $dt.Date;
    }
    else {
        say $dt;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样看起来更好一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ ./autotime 1450915200
2015-12-24</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这个条件就有点笨拙了。真的，写三个和0进行比较的表达式吗？Raku 有一个很好的小功能，可以让你写得更紧凑。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if all($dt.hour, $dt.minute, $dt.second) == 0 {
    say $dt.Date;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>all(…​)</code> 创建了一个 Junction<sup class="footnote">[<a id="_footnoteref_16" class="footnote" href="#_footnotedef_16" title="View footnote.">16</a>]</sup>, 一个由其他几个值组成的复合值，它也存储了一个逻辑模式。当你将一个 Junction 与另一个值进行比较时，这个比较会自动应用到 Junction 中的所有值上。<code>if</code> 语句在布尔语境中对 Junction 进行求值，在这种情况下，只有当所有的比较都返回 <code>True</code> 时，才会返回 <code>True</code>。</p>
</div>
<div class="paragraph">
<p>其他类型的 Junction 还有：<code>any</code>、<code>all</code>、<code>none</code> 和 <code>one</code>。考虑到0是唯一一个在布尔语境中为 <code>false</code> 的整数，我们甚至可以把前面的语句写成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if none($dt.hour, $dt.minute, $dt.second) {
    say $dt.Date;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>很好，对吗？</p>
</div>
<div class="paragraph">
<p>但你不一定需要花哨的语言构造来写出简洁的程序。在这种情况下，从一个略微不同的角度来处理这个问题，会产生更短更清晰的代码。如果 <code>DateTime</code> 对象在不丢失信息的情况下往返转换到 <code>Date</code> 和返回到 <code>DateTime</code>，那它显然是一个 <code>Date</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $dt.Date.DateTime == $dt {
    say $dt.Date;
}
else {
    say $dt;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_datetime_格式化">4.2. DateTime 格式化</h3>
<div class="paragraph">
<p>对于一个没有解析为一整天的时间戳，我们的脚本的输出目前看起来像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">2015-12-24T00:00:01Z</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中的 &#34;Z&#34; 表示 UTC 或 &#34;Zulu&#34; 时区。相反，我希望它是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">2015-12-24 00:00:01</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DateTime</code> 类支持自定义格式化，所以我们来写一个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN(Int $timestamp) {
    my $dt = DateTime.new(+$timestamp, formatter =&gt; sub ($o) {
            sprintf &#39;%04d-%02d-%02d %02d:%02d:%02d&#39;,
                    $o.year, $o.month,  $o.day,
                    $o.hour, $o.minute, $o.second,
    });
    if $dt.Date.DateTime == $dt {
        say $dt.Date;
    }
    else {
        say $dt.Str;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在输出看起来更好看了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">./autotime 1450915201
2015-12-24 00:00:01</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想以不同的格式输出，比如 <code>DD.MM.YYY</code>，你可以用你自己的格式字符串替换格式字符串。</p>
</div>
<div class="paragraph">
<p>语法 <code>formatter ⇒ …​</code> 在参数的上下文中表示一个命名的参数，这意味着名称而不是参数列表中的位置决定了要绑定到哪个参数。如果有一堆参数的话，这个很方便。</p>
</div>
<div class="paragraph">
<p>我不喜欢这样的代码了，因为 <code>formatter</code> 是在 <code>DateTime.new(…​)</code> 调用中内联的，我觉得不清楚。</p>
</div>
<div class="paragraph">
<p>让我们把这个作为一个单独的例程吧:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku
sub MAIN(Int $timestamp) {
    sub formatter($o) {
        sprintf &#39;%04d-%02d-%02d %02d:%02d:%02d&#39;,
                $o.year, $o.month,  $o.day,
                $o.hour, $o.minute, $o.second,
    }
    my $dt = DateTime.new(+$timestamp, formatter =&gt; &amp;formatter);
    if $dt.Date.DateTime == $dt {
        say $dt.Date;
    }
    else {
        say $dt.Str;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>是的，你可以把一个子例程声明放在另一个子例程声明的正文中；子例程只是一个普通的词法符号，就像用 <code>my</code> 声明的变量一样。</p>
</div>
<div class="paragraph">
<p>在这行中，<code>my $dt = DateTime.new(+$timestamp, formatter ⇒ &amp;formatter);</code>，语法中的 <code>&amp;formatter</code> 指的是将子例程作为一个对象，而不是调用它。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，<code>formatter ⇒ &amp;formatter</code> 有一个快捷方式： <code>:&amp;formatter</code>。一般来说，如果你想填充一个命名参数，其名称是变量的名称，而其值是变量的值，你可以通过写 <code>:$variable</code> 来创建它。而引申一下，<code>:thing</code> 是 <code>thing ⇒ True</code> 的简写。</p>
</div>
</div>
<div class="sect2">
<h3 id="_寻找其他途径">4.3. 寻找其他途径</h3>
<div class="paragraph">
<p>现在，从时间戳到日期和时间的转换工作已经很顺利了，我们来看看另一个方向。我们的小工具需要对输入进行解析，并决定输入是时间戳还是日期，以及可选的时间。</p>
</div>
<div class="paragraph">
<p>无聊的方法就是使用条件转换。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN($input) {
    if $input ~~ / ^ \d+ $ / {
        # convert from timestamp to date/datetime
    }
    else {
        # convert from date to timestamp

    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但我讨厌无聊，所以我想看看更刺激（和可扩展）的方法。</p>
</div>
<div class="paragraph">
<p>Raku 支持多重分派。这意味着你可以有多个名字相同，但签名不同的子程序。而 Raku 会自动决定调用哪个子程序。你必须通过写`multi sub` 而不是 <code>sub</code> 来显式地启用这个功能，这样 Raku 就能为你捕获意外的重声明。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

multi sub MAIN(Int $timestamp) {
    sub formatter($o) {
        sprintf &#39;%04d-%02d-%02d %02d:%02d:%02d&#39;,
                $o.year, $o.month,  $o.day,
                $o.hour, $o.minute, $o.second,
    }
    my $dt = DateTime.new(+$timestamp, :&amp;formatter);
    if $dt.Date.DateTime == $dt {
        say $dt.Date;
    }
    else {
        say $dt.Str;
    }
}


multi sub MAIN(Str $date) {
    say Date.new($date).DateTime.posix
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们来看看它的表现吧:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ ./autotime 2015-12-24
1450915200
$ ./autotime 1450915200
Ambiguous call to &#39;MAIN&#39;; these signatures all match:
:(Int $timestamp)
:(Str $date)
  in block &lt;unit&gt; at ./autotime line 17</code></pre>
</div>
</div>
<div class="paragraph">
<p>不太符合我的设想。问题又来了，整数参数被自动转换为 IntStr，而 Int 和 Str multi（或候选）都接受这个参数。</p>
</div>
<div class="paragraph">
<p>要避免这个错误，最简单的方法是缩小 Str 候选者接受的字符串种类。经典的方法是使用一个可以大致验证传入参数的 regex。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN(Str $date where /^ \d+ \- \d+ \- \d+ $ /) {
    say Date.new($date).DateTime.posix
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上，它确实有效，但为什么要重复 <code>Date.new</code> 已经有的验证日期字符串的逻辑？如果你传递一个看起来不像日期的字符串参数，你会得到这样的错误。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Invalid Date string &#39;foobar&#39;; use yyyy-mm-dd instead</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以用这种行为来约束 <code>MAIN multi</code> 候选者的字符串参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN(Str $date where { try Date.new($_) }) {
    say Date.new($date).DateTime.posix
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里额外的 <code>try</code> 是因为 <code>where</code> 后面的子类型约束不应该抛出一个异常，只是返回一个假值。</p>
</div>
<div class="paragraph">
<p>而现在它的工作原理和预期的一样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ ./autotime 2015-12-24;
1450915200
$ ./autotime 1450915200
2015-12-24</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_处理时间">4.4. 处理时间</h3>
<div class="paragraph">
<p>唯一需要实现的功能就是将日期和时间转换为时间戳。换句话说，我们要处理像 <code>autotime 2015-12-24 11:23:00</code> 这样的调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN(Str $date where { try Date.new($_) }, Str $time?) {
    my $d = Date.new($date);
    if $time {
        my ( $hour, $minute, $second ) = $time.split(&#39;:&#39;);
        say DateTime.new(date =&gt; $d, :$hour, :$minute, :$second).posix;
    }
    else {
        say $d.DateTime.posix;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为后面的 <code>?</code> 的存在, 新的第二个参数是可选的。我们在冒号上拆分时间字符串，得到小时、分钟和秒。在写这段代码的时候，我的第一直觉是使用更短的变量名, <code>my ($h, $m, $s) = $time.split(&#39;:&#39;)</code>, 但这样对 <code>DateTime</code> 构造函数的调用就会是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">DateTime.new(date =&gt; $d, hour =&gt; $h, minute =&gt; $m, second =&gt; $s);</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以，构造函数的命名参数让我选择了更多的自解释变量名。</p>
</div>
<div class="paragraph">
<p>所以，这样就成功了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">./autotime 2015-12-24 11:23:00
1450956180</code></pre>
</div>
</div>
<div class="paragraph">
<p>而且我们还可以检测它的往返:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ ./autotime 1450956180
2015-12-24 11:23:00</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_系好你的安全带">4.5. 系好你的安全带</h3>
<div class="paragraph">
<p>现在程序的功能已经完成了，我们应该努力去掉一些杂乱无章的东西，再去探索一下 Raku 的一些很棒的功能。</p>
</div>
<div class="paragraph">
<p>我想利用的第一个特性是隐式变量或主题的特性。快速演示一下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 1..3 {
    .say
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1
2
3</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有显式的迭代变量，所以 Raku 隐式地将循环的当前值绑定到一个叫 <code>$_</code> 的变量上。方法调用 <code>.say</code> 是 <code>$_.say</code> 的一个快捷方式。而且由于有一个子例程在同一个变量上调用了六个方法，所以在这里使用 <code>$_</code> 是一个很好的视觉优化:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub formatter($_) {
    sprintf &#39;%04d-%02d-%02d %02d:%02d:%02d&#39;,
            .year, .month,  .day,
            .hour, .minute, .second,
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想在一个词法范围内设置 <code>$_</code>，而不需要借助于函数定义，你可以使用 <code>given VALUE BLOCK</code> 构造:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given DateTime.new(+$timestamp, :&amp;formatter) {
    if .Date.DateTime == $_ {
        say .Date;
    }
    else {
        .say;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而且 Raku 还提供了一个对 <code>$_</code> 变量的条件语句的快捷方式，可以作为一个通用的 <code>switch</code> 语句来使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given DateTime.new(+$timestamp, :&amp;formatter) {
    when .Date.DateTime == $_ { say .Date }
    default { .say }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你有一个只读变量或参数，你可以不用 <code>$</code> sigil， 虽然你必须在声明时使用反斜线:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN(Int \timestamp) {
    ...
    given DateTime.new(+timestamp, :&amp;formatter) {
    ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以现在完整的代码看起来是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

multi sub MAIN(Int \timestamp) {
    sub formatter($_) {
        sprintf &#39;%04d-%02d-%02d %02d:%02d:%02d&#39;,
                .year, .month,  .day,
                .hour, .minute, .second,
    }
    given DateTime.new(+timestamp, :&amp;formatter) {
        when .Date.DateTime == $_ { say .Date }
        default { .say }
    }
}

multi sub MAIN(Str $date where { try Date.new($_) }, Str $time?) {
    my $d = Date.new($date);
    if $time {
        my ( $hour, $minute, $second ) = $time.split(&#39;:&#39;);
        say DateTime.new(date =&gt; $d, :$hour, :$minute, :$second).posix;
    }
    else {
        say $d.DateTime.posix;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_main_魔法">4.6. MAIN 魔法</h3>
<div class="paragraph">
<p>如果我们在调用 <code>sub MAIN</code> 的时候，如果我们用不符合任何 <code>multi</code> 参数的参数来调用它，那么调用 <code>sub MAIN</code> 的魔力也会给我们提供一个自动的使用信息；比如说调用时不提供参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ ./autotime
Usage:
  ./autotime &lt;timestamp&gt;
  ./autotime &lt;date&gt; [&lt;time&gt;]</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以通过在 <code>MAIN subs</code> 之前添加语义注释，为这些用法信息添加一个简短的描述:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

#| Convert timestamp to ISO date
multi sub MAIN(Int \timestamp) {
    ...
}

#| Convert ISO date to timestamp
multi sub MAIN(Str $date where { try Date.new($_) }, Str $time?) {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在用法信息变为了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ ./autotime
Usage:
  ./autotime &lt;timestamp&gt; -- Convert timestamp to ISO date
  ./autotime &lt;date&gt; [&lt;time&gt;] -- Convert ISO date to timestamp</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_自动化测试">4.7. 自动化测试</h3>
<div class="paragraph">
<p>我们已经看到一些代码经过了几次重构的迭代。没有自动测试的重构往往会让我感到不安，所以我其实有一个小的 shell 脚本，用几个不同的参数组合来调用正在开发的脚本，并将其与预期的结果进行比较。</p>
</div>
<div class="paragraph">
<p>现在让我们来看看在 Raku 本身中编写测试代码的方法。</p>
</div>
<div class="paragraph">
<p>在 Perl 社区中，将逻辑移到模块中，以便于使用外部测试脚本进行测试是很常见的。在 Raku 中，这仍然很常见，但对于像这样的小工具，我更喜欢用一个包含代码和测试的单一文件，并通过单独的测试命令来运行测试。</p>
</div>
<div class="paragraph">
<p>为了让测试更容易，我们先把 I/O 和应用逻辑分开:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env perl6
sub from-timestamp(Int \timestamp) {
    sub formatter($_) {
        sprintf &#39;%04d-%02d-%02d %02d:%02d:%02d&#39;,
            .year, .month, .day,
            .hour, .minute, .second,
    }
    given DateTime.new(+timestamp, :&amp;formatter) {
        when .Date.DateTime == $_ { return .Date }
        default { return $_ }
    }
}

sub from-date-string(Str $date, Str $time?) {
    my $d = Date.new($date);
    if $time {
        my ( $hour, $minute, $second ) = $time.split(&#39;:&#39;);
        return DateTime.new(date =&gt; $d, :$hour, :$minute, :$second);
    } else {
        return $d.DateTime;
    }
}

#| Convert timestamp to ISO date
multi sub MAIN(Int \timestamp) {
    say from-timestamp(+timestamp);
}

#| Convert ISO date to timestamp
multi sub MAIN(Str $date where { try Date.new($_) }, Str $time?) {
    say from-date-string($date, $time).posix;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个小的重构没了，我们来补充一些测试:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| Run internal tests
multi sub MAIN(&#39;test&#39;) {
    use Test;
    plan 4;
    is-deeply from-timestamp(1450915200), Date.new(&#39;2015-12-24&#39;), &#39;Timestamp to Date&#39;;

    my $dt = from-timestamp(1450915201);
    is $dt, &#34;2015-12-24 00:00:01&#34;, &#39;Timestamp to DateTime with string formatting&#39;;
    is from-date-string(&#39;2015-12-24&#39;).posix, 1450915200, &#39;from-date-string, one argument&#39;;
    is from-date-string(&#39;2015-12-24&#39;, &#39;00:00:01&#39;).posix, 1450915201, &#39;from-date-string, two arguments&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">./autotime test
1..4
ok 1 - Timestamp to Date
ok 2 - Timestamp to DateTime with string formatting
ok 3 - from-date-string, one argument
ok 4 - from-date-string, two arguments</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出格式是 Test Anything Protocol (TAP)<sup class="footnote">[<a id="_footnoteref_17" class="footnote" href="#_footnotedef_17" title="View footnote.">17</a>]</sup>，这是 Perl 社区中的实际标准<sup class="footnote">[<a id="_footnoteref_18" class="footnote" href="#_footnotedef_18" title="View footnote.">18</a>]</sup>， 但现在其他社区也在使用。对于较大的输出字符串，通过测试套件来运行测试是个好主意。对于我们的四行测试输出来说，这还不是必要的，但如果你想这样做，你可以使用 Perl 5 自带的 <code>prove</code> 程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ prove -e &#34;&#34; &#34;./autotime test&#34;
./autotime-tested.p6 test .. ok</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">All tests successful.
Files=1, Tests=4, 0 wallclock secs ( 0.02 usr 0.01 sys + 0.23 cusr 0.02 csys = 0.28 CPU)
Result: PASS</code></pre>
</div>
</div>
<div class="paragraph">
<p>在终端中，这甚至会将 &#34;All tests successful&#34; 输出的颜色标注为绿色，这样更容易被发现。而测试失败则用红色标记。</p>
</div>
<div class="paragraph">
<p>测试是如何工作的？第一行代码使用了一个我们还没有看到的新功能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN(&#39;test&#39;) {</code></pre>
</div>
</div>
<div class="paragraph">
<p>那是什么，在子程序签名中用字面值代替参数？</p>
</div>
<div class="paragraph">
<p>没错，就是这个。它是下面这段代码的简写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN(Str $anon where {$anon eq &#39;test&#39;}) {</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了它没有声明变量 <code>$anon</code>。所以它是一个 <code>multi</code> 候选项，只能通过提供字符串 &#39;test&#39; 作为唯一参数来调用。</p>
</div>
<div class="paragraph">
<p>下一行，<code>use Test;</code>，加载 Raku 附带的测试模块<sup class="footnote">[<a id="_footnoteref_19" class="footnote" href="#_footnotedef_19" title="View footnote.">19</a>]</sup>。它还会将 <code>Test</code> 默认导出的所有符号导入到当前的词法作用域中。这包括后面要用到的函数 <code>plan</code>、<code>is</code>、和 <code>is-deeply</code>。</p>
</div>
<div class="paragraph">
<p><code>plan 4;</code> 声明我们要运行四个测试。这对于检测测试代码中的无计划、提前退出，或者测试代码中的循环逻辑错误导致运行的测试量比计划中的少，是很有用的。如果你不忍心提前计算测试，可以省去 <code>plan</code> 调用，而是在测试完成后再调用 <code>done-testing</code>。</p>
</div>
<div class="paragraph">
<p><code>is-deeply</code> 和 <code>is</code> 都是把要测试的值作为第一个参数，预期值作为第二个参数，第三个参数是可选的测试标签字符串。不同的是， <code>is</code> 是将前两个参数作为字符串进行比较，而 <code>is-deeply</code> 使用的是使用 <code>eqv</code> 操作符<sup class="footnote">[<a id="_footnoteref_20" class="footnote" href="#_footnotedef_20" title="View footnote.">20</a>]</sup>的深度相等比较逻辑。</p>
</div>
<div class="paragraph">
<p>还有更多的测试函数可以使用，比如 <code>ok()</code>，它对真参数成功，而 <code>nok()</code>，它对假参数的期望值是假的。你也可以用 <code>subtest</code> 来嵌套测试:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| Run internal tests
multi sub MAIN(&#39;test&#39;) {
    use Test; plan 2;

    subtest &#39;timestamp&#39;, {
        plan 2;
        is-deeply from-timestamp(1450915200), Date.new(&#39;2015-12-24&#39;), &#39;Date&#39;;;

        my $dt = from-timestamp(1450915201);
        is $dt, &#34;2015-12-24 00:00:01&#34;, &#39;DateTime with string formatting&#39;;
    };

    subtest &#39;from-date-string&#39;, {
        plan 2;
        is from-date-string(&#39;2015-12-24&#39;).posix, 1450915200, &#39;one argument&#39;;
        is from-date-string(&#39;2015-12-24&#39;, &#39;00:00:01&#39;).posix, 1450915201, &#39;two arguments&#39;;
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每一次对 <code>subtest</code> 的调用都算作一次对外部测试运行的测试，所以 <code>plan 4;</code> 变成了 <code>plan 2;</code>。<code>subtest</code> 测试的调用本身就有一个测试标签，然后在一个 <code>subtest</code> 测试内部，你又有一个 <code>plan</code>，并调用测试函数，如下图所示。这在编写自定义测试函数时非常有用，因为它可以执行不同数量的单独测试。</p>
</div>
<div class="paragraph">
<p>嵌套测试的输出看起来是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">1..2
    1..2
    ok 1 - Date
    ok 2 - DateTime with string formatting
ok 1 - timestamp
    1..2
    ok 1 - one argument
    ok 2 - two arguments
ok 2 - from-date-string</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，测试套件只报告两个顶级测试的运行（和通过的）测试数量。是的，你可以在子测试中嵌套子测试，如果你真的想这么做的话。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_4">4.8. 总结</h3>
<div class="paragraph">
<p>我们已经看到了一些 Date 和 DateTime 的算术，但最精彩的部分是多重分派、命名参数、带 where 子句的子类型约束、 given/when 和隐式的 <code>$_</code> 变量，以及当涉及到 <code>MAIN</code> 子句时，一些严肃的魔法。</p>
</div>
<div class="paragraph">
<p>最后，我们学习了使用 Raku 自带的 <code>Test</code> 模块进行自动测试。</p>
</div>
<div class="paragraph">
<p>花点时间阅读一下你到目前为止使用过的文档。看看你是否能在你的代码中找到一个地方把 <code>if</code> 换成 <code>where</code> 语句<sup class="footnote">[<a id="_footnoteref_21" class="footnote" href="#_footnotedef_21" title="View footnote.">21</a>]</sup>。一定要利用好 <code>where</code> 引入的词法作用域。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_测试_say">5. 测试 say</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在上一章中，我修改了一些代码，让它不产生输出，而是在 MAIN 子例程中做了输出，方便的是没有测试。</p>
</div>
<div class="paragraph">
<p>改变代码以使其更容易测试是一种合理的做法。但如果你确实要测试通过调用 <code>say</code> 来产生输出的代码，有一个小技巧你可以使用：<code>say</code> 在一个文件句柄上工作，你可以把默认的文件句柄换掉，这个句柄是连接到标准输出的。你可以在它的位置上放一个假文件句柄来代替默认的文件句柄，捕捉向它发出的低级命令，并记录下来，供测试用。</p>
</div>
<div class="paragraph">
<p>这里有一个现成的模块，IO:::String<sup class="footnote">[<a id="_footnoteref_22" class="footnote" href="#_footnotedef_22" title="View footnote.">22</a>]</sup>,但为了学习的缘故，我们来看看它是如何工作的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use v6;

# function to be tested
sub doublespeak($x) {
    say $x ~ $x;
}

use Test;
plan 1;

my class OutputCapture {
    has @!lines;
    method print(\s) {
        @!lines.push(s);
    }
    method captured() {
        @!lines.join;
    }
}

my $output = do {
    my $*OUT = OutputCapture.new;
    doublespeak(42);
    $*OUT.captured;
};
is $output, &#34;4242\n&#34;, &#39;doublespeak works&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码的第一部分是我们要测试的函数 -  <code>sub doublespeak</code>。它用 <code>∼</code> 字符串连接运算符将其参数与自身进行连接。结果被传递给 <code>say</code>。</p>
</div>
<div class="paragraph">
<p>在引擎盖下，<code>say</code> 会做一些格式化处理，然后查找变量 <code>$<strong>OUT</strong></code><strong>。sigil 后面的 <code></code></strong> 标志着它是一个动态变量。对动态变量的查找会通过调用栈，在每个栈帧中查找变量的声明，并在每个栈帧中选择第一个找到的变量。</p>
</div>
<div class="paragraph">
<p>通常情况下，<code>$*OUT</code> 包含一个类型为 <code>IO:::Handle`<sup class="footnote">[<a id="_footnoteref_23" class="footnote" href="#_footnotedef_23" title="View footnote.">23</a>]</sup> 的对象，但 `say</code> 函数其实并不关心这个，只要能在这个对象上调用 <code>print</code> 方法就可以了。这就是所谓的鸭子类型化：我们其实并不关心对象的类型，只要它能像鸭子一样呱呱叫就可以了。或者在这个例子中，像鸭子一样打印。</p>
</div>
<div class="paragraph">
<p>然后是测试模块的加载<sup class="footnote">[<a id="_footnoteref_24" class="footnote" href="#_footnotedef_24" title="View footnote.">24</a>]</sup>，接下来就是声明要运行多少个测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use Test;
plan 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以省略第二行，在测试之后调用 <code>one-testing</code>。但是，如果测试代码本身有可能出现 bug，没有运行它应该运行的测试，那么事先声明一下预期的测试数量是很好的，这样测试模块或者测试线束就可以抓住这样的错误。</p>
</div>
<div class="paragraph">
<p>接下来的例子是声明一个类型，我们可以用这个类型来模拟 <code>IO::Handle</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my class OutputCapture {
    has @!lines;
    method print(\s) {
        @!lines.append(s);
    }
    method captured() {
        @!lines.join;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>class</code> 引入了一个类，而 <code>my</code> 前缀使得名称在词法上有了作用域，就像在 <code>my $var</code> 声明中一样。</p>
</div>
<div class="paragraph">
<p><code>has @!</code> 行声明了一个属性，也就是说，对于类 <code>OutputCapture</code> 的每个实例来说，它是一个单独存在的变量。<code>!</code> 标志着它是一个属性。我们可以把它省略掉，但把它放在那里意味着当你读取一个大类时，你总是知道这个名字来自哪里。</p>
</div>
<div class="paragraph">
<p>属性 <code>@!</code> 行是以 <code>@</code> 开头的，而不是像我们到目前为止看到的其他变量那样以 <code>$</code> 开头。<code>@</code> 是数组变量的标志。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">符号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类型约束</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解释</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mu</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单个值和对象</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Positional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整数索引的组合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Associative</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符串或对象索引的组合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&amp;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Callable</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你可以调用的对象代码</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>你现在可能会看到一个趋势：变量或属性名称的第一个字符表示它的粗略类型（scalar、数组、<code>&amp;</code> 表示例程，稍后我们会了解到 <code>%</code> 表示散列），如果第二个字符不是字母，则表示它的范围。我们把这个第二个字符称为 twigil。到目前为止，我们已经看到了动态变量的 <code>*</code> 和属性的 <code>!</code>。还有更多:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Twigil</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">动态作用域变量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">!</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OO 领域的属性</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">^</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">隐式位置参数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">隐式命名参数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">编译器提供的常量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pod(文档)变量</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>我们的例子的倒数第二个块是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $output = do {
    my $*OUT = OutputCapture.new;
    doublespeak(42);
    $*OUT.captured;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>do { …​ }</code> 只是执行大括号内的代码，并返回最后一条语句的值。和 Raku 中的所有代码块一样，它也引入了一个新的词法作用域。
新的作用域在下一行中派上了用场，<code>my $*OUT</code> 声明了一个新的动态变量 <code>$*OUT</code>，但是它只在块的作用域中有效。它是用 <code>OutputCapture.new</code> 来初始化的，它是前面声明的类的一个新实例。<code>new</code> 并不是什么神奇的东西，它只是从 <code>OutputCapture</code> 的超级类中继承过来的。我们没有声明一个，但默认情况下，类会得到类型为 Any<sup class="footnote">[<a id="_footnoteref_25" class="footnote" href="#_footnotedef_25" title="View footnote.">25</a>]</sup> 的超级类，它提供了（除此之外）方法 <code>new</code> 作为构造函数。</p>
</div>
<div class="paragraph">
<p>调用 <code>doublepeak</code> 调用 <code>say</code>，<code>say</code> 又会调用 <code>$*OUT.print</code>。而由于 <code>$*OUT</code> 是这个动态作用域中的 <code>OutputCapture</code> 的一个实例，所以传递给 <code>say</code> 的字符串会落在 <code>OutputCapture</code> 的属性 <code>@!line</code> 中，在这里 <code>$*OUT.captured</code> 可以再次访问它。</p>
</div>
<div class="paragraph">
<p>最后一行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

is $output, &#34;4242\n&#34;, &#39;doublespeak works&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>调用测试模块中的 <code>is</code> 函数。</p>
</div>
<div class="paragraph">
<p>在良好的测试传统中，这将产生 TAP 格式的输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">1..1
ok 1 - doublespeak works</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_总结_5">5.1. 总结</h3>
<div class="paragraph">
<p>我们已经看到，<code>say()</code> 使用一个动态作用域变量 <code>$*OUT</code> 作为它的输出文件句柄。为了测试的目的，我们可以用一个我们自己制作的对象来代替，这让我们偶然发现了 Raku 中类是如何编写的。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_silent_cron_一个_cron_包裹器">6. Silent-Cron, 一个 Cron 包裹器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Linux 和类似 UNIX 的系统中，一个名为 cron<sup class="footnote">[<a id="_footnoteref_26" class="footnote" href="#_footnotedef_26" title="View footnote.">26</a>]</sup> 的程序会在后台定期执行用户定义的命令。它用于系统维护任务，如刷新或删除缓存、旋转和删除旧的日志文件等。</p>
</div>
<div class="paragraph">
<p>如果这样的命令产生任何输出，cron 通常会发送一封包含输出的电子邮件，以便管理员查看，判断是否需要采取一些行动。</p>
</div>
<div class="paragraph">
<p>但是，并不是所有的命令行程序都是为使用 cron 编写的。例如，它们可能在成功执行时也会产生输出，并通过非零的退出代码表示失败。或者它们可能会挂起，或者其他方面的错误行为。</p>
</div>
<div class="paragraph">
<p>为了处理这类命令，我们将开发一个名为 silent-cron 的小程序，它可以封装这类命令，并在退出代码为0时抑制输出。它还允许你指定一个超时，如果时间过长，就会杀死被包装的程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ silent-cron -- command-that-might-fail args
$ silent-cron --timeout=5 -- command-that-might-hang</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_异步运行命令">6.1. 异步运行命令</h3>
<div class="paragraph">
<p>当你想运行外部命令时，Raku 基本上给你两个选择：run<sup class="footnote">[<a id="_footnoteref_27" class="footnote" href="#_footnotedef_27" title="View footnote.">27</a>]</sup>,是一个简单的同步接口；Proc::Async<sup class="footnote">[<a id="_footnoteref_28" class="footnote" href="#_footnotedef_28" title="View footnote.">28</a>]</sup>,是一个异步的、稍微复杂一点的选项。尽管我们在第一次迭代中会省略超时，但我们需要注意的是，在异步接口中实现超时是比较容易的，所以我们将使用这个接口。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

#!/usr/bin/env raku
sub MAIN(*@cmd) {
    my $proc = Proc::Async.new(|@cmd);
    my $collector = Channel.new;
    for $proc.stdout, $proc.stderr -&gt; $supply {
        $supply.tap: { $collector.send($_) }
    }
    my $result = $proc.start.result;
    $collector.close;
    my $output = $collector.list.join;
    my $exitcode = $result.exitcode;
    if $exitcode != 0 {
        say &#34;Program @cmd[] exited with code $exitcode&#34;;
        print &#34;Output:\n&#34;, $output if $output;
    }
    exit $exitcode;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里面有一大块新的功能和概念，让我们一点一点地去看一下代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub MAIN(*@cmd) {</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先你应该注意的是 <code><strong>@cmd</strong></code><strong>。变量前面的 <code></code></strong> 表示的是一个 slurpy 参数<sup class="footnote">[<a id="_footnoteref_29" class="footnote" href="#_footnotedef_29" title="View footnote.">29</a>]</sup>，它之所以这样命名，是因为它可以吞噬任何数量的参数。这个 <code>*</code> 只需要在参数声明中使用。</p>
</div>
<div class="paragraph">
<p>所以 <code>*@cmd</code> 收集了所有的命令行参数，在数组变量 <code>@cmd</code> 中，第一个元素是要执行的命令，其他元素是传递给这个命令的参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $proc = Proc::Async.new(|@cmd);</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一行用传入的命令创建了一个新的 <code>Proc::Async</code> 实例，但还没有运行任何东西。<code>Proc::Async.new</code> 并不期望我们传送一个数组，但它希望我们传递任意数量的值作为参数。因此，我们在 <code>@cmd</code> 之前使用 <code>|</code> 竖条<sup class="footnote">[<a id="_footnoteref_30" class="footnote" href="#_footnotedef_30" title="View footnote.">30</a>]</sup>将数组扁平化，这样我们就可以向 <code>Proc::Async.new</code> 发送多个值，而不是一个数组值。</p>
</div>
<div class="paragraph">
<p>对于我们的程序，我们需要捕获来自 <code>$proc</code> 的所有输出；因此我们捕获 STDOUT 和 STDERR 流的输出（Linux上的文件句柄1和2），并将其合并为一个字符串。在异步 API 中，STDOUT 和 STDERR 被建模为 Supply 类型的对象<sup class="footnote">[<a id="_footnoteref_31" class="footnote" href="#_footnotedef_31" title="View footnote.">31</a>]</sup> ，因此是事件流。由于 Supplies 可以并行地发出事件，因此我们需要一个线程安全的数据结构来收集结果，而 Raku 为此提供了一个 Channel。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $collector = Channel.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了实际得到程序的输出，我们需要切入 STDOUT 和 STDERR 流:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

for $proc.stdout, $proc.stderr -&gt; $supply {
    $supply.tap: { $collector.send($_) }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个 <code>$supply</code> 都会对它接收到的每一个字符串执行块 <code>{ $collector.send($_) }</code>。这个字符串可以是一个字符、一行，如果流是缓冲的，也可以是更大的东西。我们所要做的就是通过 <code>send</code> 方法将字符串放入通道 <code>$collector</code> 中。</p>
</div>
<div class="paragraph">
<p>请注意，前面的代码相当于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

$proc.stdout.tap: { $collector.send($_) }
$proc.stderr.tap: { $collector.send($_) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在运行一个简单的脚本时，你经常会看到正常输出和错误输出一起打印到终端上。我们的代码是将 STDOUT 和 STDERR 输出交错到 <code>$collector</code> 中，其方式基本相同。</p>
</div>
<div class="paragraph">
<p>现在这些数据流已经被分接出来，并连接到我们的收集器，我们可以启动程序，等待程序完成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $result = $proc.start.result;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Proc::Async.start</code> 执行外部进程并返回一个 <code>Promise</code>。<sup class="footnote">[<a id="_footnoteref_32" class="footnote" href="#_footnotedef_32" title="View footnote.">32</a>]</sup> <code>Promise</code> 包装了一段可能在另一个线程上运行的代码，有一个状态(<code>Planned</code>、<code>Kept</code> 或 <code>Broken</code>)，一旦完成，就会有一个结果。访问结果会自动等待被包装的代码完成。这里的代码是运行外部程序的代码，结果是 Proc<sup class="footnote">[<a id="_footnoteref_33" class="footnote" href="#_footnotedef_33" title="View footnote.">33</a>]</sup> 类型的对象（恰好和同步接口中的 <code>run()</code> 函数一样）。</p>
</div>
<div class="paragraph">
<p>在这一行之后，我们可以确定外部命令已经终止，因此不会再有 <code>$proc.stdout</code> 和 <code>$proc.stderr</code> 的输出。因此，我们可以安全地关闭通道，并通过 <code>Channel.list</code> 访问它的所有元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

$collector.close;
my $output = $collector.list.join;</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，是检查外部命令是否成功的时候了。</p>
</div>
<div class="paragraph">
<p>检查其退出代码 - 并以命令的退出代码退出包装程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $exitcode = $result.exitcode;
if $exitcode != 0 {
    say &#34;Program @cmd[] exited with code $exitcode&#34;;
    print &#34;Output:\n&#34;, $output if $output;
}
exit $exitcode;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在输出字符串内：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

say &#34;Program @cmd[] exited with code $exitcode&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>变量 <code>$exitcode</code> 被内插，也就是说，它的名字在运行时被替换为其值。这在双引号字符串&#34;…​ &#34;中会发生，但在单引号字符串&#39;…​&#39;中不会。只有标量变量在&#34;…​ &#34;中才会被插值；其他变量（数组、哈希值、代码对象）只有在后面有某种括号结构时才会被插值。这就是为什么 <code>@cmd</code> 后面有 <code>[]</code> 的原因，我们称其为 Zen slice。返回多个值的数组或哈希索引一般称为切片；例如，<code>@cmd[0，1]</code> 返回前两个值。将索引留空则返回整个数组。</p>
</div>
<div class="paragraph">
<p>另一种实现插值的方法是在变量上添加一个以括号结尾的方法调用，所以也可以写成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

say &#34;Program @cmd.join(&#39; &#39;) exited with code $exitcode&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关&#34;…​ &#34;插值的更多深入信息，请参见文档。<sup class="footnote">[<a id="_footnoteref_34" class="footnote" href="#_footnotedef_34" title="View footnote.">34</a>]</sup></p>
</div>
</div>
<div class="sect2">
<h3 id="_实现超时">6.2. 实现超时</h3>
<div class="paragraph">
<p>在 Raku 中实现超时的常用方法是使用 <code>Promise.anyof</code> 组合器和定时器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub MAIN(*@cmd, :$timeout) {
    my $proc = Proc::Async.new(|@cmd);
    my $collector = Channel.new;
    for $proc.stdout, $proc.stderr -&gt; $supply {
        $supply.tap: { $collector.send($_) }
    }

    my $promise = $proc.start;
    my $waitfor = $promise;
    $waitfor = Promise.anyof(Promise.in($timeout), $promise)
        if $timeout;
    await $waitfor;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$proc</code> 的初始化没有改变。但我们不访问 <code>$proc.start.result</code>，而是存储从 <code>$proc.start</code> 返回的承诺。如果用户指定了超时，我们运行这段代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

$waitfor = Promise.anyof(Promise.in($timeout), $promise)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Promise.in($seconds)</code> 返回一个将在 <code>$seconds</code> 秒内实现的承诺，它基本上和 <code>start { sleep $seconds }</code> 是一样的，但是调度器可以更聪明一点，不要只分配一整条线程来休眠。</p>
</div>
<div class="paragraph">
<p><code>Promise.anyof($p1,$p2)</code> 返回一个承诺，只要其中一个参数(也应该是承诺)被实现，就会返回一个承诺。所以，我们要么等待外部程序完成，要么等待 <code>sleep</code> 承诺实现。</p>
</div>
<div class="paragraph">
<p>使用 <code>await $waitfor;</code> 程序等待承诺被实现（或被打破）。在这种情况下，我们不能像以前那样简单地访问 <code>$promise.result</code>，因为在超时的情况下，<code>$promise</code>(即外部程序的承诺)可能无法实现。所以我们必须先检查承诺的状态，只有这样我们才能安全地访问 <code>$promise.result</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

if !$timeout || $promise.status ~~ Kept {
    my $exitcode = $promise.result.exitcode;
    my $output = $collector.list.join;

    if $exitcode != 0 {
        say &#34;Program @cmd[] exited with code $exitcode&#34;;
        print &#34;Output:\n&#34;, $output if $output;
    }
    exit $exitcode;
}
else {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>表达式 <code>$promise.status ~~ Kept</code> 使用智能匹配运算符来检查承诺状态是否与常数 <code>Kept</code> 的状态相同。智能匹配是一个非常通用的运算符，其语义取决于表达式的右侧。对于右侧的数，比较的是数值。对于右侧的类型，则是类型检查。更多内容请参考官方文档。<sup class="footnote">[<a id="_footnoteref_35" class="footnote" href="#_footnotedef_35" title="View footnote.">35</a>]</sup></p>
</div>
<div class="paragraph">
<p>在 <code>else { …​ }</code> 分支中，我们需要处理超时的情况。这可能就像打印出一条超时的语句一样简单，当 silent-cron 之后立即退出时，这可能是可以接受的。但是我们可能将来要做更多的事情，所以我们应该杀死外部程序。而如果程序在发出友好的 <code>kill</code> 信号后没有终止，就应该收到一个 <code>kill(9)</code>，在 UNIX 系统中，这个 <code>kill(9)</code> 会强行终止程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

else { $proc.kill;
    say &#34;Program @cmd[] did not finish after $timeout seconds&#34;;
    sleep 1 if $promise.status ~~ Planned;
    $proc.kill(9);
    await $promise;
    exit 2;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>await $promise</code> 返回承诺的结果；这里是一个 <code>Proc</code> 对象。Proc 内置了一个安全特性，如果命令返回的返回值为非零的退出代码，那么在 void 上下文中计算该对象会抛出一个异常。</p>
</div>
<div class="paragraph">
<p>由于我们在代码中显式处理了非零退出代码，所以我们可以通过将 <code>await</code> 的返回值分配给一个哑变量来抑制这个异常的产生:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $dummy = await $promise</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为我们不需要这个值，所以我们也可以把它分配给一个匿名变量代替:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

$ = await $promise</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_更多关于承诺的信息">6.3. 更多关于承诺的信息</h3>
<div class="paragraph">
<p>如果你在其他语言中处理过并发或并行程序，你可能会遇到线程、锁、mutexes 和其他低级构造。这些东西在 Raku 中也有，但不鼓励直接使用它们。</p>
</div>
<div class="paragraph">
<p>这些低级原语的问题在于它们不能很好地编译。你可以有两个使用线程的库，它们本身工作得很好，但在同一个程序中组合起来就会导致死锁。或者不同的组件可能会单独启动线程，当几个这样的组件在同一个进程中组合在一起时，可能会导致线程太多，内存消耗大。</p>
</div>
<div class="paragraph">
<p>Raku 提供了更高级别的原语。你可以使用 <code>start</code> 来异步地运行代码，而不是催生一个线程，由调度器决定在哪个线程上运行。如果有更多的 <code>start</code> 调用请求线程来调度的事情发生了，那么有些线程就会串行运行。</p>
</div>
<div class="paragraph">
<p>这里有一个非常简单的例子，就是在后台运行计算。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub count-primes(Int $upto) {
    (1..$upto).grep(&amp;is-prime).elems;
}

my $p = start count-primes 10_000;
say $p.status;
await $p;
say $p.result;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它给出如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Planned
1229</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以看到，在启动调用后，主线继续执行，<code>$p</code> 立即有一个值 - 承诺，状态为 <code>Planned</code>。</p>
</div>
<div class="paragraph">
<p>正如我们之前看到的那样，承诺有组合器，<code>anyof</code> 和 <code>allof</code>。你也可以使用 <code>then</code> 方法将动作链接到一个承诺上:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub count-primes(Int $upto) {
    (1..$upto).grep(&amp;is-prime).elems;
}

my $p1 = start count-primes 10_000;
my $p2 = $p1.then({ say .result });
await $p2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在异步执行代码内部抛出异常，那么承诺的状态就会变成 <code>Broken</code>，调用它的 <code>.result</code> 方法重抛出异常。</p>
</div>
<div class="paragraph">
<p>为了演示调度器分配任务，让我们考虑一个小的蒙特卡洛模拟来计算 π 的近似值，蒙特卡洛模拟只是一个程序，用随机数来探索一个可能值的空间，得出一个确定性的输出（图6-1）。</p>
</div>
<div class="paragraph">
<div class="title">在一个正方形中随机放置点时，四分之一圆内的点数与总点数的比值接近 π/4 时</div>
<p>我们生成一对0到1之间的随机数，将其解释为正方形中的点。一个半径为1的四分之一圆的面积为 π/4，因此，如果我们使用足够多的点，那么四分之一圆内随机放置的点与点的总数之比接近 π/4。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub pi-approx($iterations) {
    my $inside = 0;
    for 1..$iterations {
        my $x = 1.rand;
        my $y = 1.rand;
        $inside++ if $x * $x + $y * $y &lt;= 1;
    }
    return ($inside / $iterations) * 4;
}
my @approximations = (1..1000).map({ start pi-approx(80) });
await @approximations;

say @approximations.map({.result}).sum / @approximations;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序异步启动一千次计算，但如果你在运行的时候看一下系统监控工具，你会观察到只有 16 个线程在运行。这个神奇的数字来自于默认的线程调度器，我们可以通过在前面的代码上面提供自己的调度器实例来覆盖它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $*SCHEDULER = ThreadPoolScheduler.new(:max_threads(3));</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于像这种蒙特卡洛仿真这样的 CPU 绑定任务，将线程数大致限制在 CPU 内核的数量（可能是虚拟的）上是个好主意；如果很多线程被卡住等待 I/O，那么更高的线程数可以获得更好的性能。</p>
</div>
</div>
<div class="sect2">
<h3 id="_可能的扩展">6.4. 可能的扩展</h3>
<div class="paragraph">
<p>如果你想玩 silent-cron，可以增加一个重试机制。如果一个命令因为外部依赖（如API或NFS共享）而失败，那么这个外部依赖可能需要时间来恢复。因此，你应该添加一个二次幂或指数型的重试机制；也就是说，重试之间的等待时间应该以二次幂（1，2，4，9，16，16，…​）或指数型（1，2，4，8，16，32，…​）的方式增加。</p>
</div>
</div>
<div class="sect2">
<h3 id="_重构和自动化测试">6.5. 重构和自动化测试</h3>
<div class="paragraph">
<p>在我们在下一章中对 silent-cron 进行更多的扩展之前，是时候重构一下它，并为它写一些测试了。</p>
</div>
<div class="sect3">
<h4 id="_重构">6.5.1. 重构</h4>
<div class="paragraph">
<p>在此简单提醒一下，程序是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

#!/usr/bin/env raku

sub MAIN(*@cmd, :$timeout) {
    my $proc = Proc::Async.new(|@cmd);
    my $collector = Channel.new;
    for $proc.stdout, $proc.stderr -&gt; $supply {
        $supply.tap: { $collector.send($_) }
    }
    my $promise = $proc.start;
    my $waitfor = $promise;
    $waitfor = Promise.anyof(Promise.in($timeout), $promise)
        if $timeout;
    $ = await $waitfor;
    $collector.close;
    my $output = $collector.list.join;
    if !$timeout || $promise.status ~~ Kept {
        my $exitcode = $promise.result.exitcode;
        if $exitcode != 0 {
            say &#34;Program @cmd[] exited with code $exitcode&#34;;
            print &#34;Output:\n&#34;, $output if $output;
        }
        exit $exitcode;
    }
    else {
        $proc.kill;
        say &#34;Program @cmd[] did not finish after $timeout seconds&#34;;
        sleep 1 if $promise.status ~~ Planned;
        $proc.kill(9);
        $ = await $promise;
        exit 2;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里面有执行外部程序超时的逻辑，也有处理两种可能的结果的逻辑。从可测试性和未来扩展的角度来看，将外部程序的执行情况计入子程序中是有意义的。这段代码的结果不是一个单一的值，我们可能感兴趣的是它产生的输出，退出代码，以及是否超时。</p>
</div>
<div class="paragraph">
<p>我们可以写一个子例程，返回一个列表或者是这些值的哈希值，但是在这里我选择写一个小类来代替，新的子例程将返回:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

class ExecutionResult {
    has Int $.exitcode = -1;
    has Str $.output is required;
    has Bool $.timed-out = False;
    method is-success {
        !$.timed-out &amp;&amp; $.exitcode == 0;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们以前见过类，但这个类有一些新的功能。用 <code>.twigil</code> 声明的属性会自动获得一个访问器方法，所以:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

has Int $.exitcode;</code></pre>
</div>
</div>
<div class="paragraph">
<p>大致等价于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

has Int $!exitcode;
method exitcode() { $!exitcode }</code></pre>
</div>
</div>
<div class="paragraph">
<p>它允许类的用户从外部访问属性中的值。作为奖励，你还可以从标准构造函数中初始化它，作为一个命名参数，<code>ExecutionResult.new( exitcode ⇒ 42 )</code>。退出代码并不是一个必须的属性，因为我们无法知道一个已经超时的程序的退出代码。所以我们给它一个默认值，如果属性还没有被初始化，我们就给它一个默认值。</p>
</div>
<div class="paragraph">
<p>输出是一个必填属性，所以我们用 <code>is required</code> 标记为必填属性。这就是一个 trait。trait 是修改其他事物的行为的代码，这里指的是属性的行为。它们会出现在很多地方，例如子程序签名（在参数上复制）、变量声明和类中。如果你试图调用 <code>ExecutionResult.new()</code> 而不指定输出，你会得到这样的错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">The attribute &#39;$!output&#39; is required, but you did not provide a value for it.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_模拟和测试">6.5.2. 模拟和测试</h4>
<div class="paragraph">
<p>现在我们有了一个从假设子例程中返回多个值的方便方法，让我们来看看这个子例程可能是什么样子的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub run-with-timeout(@cmd, :$timeout) {
    my $proc = Proc::Async.new(|@cmd);
    my $collector = Channel.new;
    for $proc.stdout, $proc.stderr -&gt; $supply {
        $supply.tap: { $collector.send($_) }
    }
    my $promise = $proc.start;
    my $waitfor = $promise;
    $waitfor = Promise.anyof(Promise.in($timeout), $promise)
        if $timeout;
    $ = await $waitfor;

    $collector.close;
    my $output = $collector.list.join;

    if !$timeout || $promise.status ~~ Kept {
        say &#34;No timeout&#34;;
        return ExecutionResult.new(
            :$output,
            :exitcode($promise.result.exitcode),
        );
    }
    else {
        $proc.kill;
        sleep 1 if $promise.status ~~ Planned;
        $proc.kill(9);
        $ = await $promise;
        return ExecutionResult.new(
            :$output,
            :timed-out,
        );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Proc::Async<sup class="footnote">[<a id="_footnoteref_36" class="footnote" href="#_footnotedef_36" title="View footnote.">36</a>]</sup> 的用法没有变化，但例程不再是在错误发生时产生输出，而是返回 <code>ExecutionResult</code> 对象。</p>
</div>
<div class="paragraph">
<p>这大大简化了 MAIN 子例程:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

multi sub MAIN(*@cmd, :$timeout) {
    my $result = run-with-timeout(@cmd, :$timeout);
    unless $result.is-success {
        say &#34;Program @cmd[] &#34;,
            $result.timed-out ?? &#34;ran into a timeout&#34;
                              !! &#34;exited with code $result.
                              exitcode()&#34;;

        print &#34;Output:\n&#34;, $result.output if $result.output;
    }
    exit $result.exitcode // 2;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的一个新的语法特征是三元运算符，<code>CONDITION ?? TRUE-BRANCH !! FALSE-BRANCH</code>，你可能会从其他编程语言如 C 或 Perl5 中知道 <code>CONDITION ? TRUE-BRANCH : FALSE-BRANCH</code>。</p>
</div>
<div class="paragraph">
<p>最后，逻辑上的 defined-or 操作符 <code>LEFT // RIGHT</code>， 如果定义了，则返回 LEFT 边，如果没有，则运行 RIGHT 边并返回其值。它的工作原理与 <code>||</code> 和 <code>or</code> 中缀运算符一样，只是这些操作符会检查左边的布尔值，而不是检查它们是否被定义。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，我们区分了定义值和真值。默认情况下，所有的实例都是在布尔语境中，所有类型对象都是 true 和有定义的，而所有类型对象都是 false 和未定义的。</p>
</div>
<div class="paragraph">
<p>几个内置的类型覆盖了它们认为是真的东西。在布尔语境中，等于0的数字会被计算为 False，空字符串和空容器如数组、散列和集合也是如此。</p>
</div>
<div class="paragraph">
<p>另一方面，只有内置的 Failure<sup class="footnote">[<a id="_footnoteref_37" class="footnote" href="#_footnotedef_37" title="View footnote.">37</a>]</sup> 类型才会重写定义性。</p>
</div>
<div class="paragraph">
<p>你可以通过实现一个方法 Bool（应该返回 True 或 False），用定义的方法覆盖自定义类型的真值，用定义的方法覆盖定义性。</p>
</div>
<div class="paragraph">
<p>我们可以通过编写具有定义特性（输出、运行时间、退出代码）的自定义外部命令来开始测试 <code>sub run-with-timeout</code>，但这是相当繁琐的，要想以可靠的、跨平台的方式来做，那是相当麻烦的。因此，我想用一个模拟实现来代替 Proc::Async，并给子例程注入一个方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub run-with-timeout(@cmd, :$timeout, :$executer = Proc::Async) {
    my $proc = $executer.defined ?? $executer !! $executer.new(|@cmd);
    # rest as before</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过查看子例程 run-with-timeout，我们可以快速列出 Proc::Async 实现所需要的方法：<code>stdout</code>、<code>stderr</code>、<code>start</code> 和 <code>kill</code>。<code>stdout</code> 和 <code>stderr</code> 都需要返回一个 Supply.<sup class="footnote">[<a id="_footnoteref_38" class="footnote" href="#_footnotedef_38" title="View footnote.">38</a>]</sup> 最简单的方法就是返回一个只发出一个值的 Supply。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my class Mock::Proc::Async {
    has $.out = &#39;&#39;;
    has $.err = &#39;&#39;;
    method stdout {
        Supply.from-list($.out);
    }
    method stderr {
        Supply.from-list($.err);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Supply.from-list<sup class="footnote">[<a id="_footnoteref_39" class="footnote" href="#_footnotedef_39" title="View footnote.">39</a>]</sup> 返回一个 Supply，它将发出所有传递给它的参数；所以这里只是一个字符串。</p>
</div>
<div class="paragraph">
<p>最简单的 <code>kill</code> 实现，就是什么都不做:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

method kill($?) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>签名中的 <code>$?</code> 是一个没有名字的可选参数（$foo?)</p>
</div>
<div class="paragraph">
<p>只剩下一个方法需要存根：<code>start</code>。它应该是返回一个 Promise，在定义的秒数后，返回一个 Proc 对象或其模拟对象。由于代码只调用 <code>exitcode</code> 方法，所以为它写一个存根很容易:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

has $.exitcode = 0;
has $.execution-time = 1;
method start {
    Promise.in($.execution-time).then({
        (class {
            has $.exitcode;
        }).new(:$.exitcode);
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为我们在其他地方不需要 mock Proc 类，我们甚至不需要给它起个名字。<code>class { …​ }</code> 创建了一个匿名类，对它的 <code>.new</code> 调用会从它中创建一个新对象。</p>
</div>
<div class="paragraph">
<p>如前所述，当在 void 上下文中，或者我们在 Raku 中称其为 sink 上下文时，一个带有非零退出代码的 Proc 会抛出一个异常。我们可以通过扩展匿名类来模拟这种行为。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

class {
    has $.exitcode;
    method sink() {
        die &#34;mock Proc used in sink context&#34;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这些准备工作，我们终于可以写一些测试了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

multi sub MAIN(&#39;test&#39;) {
    use Test;
    my class Mock::Proc::Async {
        has $.exitcode = 0;
        has $.execution-time = 0;
        has $.out = &#39;&#39;;
        has $.err = &#39;&#39;; method kill($?) {}

        method stdout {
            Supply.from-list($.out);
        }
        method stderr {
            Supply.from-list($.err);
        }
        method start {
            Promise.in($.execution-time).then({
                (class {
                    has $.exitcode;
                    method sink() {
                        die &#34;mock Proc used in sink context&#34;;
                    }
                }).new(:$.exitcode);
            });
        }
    }

    # no timeout, success
    my $result = run-with-timeout([],
        timeout =&gt; 2,
        executer =&gt; Mock::Proc::Async.new(
            out =&gt; &#39;mocked output&#39;,
        ),
    );
    isa-ok $result, ExecutionResult;
    is $result.exitcode, 0, &#39;exit code&#39;;
    is $result.output, &#39;mocked output&#39;, &#39;output&#39;;
    ok $result.is-success, &#39;success&#39;;

    # timeout
    $result = run-with-timeout([],
        timeout =&gt; 0.1,
        executer =&gt; Mock::Proc::Async.new(
            execution-time =&gt; 1,
            out =&gt; &#39;mocked output&#39;,
        ),
    );
    isa-ok $result, ExecutionResult;
    is $result.output, &#39;mocked output&#39;, &#39;output&#39;;
    ok $result.timed-out, &#39;timeout reported&#39;;
    nok $result.is-success, &#39;success&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将通过两种情况来运行，一种是配置了超时，但没有使用（因为模拟外部程序先退出），另一种是超时生效。</p>
</div>
</div>
<div class="sect3">
<h4 id="_提高可靠性和测定时间">6.5.3. 提高可靠性和测定时间</h4>
<div class="paragraph">
<p>依靠测试中的计时总是没有吸引力。如果时间太短（或一起太慢），你就有在慢的或重载的机器上出现零星测试失败的风险。如果你使用更保守的测试时间间隔，测试会变得非常慢。</p>
</div>
<div class="paragraph">
<p>有一个模块（不与 Rakudo 一起分发）可以减轻这种痛苦。Test::Scheduler<sup class="footnote">[<a id="_footnoteref_40" class="footnote" href="#_footnotedef_40" title="View footnote.">40</a>]</sup>提供了一个具有虚拟化时间的线程调度器，让你可以这样写测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use Test::Scheduler;
my $*SCHEDULER = Test::Scheduler.new;
my $result = start run-with-timeout([],
    timeout =&gt; 5,
    executer =&gt; Mock::Proc::Async.new(
        execution-time =&gt; 2,
        out =&gt; &#39;mocked output&#39;,
    ),
);
$*SCHEDULER.advance-by(5); $result = $result.result;
isa-ok $result, ExecutionResult; # more tests here</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样安装了一个自定义的调度器，<code>$*SCHEDULER.advance-by(5)</code> 指示它将虚拟时间提前5秒，而不需要等待5秒的实际时间。在写这篇文章的时候（2016年12月）， <code>Test::Scheduler</code> 是一个相当新的模块，有一个 bug，导致第二个测试用例不能这样工作。<sup class="footnote">[<a id="_footnoteref_41" class="footnote" href="#_footnotedef_41" title="View footnote.">41</a>]</sup></p>
</div>
</div>
<div class="sect3">
<h4 id="_安装模块">6.5.4. 安装模块</h4>
<div class="paragraph">
<p>如果你想试用 <code>Test::Scheduler</code>，你需要先安装它。如果你运行 Rakudo Star，它已经为你提供了 zef 模块安装程序。你可以用它来下载并安装这个模块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ zef install Test::Scheduler</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你没有可用的 zef，可以下载，驱动并使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ git clone https://github.com/ugexe/zef.git
$ cd zef
$ raku -Ilib bin/zef install.
$ zef install Test::Scheduler</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_6">6.6. 总结</h3>
<div class="paragraph">
<p>我们已经看到了一个运行外部程序的异步 API，以及如何使用 Promises 来实现超时。我们还讨论了如何通过调度器将承诺分配给线程，让你可以启动任意数量的承诺，而不会让计算机超载。</p>
</div>
<div class="paragraph">
<p>在测试中，我们看到了属性与访问器、三元操作符和匿名类。对线程代码的测试，以及第三方模块的帮助方式也进行了讨论。最后，我们对模块安装程序zef有了一个非常小的窥视。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_有状态的_silent_cron">7. 有状态的 Silent Cron</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在上一章中，我们看了一下 <code>silent-cron</code>，它是一个包裹外部程序的封装器，可以在外部程序退出状态为零的情况下使其静音。但为了使其真正实用，它还应该对偶尔发生的故障进行静音。</p>
</div>
<div class="paragraph">
<p>外部 API 失败，网络拥塞，以及其他事情的发生会使作业无法成功，所以某种重试机制是可取的。如果是 cron 作业，cron 已经负责定期重试作业，所以 <code>silent-cron</code> 应该只是抑制偶尔的错误。另一方面，如果一个作业持续失败，这通常是管理员或开发人员应该研究的事情，所以这是一个值得报告的问题。</p>
</div>
<div class="paragraph">
<p>为了实现这个功能，<code>silent-cron</code> 需要在独立运行之间存储持久状态。它需要记录当前运行的结果，然后决定故障历史记录是否符合 &#34;偶然性&#34;。</p>
</div>
<div class="sect2">
<h3 id="_持久化存储">7.1. 持久化存储</h3>
<div class="paragraph">
<p>存储后端需要写入和检索结构化数据，并通过锁定保护状态文件的并发访问。对于这样的存储后端来说，一个很好的库是 SQLite，<sup class="footnote">[<a id="_footnoteref_42" class="footnote" href="#_footnotedef_42" title="View footnote.">42</a>]</sup>它是一个零维护的 SQL 引擎，以 C 语言库的形式提供。它是公共领域的软件，在大多数主流的浏览器、操作系统，甚至一些飞机上<sup class="footnote">[<a id="_footnoteref_43" class="footnote" href="#_footnotedef_43" title="View footnote.">43</a>]</sup>都有使用。</p>
</div>
<div class="paragraph">
<p>Raku 通过 DBIish<sup class="footnote">[<a id="_footnoteref_44" class="footnote" href="#_footnotedef_44" title="View footnote.">44</a>]</sup> 提供了 SQLite 的功能，它是一个通用的数据库接口，带有 SQLite、MySQL、PostgreSQL 和 Oracle DB 的后端驱动。要使用它，首先确保 SQLite3 已经安装好，包括头文件。例如，在基于 Debian 的 Linux 系统中，你可以通过 <code>apt-get install libsqlite3-dev</code> 来实现。如果你使用的是 Rakudo Star 发行版，DBIish 已经可用。如果不是，你可以使用其中一个模块安装程序来获取并安装它：<code>zef install DBIish</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use DBIish;
my $dbh = DBIish.connect(&#39;SQLite&#39;, :database(&#39;database-file.sqlite3&#39;));</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用 DBIish 的 SQLite 后端，首先必须通过选择后端并提供连接信息来创建数据库句柄。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

$dbh.do(&#39;INSERT INTO player (name) VALUES ?&#39;, &#39;John&#39;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>SQL中的 <code>?</code> 是一个占位符，作为独立的参数传递给 <code>do</code> 方法的带外参数，这样可以避免 SQL 注入漏洞等潜在的错误。</p>
</div>
<div class="paragraph">
<p>查询的工作方式往往是先准备一个语句，返回一个语句句柄。你可以一次或多次执行一条语句，每次执行调用后都可以检索结果行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $sth = $dbh.prepare(&#39;SELECT id FROM player WHERE name = ?&#39;);
my %ids;
for &lt;John Jack&gt; -&gt; $name {
    $sth.execute($name);
    %ids{ $name } = $sth.row[0];
}
$sth.finish;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_开发存储后端">7.2. 开发存储后端</h3>
<div class="paragraph">
<p>我们不应该把所有的存储处理代码都塞到子例程 MAIN 中，而是应该仔细考虑为存储后端创建一个有用的 API。起初，我们只需要两块功能：插入一个作业执行的结果，以及检索最近的结果。</p>
</div>
<div class="paragraph">
<p>因为 silent-cron 可以用来守护同一台机器上的多个 cron 作业，所以我们可能需要一些东西来区分不同的作业，以便其中一个成功的作业不会阻止一个不断失败的作业报错。为此，我们引入了一个作业名称，它可以默认为正在执行的命令（包括参数），但可以在命令行中明确设置。</p>
</div>
<div class="paragraph">
<p>存储后端的 API 可以看成是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $repo = ExecutionResultRepository.new(
    jobname =&gt; &#39;refresh cache&#39;,
    statefile =&gt; &#39;silent-cron.sqlite3&#39;,
);
$repo.insert($result);
my @last-results = $repo.tail(5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个 API 完全不是 SQLite 后端特有的，一个使用纯文本文件的存储后端也可以有完全相同的 API。</p>
</div>
<div class="paragraph">
<p>让我们来实现这个 API。首先我们需要类和两个属性，这两个属性在前面的使用示例中应该很明显。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

class ExecutionResultRepository {
    has $.jobname is required;
    has $.statefile is required;
    # ... more code</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了实现 <code>insert</code> 方法，我们需要连接到数据库并创建相关的表，如果表还不存在的话，那么我们需要连接到数据库并创建相关的表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

has $!db; method !db() {
    return $!db if $!db;
    $!db = DBIish.connect(&#39;SQLite&#39;, :database($.statefile));
    self!create-schema();
    return $!db;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码使用一个私有属性 <code>$!db</code> 来缓存数据库句柄，如果还不存在，则使用一个私有方法 <code>!db</code> 来创建句柄。</p>
</div>
<div class="paragraph">
<p>私有方法的声明与普通方法一样，只是名称以感叹号开始。要调用一个方法，用方法调用点代替感叹号；换句话说，用 <code>self!db()</code> 代替 <code>self.db()</code>。</p>
</div>
<div class="paragraph">
<p><code>!db</code> 方法还调用下一个私有方法，即 <code>!create-schema</code>，它创建了存储表和一些索引。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

constant $table = &#39;job_execution&#39;;
method !create-schema() {
    $!db.do(qq:to/SCHEMA/);
        CREATE TABLE IF NOT EXISTS $table (
            id          INTEGER PRIMARY KEY,
            jobname     VARCHAR NOT NULL,
            exitcode    INTEGER NOT NULL,
            timed_out   INTEGER NOT NULL,
            output      VARCHAR NOT NULL,
            executed    TIMESTAMP NOT NULL DEFAULT (DATETIME(&#39;NOW&#39;))
        );

    SCHEMA
    $!db.do(qq:to/INDEX/);
        CREATE INDEX IF NOT EXISTS {$table}_jobname_exitcode ON
        $table ( jobname, exitcode );
    INDEX
    $!db.do(qq:to/INDEX/);
        CREATE INDEX IF NOT EXISTS {$table}_jobname_executed ON
        $table ( jobname, executed );
    INDEX
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>多行字符串字符最好用 heredoc<sup class="footnote">[<a id="_footnoteref_45" class="footnote" href="#_footnotedef_45" title="View footnote.">45</a>]</sup>语法来写。  <code>qq:to/DELIMITER/</code> 告诉 Raku 要完成对当前行的解析，这样你仍然可以关闭方法调用的小括号，并添加语句结束分号。下一行开始字符串字面量，一直到 Raku 在一行上找到分界符为止。字符串字段的每一行的前导空格都会被剥去，缩进的分界符越多越好。</p>
</div>
<div class="paragraph">
<p>因此:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

print q:to/EOS/;
    Not indented
        Indented four spaces
    EOS</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Not indented
    Indented four spaces</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们有了一个工作的数据库连接，知道了数据库表的存在，插入一条新记录就变得简单了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

method insert(ExecutionResult $r) {
    self!db.do(qq:to/INSERT/, $.jobname, $r.exitcode, $r.timed-out, $r.output);
        INSERT INTO $table (jobname, exitcode, timed_out, output)
        VALUES(?, ?, ?, ?)
    INSERT
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>选择最近的记录比较麻烦，部分原因是我们需要将表的行转换为对象。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

method tail(Int $count) {
    my $sth = self!db.prepare(qq:to/SELECT/);
        SELECT exitcode, timed_out, output
          FROM $table
          WHERE jobname = ?
          ORDER BY executed DESC
          LIMIT $count
    SELECT
    $sth.execute($.jobname);
    $sth.allrows(:array-of-hash).map: -&gt; %h {
        ExecutionResult.new(
            exitcode  =&gt; %h&lt;exitcode&gt;,
            timed-out =&gt; ?%h&lt;timed_out&gt;,
            output    =&gt; %h&lt;output&gt;,
        );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>尾部方法中的最后一条语句值得注意一下。<code>$sth.allrows(:array-of-hash)</code> 将数据库中的记录生成为一个散列值列表。这个列表是惰性的，也就是说，它是按需生成的。懒人列表是一个非常方便的功能，因为它允许你用相同的 API 使用迭代器和列表。例如，当读取文件中的 <code>lines</code> 时，你可以写 <code>$handle.lines → $line { …​ }</code>，行方法不需要将整个文件加载到内存中，而是可以在访问时读取一行。</p>
</div>
<div class="paragraph">
<p><code>$sth.allrows(…​)</code> 是惰性的，后面的 <code>.map</code> 调用也是惰性的，<code>map</code> 通过调用传递给它的代码对象来变换一个个元素。而这也是懒惰地完成的。所以 SQLite 只有在实际访问结果列表中的元素时，才会从数据库文件中检索行。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用存储后端">7.3. 使用存储后端</h3>
<div class="paragraph">
<p>有了存储 API，就该用了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

multi sub MAIN(*@cmd, :$timeout, :$jobname is copy,
               :$statefile=&#39;silent-cron.sqlite3&#39;, Int :$tries = 3) {
    $jobname //= @cmd.Str;
    my $result = run-with-timeout(@cmd, :$timeout);
    my $repo = ExecutionResultRepository.new(:$jobname, :$statefile);
    $repo.insert($result);

    my @runs = $repo.tail($tries);

    unless $result.is-success or @runs.grep({.is-success}) {
        say &#34;The last @runs.elems() runs of @cmd[] all failed, the last execution &#34;,
        $result.timed-out ?? &#34;ran into a timeout&#34;
                          !! &#34;exited with code $result.exitcode()&#34;;

        print &#34;Output:\n&#34;, $result.output if $result.output;
    }
    exit $result.exitcode // 2;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，一个作业如果连续成功几次，然后连续失败两次，就不会产生任何错误输出；只有连续第三次执行失败，才会产生输出。你可以在命令行中用 <code>--tries=5</code> 来覆盖。</p>
</div>
<div class="paragraph">
<p>MAIN 子例程使用构造 <code>$var //= EXPR</code>。 <code>//</code> 代表 <strong>defined-OR,</strong>，所以如果有定义的值，它会返回左侧的值。否则，它计算并返回 EXPR 的值。结合赋值运算符，只有在变量未定义的情况下，它才会对右边的值进行计算，然后将表达式的值存储在变量中。这是一个确保变量得到一个值的方便方法，甚至可以说是写缓存的一个简短方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_扩展空间">7.4. 扩展空间</h3>
<div class="paragraph">
<p>一个系统管理员如果要调查一个 cron 作业失败的原因，可能会对该作业的历史记录感兴趣。你可以实现一个命令，列出最后的作业运行情况、成功或失败、退出代码，或者可能是运行时间等等。</p>
</div>
<div class="paragraph">
<p>或者你可以研究一个不同的后端。如果你想把状态存储在 JSON 文件而不是 SQLite 中呢？或者两者都启用呢？(提示：你可以使用JSON::Tiny<sup class="footnote">[<a id="_footnoteref_46" class="footnote" href="#_footnotedef_46" title="View footnote.">46</a>]</sup>或JSON::Fast<sup class="footnote">[<a id="_footnoteref_47" class="footnote" href="#_footnotedef_47" title="View footnote.">47</a>]</sup>模块)。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_7">7.5. 总结</h3>
<div class="paragraph">
<p>我们已经讨论过 DBIish，这是一个具有可插拔后端的数据库 API，并探讨了用它和 SQLite 来存储持久化数据。在这个过程中，我们还接触到了惰性列表和一种新形式的字符串字库，叫做 heredocs。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_回顾_raku_基础知识">8. 回顾 Raku 基础知识</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在前几章中，我们讨论了一些例子与 Perl 6 的机理交错的例子，这些例子的作用。在这里，我想把我们到目前为止所接触到的 Perl 6 的知识进行总结和深化，脱离了原来的例子，在这里，我想对这些知识进行总结和深化。</p>
</div>
<div class="sect2">
<h3 id="_变量和作用域">8.1. 变量和作用域</h3>
<div class="paragraph">
<p>在 Perl 6 中，变量名由一个符号，<code>$</code>、<code>@</code>、<code>%</code> 或 <code>&amp;</code> 组成，后面是标识符。sigil 意味着一个类型约束，其中 <code>$</code> 是最一般的类型约束。(默认没有限制)，<code>@</code> 代表数组，<code>%</code> 代表散列(关联数组/映射)，<code>&amp;</code> 代表代码对象。</p>
</div>
<div class="paragraph">
<p>标识符可以包含 <code>-</code> 和 <code>&#39;</code> 字符，只要后面的字符是字母就可以。标识符必须以字母或下划线开头。</p>
</div>
<div class="paragraph">
<p>用 <code>my</code> 声明的子程序和变量是词法作用域的。它们从声明的点到当前 <code>{}</code>-闭合块儿（或当前文件，如果声明在 block 之外）的块的结尾都是可见的。子例程参数在子例程的签名和块中是可见的。</p>
</div>
<div class="paragraph">
<p>在 sigil 和标识符之间的可选的 twigil 可以影响作用域。twigil 标志着一个动态作用域的变量；因此，查找是在当前调用栈中进行的。<code>!</code> 标志着属性，也就是说，每个实例中的变量被附加到一个对象上。</p>
</div>
</div>
<div class="sect2">
<h3 id="_子例程">8.2. 子例程</h3>
<div class="paragraph">
<p>子程序，简称 <code>sub</code>，是一段有自己的作用域的代码，通常也有一个名字。它有一个签名，指定你在调用它的时候要传入什么样的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub chunks(Str $s, Int $chars) {
#         ^^^^^^^^^^^^^^^^^^^^ signature
#   ^^^^^^ name
    gather for 0 .. $s.chars / $chars - 1 -&gt; $idx {
        take substr($s, $idx * $chars, $chars);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>签名中使用的变量被称为参数，而我们调用你在参数中传递的值。</p>
</div>
<div class="paragraph">
<p>如果要引用一个子程序而不调用它，可以在它前面加上一个句号(<code>&amp;</code>)，比如这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

say &amp;chunks.name; # Output: chunks</code></pre>
</div>
</div>
<div class="paragraph">
<p>要调用它，只需使用它的名字，后面是参数列表，参数可以放在一对圆括号中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

say chunks &#39;abcd&#39;, 2; # Output: (ab cd)
say chunks(&#39;abcd&#39;, 2); # Output: (ab cd)</code></pre>
</div>
</div>
<div class="paragraph">
<p>只有在其他构造会干扰子例程调用的情况下，你才需要括号。因此，如果你打算这样写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

say chunks(join(&#39;x&#39;, &#39;ab&#39;, &#39;c&#39;), 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>而省略了内侧的括号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

say chunks(join &#39;x&#39;, &#39;ab&#39;, &#39;c&#39;, 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么所有的参数都会进入 <code>join</code> 函数，只留下一个参数给 <code>chunks</code> 函数。另一方面，省略了外面的一对括号，写成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

say chunks join(&#39;x&#39;, &#39;ab&#39;, &#39;c&#39;), 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为这里没有任何歧义。</p>
</div>
<div class="paragraph">
<p>一个值得注意的情况是，如果你调用一个没有参数的子例程作为 <code>if</code> 条件或 <code>for</code> 循环（或类似的构造）的块，你必须包含括号，因为否则这个块会被解析为函数的参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub random-choice() {
    Bool.pick;
}

# right way:
if random-choice() {
    say &#39;You were lucky.&#39;;
}

# wrong way:
if random-choice {
    say &#39;You were lucky.&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你碰巧犯了这个错误，Raku 编译器会尽力去检测它。在前面的例子中，它打印出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Function &#39;random-choice&#39; needs parens to avoid gobbling block</code></pre>
</div>
</div>
<div class="paragraph">
<p>而当它试图解析 <code>if-statement</code> 的块时，它没有找到一个。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Missing block (apparently claimed by &#39;random-choice&#39;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你有一个叫 MAIN 的子程序时，Raku 会使用它的签名来解析命令行参数，并将这些命令行参数传递给 MAIN。</p>
</div>
<div class="paragraph">
<p><strong>multi</strong> 子例程是指几个名字相同但签名不同的子程序。编译器在运行时根据参数和参数之间的最佳匹配度来决定调用哪个子程序。</p>
</div>
</div>
<div class="sect2">
<h3 id="_类和对象">8.3. 类和对象</h3>
<div class="paragraph">
<p>类声明遵循与子程序声明相同的语法模式：关键字 <code>class</code>，后面是名称，后面是花括号中的主体:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

class OutputCapture {
    has @!lines;
    method print(\s) {
        @!lines.push(s);
    }
    method captured() {
        @!lines.join;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，类型名称被覆盖到当前的命名空间；但是，你可以通过在 <code>class</code> 前面添加一个 <code>my</code> 来使其变成词法作用域的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my class OutputCapture { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建一个新的实例一般通过在类型对象上调用 <code>new</code> 方法来实现。<code>new</code> 方法继承自所有类型都会得到的隐式父类 <code>Any</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $c = OutputCapture.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个实例的状态都存储在属性中，用 <code>has</code> 关键字声明，如前面的 <code>has @!</code> 行所示。属性始终是私有的，正如 <code>!</code> twigil 所表示的那样。如果你在声明中使用点 <code>.twigil</code>，你就同时拥有了私有属性 <code>@!line</code> 和只读的公共访问器方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my class OutputCapture {
    has @.lines;
    method print(\s) {
         # the private name with ! still works
         @!lines.push(s);
    }
    method captured() {
        @!lines.join;
    }
}
my $c = OutputCapture.new;
$c.print(&#39;42&#39;);
# use the `lines` accessor method:
say $c.lines; # Output: [42]</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你用点 twigil 声明属性时，你也可以通过命名参数从构造函数中初始化属性，如 <code>OutputCapture.new( lines ⇒ [42] )</code>。</p>
</div>
<div class="paragraph">
<p>私有方法以 <code>!</code> 开始，只能在类体内部以 <code>self!private-method</code> 的形式调用。</p>
</div>
<div class="paragraph">
<p>方法基本上只是子程序，有两个区别。第一个区别是, 它们会得到一个名为 <code>self</code> 的隐式参数，其中包含方法被调用的对象（我们称之为调用者）。二是如果调用一个子程序，编译器会在当前的词法作用域以及外部作用域中搜索这个子程序。另一方面，方法调用只在对象的类和超类中查找。</p>
</div>
<div class="paragraph">
<p>子程序的查找可以在编译时进行，因为词法作用域在运行时是不可更改的，所以编译器对所有的词法符号都有知识。但是，即使在类型约束的情况下，编译器也无法知道对象的类型是否可能是类型约束的子类型，这意味着方法查找必须推迟到运行时进行。</p>
</div>
</div>
<div class="sect2">
<h3 id="_并发">8.4. 并发</h3>
<div class="paragraph">
<p>Raku 为并发和并行执行提供了高级原语。我们鼓励你用 <code>start</code> 来运行计算，而不是显式地催生新的线程，它返回一个 Promise。<sup class="footnote">[<a id="_footnoteref_48" class="footnote" href="#_footnotedef_48" title="View footnote.">48</a>]</sup> 这是一个对象，它承诺未来的计算会产生一个结果。因此，状态可以是 Planned, Kept, 或 Broken。你可以将承诺串联起来，将它们组合起来，然后等待它们。</p>
</div>
<div class="paragraph">
<p>在后台，一个调度器将这些计算分配给操作系统级线程。默认的调度器是一个线程池调度器，对可使用的线程数量有一个上限。</p>
</div>
<div class="paragraph">
<p>并行计算之间的通信应该通过线程安全的数据结构来进行。其中最重要的是 Channel<sup class="footnote">[<a id="_footnoteref_49" class="footnote" href="#_footnotedef_49" title="View footnote.">49</a>]</sup>（线程安全队列）和 Supply<sup class="footnote">[<a id="_footnoteref_50" class="footnote" href="#_footnotedef_50" title="View footnote.">50</a>]</sup>（Raku 对观察者模式<sup class="footnote">[<a id="_footnoteref_51" class="footnote" href="#_footnotedef_51" title="View footnote.">51</a>]</sup>的实现）。Supply 是非常强大的，因为你可以用诸如 <code>map</code>、<code>grep</code>、<code>throttle</code> 或 <code>delayed</code>，并使用它们的 actor 语义<sup class="footnote">[<a id="_footnoteref_52" class="footnote" href="#_footnotedef_52" title="View footnote.">52</a>]</sup>来确保消费者一次只在一个线程中运行。</p>
</div>
</div>
<div class="sect2">
<h3 id="_展望">8.5. 展望</h3>
<div class="paragraph">
<p>当你了解了本章讨论的主题，并对内置的类型有了一定的了解，你应该已经熟悉了 Raku 的基础知识，并能够编写自己的程序了。</p>
</div>
<div class="paragraph">
<p>接下来，我们将探讨 Raku 的一个优点：通过 regexes 和 grammar 来解析。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_使用正则表达式和_grammar_解析_ini_文件">9. 使用正则表达式和 Grammar 解析 INI 文件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>你之前可能已经见过 <code>.ini</code> 文件; 它们在微软 Windows 平台上很常见, 但是在其它地方也有发现, 例如 ODBC 配置文件, Ansible 的库文件,<sup class="footnote">[<a id="_footnoteref_53" class="footnote" href="#_footnotedef_53" title="View footnote.">53</a>]</sup> 等等。</p>
</div>
<div class="paragraph">
<p>INI 文件看起来长这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">key1=value2

[section1]
key2=value2
key3 = with spaces
; comment lines start with a semicolon, and are ; ignored by the parser

[section2]
more=stuff</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 提供了用于解析的正则表达式，以及用于结构化和重用正则表达式的 grammar。</p>
</div>
<div class="paragraph">
<p>你可以使用 Config::INI<sup class="footnote">[<a id="_footnoteref_54" class="footnote" href="#_footnotedef_54" title="View footnote.">54</a>]</sup> 模块（在使用 <code>zef install Config::INI</code> 安装之后）来解析 INI 文件，就像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use Config::INI;
my %hash = Config::INI::parse($ini_string);</code></pre>
</div>
</div>
<div class="paragraph">
<p>它在底层使用了正则表达式和 grammar。这里我们将探讨如何编写自己的 INI 解析器。</p>
</div>
<div class="sect2">
<h3 id="_正则表达式基础">9.1. 正则表达式基础</h3>
<div class="paragraph">
<p>正则表达式是一段代码，它作为具有共同结构的字符串的模式。它源于计算机科学中的正则表达式的概念<sup class="footnote">[<a id="_footnoteref_55" class="footnote" href="#_footnotedef_55" title="View footnote.">55</a>]</sup>，但经过调整，提供了比纯粹的正则表达式所允许的更多的构造，并扩展了一些使其更容易使用的特性。</p>
</div>
<div class="paragraph">
<p>我们将使用命名的正则表达式来匹配原语，然后使用调用这些命名的正则表达式来构建 INI 文件的解析器。由于 INI 文件没有公认的、正式的语法，所以我们必须边走边写。</p>
</div>
<div class="paragraph">
<p>让我们从解析值对开始，比如 <code>key1=value1</code>。首先，让我们只考虑 <code>key</code>。它可能包含字母、数字和下划线 <code>_</code>。有一个快捷方式来匹配这样的字符，<code>\w</code>，通过附加一个 <code>+</code> 字符来匹配一个或多个字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use v6;

my regex key { \w+ }

multi sub MAIN(&#39;test&#39;) {
    use Test;
    ok &#39;abc&#39;     ~~ /^ &lt;key&gt; $/, &#39;&lt;key&gt; matches a simple identifier&#39;;
    ok  &#39;[abc]&#39; !~~ /^ &lt;key&gt; $/, &#39;&lt;key&gt; does not match a  section header&#39;;
    done-testing;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>my regex key { \w+ }</code> 声明一个词法上(<code>my</code>)作用域化的正则表达式，称为 <code>key</code>，它可以匹配一个或多个单词字符。</p>
</div>
<div class="paragraph">
<p>在编程语言中，支持所谓的 Perl 兼容正则表达式(PCRE)的传统由来已久。许多程序设计语言都支持一些偏离 PCRE 的元素，包括 Perl 本身，但大多数程序设计语言中都保留了一些常见的语法元素。Raku 仍然支持其中的一些元素，但在其他方面却有很大的偏差。</p>
</div>
<div class="paragraph">
<p>这里的 <code>\w+</code> 和 PCRE 中的一样，但忽略了周围的空格。在测试例程中，<code>&#39;abc&#39; ~~ /^ &lt;key&gt; $/</code> 中的斜线分隔了一个匿名的正则表达式。在这个正则表达式中，<code>^</code> 和 <code>$</code> 分别代表匹配字符串的开头和结尾，这在 PCRE 中很熟悉。然而，与 PCRE 不同的是， <code>&lt;key&gt;</code> 子规则调用了前面的命名正则表达式 <code>key</code>。这是 Raku 的一个扩展。在 PCRE 中，正则表达式中的 <code>&lt;</code> 匹配的是字面的  <code>&lt;</code>，在 Raku 中，它引入了一个子规则调用。</p>
</div>
<div class="paragraph">
<p>一般来说，所有的非单词字符都是为&#34;特殊&#34;语法所保留的，你必须用引号或反斜线才能得到字面意思。例如，在正则表达式中的 <code>\&lt;</code> 或 <code>&#39;&lt;&#39;</code> 与小于号匹配。引号可以应用于一个以上的字符，因此，正则表达式中的 <code>&#39;a+b&#39;</code> 匹配一个 a，后面是加号 <code>+</code>，再后面是 b。单词字符（字母、数字和下划线）总是按字面意思匹配。</p>
</div>
<div class="sect3">
<h4 id="_字符类">9.1.1. 字符类</h4>
<div class="paragraph">
<p>除了字面值外，字符类也是正则表达式常用的构建块。有许多预定义的字符类，其形式为反斜线，后面是一个小写字母; 例如，<code>\d</code> 匹配一个数字。它的反义词使用大写字母，所以 <code>\D</code> 匹配任何不是数字的字符。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">否定</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个数字</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\W</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个单词字符(字母,数字,下划线)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\S</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空格,空白,换行,等等</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\h</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\H</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">水平空白</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\v</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\V</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">垂直空白</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\n</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">逻辑换行(回车,换行)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意字符</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>你还可以通过枚举字符或字符范围来构建自己的字符类:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">例子</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">枚举</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;[abc]&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a, b 或 c</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">否定</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">←[abc]&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">除了 a, b 或 c 的任何东西</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">范围</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;[a..c]&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a, b 或 c</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_量词">9.1.2. 量词</h4>
<div class="paragraph">
<p>只匹配一个重复的东西很无聊，所以正则表达式提供了量词。 量词表示前一个正则表达式必须匹配的频率。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">量词</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配多少个字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..Inf</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1..Inf</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">** 1..5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1..5</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>所以, 对于 <code>ab+</code> 这个例子来说, 它匹配字符串 ab, abb, aab, 但是不匹配 a。</p>
</div>
</div>
<div class="sect3">
<h4 id="_备选分支">9.1.3. 备选分支</h4>
<div class="paragraph">
<p>可选的选项用竖条 <code>|</code> 分隔。例如， <code>\d+ | x</code> 匹配的是一个或多个数字的序列，或者是字符 <code>x</code>。</p>
</div>
<div class="paragraph">
<p>如果一个替代方案有多个路径匹配，Raku 会选择最长的匹配。如果不需要这种行为，那么 <code>||</code> 会取第一个匹配的备选路径。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_解析_ini_原语">9.2. 解析 INI 原语</h3>
<div class="paragraph">
<p>再回到 INI 解析，我们必须思考一个值里面允许使用哪些字符。列出允许的字符似乎是徒劳的，因为我们很可能会忘记一些字符。相反，我们应该思考什么是不允许在值中出现的。换行符当然不允许，因为它们会引入下一个键/值对或章节标题。分号也不允许，因为它们会引入注释。</p>
</div>
<div class="paragraph">
<p>我们可以将这种排除法表述为否定字符类。<code>←[ \n ; ]&gt;</code> 匹配任何一个既不是换行符也不是分号的字符。注意，在字符类中，几乎所有的字符都会失去其特殊意义。只有反斜线、空格、两个小点和闭合括号才代表着除它们之外的任何东西。在字符类的内部和外部都是如此， <code>\n</code> 匹配一个换行字符，而 <code>\s</code> 匹配一个空格。大写字母与此相反，因此，例如，<code>\S</code> 匹配任何一个非空格字符。</p>
</div>
<div class="paragraph">
<p>这让我们看到了一个在 INI 文件中匹配一个值的正则表达式版本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my regex value { &lt;-[ \n ; ]&gt;+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个正则表达式有一个问题：它还匹配了前导和尾部空格，我们不想将其视为值的一部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my regex value { &lt;-[ \n ; ]&gt;+ }
if &#39; abc &#39; ~~ /&lt;value&gt;/ {
    say &#34;matched &#39;$/&#39;&#34;; # matched &#39; abc &#39;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果把 Raku 正则表达式限制在计算机科学意义上的普通语言中，我们就得这样做:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my regex value {
    # match a first non-whitespace character
    &lt;-[ \s ; ]&gt;
    [
        # then arbitrarily many that can contain whitespace
        &lt;-[ \n ; ]&gt;*
        # ... terminated by one non-whitespace
        &lt;-[ \s ; ]&gt;
    ]?  # and make it optional, in case the value is only
        # only one non-whitespace character
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在你知道为什么人们在提出用正则表达式来解决问题时，会以&#34;现在你有两个问题了&#34;<sup class="footnote">[<a id="_footnoteref_56" class="footnote" href="#_footnotedef_56" title="View footnote.">56</a>]</sup>来回应。一个更简单的解决方案是先匹配一个引入的值，然后引入一个约束条件，即第一个或最后一个字符都不能是空格:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my regex value { &lt;!before \s&gt; &lt;-[ \n ; ]&gt;+ &lt;!after \s&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>连带着测试:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

is &#39; abc &#39; ~~ /&lt;value&gt;/, &#39;abc&#39;, &#39;&lt;value&gt; does not match leading or trailing whitespace&#39;;
is &#39; a&#39;    ~~ /&lt;value&gt;/, &#39;a&#39;,   &#39;&lt;value&gt; matches single non-whitespace too&#39;;
ok &#34;a\nb&#34; !~~ /^ &lt;value&gt; $/,    &#39;&lt;value&gt; does not match \n&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&lt;!before regex&gt;</code> 是一个否定的向前查看，也就是说，下面的文本必须不匹配 <code>regex</code>，并且在匹配的过程中不消耗文本。<code>&lt;!after regex&gt;</code> 是否定的向后查看，它试图匹配已经匹配过的文本，而且必须不成功，整个匹配才会成功。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，当然还有另一种方法可以解决这个问题。如果你把要求表述为&#34;值不能包含换行或分号，并且以非空格开头，以非空格结尾&#34;，那么很明显，如果我们在正则表达式中使用 AND 运算符，这个问题就很容易解决了。而事实就是如此:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my regex value { &lt;-[ \n ; ]&gt;+ &amp; \S.* &amp; .*\S }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&amp;</code> 操作符将两个或更多的小的正则表达式定界，这些表达式必须成功地匹配到同一个字符串，才能使整个匹配成功。<code>\S.<strong></strong></code><strong> 可以匹配任何以非空格字符(<code>\S</code>)开头的字符串，后面是任意字符(<code>.</code>)，任意次数的 <code></code></strong>。同样的，<code>.*\S</code> 匹配任何以非空格字符结尾的字符串。</p>
</div>
<div class="paragraph">
<p>谁会想到匹配一个配置文件中的值这么简单的东西会如此复杂呢？幸运的是，现在我们知道了如何单独匹配键/值对就简单多了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my regex pair { &lt;key&gt; &#39;=&#39; &lt;value&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>而且这个方法很好用，只要等号周围没有空格就可以了。如果有，我们要分别匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my regex pair { &lt;key&gt; \h* &#39;=&#39; \h* &lt;value&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>\h</code> 匹配的是一个水平的空白，也就是说，一个空白，一个制表符，或者其他 Unicode 为我们准备的类似于空格的东西（比如说，也是非分隔符），但不是换行。</p>
</div>
<div class="paragraph">
<p>说到换行，在 <code>regex pair</code> 的结尾处匹配一个换行是个好主意，既然我们忽略了空行，那就多匹配几个吧。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my regex pair { &lt;key&gt; \h* &#39;=&#39; \h* &lt;value&gt; \n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>是时候写一些测试了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

ok &#34;key=value\n&#34; ~~ /&lt;pair&gt;/, &#39;simple pair&#39;;
ok &#34;key = value\n\n&#34; ~~ /&lt;pair&gt;/, &#39;pair with blanks&#39;;
ok &#34;key\n= value\n&#34; !~~ /&lt;pair&gt;/, &#39;pair with newline before assignment&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>节标题是一个方括号中的字符串，所以字符串本身不应该包含括号或换行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my regex header { &#39;[&#39; &lt;-[ \[ \] \n ]&gt;+ &#39;]&#39; \n+ }
# and in multi sub MAIN(&#39;test&#39;):
ok &#34;[abc]\n&#34;    ~~ /^ &lt;header&gt; $/, &#39;simple header&#39;;
ok &#34;[a c]\n&#34;    ~~ /^ &lt;header&gt; $/, &#39;header with spaces&#39;;
ok &#34;[a [b]]\n&#34; !~~ /^ &lt;header&gt; $/, &#39;cannot nest headers&#39;;
ok &#34;[a\nb]\n&#34;  !~~ /^ &lt;header&gt; $/, &#39;No newlines inside headers&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后剩下的原语是注释:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my regex comment { &#39;;&#39; \N*\n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>\N</code> 匹配任何不是换行的字符，所以注释只是一个分号，然后是任何东西，直到行尾。</p>
</div>
</div>
<div class="sect2">
<h3 id="_把东西组装起来">9.3. 把东西组装起来</h3>
<div class="paragraph">
<p>INI 文件的 <strong>section</strong> 是标题，后跟一些键/值对或注释行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my regex section {
    &lt;header&gt;
    [ &lt;pair&gt; | &lt;comment&gt; ]*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>[…​]</code> 对正则表达式的一部分进行分组，这样，后面的量词 <code>*</code> 应用于整个组，而不仅仅是最后一项。</p>
</div>
<div class="paragraph">
<p>整个 INI 文件可能由一些初始键/值对或注释组成，然后是一些 section:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my regex inifile {
    [ &lt;pair&gt; | &lt;comment&gt; ]*
    &lt;section&gt;*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>热心的读者已经注意到，正则表达式中的 <code>[ &lt;pair&gt; | &lt;comment&gt; ]*</code> 部分已经用过两次了，所以最好把它提取成独立的正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my regex block   { [ &lt;pair&gt; | &lt;comment&gt; ]* }
my regex section { &lt;header&gt; &lt;block&gt; }
my regex inifile { &lt;block&gt; &lt;section&gt;* }</code></pre>
</div>
</div>
<div class="paragraph">
<p>是时候进行“终极”测试了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $ini = q:to/EOI/;
key1=value2

[section1]
key2=value2
key3 = with spaces

; comment lines start with a semicolon, and are
; ignored by the parser

[section2]
more=stuff
EOI

ok $ini ~~ /^&lt;inifile&gt;$/, &#39;Can parse a full INI file&#39;;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_回溯">9.4. 回溯</h3>
<div class="paragraph">
<p>在很多程序员看来，正则表达式匹配似乎很神奇。你只需说明模式，然后正则表达式引擎就会为你决定一个字符串是否匹配该模式。虽然实现一个正则表达式引擎是一件很棘手的事情，但基本原理并不难理解。</p>
</div>
<div class="paragraph">
<p>正则表达式引擎会从左到右浏览正则表达式的各个部分，试图匹配正则表达式的每个部分。它在游标中记录着到目前为止它匹配到的字符串的哪一部分。如果一个正则表达式的某一部分找不到匹配，正则表达式引擎会尝试改变之前的匹配，以占用更少的字符，然后在新的位置重新尝试失败的匹配。</p>
</div>
<div class="paragraph">
<p>例如，如果你执行了下面这个正则表达式匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

&#39;abc&#39; ~~ /.* b/</code></pre>
</div>
</div>
<div class="paragraph">
<p>正则表达式引擎首先计算 <code>.<strong></strong></code><strong>。<code>.</code> 可以匹配任何字符。<code></code></strong> 量词符是贪婪的，这意味着它尽量匹配尽可能多的字符。它最终会匹配整个字符串，即 abc。然后正则表达式引擎会尝试匹配 b，这是一个字面值。由于之前的匹配吞噬了整个字符串，所以匹配 c 和剩余的空字符串失败了。所以之前的正则表达式部分，<code>.<strong></strong></code><strong>，必须放弃一个字符。现在，它匹配了 ab，而 b 的字面值匹配器对 b 和 c 进行了比较，再次失败。所以有一个最后的迭代，<code>.</code></strong> 再次放弃了一个匹配的字符，现在 b 的字面值可以匹配字符串中的第二个字符。</p>
</div>
<div class="paragraph">
<p>这种来回迭代的方式叫做回溯。当你在字符串中搜索模式时，这是一个很好的功能。但在解析器中，它通常是不可取的。比如说，如果在输入 <code>key2=value2</code> 中的正则表达式 <code>key</code> 匹配了子串 key2，你不希望它只因为正则表达式的下一部分不能匹配到一个更短的子串，那么你就不希望它匹配到更短的子串。</p>
</div>
<div class="paragraph">
<p>你不希望这样做有三个主要原因。第一是它增加了调试的难度。当人类思考一个文本是如何结构化的时候，他们通常会很快地提交基本的标记化，比如一个词或一个句子的结尾。因此，回溯可能非常不直观。如果你根据哪些正则表达式不匹配产生错误信息，回溯基本上总是导致错误信息非常无用。</p>
</div>
<div class="paragraph">
<p>第二个原因是，回溯可能会导致意外的正则表达式匹配。例如，你想匹配两个单词，可选地用空格分隔，而你试图将其直接翻译成正则表达式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

say &#34;two words&#34; ~~ /\w+\s*\w+/; # 「two words」</code></pre>
</div>
</div>
<div class="paragraph">
<p>这似乎是可行的：第一个 <code>\w +</code> 与第一个单词匹配，第二个 <code>\w+</code> 与第二个单词匹配，一切都很好。直到你发现它实际上也匹配一个单词:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

say &#34;two&#34; ~~ /\w+\s*\w+/; # 「two」</code></pre>
</div>
</div>
<div class="paragraph">
<p>为什么会这样呢？嗯，第一个 <code>\w+</code> 匹配了整个单词，<code>\s*</code> 成功地匹配了空字符串，然后第二个 <code>\w+</code> 匹配失败了，这迫使前两个部分的正则表达式以不同的方式匹配。所以，在第二次迭代中，第一个 <code>\w+</code> 只匹配了 tw，<code>\s*</code> 匹配了 tw 和 o 之间的空字符串，第二个 <code>\w+</code> 匹配了 o。然后你会发现，如果两个词没有空格分隔，你怎么能分辨出一个词的结尾和下一个词的开头呢？在禁用回溯的情况下，正则表达式匹配失败，而不是以一种不经意的方式匹配。</p>
</div>
<div class="paragraph">
<p>第三个原因是性能问题。当你禁用回溯时，正则表达式引擎只需要对每个字符查看一次，或者在有备选项的情况下，对每个分支查看一次。使用回溯，正则表达式引擎可能会陷入回溯循环中，随着输入字符串长度的增加，回溯循环的时间会越长。</p>
</div>
<div class="paragraph">
<p>要禁用回溯，你只需要在声明中用 <strong>token</strong>  替换 <strong>regex</strong> 这个词，或者在 <strong>regex</strong> 中使用 <strong>:ratchet</strong> 修饰符。</p>
</div>
<div class="paragraph">
<p>在 INI 文件解析器中，只有 <code>regex value</code> 需要回溯（虽然前面讨论过的其他形式不需要）；其他所有的 regex 都可以安全地切换到 token:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my token key     { \w+ }
my regex value   { &lt;!before \s&gt; &lt;-[\n;]&gt;+ &lt;!after \s&gt; }
my token pair    { &lt;key&gt; \h* &#39;=&#39; \h* &lt;value&gt; \n+ }
my token header  { &#39;[&#39; &lt;-[ \[ \] \n ]&gt;+ &#39;]&#39; \n+ }
my token comment { &#39;;&#39; \N*\n+ }
my token block   { [ &lt;pair&gt; | &lt;comment&gt; ]* }
my token section { &lt;header&gt; &lt;block&gt; }
my token inifile { &lt;block&gt; &lt;section&gt;* }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_grammar">9.5. Grammar</h3>
<div class="paragraph">
<p>这种解析 INI 文件的正则表达式的集合，并不是封装和重用的巅峰之作。</p>
</div>
<div class="paragraph">
<p>因此，我们将探讨 grammar，一种将正则表达式分组成类状结构的特性，以及如何从成功匹配中提取结构化数据。</p>
</div>
<div class="paragraph">
<p>Grammar 是一个具有一些额外的特性的类，使其适用于解析文本。与方法和属性一起，你可以将正则表达式放入 grammar 中。</p>
</div>
<div class="paragraph">
<p>这就是 INI 文件解析器在制定为 grammar 时的样子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

grammar IniFile {
    token key     { \w+ }
    token value   { &lt;!before \s&gt; &lt;-[\n;]&gt;+ &lt;!after \s&gt; }
    token pair    { &lt;key&gt; \h* &#39;=&#39; \h* &lt;value&gt; \n+ }
    token header  { &#39;[&#39; &lt;-[ \[ \] \n ]&gt;+ &#39;]&#39; \n+ }
    token comment { &#39;;&#39; \N*\n+ }
    token block   { [&lt;pair&gt; | &lt;comment&gt;]* }
    token section { &lt;header&gt; &lt;block&gt; }
    token TOP     { &lt;block&gt; &lt;section&gt;* }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以通过调用 <code>parse</code> 方法来解析一些文本，该方法使用 regex 或 token TOP 作为入口点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $result = IniFile.parse($text);</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了标准化的入口点之外，grammar 还有更多的优势。你可以像从普通类中继承它，从而为正则表达式带来更多的可重用性。你可以通过在 grammar 中添加方法，将额外的功能与正则表达式组合在一起。Grammar 中还有一些机制可以让你作为一个开发者的生活更加轻松。</p>
</div>
<div class="paragraph">
<p>其中之一就是处理空白。在 INI 文件中，一般认为横向的空白是不重要的，因为 <code>key=value</code> 和 key = value` 会导致应用程序的配置相同。到目前为止，我们已经通过在 token 对中添加了 <code>\h*</code> 来明确地处理了这个问题。但是，有些地方我们实际上还没有考虑到。比如说，有一个注释不在开头的地方也是可以的。</p>
</div>
<div class="paragraph">
<p>Grammar 提供的机制是，你可以定义一个叫做 <code>ws</code> 的规则，当你用 rule 代替 token 声明一个 token 时(或者在 regex 中通过 <code>:sigspace</code> 修饰符启用这个功能)，Raku 会在 regex 定义中有空白的地方为你插入隐式的 <code>&lt;ws&gt;</code> 调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

grammar IniFile {
    token ws { \h* }
    rule pair { &lt;key&gt;    &#39;=&#39;    &lt;value&gt; \n+ }
    # rest as before
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于一个需要解析空白的单一规则来说，这可能不值得，但当有更多的规则时，这样做确实能让空白解析保持在一个位置上，这样做会有好处。</p>
</div>
<div class="paragraph">
<p>需要注意的是，你应该只解析 <code>token ws</code> 中不重要的空白。在 INI 文件中，换行是重要的，所以 <code>ws</code> 不应该与之匹配。</p>
</div>
</div>
<div class="sect2">
<h3 id="_从匹配中提取数据">9.6. 从匹配中提取数据</h3>
<div class="paragraph">
<p>到目前为止，IniFile grammar 只检查给定的输入是否匹配 grammar。然而，当它匹配时，我们真的希望解析结果能以一个易于使用的数据结构来表示。例如，我们可以将这个例子的 INI 文件</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

key1=value2

[section1]
key2=value2
key3 = with spaces
; comment lines start with a semicolon, and are
; ignored by the parser

[section2]
more=stuff</code></pre>
</div>
</div>
<div class="paragraph">
<p>范围为嵌套的散列数据结构:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

{
_ =&gt; {
          key1 =&gt; &#34;value2&#34;
      },
      section1 =&gt; {
          key2 =&gt; &#34;value2&#34;,
          key3 =&gt; &#34;with spaces&#34;
      },
      section2 =&gt; {
          more =&gt; &#34;stuff&#34;
      }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，来自任何 section 之外的键/值对都会在 <code>_</code> 顶层键中显示。</p>
</div>
<div class="paragraph">
<p>从 <code>IniFile.parse</code> 调用的结果是一个 Match<sup class="footnote">[<a id="_footnoteref_57" class="footnote" href="#_footnotedef_57" title="View footnote.">57</a>]</sup> 对象，它具有（几乎）提取所需的匹配信息。如果你把 Match 对象变成一个字符串， 它就变成了匹配的字符串。但是，还有更多。你可以像散列一样使用它来从命名的子匹配中提取匹配。因此，如果顶层的匹配对象从</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

token TOP { &lt;block&gt; &lt;section&gt;* }</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生一个匹配对象 <code>$m</code>，那么 <code>$m&lt;block&gt;</code> 又是一个匹配对象，这个匹配对象来自于 token 块的调用的匹配。而 <code>$m&lt;section&gt;</code> 是来自于重复调用 <code>token section</code> 的匹配对象的列表。所以一个 Match 对象其实就是一棵匹配树（图9-1）。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://s3-img.meituan.net/v1/mss_3d027b52ec5a4d589e68050845611e68/ff/n0/0k/c8/x0_167351.jpg@596w_1l.jpg" alt="匹配树"/>
</div>
<div class="title">Figure 1. 解析示例 INI 文件的匹配树</div>
</div>
<div class="paragraph">
<p>我们可以使用此数据结构来提取嵌套的哈希值。 标头标记匹配像“[section1] \ n”这样的字符串，我们只对“section1”感兴趣。 为了到达内部部分，我们可以通过在我们感兴趣的匹配的子规则周围插入一对括号来修改标题：</p>
</div>
<div class="paragraph">
<p>我们可以遍历这个数据结构来提取嵌套的散列值。<code>header</code> 标记匹配的字符串是 <code>&#34;[section1]\n&#34;</code>，我们只对 &#34;section1&#34; 感兴趣。为了进入内部部分，我们可以通过在我们感兴趣的匹配的子正则表达式周围插入一对括号来修改 <code>header</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

token header { &#39;[&#39; ( &lt;-[ \[ \] \n ]&gt;+ ) &#39;]&#39; \n+ }
#                   ^^^^^^^^^^^^^^^^^^^^ a capturing group</code></pre>
</div>
</div>
<div class="paragraph">
<p>那是一个捕获组，我们可以通过把 <code>header</code> 的顶层匹配作为数组，访问它的第一个元素，就可以得到它的匹配。这就引出了完整的 INI 解析器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub parse-ini(Str $input) {
    my $m = IniFile.parse($input);
    unless $m {
        die &#34;The input is not a valid INI file.&#34;;
    }

    sub block(Match $m) {
        my %result;
        for $m&lt;block&gt;&lt;pair&gt; -&gt; $pair {
            %result{ $pair&lt;key&gt;.Str } = $pair&lt;value&gt;.Str;
        }
        return %result;
    }

    my %result;
    %result&lt;_&gt; = block($m);
    for $m&lt;section&gt; -&gt; $section {
        %result{ $section&lt;header&gt;[0].Str } = block($section);
    }
    return %result;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种自上而下的方法是可行的，但它需要对 grammar 的结构有非常深刻的理解。这意味着，如果在维护过程中改变结构，你将很难搞清楚如何改变数据提取代码。</p>
</div>
<div class="paragraph">
<p>Raku 也提供了一个自下而上的方法。它允许你为每个 regex、token 或 rule 编写一个数据提取或 <strong>action</strong> 方法。Grammar 引擎将匹配对象作为单一参数传递，而 action 方法可以调用例程 <code>make</code> 将结果附加到匹配对象上。结果可以通过匹配对象上的 <code>.made</code> 方法获得。</p>
</div>
<div class="paragraph">
<p>一旦一个 regex 匹配成功，action 方法的执行就会发生；因此，一个 regex 的 action 方法可以依赖 subregex 调用的 action 方法已经运行。例如，当 <code>rule pair { &lt;key&gt; &#39;=&#39; &lt;value&gt; \n+ }</code> 正在执行时，首先标记 <code>key</code> 匹配成功，其 action 方法立即运行。然后，标记 <code>value</code> 匹配成功，它的 action 方法也会运行。最后，<code>rule pair</code> 本身可以匹配成功，所以它的 action 方法可以依赖 <code>$m&lt;key&gt;.made</code> 和 <code>$m&lt;value&gt;.made</code>，假设匹配结果存储在变量 <code>$m</code> 中。</p>
</div>
<div class="paragraph">
<p>说到变量，一个 regex 匹配会将其结果隐式地存储在特殊变量 <code>$/</code> 中，在 action 方法中习惯性地使用 <code>$/</code> 作为参数。还有一个访问命名的子匹配的捷径：你可以写 <code>$&lt;key&gt;</code>，而不是写 <code>$/&lt;key&gt;</code>。考虑到这个惯例，action 类就变成了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

class IniFile::Actions {
    method key($/) { make $/.Str }
    method value($/) { make $/.Str }
    method header($/) { make $/[0].Str }
    method pair($/) { make $&lt;key&gt;.made =&gt; $&lt;value&gt;.made }
    method block($/) { make $&lt;pair&gt;.map({ .made }).hash }
    method section($/) { make $&lt;header&gt;.made =&gt; $&lt;block&gt;.made }
    method TOP($/) {
        make {
            _ =&gt; $&lt;block&gt;.made,
            $&lt;section&gt;.map: { .made },
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前两个 action 方法其实很简单。<code>key</code> 或 <code>value</code> 匹配的结果只是匹配的字符串。对于 <code>header</code>，它只是括号内的子字符串。合适的是，<code>pair</code> 返回一个 Pair<sup class="footnote">[<a id="_footnoteref_58" class="footnote" href="#_footnotedef_58" title="View footnote.">58</a>]</sup> 对象，由 <code>key</code> 和 <code>value</code> 组成。<code>block</code> 方法从块中的所有行中构造出一个散列。 通过迭代每个 <code>pair</code> 子匹配，提取已经附加的 Pair 对象。在匹配树的上一层，<code>section</code> 接收这个散列，并与从 <code>$&lt;header&gt;.made</code> 中提取的 <code>section</code> 名称配对。最后，顶层的 action 方法收集了 <code>key_</code> 下的无 section 的 key/value 对以及所有的 section，并以散列形式返回。</p>
</div>
<div class="paragraph">
<p>在 action 类的每一个方法中，我们只依靠直接调用第一层的 regex 的知识，这些 regex 对应于 action 方法和它们 <code>.made</code> 的数据类型。因此，当你重构一个 regex 时，你也只需要改变对应的 action 方法。没有人需要注意到 grammar 的全局结构。</p>
</div>
<div class="paragraph">
<p>现在我们只需要告诉 Raku 实际使用 action 类就可以了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub parse-ini(Str $input) {
    my $m = IniFile.parse($input, :actions(IniFile::Actions));
    unless $m {
        die &#34;The input is not a valid INI file.&#34;;
    }

    return $m.made
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想用一个与 <code>TOP</code> 不同的规则开始解析（例如，你可能想在测试中这样做），你可以将一个命名的参数规则传递给方法 <code>parse</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub parse-ini(Str $input, :$rule = &#39;TOP&#39;) {
    my $m = IniFile.parse($input,
        :actions(IniFile::Actions),
        :$rule,
    );
    unless $m {
        die &#34;The input is not a valid INI file.&#34;;
    }

    return $m.made
}

say parse-ini($ini).perl;

use Test;

is-deeply parse-ini(&#34;k = v\n&#34;, :rule&lt;pair&gt;), &#39;k&#39; =&gt; &#39;v&#39;,
    &#39;can parse a simple pair&#39;;
done-testing;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了更好地封装 grammar 中的所有解析功能，我们可以把 <code>parse-ini</code> 变成一个方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

grammar IniFile {
    # regexes/tokens unchanged as before

    method parse-ini(Str $input, :$rule = &#39;TOP&#39;) {
        my $m = self.parse($input,
            :actions(IniFile::Actions),
            :$rule,
        );
    unless $m {
        die &#34;The input is not a valid INI file.&#34;;
    }

    return $m.made
    }
}

# Usage:

my $result = IniFile.parse-ini($text);</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了实现这个功能，类 <code>IniFile::Action</code> 必须在 grammar 之前声明，或者需要在文件顶部用类 <code>IniFile::Action { …​ }</code> 在文件的顶部(用三个点来标记为前向声明)预先声明。</p>
</div>
</div>
<div class="sect2">
<h3 id="_生成好的错误信息">9.7. 生成好的错误信息</h3>
<div class="paragraph">
<p>好的错误信息对于任何产品的用户体验都是至关重要的。解析器也不例外。考虑一下消息 <code>Square bracket [ on line 3 closed by curly bracket } on line 5</code>，与 Python 的懒散和通用的 <code>SyntaxError: invalid syntaxError</code> 的不同。</p>
</div>
<div class="paragraph">
<p>除了文本消息之外，知道解析错误的位置对找出错误的原因有很大的帮助。</p>
</div>
<div class="paragraph">
<p>我们将以我们的 INI 文件解析器为例，探讨如何从 Raku grammar 中生成更好的解析错误信息。</p>
</div>
<div class="sect3">
<h4 id="_失败是正常的">9.7.1. 失败是正常的</h4>
<div class="paragraph">
<p>在开始之前，我们必须意识到，在一个基于 grammar 的解析器中，即使是在一个整体成功的解析中，regex 不匹配也是很正常的。</p>
</div>
<div class="paragraph">
<p>让我们回顾一下解析器的一部分。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

token block   { [&lt;pair&gt; | &lt;comment&gt;]* }
token section { &lt;header&gt; &lt;block&gt; }
token TOP     { &lt;block&gt; &lt;section&gt;* }</code></pre>
</div>
</div>
<div class="paragraph">
<p>当这个 grammar 与字符串匹配时:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">key=value
[header]
other=stuff</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后 <code>TOP</code> 调用 <code>block</code>，即同时调用 <code>pair</code> 和 <code>comment</code>。<code>pair</code> 匹配成功，<code>comment</code> 匹配失败。这没什么大不了的。但是由于 <code>token block</code> 中存在一个 <code>*</code> 量c词符，所以它再次尝试匹配 <code>pair</code> 或 <code>comment</code>。都没有成功，但 <code>token block</code> 的整体匹配还是成功了。</p>
</div>
<div class="paragraph">
<p>一个很好的方法是安装 <code>Grammar::Tracer</code> 模块(<code>zef install Grammar::Tracer</code>)，并在 grammar 定义前添加语句 <code>use Grammar::Tracer</code>。这样就会产生调试输出，显示哪些规则匹配，哪些不匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">TOP
|  block
|  |  pair
|  |  |  key
|  |  |  * MATCH &#34;key&#34;
|  |  |  ws
|  |  |  * MATCH &#34;&#34;
|  |  |  ws
|  |  |  * MATCH &#34;&#34;
|  |  |  value
|  |  |  * MATCH &#34;value&#34;
|  |  |  ws
|  |  |  * MATCH &#34;&#34;
|  |  |  ws
|  |  |  * MATCH &#34;&#34;
|  |  * MATCH &#34;key=value\n&#34;
|  |  pair
|  |  |  key
|  |  |  * FAIL
|  |  * FAIL
|  |  comment
|  |  * FAIL
|  * MATCH &#34;key=value\n&#34;
|  section
...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_检测有害失败">9.7.2. 检测有害失败</h4>
<div class="paragraph">
<p>为了产生良好的解析错误信息，你必须区分预期的和意外的解析失败。正如前文所解释的那样，单一的 regex 或 token 的匹配失败一般不代表输入有问题。但是你可以识别出一些点，你知道一旦 regex 引擎走到这一步，其余的匹配一定会成功。</p>
</div>
<div class="paragraph">
<p>如果你回想一下 <code>pair</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

rule pair { &lt;key&gt; &#39;=&#39; &lt;value&gt; \n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们知道，如果一个键被解析了，我们真的希望下一个字符是等号。如果不是，那么输入是畸形的。</p>
</div>
<div class="paragraph">
<p>在代码中，这个写法是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

rule pair {
    &lt;key&gt;
    [ &#39;=&#39; || &lt;expect(&#39;=&#39;)&gt; ]
    &lt;value&gt; \n+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>||</code> 是一个顺序的替代方案，它首先尝试匹配左手边的子正则表达式，如果失败，则只执行右手边的子正则表达式。</p>
</div>
<div class="paragraph">
<p>所以现在我们要定义 <code>expect</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

method expect($what) {
    die &#34;Cannot parse input as INI file: Expected $what&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>是的，你可以像调用正则表达式一样调用方法，因为在底层, 正则表达式真的是方法。<code>die</code> 会抛出一个异常，所以现在错误的输入 justakey 会产生错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot parse input as INI file: Expected =</code></pre>
</div>
</div>
<div class="paragraph">
<p>后面还有一个回溯。这已经比&#34;无效语法&#34;要好，虽然位置还是缺失了。在方法 <code>expect</code> 里面，我们可以通过方法 <code>pos</code> 找到当前的解析位置，这个位置是由 `grammar ` 声明符带来的隐式父类 Grammar<sup class="footnote">[<a id="_footnoteref_59" class="footnote" href="#_footnotedef_59" title="View footnote.">59</a>]</sup> 提供的。</p>
</div>
<div class="paragraph">
<p>我们可以用它来改善一下错误信息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

method expect($what) {
    die &#34;Cannot parse input as INI file: Expected $what at character
    {self.pos}&#34;;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_提供上下文">9.7.3. 提供上下文</h4>
<div class="paragraph">
<p>对于较大的输入，我们真的要打印行号。要计算这个，我们需要掌握目标字符串，通过方法 <code>target</code> 可以获得目标字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

method expect($what) {
    my $parsed-so-far = self.target.substr(0, self.pos);
    my @lines = $parsed-so-far.lines;
    die &#34;Cannot parse input as INI file: Expected $what at line
    @lines.elems(), after &#39;@lines[*-1]&#39;&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这使我们从错误信息的&#34;meh&#34;领域进入了相当好的领域。因此:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

IniFile.parse(q:to/EOI/);
key=value
[section]
key_without_value
more=key
EOI</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在死于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot parse input as INI file: Expected = at line 3, after
&#39;key_without_value&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以通过在解析失败的位置前后提供上下文来进一步完善 <code>expect</code> 方法。当然，你还需要在 regex 中更多的地方应用 <code>[ thing || &lt;expect(&#39;thing&#39;)&gt; ]</code> 模式来获得更好的错误信息。</p>
</div>
<div class="paragraph">
<p>最后，你还可以提供不同类型的错误信息。例如，当解析一个 <code>section header</code> 时，一旦解析了初始的 <code>[</code> ，你可能不希望出现错误信息是 &#34;expected rest of section header&#34;，而是 &#34;malformed section header, at line …​&#34;。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

rule pair {
    &lt;key&gt;
    [ &#39;=&#39; || &lt;expect(&#39;=&#39;)&gt; ]
    [ &lt;value&gt; || &lt;expect(&#39;value&#39;)&gt;]
    \n+
}
token header {
    &#39;[&#39;
     [ ( &lt;-[ \[ \] \n ]&gt;+ )    &#39;]&#39;
         || &lt;error(&#34;malformed section header&#34;)&gt; ]
}
...
method expect($what) {
    self.error(&#34;expected $what&#34;);
}

method error($msg) {
    my $parsed-so-far = self.target.substr(0, self.pos);
    my @lines = $parsed-so-far.lines;
    die &#34;Cannot parse input as INI file: $msg at line @lines.
    elems(), after &#39;@lines[*-1]&#39;&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 Raku 使用 grammar 来解析 Raku 的输入，所以你可以用 Rakudo 自己的 grammar<sup class="footnote">[<a id="_footnoteref_60" class="footnote" href="#_footnotedef_60" title="View footnote.">60</a>]</sup> 作为灵感的来源，让更多的方法让错误报告变得更好。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解析配对配对的捷径">9.7.4. 解析配对配对的捷径</h4>
<div class="paragraph">
<p>由于这是一个很常见的任务，所以 Raku 的 grammar 有一个特殊的目标匹配语法，用于匹配一对分隔符之间的东西。在 INI 文件的例子中，就是一对括号，它们之间有一个 <code>section</code> 标题。</p>
</div>
<div class="paragraph">
<p>我们可以把</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

token header { &#39;[&#39; ( &lt;-[ \[ \] \n ]&gt;+ ) &#39;]&#39; \n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>更改为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

token header { &#39;[&#39; ~ &#39;]&#39; ( &lt;-[ \[ \] \n ]&gt;+ ) \n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这不仅在美学上有一个好处，那就是把匹配的分界符放在更近的地方，而且如果除了闭合分界符匹配之外的所有东西都匹配的话，它还为我们调用了一个方法 <strong>FAILGOAL</strong>。我们可以用这个方法来生成更好的错误信息，以处理匹配对的解析失败:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

method FAILGOAL($goal) {
    my $cleaned-goal = $goal.trim;
    $cleaned-goal = $0 if $goal ~~ / \&#39; (.+) \&#39; /;
    self.error(&#34;Cannot find closing $cleaned-goal&#34;);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>传给 <strong>FAILGOAL</strong> 的参数是正则表达式源码的字符串，这个字符串不能匹配闭合分隔符，这里是 &#39;]&#39;（带尾部空格）。我们希望从中提取出错误信息的字面意义的 <code>]</code> ，因此在方法中间的 regex 匹配。如果这个 regex 匹配成功，那么这个字面符号就在 <code>$/[0]</code> 中，<code>$0</code> 是一个快捷方式。</p>
</div>
<div class="paragraph">
<p>所有使用 <code>~</code> 的解析构造都可以从这样的方法 <strong>FAILGOAL</strong> 中受益，所以在解析几个不同的引号或括号构造的 grammar 中，写一个方法是值得的。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_编写你自己的_grammar">9.8. 编写你自己的 Grammar</h3>
<div class="paragraph">
<p>解析是一项必须学习的技能，主要是和你的普通编程技能分开来的。所以我鼓励你从一些小的东西开始，比如 CSV 解析器，或者逗号分隔的值。<sup class="footnote">[<a id="_footnoteref_61" class="footnote" href="#_footnotedef_61" title="View footnote.">61</a>]</sup></p>
</div>
<div class="paragraph">
<p>即使是像 CSV 这样简单的东西，也会有一些复杂性。例如，你可以允许引号字符串本身就可以包含分隔符，以及允许在引号字符串中使用引号字符的转义字符。</p>
</div>
<div class="paragraph">
<p>如果你对更深层次的 regexes 有兴趣，我强烈推荐 Jeffrey E. F. Friedl 的《精通正则表达式》（O’Reilly Media, 2008）。这本书并没有处理 Raku 中的正则表达式，但其中的概念可以很好地转化到 Raku 的正则表达式中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_8">9.9. 总结</h3>
<div class="paragraph">
<p>Raku 允许将 regex 重用，把它们当作一级公民，允许像普通例程一样命名和调用它们。通过允许在 regex 中使用空格，进一步消除了混乱。</p>
</div>
<div class="paragraph">
<p>这些功能让你可以写出正则表达式来解析正确的文件格式，甚至是编程语言。Grammar 让你可以结构化、重用和封装正则表达式。</p>
</div>
<div class="paragraph">
<p>正则表达式匹配的结果是一个匹配对象，它实际上是一棵树，每个命名的子匹配和每个捕获组都有节点。action 方法使解析和数据提取很容易解耦。</p>
</div>
<div class="paragraph">
<p>为了从解析器中生成良好的错误信息，需要区分预期的匹配失败和意外的匹配失败。顺序替换 <code>||</code> 是一个工具，你可以通过从替换的第二个分支中提出一个异常来将意外匹配失败变成错误消息。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_文件和目录使用状态图">10. 文件和目录使用状态图</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You bought a shiny new 2TB disk just a short while ago and you’re already getting low disk space warnings. What’s taking up all that space?</p>
</div>
<div class="paragraph">
<p>To answer this question, and experiment a bit with data visualization, let’s write a small tool that visualizes which files use up how much disk space. We also get to explore some functional programming concepts in the process.</p>
</div>
<div class="sect2">
<h3 id="_reading_file_sizes">10.1. Reading File Sizes</h3>
<div class="paragraph">
<p>To visualize file usage, we must first recursively read all directories and files in a given directory, and record their sizes. To get a listing of all elements in a directory, we can use the dir1 function, which returns a lazy list of IO::Path2 objects.</p>
</div>
<div class="paragraph">
<p>We distinguish between directories, which can have child entries, and files, which can’t. Both can have a direct size, and in the case of directories also a total size, which includes files and subdirectories, recursively:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

class File {
    has $.name;
    has $.size;
    method total-size() { $.size }
}

class Directory {
    has $.name;
    has $.size;
    has @.children;
    has $!total-size;
    method total-size() {
        $!total-size //= $.size + @.children.map({.total-size}).sum;
    }
}

sub tree(IO::Path $path) {
    if $path.d {
        return Directory.new(
            name     =&gt; $path.basename,
            size     =&gt; $path.s,
            children =&gt; dir($path).map(&amp;tree),
        );
    }
    else {
        return File.new(
            name =&gt; $path.Str,
            size =&gt; $path.s,
        );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code for reading a file tree recursively uses the d and s methods on IO::Path. d returns True for directories and False for files. s returns the size.</p>
</div>
<div class="paragraph">
<p>Just to check that we’ve got a sensible data structure, we can write a short routine that prints it recursively, with indentation to indicate nesting of directory entries:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub print-tree($tree, Int $indent = 0) {
    say &#39; &#39; x $indent, format-size($tree.total-size), &#39; &#39;,
    $tree.name;

    if $tree ~~ Directory {
        print-tree($_, $indent + 2) for $tree.children;
    }
}

sub format-size(Int $bytes) {
    my @units = flat &#39;&#39;, &lt;k M G T P&gt;;
    my @steps = (1, { $_ * 1024 } ... *).head(6);
    for @steps.kv -&gt; $idx, $step {
        my $in-unit = $bytes / $step;
        if $in-unit &lt; 1024 {
            return sprintf &#39;%.1f%s&#39;, $in-unit, @units[$idx];
        }
    }
}

sub MAIN($dir = &#39;.&#39;) {
    print-tree(tree($dir.IO));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The subroutine print-tree is pretty boring, if you’re used to recursion.It prints out the name and size of the current node and, if the current node is a directory, recurses into each children with an increased indentation. The indentation is applied through the x string repetition operator, which when called as $string x $count repeats the $string $count times. It uses the ∼∼ smart matching operator to perform a type check; it tests if $tree is a Directory.</p>
</div>
<div class="paragraph">
<p>To get a human-readable representation of the size of a number, format- size knows a list of six units: the empty string for one, k (kilo) for 1024, M (mega) for 1024×1024, and so on. This list is stored in the array @units. The multiple associated with each unit is stored in @steps, which is initialized through the series operator …​. Its structure is INITIAL, CALLABLE …​ LIMIT, where it applies CALLABLE first to the initial value, and then to the next value generated, and so on, until it hits LIMIT. The limit here is *, a special term called Whatever, which means it’s unlimited. Thus, the sequence operator returns a lazy, potentially infinite, list and the trailing .head(6) call limits it to six values.</p>
</div>
<div class="paragraph">
<p>To find the most appropriate unit to print with the size, we have to iterate over both the values and the indices of the array, which for @steps.kv → $idx, $step { .. } accomplishes. sprintf, known from other programming languages, does the actual formatting to one digit after the dot and appends the unit.</p>
</div>
</div>
<div class="sect2">
<h3 id="_generating_a_tree_map">10.2. Generating a Tree Map</h3>
<div class="paragraph">
<p>One possible visualization of file and directory sizes is a tree map, which represents each directory as a rectangle and each file inside it as a rectangle within the directory’s rectangle. The size of each rectangle is proportional to the size of the file or directory it represents.</p>
</div>
<div class="paragraph">
<p>We’ll generate an SVG file containing all those rectangles. Modern browsers support displaying such files and also show mouse-over texts for each rectangle. This alleviates the burden of actually labeling the rectangles, which can be quite a hassle.</p>
</div>
<div class="paragraph">
<p>To generate the SVG, we’ll use the SVG module, which you can install with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ zef install SVG</code></pre>
</div>
</div>
<div class="paragraph">
<p>This module provides a single static method, into which you pass nested pairs. Pairs whose values are arrays are turned into XML tags; other pairs are turned into attributes. As an example, this Raku script</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use SVG;
print SVG.serialize(
    :svg[
        width =&gt; 100,
        height =&gt; 20,
        title =&gt; [
            &#39;example&#39;,
        ]
    ],
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>produces this output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; xmlns:svg=&#34;http://www.w3.org/2000/svg&#34; xmlns:xlink=&#34;http://www.w3.org/1999/xlink&#34; width=&#34;100&#34;
height=&#34;20&#34;&gt; &lt;title&gt;example&lt;/title&gt;
&lt;/svg&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>(without the indentation). The xmlns-tags are helpfully added by the SVG module and are necessary for programs to recognize the file as SVG.</p>
</div>
<div class="paragraph">
<p>Returning to the tree maps (Figure 10-1), a very simple way to lay out the rectangle is to recurse into areas and for each area subdivide it either horizontally or vertically, depending upon which axis is longer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub tree-map($tree, :$x1!, :$x2!, :$y1!, :$y2) {
    # do not produce rectangles for small files/dirs
    return if ($x2 - $x1) * ($y2 - $y1) &lt; 20;

    # produce a rectangle for the current file or dir

    take &#39;rect&#39; =&gt; [
        x =&gt; $x1,
        y =&gt; $y1,
        width  =&gt; $x2 - $x1,
        height =&gt; $y2 - $y1,
        style  =&gt; &#34;fill:&#34; ~ random-color(),
        title  =&gt; [$tree.name],
    ];
    return if $tree ~~ File;

    if $x2 - $x1 &gt; $y2 - $y1 {
        # split along the x-axis
        my $base = ($x2 - $x1) / $tree.total-size;
        my $new-x = $x1;
        for $tree.children -&gt; $child {
            my $increment = $base * $child.total-size;
            tree-map(
                $child,
                x1 =&gt; $new-x,
                x2 =&gt; $new-x + $increment,
                :$y1,
                :$y2,
            );
            $new-x += $increment;
        }
    }
    else {
        # split along the y-axis
        my $base = ($y2 - $y1) / $tree.total-size;
        my $new-y = $y1;
        for $tree.children -&gt; $child {
            my $increment = $base * $child.total-size;
            tree-map(
                $child,
                :$x1,
                :$x2,
                y1 =&gt; $new-y,
                y2 =&gt; $new-y + $increment,
            );
            $new-y += $increment;
         }
    }
}

sub random-color {
    return &#39;rgb(&#39; ~ (1..3).map({ (^256).pick }).join(&#39;,&#39;) ~ &#39;)&#39;;
}

sub MAIN($dir = &#39;.&#39;) {
    my $tree = tree($dir.IO); use SVG;
    my $width = 1024;
    my $height = 768;
    say SVG.serialize(
        :svg[
            :$width,
            :$height,
            | gather tree-map $tree, x1 =&gt; 0, x2 =&gt; $width, y1 =&gt; 0,
            y2 =&gt; $height
        ]
    );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The generated file is not pretty, due to the random colors and due to some files being identified as very narrow rectangles. But it does make it obvious that there are a few big files and many mostly small files in a directory (which happens to be the .git directory of a repository). Viewing a file in a browser shows the name of the file on mouse-over.</p>
</div>
<div class="paragraph">
<p>How did we generate this file?</p>
</div>
<div class="paragraph">
<p>Sub tree-map calls take to add elements to a result list, so it must be called in the context of a gather statement. gather { take 1; take 2 } returns a lazy list of two elements, 1, 2. But the take calls don’t have to occur in the lexical scope of the gather; they can be in any code that’s directly or indirectly called from the gather. We call that the dynamic scope.</p>
</div>
<div class="paragraph">
<p>The rest of sub tree-map is mostly straightforward. For each direction in which the remaining rectangle can be split, we calculate a base unit that signifies how many pixels a byte should occupy. This is used to split up the current canvas into smaller ones and use those to recurse into tree-map.</p>
</div>
<div class="paragraph">
<p>The random color generation uses ˆ256 to create a range from 0 to 256 (exclusive) and .pick returns a random element from this range. The result is a random CSS color string like rgb(120,240,5).</p>
</div>
<div class="paragraph">
<p>In sub MAIN, the gather returns a list, which would normally be nested inside the outer array. The pipe symbol | in :svg[ …​, | gather …​ ] before the gather prevents the normal nesting and flattens the list into the outer array.</p>
</div>
</div>
<div class="sect2">
<h3 id="_火焰图">10.3. 火焰图</h3>
<div class="paragraph">
<p>The disadvantage of tree maps as generated in the preceding is that the human brain isn’t very good at comparing the sizes of rectangles with different aspect ratios, especially if their widths are very different from their heights (i.e., very tall or very flat rectangles). Flame graphs prevent this perception error by showing file sizes as horizontal bars. The vertical arrangement indicates the nesting of directories and files inside other directories. The disadvantage is that less of the available space is used for visualizing the file sizes.</p>
</div>
<div class="paragraph">
<p>It is easier to generate flame graphs than tree maps, because you only need to subdivide in one direction, whereas the height of each bar is fixed. Here it is set to 15 pixels:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub flame-graph($tree, :$x1!, :$x2!, :$y!, :$height!) {
    return if $y &gt;= $height;
    take &#39;rect&#39; =&gt; [
        x =&gt; $x1,
        y =&gt; $y,
        width =&gt; $x2 - $x1,
        height =&gt; 15,
        style =&gt; &#34;fill:&#34; ~ random-color(),
        title =&gt; [$tree.name ~ &#39;, &#39; ~ format-size($tree.total-size)],
    ];

    return if $tree ~~ File;

    my $base = ($x2 - $x1) / $tree.total-size;
    my $new-x = $x1;

    for $tree.children -&gt; $child {
        my $increment = $base * $child.total-size;
        flame-graph(
            $child,
            x1 =&gt; $new-x,
            x2 =&gt; $new-x + $increment,
            y =&gt; $y + 15,
            :$height,
        );
        $new-x += $increment;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can add a switch to sub MAIN to call either tree-map or flame-graph, depending on a command-line option:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub MAIN($dir = &#39;.&#39;, :$type=&#34;flame&#34;) {
    my $tree = tree($dir.IO);
    use SVG;
    my $width = 1024;
    my $height = 768;
    my &amp;grapher = $type eq &#39;flame&#39;
            ?? { flame-graph $tree, x1 =&gt; 0, x2 =&gt; $width, y =&gt; 0, :$height }
            !! { tree-map    $tree, x1 =&gt; 0, x2 =&gt; $width, y1 =&gt; 0, y2 =&gt; $height }
    say SVG.serialize(
        :svg[
            :$width,
            :$height,
            | gather grapher()
        ]
    );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since SVG’s coordinate system places the zero of the vertical axis at the top, this actually produces an inverted flame graph, sometimes called an icicle graph (Figure 10-2):</p>
</div>
<div class="paragraph">
<p>Figure 10-2. Inverted flame graph, where the width of each bar represents a file/ directory size and the vertical position the nesting inside a directory</p>
</div>
<div class="paragraph">
<p>This graph was generated by calling dirstat --type=flame src/rakubook/.</p>
</div>
</div>
<div class="sect2">
<h3 id="_functional_refactorings">10.4. Functional Refactorings</h3>
<div class="paragraph">
<p>There’s a pattern that occurs three times in the code for generating tree maps and flame graphs: dividing an area based on the size of the files and directories in the tree associated with the area.</p>
</div>
<div class="paragraph">
<p>Extracting such common code into a function is a good idea, but it’s slightly hindered by the fact that there is custom code inside the loop that’s part of the common code. Functional programming offers a solution: put the custom code inside a separate function and have the common code call it.</p>
</div>
<div class="paragraph">
<p>Applying this technique to the tree graph flame graph looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub subdivide($tree, $lower, $upper, &amp;todo) {
    my $base = ($upper - $lower ) / $tree.total-size;
    my $var = $lower;
    for $tree.children -&gt; $child {
        my $incremented = $var + $base * $child.total-size;
        todo($child, $var, $incremented);
        $var = $incremented,
    }
}

sub flame-graph($tree, :$x1!, :$x2!, :$y!, :$height!) {
    return if $y &gt;= $height;
    take &#39;rect&#39; =&gt; [
        x =&gt; $x1,
        y =&gt; $y,
        width  =&gt; $x2 - $x1,
        height =&gt; 15,
        style =&gt; &#34;fill:&#34; ~ random-color(),
        title =&gt; [$tree.name ~ &#39;, &#39; ~ format-size($tree.total-size)],
    ];
    return if $tree ~~ File;
    subdivide( $tree, $x1, $x2, -&gt; $child, $x1, $x2 {
        flame-graph( $child, :$x1, :$x2, :y($y + 15), :$height );
    });
}

sub tree-map($tree, :$x1!, :$x2!, :$y1!, :$y2) {
    return if ($x2 - $x1) * ($y2 - $y1) &lt; 20;
    take &#39;rect&#39; =&gt; [
        x =&gt; $x1,
        y =&gt; $y1,
        width  =&gt; $x2 - $x1,
        height =&gt; $y2 - $y1,
        style  =&gt; &#34;fill:&#34; ~ random-color(),
        title  =&gt; [$tree.name],
    ];
    return if $tree ~~ File;

    if $x2 - $x1 &gt; $y2 - $y1 {
        # split along the x-axis
        subdivide $tree, $x1, $x2, -&gt; $child, $x1, $x2 {
            tree-map $child, :$x1, :$x2, :$y1, :$y2;
        }
    }
    else {
        # split along the y-axis
        subdivide $tree, $y1, $y2, -&gt; $child, $y1, $y2 {
            tree-map $child, :$x1, :$x2, :$y1, :$y2;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The newly introduced subroutine subdivide takes a directory tree, a start and end point, and finally a code object &amp;todo. For each child of the directory tree it calculates the new coordinates and then calls the &amp;todo function.
The usage in subroutine flame-graph looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

subdivide( $tree, $x1, $x2, -&gt; $child, $x1, $x2 {
    flame-graph( $child, :$x1, :$x2, :y($y + 15), :$height );
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code object being passed to subdivide starts with →, which introduces the signature of a block. The code block recurses into flame-graph, adding some extra arguments and turning two positional arguments into named arguments along the way.</p>
</div>
<div class="paragraph">
<p>This refactoring shortened the code and made it overall more pleasant
to work with. But there’s still quite a bit of duplication between tree-map and flame-graph: both have an initial termination condition, a take of a rectangle, and then a call or two to subdivide. If we’re willing to put all the small differences into small, separate functions, we can unify it further.</p>
</div>
<div class="paragraph">
<p>If we were to pass all those new functions as arguments to each call, we would create an unpleasantly long argument list. Instead, we can use those functions to generate the previous functions flame-graph and tree-map:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub svg-tree-gen(:&amp;terminate!, :&amp;base-height!, :&amp;subdivide-x!, :&amp;other!) {
    sub inner($tree, :$x1!, :$x2!, :$y1!, :$y2!) {
        return if terminate(:$x1, :$x2, :$y1, :$y2);
        take &#39;rect&#39; =&gt; [
            x =&gt; $x1,
            y =&gt; $y1,
            width  =&gt; $x2 - $x1,
            height =&gt; base-height(:$y1, :$y2),
            style  =&gt; &#34;fill:&#34; ~ random-color(),
            title  =&gt; [$tree.name ~ &#39;, &#39; ~ format-size($tree.total-size)],
        ];
        return if $tree ~~ File;
        if subdivide-x(:$x1, :$y1, :$x2, :$y2) {
            # split along the x-axis
            subdivide $tree, $x1, $x2, -&gt; $child, $x1, $x2 {
                inner($child, :$x1, :$x2, :y1(other($y1)), :$y2);
            }
        }

        else {
            # split along the y-axis
            subdivide $tree, $y1, $y2, -&gt; $child, $y1, $y2 {
                inner($child, :x1(other($x1)), :$x2, :$y1, :$y2);
            }
        }
    }
}

my &amp;flame-graph = svg-tree-gen
    terminate =&gt; -&gt; :$y1, :$y2, | { $y1 &gt; $y2 },
    base-height =&gt; -&gt; | { 15 },
    subdivide-x =&gt; -&gt; | { True },
    other =&gt; -&gt; $y1 { $y1 + 15 },
    ;

my &amp;tree-map = svg-tree-gen
    terminate =&gt; -&gt; :$x1, :$y1, :$x2, :$y2 { ($x2 - $x1) * ($y2 - $y1) &lt; 20 },
    base-height =&gt; -&gt; :$y1, :$y2 { $y2 - $y1 },
    subdivide-x =&gt; -&gt; :$x1, :$x2, :$y1, :$y2 { $x2 - $x1 &gt; $y2 - $y1 },
    other =&gt; -&gt; $a { $a },
    ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we have a new function svg-tree-gen, which returns a function. The behavior of the returned function depends on the four small functions that svg-tree-gen receives as arguments.</p>
</div>
<div class="paragraph">
<p>The first argument, terminate, determines under what condition the inner function should terminate early. For tree-map, that’s when the area is below 20 pixels; for flame-graph, that’s when the current y-coordinate $y1 exceeds the height of the whole image (stored in $y2). svg-tree-gen always calls this function with the four named arguments x1, x2, y1, and y2, so the terminate function must ignore the x1 and x2 values. It does this by adding | as a parameter, which is an anonymous capture. Such a parameter can bind arbitrary positional and named arguments, and since it’s an anonymous parameter, it discards all the values.</p>
</div>
<div class="paragraph">
<p>The second configuration function, base-height, determines the height of the rectangle in the base case. For flame-graph it’s a constant, so the configuration function must discard all arguments, again with a |. For tree-graph, it must return the difference between $y2 and $y1, as before the refactoring.</p>
</div>
<div class="paragraph">
<p>The third function determines when to subdivide along the x axis. Flame graphs always divide along the x axis, so → | { True } accomplishes that. Our simplistic approach to tree graphs divides along the longer axis, so only along the x axis if $x2 – $x1 &gt; $y2 – $y1.</p>
</div>
<div class="paragraph">
<p>The fourth and final function we pass to svg-tree-gen calculates the coordinate of the axis that isn’t being subdivided. In the case of flame-graph that’s increasing over the previous value by the height of the bars, and for tree-map it’s the unchanged coordinate,
so we pass the identity function <code>→ $a { $a }</code>.</p>
</div>
<div class="paragraph">
<p>The inner function only needs a name because we need to call it from itself recursively; otherwise an anonymous function <code>sub ($tree, :$x1!, :$x2!, :$y1!, :$y2!) { …​ }</code> would have worked fine.</p>
</div>
<div class="paragraph">
<p>This refactoring also unifies the names of the arguments to flame-graph and tree-map (previously, tree-map had :$y2 and flame-graph had :$height), so the call can now be simplified to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my &amp;grapher = $type eq &#39;flame&#39; ?? &amp;flame-graph !! &amp;tree-map;
say SVG.serialize(
    :svg[
        :$width,
        :$height,
        | do gather grapher $tree, x1 =&gt; 0, x2 =&gt; $width, y1 =&gt; 0, y2 =&gt; $height
    ]
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that we have very compact definitions of flame-graph and tree-map, it’s a good time to play with some of the parameters. Let’s introduce a bit of margin in the flame graph by having the increment in other greater than the bar height in base-height:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my &amp;flame-graph = svg-tree-gen
    base-height =&gt; -&gt; | { 15 },
    other =&gt; -&gt; $y1 { $y1 + 16 },
    # rest as before</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another knob to turn is to change the color generation to something more deterministic and make it configurable from the outside:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub svg-tree-gen(
    :&amp;color=&amp;random-color,
    :&amp;terminate!,
    :&amp;base- height!,
    :&amp;subdivide-x!,
    :&amp;other!) {
    sub inner($tree, :$x1!, :$x2!, :$y1!, :$y2!) {
        return if terminate(:$x1, :$x2, :$y1, :$y2);
        take &#39;rect&#39; =&gt; [
            x =&gt; $x1,
            y =&gt; $y1,
            width  =&gt; $x2 - $x1,
            height =&gt; base-height(:$y1, :$y2),
            style  =&gt; &#34;fill:&#34; ~ color(),
            title  =&gt; [$tree.name ~ &#39;, &#39; ~ format-size($tree.total-size)],
    }
];
# rest as before
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can, for instance, keep state within the color generator and return a slightly different color during each iteration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub color-range(|) {
    state ($r, $g, $b) = (0, 240, 120);
    $r = ($r + 5) % 256;
    $g = ($g + 10) % 256;
    $b = ($b + 15) % 256;
    return &#34;rgb($r,$g,$b)&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>State variables keep their values between calls to the same subroutine and their initialization runs only on the first call. Hence this function slightly increases the lightness in each color channel for each invocation, except when it reaches 256, where the modulo operator % resets it back to a small value.</p>
</div>
<div class="paragraph">
<p>If we plug this into our functions by passing color ⇒ &amp;color-range to the calls to svg-tree-gen, we get much less chaotic-looking output (Figures 10-3 and 10-4):</p>
</div>
<div class="paragraph">
<p>Figure 10-3. Tree map with deterministic color generation</p>
</div>
<div class="paragraph">
<p>Figure 10-4. Flame graph with deterministic color generation and one pixel margin between bars</p>
</div>
<div class="paragraph">
<p>We could also pass in the coordinates to the &amp;color routine, which would make it possible to write a color generator that produces a nice gradient.</p>
</div>
</div>
<div class="sect2">
<h3 id="_more_language_support_for_functional_programming">10.5. More Language Support for Functional Programming</h3>
<div class="paragraph">
<p>As you’ve seen in the preceding examples, functional programming typically involves writing lots of small functions. Raku has some language features that make it very easy to write such small functions.</p>
</div>
<div class="paragraph">
<p>A common task is to write a function that calls a particular method on its argument, as we’ve seen here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

method total-size() {
    $!total-size //= $.size + @.children.map({.total-size}).sum;
    #                                        ^^^^^^^^^^^^^
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This can be abbreviated to *.total-size:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

method total-size() {
    $!total-size //= $.size + @.children.map(*.total-size).sum;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This works for chains of method calls too, so you could write @.children. map(*.total-size.round) if total-size returned a fractional number and you wanted to call the .round method on the result.</p>
</div>
<div class="paragraph">
<p>There are more cases where you can replace an expression with the “Whatever” star (<strong>) to create a small function. To create a function that adds 15 to its argument, you can write <code></code></strong><code> + 15</code> instead of <code>→ $a { $a + 15 }</code>.</p>
</div>
<div class="paragraph">
<p>If you need to write a function to just call another function, but pass more arguments to the second function, you can use the method assuming.</p>
</div>
<div class="paragraph">
<p>For example <code>→ $x { f(42, $x }</code> can be replaced with <code>&amp;f.assuming(42)</code>.This worksalsofornamedarguments,so→ $x { f($x, height ⇒ 42 ) } can be replaced with <code>&amp;f.assuming(height ⇒ 42)</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_more_improvements">10.6. More Improvements</h3>
<div class="paragraph">
<p>The classes File and Directory have some common functionality, like the size and the name attributes, and the fact that they both have a method called total-size. A good way to factor out common behavior of classes is to put the common behavior into a role:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

role Path {
    has $.name;
    has $.size;
    method total-size() { ... }
}

class File does Path {
    method total-size() { $.size }
}

class Directory does Path {
    has @.children;
    has $!total-size;
    method total-size() {
        $!total-size //= $.size + @.children.map(*.total-size).sum;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A role looks structurally similar to a class, and using the does keyword in the class declaration applies the role to the class. This role application copies attributes and methods into the target class, but with some additional compile- time checks. One such check is that a class must implement stubbed-out methods like method total-size, where the …​ as the method body marked it as a stub. In addition, when you apply multiple roles to the same class, name clashes are detected and throw an error unless you implement the method in the class for disambiguation.</p>
</div>
<div class="paragraph">
<p>Roles are the preferred method of code reuse (apart from delegation) in Raku, because of the safety features mentioned previously.</p>
</div>
<div class="paragraph">
<p>Now that File and Directory have a common role, you can use that role as a type constraint for subroutines that expect one of these types, such as sub <code>subdivide(Path $tree, $lower, $upper, &amp;todo)</code>.</p>
</div>
<div class="paragraph">
<p>Finally, the type argument to sub MAIN can have two possible values: flame for flame graphs or tree for tree maps. A data structure that models this behavior is an enum or enumeration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

enum GraphType &lt;flame tree&gt;;

sub MAIN($dir = &#39;.&#39;, GraphType :$type=flame) {
    my $tree = tree($dir.IO);
    use SVG;
    my $width = 1024;
    my $height = 768;
    my &amp;grapher = $type == flame ?? &amp;flame-graph !! &amp;tree-map;
    say SVG.serialize(
        :svg[
            :$width,
            :$height,
            | do gather grapher $tree, x1 =&gt; 0, x2 =&gt; $width, y1 =&gt; 0, y2 =&gt; $height
        ]
    );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The values of an enum are integers starting from zero, hence the comparison with == instead of eq. You can access the possible values of an enum either as short identifiers (flame) or through the namespace of the enum type, GraphType::flame.</p>
</div>
<div class="paragraph">
<p>Now if you obtain a help message from the script (by running it with the --help option), the type argument is automatically documented: --type=&lt;GraphType&gt; (flame tree).</p>
</div>
</div>
<div class="sect2">
<h3 id="_explore">10.7. Explore!</h3>
<div class="paragraph">
<p>To get familiar with the functional programming concept, I encourage you to look through the code you’ve written so far and refactor near-duplicate code blocks into a common base and to swap out the code that differs into callbacks.</p>
</div>
<div class="paragraph">
<p>More importantly, try to find abstractions that make sense. In the visualization examples, the underlying principle is divide and conquer.5 Can you come up with a general divide and conquer implementation that is still useful?</p>
</div>
<div class="paragraph">
<p>Thinking back to the tree map and flame graphs, maybe you can separate the logic for sizing rectangles from the logic for placing the rectangles?</p>
</div>
</div>
<div class="sect2">
<h3 id="_summary">10.8. Summary</h3>
<div class="paragraph">
<p>Functional programming offers techniques for extracting common logic into separate functions. The desired differences in behavior can be encoded in more functions that you pass in as arguments to other functions.</p>
</div>
<div class="paragraph">
<p>Raku supports functional programming by making functions first class, so you can pass them around as ordinary objects. It also offers closures (access to outer lexical variables from functions) and various shortcuts that make it more pleasant to write short functions.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_unicode_搜索工具">11. Unicode 搜索工具</h2>
<div class="sectionbody">
<div class="paragraph">
<p>每隔一段时间，我都要对一些 Unicode 字符进行识别或研究。在 Perl 5 发行版 App:::Uni<sup class="footnote">[<a id="_footnoteref_62" class="footnote" href="#_footnotedef_62" title="View footnote.">62</a>]</sup> 中有一个叫 uni<sup class="footnote">[<a id="_footnoteref_63" class="footnote" href="#_footnotedef_63" title="View footnote.">63</a>]</sup> 的工具，由 Audrey Tang 和 Ricardo Signes 开发。</p>
</div>
<div class="paragraph">
<p>让我们用几行 Raku 代码来重新实现它的基本功能，并以此为契机来谈谈 Raku 中对 Unicode 的支持。</p>
</div>
<div class="paragraph">
<p>如果你在命令行中给它一个字符，它就会打印出下面的字符描述。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ uni њ
њ - U+0045a - CYRILLIC SMALL LETTER NJE</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你给它一个较长的字符串，它将在 Unicode 字符名列表中搜索，并为每个描述与搜索字符串匹配的字符打印出相同的信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ uni third|head -n3
1⁄3 - U+02153 - VULGAR FRACTION ONE THIRD
2⁄3 - U+02154 - VULGAR FRACTION TWO THIRDS
↉  - U+02189 - VULGAR FRACTION ZERO THIRDS</code></pre>
</div>
</div>
<div class="paragraph">
<p>每一行都对应于 Unicode 所说的 &#34;代码点&#34;，通常是一个字符本身，但偶尔也会有像 U+00300-COMBINING GRAVE ACCENT 这样的字符，它与一个 U+00061-LATIN SMALL LETTER A 结合起来，就形成了字符 à。</p>
</div>
<div class="paragraph">
<p>Raku 在 Str 和 Int 类中都提供了一个 <code>uniname</code> 方法，它可以为给定的字符生成 Unicode 代码点名称，可以是直接的字符形式，也可以是代码点编号的形式。 有了这个，第一部分 uni 所需的功能看起来是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku
use v6;
sub format-codepoint(Int $codepoint) {
    sprintf &#34;%s - U+%05x - %s\n&#34;,
        $codepoint.chr,
        $codepoint,
        $codepoint.uniname;
}

multi sub MAIN(Str $x where .chars == 1) {
    print format-codepoint($x.ord);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们来看看实际操作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ uni ø
ø - U+000f8 - LATIN SMALL LETTER O WITH STROKE</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>chr</code> 方法将代码点编号转化为字符，<code>ord</code> 方法则相反：换句话说，从字符到代码点编号。</p>
</div>
<div class="paragraph">
<p>第二部分，在所有 Unicode 字符名中进行搜索，其工作原理是通过粗暴地枚举所有可能的字符，并通过它们的 <code>uniname</code> 进行搜索:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN($search is copy) {
    $search.=uc;
    for 1..0x10FFFF -&gt; $codepoint {
        if $codepoint.uniname.contains($search) {
            print format-codepoint($codepoint);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为所有的字符名都是大写的，所以搜索项首先用 <code>$search.=uc</code> 来转换为大写，也就是 <code>$search = $search.uc</code> 的简称。默认情况下，参数是只读的，这也是为什么它的声明在这里使用了 <code>is copy</code> 来防止这种情况。</p>
</div>
<div class="paragraph">
<p>我们也可以用一种更函数式的风格来表述它，而不是这种相当命令式的风格。我们可以把它看成是所有字符的列表，我们将其细化到我们感兴趣的字符，最后按照我们想要的方式格式化它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN($search is copy) {
    $search.=uc;
    print (1..0x10FFFF).grep(*.uniname.contains($search))
                       .map(&amp;format-codepoint)
                       .join;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了更容易识别（而不是搜索）一个以上字符的字符串，一个显式选项可以帮助消除歧义:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN($x, Bool :$identify!) {
    print $x.ords.map(&amp;format-codepoint).join;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Str.ords</code> 返回组成该字符串的代码点列表。有了这个多候选的子例程 MAIN，我们可以做这样的事情，例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ uni --identify øre
ø - U+000f8 - LATIN SMALL LETTER O WITH STROKE
r - U+00072 - LATIN SMALL LETTER R
e - U+00065 - LATIN SMALL LETTER E</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_代码点字符集和字节">11.1. 代码点、字符集和字节</h3>
<div class="paragraph">
<p>正如前面提到的，并非所有的代码点都是完全成熟的字符。或者换个说法，有些东西，我们在视觉上认为是一个字符，实际上是由几个代码点组成的。Unicode 将这种由一个基本字符和可能的几个组合字符组成的序列称为字符集。</p>
</div>
<div class="paragraph">
<p>Raku 中的字符串就是基于这些字符集。如果你用 <code>$str.comb</code> 得到一个字符串中的字符列表，或者用 <code>$str.substr.substr(0,4)</code> 提取一个子串，对一个字符串进行正则表达式匹配，确定长度，或者对一个字符串进行任何其他操作，那么这个单位总是字符集。这最符合我们对字符的直观理解，避免了通过 <code>substr</code>、<code>comb</code> 或类似的操作不小心撕开一个逻辑字符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = &#34;ø\c[COMBINING TILDE]&#34;; say $s; # Output: ø̃
say $s.chars; # Output: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uni<sup class="footnote">[<a id="_footnoteref_64" class="footnote" href="#_footnotedef_64" title="View footnote.">64</a>]</sup> 类型类似于字符串，代表了一个代码点的序列。它在边缘情况下很有用，但不支持与 Str<sup class="footnote">[<a id="_footnoteref_65" class="footnote" href="#_footnotedef_65" title="View footnote.">65</a>]</sup> 一样丰富的操作。从 Str 转为 Uni 值的典型方法是使用 NFC、NFD、NFKC 或 NFKD 方法中的一种，这些方法会产生同名的归一化形式的 Uni 值。</p>
</div>
<div class="paragraph">
<p>在 Uni 值下面，你还可以通过选择一个编码来表示字符串作为字节。如果你想从字符串到字节级，可以调用 encode<sup class="footnote">[<a id="_footnoteref_66" class="footnote" href="#_footnotedef_66" title="View footnote.">66</a>]</sup> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $bytes = &#39;Raku&#39;.encode(&#39;UTF-8&#39;); # utf8:0x&lt;50 65 72 6c 20 36&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>UTF-8 是默认的编码，也是 Raku 读取源文件时假定的编码。其结果是做 Blob<sup class="footnote">[<a id="_footnoteref_67" class="footnote" href="#_footnotedef_67" title="View footnote.">67</a>]</sup> 的作用：你可以通过位置索引访问单个字节，比如 <code>$bytes[0]</code>。<code>decode</code> 方法<sup class="footnote">[<a id="_footnoteref_68" class="footnote" href="#_footnotedef_68" title="View footnote.">68</a>]</sup>可以帮助你将 Blob 转换为 Str。</p>
</div>
<div class="paragraph">
<p>如果你用 <code>say()</code> 打印出一个 <code>Blob</code>，你会得到一个十六进制字节的字符串表示。访问单个字节会产生一个整数，因此通常会以十进制的形式打印出来。</p>
</div>
<div class="paragraph">
<p>如果你想打印出 blob 的原始字节，你可以使用 I/O 句柄的 <code>write</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$*OUT.write(&#39;Raku&#39;.encode(&#39;UTF-8&#39;));</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_数字">11.2. 数字</h3>
<div class="paragraph">
<p>Raku 中的数字字面值并不限于我们在英语国家习惯的阿拉伯数字。所有的 Unicode 代码点都允许使用 Decimal_Number(简称 Nd)属性，所以你可以使用东方阿拉伯数字<sup class="footnote">[<a id="_footnoteref_69" class="footnote" href="#_footnotedef_69" title="View footnote.">69</a>]</sup>、或其他许多脚本中的数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ٤٢; # 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于字符串与数字之间的转换也是如此:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;٤٢&#34;.Int; # 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于其他的数字代码点，可以用 <code>unival</code> 方法获得其数值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;\c[TIBETAN DIGIT HALF ZERO]&#34;.unival;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它输出了 <code>-0.5</code>，同时也说明了如何在字符串字面值中使用代码点的名称。</p>
</div>
</div>
<div class="sect2">
<h3 id="_其它_unicode_属性">11.3. 其它 Unicode 属性</h3>
<div class="paragraph">
<p>类型 Str 中的 `uniprop`<sup class="footnote">[<a id="_footnoteref_70" class="footnote" href="#_footnotedef_70" title="View footnote.">70</a>]</sup> 方法默认返回一般类别:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;ø&#34;.uniprop;                           # Ll
say &#34;\c[TIBETAN DIGIT HALF ZERO]&#34;.uniprop; # No</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回值需要一定的 Unicode 知识才能理解，或者可以阅读 Unicode 的技术报告44<sup class="footnote">[<a id="_footnoteref_71" class="footnote" href="#_footnotedef_71" title="View footnote.">71</a>]</sup>来了解一下具体的细节。Ll 代表 Letter_Lowercase，No 是 Other_Number。这就是 Unicode 所说的 General Category，但是你也可以用 uniprop（或者 uniprop-bool 方法，如果你只对布尔结果感兴趣的话）询问其他属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;a&#34;.uniprop-bool(&#39;ASCII_Hex_Digit&#39;); # True
say &#34;ü&#34;.uniprop-bool(&#39;Numeric_Type&#39;);    # False
say &#34;.&#34;.uniprop(&#34;Word_Break&#34;);           # MidNumLet</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_排序">11.4. 排序</h3>
<div class="paragraph">
<p>当你不限于 ASCII 字符时，字符串的排序就开始变得复杂了。Raku 的排序方法使用 <code>cmp</code> 中缀运算符，它基于代码点编号做一个相当标准的按字母顺序的比较。</p>
</div>
<div class="paragraph">
<p>如果你需要使用更复杂的整理算法，Rakudo 2017.02 和更新版本提供了 Unicode 排序算法<sup class="footnote">[<a id="_footnoteref_72" class="footnote" href="#_footnotedef_72" title="View footnote.">72</a>]</sup> 作为实验性功能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @list = &lt;a ö ä Ä o ø&gt;;
say @list.sort;                    # (a o Ä ä ö ø)

use experimental :collation;
say @list.collate;                 # (a ä Ä o ö ø)

$*COLLATION.set(:tertiary(False));
say @list.collate;                 # (a Ä ä o ö ø)</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认的 <code>sort</code> 认为任何带标点符号的字符都比 ASCII 字符大，因为它们在代码点列表中就是这样出现的。另一方面，<code>collate</code> 知道带标点符号的字符直接属于其基本字符之后，这在每一种语言中并不完美，但在内部是一个很好的折中方案。</p>
</div>
<div class="paragraph">
<p>对于基于拉丁文的脚本，主要的排序标准是字母表，其次的是变音符号，第三种是大小写。因此，<code>$*COLLATION.set(:tertiary(False))</code> 使得 <code>.collate</code> 忽略了大小写，不再强制小写字符排在大写字符之前。</p>
</div>
<div class="paragraph">
<p>在写这篇文章的时候，Raku 还没有实现特定语言的排序。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_9">11.5. 总结</h3>
<div class="paragraph">
<p>Raku 非常重视英语以外的其他语言，并不遗余力地帮助用户使用这些语言和它们所使用的字符。</p>
</div>
<div class="paragraph">
<p>这包括将字符串建立在字符集而不是代码点上，支持数字中的非阿拉伯数字，以及通过内置方法访问 Unicode 数据库的大部分内容。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_使用_inine_python_和_matplotlib_画图">12. 使用 Inine-Python 和 Matplotlib 画图</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Occasionally I come across git repositories where I want to know how active they are and who the main developers are.</p>
</div>
<div class="paragraph">
<p>Let’s develop a script that plots the commit history, and explore how to use Python modules in Raku.</p>
</div>
<div class="sect2">
<h3 id="_提取状态">12.1. 提取状态</h3>
<div class="paragraph">
<p>We want to plot the number of commits by author and date. We can get this information easily by passing some options to git log:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $proc = run :out, &lt;git log --date=short --pretty=format:%ad!%an&gt;;
my (%total, %by-author, %dates);
for $proc.out.lines -&gt; $line {
    my ( $date, $author ) = $line.split: &#39;!&#39;, 2;
    %total{$author}++;
    %by-author{$author}{$date}++;
    %dates{$date}++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>run executes an external command and :out tells it to capture the command’s output, making it available as $proc.out. The command is a list, with the first element being the actual executable and the rest being command-line arguments to this executable.</p>
</div>
<div class="paragraph">
<p>Here git log gets the options --date short --pretty=format:%ad!%an, which instructs it to produce lines like2017-03-01!John Doe.This line can be parsed with a simple call to $line.split: &#39;!&#39;, 2,which splits onthe! and limits the result to two elements.Assigning it to a two-element list( $date, $author ) unpacks it.We then use hashes to count commits by author(in %total), by author and date (%by-author), and finally by date. In the second case,%by-author{$author} isn’t even a hash yet and we can still hash-index it. This is due to a feature called autovivification, which automatically creates (“vivifies”) objects where we need them. The use of ++ creates integers, {…​} indexing creates hashes, […​] indexing, .push creates arrays, and so on.</p>
</div>
<div class="paragraph">
<p>To get from these hashes to the top contributors by commit count, we can sort %total by value. Since this sorts in ascending order, sorting by the negative value returns the list in descending order. The list contains Pair1 objects, where we only want the first five, and only their keys:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my @top-authors = %total.sort(-*.value).head(5).map(*.key);</code></pre>
</div>
</div>
<div class="paragraph">
<p>For each author, we can extract the dates of their activity and their commit counts like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my @dates = %by-author{$author}.keys.sort;
my @counts = %by-author{$author}{@dates};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last line uses slicing, that is, indexing a hash with a list to return a list of elements.</p>
</div>
</div>
<div class="sect2">
<h3 id="_plotting_with_python">12.2. Plotting with Python</h3>
<div class="paragraph">
<p>Matplotlib is a very versatile library for all sorts of plotting and visualization tasks. It is based on NumPy,2 a Python library for scientific and numeric computing.</p>
</div>
<div class="paragraph">
<p>Matplotlib3 is written in Python and for Python programs, but that won’t stop us from using it in a Raku program.</p>
</div>
<div class="paragraph">
<p>But first, let’s take a look at a basic plotting example that uses dates on the x axis:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">import datetime
import matplotlib.pyplot as plt
fig, subplots = plt.subplots()
subplots.plot(
    [datetime.date(2017, 1, 5), datetime.date(2017, 3, 5),
    datetime.date(2017, 5, 5)],
    [ 42, 23, 42 ],
    label=&#39;An example&#39;,
)

subplots.legend(loc=&#39;upper center&#39;, shadow=True)
fig.autofmt_xdate()
plt.show()</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make this run, you have to install Python 2.7 and matplotlib.4 You can do this on Debian-based Linux systems with <code>apt-get install -y python-matplotlib</code>. The package name is the same on RPM-based distributions such as CentOS or SUSE Linux. MacOS users are advised to install Python 2.7 through homebrew or macports and then use <code>pip2 install matplotlib</code> or <code>pip2.7 install matplotlib</code> to get the library. Windows installation is probably easiest through the conda5 package manager, which offers prebuilt binaries of both Python and matplotlib.</p>
</div>
<div class="paragraph">
<p>When you run this script with python2.7 dates.py, it opens a GUI window, showing the plot and some controls, which allow you to zoom, scroll, and write the plot graphic to a file (Figure 12-1):</p>
</div>
</div>
<div class="sect2">
<h3 id="_bridging_the_gap">12.3. Bridging the Gap</h3>
<div class="paragraph">
<p>The Rakudo Raku compiler comes with a handy library for calling foreign functions6—called ‘NativeCall’—which allows you to call functions written in C, or anything with a compatible binary interface.</p>
</div>
<div class="paragraph">
<p>The Inline::Python7 library uses the native call functionality to talk to Python’s C API and offers interoperability between Raku and Python code. At the time of writing, this interoperability is still fragile in places, but can be worth using for some of the great libraries that Python has to offer.</p>
</div>
<div class="paragraph">
<p>To install Inline::Python, you must have a C compiler available, and then run</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ zef install Inline::Python</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you can start to run Python 2 code in your Raku programs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use Inline::Python;

my $py = Inline::Python.new;
$py.run: &#39;print(&#34;Hello, Raku&#34;)&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Besides the run method, which takes a string of Python code and executes it, you can also use call to call Python routines by specifying the namespace, the routine to call, and a list of arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use Inline::Python;

my $py = Inline::Python.new;
$py.run(&#39;import datetime&#39;);
my $date = $py.call(&#39;datetime&#39;, &#39;date&#39;, 2017, 1, 31);
$py.call(&#39;__builtin__&#39;, &#39;print&#39;, $date); # 2017-01-31</code></pre>
</div>
</div>
<div class="paragraph">
<p>The arguments that you pass to call are Raku objects, such as the three Int objects in this example. Inline::Python automatically translates them into the corresponding Python built-in data structure. It translates numbers, strings, arrays, and hashes. Return values are also translated in the opposite direction, though since Python 2 does not distinguish properly between byte and Unicode strings, Python strings end up as buffers in Raku.</p>
</div>
<div class="paragraph">
<p>Objects that Inline::Python cannot translate are handled as opaque objects on the Raku side. You can pass them back into Python routines(as shown with the preceding print call) and you can call methods on them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

say $date.isoformat().decode; # 2017-01-31</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku exposes attributes through methods, so Raku has no syntax for accessing attributes from foreign objects directly. For instance, if you try to access the year attribute of datetime.date through the normal method call syntax, you get an error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

say $date.year;</code></pre>
</div>
</div>
<div class="paragraph">
<p>dies with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">&#39;int&#39; object is not callable</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead, you have to use the getattr builtin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

say $py.call(&#39;__builtin__&#39;, &#39;getattr&#39;, $date, &#39;year&#39;);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_bridge_to_plot">12.4. Using the Bridge to Plot</h3>
<div class="paragraph">
<p>We need access to two namespaces in Python, datetime and matplotlib.pyplot, so let’s start by importing them and writing some short helpers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $py = Inline::Python.new;
$py.run(&#39;import datetime&#39;);
$py.run(&#39;import matplotlib.pyplot&#39;);
sub plot(Str $name, |c) {
    $py.call(&#39;matplotlib.pyplot&#39;, $name, |c);
}

sub pydate(Str $d) {
    $py.call(&#39;datetime&#39;, &#39;date&#39;, $d.split(&#39;-&#39;).map(*.Int));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can now call pydate(&#39;2017-03-01&#39;) to create a Python datetime. date object from an ISO-formatted string and call the plot function to access functionality from matplotlib:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my ($figure, $subplots) = plot(&#39;subplots&#39;);
$figure.autofmt_xdate();

my @dates = %dates.keys.sort;

$subplots.plot:
    $[@dates.map(&amp;pydate)],
    $[ %dates{@dates} ],
    label     =&gt; &#39;Total&#39;,
    marker    =&gt; &#39;.&#39;,
    linestyle =&gt; &#39;&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Raku call plot(&#39;subplots&#39;) corresponds to the Python code fig, subplots = plt.subplots(). Passing arrays to Python functions needs a bit of extra work, because Inline::Python flattens arrays. Using an extra $ sigil in front of an array puts it into an extra scalar and thus prevents the flattening.</p>
</div>
<div class="paragraph">
<p>Now we can actually plot the number of commits by author, add a legend, and plot the result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

for @top-authors -&gt; $author {
    my @dates = %by-author{$author}.keys.sort;
    my @counts = %by-author{$author}{@dates};
    $subplots.plot:
        $[ @dates.map(&amp;pydate) ],
        $@counts,
        label     =&gt; $author,
        marker    =&gt;&#39;.&#39;,
        linestyle =&gt; &#39;&#39;;
}

$subplots.legend(loc=&gt;&#39;upper center&#39;, shadow=&gt;True);
plot(&#39;title&#39;, &#39;Contributions per day&#39;);
plot(&#39;show&#39;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>When run in the zef git repository,8 it produces the plot shown in Figure 12-2:</p>
</div>
</div>
<div class="sect2">
<h3 id="_stacked_plots">12.5. Stacked Plots</h3>
<div class="paragraph">
<p>I am not yet happy with the plot, so I want to explore using stacked plots for presenting the same information. In a regular plot, the y coordinate of each plotted value is proportional to its value. In a stacked plot, it is the distance to the previous value that is proportional to its value. This is nice for values that add up to a total that is also interesting.</p>
</div>
<div class="paragraph">
<p>Matplotlib offers a method called stackplot9 for this task. Contrary to multiple plot calls on a subplot object, it requires a shared x axis for all data series. Hence we must construct one array for each author of git commits, where dates with no value are set to zero.</p>
</div>
<div class="paragraph">
<p>This time we have to construct an array of arrays where each inner array has the values for one author:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my @dates = %dates.keys.sort;
my @stack = $[] xx @top-authors;

for @dates -&gt; $d {
    for @top-authors.kv -&gt; $idx, $author {
        @stack[$idx].push: %by-author{$author}{$d} // 0;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now plotting becomes a simple matter of a method call, followed by the usual commands to add a title and show the plot:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

$subplots.stackplot($[@dates.map(&amp;pydate)], @stack);
plot(&#39;title&#39;, &#39;Contributions per day&#39;);
plot(&#39;show&#39;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result (again run on the zef source repository) is shown in Figure 12-3:</p>
</div>
<div class="paragraph">
<p>Comparing this to the previous visualization reveals a discrepancy: there were no commits in 2014, and yet the stacked plot makes it appear this way. In fact, the previous plots would have shown the same “alternative facts” if we had chosen lines instead of points. It comes from matplotlib (like nearly all plotting libraries) interpolating linearly between data points. But in our case, a date with no data points means zero commits happened on that date.</p>
</div>
<div class="paragraph">
<p>To communicate this to matplotlib, we must explicitly insert zero values for missing dates. This can be achieved by replacing</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my @dates = %dates.keys.sort;</code></pre>
</div>
</div>
<div class="paragraph">
<p>with the line</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my @dates = %dates.keys.minmax;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The minmax method10 finds the minimal and maximal values, and returns them in a Range.11 Assigning the range to an array turns it into an array of all values between the minimal and the maximal value. The logic for assembling the @stack variable already maps missing values to zero.</p>
</div>
<div class="paragraph">
<p>The result looks a bit better, but still far from perfect (Figure 12-4):</p>
</div>
<div class="paragraph">
<p>Thinking more about the problem, contributions from separate days should not be joined together, because it produces misleading results. Matplotlib doesn’t support adding a legend automatically to stacked plots, so this seems to be to be a dead end.</p>
</div>
<div class="paragraph">
<p>Since a dot plot didn’t work very well, let’s try a different kind of plot that represents each data point separately: a bar chart, or more specifically, a stacked bar chart. Matplotlib offers the bar plotting method where the named parameter bottom can be used to generate the stacking:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my @dates = %dates.keys.sort;
my @stack = $[] xx @top-authors;
my @bottom = $[] xx @top-authors;

for @dates -&gt; $d {
    my $bottom = 0;
    for @top-authors.kv -&gt; $idx, $author {
        @bottom[$idx].push: $bottom;
        my $value = %by-author{$author}{$d} // 0;
        @stack[$idx].push: $value;
        $bottom += $value;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We need to supply color names ourselves and set the edge color of the bars to the same color, otherwise the black edge color dominates the result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $width = 1.0;
my @colors = &lt;red green blue yellow black&gt;;
my @plots;

for @top-authors.kv -&gt; $idx, $author {
    @plots.push: plot(
        &#39;bar&#39;,
        $[@dates.map(&amp;pydate)],
        @stack[$idx],
        $width,
        bottom =&gt; @bottom[$idx],
        color =&gt; @colors[$idx],
        edgecolor =&gt; @colors[$idx],
    );
}
plot(&#39;legend&#39;, $@plots, $@top-authors);

plot(&#39;title&#39;, &#39;Contributions per day&#39;);
plot(&#39;show&#39;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to improve the result further, you could experiment with limiting the number of bars by lumping together contributions by week or month (or maybe $n-day period).</p>
</div>
</div>
<div class="sect2">
<h3 id="_idiomatic_use_of_inlinepython">12.6. Idiomatic Use of Inline::Python</h3>
<div class="paragraph">
<p>Now that the plots look informative and correct, it’s time to explore how to better emulate the typical Python APIs through Inline::Python.</p>
</div>
<div class="sect3">
<h4 id="_types_of_python_apis">12.6.1. Types of Python APIs</h4>
<div class="paragraph">
<p>Python is an object-oriented language, so many APIs involve method calls, which Inline::Python helpfully automatically translates for us.</p>
</div>
<div class="paragraph">
<p>But the objects must come from somewhere and typically this is by calling a function that returns an object, or by instantiating a class. In Python, those two are really the same under the hood, since instantiating a class is the same as calling the class as if it were a function.</p>
</div>
<div class="paragraph">
<p>If you want to improve the result further, you could experiment with limiting the number of bars by lumping together contributions by week or month (or maybe $n-day period).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_idiomatic_use_of_inlinepython_2">12.7. Idiomatic Use of Inline::Python</h3>
<div class="paragraph">
<p>Now that the plots look informative and correct, it’s time to explore how to better emulate the typical Python APIs through Inline::Python.</p>
</div>
<div class="sect3">
<h4 id="_types_of_python_apis_2">12.7.1. Types of Python APIs</h4>
<div class="paragraph">
<p>Python is an object-oriented language, so many APIs involve method calls, which Inline::Python helpfully automatically translates for us.</p>
</div>
<div class="paragraph">
<p>But the objects must come from somewhere and typically this is by calling a function that returns an object, or by instantiating a class. In Python, those two are really the same under the hood, since instantiating a class is the same as calling the class as if it were a function.</p>
</div>
<div class="paragraph">
<p>An example of this (in Python) would be</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">from matplotlib.pyplot
import subplots result = subplots()</code></pre>
</div>
</div>
<div class="paragraph">
<p>But the matplotlib documentation tends to use another, equivalent syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">import matplotlib.pyplot as plt
result = plt.subplots()</code></pre>
</div>
</div>
<div class="paragraph">
<p>This uses the subplots symbol (class or function) as a method on the module matplotlib.pyplot, which the import statement aliases to plt. This is a more object-oriented syntax for the same API.</p>
</div>
</div>
<div class="sect3">
<h4 id="_mapping_the_function_api">12.7.2. Mapping the Function API</h4>
<div class="paragraph">
<p>The previous code examples used this Perl 6 code to call the subplots symbol:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

my $py = Inline::Python.new;

sub gen(Str $namespace, *@names) {
    $py.run(&#34;import $namespace&#34;);

    return @names.map: -&gt; $name {
        sub (|args) {
            $py.call($namespace, $name, |args);
        }
    }
}

my (&amp;subplots, &amp;bar, &amp;legend, &amp;title, &amp;show)
    = gen(&#39;matplotlib.pyplot&#39;, &lt;subplots bar legend title show&gt;);

my ($figure, $subplots) = subplots();

# more code here

legend($@plots, $@top-authors);
title(&#39;Contributions per day&#39;);
show();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This makes the functions’ usage quite nice, but comes at the cost of duplicating their names. One can view this as a feature, because it allows the creation of different aliases, or as a source for bugs when the order is messed up, or a name misspelled.</p>
</div>
<div class="paragraph">
<p>How could we avoid the duplication should we choose to create wrapper functions?</p>
</div>
<div class="paragraph">
<p>This is where Raku’s flexibility and introspection abilities pay off. There are two key components that allow a nicer solution: the fact that declarations are expressions, and that you can introspect variables for their names.</p>
</div>
<div class="paragraph">
<p>The first part means you can write mysub my ($a, $b), which declares the variables $a and $b, and calls a function with those variables as arguments. The second part means that $a.VAR.name returns a string &#39;$a&#39;, the name of the variable.</p>
</div>
<div class="paragraph">
<p>Let’s combine this to create a wrapper that initializes subroutines for us:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub pysub(Str $namespace, |args) {
    $py.run(&#34;import $namespace&#34;);

    for args[0] &lt;-&gt; $sub {
        my $name = $sub.VAR.name.substr(1);
        $sub = sub (|args) {
            $py.call($namespace, $name, |args);
        }
    }
}

pysub &#39;matplotlib.pyplot&#39;,
    my (&amp;subplots, &amp;bar, &amp;legend, &amp;title, &amp;show);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This avoids duplicating the name, but forces us to use some lower-level
Raku features in sub pysub. Using ordinary variables means that accessing their .VAR.name results in the name of the variable, not the name of the variable that’s used on the caller side. So we can’t use slurpy arguments as in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub pysub(Str $namespace, *@subs)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead we must use |args to obtain the rest of the arguments in a Capture.12 This doesn’t flatten the list of variables passed to the function, so when we iterate over them, we must do so by accessing args[0]. By default, loop variables are read-only, which we can avoid by using &lt;→ instead of → to introduce the signature. Fortunately, that also preserves the name of the caller side variable.</p>
</div>
</div>
<div class="sect3">
<h4 id="_an_object_oriented_interface">12.7.3. An Object-Oriented Interface</h4>
<div class="paragraph">
<p>Instead of exposing the functions, we can also create types that emulate the method calls on Python modules. For that, we can implement a class with a method FALLBACK, which Raku calls for us when calling a method that is not implemented in the class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

class PyPlot is Mu {
    has $.py;
    submethod TWEAK {
        $!py.run(&#39;import matplotlib.pyplot&#39;);
    }
    method FALLBACK($name, |args) {
        $!py.call(&#39;matplotlib.pyplot&#39;, $name, |args);
    }
}

my $pyplot = PyPlot.new(:$py);
my ($figure, $subplots) = $pyplot.subplots;
# plotting code goes here
$pyplot.legend($@plots, $@top-authors);

$pyplot.title(&#39;Contributions per day&#39;);
$pyplot.show;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Class PyPlot inherits directly from Mu, the root of the Raku type hierarchy, instead of Any, the default parent class (which in turn inherits from Mu). Any introduces a large number of methods that Raku objects get by default, and since FALLBACK is only invoked when a method is not present, this is something to avoid.</p>
</div>
<div class="paragraph">
<p>The method TWEAK is another method that Raku calls automatically for us, after the object has been fully instantiated. All-caps method names are reserved for such special purposes. It is marked as a submethod, which means it is not inherited into subclasses. Since TWEAK is called at the level of each class, if it were a regular method, a subclass would call it twice implicitly. Note that TWEAK is only supported in Rakudo version 2016.11 and later.</p>
</div>
<div class="paragraph">
<p>There’s nothing specific to the Python package matplotlib.pyplot in class PyPlot, except the namespace name. We could easily generalize it to any namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

class PythonModule is Mu {
    has $.py;
    has $.namespace;
    submethod TWEAK {
        $!py.run(&#34;import $!namespace&#34;);
    }
    method FALLBACK($name, |args) {
        $!py.call($!namespace, $name, |args);
    }
}
my $pyplot = PythonModule.new(:$py, :namespace&lt;matplotlib.pyplot&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is one Raku type that can represent any Python module. If instead we want a separate Raku type for each Python module, we could use roles, which are optionally parameterized:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

role PythonModule[Str $namespace] is Mu {
    has $.py;
    submethod TWEAK {
        $!py.run(&#34;import $namespace&#34;);
    }
    method FALLBACK($name, |args) {
        $!py.call($namespace, $name, |args);
    }
}

my $pyplot = PythonModule[&#39;matplotlib.pyplot&#39;].new(:$py);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using this approach, we can create type constraints for Python modules in Raku space:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

sub plot-histogram(PythonModule[&#39;matplotlib.pyplot&#39;], @data) {
    # implementation here
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Passing in any wrapped Python module other than matplotlib.pyplot results in a type error.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_10">12.8. 总结</h3>
<div class="paragraph">
<p>We’ve explored several ways to represent commit occurrence in plots and utilized Inline::Python to interface with a Python-based plotting library.</p>
</div>
<div class="paragraph">
<p>A bit of Raku metaprogramming allowed us to emulate different kinds of Python APIs pretty directly in Raku code, allowing a fairly direct translation of the original library’s documentation into Raku code.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_接下来是什么">13. 接下来是什么</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果你读了这本书，你很可能现在已经对 Raku 的基本知识有了扎实的掌握。</p>
</div>
<div class="paragraph">
<p>本书的例子和讨论涉及到了各种各样的主题。我们从什么是 Raku 开始，以及如何运行 Raku 程序。接下来是 Raku 程序的基本词法结构、变量、控制流和 I/O。更高级的主题包括面向对象、持久化、正则表达式和 grammar、Unicode 支持、并发，最后是通过 <code>Inline::Python</code> 使用外部库。</p>
</div>
<div class="paragraph">
<p>但要写出成功的 Raku 代码，除了学习语言本身，还有更多的内容。在这最后一章中，我想暗示一些你可能想要学习的主题，以帮助你保持你的代码库的可维护性，并让它成功地呈现在用户面前。</p>
</div>
<div class="sect2">
<h3 id="_扩展你的代码库">13.1. 扩展你的代码库</h3>
<div class="paragraph">
<p>当你的代码库增长时，通常建议你把它拆成单独的文件。你可以创建包含你的逻辑的模块，按命名空间和功能来组织。然后这些脚本往往会成为浅层次的入口，解析命令行参数，加载模块，然后调用一个函数或方法来完成实际工作。</p>
</div>
<div class="paragraph">
<p>在这种情况下，测试被写成单独的脚本，通常在一个名为 <code>t</code> 的目录下，加载和测试相同的模块。</p>
</div>
<div class="paragraph">
<p>在 <a href="https://docs.raku.org/language/modules">https://docs.raku.org/language/modules</a> 的官方文档中解释了如何编写模块，以及模块安装程序 zef（和其他工具）所依赖的标准目录布局和元数据。</p>
</div>
<div class="paragraph">
<p>随着你的代码库的增长，类型注解可以帮助你跟踪例程接受哪些参数，以及它们返回哪些参数。我倾向于在公共 API 的签名中使用类型注解。我所说的&#34;公共&#34;指的是可以从模块外访问的例程。在例程中，为了简洁和灵活，我倾向于省略它们。</p>
</div>
<div class="paragraph">
<p>为了使类型约束更可重用，你可以定义创建 <code>subset</code> 类型。例如，我们已经看到了一个临时类型约束的例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN(Str $date where /^ \d+ \- \d+ \- \d+ $ /) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反，你可以创建一个 <code>subset</code> 类型，并多次使用它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset DateStr of Str where /^ \d+ \- \d+ \- \d+ $ /;

multi sub MAIN(DateStr $date) { ... }
sub parse-date(DateStr) returns Date { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以在一个模块中收集几个这样的类型，并在你需要的地方导入。</p>
</div>
</div>
<div class="sect2">
<h3 id="_打包你的应用">13.2. 打包你的应用</h3>
<div class="paragraph">
<p>为了向用户部署你的应用程序，你通常会把它放在某种自带的存档或包中。</p>
</div>
<div class="paragraph">
<p>与所需的发布格式无关，起始点总是 zef 模块安装程序所使用的目录布局和元数据，在 <a href="https://docs.raku.org/language/modules">https://docs.raku.org/language/modules</a> 可以找到描述。</p>
</div>
<div class="paragraph">
<p>Raku 打包还在积极开发中，所以我想简单地提到一些你可能会发现值得探索的选项，而不是给出食谱。</p>
</div>
<div class="sect3">
<h4 id="_打包为传统的_raku_模块">13.2.1. 打包为传统的 Raku 模块</h4>
<div class="paragraph">
<p>传统上，Raku 模块和软件是以 tar 文件<sup class="footnote">[<a id="_footnoteref_73" class="footnote" href="#_footnotedef_73" title="View footnote.">73</a>]</sup>的形式发布的，其中包含源代码和一些元数据，如 META6.json 文件。</p>
</div>
<div class="paragraph">
<p>用户需要安装了 Raku 二进制文件和 zef。然后他们可以解压压缩包，进入新创建的目录，用 <code>zef install</code> 安装软件。</p>
</div>
<div class="paragraph">
<p>如果你的软件是开源的，你可以通过在 GitHub 上的 Raku 生态系统 git 仓库中发送一个 pull 请求，将其添加到官方的 Raku 生态系统中。拉取请求被接受后（通常只需要几小时或几分钟），用户可以通过 zef 安装你的软件，而不需要自己下载任何软件包。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用_docker_进行部署">13.2.2. 使用 Docker 进行部署</h4>
<div class="paragraph">
<p>传统的 Raku 模块分发依赖于预装的 Raku 编译器，这可能不是所有平台上都有的。</p>
</div>
<div class="paragraph">
<p>如果你选择用 Docker 镜像分发你的应用，你可以基于 rakudo-star 镜像，只需 zef 将你的应用安装到 Docker 容器中即可。</p>
</div>
<div class="paragraph">
<p>这是最基本的 Docker 文件，它建立在预先存在的映像上，并从当前工作目录中安装该 Raku 应用程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">FROM rakudo-star:2017.04
COPY myapp /tmp/install
RUN zef install /tmp/install
ENTRYPOINT [&#34;/usr/share/raku/site/bin/myapp&#34;]</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行 <code>docker build -t myapp .</code> 创建一个 Docker 镜像 myapp，然后你可以将其分发，并包含所有的依赖项。</p>
</div>
</div>
<div class="sect3">
<h4 id="_windows_安装程序">13.2.3. Windows 安装程序</h4>
<div class="paragraph">
<p>模块 App::InstallerMaker::WiX<sup class="footnote">[<a id="_footnoteref_74" class="footnote" href="#_footnotedef_74" title="View footnote.">74</a>]</sup>可以帮助你创建一个 Windows 的 .msi 安装程序，它可以创建一个 Rakudo、zef和你的应用程序的构建。它需要 Microsoft Visual C++ 构建工具和 WiX。<sup class="footnote">[<a id="_footnoteref_75" class="footnote" href="#_footnotedef_75" title="View footnote.">75</a>]</sup>，你可以创建一个描述你的应用程序的 YAML 文件，然后运行脚本 <code>make-raku-wix-installer</code> 来创建一个独立的 .msi 文件。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_结尾感想">13.3. 结尾感想</h3>
<div class="paragraph">
<p>Raku 是一门很大的语言，嵌入了一个更大的社区和生态系统。一本这样的书不可能涵盖所有的东西，但希望它能帮助你学习到足够多的编程任务，更重要的是，它能让你兴奋并有动力去探索和学习更多的东西。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_创建一个_web_服务和声明式_api">14. 创建一个 Web 服务和声明式 API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>现在，似乎每一个软件都必须通过网络、云端来实现。</p>
</div>
<div class="paragraph">
<p>本着这种精神，我们就来看看在 Raku 中使用 Cro 创建网络服务的简单方法，是一套库，它可以让你轻松地编写异步网络客户端和服务。Cro 这个名字来自于一个可怕的双关语：它允许我编写微服务，我的 cro 服务。</p>
</div>
<div class="paragraph">
<p>在本章后面，我们将看看 Cro 是如何实现其声明式 API 的。</p>
</div>
<div class="sect2">
<h3 id="_12_1_开始使用_cro">14.1. 12.1 开始使用 Cro</h3>
<div class="paragraph">
<p>我们将重用第 4 章中的代码，它将 UNIX 时间戳转换为 ISO 格式的日期时间字符串，反之亦然，现在通过 HTTP 将它们公开。</p>
</div>
<div class="paragraph">
<p>第一部分，将 UNIX 时间戳转换为 ISO 日期，是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::HTTP::Router;
use Cro::HTTP::Server;

my $application = route {
    get -&gt; &#39;datetime&#39;, Int $timestamp {
        my $dt = DateTime.new($timestamp);
        content &#39;text/plain&#39;, &#34;$dt\n&#34;;
    }
}

my $port = 8080;
my Cro::Service $service = Cro::HTTP::Server.new(
    :host&lt;0.0.0.0&gt;,
    :$port,
    :$application,
);

$service.start;
say &#34;Application started on port $port&#34;;
react whenever signal(SIGINT) { $service.stop; done; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，我们看到了由 Cro::HTTP::Router 模块导出的子程序 route、get 和 content。</p>
</div>
<div class="paragraph">
<p><code>route</code> 以一个块作为参数，并返回一个应用程序。在块内，我们可以调用 get（或者其他 HTTP 动词函数，如 post 或 put）来声明路由，当有人通过 HTTP 请求匹配的 URL 时，Cro 为我们调用的代码片段。</p>
</div>
<div class="paragraph">
<p>这里，路由声明的开头是 get -&gt; &#39;datetime&#39;, Int $timestamp。箭头→引入了一个签名，Cro 将每个参数解释为一个斜线限制的 URL 的一部分。在我们的例子中，与签名相匹配的 URL 是 <code>/datetime/</code> 后面跟着一个整数，比如 <code>/datetime/1578135634</code>。当 Cro 接收到这样的请求时，它会使用常量字符串 datetime 来识别路由，并将 1578135634 放入变量 <code>$timestamp</code> 中。</p>
</div>
<div class="paragraph">
<p>将时间戳转换为 DateTime 对象的逻辑在第 4 章中已经很熟悉了，唯一不同的是，我们没有使用 say 将结果打印到标准输出，而是使用 content 函数将其回传给 HTTP 请求者。这是必要的，因为每个 HTTP 响应都需要声明它的内容类型，这样，例如，浏览器就知道是否要将响应渲染为 HTML，还是作为图像等。文本/纯文本内容类型顾名思义，表示的是纯文本，不需要以任何特殊的方式来解释。</p>
</div>
<div class="paragraph">
<p>后面的代码是经典的管道：它在给定的 TCP 端口（这里是 8080，可以根据自己的喜好随意更改）实例化一个 Cro::HTTP::Server 对象和我们的一个微薄路由的集合，然后告诉它开始服务 HTTP 请求。我们选择了 0.0.0.0 的主机（意思是绑定到所有 IP 地址），这样如果你在 Docker 容器中运行应用程序，就可以从主机上到达。如果你不使用 Docker，使用 127.0.0.1 或 localhost 是比较安全的，因为它不会将应用程序暴露给网络中的其他机器。</p>
</div>
<div class="paragraph">
<p>最后是 shocker 一行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react whenever signal(SIGINT) { $service.stop; done; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>signal()函数返回一个 Supply，这是一个异步数据流，以下是进程间的通信信号。signal(SIGINT)具体来说只有当进程接收到 INT 或中断信号时才会发出事件，通常可以通过在终端中按 Ctrl+C 键来创建。</p>
</div>
<div class="paragraph">
<p>react 通常以其块形式使用，react { …​. }，由于它只适用于一条语句，所以在这里缩短了。它在 everever 语句中运行并派发耗材，直到代码调用 done 函数（或者所有流完成，对于信号流来说不会发生）。</p>
</div>
<div class="paragraph">
<p>所以，在 react 里面，<code>whenever signal(SIGINT) { …​ }</code> 每次接收到 SIGINT 信号时，都会调用…​标记的代码—​在这种情况下，我们会停止 HTTP 服务器，退出 react 构造。</p>
</div>
<div class="paragraph">
<p>如果你想处理其他信号，比如 SIGTERM（杀系统命令使用的），你可以将 signal(SIGINT)替换为</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">signal(SIGINT).merge(signal(SIGTERM))</code></pre>
</div>
</div>
<div class="paragraph">
<p>当有人按 Ctrl+C 时，所有这些都是一种复杂的退出程序的方式。</p>
</div>
<div class="paragraph">
<p>由于 Cro 的异步性，你也可以在这里做其他的事情，比如处理反应块中的其他用品（比如周期性的计时器、文件变化事件流），而 HTTP 服务器正在欢快地运行。</p>
</div>
<div class="paragraph">
<p>要运行这个，首先用 zef 包管理器安装 cro 和 Cro::HTTP::测试模块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ zef install --/test cro Cro::HTTP::Test</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中的 <code>--/test</code> 选项告诉 zef 不要运行模块测试，这两个选项都需要很长的时间，并且需要一些你不可能有的本地基础设施。</p>
</div>
<div class="paragraph">
<p>如果你使用 Docker 来运行你的 raku 程序，你可以使用镜像 moritzlenz/raku-fundamentals，它建立在 Rakudo Star 上，并包含必要的 cro 模块。如果你走这条路，你还必须使用 docker 的 <code>--expose</code> 命令行选项来使服务在主机上可用；否则，它只能从容器内到达。那么命令行就像这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ docker run --rm --publish 8080:8080 -v $PW/raku -w /raku \
    -it moritzlenz/raku-fundamentals raku datetime.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以在命令行上用 curl4 这样的 HTTP 客户端测试服务。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ curl http://127.0.0.1:8080/datetime/1578135634
2020-01-04T11:00:34Z</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_12_2_扩大服务范围">14.2. 12.2 扩大服务范围</h3>
<div class="paragraph">
<p>现在我们已经有了一个简约而有效的服务，我们可以将 ISO 日期时间字符串转换为 UNIX 时间戳。我们只需要看一下路由块，一切都保持不变。这里有一个实现它的方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my token date-re {
    ^
    \d**4 &#39;-&#39; \d**2 &#39;-&#39; \d** 2 # date part YYYY-MM-DD
    [
    &#39; &#39;
    \d**2 &#39;:&#39; \d**2 &#39;:&#39; \d**2  # time
    ]?
    $
}

my $application = route {
    get -&gt; &#39;datetime&#39;, Int $timestamp {
        my $dt = DateTime.new($timestamp);
        content &#39;text/plain&#39;, &#34;$dt\n&#34;;
    }

    get -&gt; &#39;datetime&#39;, Str $date_spec where &amp;date-re {
        my ( $date_str, $time_str ) = $date_spec.split(&#39; &#39;);
        my $date = Date.new($date_str);

        my $datetime;
        if $time_str {
            my ( $hour, $minute, $second ) = $time_str. split(&#39;:&#39;);
            $datetime = DateTime.new( :$date, :$hour, :$minute, :$second );
        }
        else {
            $datetime = $date.DateTime;
        }
        content &#34;text/plain&#34;, $datetime.posix ~ &#34;\n&#34;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们先用一个 regex 定义我们要接受的日期时间格式，并将其存储在变量 <code>&amp;date-re</code> 中。然后在路由 <code>{ …​ }</code> 块中，我们添加了第二个带有这个签名的 get 调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;datetime&#39;, Str $date_spec where &amp;date-re { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就定义了第二个路由，和之前的 url 类似，<code>/datetime/YYYY-MM-DD HH:MM:SS</code> (其中时间部分是可选的)。这些逻辑同样是复制自第 4 章，所以没有什么惊喜。唯一不同的是，在命令行程序中，命令行分析器为我们分割了日期和时间部分，现在我们通过调用 <code>.split(&#39; &#39;)</code> 来明确分割。</p>
</div>
<div class="paragraph">
<p>当我们用 curl 或浏览器测试这段代码时，我们需要记住，我们不能直接在 URL 中直接包含空格，而是需要将其转义为%20。启动我们的扩展服务后，我们可以再次调用 curl 进行测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ curl http://127.0.0.1:8080/datetime/2020-01-04%2011:00:34
1578135634</code></pre>
</div>
</div>
<div class="paragraph">
<p>大多数现代 Web 服务倾向于用 JSON 数据来响应，我们可以通过向内容函数传递一个 JSON 可序列化的数据结构（如哈希）来实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># in the first route
content &#39;application/json&#39;, {
    input =&gt; $timestamp,
    result =&gt; $dt.Str,
}
# in the second route
content &#34;application/json&#34;, {
    input =&gt; $date_spec,
    result =&gt; $datetime.posix,
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_12_3_测试">14.3. 12.3 测试</h3>
<div class="paragraph">
<p>测试一个 Web 应用程序有时是一件很痛苦的事情。你必须启动应用服务器，但首先你需要找到一个可以监听的空闲端口，然后你向服务器发出请求，之后再拆掉它。</p>
</div>
<div class="paragraph">
<p>通过一点点的重组和 Cro::HTTP::测试模块，这一切都可以避免。</p>
</div>
<div class="paragraph">
<p>对于重组，让我们把对路由的调用放到我们自己的一个子程序中，把服务器的设置放到一个 MAIN 函数中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub routes() {
    return route {
        # same route definitions as before
    }
}

multi sub MAIN(Int :$port = 8080, :$host = &#39;0.0.0.0&#39;) {
    my Cro::Service $service = Cro::HTTP::Server.new(
        :$host
        :$port,
        application =&gt; routes(),
    );
    $service.start;
    say &#34;Application started on port $port&#34;;
    react whenever signal(SIGINT) { $service.stop; done; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以像以前一样启动 HTTP 服务器，现在的好处是可以通过命令行覆盖端口和主机（服务器监听的 IP）。</p>
</div>
<div class="paragraph">
<p>我们的目标是测试，所以让我们为其添加另一个 multi MAIN。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN(&#39;test&#39;) {
    use Cro::HTTP::Test;
    use Test;
    test-service routes(), {
        test get(&#39;/datetime/1578135634&#39;),
            status =&gt; 200,
            json =&gt; {
                result =&gt; &#34;2020-01-04T11:00:34Z&#34;,
                input =&gt; 1578135634 ,
            };
        test get(&#39;/datetime/2020-01-04%2011:00:34&#39;),
            status =&gt; 200,
            json =&gt; {
                input =&gt; &#39;2020-01-04 11:00:34&#39;,
                result =&gt; 1578135634,
            };

    }
    done-testing;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们来见见我们的新朋友，<code>sub test-service</code>。我们用两个参数来调用它，一个是要测试的路由，另一个是包含我们测试的块。</p>
</div>
<div class="paragraph">
<p>在这个块里面，<code>get()</code> 例程在没有启动任何服务器的情况下调用相应的路由，并返回一个类型为 Cro::HTTP::Test::TestRequest 的对象。通过测试例程，我们可以检查这个测试响应是否满足我们的期望，这里关于响应代码（状态）和 JSON 响应体。</p>
</div>
<div class="paragraph">
<p>我们可以通过添加测试命令行参数来运行测试，得到这样的测试输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku datetime.p6 test
    ok 1 - Status is acceptable
    ok 2 - Content type is recognized as a JSON one
    ok 3 - Body is acceptable
    1..3
ok 1 - GET /datetime/1578135634
    ok 1 - Status is acceptable
    ok 2 - Content type is recognized as a JSON one
    ok 3 - Body is acceptable
    1..3
ok 2 - GET /datetime/2020-01-04%2011:00:34
1..2</code></pre>
</div>
</div>
<div class="paragraph">
<p>每次调用测试都会在输出中产生一个测试，并为每一个单独的比较产生一个子测试（用缩进表示）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_12_4_添加一个网页">14.4. 12.4 添加一个网页</h3>
<div class="paragraph">
<p>我们的迷你网络服务现在已经到了另一个程序可以舒服地通过 JSON 通过 HTTP 与之对话的地步，但这对终端用户来说并不友好。</p>
</div>
<div class="paragraph">
<p>作为一个可能的用户界面的演示，让我们添加一个可以在浏览器中查看的 HTML 页面。由于我们将通过 JavaScript 触发的 HTTP 请求来处理数据，所以我们可以摆脱静态文件的服务。Cro 为此提供了一个名为 <code>static</code> 的助手，它取代了我们对内容的调用。让我们把这两个路由添加到路由 <code>{ …​}</code> 块中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; { static &#39;index.html&#39;; }
get -&gt; &#39;index.js&#39; { static &#39;index.js&#39;; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个签名是空的，所以对应于 <code>/</code> (root)URL，服务于 index.html 文件。第二个是服务于一个名为 index.js 的文件，URL 相同。</p>
</div>
<div class="paragraph">
<p>静态助手可以做更多的事情，比如服务于整个目录，同时防止恶意的路径遍历，5 但对于我们的案例来说，简单的形式就足够了。</p>
</div>
<div class="paragraph">
<p>文件 index.html 应该直接放在 raku 脚本的旁边，可以像这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Datetime to UNIX timestamp conversion&lt;/title&gt;
&lt;script
    src=&#34;https://code.jquery.com/jquery-3.5.1.min.js&#34;
    crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;/index.js&#34;&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;h1&gt;Convert UNIX timestamp to ISO datetime or vice versa&lt;/h1&gt;
&lt;form&gt;
&lt;label for=&#34;in&#34;&gt;Input&lt;/label&gt;
&lt;input name=&#34;in&#34; id=&#34;in&#34; placeholder=&#34;2014-01-14 10:12:00&#34;&gt;&lt;/input&gt;
&lt;button id=&#34;submit&#34;&gt;Submit&lt;/button&gt;
&lt;/form&gt; &lt;h2&gt;Result&lt;/h2&gt;
&lt;ul id=&#34;result&#34;&gt;&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>可见的元素只是一些标题、一个输入表单和一个提交按钮，以及一个空的结果列表。</p>
</div>
<div class="paragraph">
<p>我们将在 index.js 中添加一些 JavaScript 来使其活起来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">$(document).ready(function() { $(&#39;#submit&#39;).click(function(event) {
var val = $(&#39;#in&#39;).val();
$.get(&#39;/datetime/&#39; + val, function(response) {
            $(&#39;#result&#39;).append(
                &#39;&lt;li&gt;Input: &#39; + val +
                &#39;, Result: &#39; + response[&#39;result&#39;] +
                &#39;&lt;/li&gt;&#39;);
});
        event.preventDefault();
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码使用 jQuery6 库，订阅按钮上的点击事件。当按钮被按下时，它会从
的输入元素，异步提交到 URL <code>/datetime/</code>，然后将结果作为列表项追加到无序列表（<code>&lt;ul&gt;</code>）中。</p>
</div>
<div class="paragraph">
<p>这远非完美，因为 Web 应用程序缺少错误处理和视觉吸引力，但它确实说明了如何在你的应用程序中拥有一个漂亮的以机器为中心的 API 端点，然后在上面放一个使用 HTML 和 javascript 的用户界面。</p>
</div>
<div class="paragraph">
<p>图 12-1. 日期时间转换应用的简约型 Web 前端</p>
</div>
<div class="paragraph">
<p>有几个项目旨在保持 JavaScript 代码的可组合性和可维护性，比如 Vue.js,angular 和 React。事实上，Cro 文档中附带了一个使用 React 和 Redux 构建单页应用的教程，如果你想更深入地研究这个主题，你应该遵循这个教程。</p>
</div>
</div>
<div class="sect2">
<h3 id="_12_5_声明式_api">14.5. 12.5 声明式 API</h3>
<div class="paragraph">
<p>我们现在可以通过更多的路由、认证 11 等方式来发展我们的应用，但我想提请大家注意 Cro 是如何创建其 API 的。</p>
</div>
<div class="paragraph">
<p>路由的语法是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;datetime&#39;, Int $timestamp { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的 get 是一个函数调用，所以我们也可以把这个写成</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get(-&gt; &#39;datetime&#39;, Int $timestamp { ... });</code></pre>
</div>
</div>
<div class="paragraph">
<p>箭头→引入了一个带有签名的块。其实这是一个块并不重要，一个普通的子程序也可以。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get( sub (&#39;datetime&#39;, Int $timestamp) { ... } )</code></pre>
</div>
</div>
<div class="paragraph">
<p>其实，没有必要把子程序的声明放在 get 调用里面。我们可以写成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub convert-from-timestamp(&#39;datetime&#39;, Int $timestamp) {
    my $dt = DateTime.new($timestamp);
    content &#39;application/json&#39;, {
        input =&gt; $timestamp,
        result =&gt; $dt.Str,
    }
}

sub convert-from-isodate(&#39;datetime&#39;, Str $date_spec where &amp;date-re) {
    # omitted for brevity
}

my $application = route {
    get &amp;convert-from-timestamp;
    get &amp;convert-from-isodate;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>get 是一个接受另一个函数作为参数的函数，这一点我们在第 12 章中已经看到了。与这些例子不同的是，get 并不只是调用它所接收的函数，它还会反省函数的签名，以确定何时调用它。</p>
</div>
<div class="paragraph">
<p>我们也可以这样做。在前面的例子中，你可以写下</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @params = &amp;convert-from-timestamp.signature.params;
say @params.elems;
say @params[0].type;
say @params[0].constraints;
# =&gt; 2
# =&gt; (Str)
# =&gt; all(datetime)</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过 <code>.signature.params</code> 方法链，我们获得了代表每个函数参数的 Parameter 对象列表；我们可以向它们询问类型、附加约束条件（比如第一个参数上使用的字符串 datetime）、变量名以及更多属性。</p>
</div>
<div class="paragraph">
<p>就像 get 一样，<code>route { …​ }</code> 是一个函数，它在经过一番设置后调用它的参数函数。它设置了一个动态变量，get 会锁定这个变量，这使得 route 能够返回一个对象，这个对象包含了所有对 get 的调用信息，因此也包含了所有的路由。</p>
</div>
<div class="paragraph">
<p>为了说明这个原理，我们试着写一些函数，让你根据类型写出小的调度器，也就是调用第一个匹配类型的函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;d = dispatcher {
    on -&gt; Str  $x { say &#34;String $x&#34; }
    on -&gt; Date $x { say &#34;Date $x&#34;   }
}

d(Date.new(&#39;2020-12-24&#39;));
d(&#34;a test&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了使这个抱负的例子成为一个有效的乐成代码，我们需要两个函数，dispatcher 和 on，它们都以一个可调用的块作为参数，dispatcher 需要声明一个动态变量，on 则执行一些理智性检查，并将其参数添加到动态变量中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub dispatcher(&amp;body) {
    my @*CASES;
    body();
    my @cases = @*CASES;
    return sub (Mu $x) {
        for @cases -&gt; &amp;case {
            if $x ~~ &amp;case.signature.params[0].type {
                return case($x)
            }
        }
        die &#34;No case matched $x&#34;;
    }
}

sub on(&amp;case) {
    die &#34;Called on() outside a dispatcher block&#34;
        unless defined @*CASES;
    unless &amp;case.signature.params == 1 {
        die &#34;on() expects a block with exactly one parameter&#34;
    }
    @*CASES.push: &amp;case;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>子 dispatcher 要把它的动态变量的内容复制到一个词法变量 <code>my @cases</code> 中，因为动态变量的作用范围是它所声明的函数的执行时间，所以在函数 dispatcher 返回后它就不存在了。但是 dispatcher 需要内容来做它的工作，在 case 中迭代，并调用第一个匹配的 case。它在返回的匿名函数中做这件事，这样程序员就可以在多个代码位置重复使用匹配器。</p>
</div>
<div class="paragraph">
<p>在你第一次阅读使用 Cro 的代码时，你可能会认为 route 和 get 构造看起来像语言扩展，相反，它们原来是巧妙地命名为接收其他函数作为参数的函数。你可以在自己的库和框架中使用同样的技术来创建让使用它们的程序员感到自然的接口。</p>
</div>
</div>
<div class="sect2">
<h3 id="_12_6_总结">14.6. 12.6 总结</h3>
<div class="paragraph">
<p>通过 Cro 库，你可以很容易地通过 HTTP 来暴露功能。首先，你在 <code>route { …​}</code> 块中创建一些路由（当有人请求匹配的 URL 时，Cro 会调用这些代码），然后将路由传给 HTTP server 块中创建一些路由（当有人请求匹配的 URL 时，Cro 会调用这些代码），然后将这些路由传递给 HTTP 服务器。你启动服务器，就可以了。</p>
</div>
<div class="paragraph">
<p>每条路由通过调用 content 函数来传达它的响应，指定内容类型和响应体；JSON 序列化会自动为相应的内容类型发生。</p>
</div>
<div class="paragraph">
<p>通过静态 HTML 和 JavaScript，可能借助 JavaScript 应用框架，可以创建一个用户界面。</p>
</div>
<div class="paragraph">
<p>我们也看到了 Cro 是如何通过提供高阶函数（接收其他函数作为参数的函数），并对这些函数的签名进行反省，从而实现其 API 的自然感觉。</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr/>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. <a href="http://gcc.gnu.org/" class="bare">http://gcc.gnu.org/</a>
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. <a href="https://docs.raku.org/type/Range.html" class="bare">https://docs.raku.org/type/Range.html</a>
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. <a href="https://docs.raku.org/routine/say#(IO)_sub_say" class="bare">https://docs.raku.org/routine/say#(IO)_sub_say</a>
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. <a href="https://docs.raku.org/type/Str#routine_substr" class="bare">https://docs.raku.org/type/Str#routine_substr</a>
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. <a href="https://docs.raku.org/type/Str.html#method_trans" class="bare">https://docs.raku.org/type/Str.html#method_trans</a>
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. <a href="https://docs.raku.org/type/Pair" class="bare">https://docs.raku.org/type/Pair</a>
</div>
<div class="footnote" id="_footnotedef_7">
<a href="#_footnoteref_7">7</a>. 也可以使用返回表达式来返回一个值，并立即退出子程序。
</div>
<div class="footnote" id="_footnotedef_8">
<a href="#_footnoteref_8">8</a>. <a href="https://docs.raku.org/type/List#routine_join" class="bare">https://docs.raku.org/type/List#routine_join</a>
</div>
<div class="footnote" id="_footnotedef_9">
<a href="#_footnoteref_9">9</a>. <a href="https://docs.raku.org/type/Str#routine_comb" class="bare">https://docs.raku.org/type/Str#routine_comb</a>
</div>
<div class="footnote" id="_footnotedef_10">
<a href="#_footnoteref_10">10</a>. <a href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics" class="bare">https://en.wikipedia.org/wiki/Scalable_Vector_Graphics</a>
</div>
<div class="footnote" id="_footnotedef_11">
<a href="#_footnoteref_11">11</a>. <a href="https://inkscape.org/" class="bare">https://inkscape.org/</a>
</div>
<div class="footnote" id="_footnotedef_12">
<a href="#_footnoteref_12">12</a>. <a href="https://docs.raku.org/type/DateTime" class="bare">https://docs.raku.org/type/DateTime</a>
</div>
<div class="footnote" id="_footnotedef_13">
<a href="#_footnoteref_13">13</a>. <a href="https://docs.raku.org/type/Date" class="bare">https://docs.raku.org/type/Date</a>
</div>
<div class="footnote" id="_footnotedef_14">
<a href="#_footnoteref_14">14</a>. <a href="https://docs.raku.org/type/IntStr" class="bare">https://docs.raku.org/type/IntStr</a>
</div>
<div class="footnote" id="_footnotedef_15">
<a href="#_footnoteref_15">15</a>. <a href="https://www.iso.org/iso-8601-date-and-time-format.html" class="bare">https://www.iso.org/iso-8601-date-and-time-format.html</a>
</div>
<div class="footnote" id="_footnotedef_16">
<a href="#_footnoteref_16">16</a>. <a href="https://docs.raku.org/type/Junction" class="bare">https://docs.raku.org/type/Junction</a>
</div>
<div class="footnote" id="_footnotedef_17">
<a href="#_footnoteref_17">17</a>. <a href="https://testanything.org/" class="bare">https://testanything.org/</a>
</div>
<div class="footnote" id="_footnotedef_18">
<a href="#_footnoteref_18">18</a>. <a href="http://testanything.org/testing-with-tap/perl.html" class="bare">http://testanything.org/testing-with-tap/perl.html</a>
</div>
<div class="footnote" id="_footnotedef_19">
<a href="#_footnoteref_19">19</a>. <a href="https://docs.raku.org/language/testing" class="bare">https://docs.raku.org/language/testing</a>
</div>
<div class="footnote" id="_footnotedef_20">
<a href="#_footnoteref_20">20</a>. <a href="https://docs.perl6.org/routine/eqv" class="bare">https://docs.perl6.org/routine/eqv</a>
</div>
<div class="footnote" id="_footnotedef_21">
<a href="#_footnoteref_21">21</a>. <a href="https://docs.perl6.org/language/control#with,_orwith,_without" class="bare">https://docs.perl6.org/language/control#with,_orwith,_without</a>
</div>
<div class="footnote" id="_footnotedef_22">
<a href="#_footnoteref_22">22</a>. <a href="http://modules.raku.org/dist/IO::String" class="bare">http://modules.raku.org/dist/IO::String</a>
</div>
<div class="footnote" id="_footnotedef_23">
<a href="#_footnoteref_23">23</a>. <a href="https://docs.raku.org/type/IO::Handle" class="bare">https://docs.raku.org/type/IO::Handle</a>
</div>
<div class="footnote" id="_footnotedef_24">
<a href="#_footnoteref_24">24</a>. <a href="https://docs.raku.org/language/testing.html" class="bare">https://docs.raku.org/language/testing.html</a>
</div>
<div class="footnote" id="_footnotedef_25">
<a href="#_footnoteref_25">25</a>. <a href="https://docs.raku.org/type/Any" class="bare">https://docs.raku.org/type/Any</a>
</div>
<div class="footnote" id="_footnotedef_26">
<a href="#_footnoteref_26">26</a>. <a href="https://en.wikipedia.org/wiki/Cron" class="bare">https://en.wikipedia.org/wiki/Cron</a>
</div>
<div class="footnote" id="_footnotedef_27">
<a href="#_footnoteref_27">27</a>. <a href="https://docs.raku.org/routine/run" class="bare">https://docs.raku.org/routine/run</a>
</div>
<div class="footnote" id="_footnotedef_28">
<a href="#_footnoteref_28">28</a>. <a href="https://docs.raku.org/type/Proc::Async" class="bare">https://docs.raku.org/type/Proc::Async</a>
</div>
<div class="footnote" id="_footnotedef_29">
<a href="#_footnoteref_29">29</a>. <a href="https://docs.raku.org/type/Signature#Slurpy_(A.K.A._variadic)_parameters" class="bare">https://docs.raku.org/type/Signature#Slurpy_(A.K.A._variadic)_parameters</a>
</div>
<div class="footnote" id="_footnotedef_30">
<a href="#_footnoteref_30">30</a>. <a href="https://docs.raku.org/type/Signature#index-entry-parameter_|-Capture_parameters" class="bare">https://docs.raku.org/type/Signature#index-entry-parameter_|-Capture_parameters</a>
</div>
<div class="footnote" id="_footnotedef_31">
<a href="#_footnoteref_31">31</a>. <a href="https://docs.raku.org/type/Supply" class="bare">https://docs.raku.org/type/Supply</a>
</div>
<div class="footnote" id="_footnotedef_32">
<a href="#_footnoteref_32">32</a>. <a href="https://docs.raku.org/type/Promise" class="bare">https://docs.raku.org/type/Promise</a>
</div>
<div class="footnote" id="_footnotedef_33">
<a href="#_footnoteref_33">33</a>. <a href="https://docs.raku.org/type/Proc" class="bare">https://docs.raku.org/type/Proc</a>
</div>
<div class="footnote" id="_footnotedef_34">
<a href="#_footnoteref_34">34</a>. <a href="https://docs.raku.org/language/quoting#Interpolation:_qq" class="bare">https://docs.raku.org/language/quoting#Interpolation:_qq</a>
</div>
<div class="footnote" id="_footnotedef_35">
<a href="#_footnoteref_35">35</a>. <a href="https://docs.raku.org/language/operators#infix_~~" class="bare">https://docs.raku.org/language/operators#infix_~~</a>
</div>
<div class="footnote" id="_footnotedef_36">
<a href="#_footnoteref_36">36</a>. <a href="https://docs.raku.org/type/Proc::Async" class="bare">https://docs.raku.org/type/Proc::Async</a>
</div>
<div class="footnote" id="_footnotedef_37">
<a href="#_footnoteref_37">37</a>. <a href="https://docs.raku.org/type/Failure" class="bare">https://docs.raku.org/type/Failure</a>
</div>
<div class="footnote" id="_footnotedef_38">
<a href="#_footnoteref_38">38</a>. <a href="https://docs.raku.org/type/Supply" class="bare">https://docs.raku.org/type/Supply</a>
</div>
<div class="footnote" id="_footnotedef_39">
<a href="#_footnoteref_39">39</a>. <a href="https://docs.raku.org/type/Supply#method_from-list" class="bare">https://docs.raku.org/type/Supply#method_from-list</a>
</div>
<div class="footnote" id="_footnotedef_40">
<a href="#_footnoteref_40">40</a>. <a href="https://github.com/jnthn/p6-test-scheduler" class="bare">https://github.com/jnthn/p6-test-scheduler</a>
</div>
<div class="footnote" id="_footnotedef_41">
<a href="#_footnoteref_41">41</a>. <a href="https://github.com/jnthn/p6-test-scheduler/issues/1" class="bare">https://github.com/jnthn/p6-test-scheduler/issues/1</a>
</div>
<div class="footnote" id="_footnotedef_42">
<a href="#_footnoteref_42">42</a>. <a href="https://www.sqlite.org/" class="bare">https://www.sqlite.org/</a>
</div>
<div class="footnote" id="_footnotedef_43">
<a href="#_footnoteref_43">43</a>. <a href="http://www.sqlite.org/famous.html" class="bare">http://www.sqlite.org/famous.html</a>
</div>
<div class="footnote" id="_footnotedef_44">
<a href="#_footnoteref_44">44</a>. <a href="https://github.com/perl6/DBIish/" class="bare">https://github.com/perl6/DBIish/</a>
</div>
<div class="footnote" id="_footnotedef_45">
<a href="#_footnoteref_45">45</a>. <a href="https://docs.raku.org/language/quoting#Heredocs:_:to" class="bare">https://docs.raku.org/language/quoting#Heredocs:_:to</a>
</div>
<div class="footnote" id="_footnotedef_46">
<a href="#_footnoteref_46">46</a>. <a href="https://github.com/moritz/json" class="bare">https://github.com/moritz/json</a>
</div>
<div class="footnote" id="_footnotedef_47">
<a href="#_footnoteref_47">47</a>. <a href="https://github.com/timo/json_fast" class="bare">https://github.com/timo/json_fast</a>
</div>
<div class="footnote" id="_footnotedef_48">
<a href="#_footnoteref_48">48</a>. <a href="https://docs.raku.org/type/Promise" class="bare">https://docs.raku.org/type/Promise</a>
</div>
<div class="footnote" id="_footnotedef_49">
<a href="#_footnoteref_49">49</a>. <a href="https://docs.raku.org/type/Channel" class="bare">https://docs.raku.org/type/Channel</a>
</div>
<div class="footnote" id="_footnotedef_50">
<a href="#_footnoteref_50">50</a>. <a href="https://docs.raku.org/type/Supply" class="bare">https://docs.raku.org/type/Supply</a>
</div>
<div class="footnote" id="_footnotedef_51">
<a href="#_footnoteref_51">51</a>. <a href="https://en.wikipedia.org/wiki/Observer_pattern" class="bare">https://en.wikipedia.org/wiki/Observer_pattern</a>
</div>
<div class="footnote" id="_footnotedef_52">
<a href="#_footnoteref_52">52</a>. <a href="https://docs.raku.org/type/Supply#method_act" class="bare">https://docs.raku.org/type/Supply#method_act</a>
</div>
<div class="footnote" id="_footnotedef_53">
<a href="#_footnoteref_53">53</a>. <a href="http://docs.ansible.com/ansible/intro_inventory.html" class="bare">http://docs.ansible.com/ansible/intro_inventory.html</a>
</div>
<div class="footnote" id="_footnotedef_54">
<a href="#_footnoteref_54">54</a>. <a href="https://modules.raku.org/dist/Config::INI" class="bare">https://modules.raku.org/dist/Config::INI</a>
</div>
<div class="footnote" id="_footnotedef_55">
<a href="#_footnoteref_55">55</a>. <a href="https://en.wikipedia.org/wiki/Regular_expression" class="bare">https://en.wikipedia.org/wiki/Regular_expression</a>
</div>
<div class="footnote" id="_footnotedef_56">
<a href="#_footnoteref_56">56</a>. <a href="http://regex.info/blog/2006-09-15/247" class="bare">http://regex.info/blog/2006-09-15/247</a>
</div>
<div class="footnote" id="_footnotedef_57">
<a href="#_footnoteref_57">57</a>. <a href="https://docs.raku.org/type/Match" class="bare">https://docs.raku.org/type/Match</a>
</div>
<div class="footnote" id="_footnotedef_58">
<a href="#_footnoteref_58">58</a>. <a href="https://docs.raku.org/type/Pair" class="bare">https://docs.raku.org/type/Pair</a>
</div>
<div class="footnote" id="_footnotedef_59">
<a href="#_footnoteref_59">59</a>. <a href="https://docs.raku.org/type/Grammar" class="bare">https://docs.raku.org/type/Grammar</a>
</div>
<div class="footnote" id="_footnotedef_60">
<a href="#_footnoteref_60">60</a>. <a href="https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Grammar.nqp" class="bare">https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Grammar.nqp</a>
</div>
<div class="footnote" id="_footnotedef_61">
<a href="#_footnoteref_61">61</a>. <a href="https://en.wikipedia.org/wiki/Comma-separated_values" class="bare">https://en.wikipedia.org/wiki/Comma-separated_values</a>
</div>
<div class="footnote" id="_footnotedef_62">
<a href="#_footnoteref_62">62</a>. <a href="https://metacpan.org/release/App-Uni" class="bare">https://metacpan.org/release/App-Uni</a>
</div>
<div class="footnote" id="_footnotedef_63">
<a href="#_footnoteref_63">63</a>. <a href="https://metacpan.org/pod/uni" class="bare">https://metacpan.org/pod/uni</a>
</div>
<div class="footnote" id="_footnotedef_64">
<a href="#_footnoteref_64">64</a>. <a href="https://docs.raku.org/type/Uni" class="bare">https://docs.raku.org/type/Uni</a>
</div>
<div class="footnote" id="_footnotedef_65">
<a href="#_footnoteref_65">65</a>. <a href="https://docs.raku.org/type/Str" class="bare">https://docs.raku.org/type/Str</a>
</div>
<div class="footnote" id="_footnotedef_66">
<a href="#_footnoteref_66">66</a>. <a href="https://docs.raku.org/type/Str#method_encode" class="bare">https://docs.raku.org/type/Str#method_encode</a>
</div>
<div class="footnote" id="_footnotedef_67">
<a href="#_footnoteref_67">67</a>. <a href="https://docs.raku.org/type/Blob.html" class="bare">https://docs.raku.org/type/Blob.html</a>
</div>
<div class="footnote" id="_footnotedef_68">
<a href="#_footnoteref_68">68</a>. <a href="https://docs.raku.org/type/Blob.html#method_decode" class="bare">https://docs.raku.org/type/Blob.html#method_decode</a>
</div>
<div class="footnote" id="_footnotedef_69">
<a href="#_footnoteref_69">69</a>. <a href="https://en.wikipedia.org/wiki/Eastern_Arabic_numerals" class="bare">https://en.wikipedia.org/wiki/Eastern_Arabic_numerals</a>
</div>
<div class="footnote" id="_footnotedef_70">
<a href="#_footnoteref_70">70</a>. <a href="https://docs.raku.org/type/Str#(Cool)_method_uniprop" class="bare">https://docs.raku.org/type/Str#(Cool)_method_uniprop</a>
</div>
<div class="footnote" id="_footnotedef_71">
<a href="#_footnoteref_71">71</a>. <a href="http://unicode.org/reports/tr44/#Properties" class="bare">http://unicode.org/reports/tr44/#Properties</a>
</div>
<div class="footnote" id="_footnotedef_72">
<a href="#_footnoteref_72">72</a>. <a href="http://unicode.org/reports/tr10/" class="bare">http://unicode.org/reports/tr10/</a>
</div>
<div class="footnote" id="_footnotedef_73">
<a href="#_footnoteref_73">73</a>. <a href="https://github.com/perl6/ecosystem" class="bare">https://github.com/perl6/ecosystem</a>
</div>
<div class="footnote" id="_footnotedef_74">
<a href="#_footnoteref_74">74</a>. <a href="https://modules.raku.org/dist/App::InstallerMaker::WiX" class="bare">https://modules.raku.org/dist/App::InstallerMaker::WiX</a>
</div>
<div class="footnote" id="_footnotedef_75">
<a href="#_footnoteref_75">75</a>. <a href="http://wixtoolset.org/releases/" class="bare">http://wixtoolset.org/releases/</a>
</div>
</div>

</article>


    

  </main><section class="site__search">
    <label class="site__form">
        <p class="form__label">Search around the site</p> 
        <input class="site__search-bar form__input" type="text">
    </label>
    <div class="site__search-bar-results"></div>
</section>
  
  <footer class="site__footer">
    
    
    <p class="footer__sign">© 2020 ohmyraku</p></footer>





<script defer type="text/javascript" src="https://ohmyraku.github.io/js/script.14164ab553b19613ce98aadb54b1ed9a89ae5b056c72b99a4c672e37954f33d67bebe1452b0279025ba889964b51bdf8ec69683933cf427ae67c08ac2cdda7b1.js" integrity="sha512-FBZKtVOxlhPOmKrbVLHtmomuWwVscrmaTGcuN5VPM9Z76&#43;FFKwJ5AluoiZZLUb347GloOTPPQnrmfAisLN2nsQ=="></script>



</body>
</html>