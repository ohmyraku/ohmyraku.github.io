<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>使用 Raku 正则表达式和 Grammars 进行解析 :: 山川异域, 风月同天</title>

<meta name="author" content="ohmyraku">
<meta name="application-name" content="山川异域, 风月同天">
<meta name="description" content="Table of Contents 1. 什么是正则表达式和 Grammar？ 1.1. 使用场景 1.2. 正则或正则表达式 1.3. Raku 正则表达式有什么特别之处   2. Raku 入门 2.1. 安装 Raku 2.2. 使用 Raku 2.3. 获取代码示例 2.4. 使用 Raku 的第一步 2.5. 总结   3. 正则表达式构造块 3.1. 字面量 3.2. 元字符与字面量 3.3. Anchors 3.4. 预定义字符类 3.5. 量词 3.6. 析取 3.7. 连接 3.8. 零宽断言 3.9. 总结   4. 正则表达式和 Raku 代码 4.1. 智能匹配 4.2. 引号形式 4.3. 修饰符 4.4. comb 和 split 4.">
<meta name="robots" content="noodp"/>
<meta name="generator" content="Hugo 0.63.2" />
<meta name="referrer" content="no-referrer" />
<meta name="format-detection" content="telephone=no">

<link rel="canonical" href="https://ohmyraku.github.io/parsing-with-raku-regexes-and-grammars/" />


<link rel="icon" href="https://ohmyraku.github.io/logo.png" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="使用 Raku 正则表达式和 Grammars 进行解析" />
<meta name="twitter:description" content="Table of Contents 1. 什么是正则表达式和 Grammar？ 1.1. 使用场景 1.2. 正则或正则表达式 1.3. Raku 正则表达式有什么特别之处   2. Raku 入门 2.1. 安装 Raku 2.2. 使用 Raku 2.3. 获取代码示例 2.4. 使用 Raku 的第一步 2.5. 总结   3. 正则表达式构造块 3.1. 字面量 3.2. 元字符与字面量 3.3. Anchors 3.4. 预定义字符类 3.5. 量词 3.6. 析取 3.7. 连接 3.8. 零宽断言 3.9. 总结   4. 正则表达式和 Raku 代码 4.1. 智能匹配 4.2. 引号形式 4.3. 修饰符 4.4. comb 和 split 4." />
<meta name="twitter:site" content="https://ohmyraku.github.io" />
<meta name="twitter:creator" content="ohmyraku" />
<meta name="twitter:image" content="https://ohmyraku.github.io/logo.png">
<meta property="og:type" content="article" />
<meta property="og:locale" content="en" />
<meta property="og:name" content="ohmyraku" />
<meta property="og:title" content="使用 Raku 正则表达式和 Grammars 进行解析" />
<meta property="og:url" content="https://ohmyraku.github.io" />
<meta property="og:site_name" content="山川异域, 风月同天" />
<meta property="og:description" content="Table of Contents 1. 什么是正则表达式和 Grammar？ 1.1. 使用场景 1.2. 正则或正则表达式 1.3. Raku 正则表达式有什么特别之处   2. Raku 入门 2.1. 安装 Raku 2.2. 使用 Raku 2.3. 获取代码示例 2.4. 使用 Raku 的第一步 2.5. 总结   3. 正则表达式构造块 3.1. 字面量 3.2. 元字符与字面量 3.3. Anchors 3.4. 预定义字符类 3.5. 量词 3.6. 析取 3.7. 连接 3.8. 零宽断言 3.9. 总结   4. 正则表达式和 Raku 代码 4.1. 智能匹配 4.2. 引号形式 4.3. 修饰符 4.4. comb 和 split 4." />
<script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "Article",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https:\/\/ohmyraku.github.io\/parsing-with-raku-regexes-and-grammars\/"
      },
      "headline": "使用 Raku 正则表达式和 Grammars 进行解析",
      
      "datePublished": "2020-02-05",
      "dateModified": "2020-02-05 15:26:52 \x2b0800 CST",
      "author": {
        "@type": "Person",
        "name": "ohmyraku"
      },
      "description": "Table of Contents 1. 什么是正则表达式和 Grammar？ 1.1. 使用场景 1.2. 正则或正则表达式 1.3. Raku 正则表达式有什么特别之处   2. Raku 入门 2.1. 安装 Raku 2.2. 使用 Raku 2.3. 获取代码示例 2.4. 使用 Raku 的第一步 2.5. 总结   3. 正则表达式构造块 3.1. 字面量 3.2. 元字符与字面量 3.3. Anchors 3.4. 预定义字符类 3.5. 量词 3.6. 析取 3.7. 连接 3.8. 零宽断言 3.9. 总结   4. 正则表达式和 Raku 代码 4.1. 智能匹配 4.2. 引号形式 4.3. 修饰符 4.4. comb 和 split 4.",
      "publisher": {
        "@type": "Organization",
        "name": "https:\/\/ohmyraku.github.io",
        "logo": {
          "@type": "ImageObject",
          "url": "https:\/\/ohmyraku.github.io\/logo.png"
        }
      }
    }
</script><link rel="stylesheet" href="https://ohmyraku.github.io/scss/main.min.84f71d25d375c522a861bb4719728ce6839cf3635b15ca0c7a1b4d799c2dc3399a1d6cb46058a9d8fdbebe9156a8857279cfdeb70aa3862e629de234b5a41fa1.css" integrity="sha512-hPcdJdN1xSKoYbtHGXKM5oOc82NbFcoMehtNeZwtwzmaHWy0YFip2P2&#43;vpFWqIVyec/etwqjhi5ineI0taQfoQ==">
<script>

const theme = window.localStorage.getItem('theme'); 
if (theme && theme !== "1") {
    document.documentElement.classList.add('theme-' + theme);
}
</script>


</head>
<body>
  <main class="site__content">
    <div class="site__page">
  <nav class="site__breadcrumbs">
    <a class="site__breadcrumb" href="https://ohmyraku.github.io/">山川异域, 风月同天</a><a class="site__breadcrumb--active" href="https://ohmyraku.github.io/parsing-with-raku-regexes-and-grammars/">使用 Raku 正则表达式和 Grammars 进行解析</a>
</nav>

<h1 class="page__title">使用 Raku 正则表达式和 Grammars 进行解析</h1>
  <div class="page__meta">
    <p>
    
    <span class="page__date">
    on <time datetime="2020-02-05T15:26:52&#43;08:00">2020-02-05</time>
    
    </span>
    </p>

    

    
    </div>
</div>


</div>

<article class="page__content" ><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_什么是正则表达式和_grammar">1. 什么是正则表达式和 Grammar？</a>
<ul class="sectlevel2">
<li><a href="#_使用场景">1.1. 使用场景</a></li>
<li><a href="#_正则或正则表达式">1.2. 正则或正则表达式</a></li>
<li><a href="#_raku_正则表达式有什么特别之处">1.3. Raku 正则表达式有什么特别之处</a></li>
</ul>
</li>
<li><a href="#_raku_入门">2. Raku 入门</a>
<ul class="sectlevel2">
<li><a href="#_安装_raku">2.1. 安装 Raku</a></li>
<li><a href="#_使用_raku">2.2. 使用 Raku</a></li>
<li><a href="#_获取代码示例">2.3. 获取代码示例</a></li>
<li><a href="#_使用_raku_的第一步">2.4. 使用 Raku 的第一步</a></li>
<li><a href="#_总结">2.5. 总结</a></li>
</ul>
</li>
<li><a href="#_正则表达式构造块">3. 正则表达式构造块</a>
<ul class="sectlevel2">
<li><a href="#_字面量">3.1. 字面量</a></li>
<li><a href="#_元字符与字面量">3.2. 元字符与字面量</a></li>
<li><a href="#_anchors">3.3. Anchors</a></li>
<li><a href="#_预定义字符类">3.4. 预定义字符类</a></li>
<li><a href="#_量词">3.5. 量词</a></li>
<li><a href="#_析取">3.6. 析取</a></li>
<li><a href="#_连接">3.7. 连接</a></li>
<li><a href="#_零宽断言">3.8. 零宽断言</a></li>
<li><a href="#_总结_2">3.9. 总结</a></li>
</ul>
</li>
<li><a href="#_正则表达式和_raku_代码">4. 正则表达式和 Raku 代码</a>
<ul class="sectlevel2">
<li><a href="#_智能匹配">4.1. 智能匹配</a></li>
<li><a href="#_引号形式">4.2. 引号形式</a></li>
<li><a href="#_修饰符">4.3. 修饰符</a></li>
<li><a href="#_comb_和_split">4.4. comb 和 split</a></li>
<li><a href="#_替换">4.5. 替换</a></li>
<li><a href="#_跨越代码和正则表达式边界">4.6. 跨越代码和正则表达式边界</a></li>
<li><a href="#_总结_3">4.7. 总结</a></li>
</ul>
</li>
<li><a href="#_从正则表达式匹配中提取数据">5. 从正则表达式匹配中提取数据</a>
<ul class="sectlevel2">
<li><a href="#_位置捕获">5.1. 位置捕获</a></li>
<li><a href="#_匹配对象">5.2. 匹配对象</a></li>
<li><a href="#_命名捕获">5.3. 命名捕获</a></li>
<li><a href="#_反向引用">5.4. 反向引用</a></li>
<li><a href="#_重温匹配对象">5.5. 重温匹配对象</a></li>
<li><a href="#_总结_4">5.6. 总结</a></li>
</ul>
</li>
<li><a href="#_正则表达式技术性细节">6. 正则表达式技术性细节</a>
<ul class="sectlevel2">
<li><a href="#_带状态机的匹配">6.1. 带状态机的匹配</a></li>
<li><a href="#_正则表达式控制流">6.2. 正则表达式控制流</a></li>
<li><a href="#_回溯">6.3. 回溯</a></li>
<li><a href="#_为什么要避免回溯">6.4. 为什么要避免回溯</a></li>
<li><a href="#_节俭量词和回溯">6.5. 节俭量词和回溯</a></li>
<li><a href="#_最长_token_匹配">6.6. 最长 token 匹配</a></li>
<li><a href="#_总结_5">6.7. 总结</a></li>
</ul>
</li>
<li><a href="#_正则表达式技术">7. 正则表达式技术</a>
<ul class="sectlevel2">
<li><a href="#_了解你的数据格式">7.1. 了解你的数据格式</a></li>
<li><a href="#_考虑无效输入">7.2. 考虑无效输入</a></li>
<li><a href="#_使用锚点">7.3. 使用锚点</a></li>
<li><a href="#_匹配引用的字符串">7.4. 匹配引用的字符串</a></li>
<li><a href="#_测试正则表达式">7.5. 测试正则表达式</a></li>
<li><a href="#_总结_6">7.6. 总结</a></li>
</ul>
</li>
<li><a href="#_重用和组合正则表达式">8. 重用和组合正则表达式</a>
<ul class="sectlevel2">
<li><a href="#_命名正则表达式">8.1. 命名正则表达式</a></li>
<li><a href="#_空白">8.2. 空白</a></li>
<li><a href="#_grammars">8.3. Grammars</a></li>
<li><a href="#_使用_grammars_重用代码">8.4. 使用 Grammars 重用代码</a></li>
<li><a href="#_proto_regexes">8.5. Proto Regexes</a></li>
<li><a href="#_总结_7">8.6. 总结</a></li>
</ul>
</li>
<li><a href="#_使用_grammar_进行解析">9. 使用 Grammar 进行解析</a>
<ul class="sectlevel2">
<li><a href="#_理解_grammar">9.1. 理解 Grammar</a></li>
<li><a href="#_从简单开始">9.2. 从简单开始</a></li>
<li><a href="#_组装完整的_grammars">9.3. 组装完整的 Grammars</a></li>
<li><a href="#_调试_grammars">9.4. 调试 Grammars</a></li>
<li><a href="#_解析空白和注释">9.5. 解析空白和注释</a></li>
<li><a href="#_保存状态">9.6. 保存状态</a></li>
<li><a href="#_总结_8">9.7. 总结</a></li>
</ul>
</li>
<li><a href="#_从匹配中提取数据">10. 从匹配中提取数据</a>
<ul class="sectlevel2">
<li><a href="#_action_对象">10.1. Action 对象</a></li>
<li><a href="#_使用_action_对象构建_ast">10.2. 使用 Action 对象构建 AST</a></li>
<li><a href="#_在_action_对象中保存状态">10.3. 在 Action 对象中保存状态</a></li>
<li><a href="#_总结_9">10.4. 总结</a></li>
</ul>
</li>
<li><a href="#_生成好的解析错误消息">11. 生成好的解析错误消息</a>
<ul class="sectlevel2">
<li><a href="#_探索问题">11.1. 探索问题</a></li>
<li><a href="#_断言">11.2. 断言</a></li>
<li><a href="#_改进位置报告">11.3. 改进位置报告</a></li>
<li><a href="#_高水位标记">11.4. 高水位标记</a></li>
<li><a href="#_parser_combinator_和_failgoal">11.5. Parser Combinator 和 FAILGOAL</a></li>
<li><a href="#_使用哪种技术">11.6. 使用哪种技术?</a></li>
<li><a href="#_总结_10">11.7. 总结</a></li>
</ul>
</li>
<li><a href="#_unicode_和自然语言">12. Unicode 和自然语言</a>
<ul class="sectlevel2">
<li><a href="#_书写系统">12.1. 书写系统</a></li>
<li><a href="#_字节代码点字素_和字形">12.2. 字节，代码点，字素， 和字形</a></li>
<li><a href="#_总结_11">12.3. 总结</a></li>
</ul>
</li>
<li><a href="#_案例学习">13. 案例学习</a>
<ul class="sectlevel2">
<li><a href="#_s_表达式">13.1. S 表达式</a></li>
<li><a href="#_数学表达式和运算符优先级解析器">13.2. 数学表达式和运算符优先级解析器</a></li>
<li><a href="#_pythonesque_基于缩进的语言">13.3. Pythonesque, 基于缩进的语言</a></li>
<li><a href="#_总结_12">13.4. 总结</a></li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_什么是正则表达式和_grammar">1. 什么是正则表达式和 Grammar？</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们会接触到各种各样的结构化数据: 电话号码、电子邮件地址、邮政地址、信用卡号码等等。</p>
</div>
<div class="paragraph">
<p>正则表达式是一种声明性的编程结构, 用来描述这些数据格式。正则表达式可以让你搜索数据, 确保输入的数据确实是真实的格式, 甚至可以提取相关的组件, 如邮政地址的邮政编码, 或日志文件条目中的时间戳。</p>
</div>
<div class="paragraph">
<p>当你需要读取和验证更复杂的结构时, 比如程序设计语言, 或者像 XML 这样的标记语言, 你可以把多个正则表达式组合成 grammar。Grammar 的作用不仅仅是简单地组合正则表达式。它们还提供生成良好的错误信息和在分析输入文本时跟踪状态的基础设施。</p>
</div>
<div class="sect2">
<h3 id="_使用场景">1.1. 使用场景</h3>
<div class="sect3">
<h4 id="_搜索">1.1.1. 搜索</h4>
<div class="paragraph">
<p>正则表达式的一个常见用途是在大量数据中搜索感兴趣的模式, 例如在日志文件中查找某些消息, 在 URL 中查找特定的信息, 或者在文本中查找电话号码。在写这篇文章的时候, 我的 <code>.bash_history</code> 中大约有 6% 的条目涉及到使用正则表达式进行搜索。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://imgs.xkcd.com/comics/regular_expressions.png" alt="regular_expressions">
</div>
</div>
<div class="paragraph">
<p>许多命令行工具都支持某些正则表达式方言, 允许你搜索文件名、文件内容、日志、捕获的网络流量以及几乎所有你能想到的东西。大多数现代编程语言也可以很容易地使用正则表达式, 使其成为一种无处不在、不可或缺的搜索工具。</p>
</div>
</div>
<div class="sect3">
<h4 id="_验证">1.1.2. 验证</h4>
<div class="paragraph">
<p>大多数应用程序都面临着不可信的用户输入。特别是 Web 应用程序面临着大量的不可信输入。这些输入必须在应用任何进一步的逻辑或将其存储在例如数据库中之前进行验证。</p>
</div>
<div class="paragraph">
<p>正则表达式是验证的第一步。他们使检查数字等简单的事情变得简单, 并验证输入的最小长度和最大长度。同时, 它们允许程序员进行更精确、更复杂的检查。</p>
</div>
<div class="paragraph">
<p>Web 应用程序员只需要提供一个正则表达式, 并将其与输入字段关联。然后, Web 框架可以根据所有已配置的正则表达式来验证表单输入, 并自动为终端用户生成错误信息, 这样 Web 应用程序员就不需要处理拒绝输入和重新生成表单的工作流程。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解析">1.1.3. 解析</h4>
<div class="paragraph">
<p>单独使用正则表达式不太适合解析复杂的输入数据。然而, Raku 添加了功能, 使其非常适合这项任务。这些扩展包括易于使用的回溯控制和通过命名正则表达式获得的可组合性。</p>
</div>
<div class="paragraph">
<p>一个成功的正则表达式匹配, 其结果是一个匹配对象, 它包含了所有必要的元数据, 用于从解析后的文本中提取出感兴趣的部分。 还有一些功能, 可以很容易地将匹配对象转换为抽象语法树或 AST, 一种适合在解析器之外使用的数据结构。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_正则或正则表达式">1.2. 正则或正则表达式</h3>
<div class="paragraph">
<p>正则表达式的理论基础来自于计算机科学, 它描述了一种形式语言和自动机或形式机的层次结构, 可以识别这些语言。这些语言中, 最有限的一种语言被称为<a href="https://en.wikipedia.org/wiki/Regular_language">正则语言</a>。<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>决定特定字符串是否使用常规语言需要固定的内存量和每个固定数量的计算步骤字符。</p>
</div>
<div class="paragraph">
<p>正则表达式是一种编写正则语言的形式。随着从理论计算机科学中这些概念的发展, 它们是简约的, 只允许字面量, 替换(<code>|</code>), 括号进行分组, 以及<a href="https://en.wikipedia.org/wiki/Kleene_star">Kleene star</a><sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>(*)表示零次或多次重复。</p>
</div>
<div class="paragraph">
<p>早期的文本处理工具, 如 <code>grep</code>, <code>sed</code> 和 <code>awk</code> 都接受了正则表达式的概念, 并加入了许多方便的功能, 比如可以编写 <code>[az]</code> 而不是 <code>a|b|c|d|e</code> &#8230;&#8203;.。他们提供了预定义的*字符类*、字符集、例如字母、数字、空白字符等等。他们还增加了捕获功能, 帮助提取正则表达式匹配的特定部分的字符串。</p>
</div>
<div class="paragraph">
<p>后来的实现增加了一些超出正则语言所允许的功能, 因此需要一个单独的单词。这些实现也是为了便于使用而不是理论构造的极简主义而进行优化。现在, 我们在谈论到编程语言和库中的实用(而且更强大的)实现时, 倾向于使用正则表达式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_raku_正则表达式有什么特别之处">1.3. Raku 正则表达式有什么特别之处</h3>
<div class="paragraph">
<p>为了继续上一节的历史课程, Perl 是最早将正则表达式纳入其核心功能的通用编程语言之一。它从早期的正则表达式实现中借鉴了语法, 并对其进行了扩展, 使正则表达式变得更加强大和有用。很快, Perl 的特殊版本的正则表达式就成为了事实上的标准。所以很多名为兼容 Perl 的正则表达式(PCRE)的库被创建出来, 这样其他软件可以在他们自己的实现中使用 "Perl 正则表达式"。</p>
</div>
<div class="paragraph">
<p>遗憾的是, 在使正则表达式如此有用的过程中, Perl 给几乎所有的 ASCII 字符都赋予了特殊的的含义(除了按字面匹配的字符)。并且, 随着更多新的、更强大的正则表达式功能被创造出来, 这就导致了在继续保持与现有的正则表达式语法向后兼容的同时, 还需要使用一些晦涩的字符序列来实现新的功能。<code>(?&#8656;pattern)</code> 就是一个很好的例子。</p>
</div>
<div class="paragraph">
<p>Raku 正则表达式清理了这种历史上的语法包袱。它们通过允许无处不在的空白, 引入了关于哪些字符是特殊字符, 哪些不是特殊字符的规则, 以及最重要的是, 它们有一个简单、可扩展的语法, 可以通过名字来调用其他正则表达式, 从而提高来可读性。</p>
</div>
<div class="paragraph">
<p>虽然大多数语言将正则表达式视为字符串或特殊对象, 但是 Raku 正则表达式是代码; 当正则表达式在 grammar 中组合在一起时, 就像方法一样。这让你可以自由地将所有你在编程语言中习惯你的管理和重用代码的技术应用到正则表达式中: 命名空间、类、角色<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>、继承等等。</p>
</div>
<div class="paragraph">
<p>组合正则表达式的能力使得 Raku 不仅仅能解析简单的字符串格式。你可以写出使用许多小的正则表达式来解析复杂的文件格式的 grammar。实际上, Rakudo 编译器本身就使用了 grammar 来解析 Raku 源代码。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_raku_入门">2. Raku 入门</h2>
<div class="sectionbody">
<div class="paragraph">
<p>通过阅读本书, 你可能会捡起一些东西, 了解一些基本的概念; 但如果你的目标是流畅和更深层次的理解, 你应该自己运行这些例子, 修改它们, 并进行试验。</p>
</div>
<div class="paragraph">
<p>为此, 你首先需要安装 Raku 编译器, 版本为 2017.05 或更新版本。之后, 我们将讨论如何使用它进行正则表达式实验。</p>
</div>
<div class="paragraph">
<p>如果你不愿在计算机上安装软件, 也可以使用一个在线服务来运行你的代码。在写这篇文章的时候, <a href="https://glot.io/new/raku">https://glot.io/new/raku</a> 和 <a href="https://tio.run/#raku">https://tio.run/#raku</a> 支持在浏览器中运行 Raku 代码。你也可以在 <a href="https://raku.org/resources/">https://raku.org/resources/</a> 上查看类似服务的最新列表。</p>
</div>
<div class="sect2">
<h3 id="_安装_raku">2.1. 安装 Raku</h3>
<div class="paragraph">
<p>Raku 编译器有两种: 编译器本身和 Rakudo Star。后者是一个包含编译器、zef 模块安装程序、文档和一些模块的发行版。</p>
</div>
<div class="paragraph">
<p>出于我们的目的, 你需要编译器和 zef。安装 Rakudo Star 为你提供了这两样东西, 但如果 Rakudo Star 安装程序不适合你, 或者你更喜欢更精简的安装, 你可以只安装编译器, 并<a href="https://github.com/ugexe/zef#manual">根据文档安装 zef</a>。<sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup></p>
</div>
<div class="paragraph">
<p>以下是安装 Raku 的一些选项。</p>
</div>
<div class="sect3">
<h4 id="_使用原生方式安装_rakudo_star">2.1.1. 使用原生方式安装 Rakudo Star</h4>
<div class="paragraph">
<p>Rakudo Star 下载页面 <a href="http://rakudo.org/downloads/star/">http://rakudo.org/downloads/star/</a> 为 Windows 和 Mac OS 提供了二进制安装程序。你只需打开下载文件即可安装它们。</p>
</div>
</div>
<div class="sect3">
<h4 id="_二进制_linux_包">2.1.2. 二进制 Linux 包</h4>
<div class="paragraph">
<p><a href="https://github.com/nxadm/rakudo-pkg/releases">Rakudo OS Packages</a><sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup> 仓库包含如何在 CentOS、Debian、Fedora 和 Ubuntu 系统上获取和使用 Raku 软件包的说明。它们带有编译器和一个用来安装 zef 的脚本; 对于我们的目的来说已经足够了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_基于_docker_的安装">2.1.3. 基于 Docker 的安装</h4>
<div class="paragraph">
<p>在支持 Docker 的平台上, 你可以通过一条命令获得一个预构建的轻量级镜像, 其中包含 Raku 编译器以及 <code>zef</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ docker pull moritzlenz/raku-regex-alpine</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个 Docker 镜像包含 Raku 以及一些模块, 这些模块可以让你更容易地使用正则表达式和 grammar。</p>
</div>
<div class="paragraph">
<p>一旦你拉取了这个镜像, 你就可以用它来执行单行程序, 具体方法如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ docker run -it moritzlenz/raku-regex-alpine -e 'say "hi"'</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 Docker 容器在自己隔离的世界中运行, 所以你需要采取额外步骤来使容器中的脚本文件可用。例如, 如果你想执行一个脚本 search.p6, 你可以像这样运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ docker run -it -v $PWD:/raku -w /raku \
     moritzlenz/raku-regex-alpine search.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>这很不方便, 所以用 bash 别名(或 shell 脚本)可以帮助你:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ alias p6d="docker run -it -v $PWD:/raku -w /raku
     moritzlenz/raku-regex-alpine"</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这之后, 执行脚本就变得简单多了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ p6d search.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>一般情况下, 本书假定存在 raku 可执行文件。如果你使用 docker 镜像, 那么在所有命令中用 p6d 替换 raku。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用_raku">2.2. 使用 Raku</h3>
<div class="paragraph">
<p>你可以通过运行 <code>raku --version</code> 来验证你的 Raku 安装是否正常, 应该打印出类似这样的东西:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">This is Rakudo version 2017.05-315-g160de7e built on MoarVM version 2017.05-25-g62bc54e
implementing Raku.c.</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你自己搞不定, 可以向 <a href="https://raku.org/community/">Raku 社区</a><sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup>寻求帮助。</p>
</div>
<div class="paragraph">
<p>一旦成功了, 你可以通过运行不带参数的 <code>raku</code> 启动一个简单的交互式 shell:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku
To exit type 'exit' or '^D'
&gt; say "Hello, world";
Hello, world
&gt; exit</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个 shell 中, 你可以输入几行 Raku 代码, 这些代码会立即被执行。这对于测试正则表达式非常有用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say "Hello, world" ~~ / \w+ /
⌜Hello⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>(如果你还不明白这里到底发生了什么, 不要担心; 下一章会详细解释。)</p>
</div>
<div class="paragraph">
<p>然而如果提示符返回这样的东西:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku
You may want to `zef install Readline` or `zef install
Linenoise` or use rlwrap for a line editor.
To exit type 'exit' or '^D'
&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你应该按照问候信息中的建议, 安装它提到的一个模块。这样你就能访问和编辑你的命令的历史记录了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ zef install Linenoise
===&gt; Searching for: Linenoise
===&gt; Searching for missing dependencies: LibraryMake
...
===&gt; Installing: Linenoise:ver('0.1.1'):auth('Rob Hoelz')</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然, 你也可以使用 <code>raku</code> 来执行脚本文件, 只需在命令行中添加脚本文件即可:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku greet.p6
Hello, world</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设你在当前工作目录下有一个文件 <code>greet.p6</code>, 其中包含了 <code>say "Hello, world";</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_获取代码示例">2.3. 获取代码示例</h3>
<div class="paragraph">
<p>本书中使用的代码示例的源代码可以在 GitHub 上找到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ git clone https://github.com/apress/perl-6-regexes-and-grammars.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你没有 git, 你也可以从 <a href="https://github.com/apress/perl-6-regexes-and-grammars/archive/master.zip">https://github.com/apress/perl-6-regexes-and-grammars/archive/master.zip</a> 下载一个包含源代码的压缩包。</p>
</div>
<div class="paragraph">
<p>我鼓励你运行这些示例脚本, 修改并运行它们。这是比单纯阅读本书更深入学习这些主题的最好方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_raku_的第一步">2.4. 使用 Raku 的第一步</h3>
<div class="paragraph">
<p>为了有效地使用 Raku 中是正则表达式, 你需要了解一下他们所嵌入的语言。</p>
</div>
<div class="paragraph">
<p>Raku 是一门自由形式的语言, 所以你可以随意缩进你的代码。然而, 有些情况下, 是否有空格是很重要的: <code>doit(1, 2, 3)</code> 调用带有 3 个参数的函数 <code>doit</code>, 而 <code>doit (1, 2, 3)</code> 只用单个参数来调用同一个函数, 这个参数是一个 3 个值的列表。</p>
</div>
<div class="paragraph">
<p>语句之间用分号(;)字符隔开,  你也可以在程序的最后一行放一个分号。注释以井号字符(<code>#</code>) 开头, 并一直延伸到行尾:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "Hello, World";         # Output: Hello, World
say( 2 * 21 );              # Output: 42</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_变量和值">2.4.1. 变量和值</h4>
<div class="paragraph">
<p>变量是用关键字 <code>my</code> 来声明的, 并以 sigil 符号开头, 这告诉我们一些关于变量的一般类型:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 1;
my @capitals = 'Algiers', 'Tirana', 'Berlin', 'Tokio';
my %populations =
      Algiers =&gt; 3_500_000,
      Berlin  =&gt; 3_700_000,
      Tirana  =&gt; 353_400,
      ;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$</code> 代表标量变量 - 通常是持有单一值的变量。作比之下, <code>@</code> 表示数组, 一个线性的值的集合, 可以通过一个从零开始的索引来访问元素。在上一个代码块的上下文中, <code>@capitals[0]</code> 返回 'Algiers'。</p>
</div>
<div class="paragraph">
<p>哈希(其他语言称之为字典或映射)将键(字符串)与值关联起来。你可以通过 <code>{}</code> 索引操作符来查找一个键的值, 并使用几个有用的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %populations{'Algiers'};    # Output: 3500000
say %populations.keys.sort;     # Output: (Algiers Berlin Tirana)
say %populations.values.sum;    # Output: 7553400</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_字符串">2.4.2. 字符串</h4>
<div class="paragraph">
<p>由于正则表达式作用在字符串上, 我们就应该多说说它们。</p>
</div>
<div class="paragraph">
<p>字符串是由 Unicode 字符组成的序列。<sup class="footnote">[<a id="_footnoteref_7" class="footnote" href="#_footnotedef_7" title="View footnote.">7</a>]</sup>我们已经看到了一些由单引号 <code>''</code> 和双引号 <code>""</code> 包围的字符串的示例。 主要区别在于, 双引号可以实现转义序列, 如 <code>\n</code> 是换行符(换行)和变量插值, 即用变量的值替换变量名:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = 'Larry';
say "Hello, $name";         # Output: Hello, Larry
say 'Hello, $name';         # Output: Hello, $name</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而, 即使在单引号内, 也可以用反斜线转义单引号来插入单引号。出于同样的原因, 在这样的字符串中必须使用双倍的反斜线:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'a quote: \' a backslash: \\';
# Output: a quote: ' a backslash: \</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here-documents 提供了一种编写多行字符串的简洁方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $macbeth = q:to/END/;       # need to put the ; on this line!
When shall we three meet again?
In thunder, lightning, or in rain?
    When the hurlyburly's done,
    When the battle's lost and won.
END
# normal Raku code resumes here</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以选择自己的分隔符, 但习惯上将其全部大写, 以便更容易找到 here-document 的结束位置。</p>
</div>
</div>
<div class="sect3">
<h4 id="_控制结构">2.4.3. 控制结构</h4>
<div class="paragraph">
<p>像循环和分支这样的控制结构都遵循相同的基本模式, <code>KEYWORD EXPRESSION { BLOCK }</code>, 而且 <code>if</code> 结构也允许附加 <code>elsif</code> 和 <code>else</code> 语句:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 1, 2, 3 {
    say $_;
}
if 1 &gt; 2 {
    say "No Way";
}
elsif 1 == 2 {
    say "Still no chance";
}
else {
    say "This runs";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个代码产生如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1
2
3
This runs</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>for</code> 循环块内, 当前值存储在特殊变量 <code>$_</code> 中。如果你想使用不同的变量, 可以使用下面的语法, 这就是所谓的尖号块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 1, 2, 3 -&gt; $value {
    say $value;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这在任何可以使用一个块的位置都可以使用, 也可以扩展到多个参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $callback = -&gt; $x, $y { $x + $y };
say $callback(1, 2);                    # Output: 3</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_函数类和方法">2.4.4. 函数、类和方法</h4>
<div class="paragraph">
<p>函数或子程序是一段带有形式参数列表以及可选的返回值的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub double($x) {
    return 2 * $x;
}
say double(2);         # Output: 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有运行 <code>return</code> 语句, 那么返回值是最后一个表达式的值 , 所以我们可以把它写成 <code>sub double($x) { 2 * $x }</code>。</p>
</div>
<div class="paragraph">
<p>你可以选择为参数(和变量)声明一个类型:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub double(Numeric $x) { 2 * $x }</code></pre>
</div>
</div>
<div class="paragraph">
<p>类可以有每个对象的存储, 称为属性, 而代码是附加到对象上的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Point {
    has $.x;
    has $.y;
    method magnitude() {
        return sqrt($.x * $.x + $.y * $.y);
    }
}
my $p = Point.new( x =&gt; 5, y =&gt; 2 );
say $p.x;                            # Output: 5
say $p.magnitude();                  # Output: 5.3851648071345</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_了解更多关于raku">2.4.5. 了解更多关于Raku</h4>
<div class="paragraph">
<p>有很多资源可以深入学习 Raku。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Moritz Lenz 的 <a href="https://www.apress.com/us/book/9781484228982">Raku 基础: 从示例, 项目和案例入门</a>。<sup class="footnote">[<a id="_footnoteref_8" class="footnote" href="#_footnotedef_8" title="View footnote.">8</a>]</sup>, 提供了一种示例驱动的方法来探索 Raku。</p>
</li>
<li>
<p>Andrew Shitov 的 <a href="https://www.packtpub.com/application-development/perl-6-deep-dive">Raku Deep Dive</a><sup class="footnote">[<a id="_footnoteref_9" class="footnote" href="#_footnotedef_9" title="View footnote.">9</a>]</sup>, 是一本更注重功能的类似主题的指南。</p>
</li>
<li>
<p><a href="http://rakuintro.com/">http://rakuintro.com/</a> 是一个免费的学习 Raku 的在线资源, 有多种语言版本。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最后但并非最不重要的是, Raku 的官方文档 <a href="https://docs.raku.org">https://docs.raku.org</a> 提供了介绍性和参考资料, 可以让你搜索内置的类型、函数、方法和操作符。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结">2.5. 总结</h3>
<div class="paragraph">
<p>我们已经看到了几种安装 Raku 编译器的方法。 安装完毕之后, 就可以通过运行不带参数的 <code>raku</code> 启动一个交互式的 Raku shell, 或者 <code>raku script.p6</code> 来执行 Raku 程序。</p>
</div>
<div class="paragraph">
<p>我们还探索了我们的第一个简单的 Raku 程序。接下来我们将直接开始编写我们的第一个正则表达式。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_正则表达式构造块">3. 正则表达式构造块</h2>
<div class="sectionbody">
<div class="paragraph">
<p>说了这么多, 准备了这么多, 是时候看一些实际的正则表达式了。</p>
</div>
<div class="sect2">
<h3 id="_字面量">3.1. 字面量</h3>
<div class="paragraph">
<p>正则表达式中最简单的元素是字面量: 即完全匹配自己的字符串。例如, 正则表达式 <code>/perl/</code> 匹配任何包含 p,e,r 和 l 字符的字符串, 它们的顺序正好是这样的。因此, 字符串 "properly" 从第四个字符开始匹配此正则表达式(pro<strong>perl</strong>y), 但字符串 "superficial" 不匹配, 因为它在 per 和 l 之间包含了其他字符(ficia)。</p>
</div>
<div class="paragraph">
<p>仅由字母, 下划线 <code>_</code> 和数字组成的字面量不需要任何特殊的语法。只需将字母和数字写为正则表达式的一部分写成字面量即可。其他字面量必须用引号括起来, 要么使用单引号要么使用双引号: <code>/'2016-12-24'/</code> 和 <code>/"2016-12-24"/</code> 类似, 两者都与字符串 2016-12-24 匹配。由于这两个破折号既不是字母也不是数字, 所以需要成为引号字符串的一部分, 才能从字面上匹配。单引号和双引号对儿在插值方面的行为有所不同: 变量和花括号 <code>{&#8230;&#8203;}</code> 分隔的代码块在双引号中被插值, 所以下面的正则表达式都匹配字符串 "3":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = 3; # the string to be matched against
my $x = 3;
say "yes" if /"$x"/;      # Output: yes
say "yes" if /"{1 + 2}"/; # Output: yes</code></pre>
</div>
</div>
<div class="paragraph">
<p>而正则表达式 <code>/'{1 + 2}'/</code> 只匹配字面字符串 <code>{1 + 2}</code>。</p>
</div>
<div class="paragraph">
<p>在 Raku 正则表达式中, 默认情况下会忽略空格, 所以 <code>/perl/</code>, <code>/pe rl/</code>, 和 <code>/ p e r l/</code> 都是等价的(尽管后两个产生一个警告), 而且匹配的字符串完全相同。在引号里面, 空格是重要的,  所以 <code>/"pe rl"/</code> 与字符串 properly 不匹配, 因为该字符串中没有空格字符, 但引号内的字符串有。</p>
</div>
</div>
<div class="sect2">
<h3 id="_元字符与字面量">3.2. 元字符与字面量</h3>
<div class="paragraph">
<p>正如我们在上一节中看到的那样, 正则表达式中的字母数字字符与它们自身匹配。所有其他字符都可能有一些特殊的含义。 我们已经看到 <code>'</code> 和 <code>"</code> 是特殊的: 它们包围着被引用的字符串。</p>
</div>
<div class="paragraph">
<p>我们称这种"特殊"字符为元语法或元字符。 反斜线 <code>\</code> 使字面量字符变得容易, 反之亦然。例如, <code>/d/</code> 匹配字面的 d, 但 <code>/\d/</code> 可以匹配单个数字。另一方面, 正则表达式中的 <code>+</code> 修饰前一个字符, 但是 <code>/\+/</code> 匹配的是一个加号, 也就是 <code>+</code>。唯一的例外是 <code>#</code> 字符, 它不能通过反斜线前缀来匹配字面意思, 必须用引号代替。</p>
</div>
<div class="paragraph">
<p>并非所有元字符都有特殊的语义含义。例如, 感叹号(<code>!</code>)没有元语义, 并且 Raku 产生一个适当的错误信息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku -e '/!/'
===SORRY!=== Error while compiling -e
Unrecognized regex metacharacter ! (must be quoted to match literally)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_anchors">3.3. Anchors</h3>
<div class="paragraph">
<p>正则表达式会搜索整个字符串以查找匹配项。有时这不是你想要的。锚点只在字符串中的某些位置进行匹配, 从而将正则表达式匹配锚定在该位置。</p>
</div>
<div class="paragraph">
<p>最常见的锚点是 <code>^</code> 和 <code>$</code>。它们分别匹配字符串的开头和结尾。正则表达式 <code>/^go/</code> 匹配以字母 g 开头的字符串 , 例如 gown。相比之下, <code>/go$/</code> 匹配所有以字母 o 结尾, 其前面由 g 开头的字符串, 例如 tango。 最后, 同时使用这两个锚点的正则表达式, <code>/^go$/</code> 只匹配字符串 go。</p>
</div>
<div class="paragraph">
<p>由于空格通常被忽略, 我们可以将这些正则表达式写为 <code>/ ^ go /</code>, <code>/ go $ /</code> , 或 <code>/ ^ go $ /</code>。</p>
</div>
<div class="paragraph">
<p>但是 <code>/ g ^ /</code> 和 <code>/ $ g /</code> 这两个正则表达式无法匹配任何字符串, 因为没有一个字符串在其开始之前或结束之后都有一个字符。一般来说, 如果你写出这样的正则表达, Raku 不会发出警告或抱怨, 尽管未来的版本可能会产生警告。如果你需要一个永远不可能匹配的正则表达式,  可以使用 <code>&lt;!&gt;</code>, 它可以达到同样的效果, 但更加明确。</p>
</div>
<div class="paragraph">
<p>字符串可以由多行组成; 锚点 <code>^^</code> 和 <code>$$</code> 分别匹配行的开头和结尾。<code>$$</code> 锚的特殊之处在于, 它匹配换行符之前, 如果没有尾随换行符, 则匹配字符串的末尾:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Start-of-line positions that ^^ matches:
"⏏ab\n⏏de"
"⏏ab\n⏏de\n"

# End-of-line positions that $$ matches:
"ab⏏\nde⏏"
"ab⏏\nde⏏\n"</code></pre>
</div>
</div>
<div class="paragraph">
<p>锚点是零宽度的正则表达式元素。因此他们不会"消耗"输入字符串中的字符, 也就是说, 它们不会推进正则表达式引擎尝试匹配的当前位置。一个好的心理模型是, 它们在输入字符串的两个字符之间(或在输入字符串的第一个字符之前, 或在输入字符串的最后一个字符之后)进行匹配。</p>
</div>
<div class="paragraph">
<p>Raku 中内置了更多的锚(表 3-1)。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Raku 正则表达式锚点。⏏ 标记锚点匹配的位置</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">锚点</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">样例</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">^</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符串开头</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"⏏some\nlines"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">^^</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">行的结尾</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"⏏some\n⏏lines"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符串结尾</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"some\nlines⏏"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$$</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">行的结尾</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"some⏏\nlines⏏"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;&lt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">左单词边界</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"⏏some ⏏words"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">«</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">左单词边界</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"⏏some ⏏words"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&gt;&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">右单词边界</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"some⏏ words⏏"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">»</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">右单词边界</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"some⏏ words⏏"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;?wb&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意单词边界</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"⏏some⏏ ⏏words⏏!!"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;!wb&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">非单词边界</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"s⏏o⏏m⏏e w⏏o⏏r⏏d⏏s!⏏!"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;?ww&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单词内</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"s⏏o⏏m⏏e w⏏o⏏r⏏d⏏s!!"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;!ww&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">非单词内</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"⏏some⏏ ⏏words⏏!⏏!⏏"</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>单词边界是字母数字字符组和下划线(<code>_</code>)以及任何其他字符之间的边界。例如, 字符串 "some-words_here" 就包含这些单词边界: "⏏some⏏-⏏words_here⏏"。注意, 在这种情况下 <code>_</code> 字符的周围没有边界。它被当作一个字符来处理。</p>
</div>
</div>
<div class="sect2">
<h3 id="_预定义字符类">3.4. 预定义字符类</h3>
<div class="paragraph">
<p>如果你必须拼写出每个要匹配的字符, 那么正则表达式就非常受限了。而字符类则放宽了这一要求。例如, 点(<code>.</code>) 代表任何一个字符。</p>
</div>
<div class="paragraph">
<p>你可以使用它来解决填字游戏, 效果非常好。假设你正搜索一个五个字母的单词, 你知道第二个字母是 e,  最后两个是 rl。这几乎可以是任何字符串, 对吧?</p>
</div>
<div class="paragraph">
<p>一旦有了单词列表, 你就可以用正则表达式 <code>/ ^ .e.rl $ /</code> 来测试每个单词, 这样可以大大减少需要考虑的单词数量。</p>
</div>
<div class="paragraph">
<p>有些 Linux 发行版会自带一个文件 <code>/usr/share/dict/words</code>, 其中包含一个英文单词表, 每行一个单词。搜索这样一个单词列表只需一个非常短的脚本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for '/usr/share/dict/words'.IO.lines -&gt; $word {
    say $word if lc($word) ~~ / ^ .e.rl $ /;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在我的系统(Ubuntu 16.04)上, 这只产生两行输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Pearl
pearl</code></pre>
</div>
</div>
<div class="paragraph">
<p>它们只是在大小写上有区别, 所以对于填字游戏, 它们是一样的。</p>
</div>
<div class="paragraph">
<p>这个脚本是如何工作的? 代码 '/usr/share/dict/words'.IO 创建了一个 <code>IO::Path</code> 对象, 并在其上调用 <code>.lines</code> 方法返回文件中的一系列行。<code>for</code> 循环会在这些行上进行迭代, 这些行也正好是单词。</p>
</div>
<div class="paragraph">
<p>命令 <code>say $word</code> 打印单词, 然后跟着一个换行符, 但是只有满足 <code>if</code> 后缀的条件才打印。<code>lc($word)</code> 返回小写的 <code>$word</code>, 最后一行的其余部分检查小写单词是否与正则表达式 <code>/ ^ .e.rl $ /</code> 匹配。</p>
</div>
<div class="paragraph">
<p>由于字符类非常有用, 所以 Raku 有很多字符类。有些字符类由反斜线和一个小写字母组成。在这些情况下, 大写版本是否定意义的(表 3-2)。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Raku 正则表达式预定义字符类</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配样例</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不匹配样例</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意字符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a, 4,<br></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数字</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1, ٤</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a,<br></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">非数字</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a,<br></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1, ٤</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单词字符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a, 4,</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+, /, " "</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\W</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">非单词字符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+, /, " "</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x, 4, ٤</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空白符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">" ", "\t"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a, -, 4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\S</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">非空白符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a, -, 4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">" ", "\t"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\n</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">逻辑换行符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"\n", "\c[LINE SEPARATOR]"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"\t",<br></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">非换行符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"\t", +, a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"\n"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\h</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">水平空白</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">" ", "\t"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"\n", a, 4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\H</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">非水平空白</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"\n", a, 4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">" ", "\t"</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>所有这些分类都考虑了完整的 Unicode 字符序列; 所以 <code>\d</code> 不只是匹配 0 到 9 的数字, 还匹配所有脚标和变体的数字, 例如 ٤ - ARABIC-INDIC DIGIT FOUR。在支持 Unicode 9 版本的 Rakudo 2017.05 中, 有 580 个不同的字符与 <code>\d</code> 字符类匹配。</p>
</div>
<div class="paragraph">
<p>如果要找出所有匹配某个字符类的字符, 你可以迭代所有 Unicode 字符。下面是一个例子, 它列出了所有匹配 <code>\n</code> 的字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 0..0x1FFFF -&gt; $c {
    if chr($c) ~~ /\n/ {
        printf "U+%05X - %s\n", $c, $c.uniname
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会产生如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">U+0000A - &lt;control-000A&gt;
U+0000B - &lt;control-000B&gt;
U+0000C - &lt;control-000C&gt;
U+0000D - &lt;control-000D&gt;
U+00085 - &lt;control-0085&gt;
U+02028 - LINE SEPARATOR
U+02029 - PARAGRAPH SEPARATOR</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Int#routine_chr">chr($c)</a><sup class="footnote">[<a id="_footnoteref_10" class="footnote" href="#_footnotedef_10" title="View footnote.">10</a>]</sup> 将代码点编号 <code>$c</code> 转换为它背后的实际字符。<a href="https://docs.raku.org/type/Str#sub_sprintf">printf</a><sup class="footnote">[<a id="_footnoteref_11" class="footnote" href="#_footnotedef_11" title="View footnote.">11</a>]</sup> 是一个例程, 用于打印根据模板格式化的输出, <a href="https://docs.raku.org/type/Cool#method_uniname">uniname</a><sup class="footnote">[<a id="_footnoteref_12" class="footnote" href="#_footnotedef_12" title="View footnote.">12</a>]</sup> 返回 Unicode 字符数据库中字符的名称。</p>
</div>
<div class="sect3">
<h4 id="_用户自定义字符类">3.4.1. 用户自定义字符类</h4>
<div class="paragraph">
<p>你也可以指定自己的字符类, 而不是只依赖于 Raku 正则表达式中的字符类。最简单的方法是在 <code>&lt;[</code> 和 <code>]&gt;</code> 之间枚举它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'perl' ~~ / &lt;[aeiou]&gt;/; # Output: ⌜e⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>在字符类中, 非字母数字字符会失去其特殊含义, 所以 <code>/ &lt;[ " ']&gt; /</code> 匹配单引号或双引号。例外的是空格, 它们被简单地忽略, 和结束方括号 <code>]</code> (它结束字符类, 所以必须使用反斜线转义才能成为字符类的一部分)以及反斜线。要匹配开口或闭合方括号, 请使用正则表达式 <code>/ &lt;[ [ \] ]&gt; /</code>。</p>
</div>
<div class="paragraph">
<p>你可以在自定义字符类中包含预定义的字符类: <code>/ &lt;[ \w $ - ]&gt; /</code> 匹配单个字符, 这个字符可以是一个单词字符(<code>\w</code>)、连字符或美元符号。</p>
</div>
<div class="paragraph">
<p>字符范围可以简化连续字符的列表。例如, <code>/ &lt;[ 0..9 a..f A..F ]&gt;</code> 匹配十六进制字符, 换句话说, 它匹配这些字符中的任何一个: 0123456789abcdefABCDEF。</p>
</div>
<div class="paragraph">
<p>你可以通过在字符类前面添加一个减号( <code>-</code> )来否定字符类。因此, 要匹配除双引号之外的任何字符, 可以使用 <code>/ &lt;-[ " ]&gt; /</code>。这是一个更通用语法的特例, 可以让你混合和匹配肯定和否定的字符类以及预定义的字符类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;[\d]-[78]+[abc]&gt; /</code></pre>
</div>
</div>
<div class="paragraph">
<p>此正则表达式可以匹配除 7 和 8 之外的任何数字, 但它也匹配字符 a, b 和 c。</p>
</div>
<div class="paragraph">
<p>最后, 单个字符的反斜杠转义符在字符类中的作用就像在双引号字符串中那样, 所以 <code>&lt;[ \c[ CHARACTER TABULATION] x ]&gt;</code> 和 <code>&lt;[ \t x ]&gt;</code> 都匹配字母 x 或制表符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_unicode_属性">3.4.2. Unicode 属性</h4>
<div class="paragraph">
<p>Raku 还通过引入 <a href="http://unicode.org/reports/tr23/">Unicode 属性和类别</a><sup class="footnote">[<a id="_footnoteref_13" class="footnote" href="#_footnotedef_13" title="View footnote.">13</a>]</sup>提供对字符类的访问。要在正则表达式中使用 Letter 属性, 你可以写 <code>&lt;:Letter&gt;</code> 以匹配作为字母的单个字符, 或 <code>&lt;:!Letter&gt;</code> 作为它的否定 - 也就是说, 一个不是字母的单个字符。其中一些属性有简短形式, 如 <code>&lt;:L&gt;</code> 表示 <code>&lt;:Letter&gt;</code>。</p>
</div>
<div class="paragraph">
<p>这些属性不限于你目前正阅读的拉丁字母, 而是包括整个 Unicode 字符数据库。所以 <code>&lt;:Letter&gt;</code> 可能与希腊文, 西里尔文或希伯来文字母或来自任何具有字母概念的脚本的字母相匹配 (表 3-3)。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. 从通用类别中选出的 Unicode 属性</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">短形式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">例子</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Letter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">L</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">aΦЊ</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uppercase_Letter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lu</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AЊ</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lowercase_Letter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ll</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">xή</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mark</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">M</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">83⁄4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Decimal_Number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Symbol</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">S</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$÷϶</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math_Symbol</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+±∄</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Punctuation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">P</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!@_</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_量词">3.5. 量词</h3>
<div class="paragraph">
<p>到目前为止, 我们看到的正则表达式都匹配固定数量的字符。这种情况即将改变。量词控制其前面的正则表达式元素(原子)的匹配频次, 因此允许可选和重复的元素。</p>
</div>
<div class="paragraph">
<p><code>+</code> 量词匹配它前面的原子一次或多次。例如, <code>/ ^ a+ $ /</code> 匹配字符串 a, aa, aaa,  aaaa, 等等。</p>
</div>
<div class="paragraph">
<p>量词的绑定非常紧密, 比正则表达式元素的连接更紧密 , 因此 <code>/ ab+ /</code> 匹配 ab, abb, abbb 等。你可以把它写成 <code>/ a [b+] /</code> 以消除任何歧义。</p>
</div>
<div class="paragraph">
<p>如果你想匹配 ab, abab, ababab, 你可以使用引号或括号来强制 <code>+</code> 应用于多个字符: <code>/ [ab]+ /</code> 和 <code>/ 'ab'+ /</code> 都匹配这些字符串。前者比较通用,  因为它不仅适用于字面量, 也适用于其他的正则表达式。<code>/ [\d+ ',']+ /</code> 匹配一个数字列表, 每个数字后面跟一个逗号。</p>
</div>
<div class="paragraph">
<p>还有更多的量词, 如表 3-4 所示。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Raku 正则表达式量词</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">量词</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最少匹配</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最多匹配</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">infinite</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">infinite</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">**4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">** 4..20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>* 4..</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">infinite</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>最一般的形式是 <code>** RANGE</code> 量词, 其中 RANGE 可以是 <code>MIN..MAX</code>, 表示有上限的范围, 或者 <code>MIN .. *</code> 表示没有上限的重复:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ ^ a ** 4 $ /;     # Matches exactly 4 a's
/ ^ a ** 2..4 $ /;  # Matches between 2 and 4 a's
/ ^ a ** 5..* $ /;  # Matches at least 5 a's</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_贪婪和节俭量词">3.5.1. 贪婪和节俭量词</h4>
<div class="paragraph">
<p>量词在默认情况下是贪婪的: 它们会尽可能多地匹配。</p>
</div>
<div class="paragraph">
<p>你可以通过对一个有多种可能匹配方式的字符串应用正则表达式来观察这种行为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "&lt;a&gt; b &lt;c&gt;" ~~ /"&lt;" .+ "&gt;"/; # Output: ⌜&lt;a&gt; b &lt;c&gt;⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的正则表达式与整个字符串匹配, 从第一个 <code>&lt;</code> 到最后一个 <code>&gt;</code>。如果这不是你想要的, 你可以在量词上添加一个问号(<code>?</code>)来控制量词的贪婪性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "&lt;a&gt; b &lt;c&gt;" ~~ /"&lt;" .+? "&gt;"/; # Output: ⌜&lt;a&gt;⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 社区把这个版本的量词称为节俭量词, 尽管这个名字在一般的正则表达式文献中并不普遍。还有人称之为懒惰量词。</p>
</div>
<div class="paragraph">
<p>在一般量词的情况下, <code>?</code> 出现在范围之前, 就像这样: <code>**?1..5</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_带分隔符的量词">3.5.2. 带分隔符的量词</h4>
<div class="paragraph">
<p>解析由固定分隔符连接的列表项是一项常的见任务。你可以使用 <code>/ &lt;thing&gt; [&lt;separator&gt; &lt;thing&gt;]* /</code> 或者如果允许尾随的分隔符, 则使用 <code>/ &lt;thing&gt; [&lt;separator&gt; &lt;thing&gt;]* &lt;separator&gt;? /</code>。 如果要允许空列表, 则需要进行更多修改。</p>
</div>
<div class="paragraph">
<p>Raku 提供了一个快捷方式: <code>/&lt;thing&gt;+ % &lt;separator&gt;/</code>, 可以匹配一个由 <code>&lt;separator&gt;</code> 分隔的 <code>&lt;thing&gt;</code> 列表。如果允许尾随分隔符, 只需将 <code>%</code> 更改为 <code>%%</code> 即可。这适用于任何量词。因此, <code>&lt;thing&gt;* % &lt;separator&gt;</code> 也可以匹配空字符串。</p>
</div>
<div class="paragraph">
<p>例如, 用逗号分隔的数字列表可以被解析为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '1,24,5' ~~ / [\d+]* % ',' /; # Output: ⌜1,24,5⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你把节俭量词与分隔符功能结合起来时, 请把节俭量词 <code>?</code> 放在前面:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '1,24,5' ~~ / [\d+]*? % ',' /; # Output: ⌜⌟</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_析取">3.6. 析取</h3>
<div class="paragraph">
<p>"Hi," "Hello," 和 "Hey" 可能都是英语中被普遍接受的问候语。 匹配这种问候语的正则表达式必须接受这三个选项中的任何一个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ Hi | Hello | Hey /</code></pre>
</div>
</div>
<div class="paragraph">
<p>竖条 <code>|</code> 分割分词中的备选项或分支。在这个例子中, 这些分支不一定要像这个例子中的字面意思; 他们可以是任何一个正则表达式。</p>
</div>
<div class="paragraph">
<p>Raku 就是这样, 正则表达式分词有两种形式。单个垂直条形式与产生较长匹配的分支相匹配。如果两个或多个匹配的长度相同, 那么以字面量开始的分支就会获胜, 所以对于正则表达式 <code>/a.|../</code> 匹配字符串 ab, 第一个备选项比第二个备选项更符合。</p>
</div>
<div class="paragraph">
<p>如果你将垂直条加倍, 则从左到右依次进行选择, 并且, 第一个匹配的备选项胜出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'aab' ~~ / a+ | \w+ /;  # Output: ⌜aab⌟
say 'aab' ~~ / a+ || \w+ /; # Output: ⌜aa⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中, <code>a+</code> 匹配 aa, 而 <code>\w+</code> 可以匹配整个字符串 aab。在 <code>|</code> 的情况下, <code>|</code> 作为析取运算符, 更长的匹配胜出, 因此该正则表达式匹配整个字符串。对于 <code>||</code>, 第一部分,  <code>a+</code> 匹配成功, 所以甚至不需要尝试第二个分支。</p>
</div>
<div class="paragraph">
<p>当你编写备选项时, 你可以让第一个分支留白, Raku 会忽略这个空的分支。这纯粹是出于审美的原因, 所以你可以这样写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/
    | first branch
    | second branch
    | third branch
/</code></pre>
</div>
</div>
<div class="paragraph">
<p>而不是在视觉上有点不太平衡的这种写法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/
      first branch
    | second branch
    | third branch
/</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_连接">3.7. 连接</h3>
<div class="paragraph">
<p>你可以把 <code>|</code> 和 <code>||</code> 看作逻辑或。但是 AND 运算符呢? 大多数的正则表达式实现都会省略它, 但 Raku 却没有。它被拼写成了 <code>&amp;</code>, 就像分词一样, 有一个顺序变体 <code>&amp;&amp;</code>。当我们在后面的章节中讨论你正则表达式的副作用时, <code>&amp;</code> 和 <code>&amp;&amp;</code> 之间的区别就会很明显。</p>
</div>
<div class="paragraph">
<p>当你有一个正则表达式并想要进一步地约束它时, <code>&amp;</code> 运算符很有用。举例来说, 你可能正在文本文档中搜索电话号码, 而你已经有一个电话号码的正则表达式了, 但你记得你要查找的号码中, 有一个 17 的序列。你可以使用此正则表达式搜索这样的号码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;phonenumber&gt; &amp; .* 17 .* /</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&amp;</code> 连词的分支必须匹配字符串的同一部分 , 所以这里 17 用 <code>.*</code> 拉伸右分支的匹配到左分支的匹配来填充。</p>
</div>
<div class="paragraph">
<p>你可以使用同样的技巧来排除某些字符的匹配。例如, 一个不包含数字 9 的电话号码可写为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;phonenumber&gt; &amp; &lt;-[9]&gt;* /</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_零宽断言">3.8. 零宽断言</h3>
<div class="paragraph">
<p>你怎么能实现自己的锚点呢?</p>
</div>
<div class="paragraph">
<p>到目前为止, 我们讨论过的正则表达式结构不允许你这样做, 因为他们都需要消耗字符来决定是否匹配。</p>
</div>
<div class="paragraph">
<p>零宽度断言将另一个正则表达式变为锚点, 使它们不消耗输入字符串中的任何字符。它们有两种变体: 向前查看和向后查看断言。<sup class="footnote">[<a id="_footnoteref_14" class="footnote" href="#_footnotedef_14" title="View footnote.">14</a>]</sup></p>
</div>
<div class="paragraph">
<p>向前查看断言被拼写为 <code>&lt;?before regex&gt;</code>, 它将正则表达式转换为锚点。因此, 如果你想匹配数字后跟一个单位 (例如 KB 表示千字节或 MB 表示兆字节), 但不匹配单位本身, 你可以用这样的正则表达式来匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'up to 200 MB' ~~ / \d+ &lt;?before \s* &lt;[kMGT]&gt;? B &gt; /;
# Output: ⌜200⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, 正则表达式 <code>\s* &lt;[kMGT]&gt;? B</code> 匹配可选的空格,  然后是单位 B、KB、MB、GB 或 TB。周围的 <code>&lt;?before &#8230;&#8203;&gt;</code> 使只有当单位的正则表达式匹配时, 匹配才会成功。请注意, 这个断言没有推进字符串中正则表达式的位置, 因此匹配单元的字符串不包含在整个正则表达式所匹配的字符串中。<sup class="footnote">[<a id="_footnoteref_15" class="footnote" href="#_footnotedef_15" title="View footnote.">15</a>]</sup></p>
</div>
<div class="paragraph">
<p>你可以使用 <code>!</code> 代替 <code>?</code> 来否定向前查看。所以要匹配一个数字, 其后面不是单位, 你可以使用正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'up to 200 MB' ~~ / \d+ &lt;!before \s* &lt;[kMGT]&gt;? B &gt; /;
# Output: ⌜20⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下, 正则表达式只匹配字符串 20, 因为它是一个后面不直接跟随单位的数字。如果你根本不想让它匹配这个输入字符串, 你可以在这个数字周围使用单词边界断言:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'up to 200 MB' ~~ / « \d+ » &lt;!before \s* &lt;[kMGT]&gt;? B &gt; /;
# Output: Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们也可以编写从当前位置向后查看的正则表达式, 而不是向前看字符串。匹配一个后面跟随逗号的数字, 你可以这样写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '200,50' ~~ / &lt;?after \, &gt; \d+ /; # Output: ⌜50⌟</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '200,50' ~~ / &lt;!after \, &gt; \d+ /; # Output: ⌜200⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用正向和反向向前查看和向后查看断言, 你可以重新实现内置的锚点,<sup class="footnote">[<a id="_footnoteref_16" class="footnote" href="#_footnotedef_16" title="View footnote.">16</a>]</sup> 你也可以编写自己的锚点。例如, <code>^</code> 匹配字符串的开头, 也可以写成 <code>&lt;!after .&gt;</code>; 只有在没有字符出现在它之前时才匹配。同样地, 左单词边界 <code>«</code>, 可以写成 <code>&lt;!after \w&gt; &lt;?before \w&gt;</code>。左单词边界就可以写成 <code>&lt;!after \d&gt; &lt;?before \d&gt;</code>。</p>
</div>
<div class="paragraph">
<p>需要注意的是, <code>&lt;!after \w&gt;</code> 和 <code>&lt;?after \W&gt;</code> 虽然相似, 但不尽相同。不同之处在于, <code>&lt;!after \w&gt;</code> 匹配字符串的开头, 而 <code>&lt;?after \W&gt;</code> 不是, 因为它需要匹配一个非单词字符。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_2">3.9. 总结</h3>
<div class="paragraph">
<p>正则表达式的基本构建块是字面值、字符类、锚点、量词、分词(备选项)和连词(重叠)。他们构成了使用 Raku 正则表达式进行检索、验证和解析的基础。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_正则表达式和_raku_代码">4. 正则表达式和 Raku 代码</h2>
<div class="sectionbody">
<div class="paragraph">
<p>现在你已经知道了正则表达式的基本构件, 我们将探讨在 Raku 代码中使用正则表达式的不同方法。</p>
</div>
<div class="sect2">
<h3 id="_智能匹配">4.1. 智能匹配</h3>
<div class="paragraph">
<p>智能匹配操作符 <code>~~</code> 是一个通用的比较运算符, 它右侧的对象决定了比较的语义。 例如, 如果右侧的对象是数字, 则 <code>~~</code> 就会进行数值比较。如果右侧的对象是一个类型, 则检查左侧的对象是否为该类型(或其子类型)。</p>
</div>
<div class="paragraph">
<p>我们特别感兴趣的是, 右侧是正则表达式的情况。 在这种情况下, 智能匹配操作符将左侧解释为字符串, 并使用该正则表达式搜索匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = "If I had a hammer, I'd hammer in the morning";
say $str ~~ /h.mm\w*/; # Output: ⌜hammer⌟
say $str ~~ /hummer/;  # Output: Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果匹配失败, 则匹配的返回值为 <code>Nil</code>, 或者如果匹配成功则返回一个<a href="https://docs.raku.org/type/Match.html">匹配对象</a>。<sup class="footnote">[<a id="_footnoteref_17" class="footnote" href="#_footnotedef_17" title="View footnote.">17</a>]</sup>如果在布尔值上下文中使用匹配对象 (比如 if 语句的条件), 则它的计算结果为 <code>True</code> (而 Nil 计算为 <code>False</code>); 在字符串上下文中(或通过调用 <code>.Str</code> 方法将其强制转换为字符串上下文时), 它计算为与正则表达式匹配到的字符串部分。从 <code>say</code> 输出的角括号( <code>⌜</code> 和 <code>⌟</code> ) 表示匹配对象。</p>
</div>
<div class="paragraph">
<p>除了智能匹配之外, 你还可以使用 <a href="https://docs.raku.org/type/Str#method_match">.match</a><sup class="footnote">[<a id="_footnoteref_18" class="footnote" href="#_footnotedef_18" title="View footnote.">18</a>]</sup> 方法在字符串中搜索匹配项:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = "If I had a hammer, I'd hammer in the morning";
say $str.match(/h.mm\w*/); # Output: ⌜hammer⌟</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_引号形式">4.2. 引号形式</h3>
<div class="paragraph">
<p>到目前为止, 我们已经看到由两个斜杠 <code>/&#8230;&#8203;/</code> 分隔的正则表达式, 但是还有其他的方法来编写正则表达式。这些都是等价的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ a.b /;
rx/ a.b /;
rx{ a.b };
rx! a.b !;
regex { a.b }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你使用 <code>rx</code> 编写正则表达式, 则可以使用几乎所有的非单词字符作为分隔符(除了空格、冒号(<code>:</code>)和井号(<code>#</code>)之外)。</p>
</div>
<div class="paragraph">
<p>前面介绍的形式返回一个 regex 类型的对象, 你可以将其存储在变量中, 或者在智能匹配操作中使用。</p>
</div>
<div class="paragraph">
<p>此外, 还有一个使用 <code>m</code>(意为 match)而不是 <code>rx</code> 的形式。 它不是返回正则表达式对象, 而是立即将正则表达式与特殊变量 <code>$_</code> 匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = 'abc';
if m/b./ {
    say "match";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于智能匹配运算符 <code>~~</code> 自动将 <code>$_</code> 设置为表达式的左侧, 所以在智能匹配中可以使用 <code>m/&#8230;&#8203;/</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "abc" ~~ m/b/; # Output: ⌜b⌟</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_修饰符">4.3. 修饰符</h3>
<div class="paragraph">
<p>修饰符改变了正则表达式的工作方式。它们分为两类。如果你把正则表达式看作是被编译为字节码<sup class="footnote">[<a id="_footnoteref_19" class="footnote" href="#_footnotedef_19" title="View footnote.">19</a>]</sup>的小程序, 那么有些修饰符会影响编译, 有些修饰符则会影响你调用程序的方式。</p>
</div>
<div class="paragraph">
<p>例如, <code>:global</code> 修饰符(短形式 <code>:g</code>)属于后一类; 它指示正则表达式搜索字符串中所有不重叠的匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = "If I had a hammer, I'd hammer in the morning";
say $str.match(:global, /h.mm\w*/).join('|');
# Output: hammer|hammer</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一种类别的一个例子是 <code>:ignorecase</code>(简称 <code>:i</code>),  它指示正则表达式引擎忽略大小写, 因此正则表达式中的大写字符可以与小写的等效字符匹配, 反之亦然<sup class="footnote">[<a id="_footnoteref_20" class="footnote" href="#_footnotedef_20" title="View footnote.">20</a>]</sup>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'Hello, world'.match(/:i hello/); # Output: ⌜Hello⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>如前文所示, 影响到正则表达式编译的修饰符可以在正则表达式本身内部使用。影响编译后的正则表达式行为的修饰符总是在外部使用。</p>
</div>
<div class="paragraph">
<p>由于 <code>m/&#8230;&#8203;/</code> 形式是立即匹配的, 所以你也可以给它添加会影响正则表达式的运行时行为的修饰符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ('abc' ~~ m:g/./).elems; # Output: 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 <code>m:g/./</code> 返回一个含有三个匹配项的列表, 所以 <code>.elems</code> 方法返回数字 3。(见表 4-1。)</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. 影响正则表达式编译行为的修饰符或它的一部分</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>长形式</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>短形式</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>描述</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ignorecase</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:i</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配时忽略字母大小写</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ignoremark</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:m</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配时忽略重音或组合字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:sigspace</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把空白视为重要的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ratchet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:r</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">禁用回溯</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><code>:ignoremark</code> 或 <code>:m</code> 修饰符允许你只用基本字符进行匹配, 而忽略变音符号和其他装饰字符的标记。在 <code>:m</code> 的作用下, <code>/a/</code> 可以匹配 a, à, á, â, ã, ä, å, ā 和其他 22 个字符。</p>
</div>
<div class="paragraph">
<p><code>:sigspace</code> 修饰符使 grammar 匹配中的空格与字符串中的空格匹配, 尽管不一定是一对一的映射。<code>:ratchet</code> 修饰符禁用回溯, 所以如果正则表达式引擎成功地以一种方式匹配字符串, 它不会再尝试以另一种不同的方式匹配。我们稍后将更详细地讨论这两个修饰符。</p>
</div>
<div class="paragraph">
<p>这些修饰符也可以放在正则表达式的中间, 或者通过方括号组 <code>[&#8230;&#8203;]</code> 组来限制正则表达式的一部分:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ ab :i cd /;   # match only the cd case-insensitively
/ [:i ab] cd /; # match only the ab case-insensitively</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以通过在冒号后面添加感叹号来禁用修饰符。所以最后一个正则表达式可以写成 <code>/:i ab :!i cd/</code>。 (见表4-2。)</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. 影响编译正则表达式运行使行为的修饰符</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>长形式</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>短形式</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>描述</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:global</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:g</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">找到所有不重叠的匹配</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:overlap</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ov</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:exhaustive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">找到所有可能的匹配</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:continue(5)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:c(5)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从位置 5 开始搜索</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:pos(5)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:p(5)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从位置 5 开始并锚定</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:nth(5)</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回第 5 个匹配</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>所有接收参数的形式(此处为 5)也可以接受变量作为他们的参数。从字符串的开头位置从零开始计数, 就像使用 <a href="https://docs.raku.org/type/Str#routine_substr">substr</a><sup class="footnote">[<a id="_footnoteref_21" class="footnote" href="#_footnotedef_21" title="View footnote.">21</a>]</sup> 进行字符串索引一样。</p>
</div>
<div class="paragraph">
<p>如果你用 <code>:global</code> 搜索多个匹配项, 则第二个匹配的搜索从第一个匹配结束的地方开始。使用 <code>:overlap</code>, 第二个匹配的搜索从第一个匹配的下一个字符开始, 因此这两个匹配的匹配字符串可以重叠。<code>:exhaustive</code> 修饰符找到所有可能的匹配, 即使有几个匹配都从同一个位置开始。</p>
</div>
<div class="paragraph">
<p>如果你使用不带参数的 <code>:continue</code> 和 <code>:pos</code> 修饰符, 它们将默认为上一个匹配离开时的位置。</p>
</div>
</div>
<div class="sect2">
<h3 id="_comb_和_split">4.4. comb 和 split</h3>
<div class="paragraph">
<p>如果你想在一个字符串中找到正则表达式出现的所有次数, 但你只是对结果字符串感兴趣(而不是对匹配对象感兴趣), 你可以使用 <a href="https://docs.raku.org/type/Str#routine_comb">comb</a><sup class="footnote">[<a id="_footnoteref_22" class="footnote" href="#_footnotedef_22" title="View footnote.">22</a>]</sup> 方法找出它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @numbers = "1308 5th Avenue".comb(/\d+/);
say @numbers;       # Output: [1308 5]</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反, 如果你只对字符串中不匹配正则表达式的部分感兴趣 , 那么 <a href="https://docs.raku.org/type/Str#routine_split">split</a><sup class="footnote">[<a id="_footnoteref_23" class="footnote" href="#_footnotedef_23" title="View footnote.">23</a>]</sup> 方法适合你:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my ($city, $area, $popul) = 'Berlin;891.8;3671000'.split(/';'/);
say $area;          # Output: 891.8</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, 正则表达式只包含一个字面量; 在这种情况下, 你可以直接将字面字符串传递给 <code>split</code>, 就像 'Berlin; 891.8; 3671000'.split(';'); 那样。</p>
</div>
<div class="paragraph">
<p><code>comb</code> 和 <code>split</code> 方法都接收第二个可选的参数 <code>limit</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my ($city, $rest) = 'Berlin;891.8;3671000'.split(';', 2);
say $city;          # Output: Berlin
say $rest;          # Output: 891.8;3671000</code></pre>
</div>
</div>
<div class="paragraph">
<p>split 方法对于解析简单文件格式很有用, 例如逗号分隔的不带引号的文件。</p>
</div>
</div>
<div class="sect2">
<h3 id="_替换">4.5. 替换</h3>
<div class="paragraph">
<p>你不仅可以用正则表达式来匹配文本, 还可以用正则表达式来转换文本。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Str#method_subst">subst</a><sup class="footnote">[<a id="_footnoteref_24" class="footnote" href="#_footnotedef_24" title="View footnote.">24</a>]</sup> 方法可以用另一个字符串替换正则表达式所匹配的字符串部分。在最简单的情况下, 替代者是一个字符串常量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '42 eur'.subst( rx:i/ « eur » /, '€'); # Output: 42 €</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果替代者是空字符串, 则替换将删除匹配的字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '42 €'.subst(/\s+/, '');               # Output: 42€</code></pre>
</div>
</div>
<div class="paragraph">
<p>与正则表达式匹配一样, 修饰符和替换可以一块儿用。例如, <code>:global</code> 替换正则表达式匹配的所有出现过的字符串(而不仅仅是第一个, 即没有修饰符时):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '1 2 3'.subst(/\s+/, '');              # Output: 12 3
say '1 2 3'.subst(:g, /\s+/, '');          # Output: 123</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你希望替换的字符串取决于匹配到的值, 你可以传递子程序或块作为替换部分, 它接收匹配对象作为其参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "9 of spades".subst(/\d+/, -&gt; $m { $m + 1 });
    # Output: 10 of spades</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种替换块中, 像 <code>$0</code>, <code>$1</code> 等匹配变量(下一章会有更多介绍)都不起作用, 除非你明确声明匹配变量 <code>$/</code> 作为这个块的参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "9 of spades".subst(/(\d+)/, -&gt; $/ { $0 + 1 });
    # Output: 10 of spades</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有一种语法上的变体, 用于原地修改变量的替换。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $var = '1 2 3';
$var ~~ s:g/ \s+ //;
say $var;                                  # Output: 123</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, 在这种情况下, 第一个斜线和第二个斜线(<code>/</code>)之间的部分是一个正则表达式, 但第二个斜线和第三个斜线之间的部分是一个字符串。这意味着在第一部分中, 空格被忽略, 但在第二部分中空格是有关的。在替换字符串内部, 你可以使用 <code>$0</code>、<code>$1</code>、<code>$2</code> 等等, 用于引用捕获(有关捕获的更多信息, 请参阅下一章):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $var = '"fantastic", she said';
$var ~~ s:g/ \" (.*?) \" /«$0»/;
say $var;           # Output: «fantastic», she said</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你使用 <code>[&#8230;&#8203;]</code> 或 <code>{&#8230;&#8203;}</code> 来分隔正则表达式, 那么替换部分也可以是 Raku 表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $ad = 'Buy now! USD 10 per book. Prices double soon to 20.';
$ad ~~ s:g[ \d+ ] = 2 * $/;
say $ad;</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中 <code>$/</code> 指的是匹配对象。注意, 在这种情况下, 赋值运算符是在右侧之前使用的。</p>
</div>
<div class="paragraph">
<p>这会产生如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Buy now! USD 20 per book. Prices double soon to 40.</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你替换零宽度匹配时, 替换就变成了插入操作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $input = "It's just a jump to the left.
And then a step to the right.";

$input ~~ s:g/ &lt;?before jump&gt; /⇑/;
$input ~~ s:g/ &lt;?before left&gt; /←/;
$input ~~ s:g/ &lt;?after right&gt; /→/;

say $input;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的 <code>&lt;?before &#8230;&#8203;&gt;</code> 和 <code>&lt;?after &#8230;&#8203;&gt;</code> 将它们内部的正则表达式变成零宽度的正则表达式, 所以替换命令并不会替换匹配的文本(如 "jump"), 而是在匹配之前或之后插入替换部分
:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">It's just a ⇑jump to the ←left.
And then a step to the right→.</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以把普通匹配和零宽度匹配结合起来。例如, 这个语句将后面跟着单位 MB 或 GB 的所有数字都替换为 500:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $input = '2 links with 75MB each';
say $input.subst(:g, / \d+ &lt;?before &lt;[MG]&gt; B&gt;/, 500);
    # Output: 2 links with 500MB each</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_跨越代码和正则表达式边界">4.6. 跨越代码和正则表达式边界</h3>
<div class="paragraph">
<p>正则表达式和普通的 Raku 代码编译成相同的字节码, 而你可以将 Raku 代码和正则表达式混合使用。</p>
</div>
<div class="paragraph">
<p>最明显的交互方式是将 regex 对象存储在变量, 然后在普通代码中使用它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $word-regex = /\w+/;
say "Hello, world" ~~ $word-regex;    # Output: ⌜Hello⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样, 你可以为正则表达式起个名字, 同时也可以做所有其他可以用变量做的事情: 把它们放到数据结构中, 然后从函数中返回, 等等。</p>
</div>
<div class="paragraph">
<p>反过来也可以。变量可以成为正则表达式的一部分:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $audience = 'world';
my $greeting = 'Hello';

if "Hello, world" ~~ / $greeting ', ' $audience / {
    # this branch is executed
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果一个变量包含一个字符串, 它总是按字面意思匹配; 如果它包含正则表达式, 则作为正则表达式匹配。</p>
</div>
<div class="paragraph">
<p>如果要把变量的内容解释为正则表达式, 你必须将它包含在尖括号中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $audience = "\\w+";
my $greeting = 'Hello';

if "Hello, world" ~~ / $greeting ', ' &lt;$audience&gt; / {
    # this branch is executed
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例还演示了反斜杠必须在引用的字符串中加倍 - 本例中是赋值给变量 <code>$audience</code> - 但不是正则表达式。在双引号字符串中, 反斜杠引入了一个转义序列(例如 <code>\n</code> 表示换行符, <code>\t</code> 表示制表符)。使用语法 <code>&lt;$audience&gt;</code> 可以将变量 <code>$audience</code> 的内容解释为正则表达式。</p>
</div>
<div class="paragraph">
<p>在正则表达式中使用数组变量相当于将数组中的每个元素作为备选项进行匹配; 因此</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @numbers = 'one', 'two', 'three';
my $regex = / @numbers /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>等价于这样写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $regex = / [ 'one' | 'two' | 'three' ] /</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了一点, 使用数组变量时, 用程序化的方式提供值比较容易。</p>
</div>
<div class="paragraph">
<p>最后, 你可以在正则表达式中包含 Raku 代码块, 只需将其嵌入到花括号中即可。这对于在执行正则表达式时建立数据结构(如符号表)很有用 。</p>
</div>
<div class="paragraph">
<p>例如, 我们可以计算字符串中数字出现的次数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $count = 0;
my $str = "between 23 and 42 numbers";

if $str ~~ / [ \d+ { $count++ } \D* ]+ / {
    say $count;     # Output: 2
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里块 <code>{ $count++ }</code>, 它将变量 <code>$count</code> 增量 1, 在正则表达式的 <code>\d+</code> 部分之后执行。虽然这是一个有点构造化的用例, 我们将在后面的章节中看到正则表达式代码块的实际应用。</p>
</div>
<div class="paragraph">
<p>正则表达式中代码块的另一个很好的用例是添加 <code>print</code> 语句用于调试, 以查看正则表达式是如何匹配的。</p>
</div>
<div class="paragraph">
<p>这里我们尝试将浮点数与正则表达式匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '1.0e42' ~~ / ^ \d+ ['.' \d+]?  [e|E \d+]? $ /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个正则表达式匹配失败了, 要看这个正则表达式匹配到什么程度, 你可以删除使片段可选的问号, 然后添加一些代码块来显示增量进度:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'1.0e42' ~~ / ^
    \d+        { say "integer: '$/'" }
    ['.' \d+]  { say "decimal place: '$/'" }
    [e|E \d+]  { say "exponent: '$/'" }
    $ /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这产生如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">integer: '1'
decimal place: '1.0'
exponent: '1.0e'</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以看到这个正则表达式的最后一部分只匹配了 e, 而不是 e42。 仔细观察就会发现 <code>[e|E \d+]</code> 中的备选项延伸到了 <code>\d+</code>, 而这并不是本意。添加一个分组级别, <code>[ [e|E] \d+ ]</code>, 修复该正则表达式。</p>
</div>
<div class="paragraph">
<p>这些代码块使用了特殊变量 <code>$/</code>, 它包含了匹配(或者至少是部分匹配, 就其进展而言)。</p>
</div>
<div class="paragraph">
<p>这些代码块的执行纯粹是为了它们的副作用。你可以使用 <code>&lt;?{&#8230;&#8203;}&gt;</code> 形式来影响正则表达式匹配。如果该代码块中的代码返回 <code>false</code> 值, 则匹配失败<sup class="footnote">[<a id="_footnoteref_25" class="footnote" href="#_footnotedef_25" title="View footnote.">25</a>]</sup>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $one-byte = / ^ \d ** 0..3 $ &lt;?{ $/.Int &lt;= 255 }&gt; /;
for 0, 100, 255, 256, 1000 -&gt; $num {
    if $num ~~ $one-byte {
        say $num;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例的正则表达式匹配 0 到 255 之间的数字(例如, 可能用于验证 IPv4 地址), 并且只打印 0、100 和 255 这些数字。</p>
</div>
<div class="paragraph">
<p><code>$/.Int</code> 调用将匹配的字符串转换为整数, 并且当且仅当该数字最多为 255 时比较 <code>&#8656; 255</code> 才返回 <code>True</code>。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. 把 Raku 代码嵌入正则表达式的方法</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>语法</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>描述</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">{ CODE }</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">运行 Raku 代码, 对正则表达式匹配没有影响</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;?{ CODE }&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配要成功, 则代码需要返回 true 值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;!{ CODE }&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配要成功, 则代码需要返回 false 值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;{ CODE }&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">代码的结果被解释为正则表达式</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;$STRING&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将 $STRING 解释为正则表达式源代码</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_总结_3">4.7. 总结</h3>
<div class="paragraph">
<p>在本章中, 我们已经看到了如何在 Raku 代码中使用正则表达式, 反之亦然。你可以将正则表达式存储在变量中, 也可以在正则表达式中使用变量。</p>
</div>
<div class="paragraph">
<p>在下一章中, 我们将探讨如何从正则表达式匹配中提取信息或其中的部分信息。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_从正则表达式匹配中提取数据">5. 从正则表达式匹配中提取数据</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当你使用正则表达式来验证输入时, 只要知道给定的字符串是否匹配正则表达式就可以了。在其他很多情况下, 我们想要从字符串和正则表达式匹配中提取更多的数据。</p>
</div>
<div class="paragraph">
<p>比如说, 如果你想解析一个 INI 文件(Microsoft Windows 上常见的配置文件格式),  你可能会对节标题和节内的键/值对感兴趣; 但是, 节标题周围的方括号这样的东西我们就不感兴趣了。</p>
</div>
<div class="sect2">
<h3 id="_位置捕获">5.1. 位置捕获</h3>
<div class="paragraph">
<p>你可以通过指示一个正则表达式来捕获一些数据, 通过在正则表达式的一部分的周围加上一对圆括号来提取相关数据。然后, 这部分正则表达式匹配的字符串就会被单独提供:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if "Hello, world" ~~ / (\w+) ', ' (\w+) / {
    say "Greeting: $0";         # Output: Greeting: Hello
    say "Audience: $1";         # Output: Audience: world
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>捕获从左到右, 从零开始编号。 第一对括号中的正则表达式匹配的字符串可以保存在特殊变量 <code>$0</code> 中, 第二对括号中的正则表达式匹配的字符串可保存在特殊变量 <code>$1</code> 中, 以此类推。</p>
</div>
<div class="paragraph">
<p>由于这些捕获的编号取决于它们在正则表达式中的相对位置, 我们称它们为位置捕获。</p>
</div>
</div>
<div class="sect2">
<h3 id="_匹配对象">5.2. 匹配对象</h3>
<div class="paragraph">
<p>每个成功的正则表达式匹配的结果是一个 <a href="https://docs.raku.org/type/Match.html">Match</a><sup class="footnote">[<a id="_footnoteref_26" class="footnote" href="#_footnotedef_26" title="View footnote.">26</a>]</sup> 类型的对象。 当你用智能匹配运算符 <code>~~</code> 匹配一个正则表达式时, 这个正则表达式对象也可以在特殊变量 <code>$/</code> 中使用。</p>
</div>
<div class="paragraph">
<p>匹配对象提供了大量关于正则表达式匹配的信息: <code>$/.orig</code> 包含了正则表达式匹配的字符串, <code>$/.from</code> 和 <code>$/.to</code> 包含了匹配的开始和结束位置, 在字符串上下文中使用它(或通过在它身上显式调用 <code>.Str</code> 方法)返回匹配的字符串。</p>
</div>
<div class="paragraph">
<p>但还有更多: 当你像使用数组一样使用匹配对象时, 你可以从捕获中访问匹配项。<code>$0</code> 实际上是 <code>$/[0]</code> 的别名 , <code>$1</code> 实际上是 <code>$/[1]</code> 的别名, 等等。</p>
</div>
<div class="paragraph">
<p>捕获本身也是 Match 对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $input = "There are 9 million bicycles in Beijing";

if $input ~~ /(\d+) \s+ (\w+)/ {
    say $0.^name;    # Output: Match
    say $1;          # Output: ⌜million⌟
    say $1.from;     # Output: 12
    say $1.to;       # Output: 19
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_捕获嵌套">5.2.1. 捕获嵌套</h4>
<div class="paragraph">
<p>如果在其他捕获中嵌套捕获, 则匹配对象的结构对应于捕获的嵌套:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'abcdef' ~~ /(.) (b(c)(d(e))) /;
say $0.Str;         # Output: a
say $1.Str;         # Output: bcde
say $1[0].Str;      # Output: c
say $1[1].Str;      # Output: de
say $1[1][0].Str;   # Output: e</code></pre>
</div>
</div>
<div class="paragraph">
<p>匹配对象实际上是一个匹配对象的树。</p>
</div>
<div class="paragraph">
<p>正如你在前面的示例中所看到的那样, 捕获的编号是按每一层嵌套的方式进行的; 在这个正则表达式中, 有五对圆括号, 但其中只有两对是顶层的, 所以匹配成功后只有 <code>$0</code> 和 <code>$1</code>, 没有 <code>$2</code> 或更高的级别。相反, 每一级的嵌套还引入了从 0 开始的匹配编号。这与 Perl 5 和 PCRE 语义不同, 在 Perl 5 和 PCRE 语义中, 匹配是连续编号的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_量词化捕获">5.2.2. 量词化捕获</h4>
<div class="paragraph">
<p>当捕获受制于一个量词时, 匹配对象中对应的捕获就变成了匹配对象中的<a href="https://docs.raku.org/type/Array">数组</a><sup class="footnote">[<a id="_footnoteref_27" class="footnote" href="#_footnotedef_27" title="View footnote.">27</a>]</sup>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if "127.0.0.1" ~~ /(\d+)**4 % "."/ {
    say $0.elems;       # Output: 4
    say $0[3].Str;      # Output: 1
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>唯一的例外是 <code>?</code> 量词, 它不会从捕获中产生数组。<sup class="footnote">[<a id="_footnoteref_28" class="footnote" href="#_footnotedef_28" title="View footnote.">28</a>]</sup>相反, 当它匹配一次时, 它的捕获是一个匹配对象,  如果它匹配零次, 则为 <code>Nil</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_命名捕获">5.3. 命名捕获</h3>
<div class="paragraph">
<p>当你有超过两个或三个以上的捕获时, 你可能会忘记哪个编号指向哪个捕获组。为了减轻这种负担, 并使代码在重构时更加健壮, 你可以使用命名捕获来代替:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = 'Hello, World';
if $str ~~ / $&lt;greeting&gt;=[\w+] ', ' $&lt;audience&gt;=[\w+] / {
    say $&lt;greeting&gt;.Str;        # Output: Hello
    say $&lt;audience&gt;.Str;        # Output: World
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$&lt;thename&gt;</code> 在正则表达式内部和外部都指向命名捕获。在正则表达式内部, 你可以给它分配一个名字, 然后在正则表达式外面你可以访问相应的匹配对象。在正则表达式外部, <code>$&lt;thename&gt;</code> 实际上是对匹配对象的命名访问的快捷方式, <code>$/&lt;thename&gt;</code> 或 <code>$/{'thename'}</code>。这种访问命名捕获的模式与访问哈希元素的语法相同。</p>
</div>
<div class="paragraph">
<p>如果在同一个正则表达式中使用了两次(或更频繁地)相同的名字, 那么捕获再次成为一个数组。</p>
</div>
<div class="paragraph">
<p>在后面的章节中, 我们将更详细地讨论命名正则表达式。对于现在, 创建命名捕获的更简单方法就是按名称调用正则表达式就足够了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex byte {
    \d ** 1..3
    &lt;?{ $/.Int &lt;= 255 }&gt;
}

my $str = '127.0.0.1';
if $str ~~ / ^ &lt;byte&gt; ** 4 % '.' $ / {
    for $&lt;byte&gt;.list -&gt; $byte {
        say $byte.Str;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 <code>&lt;byte&gt;</code> 调用命名正则表达式 <code>byte</code>, 并自动捕获由此同名子规则 <code>byte</code> 所匹配到的字符串。你可以使用语法 <code>&lt;alias=originalname&gt;</code> 来重命名捕获:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = 'Hello, World';
my regex word { \w+ };

if $str ~~ /&lt;greeting=word&gt; ', ' &lt;audience=word&gt;/ {
    say $&lt;greeting&gt;.Str;        # Output: Hello
    say $&lt;audience&gt;.Str;        # Output: World
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_反向引用">5.4. 反向引用</h3>
<div class="paragraph">
<p>反向引用允许你访问正则表达式内部的捕获, 匹配正则表达式的前一部分捕获的字符串。这里有几个可能有用的案例, 比如在文本中搜索意外重复的单词时。第一次尝试将是这样的正则表达式: <code>/ (\w+) \s+ $0 /</code> 这个正则表达式匹配一个单词(<code>\w+</code>)并将其捕获到 <code>$0</code> 中, 后面是空格(<code>\s+</code>), 然后再跟着原始单词(<code>$0</code>)。然而这不符合预期。用它来匹配字符串 <code>the next thing</code>, 它会匹配 <code>t t</code>, 因为 <code>\w+</code> 很乐意只匹配一个字符。</p>
</div>
<div class="paragraph">
<p>为了使它工作, 我们可以通过包括单词字边界断言: <code>/ « (\w+) \s+ $0 » /</code> (记住 « 匹配左单词边界而 » 匹配右单词边界)来限制匹配整个单词。</p>
</div>
<div class="paragraph">
<p>现在, 如果你把它与字符串 "the quick brown fox jumps over the the lazy black dog" 进行测试, 它就会正确地匹配两个 "the"。</p>
</div>
<div class="paragraph">
<p>反向引用也适用于命名捕获; 前面的例子可以写成 <code>/« $&lt;word&gt;=\w+ \s+ $&lt;word&gt; »/</code>。</p>
</div>
<div class="paragraph">
<p>反向引用的另一个常见用例是查找类似于引号的字符串, 只要两端都是一样的, 你不用关心实际的引用字符。</p>
</div>
<div class="paragraph">
<p>请注意, 反向引用绝对超出了常规计算机科学中定义的语言的范畴; 你需要更强大的形式主义来实现。</p>
</div>
<div class="sect3">
<h4 id="_跑个题_带反向引用的原始性测试">5.4.1. 跑个题: 带反向引用的原始性测试</h4>
<div class="paragraph">
<p>本节与任何实际应用无关, 但会让你深入了解人们用正则表达式所做的那些疯狂的事情。如果你只是出于实用的原因, 你可以放心地跳过这一部分。</p>
</div>
<div class="paragraph">
<p>质数是一个整数, 只能被数字 1 和它本身整除。</p>
</div>
<div class="paragraph">
<p>你可以使用正则表达式来检验一个数字是否为质数。<sup class="footnote">[<a id="_footnoteref_29" class="footnote" href="#_footnotedef_29" title="View footnote.">29</a>]</sup>首先, 我们必须通过创建一个由相同字符组成的字符串(例如 a)来编码这个数字, 其中字符串中的字符数与数字相同。因此 2 将被编码为 aa, 5 将被编码为 aaaaa, 以此类推。在 Raku 中, 我们可以使用字符串重复运算符 <code>x</code> 来执行此操作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $encoded = 'a' x 5;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后, 我们尝试找到一个大于 1 的因子, 使这个数字均匀地被分割。在我们的编码字符串中, 这是一个由至少有两个字符组成的子串, 当重复次数足够多时(但至少一次)时, 就能重新实现原始编码字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 2..15 -&gt; $number {
    my $encoded = 'a' x $number;
    if $encoded ~~ / ^ (a ** 2..*) $0+ $ / {
        say "$number is not a prime, a factor is ", $0.chars;
    } else {
        say "$number is a prime";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这产生如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">2 is a prime
3 is a prime
4 is not a prime, a factor is 2
5 is a prime
6 is not a prime, a factor is 3
7 is a prime
8 is not a prime, a factor is 4
9 is not a prime, a factor is 3
10 is not a prime, a factor is 5
11 is a prime
12 is not a prime, a factor is 6
13 is a prime
14 is not a prime, a factor is 7
15 is not a prime, a factor is 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如, 如果 <code>$number</code> 为 6, <code>$encoded</code> 就会变成 "aaaaaa"。当第一组(<code>a <strong>* 2..</strong></code>)与三个 a(<code>aaa</code>)匹配时, 正则表达式引擎就会找到匹配。相应地, <code>$0+</code> 产生另外三个 a, 总共六个 a。 在质数的情况下, 正则表达式引擎无法找到这样的分区, 导致匹配失败。</p>
</div>
<div class="paragraph">
<p>由于 <code>**</code> 量词是贪婪的, 因此正则表达式引擎首先找到最大的质数因子, 因此它将 5 识别为 10 的质数因子。如果你把它改成 <code>**?</code> 量词(因此正则表达式变为 <code>/ ^ (a <strong>*? 2..</strong>) $0+ $ /</code>), 它找到最小的质因数。</p>
</div>
<div class="paragraph">
<p>注意, 这是一种非常低效的测试质数的方法, 因为正则表达式引擎没有针对这种任务进行优化, 使用了一个非常低效的数字表示法, 甚至必须尝试所有可能的因子, 甚至是那些很容易被更智能的算法排除的因子。</p>
</div>
<div class="paragraph">
<p>尽管如此, 正则表达式引擎还是能在几秒钟内测试出多达五万个数字。Raku 有一种内置的方法来测试质数, 速度更快, 占用内存更少:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 50101.is-prime; # Output: True</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_重温匹配对象">5.5. 重温匹配对象</h3>
<div class="paragraph">
<p>如前所述, 成功的正则表达式匹配会返回匹配对象。除了匹配的子字符串的位置和长度之外, 匹配对象还存储了所有位置捕获和命名捕获。要获取所有的位置捕获的列表, 可以调用 <code>.list`方法。同样的, `.hash</code> 方法也会将命名捕获作为一个散列返回。散列是一种数据结构, 具有从名称或键到值的映射; Python 称它为 dict 或字典, JavaScript 称之为对象。</p>
</div>
<div class="paragraph">
<p>当使用 <code>say</code> 函数打印匹配对象时, 输出的是以 ⌜⌟ 分割的匹配字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "abc" ~~ /../; # Output: ⌜ab⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果正则表达式包含了捕获, 则会在单独的行中打印出来, 并缩进一个空格。因此</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "abc" ~~ /.(.)(.)/</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">⌜abc⌟
 0 =&gt; ⌜b⌟
 1 =&gt; ⌜c⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中 0 和 1 是捕获的索引。嵌套捕获会产生更多的缩进, 所以 <code>"abc" ∼∼ /.(.(.))/</code> 打印出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">⌜abc⌟
 0 =&gt; ⌜bc⌟
  0 =&gt; ⌜c⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此, 命名捕获仅以其名称来区分:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">"abc" ∼∼ /.(.$&lt;char&gt;=[.])/</code></pre>
</div>
</div>
<div class="paragraph">
<p>打印:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">⌜abc⌟
0 =&gt; ⌜bc⌟
char =&gt; ⌜c⌟</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_4">5.6. 总结</h3>
<div class="paragraph">
<p>捕获允许你从成功的正则表达式匹配中提取数据。你可以通过在正则表达式的一部分的周围添加一对圆括号, 使用 <code>$&lt;name&gt;=[&#8230;&#8203;]</code> 语法, 或者通过调用一个命名的正则表达式, 来指示正则表达式引擎捕获数据: <code>&lt;name&gt;</code>。</p>
</div>
<div class="paragraph">
<p>正则表达式匹配和捕获都产生匹配对象; 最上面的匹配对象会变成一棵子匹配树。反向引用允许你精确地匹配一个正则表达式的前一部分的匹配对象, 你可以滥用该功能来构建一个简单的质数测试。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_正则表达式技术性细节">6. 正则表达式技术性细节</h2>
<div class="sectionbody">
<div class="paragraph">
<p>有时候正则表达式看起来会很神秘。它们往往有不同的方式来匹配字符串。如何找到匹配项？哪一个匹配项先被找到？</p>
</div>
<div class="paragraph">
<p>本章通过解释正则表达式引擎的使用机制来揭开它神秘的面纱。理解这些机制是编写你想要的健壮的、恰到好处的正则表达式的关键。</p>
</div>
<div class="paragraph">
<p>我们的讨论因 Raku 正则表达式中实现的两种不同范式而略显复杂: 带有限状态机的声明式匹配以及更强大的回溯引擎。</p>
</div>
<div class="sect2">
<h3 id="_带状态机的匹配">6.1. 带状态机的匹配</h3>
<div class="paragraph">
<p>当计算机科学家谈论常规语言时，他们也会描述一种有效识别特定字符串是否为该语言的一部分的机制 。在 Raku 中，这只是字符串是否匹配正则表达式。</p>
</div>
<div class="sect3">
<h4 id="_确定性状态机">6.1.1. 确定性状态机</h4>
<div class="paragraph">
<p>用于识别匹配字符串的机制是有限状态机。它是一组在它们之间带有箭头的状态。每个箭头都用单个字符标记。机器从输入字符串中单独读取每个字符，并使用与标签相同的箭头作为当前的字符。如果没有标有当前字符的箭头，匹配立即失败。</p>
</div>
<div class="paragraph">
<p>一些状态被标记为接受状态。在从输入字符串读取最后一个字符之后，如果最终状态为接受状态，则匹配成功。否则，它会失败(图 6-1)。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://s3-img.meituan.net/v1/mss_3d027b52ec5a4d589e68050845611e68/ff/n0/0h/y9/mz_101004.jpg@596w_1l.jpg" alt="state mechine">
</div>
<div class="title">Figure 1. Figure 6-1 一个简单的确定性有限自动机。可接受状态 A1 用两个圆标记</div>
</div>
<div class="paragraph">
<p>考虑示例中的自动机。起始状态是 A0，从那开始它需要读取字符 a 才能进入接受状态 A1。它然后可以读取 b，然后 c 以回到接受状态，所以它接受的字符串与正则表达式 <code>/ ^ a [bc]* $ /</code> 相同。<sup class="footnote">[<a id="_footnoteref_30" class="footnote" href="#_footnotedef_30" title="View footnote.">30</a>]</sup>我们称这它为自动机 A。</p>
</div>
<div class="paragraph">
<p>对于每个状态，最多只有一个箭头携带某个特定字符离开该状态。因此，机器一次只处于一种状态，而我们称之为确定性有限自动机，或简称为 DFA。</p>
</div>
<div class="paragraph">
<p>可以在代码中非常有效地实现 DFA。对于每个状态，你需要一个将输入字符映射到下一个状态的查找表， 这意味着你只需要在输入字符串的每个字符上花费固定数量的步骤。</p>
</div>
<div class="paragraph">
<p>如前面的自动机所示，您可以使用它匹配字面量，你可以用向后的箭头来实现 <code>*</code> 量词 。它也支持备选分支，尽管它们可能有点棘手。</p>
</div>
<div class="paragraph">
<p>首先，让我们修改原始自动机以匹配 <code>/ ^ a [bca]* $ /</code> (图 6-2)。</p>
</div>
<div class="imageblock">
<div class="content">
<img src=":https://s3-img.meituan.net/v1/mss_3d027b52ec5a4d589e68050845611e68/ff/n0/0h/y9/pf_100956.jpg@596w_1l.jpg" alt="state mechinne">
</div>
<div class="title">Figure 2. 图 6-2 一个简单的匹配正则表达式 / ^ a [bca]* $ / 的自动机</div>
</div>
<div class="paragraph">
<p>我们称之为自动机 B。</p>
</div>
<div class="paragraph">
<p>现在我们要构建一个自动机来匹配 A 或 B 匹配的字符串。我们可以通过创建一个同时运行两个自动机的自动机来实现。两个自动机的起始状态是 A0 和 B0，所以让我们称之为新的起始状态 A0B0。从这个起始状态，读取 a 并从 A0 到 A1移动自动机 A 和从 B0 到 B1 移动自动机 B ，所以下一个状态是 A1B1。所以至少有一个原始状态正处于可接受状态，A1B1 也是如此(图 6-3)。</p>
</div>
<div class="paragraph">
<div class="title">图 6-3 部分构造自动机 A 或 B 的第一步</div>
<p>第三种状态也非常明显:从 A1 或 B1 读取 a b 将我们分别移至 A2 和 B2(图 6-4)。</p>
</div>
<div class="paragraph">
<div class="title">图 6-4  部分构造自动机 A 或 B 的第二步</div>
<p>现在它开始变得有趣了:在读取字符 c 时，A 转换为状态A1，但 B 转换为状态 B0。我们需要一个我们称之为 A1B0 的状态。因为 A1 是接受状态，A1B0 也接受状态(图 6-5)。</p>
</div>
<div class="paragraph">
<div class="title">图 6-5 部分构造自动机 A 或 B 的第三步</div>
<p>如果下一个字符是 a，会发生什么? 自动机 A 拒绝了输入，自动机 B 移动到状态 B1。所以我们可以在这儿复制自动机 B(图 6-6)。</p>
</div>
<div class="paragraph">
<div class="title">图 6-6 部分构造自动机 A 或 B 的第四步</div>
<p>同样地，从状态 A1B0 读取字符 b 使自动机 B 失败，并将自动机 A 移动到状态 A2。因此，我们可以复制状态 A1 和 A2 进入新的自动机(A0 无法从那里到达)，我们得到了我们的最终结果(图 6-7)。</p>
</div>
<div class="paragraph">
<div class="title">图 6-7 构造完全的匹配 A 或 B 的自动机</div>
<p>这种机制称为 <a href="https://en.wikipedia.org/wiki/Powerset_construction">幂集构造</a><sup class="footnote">[<a id="_footnoteref_31" class="footnote" href="#_footnotedef_31" title="View footnote.">31</a>]</sup>，因为新的状态集合是源自动机的幂。</p>
</div>
<div class="paragraph">
<p>在我们的例子中，得到的自动机有九个状态，而 A 和 B 每个只有三个状态。如果我们必须建立几个自动机的析取，在最坏的情况下，结果自动机中状态的数量与每个输入自动机的状态数的乘积成正比。或者换句话说，状态的数量可以与我们想要的建模的正则表达式的字符数呈指数关系增长。</p>
</div>
</div>
<div class="sect3">
<h4 id="_非确定性状态机">6.1.2. 非确定性状态机</h4>
<div class="paragraph">
<p>这种状态爆炸限制了正则表达式匹配代码中 DFA 的实用性。相反，正则表达式实现通常使用非确定性有限自动机，或简称 NFA。NFA 允许用同一个字符标记多个箭头， 以区分不同的状态。不确定的部分是正则表达式引擎必须猜测要遵循哪个箭头，或者它只是跟随所有这些箭头，导致机器可以一次超过一个状态的模型。</p>
</div>
<div class="paragraph">
<p>如果您将状态和标记箭头视为游戏板，请启动匹配将芯片置于初始状态。当你读取输入字符时，你遵循所有相关的箭头并在每个目标状态上放置一个芯片。最后，你从以前的状态中删除芯片。</p>
</div>
<div class="paragraph">
<p>为了使构建 NFA 更容易，人们通常允许所谓的 epsilon(ε)过渡。NFA遵循这些箭头而不消耗 输入字符。或者用不同的方式表达:如果你有从国家转移的ε C0到C1，只要将一个芯片放在C0上，就会在C1上放置第二个芯片。
通过这些ε过渡，创建两个自动机的分离变为 简单。您只需添加一个新起点C0，然后添加ε过渡到 结合自动机的起点(图 6-8)。瞧:</p>
</div>
<div class="paragraph">
<p>确定性和非确定性有限自动机是同等的 强大。对于每个NFA，您可以构建一个完全匹配的DFA 相同的字符串 相反，每个DFA也是一个NFA，因为规则 NFA比DFA更宽松。</p>
</div>
<div class="paragraph">
<p>从正则表达式构建NFA通常要快得多(并且可以使用 显着减少内存)比构建相应的DFA。在 在运行时，NFA可能必须推进多个状态(想想中的芯片) 以前的类比)，所以在最坏的情况下，它需要采取的步骤数 与每个输入字符的NFA状态数成比例。</p>
</div>
<div class="paragraph">
<p>Raku使用NFA来匹配我们讨论过的大多数正则表达式功能远，包括文字，量词，连词和分离作为字符类(它只是一种方便的析取语法)。 NFA无法处理的正则表达式是顺序析取 (||)和连词(&amp;&amp;)，锚点，反向引用，代码块和代码 断言，以及我们稍后将讨论的一些功能:正则表达式 显式回溯控制，递归，前瞻和后视。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_正则表达式控制流">6.2. 正则表达式控制流</h3>
<div class="paragraph">
<p>在正则表达式引擎无法使用NFA或其他地方的情况下 了解NFA并不能提供有关正则表达式的深入见解 将匹配，了解一般正则表达式的控制流程是有用的 发动机。第一条规则是正则表达式引擎总是从字符串的开头开始并且更喜欢最左边的匹配。</p>
</div>
<div class="paragraph">
<p>第二条规则是贪婪的规则: 正则表达式是从中评估的 从左到右，每个部分可以匹配可变数量的字符尝试匹配它可以使用的最长子字符串。<sup class="footnote">[<a id="_footnoteref_32" class="footnote" href="#_footnotedef_32" title="View footnote.">32</a>]</sup></p>
</div>
<div class="paragraph">
<p>因此，如果你有正则表达式 <code>/ \w+ .* /</code> 并对字符串abcd运行它，  <code>\w+</code> 匹配整个字符串，使 <code>.*</code> 成功匹配
空字符串。<code>\w+</code> 匹配第一个字符和 <code>.*</code> 的匹配项 其余的同样允许，但不会发生，因为它违反了 正则表达式最左边部分匹配的规则尽可能多。</p>
</div>
<div class="paragraph">
<p>如果您尝试将带引号的字符串与简单的正则表达式 <code>/ \" .* \"/</code> 匹配，则它 它可能比您预期的更匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = 'Amanda sighed. "It was madness", she said. '
    ~ '"Sheer madness"';
if $str ~~ / \" .* \" / {
    say $/.Str;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这产生如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">"It was madness", she said. "Sheer madness"</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为 <code>*</code> 并不在乎你不打算过去匹配 第一个引用的边界; 它只是尽可能多地匹配，而 仍然使整个匹配成功。</p>
</div>
</div>
<div class="sect2">
<h3 id="_回溯">6.3. 回溯</h3>
<div class="paragraph">
<p>贪婪的规则并不总是在第一次尝试时产生匹配。 在前面的例子中，<code>.*</code> 首先匹配所有可能的，包括输入字符串中的最终引号。正则表达式中的最终引用没有任何内容匹配，导致失败。</p>
</div>
<div class="paragraph">
<p>正则表达式引擎没有放弃，而是开始回溯:它开始了 回到上一个量词(<code>* in .*</code>)，并使其少一个 重复。只有这样，正则表达式中的引用才能找到引用 输入字符串，使整个正则表达式匹配成功。
如果有多个正则表达式元素可以以不同方式匹配，回溯尝试从最后一个元素中选择所有选项，如果它们全部失败，从倒数第二个元素尝试另外一个选项。然后探讨该配置中最后一个元素的所有变体并继续尝试从以前的元素搜索匹配。如果你想到的话它作为搜索树，是深度优先搜索。</p>
</div>
<div class="paragraph">
<p>让我们考虑一个带有两个可变部分的正则表达式，并结合搜索:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'mabracadabra' ~~ / (.+a) (.*) $0 /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这从匹配完整字符串的第一组(<code>.+ a</code>)开始; 该 第二组(<code>.<strong></code>)匹配空字符串; 最后一部分，<code>$0</code>，没有 比赛。因此，回溯开始并询问第二组 匹配较少的字符，但不能; 所以它又回到了第一个 组并要求它匹配较少的字符。现在第一组比赛 mabracada 和 <code>.</strong></code> 匹配剩下的三个角色。还是， 最后一组无法匹配，所以 <code>.*</code> 放弃了另一个角色和最后一个角色 小组继续失败。这个循环重复，直到第一组只匹配两个字符，ma。 即使在此配置中，正则表达式的其余部分也无法成功匹配。 正则表达式引擎没有选项，所以它进入了最后的机制 度假:它试图在第二个位置向左开始一个位置字符。</p>
</div>
<div class="paragraph">
<p>从第二个字符开始，第一个组再次尝试匹配整个剩余的绳子，abracadabra。我们可以通过添加一个来可视化 正则表达式的第二部分之后的代码块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'mabracadabra' ~~ /(.+a) (.*) { say "0: '$0'; 1: '$1'" } $0 /;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">0: 'mabracadabra'; 1: ''
0: 'mabracada'; 1: 'bra'
0: 'mabracada'; 1: 'br'
0: 'mabracada'; 1: 'b'
0: 'mabracada'; 1: ''
0: 'mabraca'; 1: 'dabra'
0: 'mabraca'; 1: 'dabr'
0: 'mabraca'; 1: 'dab'
0: 'mabraca'; 1: 'da'
0: 'mabraca'; 1: 'd'
0: 'mabraca'; 1: ''
0: 'mabra'; 1: 'cadabra'
0: 'mabra'; 1: 'cadabr'
0: 'mabra'; 1: 'cadab'
0: 'mabra'; 1: 'cada'
0: 'mabra'; 1: 'cad'
0: 'mabra'; 1: 'ca'
0: 'mabra'; 1: 'c'
0: 'mabra'; 1: ''
0: 'ma'; 1: 'bracadabra'
0: 'ma'; 1: 'bracadabr'
0: 'ma'; 1: 'bracadab'
0: 'ma'; 1: 'bracada'
0: 'ma'; 1: 'bracad'
0: 'ma'; 1: 'braca'
0: 'ma'; 1: 'brac'
0: 'ma'; 1: 'bra'
0: 'ma'; 1: 'br'
0: 'ma'; 1: 'b'
0: 'ma'; 1: ''
0: 'abracadabra'; 1: ''
0: 'abracada'; 1: 'bra'
0: 'abracada'; 1: 'br'
0: 'abracada'; 1: 'b'
0: 'abracada'; 1: ''
0: 'abraca'; 1: 'dabra'
0: 'abraca'; 1: 'dabr'
0: 'abraca'; 1: 'dab'
0: 'abraca'; 1: 'da'
0: 'abraca'; 1: 'd'
0: 'abraca'; 1: ''
0: 'abra'; 1: 'cadabra'
0: 'abra'; 1: 'cadabr'
0: 'abra'; 1: 'cadab'
0: 'abra'; 1: 'cada'
0: 'abra'; 1: 'cad'</code></pre>
</div>
</div>
<div class="paragraph">
<p>尝试46种不同的配置后，它会找到一个匹配项:从 第二个字符，(<code>.+ a</code>)匹配abra，(<code>.*</code>)匹配cad，和  <code>$0</code> 再次匹配 abra。您可以清楚地看到正则表达式的后续部分变化更快比正则表达式的早期部分，从它们匹配的东西来判断。该正则表达式的起始位置的推进甚至更慢，并且在事实上，这是最缓慢的变化。</p>
</div>
<div class="paragraph">
<p>正则表达式引擎永远不会回溯到零宽度断言(看 - 提前和后面的断言)。对于那些人来说，只是相关 他们完全匹配，而不是匹配，因为一场成功的比赛永远不会 使用输入字符串的任何字符(它匹配空字符串)。</p>
</div>
</div>
<div class="sect2">
<h3 id="_为什么要避免回溯">6.4. 为什么要避免回溯</h3>
<div class="paragraph">
<p>Backtracking 是 Secret Magic SauceTM，它使正则表达式起作用。它使 计算机代表您努力工作以在输入字符串中找到匹配项。但有些情况下，回溯弊大于利; 因此，Raku(以及其他一些正则表达式实现)提供了禁用方法 回溯，或减少它做多少工作。</p>
</div>
<div class="sect3">
<h4 id="_性能">6.4.1. 性能</h4>
<div class="paragraph">
<p>一个原因是性能:回溯可以是计算上的密集的，如果你已经知道某场比赛(或比赛的一部分)将失败，告诉计算机做更少的工作加快速度。</p>
</div>
<div class="paragraph">
<p>一个简单的例子是这个正则表达式匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">"aaaaaa" ~~ /^ (a+) &lt;[bcd]&gt; /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以看到此匹配失败，因为该中没有b，c或d 输入字符串。但是，正则表达式引擎不够聪明，不知道这一点 它必须以这种方式搜索以获得最佳性能。相反，它首先尝试 在声明之前匹配输入中的所有a，然后再少一个，依此类推 打败。同样，我们可以通过嵌入式代码块跟踪其进度。 <code>say "aaaaaa" ∼∼ /^(a+) { say $0 } b/</code> 产生这个输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">⌜aaaaaa⌟
⌜aaaaa⌟
⌜aaaa⌟
⌜aaa⌟
⌜aa⌟
⌜a⌟
Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>在某些方面比计算机更聪明，我们可以帮助它 告诉它永远不要放弃它匹配的任何东西。<code>say "aaaaaa" ∼∼ /^(a+:) { say $0 } b/</code> 产生更短的输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">⌜aaaaaa⌟
Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>量词后面的冒号(:)告诉它不要为此回溯 量词。它不仅适用于所有量词，也适用于析取。 量词与回溯控制冒号一起称为a 占有量词，因为量词从不放弃它曾经的东西 附身。</p>
</div>
<div class="paragraph">
<p>禁用回溯的第二种方法是使用:棘轮(或:r) 修饰符，您也可以在组 <code>[&#8230;&#8203;]</code> 或捕获 <code>(&#8230;&#8203;)</code> 中使用。 在这种情况下，修饰符的效果从使用点延伸到 小组的结束。</p>
</div>
</div>
<div class="sect3">
<h4 id="_正确性">6.4.2. 正确性</h4>
<div class="paragraph">
<p>回溯有时会导致意外的匹配结果。这个之所以发生，是因为正则表达式的一部分符合您的预期，并且然后后来的部分未能匹配。然后第一部分开始回溯并且以意想不到的方式匹配。</p>
</div>
<div class="paragraph">
<p>Jan Goyvaerts 在正则表达式大师博客上分享了一个<a href="http://www.regexguru.com/2008/04/unintended-backtracking-can-bite-you/">例子</a><sup class="footnote">[<a id="_footnoteref_33" class="footnote" href="#_footnotedef_33" title="View footnote.">33</a>]</sup>，这里适用于 Raku 正则表达式语法。当您尝试匹配一对 HTML 标记时，如字符串 <code>&lt;a href="&#8230;&#8203;"&gt;some text&lt;/a&gt;</code>，你可以使用这样的正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $html-re = rx:ignorecase{
    '&lt;' $&lt;tag&gt;=[ &lt;[a..z]&gt;+ ] # opening tag
         &lt;-[ &gt; ]&gt;*           # attributes within opening tag
    '&gt;'
         ( .* )              # content between opening and
                             # closing tags
    '&lt;/' $&lt;tag&gt; '&gt;'
};

say 'more text &lt;a href="..:"&gt;link text&lt;/a&gt; bla' ~~ $html-re;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这似乎有效，但错误地也匹配不匹配的标签
例如 <code>&lt;abc&gt; &lt;/a&gt;</code>。这里的正则表达式引擎首先尝试与 <code>$&lt;tag&gt;</code> 匹配是 abc，找不到比赛，然后回溯。在第二 迭代，它尝试用 ab，失败，并在第三次迭代中成功 <code>$&lt;tag&gt;</code> 是一个。</p>
</div>
<div class="paragraph">
<p>有人可能会说正则表达式是有缺陷的，它应该有一个字 匹配开始 HTML 标记后的边界断言。但是，我们仍然 关于正则表达式匹配的直觉常常与贪婪的性质相吻合 量词，而不是回溯所能带来的细微差别生产。</p>
</div>
<div class="paragraph">
<p>在编写正则表达式或解析器时，请问自己个人元素:如果正则表达式的这部分找到匹配，然后稍后失败，请执行 我希望它尝试不同的比赛?想象一下，你正在编写一个解析器 编程语言并编写与标识符匹配的正则表达式。 比赛是否应该放弃一两个角色?可能不是。在一个案例中 像这样，添加冒号(<code>:</code>)以防止它回溯是个好主意:
<code>/ $&lt;tag&gt;=[ &lt;[a..z]&gt;+: ] /</code></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_节俭量词和回溯">6.5. 节俭量词和回溯</h3>
<div class="paragraph">
<p>如前一章所述，有节俭或懒惰的量词
尝试尽可能少地匹配。这些总是回溯，即使是:启用棘轮修改器。</p>
</div>
<div class="paragraph">
<p>当一个贪婪的量词试图尽可能地匹配时，甚至 没有回溯，通过应用量化的搜索继续进行 正则表达式元素并查看它是否匹配。另一方面，节俭 量词始终以最小匹配数开始，并且仅限 回溯可以使它更匹配。所以没有回溯，<code>/ a ?? /</code>
或 <code>/ a *?/</code> 只匹配空字符串，<code>/ a +?/</code> 只是一个a，等等 向前。</p>
</div>
</div>
<div class="sect2">
<h3 id="_最长_token_匹配">6.6. 最长 token 匹配</h3>
<div class="paragraph">
<p>带 <code>|</code> 的离散项或替代项更喜欢与最长的字符串匹配的分支。我们称之为最长的令牌匹配。</p>
</div>
<div class="paragraph">
<p>这一点在解析时很重要, 因为它与我们自己直觉上识别文本的方式是一致的。例如, Raku 的表达式 <code>$var` 可以被解析为前缀运算符 `</code> (将后面的变量增量1)，后面是变量 <code>$var</code>。或者，它可以解析为 <code>+(+$var)</code>，将前缀 <code>+</code> 运算符(将其参数转换为数字)应用到 <code>$var</code>，然后再将相同的运算符应用到结果中。Raku 语法是基于 regexes，它知道更喜欢第一个变体（单个 <code>` 运算子），因为当试图解析前缀运算符时，它产生的匹配时间最长。footnote:[这是另一种你不希望回溯的情况：一旦解析器识别了 `</code> 运算符，你不希望它改变主意，把这两个字符解释为不同的运算符。]</p>
</div>
<div class="paragraph">
<p>为了能够有效地匹配最长的替代变量，Raku 会确定一个 regex 的哪些部分构成了声明性前缀。然后构造一个 NFA 来匹配这个声明性前缀。一旦完成后，一般的regex引擎的其他部分就会启动并继续进行，直到找到下一个声明式前缀。</p>
</div>
<div class="paragraph">
<p>声明性前缀被限制在NFA可以建模的元素中：字元、字符类、分词、连词、连接词和贪婪量化器。在命名的regex调用的情况下，命名的regex的声明性前缀会被合并到调用的regex中，除非它会导致递归。</p>
</div>
<div class="paragraph">
<p>我们可以通过插入一个代码块 <code>{}</code>（它不是声明性的）来限制替代的长度来说明这一点（图6-9）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "abc" ~~ /ab | a.* /;        # Output: ⌜abc⌟
say "abc" ~~ /ab | a {} .* /;    # Output: ⌜ab⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里是正则表达式ab | a。*，第二个分支匹配整体 string，比第一个分支匹配的长。</p>
</div>
<div class="paragraph">
<p>通过插入空块 <code>{}</code>，最长的令牌匹配是 有效地限于正则表达式ab <code>|</code> 一个。现在第一个分支ab产生了 较长的匹配(因为第二个分支的声明部分 只匹配“a”)，正则表达式引擎承诺做出这个决定， 只匹配“ab”。仅当后来的正则表达式元素无法匹配时(和 启用了回溯)正则表达式引擎会重新考虑这个决定。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_5">6.7. 总结</h3>
<div class="paragraph">
<p>计算机科学为我们提供了有效匹配常规语言的工具通过有限自动机。即便如此，常规语言只是其中的一部分正则表达式可以描述什么。其余的是使用回溯处理，它最喜欢最左边的匹配，而不是更长的匹配匹配较短的匹配。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_正则表达式技术">7. 正则表达式技术</h2>
<div class="sectionbody">
<div class="paragraph">
<p>前面的章节介绍了许多正则表达式构造可以用来构建你的正则表达式, 并解释它们是如何工作的。但唯独没有告诉你如何组织你的正则表达式以获得最佳结果。这个章节提供了这样的指导。</p>
</div>
<div class="sect2">
<h3 id="_了解你的数据格式">7.1. 了解你的数据格式</h3>
<div class="paragraph">
<p>这可能是显而易见的, 但仍然经常被忽视。能够写出对于某些数据格式的正则表达式, 你需要知道它的规则。也就是说, 如果有的话是规则。如果没有, 你可能需要足够的输入数据来制定规则。你自己并根据数据测试它们。然后, 你需要知道验证的背景。</p>
</div>
<div class="sect3">
<h4 id="_明确的数据格式">7.1.1. 明确的数据格式</h4>
<div class="paragraph">
<p>我们先来谈谈定义数据格式的情况。即使你认为你很了解数据格式, 值得阅读规范。经常有一些很少使用的边缘情况可能值得考虑。
例如, 像 johndoe 这样的字符串(没有任何 <code>@</code> 符号)是有效的电子邮件本地送货地址。如果你正在编写电子邮件地址正则表达式以进行输入验证, 你应该允许吗? 答案取决于具体情况。如果你正在开发一个纯粹在公司内部使用的应用程序,  允许它可能是有意义的。在公共 Web 应用程序中, 更不用说了。</p>
</div>
<div class="paragraph">
<p>保持电子邮件地址, 你知道本地部分可以被引起来吗? 或者域部分可以是 IP 地址, 可选地在 括号?是的, <code>"somebody"@[93.184.216.34]</code> 和一些 <code>some+body@[IPv6:2001:db8::1]</code> 都是有效的电子邮件地址。</p>
</div>
<div class="paragraph">
<p>某些数据格式附带其格式规范。例如 JSON 是 JavaScript Object Notation, <a href="http://json.org/">在其主页上有解析规则</a>。<sup class="footnote">[<a id="_footnoteref_34" class="footnote" href="#_footnotedef_34" title="View footnote.">34</a>]</sup> 在这种情况下, 重复作者所具有的工作往往是一种务实的选择 投入创建这些规则并简单地将它们转换为 Raku 语法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_探索数据结构">7.1.2. 探索数据结构</h4>
<div class="paragraph">
<p>如果你没有现成的规格, 那么你必须来遵守自己的规则。提出这些规则的最佳方式是镜像科学方法:首先你想出一个假设, 然后你
测试一下。迭代直到你对结果满意为止。</p>
</div>
<div class="paragraph">
<p>测试关于数据格式的假设可以采用几种形式。如果你知道另一个处理相同数据格式的程序吗?可以修改该格式的现有文件, 然后用另一个加载它们程序。如果这不是一个选项, 你应该尝试收集尽可能多的你可以使用相同的格式生成世界数据, 然后搜索该数据语料库来检验你的假设。</p>
</div>
<div class="paragraph">
<p>我们假设你要编写一个解析 INI 文件的正则表达式 Microsoft Windows 平台上常用的配置格式。</p>
</div>
<div class="paragraph">
<p>在它的基本形式, 它看起来像这样(例子取自<a href="https://en.wikipedia.org/wiki/INI_file#Example">维基百科 INI 文件页面</a><sup class="footnote">[<a id="_footnoteref_35" class="footnote" href="#_footnotedef_35" title="View footnote.">35</a>]</sup>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-INI" data-lang="INI">; last modified 1 April 2001 by John Doe
[owner]
name=John Doe
organization=Acme Widgets Inc.
[database]
; use IP address in case network name resolution
; is not working
server=192.0.2.62
port=143
file="payroll.dat"</code></pre>
</div>
</div>
<div class="paragraph">
<p>规则看起来很简单: 文件由一系列节组成。每节以方括号中的节名开头, 包含由等号(<code>=</code>)分隔的键/值对。空行和以分号(<code>;</code>)开头的行, 将被忽略。</p>
</div>
<div class="paragraph">
<p>现在是时候提出更多问题了:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>节的列表是否为空(即, 为空提交有效的INI文件)?</p>
</li>
<li>
<p>节可以为空吗(不包含任何键/值对)?</p>
</li>
<li>
<p>键/值对后是否允许注释?对于 例如, 如果你写port = 443; 只有一个没有 被防火墙阻止, 是该值的注释部分 或不?</p>
</li>
<li>
<p>允许的空格在哪里?是[数据库]还是 port = 443有效吗?</p>
</li>
<li>
<p>部分名称允许什么?例如 空白或开又括号?线路怎么样? 休息?</p>
</li>
<li>
<p>密钥相同。密钥中是否允许短划线( - )?</p>
</li>
<li>
<p>值的规则是什么?它们是否延伸到了最后 这条线?他们是否停留在评论标记处?是吗 如果下一行不是注释, 则为多行, 键/值 对, 或部分标记?允许空值吗?</p>
</li>
<li>
<p>是否有任何转义序列(例如表格的 <code>\t</code>) 允许?如果是的话, 在哪里?只是在价值, 或在 键或节标题?</p>
</li>
<li>
<p>是否支持引用, 如果是, 则在哪里?</p>
</li>
<li>
<p>部分名称中是否允许使用非ASCII字符,  键和值?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些是分析纯文本数据格式时的典型问题。当你调查这些问题的答案时, 你可以转换它们进入你的正则表达式的测试用例。</p>
</div>
<div class="paragraph">
<p>没有固定规格的数据格式通常有几种变化, 和实现在他们接受的方面有所不同。在这种情况下, 你必须决定你是仅针对一个变体, 还是一个共同的子集, 或者可能他们所有人的超集。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_考虑无效输入">7.2. 考虑无效输入</h3>
<div class="paragraph">
<p>当你写你的正则表达式时, 不要只考虑那些字符串正则表达式应该匹配。同等重视他们的字符串不应该匹配。一般来说, 正则表达式有更多的字符串应该拒绝正则表达式应该接受的字符串, 这使得它们都成为现实很重要, 很难想到它们。</p>
</div>
<div class="paragraph">
<p>你可以做的一件事是写负面测试; 也就是说, 输入测试 这不应该匹配。另一个是停下来思考更难 你会看到像 <code>*</code> 或 <code>.+</code> 这样的术语。这些是如此广泛, 以至于它们最错误的时间。大多数数据格式都不包含“然后, 无论如何”的条款。 例如, 如果你解析运行到行尾的注释, <code>/'#' .*/</code> 是错的, 因为它可以匹配过去的换行符; <code>/'#' \N* \n? /</code> 将是更好的正则表达式。如果你解析类似 C 的注释, <code>/ * &#8230;&#8203; * /</code>, 正则表达式 <code>/ '/*' .* '*/'</code> 也匹配整个字符串 <code>/* abc */ de */</code>, 因为 <code>.*</code> 贪婪地匹配结束注释标记 <code>*/</code> 在字符串的中间。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用锚点">7.3. 使用锚点</h3>
<div class="paragraph">
<p>如果你编写一个完全匹配字符串的正则表达式, 请记住 锚定^和$以确保它与整个字符串匹配。如果没有, 请想一想 关于正则表达式匹配的边界。如果你试着匹配一个单词而不是 然后是一个点(<code>.</code>), 正则表达式 <code>/\w+ &lt;!before '.'&gt; /</code> 可以匹配一个部分 字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "supercalifragilisticexpialidocious."
        ~~ / \w+ &lt;!before '.'&gt; /;
# Output: ⌜supercalifragilisticexpialidociou⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的 <code>\w+</code> 实际匹配的是一个小于实际单词的字符,  这样 <code>&lt;!before '.'&gt;</code> 可以成功匹配。
如果这种行为不是你的想法, 你可以添加一个断言, 如单词边界, <code>/ \w+ » &lt;!before '.'&gt; /</code>。 因为 <code>\w+</code> 暗示一个单词的一部分已经匹配, 你也可以写 <code>/ \w+ &lt;!before \w&gt; &lt;!before '.'&gt; /</code>。</p>
</div>
<div class="paragraph">
<p>断言的内容是正则表达式, 所以在这里我们必须引用 点(或将其作为 <code>&lt;!before \.&gt;</code> 之外的其他部分), 否则点会展开它 特殊含义并匹配任何角色。</p>
</div>
</div>
<div class="sect2">
<h3 id="_匹配引用的字符串">7.4. 匹配引用的字符串</h3>
<div class="paragraph">
<p>许多数据格式包括带引号的字符串。他们的定义特征是 两个(或可能更多)分隔字符之间 - 引号 - 更多 允许(通常几乎所有)字符。
我们已经在 Raku 正则表达式本身看到了引用的字符串, 其中 可能会出现在正则表达式中保留的非单词字符。 常见的数据交换格式, 如 CSV, JSON 和 YAML 包含引号。CSV-逗号分隔值格式 - 具有 分隔符字符(默认为逗号(, );因此名称) 分隔表格式结构中的列。如果列值本身 包含逗号, 你必须能够区分逗号 分隔符, 通常通过引用来完成。</p>
</div>
<div class="paragraph">
<p>一个CSV文件, 包含列a, 然后是b, c, 最后是d(即三个 列)可以写成</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">a,"b,c",d</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中“b, c”是带引号的字符串。</p>
</div>
<div class="paragraph">
<p>如前所述, <code>/ \" .* \" /</code> 不是一种有效的方法 解析引用的字符串, 因为 <code>.*</code> 可以匹配过去的结束引号。如果 输入是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">a,"b,c",d,"e,f"</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后引用字符串的正则表达式实际上匹配两者
在输入中引用字符串以及它们之间的列。</p>
</div>
<div class="paragraph">
<p>一种不太天真的方法是写 <code>/ \" .*? \" /</code>, 这限制了引用字符串到最短的匹配。这有效, 但仅限于此 没有什么能迫使正则表达式以不同的方式回溯和匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '"a,b","' ~~ / ^ \" .*? \" $ /; # Output: ⌜"a,b","⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的输入是一个不平衡的引用字符串, 带有第三个引号 中间的人物。第一次尝试仅匹配“a, b”部分
字符串, <code>$anchor</code> 无法匹配, 因此回溯开始 并且下一次尝试匹配整个字符串。</p>
</div>
<div class="paragraph">
<p>这通常不是理想的行为。一种更强大的方法是放弃正则表达式中的点, 并更加思考内部允许的内容</p>
</div>
<div class="paragraph">
<p>引用的字符串:除引号字符外的所有内容。这很容易用否定的字符类来实现:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '"a,b","' ~~ / \" &lt;-["]&gt;* \" /;             # Output: ⌜"a,b"⌟
say '"a,b","' ~~ / ^ \" &lt;-["]&gt;* \" $ /;         # Output: Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在这只匹配一个平衡的引用字符串。</p>
</div>
<div class="sect3">
<h4 id="_引用带有转义序列的字符串">7.4.1. 引用带有转义序列的字符串</h4>
<div class="paragraph">
<p>我们的挑战并未在此结束。在前面的CSV示例中, 我们可以 现在处理包含分隔字符的列, 但自从 引用字符获得了特殊含义, 你不能轻易拥有一个列 包含引号字符。
这个问题最常见的解决方案是引入逃逸 角色, 通常是反弹(\)。如果你在报价前加上反对意见 字符或反斜杠, 第二个字符失去其特殊含义。 因此, 如果你想要包含她在CSV中说“嘿, ho”的字符串 专栏, 你必须把它写成“她说”嘿, ho“”。
使用反斜杠作为转义字符变得更多 复杂因为反斜杠在Raku中也有特殊含义 (以及大多数其他编程语言)。所以,  在普通的字符串文字中, 你必须加倍反斜杠才能产生一个 单一:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "a\\b"; # Output: a\b</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以通过在前面添加大写Q来关闭Raku中的此行为
字符串, 禁用所有转义序列:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Q"a\b"; # Output: a\b say Q"a\\b"; # Output: a\\b</code></pre>
</div>
</div>
<div class="paragraph">
<p>正则表达式没有这样的模式, 所以你必须加倍反斜杠
正则表达式匹配文字反斜杠。
回到带有转义字符的引号, 现在有两个 在引用的字符串中要考虑的情况:没有常规字符 任何意义和转义序列。常规字符都是字符 除了引号或反斜杠, 字符类&lt; - [“\\]&gt; 描述。转义序列是反斜杠, 后跟引号或a 反斜杠。在正则表达式中, 那是\\ &lt;[“\\]&gt;。许多数据格式允许 反斜杠背后的其他字符, 在这种情况下序列 简化为\\。(记住点匹配任何字符)。
结合这两个案例导致这个正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex quoted {
    \" # opening quote
    [
        &lt;-[ " \\ ]&gt; # regular character
        | \\ .      # escape sequence
    ]*
    \" # closing quote
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你花一分钟或更长时间阅读正则表达式, 请不要担心。这有点儿解压缩和理解, 但它将是本书中涉及最多的正则表达式。 我的正则表达式引用{&#8230;&#8203;}构造声明一个名为正则表达式的
词汇变量。稍后, 我们将学习语法, 我们可以省略我的语法。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_测试正则表达式">7.5. 测试正则表达式</h3>
<div class="paragraph">
<p>正则表达式是代码。它们是声明性的而不是程序性的
表示在编写正则表达式时, 指定它匹配的文本, 以及
通常不怎么样。但是, 它们仍然是代码, 你应该编写测试
代码, 以获得他们按预期工作的信心, 并能够改变
他们无需担心破坏使用它们的其他代码。
Raku附带一个测试模块, 可以轻松编写此类测试。 这是上一节中正则表达式的一个小测试套件:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex quoted {
    \" # opening quote
    [
            &lt;-[ " \\ ]&gt; # regular character
         | \\ .         # escape sequence
    ]*
    \" # closing quote
}

my @should-match =
    Q&lt;"abc"&gt;,
    Q&lt;"abc\\"&gt;,
    Q&lt;"ac\\def\"ef"&gt;,
    ;

my @should-not-match =
    Q&lt;abc&gt;,
    Q&lt;"abc"def"&gt;,
    Q&lt;"ab\\"cdef"&gt;,
    ;

use Test;
plan 6;

for @should-match -&gt; $s {
    ok $s ~~ / ^ &lt;quoted&gt; $ /,
        "Successful match of string $s";
}

for @should-not-match -&gt; $s {
    nok $s ~~ / ^ &lt;quoted&gt; $ /,
        "Successful rejection of string $s";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们更详细地探讨这个问题。一开始是熟悉的宣言 正则表达式。然后代码声明并初始化两个数组变量,  <code>@should-match</code> 和  <code>@should-not-match</code>。</p>
</div>
<div class="paragraph">
<p>第一个包含我们期望正则表达式匹配的字符串; 第二 有正则表达式不应匹配的字符串示例。</p>
</div>
<div class="paragraph">
<p>然后, 测试开始。使用测试; 导入<a href="https://docs.perl6.org/language/testing">测试模块</a>,<sup class="footnote">[<a id="_footnoteref_36" class="footnote" href="#_footnotedef_36" title="View footnote.">36</a>]</sup> 它提供了脚本中进一步使用的一些功能。计划是 其中之一, <code>plan 6;</code> 告诉测试模块六个测试用例 即将到来的。</p>
</div>
<div class="paragraph">
<p>接下来是两个for循环, 它检查示例字符串。好的是测试 函数, 当使用真值作为其第一个参数调用时, 生成一个 测试成功; 假值失败了。这里的第一个参数是a的结果 锚定的正则表达式匹配, <code>$s ~~ / ^&lt;quoted&gt;$ /</code>。第二个论点 是测试的标签。在第二个循环中, 使用测试函数nok 相反, 它具有来自ok的逆逻辑:它期望一个假值(如a 失败的正则表达式匹配)作为第一个参数。</p>
</div>
<div class="paragraph">
<p>运行脚本时, 它会生成如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku quotes-with-escapes.p6
1..6
ok 1 - Successful match of string "abc"
ok 2 - Successful match of string "abc\\"
ok 3 - Successful match of string "ac\\def\"ef"
ok 4 - Successful rejection of string abc
ok 5 - Successful rejection of string "abc"def"
ok 6 - Successful rejection of string "ab\\"cdef"</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你更改前三个示例字符串之一来制作正则表达式
匹配失败, 你得到一个失败的测试输出, 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku quotes-with-escapes.p6
1..6
ok 1 - Successful match of string "abc"
not ok 2 - Successful match of string "abc\\"a
# Failed test 'Successful match of string "abc\\"a'
# at quotes-with-escapes.p6 line 26
ok 3 - Successful match of string "ac\\def\"ef"
ok 4 - Successful rejection of string abc
ok 5 - Successful rejection of string "abc"def"
ok 6 - Successful rejection of string "ab\\"cdef"
# Looks like you failed 1 test of 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于文件中的许多测试, 甚至许多测试文件, 它都会有所帮助 得出所有测试输出的摘要。证明程序通常与 Perl 5 捆绑在一起可以理解测试的输出(<a href="https://testanything.org/">在测试任何协议格式</a><sup class="footnote">[<a id="_footnoteref_37" class="footnote" href="#_footnotedef_37" title="View footnote.">37</a>]</sup>)并打印出一个简短的摘要:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ prove -e raku quotes-with-escapes.p6
quotes-with-escapes.p6 .. ok
All tests successful.
Files=1, Tests=6, 1 wallclock secs ( 0.02 usr  0.00 sys +  0.24
cusr 0.01 csys = 0.27 CPU)
Result: PASS</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果测试失败, 它会关注失败的测试, 以便更容易修复它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ prove -e raku quotes-with-escapes.p6
quotes-with-escapes.p6 .. 1/6
# Failed test 'Successful match of string "abc\\"a'
# at quotes-with-escapes.p6 line 26
# Looks like you failed 1 test of 6
quotes-with-escapes.p6 .. Dubious, test returned 1 (wstat 256,0x100) Failed 1/6 subtests

Test Summary Report
-------------------
quotes-with-escapes.p6 (Wstat: 256 Tests: 6 Failed: 1)
  Failed test: 2
  Non-zero exit status: 1
Files=1, Tests=6, 0 wallclock secs ( 0.01 usr 0.01 sys 0.23 cusr 0.01 csys = 0.26 CPU)
Result: FAIL</code></pre>
</div>
</div>
<div class="paragraph">
<p>证明甚至为终端输出增加了颜色, 绿色表示“所有测试 成功。“和红色测试失败, 使状态显而易见。
在正式开发你的正则表达式之后, 很可能你想要 将它们用于运行测试之外的其他东西。在这种情况下, 你可以 将测试提取到一个子程序中, 只有在你调用它时才运行它们 带有特殊命令行参数的脚本, 例如&#8212;&#8203;test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex quoted {
    \" # opening quote
    [
        &lt;-[ " \\ ]&gt; # regular character
       | \\ .       # escape sequence
    ]*
    \" # closing quote
}

multi sub MAIN(Bool :$test!) {
    my @should-match =
        Q&lt;"abc"&gt;,
        Q&lt;"abc\\"&gt;,
        Q&lt;"ac\\def\"ef"&gt;,
        ;

    my @should-not-match =
        Q&lt;abc&gt;,
        Q&lt;"abc"def"&gt;,
        Q&lt;"ab\\"cdef"&gt;,
        ;

    use Test;
    plan 6;

    for @should-match -&gt; $s {
        ok $s ~~ / ^ &lt;quoted&gt; $ /,
            "Successful match of string $s";
    }

    for @should-not-match -&gt; $s {
        nok $s ~~ / ^ &lt;quoted&gt; $ /,
            "Successful rejection of string $s";
    }
}

multi sub MAIN($input) {
    if $input ~~ / ^ &lt;quoted&gt; $ / {
        say "$input is a quoted string";
    }
    else {
        say "invalid input: $input";
        exit 1;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中, 多子MAIN引入了一个名为MAIN的子程序。Perl的 6自动为你调用子程序MAIN并转换命令行 参数为此函数的参数。多重意味着可以 是一个具有此名称的子程序。Raku称那个候选人 最适合的论点。:$测试!是一个命名的论据, 凭借 前导冒号(:)和尾随感叹号(!)使其成为必需。 你只能通过传入命名参数测试来调用此候选项。
  这是它在命令行上的样子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku quote-checker --test
1..6
ok 1 - Successful match of string "abc"
ok 2 - Successful match of string "abc\\"
ok 3 - Successful match of string "ac\\def\"ef"
ok 4 - Successful rejection of string abc
ok 5 - Successful rejection of string "abc"def"
ok 6 - Successful rejection of string "ab\\"cdef"
Or if you want to use the prove test harness:
$ prove -e "" "raku quote-checker.p6 --test"
raku examples/quote-checker.p6 --test .. ok
All tests successful.
Files=1, Tests=6,  0 wallclock secs ( 0.01 usr  0.00 sys 0.26 cusr  0.02 csys = 0.29 CPU)
Result: PASS</code></pre>
</div>
</div>
<div class="paragraph">
<p>用多子MAIN($ input)声明的第二个候选者是 程序的“正常”执行路径。这需要一个位置论证,  在命令行方面, 它是一个不是选项的字符串 (所以不要以减号( - )字符开头)。它检查是否 参数是带引号的字符串并相应地打印消息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku quote-checker '"yes"'
"yes" is a quoted string
$ raku quote-checker no
invalid input: no</code></pre>
</div>
</div>
<div class="paragraph">
<p>shell使用了一个级别的引用, 这就是为什么在第一个级别 调用我在双引号字符串周围使用单引号。这个 适用于标准POSIX shell和bash; 其他炮弹可能需要 你要做不同的引用来运行这个例子。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_6">7.6. 总结</h3>
<div class="paragraph">
<p>在为数据格式编写正则表达式时, 我们经常发现我们知道这个数据格式比我们原先想象的要少。我们可以尝试找到回答我们问题的正式规范, 或者我们可以使用实验方法, 结合我们的问题目录关于数据格式。</p>
</div>
<div class="paragraph">
<p>我们还讨论了断言在什么边界的使用正则表达式应该匹配, 以及巧妙地使用否定字符类即使在存在转义字符的情况下, 也可以可靠地解析引用的字符串。</p>
</div>
<div class="paragraph">
<p>测试让我们相信我们写的正则表达式不再匹配并且不亚于我们的期望, 我们探索了一种简单的写作方式自动化测试。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_重用和组合正则表达式">8. 重用和组合正则表达式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 提供了很好的组合正则表达式的工具, 从而使它们可以重复使用。 这激励程序员精心组织和测试他们的正则表达式, 就像常规代码一样。</p>
</div>
<div class="sect2">
<h3 id="_命名正则表达式">8.1. 命名正则表达式</h3>
<div class="paragraph">
<p>给正则起名字, 并能够通过名称来引用这些正则, 是可组合性和重用正则表达式的第一步。</p>
</div>
<div class="paragraph">
<p>正如我们之前在一些示例中看到的那样, 你可以给正则表达式起名字, 就像你给变量、子程序等起名字一样。这就把正则表达式提升到了和语言中其他构造相同的高度, 使抽象化成为可能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex byte {
    \d ** 1..3
    &lt;?{ $/.Int &lt;= 255 }&gt;
}

my $str = '127.0.0.1';
say $str ~~ / ^ &lt;byte&gt; ** 4 % '.' $ /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 <code>my regex byte { &#8230;&#8203; }</code> 声明了一个名为 <code>byte</code> 的正则表达式。<code>regex</code> 前面的关键字决定了作用域: <code>my</code> 是词法作用域的。 省略 <code>my</code> 关键字会声明一个附加到 grammar 的正则表达式。稍后会有更多介绍。</p>
</div>
<div class="paragraph">
<p>Raku 中的正则表达式是代码对象, 就像子例程或方法一样。就像例程那样, 你可以通过在正则的名称前加上一个 <code>&amp;</code> 符号来引用正则表达式<sup class="footnote">[<a id="_footnoteref_38" class="footnote" href="#_footnotedef_38" title="View footnote.">38</a>]</sup>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &amp;byte.^name;   # Output: Regex
say &amp;byte ~~ Code; # Output: True</code></pre>
</div>
</div>
<div class="paragraph">
<p>与一般的子例程不同, 你不能直接调用正则表达式; 它需要一个游标对象用于跟踪其进度。这就是你尝试之后得到的结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku -e 'my regex a { . }; a("x")'
No such method '!cursor_start' for invocant of type 'Str'</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反, 你可以使用智能匹配来调用正则表达式, 就像使用匿名正则表达式那样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex a { . };
say "x" ~~ &amp;a; # Output: ⌜x⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然也可以从一个匿名的正则表达式内部调用它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex a { . }; "x" ~~ / &lt;a&gt; /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过尖括号语法 <code>&lt;a&gt;</code> 来调用一个命名正则表达式, 会创建一个和被调用的正则表达式同名的命名捕获, 这里是 <code>a</code>。如果你想避免捕获, 你可以将其写为 <code>&lt;&amp;a&gt;</code>。</p>
</div>
<div class="paragraph">
<p>如果你希望捕获具有不同的名字, 则可以将其写为 <code>&lt;b=&amp;a&gt;</code>。 这会生成一个命名捕获 <code>b</code>, 但会调用名为 <code>a</code> 的正则表达式。如果你写的是 <code>&lt;b=a&gt;</code>, 那么同一个捕获在名字 <code>a</code>  和名字 <code>b</code> 下都可用。还有更多方法可以调用命名正则表达式(表 8-1)。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. 调用命名正则表达式的语法形式</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>例子</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>描述</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>捕获</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;a&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">命名正则表达式调用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;&amp;a&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">非捕获命名正则表达式调用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(none)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;b=a&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">带别名的命名正则表达式调用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a,b</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;b=&amp;a&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">重命名的命名正则表达式调用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">b</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;?a&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">命名正则表达式调用作为向前查看</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(none)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;!a&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">命名正则表达式调用作为否定向前查看</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(none)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果开口 <code>&lt;</code> 后的第一个字符是一个单词字符, 那么就会产生一个与该单词同名的命名捕获。任何形式的标点符号 - 不管是用于向前查看的 <code>?</code> 还是用于普通调用的 <code>&amp;</code>, 都会抑制捕获。</p>
</div>
<div class="sect3">
<h4 id="_词法分析与回溯控制">8.1.1. 词法分析与回溯控制</h4>
<div class="paragraph">
<p>在传统的解析文学中, 分析一段文本通常会有两个阶段: 词法分析, 也称为标记化, 然后是实际的解析。</p>
</div>
<div class="paragraph">
<p>词法分析将一段文本分解为 token, 即带有分类标签的小块文本。例如, 如果我们要写一个小计算器, 输入 <code>2  * (3 + 5)</code> 可能会产生一个像这样的 token 流:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">2    number
*    product
(    opening parenthesis
3    number
+    addition
5    number
)    closing parenthesis</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些 token 最初是一个线性列表; 然后解析步骤将它们转换为我们可用于表达式求值的树:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">  *
  /\
  2 +
    /\
    3 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种两步法适用于简单的基本的数学表达式方法, 但在解析某些具有上下文依赖的子语言那样的东西时往往会失败 。如果你要为 Raku 编写解析器, 主语言的词法分析与引用字符串内部的语言有很大不同 , 与正则表达式内的词法分析也有 很大不同。</p>
</div>
<div class="paragraph">
<p>为了适应这种情况, Raku 提供了关键字 <code>token</code>,  它引入了一个关闭回溯的正则表达式。这个想法就是 词法分析应该足够简单, 一旦你决定了如何录制并标记一个 token, 你就不想根据后来的输入放弃那个决定。因此, 没有回溯。</p>
</div>
<div class="paragraph">
<p>通过在正常的正则表达式匹配中进行词法分析, 我们拥有所有我们需要决定要应用的标记化的上下文。</p>
</div>
<div class="paragraph">
<p>本章的第一个例子涉及一个正则表达式 <code>byte</code>, 它很简单, 我们通常不想回溯。因此我们可以重写它以使用 <code>token</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my token byte {
    \d ** 1..3
    &lt;?{ $/.Int &lt;= 255 }&gt;
}
my $str = '127.0.0.1';
say $str ~~ / ^ &lt;byte&gt; ** 4 % '.' $ /;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>my token byte { &#8230;&#8203; }</code> 与显式禁用回溯的 <code>my regex byte { :r &#8230;&#8203;}.</code> 作用相同。但是, 它用的如此频繁, 所以它应该有自己的语法。</p>
</div>
<div class="paragraph">
<p>请注意, 我们有时使用 <code>regex</code> 这个词来指代使用 <code>token</code> 关键字声明的正则表达式。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_空白">8.2. 空白</h3>
<div class="paragraph">
<p>回到标记化一个简单的数学表达式的例子, 我们掩盖了一个重要的细节：输入包含 token 之间的空白, 而 token 流之间不包含空白。词法分析通常会丢弃无关紧要的空白。</p>
</div>
<div class="paragraph">
<p>并非所有的空白都是无关紧要的。 你不想写 "Hello, World", 出来的时候确是 Hello, World。 许多语言对空白做了区分, token 之间的空白无关紧要, 但 token 里面的空白（如带引号的字符串）非常重要。</p>
</div>
<div class="paragraph">
<p>然而, 这比那更微妙：在 SQL, Perl, Python, JavaScript 等语言中, 当类似单词的 token 后跟着非单词 token 时, 你可以省略空白, 或者反过来（例如 <code>a+b</code> 和 <code>a + b</code> 是相同的）。 然而, 不带任何空格连接两个类似单词的 token 是禁止的。 相反, 如果两个 token 之间存在空白, 则空白的数量无关紧要。<sup class="footnote">[<a id="_footnoteref_39" class="footnote" href="#_footnotedef_39" title="View footnote.">39</a>]</sup></p>
</div>
<div class="paragraph">
<p>例如, 下面这两个 SQL 语句生成相同的解析树：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT username,first_login FROM account;
SELECT
       username,
       first_login
FROM   account;</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反, 以下将是语法错误, 因为它连接了类似于单词的 token 而不带任何空格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECTusername,first_loginFROMaccount;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 定义了一个名为 <code>ws</code> 的正则表达式, 它是空白的缩写, 它将空白解析为之前规定的规则：任意数量的空白（空格, 制表符, 换行符, &#8230;&#8203;&#8230;&#8203;）, 但至少有一个空白, 除非它位于单词边界。 或者把它放在代码中, <code>regex ws { &lt;!ww&gt; \s* }</code> （其中  <code>&lt;!ww&gt;</code> 匹配除了单词内之外的任何地方）<sup class="footnote">[<a id="_footnoteref_40" class="footnote" href="#_footnotedef_40" title="View footnote.">40</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>还有一个快捷方式可以帮助你避免在代码中的任何地方使用显式的 <code>&lt;ws&gt;</code> 或 <code>&lt;.ws&gt;</code> 调用。<sup class="footnote">[<a id="_footnoteref_41" class="footnote" href="#_footnotedef_41" title="View footnote.">41</a>]</sup> 如果使用关键字 <code>rule</code> 而不是 <code>regex</code> 或 <code>token</code> 声明正则表达式, 则 Raku  会在你的正则表达式中使用空格的地方插入隐式的 <code>&lt;.ws&gt;</code> 调用。 这与在正则表达式中使用 <code>:sigspace</code> 或 <code>:s</code> 修饰符具有相同的效果。</p>
</div>
<div class="paragraph">
<p>由于 <code>ws</code> 的定义使用术语 <code>\s*</code>, 正则表达式中的单个空白可以匹配字符串中的任何数量的空格, 包括制表符, 空格, 垂直制表符等。</p>
</div>
<div class="paragraph">
<p>再次考虑我们的数学表达式, 我们可以编写以下正则表达式来匹配两个数字之和的最简单情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my token number { \d+ }
my rule  sum    { &lt;number&gt; '+' &lt;number&gt; }

say '1+2'   ~~ / ^ &lt;sum&gt; $ /;
say '1 + 2' ~~ / ^ &lt;sum&gt; $ /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二行相当于写为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token sum { &lt;number&gt; &lt;.ws&gt; '+' &lt;.ws&gt; &lt;number&gt; &lt;.ws&gt; },</code></pre>
</div>
</div>
<div class="paragraph">
<p>但更具可读性。最后两行都能匹配成功, 唯一的区别是它们匹配的空白:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">⌜1+2⌟
 sum =&gt; ⌜1+2⌟
  number =&gt; ⌜1⌟
  number =&gt; ⌜2⌟
⌜1 + 2⌟
 sum =&gt; ⌜1 + 2⌟
  number =&gt; ⌜1⌟
  number =&gt; ⌜2⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于正则表达式中的空白, 插入的隐式的 <code>&lt;.ws&gt;</code> 调用并不是每次都发生。特别是正则表达式开头的空白, 在 <code>:r</code> 或 <code>:s</code> 这样的修饰符之后的空白, 在开口花括号或开口圆括号之后的空白, 还有 <code>&amp;</code>, <code>&amp;&amp;</code> 和 <code>||</code> 之后的空白, 这些空白不会被隐式 <code>&lt;.ws&gt;</code> 调用替换。一般的概念是规则解析匹配里面和匹配结尾的空白, 但不解析匹配开头的空白。</p>
</div>
<div class="paragraph">
<p>如果你使用 <strong>rule</strong>, 你必须清楚空白是重要的, 并且原子和它的量词之间的空白也有影响:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "a a" ~~ rule { a+ }
say "a a" ~~ rule { a + }</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一行打印「a」而第二行打印「a a], 包括了最后一个 a。a 和 <code>+</code> 之间的空白被解释为 <code>&lt;.ws&gt;</code> 调用, 所以第二个 <strong>rule</strong> 等同于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token { [a &lt;.ws&gt;]+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后, 你要意识到, 就像正则表达式的任何部分一样 隐式调用 <code>ws</code> 也会使你的匹配失败:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'ab' ~~ rule { a b } # Output: Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 a 和 b 之间的隐式 <code>&lt;.ws&gt;</code> 调用不匹配, 所以规则 a 作为整体也不匹配。</p>
</div>
</div>
<div class="sect2">
<h3 id="_grammars">8.3. Grammars</h3>
<div class="paragraph">
<p>命名正则表达式提供了第一级抽象, 但我们经常需要更多级别的抽象。大多数高级编程语言都有模块、命名空间、类, 甚至三者都有, 以管理函数和方法的重用。</p>
</div>
<div class="paragraph">
<p>Raku 也提供了这些更高级别的抽象, 并使它们可用于正则表达式中。Grammar 是一个类, 它提供了一些调用正则表达式的工具。那么正则表达式是这个 grammar 中的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar IPv4Address {
    token byte {
        \d ** 1..3
        &lt;?{ $/.Int &lt;= 255 }&gt;
    }

    token TOP {
        &lt;byte&gt; ** 4 % '.'
    }
}

my $str = '127.0.0.1';
if IPv4Address.parse($str) {
    say join ', ', $&lt;byte&gt;.list;
        # Output: 127, 0, 0, 1
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个 grammar 用 <strong>grammar</strong> 关键字声明, 后面是 grammar 的名称 IPv4Address。grammar 是一种自动添加类型为 <a href="https://docs.raku.org/type/Grammar">Grammar</a><sup class="footnote">[<a id="_footnoteref_42" class="footnote" href="#_footnotedef_42" title="View footnote.">42</a>]</sup> 的父类, 并提供了一些方法, 如 <code>parse</code> 和 <code>subparse</code> 等。</p>
</div>
<div class="paragraph">
<p>grammar 的主体由花括号分割。 在主体里面, 我们使用 <code>regex</code> 或 <code>token</code> 关键字声明正则表达式。 注意我们省略了声明前面的 <code>my</code> 声明符, 因为现在正则表达式是作用域属于 grammar 的方法。</p>
</div>
<div class="paragraph">
<p><code>parse</code> 方法调用名为 <code>TOP</code> 的正则表达式, 并隐式将其锚定到字符串的开头和结尾。相比之下, <code>subparse</code> 方法仅锚定到字符串的开头。<code>parse</code> 和 <code>subparse</code> 方法都接收一个可选的, 命名参数规则, 你可以用它来调用 <code>TOP</code> 以外的正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say IPv4Address.subparse($str, :rule&lt;byte&gt;);        # Output: ⌜127⌟
say IPv4Address.parse($str, :rule&lt;byte&gt;);           # Output: Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 <code>IPv4Address.parse($str, :rule&lt;byte&gt;)</code> 失败了, 因为正则表达式 <code>&lt;byte&gt;</code> 不能匹配整个输入字符串, 并且 <code>parse</code> 隐式将正则表达式的结尾锚定到字符串的末尾。相反, <code>subparse</code> 匹配输入字符串的第一个数字。</p>
</div>
<div class="paragraph">
<p>在 grammar 内部, 调用相同 grammar 的另一个正则表达式和外面一样; 带尖括号 <code>:&lt;byte&gt;</code>。但如果你想抑制捕获, 你必须使用一个点代替 <code>&amp;</code> 符号:  <code>&lt;.byte&gt;</code>。这同样适用于重命名, 因此 <code>&lt;octect=.byte&gt;</code> 会调用正则表达式 <code>byte</code>, 但产生一个名为 <code>octect</code> 的捕获。点(<code>.</code>)的使用是类似于方法调用语法, 它也使用点号。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_grammars_重用代码">8.4. 使用 Grammars 重用代码</h3>
<div class="paragraph">
<p>Raku 提供了两种重用面向对象代码的方法:继承和角色组合。因为 grammar 实际上是类, 所以这两种机制 也适用于 grammar。</p>
</div>
<div class="sect3">
<h4 id="_继承">8.4.1. 继承</h4>
<div class="paragraph">
<p>继承是特殊化的一种形式。如果你有需要一个通用 grammar 的情况, 然后想要创建一些微调过的变体, 微调后的变体可以继承于更通用的变体。</p>
</div>
<div class="paragraph">
<p>例如, 考虑 SQL 的 grammar, 即 <a href="https://en.wikipedia.org/wiki/SQL">结构化查询语言</a><sup class="footnote">[<a id="_footnoteref_43" class="footnote" href="#_footnotedef_43" title="View footnote.">43</a>]</sup>。这种 grammar 有标准, 但有些实现是方言。一个这样的例子是 MySQL, 它使用反引号而不是双引号来引用表名和列名。然后, MySQL 方言的 grammar 将继承标准 SQL 的 grammar 并覆盖用于解析表名和列名的正则表达式。</p>
</div>
<div class="paragraph">
<p>为了说明这个想法, 让我们只关注解析 SQL 列名。 SQL 标准规定它们是标识符或双引号字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar StandardSQL {
    regex TOP {
        'SELECT' \s+ &lt;name&gt;
    }
    regex name {
          &lt;identifier&gt;
        | &lt;quoted_name&gt;
    }
    regex quoted_name {
        \" &lt;-["]&gt;+ \"
    }
    regex identifier {
        « &lt;:alpha&gt; \w* »
    }
}

say StandardSQL.parse('SELECT salary');
say StandardSQL.parse('SELECT "monthly salary"');</code></pre>
</div>
</div>
<div class="paragraph">
<p>这两个解析都成功了, 并且它们产生了这个输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">⌜SELECT salary⌟
  name =&gt; ⌜salary⌟
   identifier =&gt; ⌜salary⌟
⌜SELECT "monthly salary"⌟
 name =&gt; ⌜"monthly salary"⌟
  quoted_name =&gt; ⌜"monthly salary"⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>如前所述, MySQL 使用反引号而不是双引号来引用标识符。我们可以编写一个继承自 <code>StandardSQL</code> 并只覆盖正则表达式 <code>quoted_name</code> 的 grammar <code>MysqlSQL</code> 而不是复制整个 grammar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MysqlSQL is StandardSQL {
    regex quoted_name {
        \` &lt;-[`]&gt;+ \`
    }
}
say MysqlSQL.parse('SELECT `monthly salary`');</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 grammar 声明中的文本 "is StandardSQL" 定义了从 StandardSQL grammar 中继承。继承意味着 如果在子类中调用了正则表达式或方法, 并且未在子类中定义它, 则调用父类中同名的方法代替。</p>
</div>
</div>
<div class="sect3">
<h4 id="_角色组合">8.4.2. 角色组合</h4>
<div class="paragraph">
<p>角色 - 在其他编程语言中也称为 trait - 是一块可以复制到类或 grammar 中的功能(例如方法和正则表达式)。 这种复制称为组合。</p>
</div>
<div class="paragraph">
<p>角色组合非常适合从较小的, 独立的部分组合一个 grammar。例如, 解析数字和引用的字符串非常普遍, 在解析 SQL, JSON 和几种类型的配置文件时可能都是必需的。解析数字也适用在解析数学表达式时:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role ParseInteger {
    token unsigned { &lt;[0..9]&gt;+ }
    token signed   { ['+' | '-']? &lt;unsigned&gt; }
}

role ParseFloat does ParseInteger {
    token escale { &lt;[eE]&gt; &lt;unsigned&gt; }
    token float {
        $&lt;sign&gt;=&lt;[+-]&gt;?
        [
          $&lt;coeff&gt; = [ &lt;[0..9]&gt;* '.' &lt;unsigned&gt; ] &lt;escale&gt;?
        | $&lt;coeff&gt; = [               &lt;unsigned&gt; ] &lt;escale&gt;
        ]
    }
}

grammar Sum does ParseFloat {
    token number { &lt;signed&gt; | &lt;float&gt; }
    rule TOP { &lt;number&gt; '+' &lt;number&gt; }
}

grammar JSON does ParseFloat {
    token value {
          &lt;signed&gt;
        | &lt;float&gt;
          # more options go here
    }
    # rest of the grammar here
}

say Sum.parse('2 + -4');</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例显示了包含正则表达式的两个角色: <code>role ParseInteger</code> 有两个 token, 一个用于解析不带任何符号的整数(token  <code>unsigned</code>), 一个用于解析可能带有 <code>+</code> 或 <code>-</code> 符号的整数。 第二个角色, <code>ParseFloat</code> 通过声明 <code>does ParseInteger</code> 来使用第一个角色 。然后它声明一个 token <code>float</code> 来解析浮点数。</p>
</div>
<div class="paragraph">
<p>与继承不同, 角色组合在编译时检测名称冲突, 并迫使你解决这些冲突。这使得它安全将多个角色组合到同一个类中, 或将多个角色组合到单个角色中。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_proto_regexes">8.5. Proto Regexes</h3>
<div class="paragraph">
<p>假设你想为 <a href="http://json.org/">JSON</a><sup class="footnote">[<a id="_footnoteref_44" class="footnote" href="#_footnotedef_44" title="View footnote.">44</a>]</sup>(也称为 JavaScript 对象表示法) 写一个 grammar。json.org 主页肯定会告诉你当解析值的时候, 你期望一个字符串, 数字, 对象, 数组或字面量字符串,true, false 或 null。没问题, 你可以这样写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar JSON {
    token value {
        | &lt;string&gt;
        | &lt;number&gt;
        | &lt;object&gt;
        | &lt;array&gt;
        | 'true'
        | 'false'
        | 'null'
    }
    # more tokens and rules go here
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可以工作, 但可扩展性并不好。假设你想要解析扩展的 JSON 方言, 例如添加 2015-12-24 之类的不带引号的字符串形式的日期类型的方言 。你可以通过继承上一个例子中暗示的 JSON grammar 做到这一点 , 写一个 token <code>date</code> 来解析日期, 然后你必须覆盖 token <code>value</code>,  列出父 grammar 中的所有备选项, 然后列出你自己的 grammar。</p>
</div>
<div class="paragraph">
<p>这种重复不仅令人烦恼且容易出错, 而且还会造成对同一 grammar 进行多次修改变得不可能。如果其他人想要编写另一个扩展, 以添加不同类型的新值(例如引用类型), 他们的扩展将不会知道你的, 所以用户不能轻易地混合和匹配它们。</p>
</div>
<div class="paragraph">
<p>Raku 提供了解决这个问题的方法: <strong>proto regexes</strong>。原型正则表达式是一个 正则表达式的集合, 它们一起构成了一个很大的备选项, 就好像每个备选项都是由 <code>|</code> 分隔一样。这是我们作为原型正则表达式编写的 JSON grammar 的一部分:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar JSON {
    proto token value {*};
    token value:sym&lt;string&gt; { &lt;string&gt; }
    token value:sym&lt;number&gt; { &lt;number&gt; }
    token value:sym&lt;object&gt; { &lt;object&gt; }
    token value:sym&lt;array&gt;  { &lt;array&gt;  }
    token value:sym&lt;true&gt;   { &lt;sym&gt;    }
    token value:sym&lt;false&gt;  { &lt;sym&gt;    }
    token value:sym&lt;null&gt;   { &lt;sym&gt;    }
    # more tokens and rules go here
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>行 <code>proto token {*}</code> 引入了原型正则表达式(或 token) 名字 <code>value</code>。这指示 Raku 将有更多名字为 <code>value</code> 的正则表达式, 带有一些小的补充。这些小小的补充具有以下形式: <code>sym &lt;SOMETHING&gt;</code> 并帮助你和编译器保持这些正则表达式分开。这种正则表达式的主体可以是你所知道的任何东西, 所以我们就在那里做实现,而不是从 <code>token value:sym&lt;number&gt;</code> 里面调用 token <code>number</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token value:sym&lt;number&gt; {
    '-'?
    [ 0 | &lt;[1..9]&gt; &lt;[0..9]&gt;* ]
    [ \. &lt;[0..9]&gt;+ ]?
    [ &lt;[eE]&gt; [\+|\-]? &lt;[0..9]&gt;+ ]?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在每个候选者的内部, <code>:sym&lt;&#8230;&#8203;&gt;</code> 里面的名字可用作特殊符号 <code>&lt;sym&gt;</code>。所以不要写作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token value:sym&lt;null&gt; { 'null' }</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们能这样写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token value:sym&lt;null&gt; { &lt;sym&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>以避免重复这个名字。</p>
</div>
<div class="paragraph">
<p>让我们稍微减少示例并将其转换为可运行的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar JSONValue {
    proto token value {*};
    token value:sym&lt;true&gt;  { &lt;sym&gt; }
    token value:sym&lt;false&gt; { &lt;sym&gt; }
    token value:sym&lt;null&gt;  { &lt;sym&gt; }
    token TOP { &lt;value&gt; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个非常简约的 grammar, 只解析 JSON 值 <code>true</code>, <code>false</code> 和 <code>null</code>。我们的扩展使其解析 ISO 8601 格式的日期, 可以是一个添加一个候选 token 的简单角色:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role DateValue {
token value:sym&lt;date&gt; {
        &lt;[0..9]&gt;**4 '-' &lt;[0..9]&gt;**2 '-' &lt;[0..9]&gt;**2
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们不需要在角色中声明 <code>proto token value</code>, 因为它将混合到包含此声明的 grammar 中。</p>
</div>
<div class="paragraph">
<p>要使用 <code>DateValue</code> 扩展, 我们可以基于 JSONValue 和角色生成 grammar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar JSONValueWithDate is JSONValue does DateValue { };

for &lt;true null 2015-12-24 42&gt; -&gt; $str {
    say $str, ': ', ?JSONValueWithDate.parse($str);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这使用了 JSONValue 的继承和角色组合 DateValue 生成一个新的 grammar, 现在可以解析 <code>true</code>, <code>false</code>,  <code>null</code> 和 <code>date</code> 值。它产生这个输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">true: True
null: True
2015-12-24: True
42: False</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>?</code> 运算符在正则表达式外面外强制布尔上下文, 这就是我们在输出中看到 <code>True</code> 和 <code>False</code> 而不是 Match 对象和 <code>Nil</code> 的原因。</p>
</div>
<div class="paragraph">
<p>我们可以避免显式创建 grammar JSONValueWithDate 并且通过使用 <code>but</code> 运算符就地组合一个匿名的 grammar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;true null 2015-12-24 42&gt; -&gt; $str {
    say $str, ': ', ?(JSONValue but DateValue).parse($str);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>but</code> 运算符在左侧创建一个类型或对象的副本, 将角色应用于它, 并返回结果。</p>
</div>
<div class="paragraph">
<p>这两种方法都可以用来为 grammar 添加多个扩展:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role IntegerValue {
    token value:sym&lt;integer&gt; { &lt;[0..9]&gt;+ }
}

my $grammar = (JSONValue but DateValue) but IntegerValue;

for &lt;true null 2015-12-24 42&gt; -&gt; $str {
    say $str, ': ', ?$grammar.parse($str);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在 grammar 由 <code>JSONValue</code>, <code>DateValue</code> 和 <code>IntegerValue</code> 组合而来, 并且可以解析所有四个输入字符串示例。扩展角色不必考虑其他东西; 它们是可以自由组合的。</p>
</div>
<div class="paragraph">
<p>解析 JSON 子集的示例已经从 <a href="https://github.com/moritz/json/">JSON::Tiny</a><sup class="footnote">[<a id="_footnoteref_45" class="footnote" href="#_footnotedef_45" title="View footnote.">45</a>]</sup> 模块中获取, 它使用<a href="https://github.com/moritz/json/blob/master/lib/JSON/Tiny/Grammar.pm">可管理的Raku grammar</a><sup class="footnote">[<a id="_footnoteref_46" class="footnote" href="#_footnotedef_46" title="View footnote.">46</a>]</sup>来解析 JSON。我们越来越接近能够创造现实世界, 还有用许多实际应用创建可扩展的 grammar。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_7">8.6. 总结</h3>
<div class="paragraph">
<p>Raku 提供了命名正则表达式, 以便于重用。为了简化词法分析,  <code>token</code> 和 <code>rule</code> 关键字禁用了回溯, <code>rule</code> 关键字还会隐式解析空白。</p>
</div>
<div class="paragraph">
<p>由于正则表达式可以表现得像方法一样, 因此你可以用面向对象编程的强大技术管理和重用 正则表达式。Grammars 分组正则表达式, 继承和角色组合使它们可以重复使用。</p>
</div>
<div class="paragraph">
<p>最后, proto regexes 确保扩展可以以自然的方式发生, 而不会干扰 grammar 中相同位置的其他潜在扩展。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_使用_grammar_进行解析">9. 使用 Grammar 进行解析</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Grammar 是众所周知的用于解析的瑞士军刀<sup class="footnote">[<a id="_footnoteref_47" class="footnote" href="#_footnotedef_47" title="View footnote.">47</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>在本章中，我们将更详细地探讨它们。最重要的是，我们将讨论如何利用它们的力量。</p>
</div>
<div class="sect2">
<h3 id="_理解_grammar">9.1. 理解 Grammar</h3>
<div class="paragraph">
<p>Grammar 实现了一种自上而下的解析方法。解析的入口点， 通常是正则表达式 <code>TOP</code>，了解粗粒度结构和进一步调用进入细节的正则表达式。递归也可以参与其中。例如，如果你解析数学表达式，则项可以是一对括号内的任意表达式。</p>
</div>
<div class="paragraph">
<p>这是一种自上而下的结构，或者更准确地说是一种<a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">递归下降解析器</a><sup class="footnote">[<a id="_footnoteref_48" class="footnote" href="#_footnotedef_48" title="View footnote.">48</a>]</sup>。如果不涉及回溯，我们将其称为预测解析器，因为在字符串中的每个位置，我们确切地知道我们正在查找什么 - 我们可以预测下一个 token 将是什么(即使我们只能预测它可能是一组候选者之一)。</p>
</div>
<div class="paragraph">
<p>结果匹配树在结构上对应于 grammar 中正则表达式的调用结构。让我们考虑解析一个数学表达式，仅包含运算符 <code>*</code>，<code>+</code> 和用于分组的括号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MathExpression {
    token TOP    { &lt;sum&gt; }
    rule sum     { &lt;product&gt;+ % '+' }
    rule product { &lt;term&gt;+ % '*' }
    rule term    { &lt;number&gt; | &lt;group&gt; }
    rule group   { '(' &lt;sum&gt; ')' }
    token number { \d+ }
}

say MathExpression.parse('2 + 4 * 5 * (1 + 3)');</code></pre>
</div>
</div>
<div class="paragraph">
<p>从 grammar 本身来看，你已经可以看到递归的潜力: <code>sum</code> 调用 <code>product</code>，<code>product</code> 调用 <code>term</code>，<code>term</code> 调用 <code>group</code>，<code>term</code> 再调用 <code>sum</code>。这允许解析任意深度的嵌套表达式。</p>
</div>
<div class="paragraph">
<p>运行上一个示例会生成以下匹配对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢2 + 4 * 5 * (1 + 3)｣
 sum =&gt; ｢2 + 4 * 5 * (1 + 3)｣
  product =&gt; ｢2 ｣
   term =&gt; ｢2 ｣
    number =&gt; ｢2｣
  product =&gt; ｢4 * 5 * (1 + 3)｣
   term =&gt; ｢4 ｣
    number =&gt; ｢4｣
   term =&gt; ｢5 ｣
    number =&gt; ｢5｣
   term =&gt; ｢(1 + 3)｣
    group =&gt; ｢(1 + 3)｣
     sum =&gt; ｢1 + 3｣
      product =&gt; ｢1 ｣
       term =&gt; ｢1 ｣
        number =&gt; ｢1｣
      product =&gt; ｢3｣
       term =&gt; ｢3｣
        number =&gt; ｢3｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想知道如何解析特定数字，你可以通过查找当前行上面的行来向后追踪路径 缩进较少; 例如，数字 1 由标记 <code>number</code> 解析， 从 <code>term</code> 调用，从 <code>product</code> 调用，等等。</p>
</div>
<div class="paragraph">
<p>我们可以通过从 token <code>number</code> 中引发异常来验证这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token number {
    (\d+)
    { die "how did I get here?" if $0 eq '1' }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这确实显示了回溯中的调用链，具有最多顶部的直接背景:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">how did I get here?
  in regex number at bt.p6 line 9
  in regex term at bt.p6 line 5
  in regex product at bt.p6 line 4
  in regex sum at bt.p6 line 3
  in regex group at bt.p6 line 6
  in regex term at bt.p6 line 5
  in regex product at bt.p6 line 4
  in regex sum at bt.p6 line 3
  in regex TOP at bt.p6 line 2
  in block &lt;unit&gt; at bt.p6 line 13</code></pre>
</div>
</div>
<div class="paragraph">
<p>该语法仅使用 token 和 rule，因此没有涉及回溯，grammar 是预测解析器。这是相当典型的。
许多 grammar 在没有回溯或回溯的情况下工作正常只是几个地方。</p>
</div>
<div class="sect3">
<h4 id="_递归下降解析和优先级">9.1.1. 递归下降解析和优先级</h4>
<div class="paragraph">
<p><code>MathExpression</code> grammar 有两个结构相同的规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule sum { &lt;product&gt;+ % '+' }
rule product { &lt;term&gt;+ % '*' }</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反, 我们可以这样写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression { &lt;operator&gt;+ % &lt;term&gt; }
token operator { '*' | '+' }</code></pre>
</div>
</div>
<div class="paragraph">
<p>甚至使用前面的章节讨论过的 <code>proto</code> token 构造解析不同的运算符。我选择第一个的原因更多, 重复，方法是它使匹配结构对应于运算符 <code>*</code> 和 <code>+</code> 的优先级。</p>
</div>
<div class="paragraph">
<p>在计算数学表达式 <code>1 + 2 * 5</code> 时， 数学家和大多数编程语言首先计算 <code>2 * 5</code>，因为 <code>*</code> 运算符的优先级比 <code>+</code>  更高。结果然后被替换回表达式，导致 <code>1 + 10</code>，最后结果是 <code>11</code>。</p>
</div>
<div class="paragraph">
<p>使用第一版 grammar 解析此类表达式时， 解析树的结构表达了这种分组:它具有 - 作为顶级 - 一个 <code>sum</code>，操作数为 <code>1</code> 和 <code>2 * 5</code>。</p>
</div>
<div class="paragraph">
<p>这是有代价的:每个优先级都需要一个单独的规则和名称，并且结果匹配对象的嵌套结果每个优先级别至少有一级。此外，以后添加更多优先权的水平并不是微不足道的，而且很难用通用的方式来做。如果你不愿意接受这些费用，你可以改用扁平模型 用于解析所有运算符的单个标记。如果你那么需要一个结构反映优先顺序的方法，你可以编写转换列表的代码 进了一棵树。这通常称为运算符优先级解析器<sup class="footnote">[<a id="_footnoteref_49" class="footnote" href="#_footnotedef_49" title="View footnote.">49</a>]</sup>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_左递归和其它陷阱">9.1.2. 左递归和其它陷阱</h4>
<div class="paragraph">
<p>为了避免无限递归，你必须注意每一个可能的递归循环使游标位置前进至少一个字符。在 <code>MathExpression</code>  grammar 中，唯一可能的递归循环是 <code>sum → product → term → group → sum</code>, 并且 <code>group</code> 只能在它包含一个初始的括号 <code>(</code> 时才匹配。</p>
</div>
<div class="paragraph">
<p>如果递归不消耗字符，则称为左递归并且需要特殊的语言支持, 但是 Raku 没有提供。一个很好的例子就是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token a { &lt;a&gt;? 'a' }</code></pre>
</div>
</div>
<div class="paragraph">
<p>它本可以与正则表达式 <code>a+</code> 匹配相同的输入，但是确无限循环而不处理。</p>
</div>
<div class="paragraph">
<p>避免左递归的常用技术是要有一个结构让你可以从通用(此处为`sum`)到特定(<code>number</code>)的顺序安排正则表达式。你只需要小心并检查消费的角色正则表达式偏离该顺序(例如，<code>group</code> 调用 <code>sum</code>)。</p>
</div>
<div class="paragraph">
<p>无限循环的另一个潜在来源是可以匹配空字符串的量词化正则表达式 。解析语言时可能会发生这种情况 这实际上允许一些东西是空的。例如，在 UNIX shell 中， 你可以通过将右侧空置为空来分配变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">VAR1=value
VAR2=</code></pre>
</div>
</div>
<div class="paragraph">
<p>为 UNIX shell 命令编写 grammar 时，它可能是很想写一个可能匹配的 <code>token string { \w* }</code>  一个空字符串。在允许多个字符串文字的情况下，<code>&lt;string&gt;+</code> 然后可以挂起，因为有效的正则表达式 <code>[\w*]+</code> 会尝试 无限多次匹配零宽度字符串。</p>
</div>
<div class="paragraph">
<p>一旦你意识到问题，解决方案非常简单: 将 token 更改为不允许空字符串(<code>token string { \w+ }</code>)， 并明确地处理允许空字符串的情况:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token assignment {
    &lt;variable&gt; '=' &lt;string&gt;?
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_从简单开始">9.2. 从简单开始</h3>
<div class="paragraph">
<p>即使语法从上到下起作用，也要发展语法最好从下往上运作。从一开始往往不明显是什么语法的整体结构将是，但你通常有一个好主意</p>
</div>
<div class="paragraph">
<p>关于终端令牌:那些直接匹配文本而不需要调用的令牌其他子规则。在前面解析数学表达式的例子中，你可能会从一开始就不知道如何安排解析和的规则和产品，但很可能你知道你必须解析一个数字有一点，所以你可以从写作开始:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MathExpression {
    token number { \d+ }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这并不多，但它也不是很复杂，而且很好
如何克服程序员有时会遇到的作家的障碍
受到新问题领域的挑战。当然，只要你有一个
令牌，你可以开始写一些测试:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MathExpression {
    token number { \d+ }
}

multi sub MAIN(Bool :$test!) {
    use Test;
    plan 2;
    ok MathExpression.parse('1234', :rule&lt;number&gt;),
        '&lt;number&gt; parses 1234';
    nok MathExpression.parse('1+4', :rule&lt;number&gt;),
        '&lt;number&gt; does not parse 1+4';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，你可以开始构建更复杂的表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MathExpression {
    token number { \d+ }
    rule product { &lt;number&gt;+ % '*' }
}

multi sub MAIN(Bool :$test!) {
    use Test;
    plan 5;
    ok MathExpression.parse('1234', :rule&lt;number&gt;),
        '&lt;number&gt; parses 1234';
    nok MathExpression.parse('1+4', :rule&lt;number&gt;),
        '&lt;number&gt; does not parse 1+4';
    ok MathExpression.parse('1234', :rule&lt;product&gt;),
        '&lt;product&gt; can parse a simple number';
    ok MathExpression.parse('1*3*4', :rule&lt;product&gt;),
        '&lt;product&gt; can parse three terms';
    ok MathExpression.parse('1 * 3', :rule&lt;product&gt;),
        '&lt;product&gt; and whitespace';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在测试中尽早包含空格是值得的。以前的 示例看起来很无辜，但最后一次测试确实失败了。没有 匹配 <code>1</code> 和 <code>*</code> 之间的空格的规则。添加空间 在 <code>&lt;number&gt;</code> 和 <code>+</code> 量词之间的正则表达式中进行测试 再次传递，因为空格插入隐式 <code>&lt;.ws&gt;</code> 调用。</p>
</div>
<div class="paragraph">
<p>如果你开始非常简单并抓住它们，这些微妙之处很容易被捕获尽快地。相反，如果你屈服于写下来的诱惑整个语法从上到下，你可以花很多时间调试为什么一些看似简单的东西，如额外的空间使得解析失败。</p>
</div>
</div>
<div class="sect2">
<h3 id="_组装完整的_grammars">9.3. 组装完整的 Grammars</h3>
<div class="paragraph">
<p>一旦你编写了用于词法分析的基本标记，你就可以合并它们的进展。通常，令牌不会解析空格在他们的比赛的边界，所以组合他们的规则做到这一点。</p>
</div>
<div class="paragraph">
<p>在上一节的MathExpression示例中，规则产品 直接调用数字，即使我们现在知道最终版本 使用中间步骤，规则术语，也可以解析表达式 在括号内。引入此额外步骤不会使测试无效 我们已经为产品编写了，因为它早期匹配的字符串 版本仍然匹配。当你自然地引入更多层时 从处理语言子集的语法开始，稍后再说扩大。</p>
</div>
</div>
<div class="sect2">
<h3 id="_调试_grammars">9.4. 调试 Grammars</h3>
<div class="paragraph">
<p>正则表达式或语法有两种失败模式:它可以匹配何时它不应该匹配(误报)，或者它可能无法匹配应该匹配(假阴性)。通常，误报更容易明白了，因为你可以检查生成的匹配对象并查看哪个正则表达式匹配字符串的哪一部分。</p>
</div>
<div class="paragraph">
<p>有一个方便的工具来调试漏报: <code>Grammar::Tracer</code> 模块。如果你将模块加载到包含。的文件中 语法，运行语法产生可以的诊断信息 帮助你找出匹配出错的地方。</p>
</div>
<div class="paragraph">
<p>请注意，这只是开发人员的诊断工具; 如果你想 为了给最终用户更好的错误信息，请阅读章节为改进建议。
你需要安装 Raku 模块 <code>Grammar::Debugger</code>,它包含 <code>Grammar::Tracer</code>。如果你使用 <code>moritzlenz/raku-regex-alpine</code>   docker 镜像，这已经为你完成了。如果你通过另一种方法安装了 Raku, 你需要运行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install Grammar::Debugger</code></pre>
</div>
</div>
<div class="paragraph">
<p>在命令行上。如果尚未安装 <code>zef</code>，请按照 zef 在 GitHub 页面的安装说明进行操作<sup class="footnote">[<a id="_footnoteref_50" class="footnote" href="#_footnotedef_50" title="View footnote.">50</a>]</sup>。</p>
</div>
<div class="paragraph">
<p>我们来看看 Tadeusz Sośnierz 开发的 <a href="https://github.com/tadzik/perl6-Config-INI">Config::INI</a><sup class="footnote">[<a id="_footnoteref_51" class="footnote" href="#_footnotedef_51" title="View footnote.">51</a>]</sup>
包含以下 <a href="https://github.com/tadzik/perl6-Config-INI/blob/master/lib/Config/INI.pm">grammar</a><sup class="footnote">[<a id="_footnoteref_52" class="footnote" href="#_footnotedef_52" title="View footnote.">52</a>]</sup>(稍微重新格式化):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar INI {
    token TOP      {
                        ^
                        &lt;.eol&gt;*
                        &lt;toplevel&gt;?
                        &lt;sections&gt;*
                        &lt;.eol&gt;*
                        $
                   }
    token toplevel { &lt;keyval&gt;* }
    token sections { &lt;header&gt; &lt;keyval&gt;* }
    token header   { ^^ \h* '[' ~ ']' $&lt;text&gt;=&lt;-[ \] \n ]&gt;+ \h* &lt;.eol&gt;+ }
    token keyval   { ^^ \h* &lt;key&gt; \h* '=' \h* &lt;value&gt;? \h* &lt;.eol&gt;+ }
    regex key      { &lt;![#\[]&gt; &lt;-[;=]&gt;+ }
    regex value    { [ &lt;![#;]&gt; \N ]+ }
    token eol      { [ &lt;[#;]&gt; \N* ]? \n }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设我们想要理解它为什么不解析以下内容一段输入文字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a= b
[foo]
c: d</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以，在 grammar 之前，我们插入一行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Grammar::Tracer;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，添加一小段代码，调用该方法的.parse方法语法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">INI.parse(q:to/EOF/);
a= b
[foo]
c: d
EOF</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会产生相当大但相当丰富的输出。
每个条目都包含一个正则表达式的名称，如TOP或eol(用于“end”) 行“)，然后是它调用的正则表达式的缩进输出 正则表达式包含一个包含星号(*)和MATCH后跟的行 正则表达式匹配的字符串段，如果正则表达式失败则为FAIL。</p>
</div>
<div class="paragraph">
<p>让我们一块一块地看一下输出，即使它是一体的:</p>
</div>
<div class="paragraph">
<p>这告诉我们TOP叫eol，但未能匹配。自召唤 使用*来量化eol，这不会导致TOP的匹配失败。 TOP然后调用key，它匹配文本“a”和匹配的值 “B”。然后eol正则表达式继续匹配换行符，失败 第二次尝试(因为一行中没有两个换行符)。 这会导致初始keyval令牌成功匹配。第二次打电话给 keyval非常快速地匹配(在对key的调用中)。然后，令牌的匹配 toplevel成功进行，消耗字符串“a = b \ n”。</p>
</div>
<div class="paragraph">
<p>到目前为止，这一切看起来都像预期。现在让我们来看看第二个
输出大块:</p>
</div>
<div class="paragraph">
<p>TOP下一个调用部分，其中令牌标头成功匹配
字符串“[foo] \ n”。然后，keyval调用key，它匹配整个
行“c:d \ n”。等等，那不对，是吗?我们可能期望关键 只匹配c。我当然不希望它与a匹配 最后的换行符。输入中缺少等号 导致正则表达式引擎永远不会调用正则表达式值。但是自从keyval 再次用星*量词进行量化，即调用正则表达式的匹配 部分成功匹配标题“[foo] \ n”。
Grammar :: Tracer输出的最后一部分如下:</p>
</div>
<div class="paragraph">
<p>从这里开始就失败了。第二次调用部分再次尝试解析 一个标题，但它的下一个输入仍然是“c:d \ n”，所以它失败了，结束时也是如此 在标记TOP中字符串锚定$，在方法解析中失败整体匹配。
所以我们已经知道正则表达式键匹配整行c:d \ n，但是 由于后面没有等号(=)，因此令牌键值无法解析此行。以来 没有其他正则表达式(特别是不是标题)匹配它，这是匹配失败的地方。
从这个示例运行中可以看出，Grammar :: Tracer使我们能够 确定解析失败发生的地方，即使我们必须仔细查看 通过它的输出来定位它。在终端中运行时，会自动进行 获得彩色输出，FAIL有红色，MATCH为绿色背景，和 标记名称以粗体白色(而不是通常的灰色)输出。 这样可以更容易地从底部扫描(通常情况下失败的匹配) 留下红色失败的痕迹直到尾随成功的比赛，然后看 在比赛和失败之间的边界附近。
由于调试带来了重大的心理负担和输出 来自Grammar :: Tracer往往会快速增长，通常建议 将失败的输入减少到最小的样本。在描述的情况下 之前，我们可以删除输入字符串的第一行并保存 十行Grammar :: Tracer输出来查看。</p>
</div>
</div>
<div class="sect2">
<h3 id="_解析空白和注释">9.5. 解析空白和注释</h3>
<div class="paragraph">
<p>如前所述，解析微不足道的空白的惯用方法是 调用&lt;.ws&gt;，通常通过在规则中使用空格来隐式调用。默认为ws 实现，&lt;!ww&gt; \ s *，适用于多种语言，但它有其局限性。
有惊人数量的文件格式和计算机语言 是&lt;.ws&gt;会吞噬的重要空白。这些包括 INI文件(换行符通常表示新的键/值对)，Python 和YAML(缩进用于分组)，CSV(换行符 发出新记录的信号)和Makefile(需要缩进的地方) 用制表符字符)。</p>
</div>
<div class="paragraph">
<p>在这些情况下，最好在你自己的语法中覆盖ws 只匹配无关紧要的空白。我们来看看第二个， 简约INI解析器，独立开发的描述
在上一节中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar INIFile {
    token TOP { &lt;section&gt;* }
    token section {
        &lt;header&gt;
        &lt;keyvalue&gt;*
    }
    rule header {
        '[' &lt;-[ \] \n ]&gt;+ ']' &lt;.eol&gt;
    }
    rule keyvalue {
        ^^
        $&lt;key&gt;=[\w+]
        &lt;[:=]&gt;
        $&lt;value&gt;=[&lt;-[\n;#]&gt;*]
        &lt;.eol&gt;
    }
    token ws { &lt;!ww&gt; \h* }
    token eol {
        \n [\h*\n]*
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这解析简单的INI配置文件，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[db]
driver: mysql
host: db01.example.com
port: 122
username: us123
password: s3kr1t</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意此语法如何使用两个路径来解析空格: 一个自定义的ws标记只匹配水平空格(空格和空格) 标签)，以及匹配(重要)换行符的单独标记eol。该 eol令牌还吞噬了仅由空格组成的更多行。
如果某种语言支持注释，并且你不希望它们出现 在你的解析树中，你可以在你的ws标记或eol中解析它们 (或等同于你)。它取决于评论的位置 被允许。在INI文件中，它们仅在键/值对之后或在 在他们自己的线上，所以eol将是合适的地方。相比之下，SQL允许 在允许空格的每个地方都有评论，所以很自然</p>
</div>
<div class="paragraph">
<p>用ws解析它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># comment parsing for SQL:
token ws { &lt;!ww&gt; \s* [ '--' \N* \n ]* }

# comment parsing for INI files:
token eol { [ [ &lt;[#;]&gt; \N* ]? \n ]+ }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_保存状态">9.6. 保存状态</h3>
<div class="paragraph">
<p>一些更有趣的数据格式和语言需要 解析器存储事物(至少暂时)以便能够正确解析 他们。一个典型的例子就是C编程语言，其他人受到启发 通过它的语法(例如C ++和Java)。这些语言允许变量 表单类型变量= initial_value的声明，如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">int x = 42;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是有效的语法，但前提是第一个单词是类型名称。相反， 这将是无效的，因为x不是一个类型:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">int x = 42; x y = 23;</code></pre>
</div>
</div>
<div class="paragraph">
<p>从这些示例中可以清楚地看出，解析器必须具有
记录它知道的所有类型。由于用户也可以在其中声明类型
代码文件，解析器必须能够更新此记录。
  许多语言也需要符号(变量，类型和
函数)在引用之前声明。这也需要
语法来跟踪已声明的内容和未声明的内容。这个
已经宣布的内容的记录(以及什么是类型，可能是
其他元信息)称为符号表。
我们不考虑解析完整的C编程语言，而是考虑一个 简约语言，只允许分配数字列表，和
变量到变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a= 1
b= 2
c = a, 5, b</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们不强加声明规则，那么写一个很容易语法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar VariableLists {
    token TOP        { &lt;statement&gt;* }
    rule statement   { &lt;identifier&gt; '=' &lt;termlist&gt; \n }
    rule termlist    { &lt;term&gt; * % ',' }
    token term       { &lt;identifier&gt; | &lt;number&gt; }
    token number     { \d+ }
    token identifier { &lt;:alpha&gt; \w* }
    token ws         { &lt;!ww&gt; \h* }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们要求变量只能在它们出现之后使用 分配给，以便以下输入无效，因为b不是 在第二行声明，使用它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a= 1
c = a, 5, b
b= 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>要维护符号表，我们需要三个新元素:声明符号表的一些代码，为符号添加变量名称表解析时的表，最后检查是否一个我们在术语列表中遇到变量时声明了变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar VariableLists {
    token TOP {
        :my %*SYMBOLS;
        &lt;statement&gt;*
    }
    token ws { &lt;!ww&gt; \h* }
    rule statement {
        &lt;identifier&gt;
        { %*SYMBOLS{ $&lt;identifier&gt; } = True }
        '=' &lt;termlist&gt;
        \n
    }
    rule termlist { &lt;term&gt; * % ',' }
    token term { &lt;variable&gt; | &lt;number&gt; }
    token variable {
        &lt;identifier&gt;
        &lt;?{ %*SYMBOLS{ $&lt;identifier&gt; } }&gt;
    }
    token number { \d+ }
    token identifier { &lt;:alpha&gt; \w* }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在令牌TOP中，<code>:my%* SYMBOLS</code> 声明一个变量。声明 正则表达式以冒号(:)开头，以分号(;)结尾。在两者之间 它们看起来像Raku中的正常声明。%sigil表示 variable是一个hash -a字符串键到值的映射。*使它成为一个 动态变量 - 不限于当前范围的变量 对于从中调用的代码(或正则代码，也是代码)也是可见的 目前的范围。由于这是一个非常大的范围，因此可以自定义选择</p>
</div>
<div class="paragraph">
<p>大写字母中的变量 第二部分，在符号表中添加一个符号，发生在规则声明:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule statement {
    &lt;identifier&gt;
    { %*SYMBOLS{ $&lt;identifier&gt; } = True }
    '=' &lt;termlist&gt;
    \n
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>花括号里面是常规(非正则表达式)Raku代码，所以我们可以 用它来操纵哈希 <code>%*SYMBOLS</code>。表达式 <code>$&lt;identifier&gt;</code> 访问变量名称的捕获<sup class="footnote">[<a id="_footnoteref_53" class="footnote" href="#_footnotedef_53" title="View footnote.">53</a>]</sup>。因此，如果此规则解析a 变量a，此语句设置 <code>%*SYMBOLS{'a'} = True</code>。</p>
</div>
<div class="paragraph">
<p>代码块的位置是相关的。把它放在电话前 到termlist表示当术语列表是已知的变量解析，所以它接受像a = 2，a的输入。如果我们先称之为termlist，那就是这种 输入被拒绝。</p>
</div>
<div class="paragraph">
<p>说到拒绝，这部分发生在令牌变量中。现在这个词调用新的令牌变量(之前它直接称为标识符)，和变量验证符号之前已声明:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token term { &lt;variable&gt; | &lt;number&gt; }
token variable {
    &lt;identifier&gt;
    &lt;?{ %*SYMBOLS{ $&lt;identifier&gt; } }&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可能还记得在前面的例子中, <code>&lt;?{&#8230;&#8203;}&gt;</code> 执行了一段 Raku 代码, 如果返回一个假值，则解析失败。如果 <code>$&lt;identifier&gt;</code> 不在 <code>%*SYMBOLS</code> 中, 就会出现这种情况。这时, <strong>token</strong> 的非回溯性就很重要了。如果被解析的变量是 abc，而变量 <strong>a</strong> 在 <code>%*SYMBOLS</code> 中，那么回溯将尝试对 <code>&lt;identifier&gt;</code> 进行更短的匹配, 直到匹配到 <strong>a</strong>, 然后成功。<sup class="footnote">[<a id="_footnoteref_54" class="footnote" href="#_footnotedef_54" title="View footnote.">54</a>]</sup></p>
</div>
<div class="paragraph">
<p>因为 <code>%*SYMBOLS</code> 是在 token <strong>TOP</strong> 中声明的, 所以当你尝试从 grammar 之外调用 <strong>TOP</strong> 以外的规则时, 你必须重复这个声明。如果没有像 <code>my %*SYMBOLS;</code> 这样的声明, 那么像:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">VariableLists.parse('abc', rule =&gt; 'variable');</code></pre>
</div>
</div>
<div class="paragraph">
<p>死于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Dynamic variable %*SYMBOLS not found</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_用动态实现词法范围变量">9.6.1. 用动态实现词法范围变量</h4>
<div class="paragraph">
<p>许多编程语言都具有词法范围的概念。一个范围是程序中符号可见的区域。我们称范围词汇。如果范围仅由文本结构决定(而不是，例如，程序的运行时功能)。</p>
</div>
<div class="paragraph">
<p>范围通常可以嵌套。在一个范围内声明的变量是在此范围内以及所有内部嵌套范围中都可见(除非是内部范围声明一个同名的变量，在这种情况下是内部声明隐藏外部)。</p>
</div>
<div class="paragraph">
<p>回到列表和作业的玩具语言，我们可以引入一对花括号来表示一个新的范围，所以这是有效的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a= 1
b= 2
{
    c = a, 5, b
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是下一个例子是无效的，因为它只在内部声明b 范围，因此在外部范围内不可见:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a = 1
{
    b = 2
}
c = a, 5, b</code></pre>
</div>
</div>
<div class="paragraph">
<p>要在语法中实现这些规则，我们可以使用重要观察:语法中的动态范围对应它解析的文本中的词汇范围。如果我们有一个解析它们的正则表达式块范围的分隔符和范围内的事物，它的动态范围仅限于它所调用的所有正则表达式(直接和间接)，以及这也是它在输入文本中匹配的词法范围的范围。</p>
</div>
<div class="paragraph">
<p>我们来看看如何实现动态范围:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar VariableLists {
    token TOP {
        :my %*SYMBOLS;
        &lt;statement&gt;*
    }
    token ws { &lt;!ww&gt; \h* }
    token statement {
        | &lt;declaration&gt;
        | &lt;block&gt;
    }
    rule declaration {
        &lt;identifier&gt;
        { %*SYMBOLS{ $&lt;identifier&gt; } = True; }
        '=' &lt;termlist&gt;
        \n
    }
    rule block {
        :my %*SYMBOLS = CALLERS::&lt;%*SYMBOLS&gt;;
        '{' \n*
            &lt;statement&gt;*
        '}' \n*
    }
    rule termlist { &lt;term&gt; * % ',' }
    token term { &lt;variable&gt; | &lt;number&gt; }
    token variable {
        &lt;identifier&gt;
        &lt;?{ %*SYMBOLS{ $&lt;identifier&gt; } }&gt;
    }

    token number { \d+ }
    token identifier { &lt;:alpha&gt; \w* }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个语法的先前版本有一些变化: 规则语句已重命名为声明和新规则 statement解析声明或块。
所有有趣的位都发生在块规则中。这条线:我的 <code>%*SYMBOLS = CALLERS::&lt;%*SYMBOLS&gt;;</code> 声明一个新的动态变量 <code>%*SYMBOLS</code> 并使用该变量的先前值初始化它。<code>CALLERS::&lt;%*SYMBOLS&gt;</code> 查看调用者和调用者的调用者，以及 等等为变量 <code>%*SYMBOLS</code>，从而查找相应的值 到外部范围。初始化创建哈希的副本，这样 更改为一个副本不会影响其他副本。让我们来看看当这个语法解析时会发生什么以下输入:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a= 1 b= 2
{
    c = a, 5, b
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前两行之后，<code>%*SYMBOLS</code> 的值为 <code>{a &#8658; True，b &#8658; True}</code>。当规则块解析第三个上的开始花括号时 行，它创建 <code>%*SYMBOLS</code> 的副本。第四行的c声明</p>
</div>
<div class="paragraph">
<p>将对 <code>c &#8658; True</code> 插入`%*SYMBOLS` 的副本中。规则块之后 解析最后一行的结束大括号，它成功退出，并且 <code>%*SYMBOLS</code> 的副本超出范围。这让我们得到了早期版本 <code>%*SYMBOLS</code>(只有键a和b)，然后超出范围 当 <code>TOP</code> 退出时</p>
</div>
</div>
<div class="sect3">
<h4 id="_通过显式符号表确定范围">9.6.2. 通过显式符号表确定范围</h4>
<div class="paragraph">
<p>使用动态变量管理符号表通常很有效好吧，但是有一些边缘情况可以使用更明确的方法更好。这种边缘情况包括那些有很多符号的边缘情况复制变得非常昂贵，或者超过了必须检查最上面的范围，或者复制符号表时由于其他原因不切实际。</p>
</div>
<div class="paragraph">
<p>因此，你可以为符号表编写一个类(在最简单的情况是使用数组作为作用域的堆栈)并显式调用方法在进入和离开范围时，在声明变量时，以及检查范围中是否已知变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class SymbolTable {
    has @!scopes = {}, ;
    method enter-scope() {
        @!scopes.push({})
    }
    method leave-scope() {
        @!scopes.pop();
    }
    method declare($variable) {
        @!scopes[*-1]{$variable} = True
    }
    method check-declared($variable) {
        for @!scopes.reverse -&gt; %scope {
            return True if %scope{$variable};
        }
        return False;
    }
}

grammar VariableLists {
    token TOP {
        :my $*ST = SymbolTable.new();
        &lt;statement&gt;*
    }
    token ws { &lt;!ww&gt; \h* }
    token statement {
        | &lt;declaration&gt;
        | &lt;block&gt;
    }
    rule declaration {
        &lt;identifier&gt;
        { $*ST.declare( $&lt;identifier&gt; ) }
        '=' &lt;termlist&gt;
        \n
    }
    rule block {
        '{' \n*
            { $*ST.enter-scope() }
            &lt;statement&gt;*
            { $*ST.leave-scope() }
        '}' \n*
    }
    rule termlist { &lt;term&gt; * % ',' }
    token term { &lt;variable&gt; | &lt;number&gt; }
    token variable {
         &lt;identifier&gt;
         &lt;?{ $*ST.check-declared($&lt;identifier&gt;) }&gt;
    }
    token number { \d+ }
    token identifier { &lt;:alpha&gt; \w* } }</code></pre>
</div>
</div>
<div class="paragraph">
<p>SymbolTable 类具有私有数组属性 <code>@!scopes</code>，它 使用包含单个空哈希{}的列表进行初始化。进入一个 scope 意味着在这个数组的顶部推送一个空哈希，并在离开时 通过pop方法调用再次删除它的范围。一个变量声明将其名称添加到最顶层的哈希，<code>@!scopes[*-1]</code>。</p>
</div>
<div class="paragraph">
<p>检查变量的存在不能只考虑最顶层的哈希，因为变量被继承到内部范围。在这里，我们以最内层到最外层的相反顺序遍历所有范围范围。遍历的顺序与简单的布尔检查无关，但是如果你需要查找与变量相关的信息，那就是重要的是要遵守这个命令来引用正确的命令。</p>
</div>
<div class="paragraph">
<p>Token TOP 创建了一个类 <code>SymbolTable</code> 类的新对象，声明 调用declare方法，并且令牌变量调用方法检查 - 声明。规则块在解析语句之前调用 enter-scope 列表，然后留下范围。这有效，但仅限于语句列表 可以成功解析; 如果没有，规则块在设法调用之前就失败了 离开作用域。</p>
</div>
<div class="paragraph">
<p>Raku 具有针对这种情况的安全功能:如果你在声明前添加前缀 有了 LEAVE，Raku 会在常规出又处为你调用，无论何时何地 这是可能的(即使抛出异常)。自从 LEAVE <a href="https://docs.perl6.org/language/phasers">phasers</a><sup class="footnote">[<a id="_footnoteref_55" class="footnote" href="#_footnotedef_55" title="View footnote.">55</a>]</sup>。 只能在常规代码而不是正则表达式中运行，我们需要将正则表达式包装起来</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method block {
    $*ST.enter-scope();
    LEAVE $*ST.leave-scope();
    self.block_wrapped();
}

rule block_wrapped {
    '{' \n*
        &lt;statement&gt;*
    '}' \n*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们具有与动态方法相同的稳健性变量，以及在符号表中添加额外代码的更大灵活性
更多代码和更多努力的成本。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_8">9.7. 总结</h3>
<div class="paragraph">
<p>Raku grammar 是一种编写递归下降解析器的声明方式。 没有回溯，它们是预测性的; 在每一点上，我们知道什么列表 令人期待的令牌</p>
</div>
<div class="paragraph">
<p>语法的递归性质伴随着左递归的风险，递归路径不消耗任何字符的情况，和因此导致无限循环。</p>
</div>
<div class="paragraph">
<p>尽管语法具有自上而下的性质，但通常都要编写它们从下到上发生:从词法分析开始，然后向上解析更大的结构。</p>
</div>
<div class="paragraph">
<p>复杂语言需要额外的状态才能成功和精确解析。我们已经看到了如何使用动态变量来保持状态在语法中，它们的范围如何与输入中的词法作用域相对应，以及如何编写符号表并将其集成到语法中。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_从匹配中提取数据">10. 从匹配中提取数据</h2>
<div class="sectionbody">
<div class="paragraph">
<p>到目前为止，我们已经花了很大力气来解析各种文件格式，并且我们努力的结果是一个匹配对象，如果匹配失败则结果为 <code>Nil</code>。</p>
</div>
<div class="paragraph">
<p>在大多数情况下，只知道匹配是否成功只是第一步 - 我们想从成功的匹配中提取有用的数据。</p>
</div>
<div class="paragraph">
<p>原则上，我们可以检查生成的匹配对象并提取所有必要的数据。如果它没有提供足够的解析度，我们可以添加捕获使其解析粒度更细。这种方法可行，但它的写法往往令人沮丧，结果也很脆弱。</p>
</div>
<div class="paragraph">
<p>但在我们窥视答案之前，让我们再谈谈这个问题。我们从成功的正则表达式匹配或 grammar 解析中获得的匹配对象是一棵<strong>解析树</strong>。它的结构直接由 grammar 的结构决定，并且在解析树中找到的信息都是关于所匹配到的字符串的，以及在输入字符串中找到的关于它们的位置的信息。</p>
</div>
<div class="paragraph">
<p>我们想要解析字符串的原因通常是处理其内容。如果输入是 INI 文件，我们想要提取节(sections)和他们的键/值对; 如果是编程语言的源代码， 我们可能想检查一些特征(如 linter)，或者把它编译为较低级别的格式。通常，这个处理步骤，无论它是什么, 不应该直接绑定到解析树，而是更抽象的内容的表示。这种表示称为抽象语法树，简称 AST。</p>
</div>
<div class="paragraph">
<p>根据使用情况，AST 可能看起来非常不同。对于 JSON 解析器，AST 可以直接是已经序列化成 JSON 字符串的数据结构，所以混合了数组，散列，字符串，数字和布尔。对于编程语言，通常在你关心的捕获输入的所有方面的自定义类的集合之外构造一个 AST; 这些 AST 类通常还包含引用输入行号的注释，以便错误消息可以正确地确定错误的位置。</p>
</div>
<div class="sect2">
<h3 id="_action_对象">10.1. Action 对象</h3>
<div class="paragraph">
<p>Grammars 和匹配对象具有两个功能, 提供了更加弹性和可扩展性的数据提取方法。第一个也是比较简单的一个, 是你可以将任意数据结构附加到 <a href="https://docs.raku.org/type/Match">Match</a><sup class="footnote">[<a id="_footnoteref_56" class="footnote" href="#_footnotedef_56" title="View footnote.">56</a>]</sup> 对象， 随后通过 <code>.made</code> 属性访问它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 'abc' ~~ /\w/ {
    $/.make({'a' =&gt; 'bc'});
    say $/.made;      # Output: {a =&gt; bc}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果匹配对象在特殊变量 <code>$/</code> 中，您也可以调用 <code>make DATA</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 'abc' ~~ /\w/ {
    make {'a' =&gt; 'bc'};
    say $/.made;     # Output: {a =&gt; bc}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以看到它的发展方向:您可以构建一个数据结构，它将成为最终 AST 的一部分，并使用 <code>make</code> 将其附加到匹配对象上。</p>
</div>
<div class="paragraph">
<p>你在哪里这样做?一个选项是内联代码对象，<code>{ &#8230;&#8203; }</code>， 但是它将 grammar 与 AST 生成代码紧密结合在一起。 这是第二个功能的用武之地: action 对象。</p>
</div>
<div class="paragraph">
<p>action 对象是您传递给 grammar 上的 <code>.parse</code> 或 <code>.subparse</code> 调用的参数。从此以后，每当命名正则表达式成功匹配时， 正则表达式引擎为您调用一个方法; 它搜索和该正则表达式同名的方法，如果存在同名方法，则使用匹配对象作为参数调用它。 如果不存在这样的方法，则不会发生任何事情，也不会引发错误。</p>
</div>
<div class="paragraph">
<p>以下是解析计算数学表达式的 action 示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MathExpression {
    token TOP    { &lt;sum&gt; }
    rule sum     { &lt;product&gt;+ % '+' }
    rule product { &lt;term&gt;+ % '*' }
    rule term    { &lt;number&gt; | &lt;group&gt; }
    rule group   { '(' &lt;sum&gt; ')' }
    token number { \d+ }
}

class MathEvalAction {
    method TOP($/) {
        make $&lt;sum&gt;.made;
    }
    method sum($/) {
        make [+] $&lt;product&gt;».made;
    }
    method product($/) {
        make [*] $&lt;term&gt;».made;
    }
    method term($/) {
        make $/.values[0].made;
    }
    method group($/) {
        make $&lt;sum&gt;.made;
    }
    method number($/) {
        make $/.Int;
    }
}

my $match = MathExpression.parse(
    '4 + 5 * (1 + 3)',
    actions =&gt; MathEvalAction.new,
);

say $match.made;       # Output: 24</code></pre>
</div>
</div>
<div class="paragraph">
<p>你应该已经从前面的章节熟悉了 <code>MathExpression</code> grammar; 新的东西是另一个类, <code>MathEvalAction</code>，对于 grammar 中的每个正则表达式, 它都有一个方法与之对应。每个方法都以 <code>$/</code> 作为唯一参数， 匹配对象绑定到 <code>$/</code>。它调用 <code>make</code> 来附加内容到这个匹配对象上。</p>
</div>
<div class="paragraph">
<p>这个类的想法是每个方法都附加一个数字到当前匹配对应的当前匹配对象上。因此，如果它解析字符串 <code>2 *(1 + 4)</code>，它将数字 2 附加到解析了 2 的匹配对象上。 它对数字 1 和 4 做同样的事情，然后附加 <code>sum</code> 的结果 5，到解析了 <code>1 + 4</code> 的匹配对象上，然后再次， 把数字 5 附加到解析了 <code>(1 + 4)</code> 的匹配对象上，最后它计算 <code>product</code>，并将数字 10 附加到顶级匹配对象上。</p>
</div>
<div class="paragraph">
<p>从下到上阅读，<code>number</code> 方法通过在匹配对象上调用 <code>Int</code> 方法将字符串转换为数值。它将结果整数附加到匹配对象上。匹配 <code>group</code> 只需要来自 <code>$&lt;sum&gt;</code> 的匹配的附加值，并将其附加到自己的匹配对象上。</p>
</div>
<div class="paragraph">
<p>术语 <code>rule</code> 与两个备选项中的一个匹配。<code>$/.values</code> 返回一个所有匹配对象的列表，它总是一个元素。<code>make $/.values[0].made</code> 因此传送来自任一匹配的附加值并把它附加到它自己的匹配对象上。</p>
</div>
<div class="paragraph">
<p>规则 <code>product</code> 解析由星号分隔的术语列表。同名的 action 方法取每个术语附带的数字并将它们相乘。<code>$&lt;term&gt;».made</code> 中的 <code>».</code> 语法在列表 <code>$&lt;term&gt;</code> 的每个元素上调用 <code>made</code> 方法, 并返回所有结果的列表。 如果您无法使用键盘编写出 <code>»</code> 字符，则可以改用 <code>&gt;&gt;</code>，所以这就变成了 <code>$&lt;term&gt;&gt;&gt;.made</code>。</p>
</div>
<div class="paragraph">
<p><code>[*] LIST</code> 在 LIST 的每个元素之间插入 * 运算符， 因此计算所有这些值的乘积。</p>
</div>
<div class="paragraph">
<p>由于规则 <code>sum</code> 和 <code>product</code> 具有相同的结构，所以它们的 action 方法也是如此。<code>sum</code> 使用 <code>[+]</code> 来创建所有附加到下面一级的匹配对象的数字的总和。</p>
</div>
<div class="paragraph">
<p>最后，token <code>TOP</code> 只调用 <code>sum</code>，因此 action 类中的方法 <code>TOP</code> 就是传递附加到 <code>$&lt;sum&gt;</code> 的值。</p>
</div>
<div class="paragraph">
<p>这是一个匹配树，右边的一列使用每个 <code>.made</code> 的值注解:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">sum =&gt; ⌜4 + 5 * (1 + 3)⌟          24
 product =&gt; ⌜4 ⌟                   4
  term =&gt; ⌜4 ⌟                     4
   number =&gt; ⌜4⌟                   4
 product =&gt; ⌜5 * (1 + 3)⌟         20
  term =&gt; ⌜5 ⌟                     5
   number =&gt; ⌜5⌟                   5
  term =&gt; ⌜(1 + 3)⌟                4
   group =&gt; ⌜(1 + 3)⌟              4
    sum =&gt; ⌜1 + 3⌟                 4
     product =&gt; ⌜1 ⌟               1
      term =&gt; ⌜1 ⌟                 1
       number =&gt; ⌜1⌟               1
     product =&gt; ⌜3⌟                3
      term =&gt; ⌜3⌟                  3
       number =&gt; ⌜3⌟               3</code></pre>
</div>
</div>
<div class="paragraph">
<p>在每个分支中，缩进最多的匹配是其 action 方法首先被调用的匹配，所以 <code>number</code> 在 <code>term</code> 之前调用, <code>term</code> 在 <code>product</code> 之前调用, <code>product</code> 在 <code>sum</code> 之前调用。 这种排序保证了每个 action 方法都可以依赖于子匹配上的 <code>.made</code> 属性的存在。</p>
</div>
<div class="paragraph">
<p>编写 action 方法只需要知道相应的正则表达式捕获的内容以及它们的 <code>.made</code> 属性包含的内容。我们不需要深入了解匹配树的嵌套结构。如果以这种方式构建 action，则可灵活应对 grammar 的变更。每当你修改正则表达式时，你都可以放心，您只需要触摸与其对应的 action 方法，并且你永远不必担心另一个 action 方法可能依赖于你正所接触的正则表达式。</p>
</div>
<div class="paragraph">
<p>当您为 <code>proto token</code> 编写 action 方法时，您应该注意，对于成功匹配候选者, 调用 action 方法，但不是整个原型。所以，如果你的 grammar 包含如下行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto token value {*};
token value:sym&lt;string&gt; { &lt;string&gt; }
token value:sym&lt;number&gt; { &lt;number&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么 grammar 引擎可能会为你调用一个名为 <code>value:sym&lt;string&gt;</code> 或 <code>value:sym&lt;number&gt;</code> 的方法，但不是 <code>value</code> 方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_action_对象构建_ast">10.2. 使用 Action 对象构建 AST</h3>
<div class="paragraph">
<p>上一节说明了 action 对象和方法的机制，它构建类似于 AST 的东西，但它不是树。因为树是解析成功的最常见结果，我想呈现另一个用于创建抽象语法的相同语法的 action 类 解析期间的树。</p>
</div>
<div class="paragraph">
<p>为了省去编写单独树类的麻烦，我们将使用嵌套的数组表示树。树的第一个元素是运算符; 其他元素是操作数。因此，对于表达式 <code>1 + 2 + 3</code>， 结果是 <code>['+', 1, 2, 3]</code>。由于嵌套表达式由嵌套括号表示，对于一组圆括号, 我们不需要运算符: 因此表达式 <code>2 *(3 + 4)</code> 表示为 <code>['*', 2，['+', 3, 4]]</code>。</p>
</div>
<div class="paragraph">
<p>我们来看看 action 类，以及我们如何使用它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class MathASTAction {
    method reduce($op, @list) {
        return @list[0] if @list.elems == 1;
        return [$op, |@list];
    }

    method TOP($/) {
        make $&lt;sum&gt;.made;
    }
    method sum($/) {
        make self.reduce('+', $&lt;produce&gt;».made);
    }
    method product($/) {
        make self.reduce('*', $&lt;term&gt;».made);
    }
    method term($/) {
        make $/.values[0].made;
    }
    method group($/) {
        make $&lt;sum&gt;.made;
    }
    method number($/) {
        make $/.Int;
    }
}

say $match = MathExpression.parse(
    '4 + 5 * (1 + 3)',
    actions =&gt; MathASTAction.new,
);
say $match.made.perl;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码(以及前一节的 grammar 定义)产生如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">["+", 4, ["*", 5, ["+", 1, 3]]]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TOP</code>，<code>term</code>，<code>group</code> 和 <code>number</code> 的 action 方法与前面讨论过的 action 类的那些是相同的。有趣的部分是 <code>sum</code> 和 <code>product</code> 的 action 方法。我们来看看后者， 代表两者:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method reduce($op, @list) {
    return @list[0] if @list.elems == 1;
    return [$op, |@list];
}

method product($/) {
    make self.reduce('*', $&lt;term&gt;».made);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们只使用 <code>make ['*'，|$&lt;term&gt;».made]</code> 作为 <code>product</code> 方法的主体，那么 <code>1 + 2</code> 的 AST 会以 <code>['+', ['*', 1], ['*', 2]]</code> 的形式出现， 因为每个 <code>sum</code> 解析一个 <code>product</code> 表达式。我们不想要额外的单元素乘法的级别，所以我们做一个特例。如果只有一个项被解析，只返回该项。否则，返回一个由运算符组成的数组，然后是所有项的 AST。</p>
</div>
<div class="paragraph">
<p>由于这种特殊情况使用了两次(对于 <code>sum</code> 和 <code>product</code>)，把它分解成一个方法是有意义的，我称这个方法为 <code>reduce</code>。<code>reduce</code> 方法使用语法 <code>[$op, |@list]</code> 来创建 <code>$op</code> 与 <code>@list</code> 的元素连接在一起的数组。<code>|</code> 扁平化 <code>@list</code>; 要是我们不使用它，结果将是 <code>['+', [1, 2]]</code> 而不是 <code>['+', 1, 2]</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_在_action_对象中保存状态">10.3. 在 Action 对象中保存状态</h3>
<div class="paragraph">
<p>上一节中的 action 类是方法的集合， 但他们不保存任何状态。有人可能会说他们不是"真正的" 对象。实际上，我们可以移除 action 类上的 <code>.new</code> 调用，并将类直接传递给 grammar，这些例子就可以像之前一样工作。状态是正在构建的 AST，它存储在匹配对象的 <code>.made</code> 属性中。</p>
</div>
<div class="paragraph">
<p>这是一种常见的模式，但不一定是这种方式。您用作 action 对象的对象是普通的 Raku 对象，可以随心所欲地做任何事。您可以在其中存储数据，以及甚至可以在对 grammar 的 <code>.parse</code> 方法的多次调用中重用同一个 action 对象。</p>
</div>
<div class="paragraph">
<p>读到这一点，你可能想知道为什么我们在前面的示例中经历了将符号表保留在动态变量中的麻烦， 而不是使用 action 对象。这里的区别是符号表影响了解析的结果; 引用未声明的变量使匹配失败。Grammar 有意独立于他们的 action 对象，以便您可以修改甚至交换 action 类不影响 grammar。</p>
</div>
<div class="paragraph">
<p>以下是解析单个变量赋值的 grammar 示例并把这些变量收集到哈希中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class VariableCollection {
   has %.definitions;
    method TOP($/) {
        %.definitions{ $&lt;identifier&gt; } = $&lt;termlist&gt;.made;
    }
    method number($/)     { make $/.Int }
    method identifier($/) { make $/.Str }
    method termlist($/)   { make $&lt;term&gt;».made }
    method term($/)       { make $/.values[0].made }
}

grammar VariableAssignment {
    rule TOP         { \s* &lt;identifier&gt; '=' &lt;termlist&gt; }
    rule termlist    { &lt;term&gt; * % ',' }
    token term       { &lt;identifier&gt; | &lt;number&gt; }
    token number     { \d+ }
    token identifier { &lt;:alpha&gt; \w* }
    token ws         { &lt;!ww&gt; \h* }
}

my $actions = VariableCollection.new;

my @lines = 'a = 1', 'c = a, 5, b', 'b = 2';

for @lines -&gt; $line {
    unless VariableAssignment.parse($line, :$actions) {
        die qq[Invalid input: "$line"];
    }
}

say $actions.definitions;
        # Output: {a =&gt; [1], b =&gt; [2], c =&gt; [a 5 b]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，<code>has %.define</code> 定义了一个公共属性; 一个附着在对象上的一块状态，可以从外面访问。语法: <code>$actions</code> 是 <code>actions &#8658; $actions</code> 的简写。</p>
</div>
<div class="paragraph">
<p>这种使用有状态 action 对象和一次一项地解析部分输入的模式对流处理非常有用; 如果你收到数据分段，需要在收到完整的输入之前访问结果，或者如果你的系统连续运行并且有一个不断的输入流。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_9">10.4. 总结</h3>
<div class="paragraph">
<p>如果你为 grammar 的 <code>parse</code> 调用提供一个 action 对象，那么就会调用与正则表达式同名的方法。你可以用它来从你的 grammar 构建一个抽象语法树。此外，您可以在此 action 对象中保持状态并使用此机制来解析分段但相关的输入。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_生成好的解析错误消息">11. 生成好的解析错误消息</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当正则表达式匹配或语法分析失败时，它返回 <code>Nil</code>。如果是这种情况 在没有预料到失败的地方，我们可以告知用户某种形式的输入(可能是配置文件)无效。</p>
</div>
<div class="paragraph">
<p>对于简单的输入，如电子邮件地址或 URL，这段二进制文件 信息可能令人满意。对于更大的配置或源文件， 我们真的想给用户更多信息。为什么输入无效? 如果我们不能回答，错误在哪里?</p>
</div>
<div class="paragraph">
<p>或者换一种方式:当解析失败时，我们想要识别位置，可能是解析失败的原因，并产生一个好处错误信息。</p>
</div>
<div class="sect2">
<h3 id="_探索问题">11.1. 探索问题</h3>
<div class="paragraph">
<p>Raku 中没有内置的通用机制可以产生良好的解析 错误消息，我不知道怎么会有这样的机制。该原因是，即使在成功的解析运行中，个人也是正常的正则表达式和令牌失败。</p>
</div>
<div class="paragraph">
<p>我们只考虑早期语法中的两行，即 VariableLists:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule  termlist { &lt;term&gt; * % ',' }
token term     { &lt;identifier&gt; | &lt;number&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设这匹配字符串令牌术语首先尝试匹配字符串的标识符和编号。标识符正则表达式失败; 然而，数字成功了。然后，<code>termlist</code> 本身与逗号匹配， 而它的术语又回来了。这次标识符分支成功匹配字符串，数字无法匹配。最后，termlist 尝试匹配下一个逗号，并失败，但整个 termlist 匹配成功。</p>
</div>
<div class="paragraph">
<p>在这个例子中，我们已经看到三次失败的比赛是成功的一部分 比赛。那么这种“正常”失败的比赛与那场比赛的区别是什么致命导致整个解析中止?</p>
</div>
<div class="paragraph">
<p>从技术上讲，一个致命的失败的正则表达式是一个失败传播的正则表达式向上一直到 TOP。但这并没有帮助我们创造出好的错误消息。当它失败时，我们还不知道它是否会传播整个过程。一旦它传播到正则表达式 TOP，就为时已晚, 从失败的匹配中提取有用的信息。</p>
</div>
<div class="paragraph">
<p>匹配失败的不同视角提供了更多洞察力。那里基本上是两种匹配可能出错的方式。一个案例就是我们 开始解析一些东西，我们只能匹配它的第一部分，但不能匹配休息。在数学表达式的情况下，这可能是一个开头 括号中没有对应的右括号，或者加号后面没有任何表达式。第二种情况是一种情况 或者更多的替代品，但没有一个匹配。例如，一个 JSON 解析器可能期望一个对象，一个数组，一个数字或一个字符串，但是输入字符是一个 <code>$-something</code>，它只是一个无效的 JSON 引用字符串。</p>
</div>
</div>
<div class="sect2">
<h3 id="_断言">11.2. 断言</h3>
<div class="paragraph">
<p>顺序替代方案允许您创建良好的错误消息。一般模式是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule group {
    '(' &lt;sum&gt;
    [')' || { die "Cannot find closing ')'" } ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此正则表达式尝试匹配右括号。如果没有 工作，而不是默默地失败，它使用 <code>{&#8230;&#8203;}</code> 代码块来抛出 使用内置模具功能的异常。异常中止解析， 如果没有解析方法的调用者捕获它，程序将退出返回代码不成功。成为改善错误的有效工具报告，我们必须将相同的模式应用于更多的位置。</p>
</div>
<div class="paragraph">
<p>在最微不足道的输入中描述错误是足够的。在任何多行输入，我们需要指出错误的位置; 除此以外， 用户将很难解决问题。
我们可以通过匹配对象 <code>$/</code> 访问该位置，并使用它计算行号。因为这是我们需要的东西 很少有地方，最好将该逻辑提取到一个方法中。然后我们可以打电话这个方法来自正则表达式，其语法与我们称之为正则表达式相同， 在参数周围添加了一对括号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MathExpression {
    token TOP           { &lt;sum&gt; }
    rule sum            { &lt;multiplication&gt;+ % '+' }
    rule multiplication { &lt;term&gt;+ % '*' }
    rule term           { &lt;number&gt; | &lt;group&gt; }
    rule group {
              '(' &lt;sum&gt;
            [ ')' || &lt;error("no closing ')'")&gt; ]
    }

    token number        { \d+ }

    method error($msg)  {
        my $parsed = self.target.substr(0, self.pos);
        my $line-no = $parsed.lines.elems;
        die "Cannot parse mathematical expression: "
            ~ "$msg at line $line-no";
    }
}

say MathExpression.parse("(\n1");</code></pre>
</div>
</div>
<div class="paragraph">
<p>它以前是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[ ')' || {die "Cannot find closing ')'" } ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[ ')' || &lt;error("no closing ')'")&gt; ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，我们通过调用替换了直接模具函数调用 自定义错误方法。这种方法有一些技巧 确定行号: <code>.target</code> 方法返回字符串 语法当前匹配，<code>self.pos</code> 提取当前 解析位置。<code>self.pos</code> 相当于 <code>$/.to</code>，除了后者仅适用于解析结束或生成捕获时。</p>
</div>
<div class="paragraph">
<p>这些方法来自哪里?通过声明一个类型语法，它自动获取父类 <a href="https://docs.raku.org/type/Grammar">Grammar</a><sup class="footnote">[<a id="_footnoteref_57" class="footnote" href="#_footnotedef_57" title="View footnote.">57</a>]</sup>(提供解析和 <code>subparse</code> 方法)，继而从 <a href="https://docs.raku.org/type/Cursor">Cursor</a><sup class="footnote">[<a id="_footnoteref_58" class="footnote" href="#_footnotedef_58" title="View footnote.">58</a>]</sup> 继承，供应 <code>.target</code> 和 <code>.pos</code> 方法。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Str%23routine_lines">Str.lines</a><sup class="footnote">[<a id="_footnoteref_59" class="footnote" href="#_footnotedef_59" title="View footnote.">59</a>]</sup> 方法将字符串分解为行列表包含; 在此列表上调用 <code>.elems</code> 会产生行数。为一个 没有任何换行符的字符串，这会产生数字。注意比 即使是最核心的C程序员也会从头数开始计算行数一个(不是零)，所以 <code>lines.elems</code> 中的数字符合我们作为一条线的目的数。</p>
</div>
<div class="paragraph">
<p>示例代码的输出如下: 无法解析数学表达式:第2行没有关闭')'错误报告正确地将错误报告为在线号码 2，因为输入字符串中的 <code>\n</code> 引入了换行符。</p>
</div>
</div>
<div class="sect2">
<h3 id="_改进位置报告">11.3. 改进位置报告</h3>
<div class="paragraph">
<p>我们在上一节中看到的错误方法是第一个好的方法</p>
</div>
<div class="paragraph">
<p>近似，但我们可以做更多的事情来提高其准确性。第一个很简单。在许多情况下，隐式的 <code>&lt;.ws&gt;</code> 调用可以 在 <code>[&lt;something&gt; ||</code> 之前匹配空格 <code>&lt;error(&#8230;&#8203;)&gt;]</code> 阻止。在一个 ws 可以匹配换行符的语法，这可以移动报告的错误位置向下，这与我们对如何直观理解不符我们希望报告错误位置。</p>
</div>
<div class="paragraph">
<p>我们可以通过从中删除尾随空格来解决这个问题 <code>$parsed</code> string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $parsed = self.target.substr(0, self.pos)\
             .trim-trailing;</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个改进策略是提供一些上下文 错误信息。例如，Rakudo Raku 解析器打印源 错误位置周围的代码，并使用弹出标记错误位置 符号，⏏。</p>
</div>
<div class="paragraph">
<p>我们可以在我们自己的语法中做同样的事情:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method error($msg) {
    my $parsed = self.target.substr(0, self.pos)\
                 .trim-trailing;
    my $context = $parsed.substr($parsed.chars - 10 max 0)
          ~ '⏏' ~ self.target.substr($parsed.chars, 10);
    my $line-no = $parsed.lines.elems;
    die "Cannot parse mathematical expression: $msg\n"
        ~ "at line $line-no, around " ~ $context.perl
        ~ "\n(error location indicated by ⏏)\n";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此版本的error方法构造十个上下文字符串 错误位置之前和之后的字符(尽管它使用 <code>$chars max 0</code> 防止负面指数)。它产生如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot parse mathematical expression: no closing ')' at line 1, around "(1 + 2⏏"
(error location indicated by ⏏)</code></pre>
</div>
</div>
<div class="paragraph">
<p>或使用输入字符串 "1 + 2 5", 你得到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot parse mathematical expression: no closing ')' at line 1, around "(1 + 2⏏ 5"
(error location indicated by ⏏)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_高水位标记">11.4. 高水位标记</h3>
<div class="paragraph">
<p>到目前为止讨论的技术依赖于手动插入 <code>|| &lt;error(&#8230;&#8203;)&gt;</code> 分成语法。如果你想避免这种情况在错误消息中牺牲一点清晰度 - 你可以使用另一个技术。即使没有，您也可以将它与显式错误结合使用报告。</p>
</div>
<div class="paragraph">
<p>就像高水位标记每次大海或更高时被推高一点河流水位达到新的记录，我们可以记录到最远的位置我们的语法达到了。我们可以通过动态变量来做到这一点。 如果 <code>self.pos</code> 大于当前的值，我们设置为 <code>self.pos</code> 变量。然后，这个高水位标记构成了我们错误位置的基础报告。</p>
</div>
<div class="paragraph">
<p>这种录音的一个方便的地方是 ws 令牌，因为它是在许多地方已经被召唤过，它是原始的自然分界符令牌。每当正则表达式位置达到新的高水位时，我们就会还可以记录调用ws的规则的名称。这个信息是可以通过 <a href="https://docs.raku.org/type/CallFrame%23sub_callframe">callframe</a><sup class="footnote">[<a id="_footnoteref_60" class="footnote" href="#_footnotedef_60" title="View footnote.">60</a>]</sup> 内置子程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method ws() {
    if self.pos &gt; $*HIGHWATER {
        $*HIGHWATER = self.pos;
        $*LASTRULE = callframe(1).code.name;
    }
    callsame;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>callsame 函数从父类调用 ws 方法。(在语法中是语法)，传递相同的论点 收到的当前方法。换句话说，你在这里看到的 ws 方法 包装默认的 ws 正则表达式。我们可以委托任何其他命名的正则表达式这里的语法只需通过调用它，例如 <code>self.customws</code>。</p>
</div>
<div class="paragraph">
<p>这个 ws 方法假设动态变量 <code>$*HIGHWATER</code> 和 <code>$*LASTRULE</code> 已在某处宣布。如果我们在令牌 TOP 中这样做 (如前面的例子所示)，我们遇到了一个问题: 一旦解析了失败，变量不再可用于报告错误。再次一个包装器来拯救: 我们可以将所有的解析方法包装起来语法有:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method parse($target, |c) {
    my $*HIGHWATER = 0;
    my $*LASTRULE;
    my $match = callsame;
    self.error($target) unless $match;
    return $match;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>签名中的语法 <code>|c</code> 捕获所有剩余的参数命名和位置。这确保了像 MathExpression 这样的调用。 解析( <code>$string，rule &#8658;'multiplication'</code> )继续工作。 然后，callsame 将相同的参数传递给原始的解析方法。关键部分是匹配失败时调用错误方法。 当然，错误方法也需要一些摆弄才能使用 <code>$*HIGHWATER</code> 和 <code>$*LASTRULE</code> 动态变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method error($target) {
    my $parsed = $target.substr(0, $*HIGHWATER)\
                 .trim-trailing;
    my $line-no = $parsed.lines.elems;
    my $msg = "Cannot parse mathematical expression";
    $msg ~= "; error in rule $*LASTRULE" if $*LASTRULE;
    die "$msg at line $line-no";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此错误方法使用 <code>$*HIGHWATER</code> 而不是 <code>self.pos</code> 确定解析失败的位置和 <code>$*LASTRULE</code> 报告取得进展的最后一个解析规则。这里还有另一个变化: 不是访问自己。</p>
</div>
<div class="paragraph">
<p>target，error方法获取目标字符串作为参数。这个到期了到目前为止，我们已经掩盖了语法力学的细节。什么时候你调用 <code>SomeGrammar.parse(&#8230;&#8203;)</code>，这是对类型对象的方法调用 <code>SomeGrammar</code>。但语法引擎需要在某处保持状态， 所以方法解析创建了一个语法实例 - 非常相似 您可以在从正则表达式调用的方法内的self中访问的实例。 这个细节是很重要的，因为方法解析调用错误后的解析已经完成，所以实例已经消失了。试图调用 <code>self.target</code> 或者 <code>self.pos</code> 死于消息无法在中查找属性 <code>MathExpression</code> 类型对象。</p>
</div>
<div class="paragraph">
<p>这种基于高水位标记的错误报告正确识别作为未完成的总和，<code>*</code> 作为未完成的乘法，并且(作为不完整的群体表达</p>
</div>
</div>
<div class="sect2">
<h3 id="_parser_combinator_和_failgoal">11.5. Parser Combinator 和 FAILGOAL</h3>
<div class="paragraph">
<p>解析匹配的分隔符对与它们之间的一些内容是足够普遍，Raku 有一个特殊的语法。而不是写作</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token group {
    '(' &lt;sum&gt; ')'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以写作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token group {
    '(' ~ ')' &lt;sum&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中 <code>~</code> 是解析器组合器，重新排列后续标记。在这个例子，视觉上的好处并不大，但如果是正则表达式的话分隔的内容更长，将分隔符放在一起很好。</p>
</div>
<div class="paragraph">
<p>更重要的是，如果无法找到结束分隔符，则使用正则表达式 引擎调用一个名为 FAILGOAL 的方法。在默认实现中，这个刚刚失败的比赛。我们可以覆盖此方法以生成错误消息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MathExpression {
    token TOP           { &lt;sum&gt; }
    rule sum            { &lt;multiplication&gt;+ % '+' }
    rule multiplication { &lt;term&gt;+ % '*' }
    rule term           { &lt;number&gt; | &lt;group&gt; }
    rule group          { '(' ~ ')' &lt;sum&gt; }
    token number        { \d+ }

    method FAILGOAL($goal) {
        my $cleaned = $goal.trim;
        self.error("No closing $cleaned");
    }

    method error($msg) {
        my $parsed = self.target.substr(0, self.pos)\
                     .trim-trailing;
    my $context = $parsed.substr($parsed.chars - 10 max 0)
        ~ '⏏' ~ self.target.substr($parsed.chars, 10);
    my $line-no = $parsed.lines.elems;
    die "Cannot parse mathematical expression: $msg\n"
         ~ "at line $line-no, around " ~ $context.perl
         ~ "\n(error location indicated by ⏏)\n";
    }
}

MathExpression.parse('(1');</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>FAILGOAL</code> 方法的参数是正则表达式的源代码 与结束分隔符匹配的部分。<a href="https://docs.raku.org/type/Str%23method_trim">trim</a><sup class="footnote">[<a id="_footnoteref_61" class="footnote" href="#_footnotedef_61" title="View footnote.">61</a>]</sup> 方法删除 周围的空白，我们输入的一个版本的输出本章前面所见的错误方法。</p>
</div>
<div class="paragraph">
<p>输出如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot parse mathematical expression: No closing ')' at line 1, around "(1⏏"
(error location indicated by ⏏)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用哪种技术">11.6. 使用哪种技术?</h3>
<div class="paragraph">
<p>错误报告技术没有严格的规则用于哪种项目。唯一的规则就是那个人越多实际上使用你的语法，你应该付出更多努力错误信息好。</p>
</div>
<div class="paragraph">
<p>您也可以结合所有这些技巧: 使用 <code>[&lt;expected&gt; || &lt;error('&#8230;&#8203;')&gt;]</code> 模式就在你需要的地方，放一个 FAILGOAL 方法到位，并使用高水位技术得到一个在没有明确安装的情况下，错误的位置很好断言更好的错误报告。</p>
</div>
<div class="paragraph">
<p>你可能会因为在后面的例子中被推迟一章，超过一半的语法源代码现在都是专用的错误报告。但是我们开始使用非常简单的语法，它人为地减小了它的大小。</p>
</div>
<div class="paragraph">
<p>此外，大多数错误报告代码都非常通用，并且可以被分解成一个角色，并在许多语法中重复使用。那是什么的 <a href="https://modules.raku.org/dist/Grammar-ErrorReporting">Grammar::ParseError</a><sup class="footnote">[<a id="_footnoteref_62" class="footnote" href="#_footnotedef_62" title="View footnote.">62</a>]</sup> 个模块提供。</p>
</div>
<div class="paragraph">
<p>最后，我认为好的解析错误非常重要保证这种关注。<sup class="footnote">[<a id="_footnoteref_63" class="footnote" href="#_footnotedef_63" title="View footnote.">63</a>]</sup></p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_10">11.7. 总结</h3>
<div class="paragraph">
<p>从失败的解析过程生成良好的错误消息并不容易因为失败的正则表达式是解析的正常部分。因此，我们可以生成只有在某些时候我们决定提交解析时才会出现错误消息结果，并在该承诺没有时产生错误消息耽误。</p>
</div>
<div class="paragraph">
<p>这种承诺可以以顺序替代的形式明确在第二个分支中触发异常。或者我们可以隐含它每当规则使用高水位标记方法解析空格时。</p>
</div>
<div class="paragraph">
<p>最后，<code>~parser</code> 组合器允许您匹配一条输入 由分隔符包围，并提供一个钩子来改善错误关闭分隔符不匹配时的消息。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_unicode_和自然语言">12. Unicode 和自然语言</h2>
<div class="sectionbody">
<div class="paragraph">
<p>计算机处理的文本往往分为两类:旨在被人类消费的东西(如散文)，和旨在被软件消费的东西(机器代码和加密文件浮现在脑海中)。</p>
</div>
<div class="paragraph">
<p>到目前为止，我们所看到的数据格式都属于中间:它们被软件明确地理解，但是仍然能够被人类读写。</p>
</div>
<div class="paragraph">
<p>在本章中，我们将简要介绍隐藏在自然语言领域中的复杂性 - 文本直接针对人类消费，但仍然存储为一系列字节。</p>
</div>
<div class="paragraph">
<p>本章不是对自然语言处理的介绍; 它的意图是讨论处理多语言输入时必须注意的问题。</p>
</div>
<div class="sect2">
<h3 id="_书写系统">12.1. 书写系统</h3>
<div class="paragraph">
<p>书面英语基于字母表，通常是一组字母对应音素(口语元素)。</p>
</div>
<div class="paragraph">
<p>Abjads或辅音字母表遵循类似的结构，但只 包含辅音。可能有也可能没有元音标记表示 在说出单词的时候应该在哪里插入元音，但是那些 标记通常不表示要插入哪个元音。阿拉伯语和希伯来语 与古代北非和西亚的一些脚本类似，属于这一类。</p>
</div>
<div class="paragraph">
<p>音节是一个书写系统，其中每个音节都有自己的字符。一个著名的例子是平假名，日语书写系统的一个组成部分。</p>
</div>
<div class="paragraph">
<p>相比之下，表意文字传达了一种观念或意义。他们出现在中文书写系统中，往往与语音字符相结合，总共产生数千个字符。</p>
</div>
<div class="paragraph">
<p>有几个不同的书写系统会影响程序员如何处理文本处理的地方: 你不能假设单词是实际上是由字母组成的。一般来说，文本分割(将文本分成单词、句子和其他单位的过程)变得相当语言特定。并非所有语言和书写系统都使用空格分割单词，甚至划定单词。见<a href="http://unicode.org/reports/tr29/">关于文本分段的 Unicode 技术报告</a><sup class="footnote">[<a id="_footnoteref_64" class="footnote" href="#_footnotedef_64" title="View footnote.">64</a>]</sup>了解更多信息。</p>
</div>
<div class="paragraph">
<p>内置字符类如 <code>\d</code> 和 <code>\w</code> 匹配来自所有书写文字的字符 ，而不仅仅是拉丁文字。这意味着如果你使用 <code>\d+</code> 来 匹配一个数字，它可以匹配 42 和 ٤٢ (这是<a href="https://en.wikipedia.org/wiki/Eastern_Arabic_numerals">东阿拉伯语数字</a><sup class="footnote">[<a id="_footnoteref_65" class="footnote" href="#_footnotedef_65" title="View footnote.">65</a>]</sup>)。虽然这可能会令人惊讶，但将字符串 "٤٢" 转换为数字与我们的"普通"阿拉伯数字相同。</p>
</div>
</div>
<div class="sect2">
<h3 id="_字节代码点字素_和字形">12.2. 字节，代码点，字素， 和字形</h3>
<div class="paragraph">
<p>计算机将文本存储为一系列字节。编码，如 UTF-8， UTF-32 或 ISO-8859-1 描述了字节或字节序列如何映射到代码点。</p>
</div>
<div class="paragraph">
<p>代码点是 Unicode 联盟对字符的描述,因为它用于人类语言。它由零和大约 110 万之间的数字组成，以及使用大写 ASCII 字符的描述，如 GREEK SMALL LETTER OMICRON。Unicode 属性数据库记录更多信息，例如字符是否一个字母，一个小写字母，通常是从左到右书写的一部分，依此类推。</p>
</div>
<div class="sect3">
<h4 id="_字素簇">12.2.1. 字素簇</h4>
<div class="paragraph">
<p>并非每个代码点都对应一个完整的字符。有些语言允许基本字符与组合字符的自由组合。你可能会熟悉法语中使用的重音符和抑音符，如"née" (出生)或 "après"(之后)。为了与其他遗留编码兼容， 字符 é 和 è 作为独立的代码点存在，即所谓的预组合字符。但它们也可以写成基本字符 e，后面跟着 <strong>COMBINING ACUTE ACCENT</strong> 或 <strong>COMBINING GRAVE ACCENT</strong>。</p>
</div>
<div class="paragraph">
<p>在法语中，重音符和抑音符只作用在几个基础字符上 ，但在其他书写系统中，此类限制不适用。对于梵文文字中的一个例子，在印度次大陆很常见， 元音可以写成应用于辅音基础字符的组合字符。在这种情况下，并非所有可能的基本字符的组合和组合字符作为预先组合的 Unicode 代码点存在。</p>
</div>
<div class="paragraph">
<p>这意味着读者会认为某个字符可能会被存储为多个代码点 - 通常是基本字符后跟一个或多个组合字符 。我们称之为字素簇，或简称为字素。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，字符串的基本单位是字素簇。如果你通过调用其 <code>chars</code> 方法问一个字符串中的字符数，答案是字素簇的数量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "e\c[COMBINING GRAVE ACCENT]".chars; # Output: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>\c[NAME]</code> 语法按名称将代码点插入到双引号字符串中。</p>
</div>
<div class="paragraph">
<p>在这种情况下，碰巧存在预组合字符，但事实并非如此 Raku 必须将其视为单个字素; 因此，如果你选择了 <code>x</code> 作为基字符，不存在预组合字符，而 Raku 仍然存在将其归类为单个字符。</p>
</div>
<div class="paragraph">
<p>在正则表达式中它没有什么不同: 任何可以匹配单个字符的构造, 如字符类, 都可以匹配字素簇:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if "e\c[COMBINING GRAVE ACCENT]" ~~ / ^ . $ / {
    say "A single grapheme cluster";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当渲染文本时，无论是打印还是在屏幕上显示，渲染引擎可以选择将几个字素簇组合成单个字形(可以显示的形状)。例如，在英语中， 字母 f 和 i 的序列可以呈现为连字，单个字形包含两个字符，这通常分别比两个字符窄。</p>
</div>
<div class="paragraph">
<p>要在匹配正则表达式时忽略组合字符，您可以使用 <code>:ignoremark</code> 修饰符; <code>:m</code> 是简称。因此，<code>/:ignoremark uber/</code> 匹配字符串 "über"。当您怀疑用户可能难以输入变音符号，但仍想给他们包括这样的标记的搜索结果时, 这很有用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_字形">12.2.2. 字形</h4>
<div class="paragraph">
<p>在渲染期间选择字形的过程高度依赖输出媒体和字体，因此 Raku 不提供处理字形级别的字符串的内置功能。</p>
</div>
<div class="paragraph">
<p>你应该知道即使是等宽字体，中文，日语和韩语不符合单个常规字符的空间，而是占用两倍水平空间。全角字符是(通常为拉丁文)字符拉伸到与中文相同的宽度字符。在解析缩进块或水平对齐的表时您可能需要考虑字符的宽度。</p>
</div>
<div class="paragraph">
<p>主要的内容是，即使有字素簇和等宽字体，你不能假设一个渲染的宽度字符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_unicode_属性_2">12.2.3. Unicode 属性</h4>
<div class="paragraph">
<p>Unicode 中庞大的字符库使其不切实际且错误 - 容易枚举任何给定类别中的所有字符，如字母， 数字，标点符号，数学符号等。相反，你可以指定您希望匹配给定类别的字符。这些是由 Unicode 联盟定义的字符类。</p>
</div>
<div class="paragraph">
<p>Unicode 属性使用冒号(<code>:</code>)后跟尖括号内的属性名称。例如，<code>&lt;:Letter&gt;</code> 匹配任何字母 - 在撰写本文时，共有 63409 个代码点。一个新的 Unicode 版本可以进一步扩展该总数。</p>
</div>
<div class="paragraph">
<p>您可以使用 <code>+</code> 和 <code>-</code> 自由组合 Unicode 属性 <code>&lt;:Letter+:Digit&gt;</code> 匹配字母或数字。你也可以将基于属性的字符类与枚举相结合。如果你想为了匹配没有字符 e 的单词，你可以用正则表达式 <code>/&lt;:Letter-[eE]&gt;+/</code> 来做到这一点。</p>
</div>
<div class="paragraph">
<p>字母，数字，标点符号等字符的分类是称为常规类别，您可以使用 <code>uniprop</code> 方法进行查询字符所属的 Unicode 类别:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "a".uniprop; # Output: Ll</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 Ll 是 Lowercase_Letter 的简写。全套可能值可从<a href="https://docs.raku.org/language/regexes#Unicode_properties">官方文档</a>中获得。<sup class="footnote">[<a id="_footnoteref_66" class="footnote" href="#_footnotedef_66" title="View footnote.">66</a>]</sup></p>
</div>
<div class="paragraph">
<p>您可以查询更多类别</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "a".uniprop('Script');         # Output: Latin
say "a".uniprop('Block');          # Output: Basic Latin</code></pre>
</div>
</div>
<div class="paragraph">
<p>类别和属性的相同组合可用于正则表达式;  ` /&lt;:Block('Basic Latin'&gt;)&gt;/ ` 匹配来自"基本拉丁语"块的任何字符 。</p>
</div>
<div class="paragraph">
<p>在字素簇的情况下，无论是 <code>uniprop</code> 方法还是对属性的正则表达式匹配适用于基本字符，因此 字符串 <code>x\c[COMBINING TILDE]</code> 可以成功匹配 <code>&lt;:Letter&gt;</code>，但不是 <code>&lt;:Mark&gt;</code>，标识组合标记代码点的类别。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_11">12.3. 总结</h3>
<div class="paragraph">
<p>各种各样的自然语言和书写系统意味着许多我们(通常含蓄地)对语言做出的假设并不成立:不是每个逻辑字符或视觉字符都是一个代码点，而不是所有的单词都是由字母组成，并不是所有单词都用空格分隔，仅举几例。Raku 通过将字素簇作为单一字符来提供一些缓解 ，并通过字符类里面的 Unicode 属性提供可靠的匹配支持。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_案例学习">13. 案例学习</h2>
<div class="sectionbody">
<div class="paragraph">
<p>前面的章节为您提供了如何知识语法工作, 关于错误报告和数据提取。</p>
</div>
<div class="paragraph">
<p>让我们来看看一些真实世界的输入格式以及我们如何做解析他们。</p>
</div>
<div class="paragraph">
<p>这些案例研究的主要限制是大小:解析语言 像 SQL 一样, 语法非常平易近人, 但由于它是一项重大任务</p>
</div>
<div class="paragraph">
<p>纯粹的语言浩瀚。你可能不会喜欢阅读 40页 关于它。
我们将探索解析三种格式, 重点放在不同的格式上技术。S 表达式是一种简单但相当典型的数据序列化 格式, 具有少量的空白意义。然后, 我们会探索解析数学表达式, 但略有不同方法比前几章的例子。我们使用运算符优先级解析器保持语法平坦。最后, 像 Python 一样 minilanguage 可以教我们如何解析基于缩进的格式。</p>
</div>
<div class="sect2">
<h3 id="_s_表达式">13.1. S 表达式</h3>
<div class="paragraph">
<p>符号表达式, 更好地称为 S 表达式, 是一种表示法 树作为用于 Lisp 编程语言的嵌套列表。在 S-Expressions 中, 列表由括号和 a 中的元素分隔 列表由空格分隔。S 表达式</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(a b (c d))</code></pre>
</div>
</div>
<div class="paragraph">
<p>对应于 Raku 数据结构</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">["a", "b", ["c", "d"]]</code></pre>
</div>
</div>
<div class="paragraph">
<p>列表元素通常称为原子。原子可以是未引用的 标识符, 通常可以包含各种标点符号。例如 (+ 1 2) 是1 + 2 的 Lisp 表达式。您可以引用包含的原子 使用双引号的空格:</p>
</div>
<div class="paragraph">
<p>大型Lisp编程语言中的大多数方言 对程序代码和数据结构都使用 S-Expressions。他们 然而, 在 S-Expression 中确切允许的是什么。一些允许 浮点文字, 以及其他允许的字符不同在标识符内。</p>
</div>
<div class="sect3">
<h4 id="_解析_s_表达式">13.1.1. 解析 S 表达式</h4>
<div class="paragraph">
<p>让我们从解析原子开始吧。原子可以是整数, 如 12345, a 标识符, 如 lisp, 或引用的字符串“像这样”。在可扩展的语法, 这样的替代品清单应该作为原型实施令牌:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar S-Expression {
    proto token atom {*}
    token atom:sym&lt;identifier&gt; {
        &lt;[ a..z A..Z =*: ]&gt;
        &lt;[ a..z A..Z 0..9 _ =*: ]&gt;*
    }
    token atom:sym&lt;integer&gt; { &lt;[+-]&gt;? &lt;[0..9]&gt;+           }
    token atom:sym&lt;string&gt;  { '"' ~ '"' &lt;string_contents&gt; }
    token string_contents   { [ | &lt;-[\\"]&gt;+ | \\ . ]*     }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>匹配潜在的有符号整数非常简单。</p>
</div>
<div class="paragraph">
<p>S-Expression 标识符的难点不在于如何解析它们,  但决定在他们中允许什么。这取决于Lisp方言 解析。在前面的例子中, 第一个字符允许拉丁字母和 符号=, *和:; 任何后续字符也允许数字和下划线。构造为使得整数是明确的解析为这样, 也不能被解析为标识符。</p>
</div>
<div class="paragraph">
<p>此设置不允许单个+或 - 匹配作为标识符, 并且只需将其添加到第一个字符类即可创建 歧义。如果我们想要允许这个, 我们可以单独处理科:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token atom:sym&lt;identifier&gt; {
    | &lt;[ a..z A..Z =*: ]&gt; &lt;[ a..z A..Z 0..9 _ =*: ]&gt;*
    | &lt;[+-]&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>解析字符串遵循前面章节中规定的模式:两个外部引用和中间的字符串内容。字符串此处的内容由单独的规则解析以进行数据提取 更轻松。字符串内容由“常规”允许字符组成 (除反斜杠或双引号外的所有内容)或转义序列: 反斜杠后跟一个任意字符。</p>
</div>
<div class="paragraph">
<p>您可能已经注意到 perl 6 允许您使用连字符 我之前使用过的标识符中的减号字符( - ) 在类名 S-Expression 中, 但不在正则表达式的名称中 string_contents。造成这种不一致的原因是角色存在潜在的歧义:&#8592;alpha-hexdigit&gt; 可能是一个否定的命名字符类 alpha-hexdigit,  或匹配既不是 alpha 也不是 hexdigit 的任何东西。perl 6 消除第一种可能性的歧义, 但避免这种情况 完全看起来仍然值得。</p>
</div>
<div class="paragraph">
<p>既然我们有一些语法规则, 我们应该测试核心功能:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Test;

my %atoms =
    integer    =&gt; ('1', '01234', '-23', '+12'),
    identifier =&gt; ('abc', '=', '*_*'),
    string     =&gt; ('""', '"abc"', Q'"abc\"def"', Q'"\\"'),
    ;

my %not-atoms =
    identifier =&gt; ('', '_'),
    string     =&gt; ('', '"""', Q'"\"',),
    ;

for %atoms.keys.sort -&gt; $atom {
    for %atoms{$atom}.list -&gt; $test {
        ok S-Expression.parse($test,
            rule =&gt; "atom:sym&lt;$atom&gt;";
            "Parsing '$test' as atom $atom";
            ),
    }
}

for %not-atoms.keys.sort -&gt; $atom {
    for %not-atoms{$atom}.list -&gt; $test {
        nok try {S-Expression.parse($test,
            rule =&gt; "atom:sym&lt;$atom&gt;") },
            "Not parsing '$test' as atom $atom";
    }
}
done-testing;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们设置了一些原子应匹配的输入字符串(<code>%atoms</code>)和 一些他们不应该匹配(<code>%not-atoms</code>)。接下来, 我们迭代 这些示例, 并使用示例字符串和调用 <code>S-Expression.parse</code> 相应的规则, 并在对我们的那些字符串的ok调用中包装它 期望被解析, 并为我们期望的字符串nok(否定ok)不配。</p>
</div>
<div class="paragraph">
<p>对于我们期望解析失败的情况, 测试代码会将调用包装起来 <code>try {&#8230;&#8203;}</code> 块中的 <code>S-Expression.parse</code>。这不是绝对必要的,  因为我们没有可能导致错误的高级错误报告被抛出的异常。但是, 这样的事情可能会在以后添加, 并且我们不应该通过导致测试失败来惩罚未来的改进。</p>
</div>
<div class="paragraph">
<p>最后, 而不是使用通常的计划NUMBER; 在开始时, 测试代码使用完成测试; 在末尾。这减少了计算测试的需要 你自己会以降低检测我们是否能够运行的能力为代价我们计划的测试。</p>
</div>
<div class="paragraph">
<p>测试全部通过, 因此我们可以继续更高级别的位。要解析列表, 我们需要一对包含空格分隔列表的括号原子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token expression {
    '(' ~ ')' [&lt;atom&gt;* % \s+]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们也可以处理嵌套列表的情况, 其中 atom 是 a 子列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token atom:sym&lt;expression&gt; { &lt;expression&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后我们指定一个S表达式是一个表达式列表,  可选地在它之间, 之前和之后有空格:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token TOP { \s* [&lt;expression&gt; \s*] * }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是第一次拍摄, 很可能完全不起作用。您可能已经注意到所有正则表达式都是令牌而不是规则。这是因为空白是重要的(它划定原子)并使用规则风险无意中耗尽了这个重要的空白。因此语法错过了应该允许空白的情况, 但什么也没有然后在那里解析它。解决这个问题的一个好方法是编写测试和运行它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @tests = '()', '(abc)', ' (abc) ', '( abc )',
            '(1)', '(+1)', '(-1)', '( () ( ) )';

for @tests -&gt; $t {
    ok S-Expression.parse($t), "can parse '$t'";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这使两个测试失败:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">not ok 20 - can parse '( abc )'
not ok 24 - can parse '( () ( ) )'</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以通过向表达式添加更多的空格分析来解决这个问题 token:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token expression {
    \s* '(' ~ ')' [\s* &lt;atom&gt;* % \s+ \s*]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是完整的 grammar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar S-Expression {
    token TOP                  { \s* [&lt;expression&gt; \s*] *    }
    token expression           {
        \s* '(' ~ ')' [\s* &lt;atom&gt;* % \s+ \s*]
    }
    proto token atom {*}
    token atom:sym&lt;expression&gt; { &lt;expression&gt;                }
    token atom:sym&lt;identifier&gt; {
        &lt;[ a..z A..Z =*:+- ]&gt;
        &lt;[ a..z A..Z 0..9 _ =*:+- ]&gt;*
    }
    token atom:sym&lt;integer&gt;   { &lt;[+-]&gt;? &lt;[0..9]&gt;+            }
    token atom:sym&lt;string&gt;    { '"' ~ '"' &lt;string_contents&gt;  }
    token string_contents     { [ | &lt;-[\\"]&gt;+ | \\ . ]*      }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_数据提取">13.1.2. 数据提取</h4>
<div class="paragraph">
<p>对应于 S 表达式语法的动作类大多是 直截了当。只有两件事与众不同。首先是区分 S 表达式(a)和(“a”)是有用的,  换句话说, 在标识符和带引号的字符串之间。保持这一点 区别, action 类从此类返回一个 Identifier 对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Identifier { has $.str }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可以通过这样的 action 方法来完成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method atom:sym&lt;identifier&gt;($/) {
    make Identifier.new(str =&gt; $/.Str);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要考虑的第二件事是如何处理反斜杠转义引用字符串中的字符。似乎有一致意见 S-Expression 实现 \\ 是一个强烈反对, 而“是一个双重的 引用字符; 然而, 反斜杠的语义依次为另一个不同的角色未达成一致。在这里我们将简单地剥离逃避反斜杠, 所以\\变为\和\ a成为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method string_contents($/) {
    make $/.Str.subst(:global, / \\ (.) /, -&gt; $/ { $0 });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>整数的 action 方法将匹配转换为整数, 和其他方法只是传递其捕获的 <code>.made</code> 值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Identifier { has $.str }

class S-Actions {
    method TOP($/)                  {
        make $&lt;expression&gt;».made;
    }
    method expression($/)           {
        make $&lt;atom&gt;».made;
    }
    method atom:sym&lt;expression&gt;($/) {
        make $&lt;expression&gt;.made;
    }
    method atom:sym&lt;identifier&gt;($/) {
        make Identifier.new(str =&gt; $/.Str);
    }
    method atom:sym&lt;integer&gt;($/)    {
        make $/.Int;
    }
    method atom:sym&lt;string&gt;($/)     {
        make $&lt;string_contents&gt;.made;
    }
    method string_contents($/)      {
        make $/.Str.subst(:global, / \\ (.) /, -&gt; $/ { $0 });
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们给它写一个简短的测试:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $m = S-Expression.parse(
    Q'((a "b") 23 "ab \\cd")',
    actions =&gt; S-Actions.new,
);
ok $m, 'Can parse S-Expression with action method';

is-deeply $m.made,
    [[[Identifier.new(str =&gt; "a"), "b"], 23, "ab \\cd"],],
    "correct data extracted";</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们为此写一个简短的测试:这个测试通过了, 所以是时候把它包装成一个子程序了成为 S-Expression 解析器的公共 API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub parse-s-expression(Str $input) {
    my $m = S-Expression.parse($input,
        actions =&gt; S-Actions.new);
    unless $m {
        die "Cannot parse S-Expression";
    }
    return $m.made;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为简洁起见, 我们不会为此改进错误消息生成 语法; 本章讨论的任何技术11可以在这里使用</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_数学表达式和运算符优先级解析器">13.2. 数学表达式和运算符优先级解析器</h3>
<div class="paragraph">
<p>“如果你拥有的只是一把锤子, 那么一切看起来都像钉子一样<sup class="footnote">[<a id="_footnoteref_67" class="footnote" href="#_footnotedef_67" title="View footnote.">67</a>]</sup>, “如果你合作 一个闪亮的新工具, 如正则表达式和语法, 你往往忽略了选项使用其他工具来解决您的问题。本着这种精神, 我想重温前面的解析示例数学表达式, 这次在语法上做得更少 在随附的代码中。而不是为&#8230;&#8203;引入新的解析级别 每个优先级, 这个语法的迭代忽略优先级 完全简单地解析交替的术语和运算符列表。该 然后, action方法使用运算符优先级表来创建 适当的树。这称为运算符优先级解析器, 也称为运算符优先级解析器 作为OPP的简称。</p>
</div>
<div class="paragraph">
<p>这种方法有两个主要优点。它做得很多更容易在两个现有级别和平面之间插入优先级别语法结构使解析更快。</p>
</div>
<div class="sect3">
<h4 id="_一个简单的算子优先级解析器">13.2.1. 一个简单的算子优先级解析器</h4>
<div class="paragraph">
<p>语法的核心是将表达式解析为列表的部分由中缀运算符分隔的术语<sup class="footnote">[<a id="_footnoteref_68" class="footnote" href="#_footnotedef_68" title="View footnote.">68</a>]</sup>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression { &lt;term&gt; + % &lt;infix&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使中缀运算符列表可扩展, 它必须是 proto 令牌:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto token infix   { * }
token infix:sym&lt;*&gt;  { &lt;sym&gt; }
token infix:sym&lt;/&gt;  { &lt;sym&gt; }
token infix:sym&lt;+&gt;  { &lt;sym&gt; }
token infix:sym&lt;-&gt;  { &lt;sym&gt; }
token infix:sym&lt;**&gt; { &lt;sym&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了四个常用运算符外, 此列表还包括 **, 即 通常用于求幂, 其优先级比乘法。</p>
</div>
<div class="paragraph">
<p>这个术语包含数字并不会让你感到惊讶, 但我们也可以 解析括号中的括号中的子表达式, 以及 cos(0) 等函数调用或 sqrt(4):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto token term { * }
token term:sym&lt;integer&gt; {
    &lt;[+-]&gt;? &lt;[0..9]&gt;+
}
rule term:sym&lt;parenthesized&gt; {
    '(' ~ ')'&lt;expression&gt;
}
rule term:sym&lt;function&gt; {
    &lt;name=.identifier&gt; '(' ~ ')' &lt;expression&gt;
}
token identifier { &lt;[a..z]&gt;+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>是时候将他们合在一块儿了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Grammar::ErrorReporting;

grammar MathExpression does Grammar::ErrorReporting {
    rule TOP { &lt;.ws&gt; &lt;expression&gt; }
    rule expression { &lt;term&gt; + % &lt;infix&gt; }
    proto token infix   { * }
    token infix:sym&lt;*&gt;  { &lt;sym&gt; }
    token infix:sym&lt;/&gt;  { &lt;sym&gt; }
    token infix:sym&lt;+&gt;  { &lt;sym&gt; }
    token infix:sym&lt;-&gt;  { &lt;sym&gt; }
    token infix:sym&lt;**&gt; { &lt;sym&gt; }

    proto token term { * }
    token term:sym&lt;integer&gt; {
        &lt;[+-]&gt;? &lt;[0..9]&gt;+
    }
    rule term:sym&lt;parenthesized&gt; {
        '(' ~ ')' &lt;expression&gt;
    }
    rule term:sym&lt;function&gt; {
        &lt;name=.identifier&gt; '(' ~ ')' &lt;expression&gt;
    }
    token identifier { &lt;[a..z]&gt;+ } }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Grammar::ErrorReporting</code> 是一个提供错误的模块花式位置输出的方法, 但也安装 <code>FAILGOAL</code> 方法 当 <code>~</code> 表达式无法找到目标时触发。如果你使用 <code>moritzlenz/raku-regex-alpine</code> Docker 镜像, 这个模块已经存在包括在内。否则, 您可以通过运行来安装它</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">zef install Grammar::ErrorReporting</code></pre>
</div>
</div>
<div class="paragraph">
<p>在命令行上。</p>
</div>
<div class="paragraph">
<p>这个语法现在生成一个平面分析树。例如, 输入字符串 <code>1 + 2 * 5</code> 生成以下匹配对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">⌜1 + 2 * 5⌟
 expression =&gt; ⌜1 + 2 * 5⌟
  term =&gt; ⌜1⌟
   infix =&gt; ⌜+⌟
    sym =&gt; ⌜+⌟
   term =&gt; ⌜2⌟
   infix =&gt; ⌜*⌟
    sym =&gt; ⌜*⌟
   term =&gt; ⌜5⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们需要编写运算符优先级解析器来转换 平面数组 <code>[1, '+', 2, '*', 5]</code> 分为按优先级分组的树, 所以 <code>[1, '+', [2, '\*', 5]</code>, 甚至更好 <code>['+', 1, ['*', 2, 5]]</code>。</p>
</div>
<div class="paragraph">
<p>关键是每当我们第一次看到一个操作员时,  我们不知道它的相邻操作数是否实际属于该运算符 (如2 * 5的情况), 或者下一个运算符有更高的值 优先并窃取正确的操作数。</p>
</div>
<div class="paragraph">
<p>我们可以通过首先放置一个运算符及其左操作数来解决这个问题在堆栈上。当我们访问下一个运营商和第二个运营商时优先级低于第一个优先级, 我们可以删除之前的优先级运算符及其操作数来自堆栈, 将其转换为表达式, 以及然后继续将第二个操作符放在堆栈上。如果是第二个运算符具有更高的优先级, 我们只需将第二个运算符放在上面堆。</p>
</div>
<div class="paragraph">
<p>一旦到达输入列表的末尾, 我们就可以应用缩减步骤直到堆栈上只剩下一个元素。这就是算法在代码中看起来像:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class MathActions {
    method opp-parse(@tokens) {
        sub opp-reduce(@stack) {
            my ($term1, $op, $term2) = @stack.splice(*-3, 3);
            @stack.push([$op, $term1, $term2]);
        }

        my %prec = '+' =&gt; 1, '-' =&gt; 1,
                   '*' =&gt; 2, '/' =&gt; 2,
                   '**' =&gt; 3;

        my @stack = @tokens[0];
        for @tokens[1..*] -&gt; $op, $term {
            while @stack &gt; 2
                    &amp;&amp; %prec{$op} &lt;= %prec{@stack[*-2]} {
                opp-reduce(@stack);
            }
            @stack.push($op, $term);
        }
        opp-reduce(@stack) while @stack &gt; 1;
        return @stack[0];
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>方法 opp-parse 期望一个令牌列表, 从一个术语开始, 然后中缀运算符, 依此类推, 其他每个令牌都是运算符。</p>
</div>
<div class="paragraph">
<p>第一个元素是一个子程序 opp-reduce, 它实现了 减少步骤: 取最后两个术语和它们之间的运算符 从堆栈中, 并将它们作为数组添加回来。因此, 如果堆栈有 元素 <code>1, '+', 2, '*', 4</code>, 对此函数的调用将其修改为 <code>[1, '+', ['\*', 2, 4]]</code>, 第二个调用进一步将其更改为 <code>['+', 1, ['*', 2, 4]]</code>。 <code>%prec</code> 是将每个中缀运算符映射到数字的哈希优先级, 其中较高的数字对应于运算符绑定他们的论点更紧密。</p>
</div>
<div class="paragraph">
<p>随后, <code>@stack</code> 初始化为第一个术语(来自@)令牌[0]), 然后循环遍历其余的令牌元素一次。只要堆栈至少有三个元素(和 因此, 至少一个运营商), 并且当前运营商具有较低的优先权 与前一个运算符相比, 代码调用了opp-reduce 函数。在任何 case, 当前运算符和 term 被添加到堆栈中。</p>
</div>
<div class="paragraph">
<p>在访问了所有初始令牌之后, 剩下要做的就是重复减少步骤, 直到堆栈上只剩下一个元素。这就是我们感兴趣的解析树。</p>
</div>
<div class="paragraph">
<p>请注意, 通过在令牌术语中解析带括号的表达式, 我们不会必须在运算符优先级中将括号作为运算符处理解析器。更传统的实现只使用词法分析和运算符优先级解析器, 用于检查和处理括号对。其余的动作方法非常简单</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method TOP($/) { make $&lt;expression&gt;.made }
method expression($/) {
    my @tokens = $/.caps.map({.value.made});
    make self.opp-parse(@tokens);
}
method infix:sym&lt;*&gt;($/)  { make ~$&lt;sym&gt; }
method infix:sym&lt;/&gt;($/)  { make ~$&lt;sym&gt; }
method infix:sym&lt;+&gt;($/)  { make ~$&lt;sym&gt; }
method infix:sym&lt;-&gt;($/)  { make ~$&lt;sym&gt; }
method infix:sym&lt;**&gt;($/) { make ~$&lt;sym&gt; }

method term:sym&lt;integer&gt;($/) { make $/.Int }
method term:sym&lt;parenthesized&gt;($/) {
    make $&lt;expression&gt;.made;
}
method term:sym&lt;function&gt;($/) {
    make [$&lt;name&gt;.made, $&lt;expression&gt;.made];
}
method identifier($/) { make $/.Str }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里唯一有趣的地方是表达式方法。要知道, 方法 <code>opp-parse</code> 希望项与运算符交错, 但规则 <strong>expression</strong> 的匹配会产生两个数组, <code>$&lt;term&gt;</code> 和 <code>$&lt;infix&gt;</code>。我们可以自己进行交织, 但 Raku 提供了一个更好的解决方案：<a href="https://docs.raku.org/type/Match.html%23method_caps">Match 类中的方法 caps</a><sup class="footnote">[<a id="_footnoteref_69" class="footnote" href="#_footnotedef_69" title="View footnote.">69</a>]</sup>, 按照字符串中出现的顺序返回所有的 captures, 这正是我们想要的交织顺序。该方法的 caps 返回的是被封装在 <a href="https://docs.raku.org/type/Pair">Pair</a><sup class="footnote">[<a id="_footnoteref_70" class="footnote" href="#_footnotedef_70" title="View footnote.">70</a>]</sup> 对象中的捕获, 所以我们需要调用 <code>.value</code> 来到达 match 对象, 然后调用 <code>.made</code> 来访问附加在 match 上的抽象语法树 (AST) 。<code>map</code> 方法对 <code>caps</code> 返回的所有元素都是这样做的。</p>
</div>
<div class="paragraph">
<p>同样的, 我们可以把对语法的调用封装成一个子例程。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub parse-math-expression(Str $input) {
    my $match = MathExpression.parse($input,
        actions =&gt; MathActions.new);
    die "Cannot parse input" unless $match;
    return $match.made;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并写一些测试。这里只是一个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Test;
plan 1;

is-deeply parse-math-expression('1 + 2 * 3**4 * 5 + 6'),
    ["+", ["+", 1, ["*", ["*", 2, ["**", 3, 4]], 5]], 6],
    'correct parse tree from nested expression';</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_更灵活的方法">13.2.2. 更灵活的方法</h4>
<div class="paragraph">
<p>上一节中讨论的语法和运算符优先级解析器可以工作，但运算符优先级解析器的可扩展性不强。你可以很容易地应用一个角色，增加另一个 <code>infix:sym&lt;something&gt;</code> 规则，但你不能为它定义一个优先级，因为 <code>%prec</code> 是一个词法变量，不能在 <code>opp-parse</code> 之外访问。</p>
</div>
<div class="paragraph">
<p>一个可能的解决方法是创建一些注册表，通过这些注册表，扩展可以添加一个操作符，但问题就更深了。有几个用例，我们需要更多关于操作符的元数据。其中一个例子是，如果解析器能够处理不同的关联性。如果一个运算符出现了两次或更多（或不同的运算符出现在同一个表达式中出现了相同的前缀），那么表达式 <strong>1 OP 2 OP 3</strong> 可以被解释为 <strong>(1 OP 2) OP 3</strong> (左联动)或 <strong>1 OP (2 OP 3)</strong> (右联动)。对于求和+和乘法*运算符，优先级并不重要。对于差分-和除法/，典型的联想性是左联想，但对于指数运算，大多数编程语言都假定是右联想。我们需要一种方法来存储运算符的联想性和优先级。</p>
</div>
<div class="paragraph">
<p>还有其他类型的运算符。后缀运算符是出现在项的后面(post)。例如，阶乘运算符(!)代表所有正整数的乘积，直到并包括它后面的数。举例说明： 6! 是 <code>6*5*4*3*2*1</code> 或 720。现在我们需要关于运算符类型的元信息，由于后缀运算符打破了关于交替项和运算符的规则<sup class="footnote">[<a id="_footnoteref_71" class="footnote" href="#_footnotedef_71" title="View footnote.">71</a>]</sup>，所以运算符优先级解析器也需要一种方法来可靠地区分运算符和运算符。</p>
</div>
<div class="paragraph">
<p>为了解决这些困难，常用的方法是收集所有的的运算符信息，将运算符的信息转化为对象。然后，算子优先级解析器可以做一个类型检查，看看某事是否是一个算子，然后询问它的优先级、关联性和类型（infix、postfix、前缀）。更重要的是，不需要再有一个中心位置来存储所有类型。当你为语法创建一个扩展角色时，你也为动作类创建了一个扩展角色，而动作类又反过来为新引入的操作符返回一个对象。</p>
</div>
<div class="paragraph">
<p>最小化的方法（还没有处理关联性或其他类型的操作符）是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Operator {
    has Str $.symbol is required;
    has Numeric $.precedence is required;
    method new(Str $symbol, Numeric $precedence) {
        self.bless(:$symbol, :$precedence);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后, 运算符的操作方法返回 Operator 对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method infix:sym&lt;+&gt;($/)  { make Operator.new(~$&lt;sym&gt;, 1) }
method infix:sym&lt;*&gt;($/)  { make Operator.new(~$&lt;sym&gt;, 2) }
method infix:sym&lt;**&gt;($/) { make Operator.new(~$&lt;sym&gt;, 3) }
# more action methods go here</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 方法可以将操作符作为对象访问
因此可以直接使用它们的优先级进行比较:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @tokens[1..*] -&gt; $op, $term {
    opp-reduce(@stack)
        while @stack &gt;= 3
           &amp;&amp; $op.precedence &lt;= @stack[*-2].precedence;
    @stack.push($op, $term);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>比较 <code>$op.precedence &#8656; @stack[\*-2].precedence</code> 是 对于左关联运算符; 当你改变小于或等于 (&#8656;) 严格小于 (&lt;), 你得到右关联的行为运营商。如果您想更多地探索运算符优先级解析器,  你可以为类Operator添加一个关联属性, 给出取幂运算符权限优先, 并更改比较把关联性考虑在内。表达式 <code>2 <strong> 3 </strong> 4</code> 应该出来是 <code>['<strong>'2, ['</strong>', 3,4]]</code>。如果您觉得真的很冒险, 那么甚至可能尝试将后缀运算符添加到语法和运算符中优先解析器。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pythonesque_基于缩进的语言">13.3. Pythonesque, 基于缩进的语言</h3>
<div class="paragraph">
<p>Python, YAML, CoffeeScript 以及其他编程语言和数据 格式使用缩进来编码程序或数据的结构。 例如, 这个 Raku 程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 1 &lt; 2 {
    say "Inside the branch";
}
say "outside the branch";</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Python 3 中看起来像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 1 &lt; 2:
    print("Inside the branch")
print("outside the branch")</code></pre>
</div>
</div>
<div class="paragraph">
<p>在以冒号(:)结尾的行之后, 下一行必须更多缩进比前一个缩进。所有其他共享相同的行缩进作为第二行属于块。如果一条线路较少前导空格比前一个块, 这完成了所有打开的块更多领先的空间。</p>
</div>
<div class="paragraph">
<p>Python 或 YAML 的完整语法太多了, 无法适应这一点 因此, 让我们探讨解析基于缩进的背后的概念没有大多数无关复杂性的语言。</p>
</div>
<div class="paragraph">
<p>我们将在这里解析的语言是 Python 的一小部分, 我已经将它命名为 Pythonesque。它由包含数字的表达式组成,  变量, 常见的中缀运算符, 以及 if 语句缩进的身体。if 语句可以嵌套。</p>
</div>
<div class="paragraph">
<p>以下代码是一个小的示例程序 Pythonesque:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">a= 1
if a:
    x= 1
    y= 2
    if x + 1 &lt; 3:
        z=x+ y
    a=z* 4
b= 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>顶级开始时为零缩进, 即第一个缩进级别使用至少一个空格(此处为四个), 第二个级别必须更远缩进而不是第二个(这里是十个空格)。</p>
</div>
<div class="sect3">
<h4 id="_pythonesque_的语法">13.3.1. Pythonesque 的语法</h4>
<div class="paragraph">
<p>我们将保持表达式解析非常简约:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Pythonesque {
    token ws { \h* }
    rule expression  { &lt;term&gt; + % &lt;operator&gt;  }
    token term       { &lt;identifier&gt; | &lt;number&gt;}
    token number     { \d+                    }
    token identifier { &lt;:alpha&gt; \w*           }
    token operator   {
         &lt;[-+=&lt;&gt;*/,]&gt;| '==' | '&lt;=' | '&gt;=' | '!='
    }
    # more rules go here later
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在现实世界的用例中, 我们可能会使用 proto 令牌来表示这两个术语和运营商; 这里我们只使用最小值来解析表达式。 如果要强制运算符优先级, 可以使用运算符来自前一个案例研究的优先解析器。由于空间在 Pythonesque 中很重要, 所以 ws 只匹配水平空间(我们允许在令牌之间;即, 你可以写一个 =1 作为 a = 1)。然而, 我们只有在确保这一点时才能这样做一行开头的空格由不同的规则匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token line {
    ^^ ( \h* ) { self.handle_indentation($0) }
    &lt;statement&gt; $$ \n*
}
proto token statement { * }
token statement:sym&lt;expression&gt; {
    &lt;expression&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的核心概念是输入线由前导组成 缩进(长度可能为零, 因此为 <code>\h*</code>), 然后是声明, 最后是行尾 <code>$$</code> 后跟一个或多个换行符字符。请注意, 必须检查前导空格的数量。 如果它与前一行相同, 一切都很好。如果它与缩进匹配 在外部范围内, 必须完成内部范围。如果它不匹配这些, 我们发现了一个错误。要做那个检查, 我们需要一个当前的数组活动(尚未完成)缩进级别:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token TOP {
    :my @*INDENTATION = (0,);
    &lt;line&gt;*
    $
}
method handle_indentation($match) {
    my $current = $match.Str.chars;
    my $last = @*INDENTATION[*-1];
    if $current &gt; $last {
        die "Inconsistent indentation: expected "
          ~ "at most $last, got $current spaces";
    }
    elsif $current &lt; $last {
        my $idx = @*INDENTATION.first(:k, $current);
        if defined $idx {
            for $idx + 1 .. @*INDENTATION.end {
                @*INDENTATION.pop;
            }
        }
        else {
            die "Unexpected indentation level: $current.";
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Token TOP 用零作为初始化动态变量 <code>@*INDENTATION</code> 它的第一个元素。下一步, 我们将实现添加元素 数组的结尾, 但是现在我们假设它包含了数字每个缩进级别的空格。当我们解析这个输入时:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">if a:
    x= 1
    if x + 1 &lt; 3:
        z=x+ y</code></pre>
</div>
</div>
<div class="paragraph">
<p>数组 <code>@*INDENTATION</code> 包含数字 0, 4 和 10。如果是当前数字 缩进是十个空格(由 <code>$match.Str.chars</code> 确定;更多 复杂的分析可能会对标签的重量不同于空格, 或者禁止混合标签和空格), 没有任何反应。如果目前还有更多前导空格, 这必定是一个错误, 因为增加的缩进是只有在 if 语句后才允许。</p>
</div>
<div class="paragraph">
<p>如果当前缩进级别小于记录的最后一个级别 <code>@*INDENTATION</code>, 我们必须在 <code>@*INDENTATION</code> 中搜索当前值。 这就是我的 <code>$idx = @*INDENTATION.first(:k, $current);</code> 确实。该方法 <a href="https://docs.raku.org/type/List%23routine_first">first</a><sup class="footnote">[<a id="_footnoteref_72" class="footnote" href="#_footnotedef_72" title="View footnote.">72</a>]</sup> 搜索与某个匹配的第一个数组元素标准, 这里等于 <code>$current</code>。使用 <code>:k</code> 修饰符, 它返回该数组元素的索引。如果没有找到, 则会出现未定义的值返回, <code>if defined $idx</code> check 触发器, 抛出异常。 如果找到, 则当前缩进是先前作用域的缩进。我们然后需要关闭所有更深入缩进的内部范围, 这就是什么 <code>@*INDENTATION.pop</code> 适用于每个此类范围。</p>
</div>
<div class="paragraph">
<p>当我们解析 if 语句时, 我们知道它之后的行必须 有比当前行更多的缩进, 但还没有多少。 我们可以通过设置第二个变量或推送特殊变量来表示 值得注意这个事实的 <code>@*INDENTATION</code>。这个<a href="https://en.wikipedia.org/wiki/Sentinel_value">哨兵值</a><sup class="footnote">[<a id="_footnoteref_73" class="footnote" href="#_footnotedef_73" title="View footnote.">73</a>]</sup>可以是一个不是有效缩进的值(如 -1 或 0.5), 或单独的类型:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Pythonesque {
my class NEW_INDENTATION { }
rule statement:sym&lt;if&gt; {
        'if'  &lt;expression&gt; ':'
        { @*INDENTATION.push(NEW_INDENTATION) }
    }
    # rest of the grammar here
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们必须在方法中处理 NEW_INDENTATION 的情况</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">handle_indentation:

method handle_indentation($match) {
    my $current = $match.Str.chars;
    my $last = @*INDENTATION[*-1];
    if $last ~~ NEW_INDENTATION {
        my $before = @*INDENTATION[*-2];
        if $current &gt; $before {
            @*INDENTATION[*-1] = $current;
        }
        else {
            die "Inconsistent indentation: expected "
              ~ "more than $before, got $current spaces";
        }
    }
    elsif $current &gt; $last {
        die "Inconsistent indentation: expected "
          ~ "at most $last, got $current spaces";
    }
    # rest of the method as before
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这标志着我们的语法可以成功解析的地步在该部分开头给出的例子, 同样重要的是拒绝包含无效缩进的示例。</p>
</div>
<div class="paragraph">
<p>但是, 如果您尝试为此语法编写操作方法, 那么您将会这样做很快就会注意到这是不合理的, 因为语法解析的范围开始或结束时不进行通信。就这样动作方法需要查看一开始时的空白量行, 然后使用 <code>@*INDENTATION</code>(或维护自己的版本) 重建当前和外部范围的图片。这是个不幸的重复劳动和相当多的耦合对语法内部的动作方法。</p>
</div>
<div class="paragraph">
<p>一个更清洁的解决方案是提供某种指示的API 语法进入或离开范围时的动作对象。一个很好的技巧 这是调用始终匹配零个字符作为一种标记的规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token enter_scope { &lt;?&gt; }
token leave_scope { &lt;?&gt; }
token TOP {
    :my @*INDENTATION = (0,);
    &lt;.enter_scope&gt;
    &lt;line&gt;*
    $
    &lt;.leave_scope&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>令牌中的 construst&lt;?&gt;是 enter_scope 和 leave_scope 的一个空零宽度断言, 总是成功匹配空串。</p>
</div>
<div class="paragraph">
<p>除了来自令牌TOP的调用之外, 我们还需要插入对self的调用。 <code>enter_scope()</code> 进入方法 <code>handle_indentation</code>, 遇到它 NEW_INDENTATION sentinel, 并在添加调用 <code>self.leave_scope()</code> 时 范围已完成, 因此伴随着 <code>@*INDENTATION</code> 的行。<code>pop()</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method handle_indentation($match) {
    my $current = $match.Str.chars;
    my $last = @*INDENTATION[*-1];
    if $last ~~ NEW_INDENTATION {
        my $before = @*INDENTATION[*-2];
        if $current &gt; $before {
            @*INDENTATION[*-1] = $current;
            self.enter_scope();
        } ...

       elsif $current &lt; $last {
           my $idx = @*INDENTATION.first(:k, $current);
           if defined $idx {
               for $idx + 1 .. @*INDENTATION.end {
                   @*INDENTATION.pop;
                   self.leave_scope();
                }
            }
        ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 操作对象有一个可以挂钩的地方, 允许它们通过合理的努力处理语句的嵌套。</p>
</div>
</div>
<div class="sect3">
<h4 id="_action_对象_2">13.3.2. Action 对象</h4>
<div class="paragraph">
<p>当我第一次为 Pythonesque 编写动作对象时, 我做了一切 array: if 语句是一个数组, 其第一个元素是字符串 “如果”, 第二个是条件, 第三个是身体 if语句。表达式也是数组, 所以第二个元素是 也是一个数组。我很快忘记了生成的 AST。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题, 我把表达式保存为数组, 但移动了运算符,  变量和if语句分成不同的类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Operator {
    has Str $.action is required;
}
class Variable {
    has Str $.name is required;
}
class If {
    has $.condition;
    has @.block;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>完成此设置后, 简单语句的操作方法就是不是很奇怪:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Pythonesque::Actions {
    # more methods go here
    method statement:sym&lt;if&gt;($/) {
        make If.new(condition =&gt; $&lt;expression&gt;.made);
    }
    method statement:sym&lt;expression&gt;($/) {
        make $&lt;expression&gt;.made;
    }
    method expression($/) { make $/.caps».value».made.Array }
    method identifier($/) { make Variable.new(name =&gt; $/.Str) }
    method term($/)       { make $/.caps[0].value.made; }
    method number($/)     { make $/.Int }
    method operator($/)   { make Operator.new(action =&gt; $/.Str) }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意方法语句中的If-object如何: sym&lt;if&gt;被初始化它的状况, 但不是它的身体。这是因为它尚未解析在声明时:sym&lt;if&gt;运行。为了正确嵌套语句, 我们需要维护一堆范围。底部元素(或索引0, 当实现为数组时) 是最外面的范围, 顶部元素(或索引* -1)对应于 目前的范围。当我们离开一个范围时(除了最外面的范围, 也称为 “mainline”), 它属于一个if语句, if 语句是最后一个 已在下一个最外层范围内解析的语句。所以我们需要 删除堆栈的当前范围并将其设置为堆栈的主体如果声明:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Pythonesque::Actions {
    has @.scopes;
    method TOP($/) {
        make @.scopes[0];
    }
    method line($/) {
        @.scopes[*-1].push($&lt;statement&gt;.made)
    }
    method enter_scope($/) { @.scopes.push([]) }
    method leave_scope($/) {
        if @.scopes &gt; 1 {
            my $last = @.scopes.pop;
            @.scopes[*-1][*-1].block = $last.list;
       }
    }
    # rest of the class goes here as before
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用各种示例字符串对此进行测试表明这主要起作用,  但在一个有趣的角落案例中失败:如果输入的最后一行至少有 两个级别的缩进, 只有第一级缩进存在于 AST。例如, 这个输入:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">if 1:
    if 2:
        x= 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生这个 AST:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[If.new(condition =&gt; [1], block =&gt; [])</code></pre>
</div>
</div>
<div class="paragraph">
<p>缺少第二个 if 语句及其正文。自从身体 如果在 leave_scope 调用中填充了 If-objects, 那么它就是理所当然的不调用 leave_scope。将 debug say 语句添加到操作中 方法 enter_scope 和 leave_scope 确认:对于显示的输入 之前, enter_scope 被调用三次(主线一次, 一次 对于每个内部范围), 但只调用一次 leave_scope。</p>
</div>
<div class="paragraph">
<p>leave_scope 可以从两个地方调用:来自令牌TOP(其中 工作), 并从方法 handle_indentation。这使得错误更清楚: handle_indentation 只调用 leave_scope 使用小于当前的缩进调用 handle_indentation 水平。但是, 当最后没有解析未缩进的行时, 没有这样的调用 handle_indentation 发生了。我们可以通过插入这样一个来解决这个问题最后人为地打电话:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token TOP {
    :my @*INDENTATION = (0,);
    &lt;.enter_scope&gt;
    &lt;line&gt;*
    $

    # leave all open scopes:
    { self.handle_indentation('') }
    &lt;.leave_scope&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这个修复程序, 所有测试都通过了, 我们可以考虑这个试验成功。
您可以查看完整的代码, 包括测试(以及一些小的 增强功能, 可以更轻松地测试错误条件) <a href="https://github.com/apress/perl-6-regexes-and-grammars/blob/master/chapter-13-case-studies/pythonesque.p6">GitHub</a><sup class="footnote">[<a id="_footnoteref_74" class="footnote" href="#_footnotedef_74" title="View footnote.">74</a>]</sup>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_12">13.4. 总结</h3>
<div class="paragraph">
<p>本章向您展示了使用的真实解析器的元素处理现实世界的数据:递归, 运算符优先级解析器和基于缩进级别解析结构。最后一个例子也是在正则表达式和代码之间的相互作用中展示了权衡。</p>
</div>
<div class="paragraph">
<p>在本书的整个过程中, 您已经了解了基础知识关于 Raku, Raku 正则表达式的构建块, 如何使用 regex 和 Raku 代码交互和捕获, 提供从中提取信息的方法正则表达式匹配。</p>
</div>
<div class="paragraph">
<p>关于正则表达式力学和技术的章节给了你了解正则表达式如何工作以及如何使用的背景知识它们用于解析常见的数据格式。语法允许你构造并重用正则表达式。动作对象机制便于访问得到的匹配, 以及关于错误报告的讨论比赛失败时该怎么办。武装与前几章的背景, 以及 本章的应用程序, 你应该能够自己编写 语法和解析器。我会留下 Larry Wall 的一句话,  Perl 创造者和 Raku 的发明者:拥有适当的乐趣!</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. <a href="https://en.wikipedia.org/wiki/Regular_language" class="bare">https://en.wikipedia.org/wiki/Regular_language</a>
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. <a href="https://en.wikipedia.org/wiki/Kleene_star" class="bare">https://en.wikipedia.org/wiki/Kleene_star</a>
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. 其他编程语言用 "Traits" 一词来表示 Raku 中角色的概念。
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. <a href="https://github.com/ugexe/zef" class="bare">https://github.com/ugexe/zef</a>
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. <a href="https://github.com/nxadm/rakudo-pkg/releases" class="bare">https://github.com/nxadm/rakudo-pkg/releases</a>
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. <a href="https://raku.org/community/" class="bare">https://raku.org/community/</a>
</div>
<div class="footnote" id="_footnotedef_7">
<a href="#_footnoteref_7">7</a>. Raku 希望你的程序文件是 UTF-8 编码的。
</div>
<div class="footnote" id="_footnotedef_8">
<a href="#_footnoteref_8">8</a>. www.apress.com/us/book/9781484228982
</div>
<div class="footnote" id="_footnotedef_9">
<a href="#_footnoteref_9">9</a>. www.packtpub.com/application-development/perl-6-deep-dive
</div>
<div class="footnote" id="_footnotedef_10">
<a href="#_footnoteref_10">10</a>. <a href="https://docs.raku.org/type/Int#routine_chr" class="bare">https://docs.raku.org/type/Int#routine_chr</a>
</div>
<div class="footnote" id="_footnotedef_11">
<a href="#_footnoteref_11">11</a>. <a href="https://docs.raku.org/type/Str#sub_sprintf" class="bare">https://docs.raku.org/type/Str#sub_sprintf</a>
</div>
<div class="footnote" id="_footnotedef_12">
<a href="#_footnoteref_12">12</a>. <a href="https://docs.raku.org/type/Cool#method_uniname" class="bare">https://docs.raku.org/type/Cool#method_uniname</a>
</div>
<div class="footnote" id="_footnotedef_13">
<a href="#_footnoteref_13">13</a>. <a href="http://unicode.org/reports/tr23/" class="bare">http://unicode.org/reports/tr23/</a>
</div>
<div class="footnote" id="_footnotedef_14">
<a href="#_footnoteref_14">14</a>. 严格来说, 锚点也是零宽断言, 既可以向前查看, 也可以向后查看。
</div>
<div class="footnote" id="_footnotedef_15">
<a href="#_footnoteref_15">15</a>. 如果这些对你来说没有意义, 不要担心；在后面的章节中讨论了匹配对象和正则表达式技术性细节之后, 就会比较清楚了。
</div>
<div class="footnote" id="_footnotedef_16">
<a href="#_footnoteref_16">16</a>. 应该是没有这个必要。但还是要说, 有这个能力就更好了。
</div>
<div class="footnote" id="_footnotedef_17">
<a href="#_footnoteref_17">17</a>. <a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>
</div>
<div class="footnote" id="_footnotedef_18">
<a href="#_footnoteref_18">18</a>. <a href="https://docs.raku.org/type/Str#method_match" class="bare">https://docs.raku.org/type/Str#method_match</a>
</div>
<div class="footnote" id="_footnotedef_19">
<a href="#_footnoteref_19">19</a>. 实际上他们就是
</div>
<div class="footnote" id="_footnotedef_20">
<a href="#_footnoteref_20">20</a>. 从技术上讲, 还有<a href="http://unicode.org/faq/casemap_charprop.html%234">标题大小写</a>, 在标题中, 每个字的第一个字母的大写时, 比如在标题中, 也有特殊规定。修饰符 :ignorecase 也可以使用标题大小写。
</div>
<div class="footnote" id="_footnotedef_21">
<a href="#_footnoteref_21">21</a>. <a href="https://docs.raku.org/type/Str#routine_substr" class="bare">https://docs.raku.org/type/Str#routine_substr</a>
</div>
<div class="footnote" id="_footnotedef_22">
<a href="#_footnoteref_22">22</a>. <a href="https://docs.raku.org/type/Str#routine_comb" class="bare">https://docs.raku.org/type/Str#routine_comb</a>
</div>
<div class="footnote" id="_footnotedef_23">
<a href="#_footnoteref_23">23</a>. <a href="https://docs.raku.org/type/Str#routine_split" class="bare">https://docs.raku.org/type/Str#routine_split</a>
</div>
<div class="footnote" id="_footnotedef_24">
<a href="#_footnoteref_24">24</a>. <a href="https://docs.raku.org/type/Str#method_subst" class="bare">https://docs.raku.org/type/Str#method_subst</a>
</div>
<div class="footnote" id="_footnotedef_25">
<a href="#_footnoteref_25">25</a>. 或者至少它试图以不同的方式进行匹配; 详情见第六章中关于回溯的讨论。
</div>
<div class="footnote" id="_footnotedef_26">
<a href="#_footnoteref_26">26</a>. <a href="https://docs.raku.org/type/Match.html" class="bare">https://docs.raku.org/type/Match.html</a>
</div>
<div class="footnote" id="_footnotedef_27">
<a href="#_footnoteref_27">27</a>. <a href="https://docs.raku.org/type/Array" class="bare">https://docs.raku.org/type/Array</a>
</div>
<div class="footnote" id="_footnotedef_28">
<a href="#_footnoteref_28">28</a>. Raku 的早期版本为所有量词化的捕获创建了一个数组捕获, 即使是使用了 ? 量词符。这让大多数用户感到困惑。
</div>
<div class="footnote" id="_footnotedef_29">
<a href="#_footnoteref_29">29</a>. 这个素数测试通常归功于 Abigail, 一个多产的 Perl 黑客。例如参见 <a href="http://neilk.net/blog/2000/06/01/abigails-regex-to-test-for-prime-numbers/。" class="bare">http://neilk.net/blog/2000/06/01/abigails-regex-to-test-for-prime-numbers/。</a>
</div>
<div class="footnote" id="_footnotedef_30">
<a href="#_footnoteref_30">30</a>. 有限状态机形式假定你总是想匹配整个字符串, 因此使用了锚点。如果你只想在一个字符串中搜索, 你必须在 regex 后面加上 <code>.*</code>。
</div>
<div class="footnote" id="_footnotedef_31">
<a href="#_footnoteref_31">31</a>. <a href="https://en.wikipedia.org/wiki/Powerset_construction" class="bare">https://en.wikipedia.org/wiki/Powerset_construction</a>
</div>
<div class="footnote" id="_footnotedef_32">
<a href="#_footnoteref_32">32</a>. 对于贪婪或节俭的量词，它试图匹配它能匹配的最短的子串。
</div>
<div class="footnote" id="_footnotedef_33">
<a href="#_footnoteref_33">33</a>. <a href="http://www.regexguru.com/2008/04/unintended-backtracking-can-bite-you/" class="bare">http://www.regexguru.com/2008/04/unintended-backtracking-can-bite-you/</a>
</div>
<div class="footnote" id="_footnotedef_34">
<a href="#_footnoteref_34">34</a>. <a href="http://json.org/" class="bare">http://json.org/</a>
</div>
<div class="footnote" id="_footnotedef_35">
<a href="#_footnoteref_35">35</a>. <a href="https://en.wikipedia.org/wiki/INI_file#Example" class="bare">https://en.wikipedia.org/wiki/INI_file#Example</a>
</div>
<div class="footnote" id="_footnotedef_36">
<a href="#_footnoteref_36">36</a>. <a href="https://docs.perl6.org/language/testing" class="bare">https://docs.perl6.org/language/testing</a>
</div>
<div class="footnote" id="_footnotedef_37">
<a href="#_footnoteref_37">37</a>. <a href="https://testanything.org/" class="bare">https://testanything.org/</a>
</div>
<div class="footnote" id="_footnotedef_38">
<a href="#_footnoteref_38">38</a>. Raku 有一个名为 <code>byte</code> 的内置类型, 所以如果省略了 <code>&amp;</code> 符号, 你会不小心引用这个类型。
</div>
<div class="footnote" id="_footnotedef_39">
<a href="#_footnoteref_39">39</a>. 在 Python 中, 这个问题就更复杂了, 因为行的开头的空格是重要的, 除非是在表达式里面。
</div>
<div class="footnote" id="_footnotedef_40">
<a href="#_footnoteref_40">40</a>. <code>&lt;!ww&gt;</code> 匹配除了单词内之外的任何地方
</div>
<div class="footnote" id="_footnotedef_41">
<a href="#_footnoteref_41">41</a>. 记住, <code>&lt;.ws&gt;</code> 中的前导点会导致 regex 不被捕获。因为 <code>ws</code> 例程都是关于我们并不特别在意的空白, 不捕捉它的匹配是有意义的。
</div>
<div class="footnote" id="_footnotedef_42">
<a href="#_footnoteref_42">42</a>. <a href="https://docs.raku.org/type/Grammar" class="bare">https://docs.raku.org/type/Grammar</a>
</div>
<div class="footnote" id="_footnotedef_43">
<a href="#_footnoteref_43">43</a>. <a href="https://en.wikipedia.org/wiki/SQL" class="bare">https://en.wikipedia.org/wiki/SQL</a>
</div>
<div class="footnote" id="_footnotedef_44">
<a href="#_footnoteref_44">44</a>. <a href="http://json.org/" class="bare">http://json.org/</a>
</div>
<div class="footnote" id="_footnotedef_45">
<a href="#_footnoteref_45">45</a>. <a href="https://github.com/moritz/json/" class="bare">https://github.com/moritz/json/</a>
</div>
<div class="footnote" id="_footnotedef_46">
<a href="#_footnoteref_46">46</a>. <a href="https://github.com/moritz/json/blob/master/lib/JSON/Tiny/Grammar.pm" class="bare">https://github.com/moritz/json/blob/master/lib/JSON/Tiny/Grammar.pm</a>
</div>
<div class="footnote" id="_footnotedef_47">
<a href="#_footnoteref_47">47</a>. 就像瑞士军刀，但威力更大。
</div>
<div class="footnote" id="_footnotedef_48">
<a href="#_footnoteref_48">48</a>. <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser" class="bare">https://en.wikipedia.org/wiki/Recursive_descent_parser</a>
</div>
<div class="footnote" id="_footnotedef_49">
<a href="#_footnoteref_49">49</a>. <a href="https://en.wikipedia.org/wiki/Operator-precedence_parser" class="bare">https://en.wikipedia.org/wiki/Operator-precedence_parser</a>
</div>
<div class="footnote" id="_footnotedef_50">
<a href="#_footnoteref_50">50</a>. <a href="https://github.com/ugexe/zef" class="bare">https://github.com/ugexe/zef</a>
</div>
<div class="footnote" id="_footnotedef_51">
<a href="#_footnoteref_51">51</a>. <a href="https://github.com/tadzik/perl6-Config-INI" class="bare">https://github.com/tadzik/perl6-Config-INI</a>
</div>
<div class="footnote" id="_footnotedef_52">
<a href="#_footnoteref_52">52</a>. <a href="https://github.com/tadzik/perl6-Config-INI/blob/master/lib/Config/INI.pm" class="bare">https://github.com/tadzik/perl6-Config-INI/blob/master/lib/Config/INI.pm</a>
</div>
<div class="footnote" id="_footnotedef_53">
<a href="#_footnoteref_53">53</a>. 在这一点上，标识符不解析其周围的空白是至关重要的。因此，令牌不关心空白的原则，以及调用这些令牌的规则解析空白。
</div>
<div class="footnote" id="_footnotedef_54">
<a href="#_footnoteref_54">54</a>. 在这种情况下, 这种情况是无害的，因为没有其他的规则可以匹配到变量的其他部分, 但还是会导致解析错误。但是, 在更复杂的情况下, 这种不经意的回溯可能会导致 grammar 的维护者感到非常困惑的错误。
</div>
<div class="footnote" id="_footnotedef_55">
<a href="#_footnoteref_55">55</a>. <a href="https://docs.perl6.org/language/phasers" class="bare">https://docs.perl6.org/language/phasers</a>
</div>
<div class="footnote" id="_footnotedef_56">
<a href="#_footnoteref_56">56</a>. <a href="https://docs.raku.org/type/Match" class="bare">https://docs.raku.org/type/Match</a>
</div>
<div class="footnote" id="_footnotedef_57">
<a href="#_footnoteref_57">57</a>. <a href="https://docs.raku.org/type/Grammar" class="bare">https://docs.raku.org/type/Grammar</a>
</div>
<div class="footnote" id="_footnotedef_58">
<a href="#_footnoteref_58">58</a>. <a href="https://docs.raku.org/type/Cursor" class="bare">https://docs.raku.org/type/Cursor</a>
</div>
<div class="footnote" id="_footnotedef_59">
<a href="#_footnoteref_59">59</a>. <a href="https://docs.perl6.org/type/Str#routine_lines" class="bare">https://docs.perl6.org/type/Str#routine_lines</a>
</div>
<div class="footnote" id="_footnotedef_60">
<a href="#_footnoteref_60">60</a>. <a href="https://docs.raku.org/type/CallFrame#sub_callframe" class="bare">https://docs.raku.org/type/CallFrame#sub_callframe</a>
</div>
<div class="footnote" id="_footnotedef_61">
<a href="#_footnoteref_61">61</a>. <a href="https://docs.raku.org/type/Str#method_trim" class="bare">https://docs.raku.org/type/Str#method_trim</a>
</div>
<div class="footnote" id="_footnotedef_62">
<a href="#_footnoteref_62">62</a>. <a href="https://modules.raku.org/dist/Grammar-ErrorReporting" class="bare">https://modules.raku.org/dist/Grammar-ErrorReporting</a>
</div>
<div class="footnote" id="_footnotedef_63">
<a href="#_footnoteref_63">63</a>. 可悲的是, 许多关于解析的学术文献都忽略了这一方面, 大概是因为很难量化错误信息的质量。
</div>
<div class="footnote" id="_footnotedef_64">
<a href="#_footnoteref_64">64</a>. <a href="http://unicode.org/reports/tr29/" class="bare">http://unicode.org/reports/tr29/</a>
</div>
<div class="footnote" id="_footnotedef_65">
<a href="#_footnoteref_65">65</a>. <a href="https://en.wikipedia.org/wiki/Eastern_Arabic_numerals" class="bare">https://en.wikipedia.org/wiki/Eastern_Arabic_numerals</a>
</div>
<div class="footnote" id="_footnotedef_66">
<a href="#_footnoteref_66">66</a>. <a href="https://docs.raku.org/language/regexes#Unicode_properties" class="bare">https://docs.raku.org/language/regexes#Unicode_properties</a>
</div>
<div class="footnote" id="_footnotedef_67">
<a href="#_footnoteref_67">67</a>. 亚伯拉罕-马斯洛之后, 1966 年。见 <a href="https://en.wikipedia.org/wiki/" class="bare">https://en.wikipedia.org/wiki/</a> Law_of_the_instrument.
</div>
<div class="footnote" id="_footnotedef_68">
<a href="#_footnoteref_68">68</a>. 中缀运算符是指在两个项之间的运算符, 如 2*4 中的星号 *。
</div>
<div class="footnote" id="_footnotedef_69">
<a href="#_footnoteref_69">69</a>. <a href="https://docs.raku.org/type/Match.html#method_caps" class="bare">https://docs.raku.org/type/Match.html#method_caps</a>
</div>
<div class="footnote" id="_footnotedef_70">
<a href="#_footnoteref_70">70</a>. <a href="https://docs.raku.org/type/Pair" class="bare">https://docs.raku.org/type/Pair</a>
</div>
<div class="footnote" id="_footnotedef_71">
<a href="#_footnoteref_71">71</a>. 例如，表达式 3! + 2 有一个项，后面是后缀运算符，再后面也是后缀运算符。
</div>
<div class="footnote" id="_footnotedef_72">
<a href="#_footnoteref_72">72</a>. <a href="https://docs.raku.org/type/List#routine_first" class="bare">https://docs.raku.org/type/List#routine_first</a>
</div>
<div class="footnote" id="_footnotedef_73">
<a href="#_footnoteref_73">73</a>. <a href="https://en.wikipedia.org/wiki/Sentinel_value" class="bare">https://en.wikipedia.org/wiki/Sentinel_value</a>
</div>
<div class="footnote" id="_footnotedef_74">
<a href="#_footnoteref_74">74</a>. <a href="https://github.com/apress/perl-6-regexes-and-grammars/blob/master/" class="bare">https://github.com/apress/perl-6-regexes-and-grammars/blob/master/</a> chapter-13-case-studies/pythonesque.p6
</div>
</div>

</article>


    

  </main><section class="site__search">
    <label class="site__form">
        <p class="form__label">Search around the site</p> 
        <input class="site__search-bar form__input" type="text">
    </label>
    <div class="site__search-bar-results"></div>
</section>
  
  <footer class="site__footer">
    
    
    <p class="footer__sign">© 2020 ohmyraku</p></footer>
    

    
    <script>
        window.addEventListener("load", function () {
            const script = document.createElement("script");
            script.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
            script.async = true

            document.head.appendChild(script);
        })
    </script>





<script defer type="text/javascript" src="https://ohmyraku.github.io/js/script.14164ab553b19613ce98aadb54b1ed9a89ae5b056c72b99a4c672e37954f33d67bebe1452b0279025ba889964b51bdf8ec69683933cf427ae67c08ac2cdda7b1.js" integrity="sha512-FBZKtVOxlhPOmKrbVLHtmomuWwVscrmaTGcuN5VPM9Z76&#43;FFKwJ5AluoiZZLUb347GloOTPPQnrmfAisLN2nsQ=="></script>



</body>
</html>