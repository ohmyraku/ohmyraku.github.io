<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Raku 手册 :: 山川异域, 风月同天</title>

<meta name="author" content="ohmyraku">
<meta name="application-name" content="山川异域, 风月同天">
<meta name="description" content="1. 关于 Raku Raku 以前被称为 Perl 6，因此你会在转换完全完成之前的相当一段时间内看到该名称。
 1.1. Rakudo Rakudo 是用 NQP(«Not Quite Perl»)编写的 Raku 的生产就绪型实现，在专用的 MoarVM(&#34;运行时的元模型&#34;)虚拟机上运行。
 MoarVM 可用于 Windows，MacOS 和 Linux(以及某些其他操作系统)。
 Rakudo 每月发布一次。(或者至少打算拥有它们。)
 在 jvm 和 javascript(node.js)上运行的 Rakudo 的实现还不完整。
 1.1.1. Rakudo Star Rakudo Star 每三个月发布一次。 Rakudo 捆绑了文档(p6doc 命令，请参见第 1.8 节, &#34;文档&#34;)和一些有用的模块（尤其是模块安装程序 zef; 请参见第 12.2 节&#34;使用 zef 进行模块管理”)。
 这是安装 Rakudo 的最简单方法。
 如果你正在运行 Linux 或 MacOS，则可以选择使用 Docker 和 Rakudo 镜像。 在决定之前参考附录1.Docker。
  1.">
<meta name="robots" content="noodp"/>
<meta name="generator" content="Hugo 0.79.0" />
<meta name="referrer" content="no-referrer" />
<meta name="format-detection" content="telephone=no">

<link rel="canonical" href="https://ohmyraku.github.io/begining-raku/" />


<link rel="icon" href="https://ohmyraku.github.io/logo.png" />

<link rel="stylesheet" href="https://ohmyraku.github.io/scss/main.min.84f71d25d375c522a861bb4719728ce6839cf3635b15ca0c7a1b4d799c2dc3399a1d6cb46058a9d8fdbebe9156a8857279cfdeb70aa3862e629de234b5a41fa1.css" integrity="sha512-hPcdJdN1xSKoYbtHGXKM5oOc82NbFcoMehtNeZwtwzmaHWy0YFip2P2&#43;vpFWqIVyec/etwqjhi5ineI0taQfoQ==">
<script>

const theme = window.localStorage.getItem('theme'); 
if (theme && theme !== "1") {
    document.documentElement.classList.add('theme-' + theme);
}
</script>


</head>
<body>
  <main class="site__content">
    <div class="site__page">
  <nav class="site__breadcrumbs">
    <a class="site__breadcrumb" href="https://ohmyraku.github.io/">山川异域, 风月同天</a><a class="site__breadcrumb--active" href="https://ohmyraku.github.io/begining-raku/">Raku 手册</a>
</nav>

<h1 class="page__title">Raku 手册</h1>
  <div class="page__meta">
    <p>
    
    <span class="page__date">
    on <time datetime="2020-02-05T15:26:52&#43;08:00">2020-02-05</time>
    
    </span>
    </p>

    

    
    </div>
</div>


</div>

<article class="page__content" >
<div class="sect1">
<h2 id="_关于_raku">1. 关于 Raku</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 以前被称为 Perl 6，因此你会在转换完全完成之前的相当一段时间内看到该名称。</p>
</div>
<div class="sect2">
<h3 id="_rakudo">1.1. Rakudo</h3>
<div class="paragraph">
<p>Rakudo 是用 NQP(«Not Quite Perl»)编写的 Raku 的生产就绪型实现，在专用的 MoarVM(&#34;运行时的元模型&#34;)虚拟机上运行。</p>
</div>
<div class="paragraph">
<p>MoarVM 可用于 Windows，MacOS 和 Linux(以及某些其他操作系统)。</p>
</div>
<div class="paragraph">
<p>Rakudo 每月发布一次。(或者至少打算拥有它们。)</p>
</div>
<div class="paragraph">
<p>在 jvm 和 javascript(node.js)上运行的 Rakudo 的实现还不完整。</p>
</div>
<div class="sect3">
<h4 id="_rakudo_star">1.1.1. Rakudo Star</h4>
<div class="paragraph">
<p>Rakudo Star 每三个月发布一次。 Rakudo 捆绑了文档(<code>p6doc</code> 命令，请参见第 1.8 节, &#34;文档&#34;)和一些有用的模块（尤其是模块安装程序 <code>zef</code>; 请参见第 12.2 节&#34;使用 zef 进行模块管理”)。</p>
</div>
<div class="paragraph">
<p>这是安装 Rakudo 的最简单方法。</p>
</div>
<div class="paragraph">
<p>如果你正在运行 Linux 或 MacOS，则可以选择使用 Docker 和 Rakudo 镜像。 在决定之前参考附录1.Docker。</p>
</div>
</div>
<div class="sect3">
<h4 id="_安装_rakudo_star">1.1.2. 安装 Rakudo Star</h4>
<div class="paragraph">
<p>Rakudo Star: 浏览 <a href="https://rakudo.org/files" class="bare">https://rakudo.org/files</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Windows 和 Mac：使用安装二进制文件。 参见 <a href="https://rakudo.org/files/" class="bare">https://rakudo.org/files/</a></p>
</li>
<li>
<p>Linux：使用常规软件包系统(Debian, Centos, Fedora, openSUSE，Ubuntu 和 Alpine)。参见 <a href="https://nxadm.github.io/rakudo-pkg/" class="bare">https://nxadm.github.io/rakudo-pkg/</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>更多信息：<a href="https://raku.org/downloads/" class="bare">https://raku.org/downloads/</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_在浏览器中运行_raku">1.2. 在浏览器中运行 Raku</h3>
<div class="paragraph">
<p>在这些网站中也可以运行 Raku 程序:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://glot.io/new/perl6" class="bare">https://glot.io/new/perl6</a></p>
</li>
<li>
<p><a href="https://tio.run/#perl6" class="bare">https://tio.run/#perl6</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，它们不支持模块，并且更改服务器状态（作为文件操作）的任何操作都必然会失败。 REPL 模式（请参阅下一节）可能是一个更好的选择，但这确实需要安装 Raku。</p>
</div>
</div>
<div class="sect2">
<h3 id="_repl">1.3. REPL</h3>
<div class="paragraph">
<p>运行不带任何参数的 <code>raku</code> 以交互或 <code>REPL</code>（读取-计算-打印循环）模式启动它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku
To exit type &#39;exit&#39; or &#39;^D&#39;
&gt; say 12; my $a = False;
12
&gt; my $a = False;
False</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>REPL</code> 模式始终显示一个值。 如果你的代码输出一个值，那很好。 但是，如果没有，<code>REPL</code> 将输出最后一个表达式求值的内容。</p>
</div>
<div class="paragraph">
<p>为了节省空间，有时会在代码的同一行显示输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = False; # -&gt; False</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_命令行补全">1.3.1. 命令行补全</h4>
<div class="paragraph">
<p>你可以键入部分命令，然后使用 &lt;TAB&gt; 展开它。 如果可能的命令不止一个，请再次使用 &lt;TAB&gt; 在这些命令之间循环。</p>
</div>
<div class="paragraph">
<p>使用向上和向下箭头键循环显示命令历史记录。</p>
</div>
<div class="paragraph">
<p>如果箭头键无法正常工作，则必须安装 <code>Linenoise</code>（适用于所有平台，并且包括 Rakudo Star）。</p>
</div>
<div class="paragraph">
<p>Linenoise 不包含在本机软件包(Linux)中。 但是好消息是你不需要 «sudo» 来安装模块。</p>
</div>
<div class="paragraph">
<p><strong>练习 1.1</strong>
如果尚未安装 Rakudo Star(或 Docker 和一个(或两个) Docker 映像)，请先安装它。</p>
</div>
<div class="paragraph">
<p>启动 REPL，并使用 <code>$*PERL.compiler</code>(或 shell 中的 <code>raku -v</code>)检查版本。</p>
</div>
<div class="paragraph">
<p><strong>Linenoise</strong></p>
</div>
<div class="paragraph">
<p>Rakudo Star 随附了 raku 模块 <strong>Linenoise</strong>。 它提供了 REPL 命令行历史记录，并且就像普通的 shell 一样，可以编辑命令。</p>
</div>
<div class="paragraph">
<p>历史记录将保存到文件中，并在下次启动 REPL 时加载。</p>
</div>
<div class="paragraph">
<p>如果没有它（如在 REPL 中使用箭头键所示），请手动安装。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ zef install Linenoise</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，由于该模块具有二进制组件，因此你需要一个可运行的 C 编译器。</p>
</div>
<div class="paragraph">
<p>在基于 Debian 的系统(例如 Ubuntu)上，构建 Linenoise 所需的一切都在 «build-essential» 软件包中。</p>
</div>
<div class="paragraph">
<p>如果你没有 «zef»，请先安装它。 有关说明，请参见 <a href="https://github.com/ugexe/zef" class="bare">https://github.com/ugexe/zef</a>。 或考虑安装 Rakudo Star, 或使用 Docker。</p>
</div>
<div class="paragraph">
<p><strong>rlwrap</strong></p>
</div>
<div class="paragraph">
<p>在类似 Unix 的系统上，也可以使用 «rlwrap» 库。 可以像这样在基于 Debian 的系统上安装它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">sudo apt install rlwrap</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>zef</code> 不是必须的。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_单行程序">1.4. 单行程序</h3>
<div class="paragraph">
<p>我们可以使用命令行为 Raku 提供单行代码，并使用 «-e» 选项执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku -e &#39;say e&#39;;
2.718281828459045

$ raku -e &#39;say &#34;hello&#34;&#39;
hello</code></pre>
</div>
</div>
<div class="paragraph">
<p>我用 <code>say</code> 在屏幕上显示数据。 它在末尾添加一个换行符。</p>
</div>
<div class="paragraph">
<p>我本可以使用 <code>print</code>，但随后必须手动指定换行符。</p>
</div>
<div class="paragraph">
<p>有关详细信息，请参见第6.3节&#34;输出&#34;。</p>
</div>
<div class="paragraph">
<p>在 Windows 上，你必须交换引号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku -e &#34;say &#39;hello&#39;&#34;;
hello</code></pre>
</div>
</div>
<div class="paragraph">
<p>有时，你可以摆脱 Windows 在 Unix 之类的系统上的引用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku -e &#39;say &#34;Hello, World!&#34;&#39;
Hello, World!</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，shell 逃逸字符将由 shell 解析：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku -e &#34;say &#39;Hello, World!&#39;&#34;
bash: !&#39;: event not found</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_命令行选项">1.4.1. 命令行选项</h4>
<div class="paragraph">
<p>Raku 解释器支持几个命令行选项。 上一节介绍了 <code>-e</code>。</p>
</div>
<div class="paragraph">
<p>运行 <code>raku --help</code> 以获得完整列表。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_运行程序">1.5. 运行程序</h3>
<div class="paragraph">
<p>在本书的所有示例中，我都输入以下代码来运行程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku program</code></pre>
</div>
</div>
<div class="paragraph">
<p>代码文件的第一行是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">#! /usr/bin/env raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>在类似 Unix 的系统上，我们可以在不指定 <code>raku</code> 的情况下执行文件，因为系统将读取第一行并自动为我们启动 Raku -只要文件中设置了可执行标志：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ ./program</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 1.2</strong></p>
</div>
<div class="paragraph">
<p>使用文本编辑器(如 <code>emacs</code>, <code>vi</code> 或 <code>Notepad</code>)制作一个名为 «hello-world»(在 Windows 上为 «helloworld.p6» )的文本文件，其内容如下：
.文件: hello-world</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#! /usr/bin/env raku
say &#34;Hello, World!&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>并执行它。</p>
</div>
<div class="paragraph">
<p>请注意，如果通过双击该程序(在 Windows 中)运行该程序，它将为输出打开一个终端窗口，打印到该窗口，然后在程序终止时再次关闭它。 在所有人都可以阅读文本之前。 因此，打开一个终端窗口，然后在其中键入命令。</p>
</div>
</div>
<div class="sect2">
<h3 id="_错误信息">1.6. 错误信息</h3>
<div class="paragraph">
<p>Raku 尽力给出有用的错误消息。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用礼貌的 «===SORRY!===» 给出编译时错误。</p>
</li>
<li>
<p>没有给出运行时错误。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于一般用户而言，区别可能并不那么重要，但是在编译时捕获的错误是可取的，因为实际上尚未执行任何代码。</p>
</div>
</div>
<div class="sect2">
<h3 id="_use_v6">1.7. use v6</h3>
<div class="paragraph">
<p>如果你尝试使用 Perl 5 运行 Raku 程序，则会收到一条错误消息，提示你语法错误。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ perl hello-world
String found where operator expected at content/code/hello-world line 3, near &#34;say &#34;Hello, World!&#34;&#34;
      (Do you need to predeclare say?)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果添加 <code>use v6;</code> 在文件中的一行中，Perl 5 将给出更好的错误消息。</p>
</div>
<div class="paragraph">
<p>使用此指令可以告诉 Perl 5 要求它没有的版本，因此它将失败-无需尝试解析并执行程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ perl -e&#34;use v6&#34;
Perl v6.0.0 required--this is only v5.26.2, stopped at -e line 1. BEGIN failed--compilation aborted at -e line 1.</code></pre>
</div>
</div>
<div class="paragraph">
<p>我在本课程介绍的程序中没有做到这一点。</p>
</div>
<div class="paragraph">
<p>也可以指定 Raku 的特定版本。 例如 <code>use v6.c</code>，就像我在某些情况下在代码中所做的那样。 我这样做是为了向早期（预发行版； 6.a 和 6.b）的用户施加压力，以进行升级。 缺点是即使有较新的版本，该代码仍将使用 6.c。 （6.d 已于 2018 年 11 月发布。）</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见附录4.Raku 背景和历史记录。</p>
</div>
</div>
<div class="sect2">
<h3 id="_文档">1.8. 文档</h3>
<div class="paragraph">
<p>Raku 的文档非常好，并且一直在扩展。 它可以在线（在 Web上）和离线（本地）上使用。</p>
</div>
<div class="sect3">
<h4 id="_在线文档">1.8.1. 在线文档</h4>

</div>
<div class="sect3">
<h4 id="_本地文档">1.8.2. 本地文档</h4>
<div class="paragraph">
<p>该文档可通过 <code>p6doc</code> 命令在本地获得。 «p6doc» 软件包与 Rakudo Star 捆绑在一起，但可以与 «zef» 一起手动安装。</p>
</div>
<div class="paragraph">
<p><code>p6doc</code> 存在一些影响可用性的问题，因此你可能会发现联机文档更易于使用。</p>
</div>
<div class="paragraph">
<p>让我们尝试在不带参数的情况下运行它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"> $ p6doc
You want to maintain the index?
To build an index for &#39;p6doc -f&#39;

          p6doc build

To list the index keys
          p6doc list

To display module name(s) containing key
          p6doc lookup

To show where the index file lives
          p6doc path-to-index

What documentation do you want to read?
Examples: p6doc Str
          p6doc Str.split p6doc faq
          p6doc path/to/file

Set the POD_TO_TEXT_ANSI if you want to use ANSI escape sequences to enhance text

You can list some top level documents:
          p6doc -l

You can also look up specific method/routine/sub definitions:
          p6doc -f hyper
          p6doc -f Array.push

You can bypass the pager and print straight to stdout:
          p6doc -n Str</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，本地文档是安装时的快照，自那时以来，联机文档可能已发生了很大变化。</p>
</div>
<div class="paragraph">
<p>可以运行文档网站的本地副本，最简单的方法是使用 Docker。</p>
</div>
<div class="paragraph">
<p>像这样运行它，并转到 <a href="http://localhost:31415" class="bare">http://localhost:31415</a> 来使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">docker run --rm -it -p 31415:3000 jjmerelo/perl6-doc</code></pre>
</div>
</div>
<div class="paragraph">
<p>«--rm» 部分告诉 Docker 在停止容器后自动删除它。 你仍将拥有该映像，但是再次运行它可能需要一些时间，因为它将需要重新设置它。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见 <a href="https://github.com/Raku/doc" class="bare">https://github.com/Raku/doc</a>。</p>
</div>
<div class="paragraph">
<p><strong>练习 1.3</strong></p>
</div>
<div class="paragraph">
<p>运行命令 <code>p6doc list</code> 并注意条目（或关键字）的绝对大小。</p>
</div>
<div class="paragraph">
<p>首先是很多行，从 <code>method</code> 开始，然后是 <code>routine</code>，最后是 <code>sub</code>。 它们的含义如下：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">method</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法。在对象上调用的东西。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">routine</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以用作方法或子(例程)。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sub</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">子例程, 函数或过程。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>稍后，我们将在有一些基础知识的基础上返回文档。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_更多信息">1.9. 更多信息</h3>
<div class="ulist">
<ul>
<li>
<p>优秀的《每周 Rakudo 新闻》博客提供了（几乎）与 Raku 有关的所有内容的每周摘要：<a href="https://rakudoweekly.blog/" class="bare">https://rakudoweekly.blog/</a>。 自 2003 年以来一直在进行。</p>
</li>
<li>
<p>在 <a href="irc.freenode.net" class="bare">irc.freenode.net</a> 的 <code>#raku</code> IRC 频道上询问有关 Raku 问题的问题。 有关更多信息，请参见 <a href="https://raku.org/community/irc" class="bare">https://raku.org/community/irc</a>。</p>
</li>
<li>
<p>有关 Raku(和 Perl 6)的书籍：<a href="https://perl6book.com/" class="bare">https://perl6book.com/</a> 请注意，本网站上未提及有关 Perl 6 的较旧书籍。 避免在 2016 年之前出版的书籍，因为它们已经过时了。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_速度">1.10. 速度</h3>
<div class="paragraph">
<p>Rakudo 通常比 Perl 5 慢，但比一年前快得多。</p>
</div>
<div class="paragraph">
<p>开发人员关注的重点是：&#34;做对的事情, 然后变的更快&#34;。</p>
</div>
<div class="paragraph">
<p>Raku 完全兼容 Unicode，因此比原先的速度慢。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_变量运算符值和过程">2. 变量、运算符、值和过程</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_使用_say_和_print_输出">2.1. 使用 say 和 print 输出</h3>
<div class="paragraph">
<p>在执行其他操作之前，我们将讨论如何在屏幕上显示文本：</p>
</div>
<div class="paragraph">
<p>正常方式（使用其他语言）是 <code>print</code> 命令。 如果要换行，必须在末尾添加换行（<code>\n</code>）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; print &#34;a&#34;; print &#34;b&#34;;
ab&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&gt;</code> 是 REPL 提示符，在同一行上。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，<code>say</code> 会自动在末尾附加一个换行符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;a&#34;; say &#34;b&#34;;
a
b</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据要实现的目的同时使用两者：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; print &#34;a&#34;; say &#34;b&#34;;
ab</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将在第 6.1 节&#34;换行&#34;中介绍有关换行的详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="_变量">2.2. 变量</h3>
<div class="paragraph">
<p>变量是可以保存值的命名容器（也称为存储桶），并且可以随时更改该值。</p>
</div>
<div class="sect3">
<h4 id="_符号">2.2.1. 符号</h4>
<div class="paragraph">
<p>变量类型由名称前的第一个字符 sigil 决定。 四种类型是：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">符号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何东西</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">几个值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">几个键值对儿</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&amp;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Code</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可调用代码</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>标记是变量名称的一部分，因此 «$a» 可以与 «@a», «％a» 和 «&amp;a» 共存，它们是独立的变量。</p>
</div>
<div class="paragraph">
<p><strong>Anything($)</strong></p>
</div>
<div class="paragraph">
<p>可以像我们一开始那样保留一个值。 但是它也可以用来存放任何东西。</p>
</div>
<div class="paragraph">
<p>在 Perl 5 中，此类型称为 Scalar，你可能还会看到用于 Raku 的名称。</p>
</div>
<div class="paragraph">
<p><strong>Arrays(@)</strong></p>
</div>
<div class="paragraph">
<p>数组是具有一个或多个值的排序列表。</p>
</div>
<div class="paragraph">
<p>有关详细信息，请参见第8章，数组和列表。</p>
</div>
<div class="paragraph">
<p><strong>Hashes (%)</strong></p>
</div>
<div class="paragraph">
<p>散列是键和值对的未排序集合。 使用键查找值。</p>
</div>
<div class="paragraph">
<p>有关详细信息，请参见第9章，配对和哈希；有关更多详细信息，请参见&#34;高级 Raku&#34;课程。</p>
</div>
<div class="paragraph">
<p><strong>Code (&amp;)</strong></p>
</div>
<div class="paragraph">
<p><code>&amp;</code> 表示我们获得了对代码的引用（通常是过程名称），而不是立即执行。</p>
</div>
<div class="paragraph">
<p>如果你曾经有过 Perl 5 的经验，那么应该熟悉前三个信号，并且这是该语言的内置类型的限制。</p>
</div>
<div class="paragraph">
<p>Raku 还有其他几种类型，我们稍后再介绍。 如果我们将这些类型之一的内容分配给哈希或数组，则会更改类型。 将其分配给标量以保留类型，因为标量可以包含任何内容。</p>
</div>
<div class="paragraph">
<p>我们将遇到的第一个示例（请参见第8章，数组和列表）是数组和列表之间的区别。</p>
</div>
<div class="paragraph">
<p>实际上，我们可以删除其他信号，并对所有内容使用标量 <code>$</code>。 但这对可读性并没有帮助，因此不建议使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_twigils">2.2.2. Twigils</h4>
<div class="paragraph">
<p>符号后面可以加上一个 twigil(&#34;微调符号&#34;的东西)。 最常用的是：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Twigil</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">属性(类成员)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">动态变量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法(不是真正的变量)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自我声明的正式命名参数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>?</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">编译时变量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>^</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自我声明的正式位置参数，也称为占位符变量。 有关详细信息, 请参见 8.13.1，&#34;占位符变量&#34;。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>有关完整列表，请参见 <a href="https://docs.raku.org/language/variables#Twigils" class="bare">https://docs.raku.org/language/variables#Twigils</a>。</p>
</div>
<div class="paragraph">
<p>我们将在适当时候进行调查。</p>
</div>
</div>
<div class="sect3">
<h4 id="_my">2.2.3. my</h4>
<div class="paragraph">
<p>必须先声明变量(使用 <code>my</code>)，然后才能使用它们。 否则我们会得到一个编译时错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">===SORRY!=== Error while compiling:
Variable &#39;$s&#39; is not declared
------&gt; &lt;BOL&gt;⏏$</code></pre>
</div>
</div>
<div class="paragraph">
<p>弹出符号(⏏)显示编译器认为问题出在哪里。 实际输出取决于终端的功能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $r
(Any)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>(Any)</code> 表示该变量没有值。 （或者说，它可以保留任何值。）我们将在第3章，类型系统中对此进行说明。</p>
</div>
<div class="paragraph">
<p><code>my</code> 定义了一个词法范围的变量，这意味着该变量仅在当前块中可用，从其定义位置到第一个右花括号(<code>}</code>)：</p>
</div>
<div class="listingblock">
<div class="title">文件: my</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    my $a = 12;
    say $a; # -&gt; 12
}

say $a; # -&gt; Variable &#39;$a&#39; is not declared</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以同时声明几个变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my ($a, @b, %c);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>my</code> 和开口圆括号之间的空间至关重要。 如果你忘记了它，它将被视为对带有三个参数的过程&#34;my&#34;（希望不存在）的调用。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_注释">2.3. 注释</h3>
<div class="paragraph">
<p>以 <code>#</code> 号开始注释。 该行的其余部分将被编译器忽略。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;12&#34;; # This is a comment
12</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_多行注释">2.3.1. 多行注释</h4>
<div class="paragraph">
<p>多行和嵌入式注释以井号(<code>＃</code>)，反引号(`)和方括号开头的字符(例如 <code>(</code>, <code>{</code> 和 <code>[</code>) 或字符组(例如 <code>((</code> 或 <code>{[</code>)。 直到匹配的一个包围的方括号字符为止。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;Hello&#34;;
#`[ This is a comment.
The compiler will ignore it.
But you, the reader, cannot ignore it ]
say &#34;Good bye&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用递归方括号（注释内的注释），但可能不太有用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 14 #`{ a { b } c }, 12;
1412</code></pre>
</div>
</div>
<div class="paragraph">
<p>注释一直持续到字符串的最后。</p>
</div>
</div>
<div class="sect3">
<h4 id="_嵌入式注释">2.3.2. 嵌入式注释</h4>
<div class="paragraph">
<p>我们也可以将多行语法用于内联注释（单行）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say #`( Yeah, right. Why bother commenting the code? ) &#34;Whatever...&#34;;
Whatever...

&gt; say 14; #`({ hidden-comment })
14</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_非破坏性运算符">2.4. 非破坏性运算符</h3>
<div class="paragraph">
<p>几乎每个运算符和函数都将返回新的修改后的值，而原始值则保持不变/不变。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 10; my $b = 20;
my $a = $a + $b;
my $string = &#34;abcabc&#34; ~ &#34;ABC&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以同时分配新值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$a += $b;
$string ~= &#34;ABC&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为什么这不是默认设置？ 好。 表达式 <code>2+2</code> 是有效的，但是你不能将总和(<code>4</code>)分配回第一个值(<code>2</code>)。</p>
</div>
<div class="paragraph">
<p>这也适用于方法，请参见第3.3节&#34;一切都是对象&#34;。</p>
</div>
</div>
<div class="sect2">
<h3 id="_数值运算符">2.5. 数值运算符</h3>
<div class="paragraph">
<p>操作符使用一个或多个值或变量执行某项操作。</p>
</div>
<div class="paragraph">
<p>当然，我们有通常的数学方法：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Numerical</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">减法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">++</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">递增 1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"> — </p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">递减 1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">乘法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">div</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">除法</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_加法">2.5.1. +(加法)</h4>
<div class="paragraph">
<p>使用 <code>+</code>（加法运算符）将两个数字（和/或变量）相加：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; 2 + 2; # -&gt; 4</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_减法">2.5.2. -(减法)</h4>
<div class="paragraph">
<p>使用 <code>-</code>（减法运算符）从另一个减去一个数字（和/或变量）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = 3; my $b = 2;
&gt; $a - $b; # -&gt; 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_自增">2.5.3. ++(自增)</h4>
<div class="paragraph">
<p>使用 <code>++</code> 将变量加1。如果该值尚未为数字，则将其强制为数字。</p>
</div>
<div class="paragraph">
<p>可以用作前缀和后缀运算符：</p>
</div>
<div class="listingblock">
<div class="title">文件: plusplus</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $i = 10; say &#34;{ $i++ } $i&#34;; # -&gt; 10 11
   $i = 10; say &#34;{ ++$i } $i&#34;; # -&gt; 11 11</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，组合前缀和后缀版本是非法的。 因此 <code>--$a++</code>(和变体)将失败。</p>
</div>
</div>
<div class="sect3">
<h4 id="_自减">2.5.4. --(自减)</h4>
<div class="paragraph">
<p>使用 <code>--</code> 将变量减1。如果该值尚未为数字，则将其强制为数字。</p>
</div>
<div class="paragraph">
<p>它可以用作前缀和后缀运算符。</p>
</div>
<div class="listingblock">
<div class="title">文件: minusminus</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $i = 10; say &#34;{ $i-- } $i&#34;; # -&gt; 10 9
   $i = 10; say &#34;{ --$i } $i&#34;; # -&gt; 9 9</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，组合前缀和后缀版本是非法的。 因此，<code>++$a--</code>(和变体)将失败。</p>
</div>
</div>
<div class="sect3">
<h4 id="_乘法">2.5.5. *(乘法)</h4>
<div class="paragraph">
<p>使用 <code>*</code>(乘法运算符)将两个数字（和/或变量）相乘：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; 2 * 7; # -&gt; 14</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_除法">2.5.6. /(除法)</h4>
<div class="paragraph">
<p>使用 <code>/</code>(除法运算符)将一个数字（和 <code>/</code> 或变量）除以另一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; 8 / 4; # -&gt; 2</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_div">2.5.7. div</h4>
<div class="paragraph">
<p>整数除法运算符 <code>div</code> 是 <code>/</code> 的变体，如果两个值都是整数，则可以使用 <code>/</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; 8 div 4; # -&gt; 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果一个或两个值都是其他值，它将失败。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_运算符优先级">2.6. 运算符优先级</h3>
<div class="paragraph">
<p>从最高（也称为最严格）优先级到最低优先级：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">运算符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">圆括号</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>**</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">幂</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*</code> 和 <code>/</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">乘法和除法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+</code> 和 <code>-</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加法和减法</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>当在代码中遇到具有相同优先级的运算符时，它们将从左到右执行。</p>
</div>
<div class="paragraph">
<p>有关运算符优先级规则的完整列表，请参见 <a href="https://docs.raku.org/language/operators" class="bare">https://docs.raku.org/language/operators</a>。</p>
</div>
<div class="paragraph">
<p>如有疑问，请使用括号。 （是的，我说真的。）</p>
</div>
<div class="paragraph">
<p><strong>练习 2.1</strong></p>
</div>
<div class="paragraph">
<p>这个表达式的结果是?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 12 + 10 * 4;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_赋值">2.6.1. <code>=</code>(赋值)</h4>
<div class="paragraph">
<p>使用 <code>=</code>(赋值运算符)为变量赋值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $s = 5; # -&gt; 5
&gt; $s = 10;   # -&gt; 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>这实际上是 Raku 中的运算符，尽管不是数学意义上的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_绑定">2.6.2. :=(绑定)</h4>
<div class="paragraph">
<p>使用 <code>:=</code> 运算符将变量设置为指向右侧的东西。 正常赋值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;  # (1)
my $b = $a;  # (1)
$a += 10;    # (2)
say &#34;$a $b&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会打印出期望的 <code>52 42</code>。</p>
</div>
<div class="paragraph">
<p>如果右边的东西是一个变量，那么我们在同一个容器中有一个别名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;  # (1)
my $b := $a; # (1)
$a += 10;    # (2)
say &#34;$a $b&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会打印出 <code>52 52</code>。</p>
</div>
<div class="paragraph">
<p>如果右边的东西是表达式（而不是变量），则将对其求值并使用该值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;      # (1)
my $b := $a + 0; # (1)
$a += 10;        # (2)
say &#34;$a $b&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会打印出 <code>42 52</code>。</p>
</div>
<div class="paragraph">
<p>表达式 <code>my $b := $a + 0;</code> 将变量绑定到值 <code>42</code>(无容器)。 任何此类（无容器）值都是常量，并且无法更改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; $b++; # -&gt; Error
&gt; 12++ # -&gt; Just as this is an error</code></pre>
</div>
</div>
<div class="paragraph">
<p>更改值的唯一方法是将其绑定到另一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$b := 4;</code></pre>
</div>
</div>
<div class="paragraph">
<p>普通赋值将尝试更改该值，在这种情况下为 4，该值将不起作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt;  $b = 14;
Cannot assign to an immutable value</code></pre>
</div>
</div>
<div class="paragraph">
<p>绑定也适用于数组和哈希。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_值">2.7. 值</h3>
<div class="paragraph">
<p>值可以是字符串，数字，也可以是更复杂的对象，我们将在第17章，类中看到。</p>
</div>
<div class="sect3">
<h4 id="_字符串">2.7.1. 字符串</h4>
<div class="paragraph">
<p>字符串用引号指定； 单引号 ，双引号或其他 Unicode 必须提供的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $name = &#34;Arne&#34;;          # -&gt; Arne
&gt; my $hello = &#34;Hello, $name&#34;; # -&gt; Hello, Arne
&gt; my $hello = &#39;Hello, $name&#39;; # -&gt; Hello, $name</code></pre>
</div>
</div>
<div class="paragraph">
<p>除非使用单引号，否则将对变量进行插值。</p>
</div>
<div class="paragraph">
<p>所谓的«法语引号»(« 和 »)插值变量，但是字符串被分解为一个以空格作为分隔符的数组。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; «Hello, $name».raku; # -&gt; (&#34;Hello&#34;, &#34;Arne&#34;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也适用于 ASCII 等效的 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &lt;&lt;Hello, $name&gt;&gt;.raku; # -&gt; (&#34;Hello,&#34;, &#34;Arne&#34;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>单括号版本(带有 <code>&lt;</code> 和 <code>&gt;</code>)用作单引号，因为不对变量进行插值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &lt;Hello, $name&gt;.raku; # -&gt; (&#34;Hello,&#34;, &#34;\$name&#34;)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>raku</code> 方法显示 Raku 如何在内部存储值，并有助于显示正在发生的情况。 有关更多信息，请参见第 6.2.3 节&#34;raku(perl)&#34;。</p>
</div>
<div class="paragraph">
<p>请注意，如果不使用索引，则不会内插字符串中的数组和哈希。 我们可以添加一个空索引来使其工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @a = 1,2,3; say &#34;@a&#34;;   # -&gt; @a
&gt; my @a = 1,2,3; say &#34;@a[]&#34;; # -&gt; 1 2 3

&gt; my %a; say &#34;%a{}&#34;;             # -&gt; %a
&gt; my %a; %a&lt;a&gt; = 12; say &#34;%a{}&#34;; # -&gt; a 12</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者我们可以将变量放置在花括号中以确保插值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $hello = &#34;Hello, { $name }&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这对于表达式很有用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;I am almost { $age + 1 } years old.&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多信息，请参见第7章，字符串；有关其他引用结构，请参见第7.12节&#34;引用&#34;。</p>
</div>
<div class="paragraph">
<p><strong>~(字符串连接)</strong></p>
</div>
<div class="paragraph">
<p>使用 <code>~</code> 将两个字符串粘合在一起：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $t = &#34;abc&#34; ~ &#34;def&#34;;
abcdef</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_数字">2.7.2. 数字</h4>
<div class="paragraph">
<p>如果它没有引号，并且看起来像一个数字，则可以是一个数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">12       # Integer
12.8     # A number
1.12e+20 # Floating point
2+4i     # A Complex number</code></pre>
</div>
</div>
<div class="paragraph">
<p>或一个错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">12A
1.12e
2+4j</code></pre>
</div>
</div>
<div class="paragraph">
<p>复数将在《高级 Raku》课程中介绍。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_变量名">2.8. 变量名</h3>
<div class="paragraph">
<p>变量名（以及任何其他名称）中的第一个字符（在标记和可选的 twigil 之后）；例如 过程，类）必须是字母（如 Unicode 所决定的是字母）或“开始”下划线(<code>_</code>)。</p>
</div>
<div class="paragraph">
<p>其余的可以是字母，下划线(<code>_</code>)，减号(<code>-</code>)，单引号(&#39;)和数字。</p>
</div>
<div class="paragraph">
<p>减号(<code>-</code>)或单引号(&#39;)后必须是字母或下划线(<code>_</code>)，最后一个字符必须是字母，下划线或数字。</p>
</div>
<div class="paragraph">
<p>一些例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $r1234;    # OK
my $r1234-56; # ERROR - parsed as &#34;$r1234 - 56&#34;
my $r1234_56; # OK
my $r1234-5A; # ERROR - as &#34;5A&#34; is not a number
my $r1234&#39;5A; # ERROR - as &#34;5A&#34; is not a number
my $Große;    # OK
my $ßßßßßß;   # OK
my $______;   # OK
my $;         # OK (doesn&#39;t work in print; two Chinese letters)
my $_;        # ERROR, as we cannot redeclare this one.</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们甚至可以使用难以打印的字符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $㑄㒔;    # OK - two chinese letters</code></pre>
</div>
</div>
<div class="paragraph">
<p>建议常识，尤其是在进入 Unicode 丛林之前。</p>
</div>
<div class="paragraph">
<p><strong>练习 2.2</strong></p>
</div>
<div class="paragraph">
<p>以下哪个变量名称是合法的？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $don&#39;t-do-it;
my $dog;
my $dog2;
my $dog-3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>REPL</code> 来检测你是不是对的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_常量">2.9. 常量</h3>
<div class="paragraph">
<p>不要将变量用于应保持恒定的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; constant $pi = 3.14;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你不能更改常量值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; constant $pi = 3.14;
&gt; $pi = 3;
Cannot assign to an immutable value in block &lt;unit&gt; at &lt;unknown file&gt; line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，仅将“不变”视为“只读”的花哨词。 我们将在“高级 Raku”课程中再次介绍它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_无符号变量">2.10. 无符号变量</h3>
<div class="paragraph">
<p>你可以删除符号，如果这样会使你感觉更好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; constant pi = 3.14;
&gt; say pi * 5;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用绑定，但是与赋值相比，它不添加任何内容（也许除外）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; constant pi := 3.14; # Use assignment instead</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_pi">2.10.1. pi</h4>
<div class="paragraph">
<p>Raku 有一个内置的 <code>pi</code> 值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say pi; # -&gt; 3.141592653589793</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以重新定义它-无需任何警告。 但是请不要。</p>
</div>
</div>
<div class="sect3">
<h4 id="_仍旧是常量">2.10.2. 仍旧是常量?</h4>
<div class="paragraph">
<p>如果你认为 <code>constant</code> 输入太多，请在声明常量时使用反斜杠：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my \z = 2;   # -&gt; 2
&gt; say z + 100; # -&gt; 102
&gt; z= 2
Cannot modify an immutable Int (1) in block &lt;unit&gt; at &lt;unknown file&gt; line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>变量 <code>z</code> 实际上是常量，因此，无符号变量根本不是变量。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_true_和_false">2.11. True 和 False</h3>
<div class="paragraph">
<p>Raku 内置了布尔值 <code>True</code> 和 <code>False</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = False; # -&gt; False
&gt; my $b = True;  # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>在数字上下文中，<code>False</code> 的值为 0，<code>True</code> 的值为 1。这意味着我们可以执行以下操作，尽管这是不明智的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; True + False; # -&gt; 1
&gt; True + True;  # -&gt; 2
&gt; True * 12;    # -&gt; 12</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_so_bool">2.11.1. so / ? / Bool</h4>
<div class="paragraph">
<p>如果我们在布尔上下文中评估非布尔值，则如果未定义，则将为 <code>False</code>，否则将为空字符串或数字 0。其他所有结果均将为 <code>True</code>。</p>
</div>
<div class="paragraph">
<p><code>so</code> 关键字(或 <code>?</code> 前缀）强制在布尔上下文中对表达式求值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;False&#34;.Bool; # -&gt; True
&gt; so &#34;False&#34;;   # -&gt; True
&gt; ? &#34;False&#34;     # -&gt; True ## The space is optional
&gt; &#34;False&#34;.so    # -&gt; True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_布尔运算符">2.11.2. 布尔运算符</h4>
<div class="paragraph">
<p>布尔运算符成对出现，一个优先级高，另一个优先级低。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">高优先级</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">低优先级</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>not</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">否定</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;&amp;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>and</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">都</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">`</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">`</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>or</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">之一或都</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>^^</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>!/not</strong></p>
</div>
<div class="paragraph">
<p><code>!</code> 和 <code>not</code> 运算符可用于否定布尔值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; ! True;  # -&gt; False
&gt; ! False; # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>当对非布尔值使用时，该值在取反之前将转换为布尔值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; ! 10;    # -&gt; False
&gt; ! 0;     # -&gt; True
&gt; ! &#34;ABC&#34;; # -&gt; False
&gt; ! &#34;&#34;;    # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>代替</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; if ! $value == 15</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用取反的运算符 <code>!=</code>（我们将在第3.7节&#34;比较运算符&#34;中进行解释）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; if $value != 15</code></pre>
</div>
</div>
<div class="paragraph">
<p>或否定测试:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; unless $value == 15</code></pre>
</div>
</div>
<div class="paragraph">
<p>小心优先级:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; not 1 - 1; # -&gt; not (1 - 1) -&gt; not 0
True

&gt; ! 1 - 1; # -&gt; (!1) - 1 -&gt; False - 1 -&gt; 0 - 1
-1</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>&amp;&amp; / and</strong></p>
</div>
<div class="paragraph">
<p>如果所有参数的计算结果均为 <code>True</code>，则返回 <code>True</code>-ish值，否则返回 <code>False</code>-ish 值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; 1 and 6;        # -&gt; 6
&gt; True and 0;     # -&gt; 0
&gt; True and False; # -&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回值是第一个参数的结果为 <code>False</code> 或最后一个参数（结果为 <code>True</code>）。</p>
</div>
<div class="paragraph">
<p>此操作会短路，因此编译器在遇到第一个 <code>False</code> 值后将跳过给出的所有表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = 1; $a++ and $a++ and $a++ and $a++; # -&gt; 4
&gt; my $b = 0; $b++ and $b++ and $b++ and $b++; # -&gt; 0</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>|| / or</strong></p>
</div>
<div class="paragraph">
<p>如果至少一个参数的计算结果为 <code>True</code>，则返回 <code>True</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; True  || False; # -&gt; True
&gt; True  || True;  # -&gt; True
&gt; False || False; # -&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>xor / ^^</strong></p>
</div>
<div class="paragraph">
<p>如果正好其中一个参数的计算结果为 <code>True</code>，则返回 <code>True</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; True xor False;  # -&gt; True
&gt; False xor False; # -&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果其中多个计算为 <code>True</code>，则返回 <code>Nil</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; True xor True;                      # -&gt; Nil
&gt; True xor True xor False;            # -&gt; Nil
&gt; False xor False xor False xor True; # -&gt; True
&gt; False ^^ False ^^ False ^^ True;    # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 2.3</strong></p>
</div>
<div class="paragraph">
<p>解释为什么我们在使用 <code>!</code> 和 <code>not</code> 时会得到不同的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $value = 1;
&gt; ! $value == 15;   # -&gt; False
&gt; not $value == 15; # -&gt; True</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="">2.12. //</h3>
<div class="paragraph">
<p><code>or</code> 和 <code>||</code> 的问题是运算符是他们不区分零值和未定义的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $age = 0; # Age in years
&gt; say $age || &#34;unknown&#34;; # -&gt; unknown</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 «Defined-or» 运算符 <code>//</code> 来解决此问题。 它返回定义的第一个操作数，如果未定义则返回最后一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $age = 0; # Age in years
&gt; say $age // &#34;unknown&#34;; # -&gt; 0

&gt; my $price-pound;
&gt; my $price-dollar = 5;
&gt; my $price-yen = 2;
&gt; say &#34;The price is: { $price-pound // $price-dollar // $price-yen // &#34;unknown&#34; }.&#34;; The price is: 5.</code></pre>
</div>
</div>
<div class="paragraph">
<p>（我们应该告诉我们以哪种货币给出了价格，但没关系。）</p>
</div>
<div class="sect3">
<h4 id="_分组运算符">2.12.1. ()(分组运算符)</h4>
<div class="paragraph">
<p>使用括号将表达式分组在一起。 它们具有比其他任何事物更高的优先级：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; 1 + 2 * 3 + 4; # -&gt; 1 + ( 2 * 3 ) + 4; # -&gt; 11
&gt; (1 + 2) * (3 + 4) # -&gt; 3 * 7;          # -&gt; 21</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，分组运算符不会列出。 我们可以使用逗号（称为列表运算符；请参见第8.1节&#34;列表运算符&#34;）来创建列表。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_类型系统">3. 类型系统</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 具有复杂的（如复杂的）类型系统，我们可以选择积极使用它（称为&#34;强类型&#34;）- 或忽略它。</p>
</div>
<div class="paragraph">
<p>即使我们忽略它们，这些类型仍然存在，并且可能引起意外。 通常建议使用类型系统。</p>
</div>
<div class="paragraph">
<p>不使用类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = 12;
&gt; $a = &#34;hello, world!&#34;;</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_强类型">3.1. 强类型</h3>
<div class="paragraph">
<p>使用强类型:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my Int $a = 12; # -&gt; 12

&gt; $a = &#34;hello, world!&#34;;
Type check failed in assignment to $a; expected Int but got Str (&#34;Hello, world!&#34;)
  in block &lt;unit&gt; at &lt;unknown file&gt; line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>强类型可以防止编程错误。</p>
</div>
<div class="paragraph">
<p>当变量不包含值时，<code>REPL</code> 将报告类型。 <code>Any</code> 是最通用的类型，因为它可以表示任何东西。</p>
</div>
<div class="paragraph">
<p>我们可以对数组和哈希进行相同的操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my Int @a;
&gt; my Str %h;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以根据需要使用类型系统：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my Int $a = 12; # -&gt; 12
&gt; my $b = $a + 1; # -&gt; 13
&gt; $b = &#34;Hi!&#34;;     # -&gt; Hi!</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_of作为关键字">3.1.1. of(作为关键字)</h4>
<div class="paragraph">
<p>我们也可以使用 <code>of</code> 将类型约束添加到变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $i of Int = 42;
&gt; my Int $i = 42;    # The same

&gt; my Int @a;
&gt; my @a of Int;

&gt; my Int %h;
&gt; my %h of Int;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_name">3.1.2. ^name</h4>
<div class="paragraph">
<p><code>^name</code> 方法可用于告诉我们值或变量的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; 12.^name;                 # -&gt; Int
&gt; &#34;12&#34;.^name;               # -&gt; Str
&gt; my $i = 12; say $i.^name; # -&gt; Int
&gt; $i = &#34;AB&#34;; say $i.^name;  # -&gt; Str
&gt; True.WHAT;                # -&gt; Bool</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有一个 <code>WHAT</code> 方法（和过程）给出类似的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; 12.^name; # -&gt; Int  # A scalar value
&gt; 12.WHAT; # -&gt; (Int) # A one-element list</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是建议使用 <code>^name</code>。</p>
</div>
<div class="paragraph">
<p><code>^name</code>(和 <code>WHAT</code>)方法显示实现细节，你不应根据他们编写代码。</p>
</div>
<div class="paragraph">
<p>一个明显的原因是类和继承（将在第17章，类中讨论），可以更改类名。</p>
</div>
<div class="paragraph">
<p>另一个（不是很明显）的原因是优化程序，它可以选择更改类型。</p>
</div>
</div>
<div class="sect3">
<h4 id="_of作为方法">3.1.3. of(作为方法)</h4>
<div class="paragraph">
<p>我们可以使用 <code>of</code> 作为一种方法来显示数组和散列的值或变量的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; my Int %hash; say %hash.of; # -&gt; (Int)
&gt; my Str %hash; say %hash.of; # -&gt; (Str)
&gt; my @a;        say @a.of;    # -&gt; (Mu)
&gt; my Int @a;    say @a.of;    # -&gt; (Int)</pre>
</div>
</div>
<div class="paragraph">
<p><code>of</code> 方法不适用于标量，在这里我们必须使用 <code>.VAR</code> 来获取标量对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my Numeric $a; say $a.^name; # -&gt; Numeric
&gt; $a = 3; say $a.^name;        # -&gt; Int
&gt; $a.VAR.of;                   # -&gt; (Numeric)
&gt; say $a.VAR.of.^name;         # -&gt; Numeric</code></pre>
</div>
</div>
<div class="paragraph">
<p>这表明我们可以区分对象的类型（在这种情况下为 <code>Numeric</code>）和实际值的类型（在这种情况下为整型）。 不过，它可能没那么有用。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mro方法解析顺序">3.2. <code>^mro</code>(方法解析顺序)</h3>
<div class="paragraph">
<p><code>^mro</code>（《方法解析顺序》）方法以继承（和优先级）顺序列出对象或值所属的类型（或类）的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 12.^mro; # -&gt; ((Int) (Cool) (Any) (Mu))</code></pre>
</div>
</div>
<div class="paragraph">
<p>这告诉我们数字 12 是 <code>Int</code> 类型，<code>Int</code> 从 <code>Cool</code> 继承，<code>Cool</code> 从 <code>Any</code> 继承，最后 <code>Any</code> 从 <code>Mu</code> 继承。</p>
</div>
<div class="paragraph">
<p>这意味着如果我们在 <code>Int</code> 上应用 <code>say</code>，则调度程序（或方法解析器）以 <code>Int</code> 开头并检查那里是否存在 <code>say</code> 方法。 如果没有，它将沿着继承图继续，直到找到它或放弃为止。</p>
</div>
<div class="paragraph">
<p>从实现的角度来看，这很有用。 我们从基类（或父类）继承方法，并仅在需要时提供自定义版本。</p>
</div>
<div class="paragraph">
<p><code>^mro</code> 中的初始插入符号告诉你此方法提供了特定于实现的详细信息。 来自此类调用的信息可能会在 Raku 的更高版本中更改，而不会事先发出警告。</p>
</div>
<div class="paragraph">
<p>有关类型系统的更多信息，请参见 <a href="https://docs.raku.org/type.html" class="bare">https://docs.raku.org/type.html</a>。</p>
</div>
<div class="sect3">
<h4 id="_int_继承树">3.2.1. Int 继承树</h4>
<div class="paragraph">
<p><code>^mro</code> 也可以用于类型对象。 这里我们有 <code>Int</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say Int.^mro; # -&gt; ((Int) (Cool) (Any) (Mu))</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mu</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类型系统的根</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Any</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Thing/object</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">既可以当作字符串也可以当作数字的对象（«便捷OO循环»的缩写）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整型</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>![img]()</p>
</div>
<div class="paragraph">
<p>使用的颜色为：黑色（类型），绿色（枚举；我们将在《高级 Raku》课程中再讲到它），蓝色（角色，请参见17.14，&#34;角色&#34;）。 类型从它具有指针的东西继承。</p>
</div>
<div class="paragraph">
<p>在线图：<a href="https://docs.raku.org/type/Int#Type_Graph" class="bare">https://docs.raku.org/type/Int#Type_Graph</a>。</p>
</div>
<div class="paragraph">
<p>有关 <code>Str</code> 继承树，请参见第6.6.2.1节&#34;Str 继承树&#34;。</p>
</div>
</div>
<div class="sect3">
<h4 id="_其它类型">3.2.2. 其它类型</h4>
<div class="paragraph">
<p>注意我们不能在角色上使用 <code>^mro</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; Real.^mro
No such method &#39;mro&#39; for invocant of type &#39;Perl6::Metamodel::ParametricRoleGroupHOW&#39;
    in block &lt;unit&gt; at &lt;unknown file&gt; line 1

&gt; Numeric.^mro
No such method &#39;mro&#39; for ...</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_一切皆对象">3.3. 一切皆对象</h3>
<div class="paragraph">
<p>如果你想要的话。</p>
</div>
<div class="paragraph">
<p>大多数内置函数都有相应的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say $a;
&gt; $a.say;

&gt; say &#34;Hello&#34;;
&gt; &#34;Hello&#34;.say;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住第一章中的下表：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">method</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法。在对象上调用的东西。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">routine</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以用作方法或子(例程)。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sub</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">子例程, 函数或过程。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果你想知道某个关键字是否可以用作方法，子例程或同时用作两者，请使用 <code>p6doc list</code> 进行查找。 例如 <code>say</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ p6doc list | grep say
method say
sub say</pre>
</div>
</div>
<div class="paragraph">
<p>这表明文档不 100% 一致。 我们应该在这里的&#34;子例程 say&#34;上受到打击。</p>
</div>
<div class="paragraph">
<p>大多数方法（以及运算符，请参见第2.4节&#34;非破坏性运算符&#34;）保留原样调用的值，并返回修改后的版本。</p>
</div>
<div class="paragraph">
<p>我们可以使用以下简短形式进行赋值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$val = $val.something; # This method doesn&#39;t exist.
$val .= something;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_特殊值">3.4. 特殊值</h3>
<div class="paragraph">
<p>在本节中，我们将查看特殊值 <code>Nil</code>，<code>Any</code>，<code>Inf</code> 和 <code>NaN</code>。</p>
</div>
<div class="sect3">
<h4 id="_nil_any">3.4.1. Nil &amp; Any</h4>
<div class="paragraph">
<p><code>Nil</code> 是空值（不存在值）。</p>
</div>
<div class="paragraph">
<p>将其赋值给变量以将其重置为其默认（未定义）值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $b = &#34;b&#34;; $b = Nil;   # -&gt; (Any)
&gt; my Int $i = 4; $i = Nil; # -&gt; (Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用类型代替 <code>Nil</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my Int $i = 4; $i = Int; # -&gt; (Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你使用类型（强输入），则 <code>Any</code> 无效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = Any; # -&gt; (Any)

&gt; my Int $i = Any;
Type check failed in assignment to $i; expected Int but got Any (Any)

&gt; my Int $i = Nil; # -&gt; (Int)
&gt; my Int $i = Int; # -&gt; (Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>尝试输出未定义的值时要小心：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = Any; say $a; # -&gt; (Any)

&gt; my $a = Any; say &#34;: $a&#34;;
Use of uninitialized value of type Any in string context.</code></pre>
</div>
</div>
<div class="paragraph">
<p>详细信息, 请参见 &#34;6.3.1节的 say&#34;。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infinity">3.4.2. Infinity</h4>
<div class="paragraph">
<p><code>Inf</code> 是无穷大。 我们也可以使用 Unicode 无限符号 <code>∞</code>。</p>
</div>
<div class="paragraph">
<p>无穷大是一个我们无法表达的值，将永远遥不可及：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 100000000000000000000000000000000000000000000000000000 &gt; Inf
False</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以否定它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say -100000000000000000000000000000000000000000000000000000 &lt; -Inf
False</code></pre>
</div>
</div>
<div class="paragraph">
<p>不要将 <code>Inf</code> 视为数字。 它对于比较很有用，但是对其进行算术运算几乎没有用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; Inf + 1;    # -&gt; Inf
&gt; -Inf - 1;   # -&gt; -Inf
&gt; -Inf + Inf; # -&gt; NaN
&gt; Inf * 0;    # -&gt; NaN</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个证明 <code>1 == 0</code>。期望它不是，因为 <code>Inf</code> 不是数字，因此不能在表达式中使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_nannot_a_number">3.4.3. NaN(Not a Number)</h4>
<div class="paragraph">
<p>查看 5.10 章节, &#34;NaN(Not a Number)&#34;</p>
</div>
<div class="paragraph">
<p><strong>练习 3.1</strong></p>
</div>
<div class="paragraph">
<p>我们可以在一个 <code>Int</code> 中存储的最大数量是多少？</p>
</div>
<div class="paragraph">
<p>使用 <code>REPL</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_d定义副词">3.5. :D(定义副词)</h3>
<div class="paragraph">
<p>很显然，类型化变量接受指定类型的值。 但它也将接受默认值 <code>Nil</code>。 对于过程参数，通常不是一个好主意（有关详细信息，请参见第10章，过程），我们尚未对其进行讨论。</p>
</div>
<div class="paragraph">
<p>我们可以使用以下类型的 <code>:D</code>（表示«Defined»）副词来解决这个问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my Int:D $a;
===SORRY!=== Error while compiling:
Variable definition of type Int:D requires an initializer at line 2</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my Int:D $i = Nil
Type check failed in assignment to $i; expected type Int:D cannot be itself...

&gt; my Int:D $i = Int
Type check failed in assignment to $i; expected Int:D but got Int (Int) ...

&gt; my Int:D $i = Any
Type check failed in assignment to $i; expected Int:D but got Any (Any) ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有 <code>:D</code> 副词，上面的代码将起作用。</p>
</div>
<div class="sect3">
<h4 id="_uundefined_adverb">3.5.1. :U(Undefined Adverb)</h4>
<div class="paragraph">
<p>也可以在类型上带有 <code>:U</code>(即 «Undefined»)副词来禁止变量中的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">my Int:U $i;

&gt; $a = Nil
  (Int:U)

&gt; $a = Int
  (Int)

$a = 1
Type check failed in assignment to $a; expected Int:U but got Int (1)
  in block &lt;unit&gt; at &lt;unknown file&gt; line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是没有意义的，但是可以在过程的参数上使用一连串的内容，在这里我们使用类型而不是实际值。 但是我真的不推荐。</p>
</div>
</div>
<div class="sect3">
<h4 id="_defined">3.5.2. defined</h4>
<div class="paragraph">
<p>使用 <code>defined</code> 检查是否定义了一个值（有一个值）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say Int.defined; # -&gt; False
&gt; say 12.defined;  # -&gt; True

&gt; my $a; say $a.defined;     # -&gt; False
&gt; my $a = 1; say $a.defined; # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，还有一个 <code>DEFINITE</code> 方法可以提供几乎相同的结果。 我们将在“高级 Raku”课程中再次介绍它。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类型转换">3.6. 类型转换</h3>
<div class="paragraph">
<p>Raku 具有自动和手动类型强制（也称为转换）。</p>
</div>
<div class="sect3">
<h4 id="_自动类型转换">3.6.1. 自动类型转换</h4>
<div class="paragraph">
<p>如果可能，Raku 将自动将值转换为所需的类型。 但前提是我们没有使用强类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $string1 = &#34;12&#34;; my $string2 = &#34;13&#34;;
&gt; my $sum1 = $string1 + $string2; # Addition
25

&gt; $sum1.^name;
Int

&gt; my $sum2 = $string1 ~ $string2; # String concatenation
1213

&gt; $sum2.^name;
Str

&gt; my Int $a = 12; my Int $b = 13;
&gt; my $c = $a ~ $b;
1213

&gt; my Int $d = $a ~ $b;
Type check failed in assignment to $d; expected Int but got Str (&#34;1213&#34;)
    in block &lt;unit&gt; at &lt;unknown file&gt; line 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_手动类型转换">3.6.2. 手动类型转换</h4>
<div class="paragraph">
<p>当我们想要（并拥有）对类型的完全控制权时，手动类型强制与强类型结合很有用：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">转换为</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">前缀</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">关键字</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">函数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Numeric</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">.Numeric</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Numeric()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">.Str</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">~</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Str()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">.so 或 .Bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">so</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bool()</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>还有一个 <code>?^</code> 前缀运算符，可强制转换为布尔值并取反，而 <code>?^</code>（相同），<code>?|</code> 和 <code>?&amp;</code>  中缀运算符，它们执行逻辑 XOR，OR 和 AND 运算。</p>
</div>
<div class="paragraph">
<p>这些值必须可转换才能正常工作。</p>
</div>
<div class="paragraph">
<p><strong>Numeric / +</strong></p>
</div>
<div class="paragraph">
<p><code>Numeric</code> 或 <code>+</code> 前缀将转换为给定值的最佳数字类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;12&#34;.Numeric.^name    # -&gt; Int # Integer
&gt; &#34;12.1&#34;.Numeric.^name  # -&gt; Rat # Rational number
&gt; &#34;5e+10&#34;.Numeric.^name # -&gt; Num # Floating point

&gt; +(&#34;12&#34;).^name   # -&gt; Int
&gt; +(&#34;12.1&#34;).^name # -&gt; Rat

&gt; &#34;abc&#34;.Numeric
Cannot convert string to number: ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果可以确定我们想要的是什么，我们可以指定实际的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;12&#34;.Int.^name  # -&gt; Int # Integer
&gt; &#34;12&#34;.Rat.^name  # -&gt; Rat # Rational number
&gt; &#34;12&#34;.Num.^name  # -&gt; Num # Floating point
&gt; 12.1.Str.^name  # -&gt; Str # String; &#34;12.1&#34;
&gt; ~(12.1).^name   # -&gt; Str # String; &#34;12.1&#34; # Prefix ~</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是你将完全得到你想要的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;12.1&#34;.Int; # -&gt; 12</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Str / ~</strong></p>
</div>
<div class="paragraph">
<p>把数字转换为字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; 12.Str;
&gt; ~12;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关布尔型示例，请参见第2.11节&#34;True 和 False&#34;。</p>
</div>
<div class="paragraph">
<p>还有其他将值分类的方法。 有关详细信息，请参见6.3, &#34;输出&#34;。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用_try_阻止运行时错误">3.6.3. 使用 <code>try</code> 阻止运行时错误</h4>
<div class="paragraph">
<p>Raku 无法执行某些操作时，将发生运行时错误。 例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;AS&#34;.Int
Cannot convert string to number: ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以通过在表达式前面加上 <code>try</code> 来防止程序终止：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; try &#34;AS&#34;.Int
Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，程序有责任处理错误情况。 一些可能性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $text = &#34;AS&#34;;
&gt; try $possibly-an-int.Int;
Nil

&gt; try $possibly-an-int.Int // 0;
0</code></pre>
</div>
</div>
<div class="paragraph">
<p>小心零值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $zero = 0;
&gt; try $zero.Int;
0</code></pre>
</div>
</div>
<div class="paragraph">
<p>将 <code>try</code> 应用于非故障时，它将使该值保持不变。 因此返回零，如果在测试中使用它，我们将遇到问题。 例如。 这样，即使有整数，也不会执行 <code>if</code> 块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">my $zero = 0;
if try $zero.Int {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 <code>.defined</code> 方法来避免此问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $zero = 0;
&gt; say &#34;OK&#34; if try $zero.Int.defined; # -&gt; OK</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>try</code> 和 <code>$!</code> 将在&#34;高级 Raku&#34;课程中详细介绍。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_比较运算符">3.7. 比较运算符</h3>
<div class="paragraph">
<p>我们有常用的数字比较运算符及其字符串版本。 以及许多其他的：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Numeric</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Strings</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Smart</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Other</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">What</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">==</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">eq</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">before</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Less than</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⇐</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">le</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小于等于</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">gt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">after</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大于</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&gt;=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ge</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大于等于</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">!=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ne</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不等于</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;⇒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">leg</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cmp</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">三向比较</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">=:=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">容器相等; 查看 3.7.6 节, &#34;=:=&#34;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">===</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">值相等; 查看 3.7.7 节, &#34;===&#34;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">=~=</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">近似相等; 查看 5.11 节, &#34;=~=&#34;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>请注意，字符串比较区分大小写。 它无法识别字母，但会比较 Unicode 值。 因此，大写字母位于小写字母版本之前。</p>
</div>
<div class="paragraph">
<p>它们大多数都是直截了当的，但是我们将在以下各节中讨论最后一行（“三向比较”运算符）和“智能”列。</p>
</div>
<div class="sect3">
<h4 id="_cmp">3.7.1. cmp</h4>
<div class="paragraph">
<p><code>cmp</code>（如《比较》中所述）是多功能的三向比较运算符。</p>
</div>
<div class="paragraph">
<p>它比较具有字符串语义的字符串，具有数字语义的数字，首先按键比较，然后按值比较等。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (a =&gt; 3) cmp (a =&gt; 4); # -&gt; Less
&gt; say 4 cmp 4.0;             # -&gt; Same
&gt; say &#39;b&#39; cmp &#39;a&#39;;           # -&gt; More</code></pre>
</div>
</div>
<div class="paragraph">
<p>在数字上下文中，返回值为 <code>-1</code>（Less），<code>0</code>（Same）和 <code>1</code>（More）。</p>
</div>
<div class="paragraph">
<p><strong>unicmp</strong></p>
</div>
<div class="paragraph">
<p>有一个 <code>cmp</code> 的 <code>unicmp</code> 版本，它忽略了字符的大小写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;a&#34; unicmp &#34;B&#34;; # -&gt; Less
&gt; &#34;A&#34; unicmp &#34;b&#34;; # -&gt; Less</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们比较同一字母的小写和大写版本时，它并没有达到预期的效果。 小写版本被认为小于大写版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;A&#34; unicmp &#34;a&#34;; # -&gt; More
&gt; &#34;A&#34; unicmp &#34;A&#34;; # -&gt; Same
&gt; &#34;a&#34; unicmp &#34;A&#34;; # -&gt; Less</code></pre>
</div>
</div>
<div class="paragraph">
<p>但这意味着我们可以实际使用它进行排序，并获得可预测的结果。</p>
</div>
<div class="paragraph">
<p><code>unicmp</code> 的排序规则感知版本称为 <code>coll</code>。 它将在《高级 Raku》课程中介绍。</p>
</div>
</div>
<div class="sect3">
<h4 id="_leg">3.7.2. leg</h4>
<div class="paragraph">
<p><code>leg</code>（如 «Less, Equal or Greater» 中所述）是 <code>cmp</code> 的仅字符串版本(请参见第3.7.1节&#34;cmp&#34;)。</p>
</div>
<div class="paragraph">
<p>比较之前，非字符串值将转换为字符串。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#39;a&#39; leg &#39;b&#39;; # -&gt; Less
&gt; say &#39;a&#39; leg &#39;a&#39;; # -&gt; Same
&gt; say &#39;b&#39; leg &#39;a&#39;; # -&gt; More</code></pre>
</div>
</div>
<div class="paragraph">
<p>在数字上下文中，返回值为 <code>-1</code> (Less), <code>0</code> (Same) 和 <code>1</code> (More)。</p>
</div>
<div class="paragraph">
<p>比较 <code>cmp</code> 和 <code>leg</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; 11 leg 2; # -&gt; Less
&gt; 11 cmp 2; # -&gt; More</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_2">3.7.3. &lt;⇒</h4>
<div class="paragraph">
<p><code>&lt;⇒</code> 是 <code>cmp</code> 的数字版本(请参见第3.7.1节&#34;cmp&#34;)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 1 &lt;=&gt; 2;   # -&gt; Less
&gt; say 2 &lt;=&gt; 2.0; # -&gt; Same
&gt; say 2 &lt;=&gt; 1;   # -&gt; More</code></pre>
</div>
</div>
<div class="paragraph">
<p>非数字值会在比较之前转换为数字，如果无法进行转换，则会出现错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; 2 &lt;=&gt; &#34;sj&#34;
Cannot convert string to number: ...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_before">3.7.4. before</h4>
<div class="paragraph">
<p><code>before</code> 运算符的行为类似于 <code>cmp</code>（请参见第 3.7.1 节&#34;cmp&#34;），不同之处在于，如果第一个参数位于（小于）第二个参数之前，则返回 <code>True</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; 1 before 1;         # -&gt; False
&gt; 1 before 2;         # -&gt; True
&gt; 111 before 21;      # -&gt; False
&gt; &#34;111&#34; before &#34;21&#34;;  # -&gt; True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_after">3.7.5. after</h4>
<div class="paragraph">
<p><code>after</code> 运算符的行为与 <code>cmp</code> 相同(请参见第3.7.1节&#34;cmp&#34;)，但如果第一个参数在第二个参数之后（大于），则返回 <code>True</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;ab&#34; after &#34;aaaa&#34;; # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 3.2</strong></p>
</div>
<div class="paragraph">
<p>解释为什么我们从第一个得到 <code>False</code>，而从第二个得到 <code>True</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; 111 before 21;     # -&gt; False
&gt; &#34;111&#34; before &#34;21&#34;; # -&gt; True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_3">3.7.6. =:=</h4>
<div class="paragraph">
<p>使用容器标识运算符 <code>=:=</code> 来确定两个参数是否都绑定到同一容器。 如果返回 <code>True</code>，则通常意味着修改一个也会修改另一个。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = 42;
&gt; my $b = $a;
&gt; $a =:= $b; # -&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们对 2.6.2 节&#34;=:=(Binding)&#34;中的前两个代码块应用 <code>=:=</code>，以表明它可以识别绑定：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = 42;
&gt; my $b := $a;
&gt; $a =:= $b; # -&gt; True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_4">3.7.7. ===</h4>
<div class="paragraph">
<p>使用值标识运算符 <code>===</code> 来检查两个参数是否是相同的对象或值，而无需考虑任何容器化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = 3;  # -&gt; 3
&gt; my $b := 3; # -&gt; 3
&gt; $a === $b;  # -&gt; True
&gt; 1 === 1.0;  # -&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p>在值上使用（如此处所做）时，<code>===</code> 的行为与 <code>eqv</code> 相同。</p>
</div>
<div class="paragraph">
<p>有关在对象上使用 <code>===</code> 的描述，请参见第17.9.2节&#34;===&#34;。 我们可以使用类型对象来检查变量或值的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = 12; $a.WHAT === Int; # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>这不适用于 <code>^name</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = 12; $a.^name === Int; # -&gt; False</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_isa">3.7.8. isa</h4>
<div class="paragraph">
<p><code>isa</code> 方法更好，因为它避免了 <code>WHAT</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = 12; $a.isa(Int); # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以使用智能匹配来检查类型。 请参见第9.16.2节&#34;使用智能匹配&#34;。</p>
</div>
</div>
<div class="sect3">
<h4 id="_buttrue_和_false_but">3.7.9. but(True 和 False, but …​)</h4>
<div class="paragraph">
<p>我们可以使用 <code>but</code> 关键字更改将非布尔值转换为布尔值的方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = &#34;Hi&#34; but False; # -&gt; Hi
&gt; say $a;                 # -&gt; Hi
&gt; say so $a;              # -&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以像 «yes, but…​» 一样阅读它</p>
</div>
<div class="paragraph">
<p><code>but</code> 子句是当前值（而不是变量）的一部分，如果我们更改值，它将丢失：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $c = 156 but False; # -&gt; 156
&gt; say so $c;             # -&gt; False
&gt; $c++;                  # -&gt; 157
&gt; say so $c;             # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>可能（但不明智）在 <code>but</code> 关键字之后将其与非布尔值一起使用。 这应该是所有可能的组合（基本类型为string/number/Boolean）：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;"/>
<col style="width: 16.6666%;"/>
<col style="width: 16.6666%;"/>
<col style="width: 16.6666%;"/>
<col style="width: 16.6666%;"/>
<col style="width: 16.667%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">my $x =</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$x.Str</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$x.Int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$x.Bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+$x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$x + 0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10 but 0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10 but &#39;ten&#39;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ten</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ten</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ten</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10 but False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10 but True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0 but 10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0 but &#39;ten&#39;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ten</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ten</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ten</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0 but False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0 but True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#39;ten&#39; but 0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ten</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#39;ten&#39; but 10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ten</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#39;ten&#39; but False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ten</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#39;ten&#39; but True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ten</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">True but 0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">True but 10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">True but &#39;ten&#39;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ten</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">True but False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">False but 0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">False but 10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">False but &#39;ten&#39;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ten</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">False but True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Error</strong> 表示运行时错误（和程序终止）。</p>
</div>
<div class="paragraph">
<p>表格中的某些值没有太大意义。 但是问题是输入。 只要我们按预期使用它，然后在 <code>but</code> 后面的布尔值后面加上一个布尔值，那么它就会按预期工作。</p>
</div>
<div class="paragraph">
<p>该程序用于制作此表，并尝试防止由于错误而终止程序：</p>
</div>
<div class="listingblock">
<div class="title">文件: but</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;\$x = |\$x.Str |\$x.Int |\$x.Bool|+\$x |\$x+0&#34;;
say &#34;----------------+-------+-------+-------+-------+----&#34;;

print-it(&#34;10 but 0&#34;,     10 but 0);
print-it(&#34;10 but &#39;ten&#39;&#34;, 10 but &#39;ten&#39;);
print-it(&#34;10 but False&#34;, 10 but False);
print-it(&#34;10 but True&#34;,  10 but True);

print-it(&#34;0 but 10&#34;,    0 but 10);
print-it(&#34;0 but &#39;ten&#39;&#34;, 0 but &#39;ten&#39;);
print-it(&#34;0 but False&#34;, 0 but False);
print-it(&#34;0 but True&#34;,  0 but True);

print-it(&#34;&#39;ten&#39; but 0&#34;,     &#39;ten&#39; but 0);
print-it(&#34;&#39;ten&#39; but 10&#34;,    &#39;ten&#39; but 10);
print-it(&#34;&#39;ten&#39; but False&#34;, &#39;ten&#39; but False);
print-it(&#34;&#39;ten&#39; but True&#34;,  &#39;ten&#39; but True);

print-it(&#34;True but 0&#34;, True but 0);
print-it(&#34;True but 10&#34;, True but 10);
print-it(&#34;True but &#39;ten&#39;&#34;, True but &#39;ten&#39;);
print-it(&#34;True but False&#34;, True but False);

print-it(&#34;False but 0&#34;, False but 0);
print-it(&#34;False but 10&#34;, False but 10);
print-it(&#34;False but &#39;ten&#39;&#34;, False but &#39;ten&#39;);
print-it(&#34;False but True&#34;, False but True);

sub print-it ($label, $expression) {
    print $label, &#34;\t|&#34;;
    print trap-it($expression.Str), &#34;\t|&#34;;
    print trap-it($expression.Int), &#34;\t|&#34;;
    print trap-it($expression.Bool), &#34;\t|&#34;;
    print trap-it(+$expression), &#34;\t|&#34;;
    print trap-zero($expression);
    say &#34;&#34;;
}

sub trap-it ($expression) {
    my $result;
    try { $result = $expression.gist; }

    return $!
      ?? &#34;ERR&#34;
      !! $result;
}

sub trap-zero ($expression) {
    my $result;
    try { $result = ($expression + 0).gist; }

    return $!
      ?? &#34;ERR&#34;
      !! $result;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>错误变量 <code>$!</code> 包含错误对象（如果我们包装在 <code>try</code> 中的代码失败）。 在布尔上下文中，它告诉我们是否有错误。 在字符串上下文中，它给出错误消息。</p>
</div>
</div>
<div class="sect3">
<h4 id="_does">3.7.10. does</h4>
<div class="paragraph">
<p><code>does</code> 关键字类似于 <code>but</code>。 区别在于确实会将其添加到给定的变量中，而将其应用于它的副本。</p>
</div>
<div class="paragraph">
<p>因此正常赋值的工作原理是相同的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = &#34;Hi&#34; but False; say $a.^name;  # -&gt; Str+{&lt;anon|6&gt;}
&gt; my $b = &#34;Hi&#34; does False; say $b.^name; # -&gt; Str+{&lt;anon|7&gt;}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = &#34;Hi&#34;; $a but False; say $a.^name;  # -&gt; Str
&gt; my $b = &#34;Hi&#34;; $b does False; say $b.^name; # -&gt; Str+{&lt;anon|9&gt;}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将 <code>but</code> 应用于 <code>$a</code> 的副本，由于未将其赋值给变量，因此该值被丢弃。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_控制流">4. 控制流</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本章中，我们将从常规的自上而下讨论用于更改执行流程的语句。</p>
</div>
<div class="sect2">
<h3 id="_块儿">4.1. 块儿</h3>
<div class="paragraph">
<p>块是被视为一个整体的代码的集合。 一对花括号内设置了块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    # This is a block
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_范围简介">4.2. 范围(简介)</h3>
<div class="paragraph">
<p>Raku 中的范围是连续递增的整数的集合。 范围 <code>1 .. 10</code> 包含从1到10的所有整数。</p>
</div>
<div class="paragraph">
<p><code>..</code> 运算符给出范围（而不是列表）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1 .. 5).^name
Range

&gt; say (1 .. 5) 1..5</code></pre>
</div>
</div>
<div class="paragraph">
<p>范围是惰性的，因此只有在实际需要时才计算各个值。</p>
</div>
<div class="paragraph">
<p>从10（但不包括，所以从11）到100万：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (10 ^.. 1_000_000)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们也可以排除最后一个值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (10 ..^ 1_000_000)</code></pre>
</div>
</div>
<div class="paragraph">
<p>起始值和结束值均不包括在内：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (10 ^..^ 1_000_000)</code></pre>
</div>
</div>
<div class="paragraph">
<p>(将 <code>^</code> 字符读为 «up to/from，但不包括»。)</p>
</div>
<div class="paragraph">
<p><code>^</code> 是范围运算符的一部分，而不是值！
这就是为什么 <code>^</code> 和范围运算符之间不能有任何空格的原因。
如果需要，我们可以使用此简短格式。 例如取 10 个值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @values = ^10;
[0 1 2 3 4 5 6 7 8 9]</code></pre>
</div>
</div>
<div class="paragraph">
<p>它从零开始并递增。</p>
</div>
</div>
<div class="sect2">
<h3 id="_loop">4.3. loop</h3>
<div class="paragraph">
<p><code>loop</code> 语句是其他语言所熟知的经典 «for» 循环。 它需要三个由分号分隔的语句：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; loop (my $i = 0; # The initial value
&gt;       $i &lt; 10;   # The test to decide if the loop should be stopped
&gt;       $i++)      # The incrementer
&gt; { print $i; }
&gt; print &#34;\n&#34;;
0123456789</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，如此处所做的那样，可以将 <code>my</code> 用作引入新变量作为循环计数器，也可以使用在循环外部定义的变量。 但是副作用是我们改变了它的值。</p>
</div>
<div class="paragraph">
<p>可以跳过最后一部分（增量器）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; loop (my $i = 0; $i++ &lt; 10;) { say $i; }
1
2
3
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>但这可能会引起细微的变化（不同的起始值），如上所示。</p>
</div>
<div class="paragraph">
<p>语句必须在括号中指定。</p>
</div>
<div class="paragraph">
<p>我们可以遍历这样的数组：</p>
</div>
<div class="listingblock">
<div class="title">文件: loop-array</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = &lt;A B C D E F G H I J K L&gt;;

loop (my $i = 0; $i &lt; @a.elems; $i++) {
    print &#34;|&#34;, @a[$i];
}

print &#34;\n&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku loop-array
|A|B|C|D|E|F|G|H|I|J|K|L</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一行是一个由单个字符组成的数组。 如第2.7.1节&#34;字符串&#34;中所述。</p>
</div>
<div class="paragraph">
<p>我们本可以这样写的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = &#34;A&#34; .. &#34;L&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>大量代码要遍历数组，很容易使索引错误（通常为1）。 但是，我们有一种更有效的方式来执行此操作，我们将在下一部分中进行演示。</p>
</div>
</div>
<div class="sect2">
<h3 id="_for">4.4. for</h3>
<div class="paragraph">
<p><code>for</code> 循环是最常用的循环类型，几乎可以用于任何循环。</p>
</div>
<div class="paragraph">
<p>上一节中的 «loop-array» 程序可以这样编写得紧凑得多：</p>
</div>
<div class="listingblock">
<div class="title">文件: for-array</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = &lt;A B C D E F G H I J K L&gt;;

for @a -&gt; $elem {
    print &#34;|&#34;, $elem;
}

print &#34;\n&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>→</code> 语法在以下代码块中引入了局部变量（隐式 <code>my</code> 变量），该变量包含数组中的每个值。</p>
</div>
<div class="paragraph">
<p>运行它给出相同的结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku for-array
|A|B|C|D|E|F|G|H|I|J|K|L</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意区别； 这里我们迭代实际值，而不是索引。</p>
</div>
<div class="paragraph">
<p>还要注意，我们获得了该值的只读版本，因此尝试更改它将会失败：</p>
</div>
<div class="listingblock">
<div class="title">文件: for-array-error (partial)</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">print &#34;|&#34;, $elem; $elem ~= &#34;.&#34;;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot assign to a readonly variable or a value in block &lt;unit&gt; at ./for-array-error line 7</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 4.1</strong>
该程序的输出是什么？</p>
</div>
<div class="listingblock">
<div class="title">文件: for-array2</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = &lt;A B C D E F G H I J K L&gt;;

my $elem = 99;

for @a -&gt; $elem {
    ; # Do nothing
}

say $elem;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_for_作为计数器">4.4.1. for 作为计数器</h4>
<div class="paragraph">
<p>我们也可以执行特定次数的循环。 第4.2节&#34;范围（简短介绍）&#34;中描述的范围简短形式非常适合迭代：</p>
</div>
<div class="listingblock">
<div class="title">文件: for-school</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">for ^5 {
    say &#34;I like school.&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">I like school.
I like school.
I like school.
I like school.
I like school.</code></pre>
</div>
</div>
<div class="paragraph">
<p>索引是0到4（而不是1到5），但是由于我们不在表达式中使用它们并不重要。</p>
</div>
<div class="paragraph">
<p><strong>练习 4.2</strong></p>
</div>
<div class="paragraph">
<p>这个程序的输出是什么:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 5 {
    say &#34;I like school.&#34;;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_主题变量">4.4.2. <code>$_</code>(主题变量)</h4>
<div class="paragraph">
<p>«主题变量» <code>$_</code> 是没有显式签名的块的默认参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;a b c&gt; { say $_ } # sets $_ to &#39;a&#39;, &#39;b&#39; and &#39;c&#39; in turn
say $_ for &lt;a b c&gt;;    # same, even though it&#39;s not a block</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常最好使用显式变量（具有第4.4节&#34;for&#34;中所述的→语法），只要该变量具有良好的名称即可。</p>
</div>
<div class="paragraph">
<p>可以通过省略变量名来缩短在 <code>$_</code> 上调用方法的时间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say; # same as $_.say</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们不能使用显式块变量，例如 <code>→ $val</code>，在块外：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; $val.say for (1 .. 10) -&gt; $val
===SORRY!=== Error while compiling: Variable &#39;$val&#39; is not declared.
Did you mean &#39;&amp;val&#39;?
------&gt; &lt;BOL&gt;⏏$val.say for (&#34;aa&#34; .. &#34;bb&#34;) -&gt; $val</code></pre>
</div>
</div>
<div class="paragraph">
<p>问题是 <code>→ $val</code> 仅在以下块中可用。 但是我们在块之前使用了很长时间，并且块丢失了。</p>
</div>
<div class="paragraph">
<p>这有效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (1 .. 10) -&gt; $val {
    $val.say;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_后缀_for">4.4.3. 后缀 for</h4>
<div class="paragraph">
<p>如果只有一个表达式，则可以使用 <code>for</code> 的后缀版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;Country: $_&#34; for @countries;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，&#34;一个表达式&#34;也可以表示一个块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; { .say; .say } for 1 .. 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者我们可以用圆括号将表达式分组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; ( .say; .say ) for 1 .. 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是我不建议这样使用。</p>
</div>
<div class="paragraph">
<p>块中的最后一条语句不需要结尾的分号，但添加一条也无害。</p>
</div>
<div class="paragraph">
<p>我们可以遍历一个范围：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 1 .. 10 -&gt; $i {
    say $i;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你已经有 <code>$i</code> 变量，它将被隐藏在 <code>for</code> 主体中，但之后将再次使用原始值。</p>
</div>
<div class="paragraph">
<p>范围短形式 <code>^10</code> 在10次迭代循环中很方便。 它与 <code>0 ..^ 10</code> 和 <code>0 .. 9</code> 相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">do-something($_) for 1 .. 10; # 1 .. 10 # 10 iterations
do-something($_) for ^10; # 0 .. 9      # 10 iterations</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要你不依赖于1到10的值即可。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_无限循环">4.5. 无限循环</h3>
<div class="paragraph">
<p>这些都是一样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for 1 .. Inf
.say for 1 .. ∞
.say for 1 .. *
.say for ^Inf</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，我们必须使用 <code>^Inf</code> 来获取 Range。 一个 <code>Inf</code> 只是一个值，循环只会运行一次。</p>
</div>
<div class="paragraph">
<p>另请注意，最后一个从零开始。</p>
</div>
<div class="paragraph">
<p>或者，如果不需要计数器，则可以使用不带参数的 <code>loop</code>（并且可以省略括号）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop { say &#39;forever&#39; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>无限循环应具有退出策略。 我们将在第4.17.3节&#34;last&#34;中讨论 <code>last</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_while">4.6. while</h3>
<div class="paragraph">
<p>只要给定条件为 true，<code>while</code> 语句就会执行该块。</p>
</div>
<div class="listingblock">
<div class="title">文件: while</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 1;

while $x &lt; 4 {
    print $x++;
}

print &#34;\n&#34;;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku while
123</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>while</code> 也可以用作语句修饰符：</p>
</div>
<div class="listingblock">
<div class="title">文件: while2</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 1;

print $x++ while $x &lt; 4;

print &#34;\n&#34;;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku while2
123</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出是相同的，因为在执行 <code>print</code> 语句之前已经测试了条件。</p>
</div>
</div>
<div class="sect2">
<h3 id="_until">4.7. until</h3>
<div class="paragraph">
<p><code>until</code> 语句是带有否定测试的 <code>while</code> 语句。 只要表达式为假，它将执行该块：</p>
</div>
<div class="listingblock">
<div class="title">文件: until</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 1;

until $x &gt; 3 {
    print $x++;
}

print &#34;\n&#34;;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku until
123</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>until</code> 也能用于语句修饰符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">my $i = 0;
say &#34;Hello&#34; until $i++ &gt; 10;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_repeat_while">4.8. repeat while</h3>
<div class="paragraph">
<p><code>repeat { …​ } while</code> 语句的末尾有测试。 结果是该块至少执行一次。 只要条件成立，就会发生另一次重复。</p>
</div>
<div class="listingblock">
<div class="title">文件: repeat-while</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 5;
repeat {
    print $x++;
} while $x &lt; 1;

print &#34;\n&#34;;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku repeat-while
5</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以将 <code>repeat</code> 和 <code>while</code> 语句放在开头：</p>
</div>
<div class="listingblock">
<div class="title">文件: repeat-while2</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 5;

repeat while $x &lt; 1 {
    print $x++;
}

print &#34;\n&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使放在最前面，该条件仍会在循环结束时进行计算。</p>
</div>
</div>
<div class="sect2">
<h3 id="_repeat_until">4.9. repeat until</h3>
<div class="paragraph">
<p><code>repeat {…​} until</code> 语句是带有否定测试的 <code>repeat {…​} while</code> 语句。 它将至少执行一次该块，然后执行一次，只要表达式为 <code>False</code>：</p>
</div>
<div class="listingblock">
<div class="title">文件: repeat-until</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 5;

repeat {
    print $x++;
} until $x &gt; 1;

print &#34;\n&#34;;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku repeat-until
5</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以将 <code>repeat</code> 和 <code>until</code> 语句放在开头：</p>
</div>
<div class="listingblock">
<div class="title">文件: repeat-until2</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 5;

repeat until $x &gt; 1 {
    print $x++;
}

print &#34;\n&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使放在最前面，该条件仍会在循环结束时进行计算。</p>
</div>
</div>
<div class="sect2">
<h3 id="_循环总结">4.10. 循环总结</h3>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">结构</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">查看所在章节</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">总是执行一次</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">loop</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.3, &#34;loop&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">for …​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.4, &#34;for&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">…​ for</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.4.3, &#34;Postfix for&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">while …​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.6, &#34;while&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">…​ while</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.6, &#34;while&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">until …​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.7, &#34;until&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">…​ until</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.7, &#34;until&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">repeat …​ while</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.8, &#34;repeat while&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">repeat while …​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.8, &#34;repeat while&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">repeat …​ until</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.9, &#34;repeat until&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">repeat until …​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.9, &#34;repeat until&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_if">4.11. if</h3>
<div class="paragraph">
<p>我们可以使用 <code>if</code> 语句有条件地执行一次块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $hour == 17 {
    say &#34;Time to go home&#34;;
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_elsif">4.11.1. elsif</h4>
<div class="paragraph">
<p>我们可以有几个条件:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $hour == 17 {
    say &#34;Time to go home&#34;;
} elsif $hour == 8 {
    say &#34;Time to go to work&#34;;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_else">4.11.2. else</h4>
<div class="paragraph">
<p>我们可以添加一个 <code>else</code> 块，如果 <code>if</code> 和 <code>elsif</code> 都不匹配则执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $time == 17 {
    say &#34;Time to go home&#34;;
} elsif $time == 8 {
    say &#34;Time to go to work&#34;;
} else {
    say &#34;Stay put!&#34;;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_unlesss">4.11.3. unlesss</h4>
<div class="paragraph">
<p>使用 <code>unless</code> 来否定 if-test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;Not OK&#34; if not $a;
say &#34;Not OK&#34; unless $a; # The same</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>unless</code> 不支持 <code>else</code> 和 <code>elsif</code>，否则生成的代码将难以理解。 （不，那根本不是假的。）</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_given">4.12. given</h3>
<div class="paragraph">
<p>我们可以使用 <code>given</code> 给块儿设置 <code>$_</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; $_ = 12;
&gt; .say;          # -&gt; 12
&gt; .say given 13; # -&gt; 13
&gt; .say;          # -&gt; 12

&gt; given &#39;a&#39; { say $_ }; # sets $_ to &#39;a&#39;
&gt; say $_ given &#39;a&#39;;     # same, even though it&#39;s not a block</code></pre>
</div>
</div>
<div class="paragraph">
<p>在执行块或（在这种情况下）前缀语句之后，将恢复旧值（如果有）。</p>
</div>
<div class="paragraph">
<p><code>given</code> 也可以用来形成类似 switch 的语句（与 <code>when</code> 结合使用）； 它将在&#34;高级 Raku&#34;课程中介绍。</p>
</div>
</div>
<div class="sect2">
<h3 id="_with">4.13. with</h3>
<div class="paragraph">
<p><code>with</code> 语句就像 <code>if</code>，但是测试定义性而不是真实性。 此外，它还对条件进行了主题化（将 <code>$_</code> 设置为值）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;OK&#34; if 0;         # -&gt; ()
&gt; say &#34;OK&#34; with 0;       # -&gt; OK
&gt; with 12 { .^name.say } # -&gt; Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>尝试输出未定义的值(<code>Any</code>，<code>Nil</code> 和 <code>Int</code>)在字符串中失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = Any;
&gt; say &#34;Not OK: $a;
Use of uninitialized value of type Any in string context.
Methods .^name, .perl, .gist, or .say can be used to stringify it to something meaningful.</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以我们可以使用 <code>with</code> 来检测它们:</p>
</div>
<div class="listingblock">
<div class="title">文件: with</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (0, &#34;2&#34;, Any, Nil, Int, pi, &#34;hello&#34;) -&gt; $input {
    with $input {
        say &#34;OK: $_&#34;;
    } else {
      say &#34;Not OK: undefined value&#34;;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku with
OK: 0
OK: 2
Not OK: undefined value
Not OK: undefined value
Not OK: undefined value
OK: 3.141592653589793
OK: hello</code></pre>
</div>
</div>
<div class="paragraph">
<p>它提到的错误消息是说一种方法。 让我们尝试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a; $a.say; # -&gt; (Any)</code></pre>
</div>
</div>
<div class="paragraph">
<p>请参见第6.3节&#34;输出&#34;，以获取有关为什么 <code>say</code> 对未定义值起作用的讨论，但对在字符串中内插时不起作用的讨论。</p>
</div>
<div class="paragraph">
<p>因此，我们相应地重写了代码：</p>
</div>
<div class="listingblock">
<div class="title">文件: with</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (0, &#34;2&#34;, Any, Nil, Int, pi, &#34;hello&#34;) -&gt; $input {
    with $input { say &#34;OK: $_&#34;; }
    else { print &#34;Not OK: &#34;; .say; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我已将 <code>else</code> 中的 <code>say</code> 更改为 <code>print</code> 以避免额外的换行符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku with2
OK: 0
OK: 2
Not OK: (Any)
Not OK: Nil
Not OK: (Int)
OK: 3.141592653589793
OK: hello</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_given_vs_with">4.13.1. given vs. with</h4>
<div class="paragraph">
<p><code>given</code>(请参阅第4.12节&#34;given&#34;)和 <code>with</code> 语句修饰符的使用有些相似：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">表达式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">given</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">with</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.say XXX 12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.say XXX 0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.say XXX Nil</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nil</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.say XXX Any</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.say XXX NaN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NaN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">()</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>仅当我们提供未定义的值时它们才有所不同：<code>given</code> 返回未定义的值，而 <code>with</code> 返回空列表。</p>
</div>
<div class="paragraph">
<p>请勿使用 <code>with</code> 作为语句修饰符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_orwith">4.13.2. orwith</h4>
<div class="paragraph">
<p><code>with</code> 具有 <code>orif</code>，就像 <code>if</code> 具有 <code>elsif</code>：</p>
</div>
<div class="listingblock">
<div class="title">文件: orwith</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for ( 0, &#34;2&#34;, 3/11, pi, &#34;hello&#34;) -&gt; $input {
    with   $input.Numeric { say &#34;Number: $input&#34;;     }
    orwith $input.Str     { say &#34;Str: $input&#34;;        }
    else                  { say &#34;??: &lt;unknown type&gt;&#34;; }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku orwith
Number: 0
Number: 2
Number: 0.272727
Number: 3.141592653589793
Str: hello</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们写一个数字，如果可能的话，将数值转换成数字。 如果没有，我们尝试将其转换为字符串。 这适用于所有定义的值，因此永远不会使用 <code>else</code> 部分。</p>
</div>
<div class="paragraph">
<p>(如果我们通过了例如 <code>Any</code>，则对于 <code>else</code> 部分，<code>with</code> 条件会导致运行时错误。)</p>
</div>
<div class="paragraph">
<p>我们可以混合基于 <code>if</code> 和 <code>with</code> 的子句。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># This says &#34;Yes&#34;
if 0 { say &#34;No&#34; } orwith Nil { say &#34;No&#34; } orwith 0 { say &#34;Yes&#34; };</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_without">4.13.3. without</h4>
<div class="paragraph">
<p><code>without</code> 和 <code>with</code> 的关联与 <code>unless</code> 与 `if `的关联相同：否定测试。</p>
</div>
<div class="listingblock">
<div class="title">文件: without</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (1, &#34;2&#34;, Any, Nil, Int, pi, &#34;hello&#34;) -&gt; $input {
    without $input { print &#34;Not OK: &#34;; .say: }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku without
Not OK: (Any)
Not OK: Nil
Not OK: (Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有 <code>else</code> 子句，原因与 <code>unless</code> 子句相同。</p>
</div>
<div class="paragraph">
<p>我们也可以使用 <code>with</code> 和 <code>without</code> 作为语句修饰符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $variable = 12; say &#34;$_ is of type { .^name } with $variable;
12 is of type Int

&gt; my $answer; say &#34;undefined answer&#34; without $answer;
undefined answer</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_5">4.14. ?? !!</h3>
<div class="paragraph">
<p>这是一个紧凑的 if-then-else:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = $y == True ?? 5 !! 4;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果表达式位于 <code>??</code> 的左侧 计算第一个参数(在 <code>??</code> 之后) 为 <code>True</code>，否则使用第二个参数(在 <code>!!</code> 之后)。</p>
</div>
<div class="paragraph">
<p>或者，以通常的详细方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x; if $y == True { $x = 5; } else { $x = 4; }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_do">4.15. do</h3>
<div class="paragraph">
<p><code>do</code> 是一个块构造，返回块内的最后一条语句。</p>
</div>
<div class="paragraph">
<p>我们可以像这样使用 <code>do</code> 来缩短前一段代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = do { if $y == True { 5; } else { 4; } }</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者甚至更紧凑:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = do { $y == True ?? 5 !! 4; }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_when">4.16. when</h3>
<div class="paragraph">
<p><code>when</code> 块看起来与 <code>if</code> 块相似，但是行为略有不同。</p>
</div>
<div class="paragraph">
<p>我们从常规的 <code>if</code> 块开始：</p>
</div>
<div class="listingblock">
<div class="title">文件: if-when (partial)</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for True, False {
    if $_ { say &#34;if $_&#34;; } ① ③
    say &#34;if $_ 2&#34;; ② ④
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>① True → Executed
② True → Always executed
③ False → Not executed
④ False → Always executed</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku if-when
if True
if True 2
if False 2</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>when</code> 块的行为有所不同，因为紧随其后的代码在同一块级别中被视为隐式 <code>else</code> 块：</p>
</div>
<div class="listingblock">
<div class="title">文件: if-when (partial)</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">for True, False {
    when $_ { say &#34;when $_&#34;; } ① ③
    say &#34;when $_ 2&#34;; ② ④
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>① True → Executed
② True → Not executed because «1» was
③ False → Not executed
④ False → Executed because «3» was not</p>
</div>
<div class="paragraph">
<p>我不得不使用 <code>so</code> 来避免警告。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku if-when
when True
when False 2</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_循环操纵">4.17. 循环操纵</h3>
<div class="paragraph">
<p>我们可以早点退出循环，跳过迭代或再次循环。</p>
</div>
<div class="sect3">
<h4 id="_once">4.17.1. once</h4>
<div class="paragraph">
<p>带有 <code>once</code> 前缀的块将只执行一次，即使它位于循环或递归例程中也是如此：</p>
</div>
<div class="listingblock">
<div class="title">文件: for-once</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">for ^5 {
    once { say &#34;once&#34;; }
    say &#34;many ($_)&#34;;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku for-once
once
many (0)
many (1)
many (2)
many (3)
many (4)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 <code>FIRST</code> 移相器实现相同的目的（我们将在&#34;高级 Raku&#34;课程中再次介绍它。）</p>
</div>
</div>
<div class="sect3">
<h4 id="_next">4.17.2. next</h4>
<div class="paragraph">
<p><code>next</code> 命令开始循环的下一个迭代：</p>
</div>
<div class="listingblock">
<div class="title">文件: for-next</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for ^5 {
    next if $_ == 2;
    say &#34;many ($_)&#34;;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku for-next
many (0)
many (1)
many (3)
many (4)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_last">4.17.3. last</h4>
<div class="paragraph">
<p><code>last</code> 命令立即退出循环:</p>
</div>
<div class="listingblock">
<div class="title">文件: for-last</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for ^Inf {
    last if $_ == 5;
    say &#34;many ($_)&#34;;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku for-last
many (0)
many (1)
many (2)
many (3)
many (4)</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>last</code> 给出的表达式。 如果该值从未达到 <code>5</code>，则将发生无限循环。 （就如 <code>last if $_ == 4.5</code>)。</p>
</div>
<div class="paragraph">
<p>也可以使用 <code>die</code> 或 <code>exit</code>（将在&#34;高级 Raku&#34;课程中进行说明）退出循环，但它们也将终止程序。</p>
</div>
<div class="paragraph">
<p><strong>练习 4.3</strong>
编写一个程序，计算从1到向上的所有整数的和，直到和达到指定的上限（例如1000），并显示最后一个达到或超过极限的整数。</p>
</div>
<div class="paragraph">
<p>提示：使用无限循环，然后使用 <code>last</code> 退出该循环。</p>
</div>
<div class="paragraph">
<p>对于1000，输出可以是：«在值45处达到限制1000（1035）。»</p>
</div>
</div>
<div class="sect3">
<h4 id="_redo">4.17.4. redo</h4>
<div class="paragraph">
<p><code>redo</code> 命令重新启动循环块，而无需再次计算条件。</p>
</div>
<div class="listingblock">
<div class="title">文件: loop-redo</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sum;

for 1 .. 1000 -&gt; $i {
    $sum += $i;
    redo if $sum.is-prime;
}

say &#34;Sum: $sum&#34;;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku loop-redo
Sum: 546089</code></pre>
</div>
</div>
<div class="paragraph">
<p>此处发生的是，如果总和是质数，我们将数字加1至1000，然后第二次（或更多）相加（请参见第5.12节&#34;is-prime(素数)&#34;)。</p>
</div>
<div class="paragraph">
<p>如果没有 <code>redo</code>，我们将得到 «500500»。(这很容易用 <code>sum</code> 来计算(请参见第9.16.1节&#34;«sum»方法&#34;)：<code>sum(1 .. 1000)</code>。)</p>
</div>
</div>
<div class="sect3">
<h4 id="_label">4.17.5. LABEL</h4>
<div class="paragraph">
<p>所有循环结构(<code>while</code>，<code>until</code>，<code>loop</code> 和 <code>for</code>)都可以有一个标签，用于标识它们的 <code>next</code>，<code>last</code> 和 <code>redo</code>。 如果我们有嵌套循环，这将很有用，因为否则这些语句仅适用于同一作用域。</p>
</div>
<div class="listingblock">
<div class="title">文件: loop-labels</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">FIRST-ONE:
for 1 .. 20 -&gt; $a {
    NEXT-ONE: for 0 .. 2 -&gt; $b {
        next FIRST-ONE if ($a + $b).is-prime;
        next NEXT-ONE if ($a + $b) % 3;
        say &#34;$a -&gt; $b&#34;;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku loop-labels
6 -&gt; 0
8 -&gt; 1
9 -&gt; 0
12 -&gt; 0
14 -&gt; 1
15 -&gt; 0
18 -&gt; 0
20 -&gt; 1</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 4.4</strong></p>
</div>
<div class="paragraph">
<p>在第4.17.1节&#34;once&#34;的 «for-once» 程序中在 <code>once</code> 后添加一个冒号后会发生什么情况？</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_数字_2">5. 数字</h2>
<div class="sectionbody">
<div class="paragraph">
<p>数字是数字值，例如 «2»，«0» 和 «3.14»。</p>
</div>
<div class="sect2">
<h3 id="_八进制十六进制和二进制">5.1. 八进制、十六进制和二进制…​</h3>
<div class="paragraph">
<p>数字不能以零开头，除非指定数字系统（或基数）：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">数字系统</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">短形式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一般语法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Decimal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">123</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:10&lt;123&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Octal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0o123</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:8&lt;123&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hexadecimal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x12A39F</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:16&lt;12A39F&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Binary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0b10101010</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:2&lt;10101010&gt;</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say :2&lt;0b10101010&gt;; # -&gt; 170</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，小写和大写字母在数字上相等：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; :16&lt;12A39F&gt; == :16&lt;12a39f&gt;; # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们也可以使用过程式语法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say :2(&#34;0b10101010&#34;); # -&gt; 170</code></pre>
</div>
</div>
<div class="paragraph">
<p>将值放在变量中有效，但只能使用圆括号语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a =&#34;0b10101010&#34;;
&gt; say :1&lt;$a&gt;; # -&gt; Compile time error
&gt; say :1($a); # -&gt; 170</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 5.1</strong></p>
</div>
<div class="paragraph">
<p>Raku 支持多少个数字系统（不同的基数或进制）？</p>
</div>
<div class="paragraph">
<p>使用 <code>REPL</code>。</p>
</div>
<div class="sect3">
<h4 id="_base">5.1.1. base</h4>
<div class="paragraph">
<p>我们可以使用 <code>base</code> 方法在其他数字系统（不同的底数）中显示数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 1200.base(8); # -&gt; 2260
&gt; say 170.base(2);  # -&gt; 10101010
&gt; say 256.base(16); # -&gt; FF</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>冒号语法</strong></p>
</div>
<div class="paragraph">
<p>可以使用或不使用括号来指定函数的参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say(&#34;12&#34;, &#34;34&#34;); # -&gt; 1234
&gt; say &#34;12&#34;, &#34;34&#34;;  # -&gt; 1234</code></pre>
</div>
</div>
<div class="paragraph">
<p>方法的参数通常用括号指定。 但是，如果要忽略它们，可以使用特殊的冒号语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 1200.base(8); # -&gt; 2260
&gt; say 1200.base: 8; # -&gt; 2260</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_parse_base">5.1.2. parse-base</h4>
<div class="paragraph">
<p><code>parse-base</code> 是 <code>base</code> 反义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;FF&#34;.parse-base(16); # -&gt; 255</code></pre>
</div>
</div>
<div class="paragraph">
<p>往返行程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;FF&#34;.parse-base(16).base(16); # -&gt; FF</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_其它转换">5.1.3. 其它转换</h4>
<div class="paragraph">
<p>我们还可以使用格式字符串将数字转换为其他基数，包括 <code>printf</code>，<code>sprintf</code> 和 <code>fmt</code>：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">指令</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">例子</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把无符号整数转换为二进制数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">255.fmt(&#39;%b&#39;); # → 11111111</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">把无符号整数转换为十六进制数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">255.fmt(&#39;%x&#39;); # → ff</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">和 %x 一样, 但是是大写</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">255.fmt(&#39;%X&#39;); # → FF</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>查看 6.5 节, &#34;printf&#34; (和 6.5.3, &#34;sprintf&#34; 和 6.5.4, &#34;fmt&#34;) 获取详情。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_unnicode_数">5.2. Unnicode 数</h3>
<div class="paragraph">
<p>Unicode 有很多被视为数字的字符。 如果要引起混淆，请使用它们：</p>
</div>
<div class="paragraph">
<p>½   # 这是单个字符
Ⅷ  # 单个字符(代码点 U+2168)</p>
</div>
<div class="paragraph">
<p>好。 如果你的终端机或打印机支持这些字符，你可能不会感到困惑，但是该怎么办：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_非数值">5.3. 非数值</h3>
<div class="paragraph">
<p>如果以字母(或下划线)开头，则可能是过程调用，预定义值或错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say    # -&gt; error: Missing parameter
&gt; True   # -&gt; True
&gt; False  # -&gt; False
&gt; abcdic # -&gt; error: Undeclared routine</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>True</code> 和 <code>False</code> 是内置的。 请参见第2.11节&#34;True 和 False&#34;。</p>
</div>
</div>
<div class="sect2">
<h3 id="_n_u_m_b_e_r_s">5.4. N_U_M_B_E_R_S</h3>
<div class="paragraph">
<p>你可以在数字中添加下划线，以使代码更具可读性。 编译器将忽略它们。 下划线的两边都必须有一个数字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $number1 = 1000000000;    # -&gt; 1000000000
&gt; my $number2 = 1_000_000_000; # -&gt; 1000000000
&gt; my $number3 = 1_0_0_0 ;      # -&gt; 1000</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一个是合法的，但是很愚蠢。</p>
</div>
</div>
<div class="sect2">
<h3 id="_浮点数">5.5. 浮点数</h3>
<div class="paragraph">
<p>Raku 有几种数字类型（除了整数之外（我们已经讨论过））。</p>
</div>
<div class="sect3">
<h4 id="_pi_2">5.5.1. pi</h4>
<div class="paragraph">
<p><code>pi</code> 是内置的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say pi;       # -&gt; 3.14159265358979
&gt; say pi.^name; # -&gt; Num</code></pre>
</div>
</div>
<div class="paragraph">
<p>术语&#34;浮点数&#34;源自以下事实：小数点前后没有固定的位数； 也就是说，小数点可以浮动。 Raku 称他们为 <code>Num</code>。</p>
</div>
<div class="paragraph">
<p><strong>练习 5.2</strong></p>
</div>
<div class="paragraph">
<p>将 <code>pi</code> 显示为二进制数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; pi.say; # -&gt; 3.141592653589793</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>REPL</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_e">5.5.2. e</h4>
<div class="paragraph">
<p>也可以使用欧拉数 <code>e</code>（或 Unicode 版本 <code>e</code>）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say e; # -&gt; 2.718281828459045</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tau">5.5.3. tau</h4>
<div class="paragraph">
<p>与 <code>tau</code>（或 Unicode 版本 <code>τ</code> ）一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say tau;      # -&gt; 6.283185307179586
&gt; say tau / pi; # -&gt; 2</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>tau</code> 是圆周与半径之比。</p>
</div>
</div>
<div class="sect3">
<h4 id="_浮点数错误">5.5.4. 浮点数错误</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $one-third = 1/3; # -&gt; 0.333333</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是预期的结果（唯一的意外是显示了3的实际数字）。 将其中三个相加应得出 0.999999：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say $one-third * 3; # -&gt; 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>单你是没有。我们确实得到的是 1。</p>
</div>
</div>
<div class="sect3">
<h4 id="_有理数">5.5.5. 有理数</h4>
<div class="paragraph">
<p>Raku 拥有内置的 <code>Rat</code>(有理数)类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $one-third = 1/3; # -&gt; 0.333333
&gt; $one-third.^name;    # -&gt; Rat
&gt; 0.3.^name;           # -&gt; Rat</code></pre>
</div>
</div>
<div class="paragraph">
<p>是的，最后一个是有效的语法！</p>
</div>
<div class="paragraph">
<p>如果可能，<code>Rat</code> 类型将自动用于带有小数部分的值。 否则，将使用浮点类型 <code>Num</code>。</p>
</div>
<div class="paragraph">
<p><code>Rat</code> 类型在内部使用两个整数。 实际值是第一个(&#34;分子&#34;)除以第二个(&#34;分母&#34;)。</p>
</div>
<div class="paragraph">
<p>我们可以使用 <code>nude</code>(«Numerator» + «Denominator»; «Nu» + «De»)方法获取值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1/3).nude; # -&gt; (1 3)
&gt; (0.1).nude; # -&gt; (1 10)
&gt; 0.2.nude;   # -&gt; (1 5)</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么 0.333333 是从哪里来的呢？
转换发生在我们打印值时，因为它将值转换为字符串。 这种情况发生在我们无法（或应该）打印出来的东西之后，它是带有点的零和无穷多个3。</p>
</div>
<div class="paragraph">
<p>有关详细信息，请参见第6.2节&#34;字符串化&#34;。</p>
</div>
<div class="paragraph">
<p>内部尽量减少有理数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (3/9).nude;  # -&gt; (1 3)
&gt; say (8/16).nude; # -&gt; (1 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以添加有理数，因为 Raku 支持带分数的算术：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $sum = 1/2 + 1/3; # -&gt; 0.833333
&gt; say $sum.nude;       # -&gt; (5 6)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_narrow">5.6. narrow</h3>
<div class="paragraph">
<p>返回强制保留为最窄类型且不损失精度的数字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (4.0 + 0i).narrow.perl;  # -&gt; 4
&gt; say (4.0 + 0i).narrow.^name; # -&gt; Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以直接应用类型，但可能会降低精度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say pi.Int; # -&gt; 3</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sign">5.7. sign</h3>
<div class="paragraph">
<p><code>sign</code> 将值转换为数字并返回符号； 如果数字为 <code>0</code>，则为 0；对于正数，为 1；对于负数，则为 <code>-1</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 6.sign;    # -&gt; 1
&gt; say (-6).sign; # -&gt; -1
&gt; say &#34;0&#34;.sign;  # -&gt; 0</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_凑整">5.8. 凑整</h3>
<div class="paragraph">
<p>我们可以通过几种方式将非整数强制为整数。</p>
</div>
<div class="sect3">
<h4 id="_round">5.8.1. round</h4>
<div class="paragraph">
<p>使用 <code>round</code> 将调用者（如有必要，转换为数字）四舍五入为最接近的整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 1.7.round;     # -&gt; 2
&gt; say (−0.5 ).round; # -&gt; 0
&gt; say ( .5 ).round;  # -&gt; 1</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>round</code> 可以使用第二个参数，指定一个我们要四舍五入为（多个）的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 1.07.round(0.1); # -&gt; 1.1
&gt; say 21.round(10);    # -&gt; 20</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_截断">5.8.2. 截断</h4>
<div class="paragraph">
<p>使用 <code>truncate</code> 将调用者（如有必要，转换为数字）向零四舍五入。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 1.2.truncate;  # -&gt; 1
&gt; say truncate -1.2; # -&gt; -1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_floor">5.8.3. floor</h4>
<div class="paragraph">
<p>使用 <code>truncate</code> 将调用者（如有必要，转换为 Numeric）向下舍入到最接近的整数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;1.99&#34;.floor; # &gt; 1
&gt; say &#34;-1.9&#34;.floor; # -&gt; -2</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ceiling">5.8.4. ceiling</h4>
<div class="paragraph">
<p>使用 <code>ceiling</code> 将调用者（如有必要，转换为数字）向上舍入到最接近的整数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;1&#34;.ceiling;    # -&gt; 1
&gt; say &#34;-0.9&#34;.ceiling; # -&gt; 0
&gt; say &#34;42.1&#34;.ceiling; # -&gt; 43</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gcd_最大公约数">5.8.5. gcd (最大公约数)</h4>
<div class="paragraph">
<p>将两个参数都转换为整数将返回最大公约数，即可以将它们都整数除的最大数字）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 10 gcd 12; # -&gt; 2</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_lcm_最小公倍数">5.8.6. lcm (最小公倍数)</h4>
<div class="paragraph">
<p>将两个参数都转换为整数，并返回最小公倍数，这是两个参数可均分的最小整数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 10 lcm 12; # -&gt; 60
&gt; say 10 lcm 2;  # -&gt; 10
&gt; say 2 lcm 3;   # -&gt; 6</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_msb_most_significant_binary">5.8.7. msb (Most Significant Binary)</h4>
<div class="paragraph">
<p>如果数字为0，则 <code>msb</code> 返回 <code>Nil</code>。否则，它从数字的二进制表示形式的最高有效（最高值）数字1的右边返回位置（从零开始的索引）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 0b00001.msb; # -&gt; 0
&gt; say 0b00011.msb; # -&gt; 1
&gt; say 0b00101.msb; # -&gt; 2
&gt; say 0b01010.msb; # -&gt; 3
&gt; say 0b10011.msb; # -&gt; 4</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_nannot_a_number_2">5.9. NaN(Not a Number)</h3>
<div class="paragraph">
<p><code>NaN</code> 的值为 <code>Num</code> 类型，用于表示浮点 «Not a Number» 值。 它被用作一些数学函数的返回值，这些数学函数没有实际的数值答案-但是数值仍然可以接受。</p>
</div>
<div class="paragraph">
<p><code>NaN</code> 已定义，并且在布尔上下文中转换为 <code>True</code>。 它在数值上不等于任何值，包括其自身。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say cos ∞;     # -&gt; NaN
&gt; say (0/0).Num; # -&gt; NaN</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_isnan">5.9.1. isNaN</h4>
<div class="paragraph">
<p>使用 <code>isNaN</code> 方法（或 <code>===</code> 运算符）测试 <code>NaN</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (0/0).isNaN; # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们要执行以下操作，则可以使用值相等运算符 <code>===</code>（请参见第3.7.7节 &#34;===&#34;）显式测试 <code>NaN</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (0/0).Num === NaN; # -&gt; True</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_6">5.10. =~=</h3>
<div class="paragraph">
<p>使用近似等于的运算符 <code>=~=</code>(或 Unicode 版本 <code>≅</code>)来确定两个值在数值上是否几乎相等。 如果差异小于特殊动态值`$*TOLERANCE`(默认值为 <code>1e-15</code>)，则返回 <code>True</code>，否则返回 <code>False</code>。</p>
</div>
<div class="paragraph">
<p>我们用来解释 <code>Rat</code> 的示例（请参见第5.6节&#34;有理数&#34;)为 <code>1/3</code>。 没有 <code>Rat</code>，这将是结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $b = 0.3333333333333333 * 3;

&gt; say $b;        # -&gt; 0.9999999999999999
&gt; say $b == 1;   # -&gt; False;
&gt; say $b =~= 1;  # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，在实际中，<code>Rat</code> 类型减少了对 <code>=~=</code> 的需要。</p>
</div>
</div>
<div class="sect2">
<h3 id="_is_prime_素数">5.11. is-prime (素数)</h3>
<div class="paragraph">
<p>质数是一个只能被1除以的数字（整数）。</p>
</div>
<div class="paragraph">
<p>使用 <code>is-prime</code> 来确定给定值是否是质数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; 7.is-prime;   # -&gt; True
&gt; 1.4.is-prime; # -&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一个显示为什么方法或过程名称不能以数字开头。</p>
</div>
<div class="paragraph">
<p><strong>练习 5.3</strong></p>
</div>
<div class="paragraph">
<p>编写一个程序，将所有素数（按数字递增的顺序）从1加到100_000（均包括在内），以显示总和是否为素数。</p>
</div>
<div class="paragraph">
<p>显示这些和中有多少是质数。</p>
</div>
</div>
<div class="sect2">
<h3 id="_取模和变体">5.12. 取模和变体</h3>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">数值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">mod</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">取模运算符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%%</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">整除运算符</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_7">5.12.1. %</h4>
<div class="paragraph">
<p>使用取模运算符 <code>%</code> 可以得到除法后的余数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 10 % 3; # -&gt; 1 # 3 * 3 + 1
&gt; say 11 % 3; # -&gt; 2 # 3 * 3 + 2
&gt; say 12 % 3; # -&gt; 0 # 4 * 3 + 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>模运算符 <code>%</code> 在除法之前将值转换为数值，并且也可以用于非整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 12 % &#34;3.1&#34;; # -&gt; 2.7</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mod">5.12.2. mod</h4>
<div class="paragraph">
<p><code>mod</code> 是 <code>%</code> 的整数版本。 值必须是整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 7 mod 3; # -&gt; 1  # 2 * 3 + 1
&gt; say 8 mod 3; # -&gt; 2  # 2 * 3 + 2
&gt; say 9 mod 3; # -&gt; 0  # 3 * 3 + 0</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_8">5.12.3. %%</h4>
<div class="paragraph">
<p>除数运算符 <code>%%</code> 是模运算符的双胞胎姐妹。 如果余数为零，则模运算符返回除法的结果，而除数运算符 <code>%%</code> 返回 <code>True</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 9 %% 3;       # -&gt; True
&gt; say 11 %% 3;      # -&gt; False
&gt; say 9.3 %% &#34;3.1&#34;; # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>除数运算符 <code>%%</code> 在除法之前将值转换为数值，并且也可以用于非整数。</p>
</div>
<div class="paragraph">
<p>除数运算符是以下操作的快捷方式：<code>$a % $b == 0</code>。</p>
</div>
<div class="paragraph">
<p><strong>练习 5.4</strong>
编写一个程序，将1到1000之间每个不能被7整除的数字加在一块儿。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_其它运算符">5.13. 其它运算符</h3>
<div class="paragraph">
<p>Raku 有很多内置的数学运算符。</p>
</div>
<div class="sect3">
<h4 id="_sqrt">5.13.1. sqrt</h4>
<div class="paragraph">
<p>数字的平方根：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say sqrt(9);       # -&gt; 3
&gt; say sqrt(-1);      # -&gt; NaN
&gt; say sqrt(-1 + 0i); # -&gt; 0+1i</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exp">5.13.2. exp</h4>
<div class="paragraph">
<p>将参数转换为数值，并将返回的 <code>$base</code> 提高为 <code>$power</code> 的幂。 如果未提供 <code>$base</code>，则使用 <code>e</code>(欧拉数；请参阅第5.5.2节&#34;e&#34;)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; $power.exp($base);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say exp 3;     # -&gt; 20.085536923187668
&gt; say 3.exp;     # -&gt; 20.085536923187668
&gt; say 2.exp(3);  # -&gt; 9
&gt; say exp(2, 3); # -&gt; 9</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_9">5.13.3. **</h4>
<div class="paragraph">
<p>求幂运算符 <code>**</code> 将两个参数都转换为数值，并计算左手边的乘方为右手边的幂：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 2 ** 3; # -&gt; 8
&gt; say 3 ** 2; # -&gt; 9
&gt; say e ** 3; # -&gt; 20.085536923187664</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意舍入错误（即使它们应该相同）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say e ** 3 - exp 3; # -&gt; -3.552713678800501e-15</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以使用 Unicode 上标数字，例如：2³ 与 2 ** 3 相同。</p>
</div>
</div>
<div class="sect3">
<h4 id="_expmod">5.13.4. expmod</h4>
<div class="paragraph">
<p><code>expmod</code> 将第一个参数提高为第二个元素的幂，并在其上应用第三个参数作为模数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say expmod(4, 2, 5); # -&gt; 1 ## The same as: 4 ** 2 mod 5
&gt; say 7.expmod(2, 5); # -&gt; 4  ## The same as: 7 ** 2 mod 5;</code></pre>
</div>
</div>
<div class="paragraph">
<p>方法形式需要整数。 过程版本也接受非整数，但将其截断为整数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_log">5.13.5. log</h4>
<div class="paragraph">
<p><code>log</code> 将对数返回给定值的指定底数（默认为 <code>e</code>，欧拉数；请参见第5.5.2节&#34;e&#34;，如果未给出）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say log(10);    # -&gt; 2.302585092994046
&gt; say log(10, e); # -&gt; 2.302585092994046</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果(<code>2.302585092994046</code>)是一个数字，当提高到基数(<code>e</code>)的幂时，得出的值是(<code>10</code>)，或者近似值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say exp 2.302585092994046; # -&gt; 10.000000000000002</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们尝试另一个基数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say log(10, pi);                 # -&gt; 2.0114658675880612
&gt; say exp(2.0114658675880612, pi); # -&gt; 10.000000000000002</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果基数为负，则返回 <code>NaN</code>；如果基数为 <code>1</code>，则抛出异常。</p>
</div>
<div class="paragraph">
<p><strong>log10</strong></p>
</div>
<div class="paragraph">
<p><code>log10</code> 将其对数返回以 10 为底的数字，即将其幂提高到 10 时近似产生原始数字的数字。</p>
</div>
<div class="paragraph">
<p>可以用 <code>log</code> 代替：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say log10(1001);  # -&gt; 3.0004340774793183
&gt; say log(1001,10); # -&gt; 3.0004340774793183</code></pre>
</div>
</div>
<div class="paragraph">
<p>它为负参数返回 <code>NaN</code>，为 <code>-Inf</code> 返回 <code>0</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_三角函数">5.13.6. 三角函数</h4>
<div class="paragraph">
<p>这是完整的列表。 它们都以弧度表示：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">函数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sin</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sine</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">asin</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">arc-sine</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cosine</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">acos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">arc-cosine</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tan</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tangent</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">atan</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">arc-tangent</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">atan2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">arc-tangent (two argument form)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sec</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">secant</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">asec</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">arc-secant</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cosec</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cosecant</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">acosec</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">arc-cosecant</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cotan</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cotangent</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">acotan</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">arc-cotangent</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sinh</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sine hyperbolic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">asinh</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">inverse sine hyperbolic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cosh</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cosine hyperbolic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">acosh</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">inverse cosine hyperbolic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tanh</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tangent hyperbolic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">atanh</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">inverse tangent hyperbolic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sech</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">secant hyperbolic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">asech</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">inverse secant hyperbolic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cosech</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cosecant hyperbolic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">acosech</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">inverse secant hyperbolic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cotanh</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hyperbolic cotangent</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">acotanh</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">inverse hyperbolic cotangent</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cis</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cos(argument) + i*sin(argument)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果在此表中找不到所需的功能，请查看 «Math::Trig» 模块。</p>
</div>
<div class="paragraph">
<p>我们将安装并仔细研究练习12.1中的&#34;Math::Trig&#34;。</p>
</div>
<div class="paragraph">
<p><strong>练习 5.5</strong>
你有一个内半径为 10cm 的广口瓶（或圆柱体）。 高 50 厘米。 它可以容纳多少升液体？</p>
</div>
<div class="paragraph">
<p>不记得公式了吗？ 查一下 例如 link:https://www.varsitytutors.com/hotmath/hotmath_help/ topics/volume-of-a-cylinder[]。</p>
</div>
<div class="paragraph">
<p><strong>练习 5.6</strong>
为你提供了两个罐子（或圆柱体），第一个罐子的内部半径为 10cm，高度为 35cm，第二个罐子的内部半径为 35cm，高度为 10cm。 你想要最大的一个（就内容而言）。 你选择哪一个？</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_基本输入和输出">6. 基本输入和输出</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章讨论用户的输入并输出到屏幕。</p>
</div>
<div class="paragraph">
<p>(在第13章，文件和目录中讨论了文件。)</p>
</div>
<div class="sect2">
<h3 id="_换行">6.1. 换行</h3>
<div class="paragraph">
<p>默认情况下，所有读取内容(从文件或终端)的函数都会删除尾随换行符。 (然后说再加上一次。)</p>
</div>
<div class="paragraph">
<p>换行符用一个或两个字符标记：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">操作系统</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">以字符串方式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">代码点</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Windows</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;CR&gt;&lt;LF&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\r\n</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10 + 13</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Linux</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;LF&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\n</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mac OSX</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;LF&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\n</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mac (old)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;CR&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\r</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>特殊变量 <code>$?NL</code> 报告在打印换行符时编译器将使用什么(隐式地使用 <code>say</code> 或显式地使用 &#34;\n&#34;)。</p>
</div>
<div class="paragraph">
<p><code>$?NL</code> 给出了实际的换行符，因此仅打印变量无济于事。</p>
</div>
<div class="paragraph">
<p>我们可以使用 <code>ords</code>(请参见第7.1.6.1节&#34;ords&#34;)获取代码点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; $?NL.ords; # On Linux we get «10»
(10)</code></pre>
</div>
</div>
<div class="paragraph">
<p>此变量是只读的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; $?NL = &#34;\n&#34;;
Cannot assign to an immutable value in block &lt;unit&gt; at &lt;unknown file&gt; line 1</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_chop">6.1.1. chop</h4>
<div class="paragraph">
<p><code>chop</code> 将调用者(或子例程形式的参数)强制转换为字符串，并在除去最后一个字符的情况下返回它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;abcde&#34;.chop; # -&gt; abcd</code></pre>
</div>
</div>
<div class="paragraph">
<p>无法以任何方式获得已删除的字符，因此无法使用 <code>chop</code> 遍历字符串（从结尾开始）。 请改用 <code>comb</code>(参见第7.5节&#34;comb&#34;)。</p>
</div>
<div class="paragraph">
<p><code>chop</code> 使用一个可选参数，指定要删除的字符数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;abcde&#34;.chop(2); # -&gt; abc</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_chomp">6.1.2. chomp</h4>
<div class="paragraph">
<p><code>chomp</code> 将调用者(或子例程形式，其参数)强制转换为字符串，并在删除最后一个字符(如果它是逻辑换行符)的情况下返回该字符串。</p>
</div>
<div class="paragraph">
<p>实际上，这不是很有用，因为标准读取行为会默认删除换行符。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_字符串化">6.2. 字符串化</h3>
<div class="paragraph">
<p>有三种内置的方法可以对非字符串值进行显式字符串化：<code>gist</code>，<code>Str</code> 和 <code>raku</code>(以前称为 <code>perl</code>)。(尽管前两者大多是隐式应用的，我们将在第6.3节&#34;输出&#34;中显示。)</p>
</div>
<div class="paragraph">
<p>差异可以总结如下：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">表达式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">gist</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Str</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">raku/perl</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注释</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pi</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.141592653589793</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.141592653589793</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.141592653589793e0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[1]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$a = pi</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.141592653589793</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.141592653589793</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.141592653589793e0</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1/3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.333333</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.333333</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;1/3&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[2]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$b = 1/3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.333333</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.333333</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;1/3&gt;</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(Any)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[3]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$c = Any</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(Any)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[4]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">(1..5)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1..5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 2 3 4 5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1..5</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@a = 1..5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[1 2 3 4 5]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 2 3 4 5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[1, 2, 3, 4, 5]</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">(1..Inf)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1..Inf</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1..*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1..Inf</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[5]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@b = (1..Inf)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">…​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">…​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Error</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[6]</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>[1] <code>pi</code> 常数是一个浮点数(请参见第5.5节&#34;浮点数&#34;)，内部类型为 <code>Num</code>。</p>
</div>
<div class="paragraph">
<p>[2] <code>1/3</code> 表达式给出内部类型为 <code>Rat</code> 的有理数(请参见第5.6节&#34;有理数&#34;)。</p>
</div>
<div class="paragraph">
<p>[3] 错误消息是 «No such method &#39;str&#39; for invocant of type &#39;Any&#39;. Did you mean &#39;Str&#39;?»。</p>
</div>
<div class="paragraph">
<p>[4] 错误消息是 «Use of uninitialized value $a of type Any in string context»。</p>
</div>
<div class="paragraph">
<p>[5] <code>1..Inf</code> 表达式是一个惰性列表。 仅在需要时才计算各个值。 有关更多信息，请参见第16.1.1节&#34;懒惰与渴望&#34;。</p>
</div>
<div class="paragraph">
<p>[6] 错误消息是 «Cannot .elems a lazy list»。</p>
</div>
<div class="paragraph">
<p>请注意，在赋值给列表时，列表的输出有所不同（懒惰与否）。</p>
</div>
<div class="sect3">
<h4 id="_gist">6.2.1. gist</h4>
<div class="paragraph">
<p>词典中 «gist» 的定义是“语音或文本的实质或一般含义。”</p>
</div>
<div class="paragraph">
<p>每个对象都有一个 <code>gist</code> 方法(继承自基类&#34;Mu&#34;, 请参见第3.2节&#34;^mro(方法解析顺序)&#34;)。 其任务（根据官方文档）是&#34;返回调用者的字符串表示形式，并对其进行了优化以实现人类的快速识别。&#34;</p>
</div>
<div class="paragraph">
<p>如果对象很大，则 <code>gist</code> 仅返回有关该对象的部分信息。 一长串列表的上限是第100个元素（后跟 «…​»）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @a = (1 .. 110); say @a.gist;
[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 ...]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gist</code> 处理未定义值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a; say $a.gist;
(Any)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_str">6.2.2. Str</h4>
<div class="paragraph">
<p><code>Str</code> 展平数据结构:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @a = (1,2,3, (4,5,6),7,8,9); say @a.Str;

&gt; say @a.gist
[1 2 3 (4 5 6) 7 8 9]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Str</code> 在未定义的值上失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a; say $a.Str
Use of uninitialized value $a of type Any in string context.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rakuperl">6.2.3. raku(perl)</h4>
<div class="paragraph">
<p>每个对象都有一个 <code>raku</code> 方法。 它可以用于（递归地）转储对象，并在Raku实际存储对象时显示对象。</p>
</div>
<div class="paragraph">
<p>此方法对于以适合以后传递给程序的格式转储数据结构很有用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1/3).raku; # -&gt; &lt;1/3&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>较早版本的 Raku 没有 <code>raku</code> 方法。 如果无法升级，请使用 <code>perl</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_总结">6.2.4. 总结</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">gist</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Str</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">raku</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Flattens data structures</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Handles undefined values</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Shows everything</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>旧名称（从将语言从«Perl 6»重命名为«Raku»之前的名称）是 <code>perl</code>，你可能会在相当一段时间内看到它。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_输出">6.3. 输出</h3>
<div class="paragraph">
<p>我们已经使用 <code>say</code>（有时是 <code>print</code>）在屏幕上显示数据，并且说它们是相等的，只是添加了带有 <code>say</code> 的换行符。</p>
</div>
<div class="paragraph">
<p>那不是完全正确。 <code>put</code> 例程在打印时添加了换行符，并且说起来有些神奇。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">函数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">带 \n</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符串化</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">查看章节</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">say</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">.gist</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6.3.1, &#34;say&#34;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">put</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">.Str</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6.3.2, &#34;put&#34;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">print</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">.Str</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6.3.3, &#34;print&#34;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">.raku</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>我们先从 <code>say</code> 开始，然后看一下 <code>put</code>，最后是 <code>print</code>。</p>
</div>
<div class="sect3">
<h4 id="_say">6.3.1. say</h4>
<div class="paragraph">
<p><code>say</code> 是 Raku（而不是 <code>print</code>）中最常用的输出方法，因为它在末尾添加了换行符。</p>
</div>
<div class="paragraph">
<p>请注意，如上表所述，在变量或数据结构上说使用要点。</p>
</div>
<div class="paragraph">
<p>但是只要你将其放入字符串中，例如 &#34;say $a&#34;, 它使用 <code>Str</code> 来对字符串进行排序，然后在该字符串上使用 <code>gist</code>(由于该字符串已经是字符串，因此它不会执行任何操作)。 这也适用于花括号内的字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a; say &#34;The value is: $a&#34;;
Use of uninitialized value of type Any in string context.

&gt; say &#34;The value is: { $a }&#34;;
Use of uninitialized value of type Any in string context.</code></pre>
</div>
</div>
<div class="paragraph">
<p>必须使用 <code>gist</code> 或 <code>raku</code>（可处理未定义的值）手动将其字符串化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;The value is: { $a.gist }&#34;;
The value is: (Any)

&gt; say &#34;The value is: { $a.raku }&#34;;
The value is: Any</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要控制输出，可以使用 «Defined-or» 运算符 <code>//</code>(请参阅第2.12节&#34;//&#34;)：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;foo { $a // &#34;Undefined&#34; } bar&#34;
foo Undefined bar</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以根据你要实现的目标，使用 <code>defined</code>(请参见3.5.2节，&#34;defined&#34;) 或 <code>try</code>(请参见3.6.3节，&#34;通过 try 防止运行时错误&#34;)来防止输出未定义的值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_put">6.3.2. put</h4>
<div class="paragraph">
<p>无论类型如何，<code>put</code> 都会在值上使用 <code>Str</code>。 它在末尾添加一个换行符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; put ^10; # -&gt; 0 1 2 3 4 5 6 7 8 9
&gt; say ^10; # -&gt; ^10</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次提醒你在 <code>say</code> 的时候注意插值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; put &#34;{ ^10 }&#34;; # -&gt; 0 1 2 3 4 5 6 7 8 9
&gt; say &#34;{ ^10 }&#34;; # -&gt; 0 1 2 3 4 5 6 7 8 9</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_print">6.3.3. print</h4>
<div class="paragraph">
<p><code>print</code>(还有 <code>say</code> 和 <code>put</code>)打印到指定的文件句柄，如果不使用一个，则打印到 <code>$*OUT</code>。</p>
</div>
<div class="paragraph">
<p><code>print</code> 与 <code>put</code> 相同，只是它不会在末尾添加换行符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_put_vs_say">6.3.4. put vs say</h4>
<div class="paragraph">
<p>为什么使用 <code>put</code> 而不是 <code>say</code>（如《Learning Perl 6》一书中所提倡的）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>say</code> 使用 <code>gist</code></p>
</li>
<li>
<p><code>put</code> 使用 <code>Str</code></p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">my @a = 1..5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">结果</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">注释</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">say @a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[1 2 3 4 5]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[1]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">say @a, &#34;X&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 2 3 4 5]X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[1]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">say @a ~ &#34;X&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 2 3 4 5X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">say &#34;@a[]&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 2 3 4 5</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">put @a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 2 3 4 5</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">put &#34;@a[]&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 2 3 4 5</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">print @a, &#34;\n&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 2 3 4 5</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">print &#34;@a[]\n&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 2 3 4 5</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>它们所有人的末尾都有换行符。</p>
</div>
<div class="paragraph">
<p>[1] 这是 <code>say</code> 实际使用 <code>gist</code> 的唯一情况。 在所有其他情况下，首先字符串插值均适用，使用 <code>Str</code>。 这也适用于 <code>REPL</code> 模式下的隐式输出（请参见第1.3节“ REPL”）。</p>
</div>
<div class="paragraph">
<p>结论：如果只获得部分数据结构没关系，请使用 <code>say</code>。 如果有关系，请使用 <code>put</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_字符串化数字">6.4. 字符串化数字</h3>
<div class="paragraph">
<p>数字是有问题的。 特别是(<code>RAT</code> 类型的)有理数。 例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $third = 1/3;
&gt; say $third;      # -&gt; 0.333333
&gt; say $third.Str;  # -&gt; 0.333333
&gt; say $third.gist; # -&gt; 0.333333
&gt; say $third.raku; # -&gt; &lt;1/3&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个具有无限数字位数的数字（例如 <code>1/3</code>）将被截断。 在这里，我们在小数点后有六位数。</p>
</div>
<div class="paragraph">
<p>在字符串化之前，将值强制为浮点数会得到不同的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1/3).Num.say
0.3333333333333333</code></pre>
</div>
</div>
<div class="paragraph">
<p>将有理数强制转换为另一种类型，然后再返回，也可能会出现问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; 1/3 &lt;=&gt; 0.33333333333333; # -&gt; More</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们进行三向比较时，<code>1/3</code> 实际上是 <code>1/3</code>(请参见第3.7.3节&#34;&lt;⇒&#34;)，因此这很有意义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1/3).Str.Num &lt;=&gt; 0.33333333333333; # -&gt; Less</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里 <code>1/3</code> 已被字符串化为 <code>0.333333</code>，并被强制转换回数字值。</p>
</div>
<div class="paragraph">
<p>这里的计算是正确的，但字符串化不匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $r = 1/3;              # -&gt; 0.333333
&gt; my $s = .3333333333333;   # -&gt; 0.3333333333333
&gt; say &#34;$r &gt; $s ? {$r &gt; $s}&#34; # -&gt; 0.333333 &gt; 0.3333333333333 ? True</code></pre>
</div>
</div>
<div class="paragraph">
<p>小数点后的位数比分母中的位数多 1，最小值为 6。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (7412 / 123456789).raku; # -&gt; &lt;7412/123456789&gt; ## Denominator with 9 digits
&gt; say (7412 / 123456789);      # -&gt; 0.0000600372 ## 10 digits</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，位数是基于内部减少的值，而不是程序员指定的位数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (123123123 / 321321321).raku; # -&gt; &lt;41/107&gt; ## Denominator with 3 digits
&gt; say (123123123 / 321321321);      # -&gt; 0.383178 ## 6 digits, the minimum</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_printf">6.5. printf</h3>
<div class="paragraph">
<p>在打印值之前，请使用 <code>printf</code>(«print formatted»)格式化值。</p>
</div>
<div class="paragraph">
<p>用作函数时，第一个参数是格式字符串，其余参数是要打印的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $x = 1;
&gt; printf(&#34;%e\n&#34;, $x); # -&gt; 1.000000e+00</code></pre>
</div>
</div>
<div class="paragraph">
<p>我建议在格式字符串上使用单引号。 我不得不在上面使用双引号来获取换行符。
上面的行之所以有用，是因为除非在末尾添加 <code>{}</code>，否则哈希变量不会插在字符串中。 （请记住，我们必须在数组变量之后添加 <code>[]</code> 以进行插值。）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my %e = ( A =&gt; 14 );
&gt; my $x = 1;
&gt; printf(&#34;%e\n&#34;, $x); # -&gt; 1.000000e+00
&gt; printf(&#34;%e{}\n&#34;, $x);
Your printf-style directives specify 0 arguments, but 1 argument was
  supplied in block &lt;unit&gt; at &lt;unknown file&gt; line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在 <code>%e{}</code> 表示哈希变量，并且格式字符串没有指令。 然后，它得到一个参数，并抱怨。</p>
</div>
<div class="paragraph">
<p>当用作方法时，我们在格式字符串上调用它，并将值作为参数传递：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;%s\n&#34;.printf($x);</code></pre>
</div>
</div>
<div class="paragraph">
<p>该示例使用 <code>%s</code> 表示字符串，它打印我们传递的字符串，并在末尾附加换行符。</p>
</div>
<div class="paragraph">
<p>指令是：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">序列</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A literal percent sign</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An unsigned integer, in binary</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%c</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A character with the given codepoint</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A signed integer, in decimal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%e</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A floating-point number, in scientific notation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Like e, but using an uppercase &#34;E&#34;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%f</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A floating-point number, in fixed decimal notation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%g</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A floating-point number, in %e or %f notation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%G</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Like g, but with an uppercase &#34;E&#34; (if applicable)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%o</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An unsigned integer, in octal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A string (stringification with Str)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%u</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An unsigned integer, in decimal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An unsigned integer, in hexadecimal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Like x, but using uppercase letters</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>一些例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; printf(&#34;%e\n&#34;, 1); 1.000000e+00
&gt; my $name = &#34;Tom&#34;;

&gt; printf(&#34;Hello %s, and welcome to the jungle!\n&#34;, &#34;$name&#34;);
Hello Tom, and welcome to the jungle!</code></pre>
</div>
</div>
<div class="paragraph">
<p>字符串内变量的常规插值会降低 <code>printf</code> 的用途：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $name = &#34;Tom&#34;;
&gt; print &#34;Hello $name, and welcome to the jungle!\n&#34;;
Hello Tom, and welcome to the jungle!</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_参数索引">6.5.1. 参数索引</h4>
<div class="paragraph">
<p>如果参数数量与格式字符串不匹配，则会收到错误消息（如上面的警告中所示）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; printf(&#34;%s\n&#34;, &#34;Tom&#34;, 11222);
Your printf-style directives specify 1 argument, but 2 arguments were supplied
  in block &lt;unit&gt; at &lt;unknown file&gt; line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以改组它们的使用顺序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; printf(&#34;Hello %s, and %s.\n&#34;, &#34;Tom&#34;, &#34;Welcome&#34;);
Hello Tom, and Welcome.

&gt; printf(&#39;Hello %2$s, and %1$s.&#39; ~ &#34;\n&#34;, &#34;Tom&#34;, &#34;Welcome&#34;);
Hello Welcome, and Tom.</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个参数指定为 <code>1$</code>，第二个参数指定为 <code>2$</code>，依此类推。 也可以重用参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; printf(&#39;Hello %1$s, and %1$s.&#39; ~ &#34;\n&#34;, &#34;Tom&#34;);
Hello Tom, and Tom.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_标志">6.5.2. 标志</h4>
<div class="paragraph">
<p>我们可以在 <code>%</code> 和字母之间指定标志：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">标志</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">例子</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">结果</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" rowspan="3"><p class="tableblock">space</p></td>
<td class="tableblock halign-left valign-top" rowspan="3"><p class="tableblock">Prefix a non-negative number with a space</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">printf &#39;§% d§&#39;, 12;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">§ 12§</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">printf &#39;§% d§&#39;, 0;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">§ 0§</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">printf &#39;§% d§&#39;, -12;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">§-12§</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" rowspan="3"><p class="tableblock"><code>+</code></p></td>
<td class="tableblock halign-left valign-top" rowspan="3"><p class="tableblock">Prefix a non-negative number with a plus sign</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">printf &#39;§%+d§&#39;, 12;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">§+12§</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">printf &#39;§%+d§&#39;, 0;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">§+0§</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">printf &#39;§%+d§&#39;, -12;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">§-12§</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Add trailing spaces (instead of leading)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">printf &#39;§%-6s§&#39;, 12;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">§12 §</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Use leading zeros, not spaces, for padding</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">printf &#39;§%06s§&#39;, 12;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">§000012§</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" rowspan="5"><p class="tableblock">#</p></td>
<td class="tableblock halign-left valign-top" rowspan="5"><p class="tableblock">Show a leading &#34;0&#34; and the type prefix (hexadecimal with &#34;0x&#34; or &#34;0X&#34;, octal with &#34;0o&#34; and binary with&#34;0b&#34; or &#34;0B&#34;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">printf &#39;§%#o§&#39;, 12;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">§014§</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">printf &#39;§%#x§&#39;, 12;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">§0xc§</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">printf &#39;§%#X§&#39;, 12;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">§0XC§</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">printf &#39;§%#b§&#39;, 12;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">§0b1100§</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">printf &#39;§%#B§&#39;, 12;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">§0B1100§</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>可以将数字指定为参数。 以下几行给出相同的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; printf &#39;|%6s|&#39;, 12;    # -&gt; | 12|
&gt; printf &#39;|%*s|&#39;, 6, 12; # -&gt; | 12|</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样可以很容易地将宽度指定为变量。</p>
</div>
<div class="paragraph">
<p>还可以指定要显示的最大字符数。 详情请参阅 <a href="https://docs.raku.org/routine/sprintf" class="bare">https://docs.raku.org/routine/sprintf</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_sprintf">6.5.3. sprintf</h4>
<div class="paragraph">
<p><code>sprintf</code>(«string print formatted»)的行为与 <code>printf</code> 相同(请参见上一节), 但是它返回字符串而不是打印它。</p>
</div>
<div class="paragraph">
<p>我们可以使用 <code>sprintf</code> 和 <code>say</code> 避免指定换行符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; printf(&#39;Hello %2$s, and %1$s.&#39; ~ &#34;\n&#34;, &#34;Tom&#34;, &#34;Welcome&#34;);
Hello Welcome, and Tom.

&gt; say sprintf(&#39;Hello %2$s, and %1$s.&#39;, &#34;Tom&#34;, &#34;Welcome&#34;);
Hello Welcome, and Tom.</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>sprintf</code> 仅是一个函数。 相应的方法是 <code>fmt</code>（请参阅下一节）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $t1 = $string.fmt($format);
&gt; my $t2 = sprintf($format, $string); # Exactly the same</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_fmt">6.5.4. fmt</h4>
<div class="paragraph">
<p><code>fmt</code> 是 <code>sprintf</code> 函数的方法版本（请参见上一节）。</p>
</div>
<div class="paragraph">
<p>如果使用的 <code>fmt</code> 不带格式参数，则默认为 <code>%s</code>。</p>
</div>
<div class="paragraph">
<p>一些例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 1200.fmt(&#34;%o&#34;); # -&gt; octal
2260

&gt; say 1200.fmt(&#34;Octal: %o&#34;); # More verbose.
Octal: 2260

&gt; say 1200.fmt(&#39;Decimal: %1$d - Octal: %1$o&#39;);
Decimal: 1200 - Octal: 2260</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_获取用户输入">6.6. 获取用户输入</h3>
<div class="sect3">
<h4 id="_prompt">6.6.1. prompt</h4>
<div class="paragraph">
<p>使用 <code>prompt</code> 显示可选消息，然后等待用户键入内容。</p>
</div>
<div class="listingblock">
<div class="title">文件: prompt</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">my $name = prompt &#34;What&#39;s your name? &#34;;
say &#34;Hi, $name! Nice to meet you!&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>prompt</code> 是 <code>say</code> 和 <code>get</code>(请参见第13.3.3节&#34;get&#34;)的组合。</p>
</div>
<div class="paragraph">
<p>还记得数字和字符串之间的区别吗？</p>
</div>
<div class="ulist">
<ul>
<li>
<p>引号中的值是一个字符串</p>
</li>
<li>
<p>不带引号的值是数字或错误</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>那么，当我们从终端输入而不在字符串上使用引号时会发生什么呢？ 让我们尝试一下，对填充了 <code>prompt</code> 的变量应用 <code>^name</code>：</p>
</div>
<div class="listingblock">
<div class="title">文件: prompt-type</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">loop {
    my $name = prompt &#34;Enter a value (or return to exit): &#34; or exit;
    say &#34;Value $name is of the type { $name.^name }.&#34;;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku prompt-type
Enter a value (or return to exit): Allan
Value Allan is of the type Str.
Enter a value (or return to exit): 12
Value 12 is of the type IntStr.
Enter a value (or return to exit): &#34;12&#34;
Value &#34;12&#34; is of the type Str.
Enter a value (or return to exit):</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_intstr_和异形体">6.6.2. IntStr 和异形体</h4>
<div class="paragraph">
<p>Raku 能够猜测类型，除非我们指定了看起来像数字的东西-不带引号。</p>
</div>
<div class="paragraph">
<p>然后，类型为 <code>IntStr</code>，它不能同时是字符串和整数-不需要我们通常需要的类型转换。 <code>IntStr</code> 是同种异体类型； 两种类型的子类，它们可以表现两者之一。 这意味着它们将满足类型约束。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my Int $a = prompt;
1234            # &lt;- This is user input
&gt; say $a.^name; # -&gt; IntStr

&gt; my Str $a = prompt;
1234            # &lt;- This is user input
&gt; say $a.^name; # -&gt; IntStr

&gt; my Int $a = prompt;
foo             # &lt;- This is user input
Type check failed in assignment to $a; expected Int but got Str (&#34;foo&#34;)</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Str 继承树</strong></p>
</div>
<div class="paragraph">
<p>我们在 <code>Str</code> 的继承树中找到 <code>IntStr</code> 类型：</p>
</div>
<div class="paragraph">
<p>![img]()</p>
</div>
<div class="paragraph">
<p>在线图：<a href="https://docs.raku.org/type/Str#Type_Graph" class="bare">https://docs.raku.org/type/Str#Type_Graph</a>。</p>
</div>
<div class="paragraph">
<p>请注意4种同种异体类型：<code>IntStr</code>，<code>NumStr</code>，<code>RatStr</code> 或 <code>ComplexStr</code>。 我们不会覆盖其中的最后三个，但是如果你了解 <code>IntStr</code>，那么它们应该微不足道。</p>
</div>
<div class="paragraph">
<p>有关 <code>Int</code> 继承树，请参见第3.2.1节&#34;Int 继承树&#34;。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say IntStr.^mro; # -&gt; ((IntStr) (Int) (Str) (Cool) (Any) (Mu))
&gt; say Str.^mro;    # -&gt; ((Str) (Cool) (Any) (Mu))
&gt; say Int.^mro;    # -&gt; ((Int) (Cool) (Any) (Mu))</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>^mro</code>(方法解析顺序)仅是-应用方法的类的顺序（查找方法的类的顺序）。</p>
</div>
<div class="paragraph">
<p>在 <code>mro</code> 对象上应用 <code>raku</code> 可以使它更加清楚，这只是一个平面结构（列表）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say IntStr.^mro.raku; # -&gt; (IntStr, Int, Str, Cool, Any, Mu)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们通过使用引号避免了 <code>IntStr</code> 值的问题(如果我们将其视为一个问题)。 但是，当我们从命令行输入内容时(shell 引用是一个问题), 这是行不通的; 请参见第10.10.1节&#34;带类型的 MAIN&#34;。</p>
</div>
<div class="paragraph">
<p><strong>练习 6.1</strong></p>
</div>
<div class="paragraph">
<p>编写一个要求输入数字的程序，假设输入为二进制，一直到十六进制格式(即以2为底，以3为底，以16为底), 然后以十进制打印该值。</p>
</div>
<div class="paragraph">
<p>如果失败，请不要打印该值； 例如&#34;12&#34;不是二进制。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_字符串_2">7. 字符串</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍了字符串以及我们可以使用它们进行的一些基本操作。</p>
</div>
<div class="paragraph">
<p>字符串是真实的标量值，不能视为字符列表。 （我们可以将其转换为字符列表，我们将在后面看到，但这是另一回事。）</p>
</div>
<div class="paragraph">
<p>我们不能从字符串中选择单个字符。</p>
</div>
<div class="sect2">
<h3 id="_unicode">7.1. Unicode</h3>
<div class="paragraph">
<p>所有字符串均以 Unicode 编码。</p>
</div>
<div class="paragraph">
<p>请注意这些函数的通用命名结构：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">几个值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uniname</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uninames</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获取字符的 unicode 名字</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uniparse</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获取给定 Unicode 名称的 Unicode 字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ord</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ords</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获取字符的 Unicode 代码点</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">chr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">chrs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">获取具有给定代码点的 Unicode 字符</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>缺少的 <code>uniparse</code> 的多值版本很容易使用 <code>hyper</code> 运算符实现。 我们将在«高级 Raku» 课程中介绍这两个方面。</p>
</div>
<div class="sect3">
<h4 id="_chars">7.1.1. chars</h4>
<div class="paragraph">
<p>使用 <code>chars</code> 来获取字符串中字符的个数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;abc&#34;.chars; # -&gt; 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果用于其他任何东西，它将被转换为字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say chars(pi); # -&gt; 17</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 <code>chop</code> 和 <code>chars</code> 来获取字符串中的第一个字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = &#34;1234567890&#34;;
say $s.chop($s.chars -1); # -&gt; 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是稍后我们将展示更好的方法。
请注意，该值是Unicode字素或用户可见字符的数量。 如果它看起来像一个字符，则它是一个字素。</p>
</div>
<div class="paragraph">
<p>让我们考虑一下斯堪的纳维亚字母“Å”。 它存在于Unicode字符集中（使用代码U + 00C5），可以“开箱即用”使用。 在Unicode中，我们还可以通过将字母«A»（U + 0041）与«上面的组合环»（U + 030A）组合在一起来构成它，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = &#34;A\c[Combining Ring Above]&#34;;    # -&gt; Å
say $s.chars;                           # -&gt; 1
say &#34;A\c[Combining Ring Above]&#34; eq &#34;Å&#34;; # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码向我们展示了 Raku 在从字符串或文件中读取字符串时对其进行规范化。 这意味着你得到的不一定是所提供的。
（换行符（行尾标记，在 Unix，Windows 和 Mac 上也不同）也已标准化，如第6.1节&#34;换行符&#34;中所述。）</p>
</div>
</div>
<div class="sect3">
<h4 id="_组合字符">7.1.2. 组合字符</h4>
<div class="paragraph">
<p>组合字符（或多个字符）在基本字符之后。 （这意味着编译器每次一次读取一个字符的字符串时，必须至少向前看一个字节；例如， <code>for $string.comb → $char { …​ }</code>。）</p>
</div>
</div>
<div class="sect3">
<h4 id="_codes">7.1.3. codes</h4>
<div class="paragraph">
<p>这为我们提供了 Unicode 代码点的数量。 通常与字符相同。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;12øøæåsaåsæ&#34;.codes; # -&gt; 11
say &#34;12øøæåsaåsæ&#34;.chars; # -&gt; 11

say &#34;A\c[Combining Ring Above]&#34;.codes; # -&gt; 1
say &#34;A\c[Combining Ring Above]&#34;.chars; # -&gt; 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 Unicode 具有 Å 字符。 我们可以尝试 Unicode 没有的功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;O\c[Combining Ring Above]&#34;.codes; # -&gt; 2
say &#34;O\c[Combining Ring Above]&#34;.chars; # -&gt; 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_uniname">7.1.4. uniname</h4>
<div class="paragraph">
<p>使用 <code>uniname</code> 获取字符串中第一个字符（字素）的 Unicode 名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;A\c[Combining Ring Above]&#34;.uniname;
# LATIN CAPITAL LETTER A WITH RING ABOVE

say &#34;abc&#34;.uniname;
# LATIN SMALL LETTER A</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 Unicode 名称指定任何字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;\c[LATIN SMALL LETTER A]&#34;; # -&gt; a
say &#34;\c[Latin Small Letter a]&#34;; # -&gt; a</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_uninnames">7.1.5. uninnames</h4>
<div class="paragraph">
<p>使用 <code>uniname</code> 获取字符串中所有字符的 Unicode 名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;O\c[Combining Ring Above]&#34;.uninames;
# (LATIN CAPITAL LETTER O COMBINING RING ABOVE)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 <code>raku</code> 方法获得更好的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;O\c[Combining Ring Above]&#34;.uninames.raku;
# (&#34;LATIN CAPITAL LETTER O&#34;, &#34;COMBINING RING ABOVE&#34;).Seq

say ‘»ö«’.uninames.raku;
# «(&#34;RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK&#34;, &#34;LATIN SMALL LETTER O WITH DIAERESIS&#34;, &#34;LEFT-POINTING DOUBLE ANGLE QUOTATION MARK&#34;).Seq»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_uniparse">7.1.6. uniparse</h4>
<div class="paragraph">
<p>我们可以对 Unicide 名称使用 <code>uniparse</code> 来获得字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;LATIN SMALL LETTER A&#34;.uniparse; # -&gt; a</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们通过非法的东西，它就会失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">uniparse(&#34;LATIN SMALL LETTER A WITH VERTICAL LINE BELOW AND ACUTE&#34;);
#  Unrecognized character name [LATIN SMALL LETTER A WITH VERTICAL LINE BELOW AND ACUTE]
#    in block &lt;unit&gt; at &lt;unknown file&gt; line 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ord">7.1.7. ord</h4>
<div class="paragraph">
<p>使用 <code>ord</code> 获取一个字符的 Unicode 代码点（一个数字）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;A&#34;.ord;    # -&gt; 65
&#34;Abba&#34;.ord; # -&gt; 65</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ords">7.1.8. ords</h4>
<div class="paragraph">
<p>使用 <code>ords</code> 获取字符串中所有字符的 Unicode 代码点（数字）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;Abb&#34;.ords; # -&gt; (65 98 98)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以重新访问在7.1.3&#34;代码&#34;部分中显示的组合字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;A\c[Combining Ring Above]&#34;.ords; # -&gt; (197)
say &#34;O\c[Combining Ring Above]&#34;.ords; # -&gt; (79 778)</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，Unicode 将第一个字符，«A» 和组合器合并为一个单独的 Unicode 字符。</p>
</div>
<div class="paragraph">
<p>对于 <code>ord</code>，请务必谨慎，因为你认为这是单个字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;O\c[Combining Ring Above]&#34;.ord; # -&gt; 79</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_chr">7.1.9. chr</h4>
<div class="paragraph">
<p>使用 <code>chr</code> 将整数转换为 Unicode 字符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 65.chr;   # -&gt; A ## Decimal
say 0x41.chr; # -&gt; A ## Hexadecimal</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_chrs">7.1.10. chrs</h4>
<div class="paragraph">
<p>使用 <code>chrs</code> 将整数列表转换为 Unicode 字符字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &lt;67 97 109 101 108 105 97&gt;.chrs; # -&gt; Camelia</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以再次尝试合并的字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (79, 778).chrs.ords;                   # -&gt; (79 778)
say &#34;O\c[Combining Ring Above]&#34;.chrs.ords; # -&gt; (79 778)</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，他们并不总是往返。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 197.chr;             # -&gt; Å
say (65, 778).chrs;      # -&gt; Å
say (65, 778).chrs.ords; # -&gt; (197)</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，«A» 和组合器将替换为单独的 Unicode 字符。</p>
</div>
<div class="paragraph">
<div class="title">练习 7.1</div>
<p>编写一个要求输入（循环）的程序，然后在屏幕上打印之前，将每个小写字母（仅a-z）替换为大写字母，反之亦然。 其他字符保持不变。
使用 <code>ord/ords</code> 和 <code>chr/chrs</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_join">7.2. join</h3>
<div class="paragraph">
<p>我们可以使用 <code>join</code> 将字符串列表粘合在一起：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &lt;1 2 3&gt;.join; # -&gt; 123</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们指定要 <code>join</code> 的参数，则将在元素之间使用该字符串。 我们可以像这样生成 CSV 文件行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &lt;12 hello 3.14 bingo 87&gt;.join(&#34;;&#34;); # -&gt; 12;hello;3.14;bingo;87</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_split">7.3. split</h3>
<div class="paragraph">
<p>这是 <code>join</code> 的反面:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;12;hello;3.14;bingo;87&#34;.split(&#34;;&#34;); # -&gt; (12 hello 3.14 bingo 87)</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，我们分割的文本（在本例中为;）不包括在结果中。</p>
</div>
<div class="paragraph">
<p><code>split</code> 使用可选的第二个参数，一个整数告诉它将其拆分为多少部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;12;hello;3.14;bingo;87&#34;.split(&#34;;&#34;, 2)
# (12 hello;3.14;bingo;87)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_words">7.4. words</h3>
<div class="paragraph">
<p>我们可以使用 <code>split</code> 和空格字符将字符串拆分成单词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @words = $text.split(&#34; &#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，如果我们彼此之间有多个空格，这还不太可行。 （我们可以使用正则表达式作为 <code>split</code> 的参数来解决此问题，我们将在第11章，正则表达式简介中进行介绍。）</p>
</div>
<div class="paragraph">
<p>但是 <code>word</code> 方法是不言自明的，它处理多个空格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @words = $text.words;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>words</code> 不能很好地处理标点符号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;This is it, isn&#39;t it? Or perhaps not. 2nd try&#34;.words.join(&#34;|&#34;);
# This|is|it,|isn&#39;t|it?|Or|perhaps|not.|2nd|try</code></pre>
</div>
</div>
<div class="paragraph">
<p>一种可能的解决方案是在应用 <code>words</code> 之前，将所有不是字母或数字的内容替换为空格。</p>
</div>
<div class="paragraph">
<p>也可以使用 &lt;one two …​&gt; Quote Words 构造。 请参见第8.3节&#34;&lt;xxx&gt;（Quote Word）&#34;。</p>
</div>
</div>
<div class="sect2">
<h3 id="_comb">7.5. comb</h3>
<div class="paragraph">
<p>我们可以使用 <code>split</code> 从字符串中获取单个字符的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;12345&#34;.split(&#34;&#34;);       # -&gt; ( 1 2 3 4 5 )
say &#34;12345&#34;.split(&#34;&#34;).elems; # -&gt; 7</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意空的第一个和最后一个元素。</p>
</div>
<div class="paragraph">
<p><code>elems</code> 给 出列表中元素的个数。</p>
</div>
<div class="paragraph">
<p>最好使用 <code>comb</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;12345&#34;.comb;       # -&gt; (1 2 3 4 5)
say &#34;12345&#34;.comb.elems; # -&gt; 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以获取字符组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;12345&#34;.comb(2); # -&gt; (12 34 5)</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">练习 7.2</div>
<p>编写一个在循环中要求整数值的程序。
如果该值为整数，则计算所有数字的总和。 提示：从第6.5.1节&#34;prompt&#34;中的&#34;提示类型&#34;开始。</p>
</div>
<div class="paragraph">
<div class="title">练习 7.3</div>
<p>编写一个要求循环输入的程序。
- 显示最后一个字符
- 显示第二个字符</p>
</div>
</div>
<div class="sect2">
<h3 id="_flip">7.6. flip</h3>
<div class="paragraph">
<p>我们可以使用 <code>comb</code>, <code>reverse</code> 和 <code>join</code> 来反转字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;abc123&#34;.comb.reverse.join; # -&gt; 321cba</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>comb</code> 为我们提供了一个单字符列表，<code>reverse</code> 反转了此列表的顺序，<code>join</code> 通过字符串将列表合并在一起。</p>
</div>
<div class="paragraph">
<p>但是使用 <code>flip</code> 方法来反转字符串更容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;abc123&#34;.flip; # -&gt; 321cba</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_substr部分字符串">7.7. substr(部分字符串)</h3>
<div class="paragraph">
<p>使用 <code>substr</code>（substring）获取字符串的一部分，从指定的偏移量位置开始（因此第一个字符位于位置0），然后返回其余部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;1234567890&#34;.substr(3); # -&gt; 4567890</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以指定长度（字符数）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;1234567890&#34;.substr(3, 2); # -&gt; 45</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以获取字符串的最后一个字符（参见练习7.3）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = &#34;123456&#34;;
say $s.substr($s.chars -1); # -&gt; 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也适用，其中 <code>*</code> 表示&#34;从末尾开始&#34;：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$s.substr(* -1)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_substr_eq_部分字符串">7.7.1. substr-eq (部分字符串)</h4>
<div class="paragraph">
<p><code>substr-eq</code> 是 <code>substr</code> 和 <code>eq</code> 的组合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;abc123&#34;.substr-eq(&#34;c123&#34;, 3); # -&gt; False ## As &#34;123&#34; ne &#34;c123&#34;
say &#34;abc123&#34;.substr-eq(&#34;c123&#34;, 2); # -&gt; True ## As &#34;c123&#34; eq &#34;c123&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，我们不能像使用 <code>substr</code> 那样指定长度。</p>
</div>
</div>
<div class="sect3">
<h4 id="_substr_rw_部分字符串">7.7.2. substr-rw (部分字符串)</h4>
<div class="paragraph">
<p><code>substr-rw</code> 是 <code>substr</code> 的版本，它向字符串的指定部分返回可写视图（与仅返回副本的 <code>substr</code> 相对）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = &#34;abc&#34;; $s.substr-rw(1, 1) = &#34;Q&#34;; $s.say;  # -&gt; aQc
my $s = &#34;abc&#34;; substr-rw($s, 1, 1) = &#34;Q&#34;; $s.say; # -&gt; aQc</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们不受长度的限制：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = &#34;abc&#34;; $s.substr-rw(1, 1) = &#34;QQQ&#34;; $s.say; # -&gt; aQQc</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二个参数决定要删除的字符数。 我们可以将其设置为零以进行插入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = &#34;abc&#34;; $s.substr-rw(1, 0) = &#34;ZZ&#34;; $s.say; # -&gt; aZZbc</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用绑定为子字符串创建别名（请参见第2.6.2节&#34;:=(绑定)&#34;）：</p>
</div>
<div class="listingblock">
<div class="title">文件: substr-rw</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $string = &#34;abc*123*ABC&#34;;
my $partial := $string.substr-rw(4, 3);
say &#34;$string - $partial&#34;; ## -&gt; abc*123*ABC - 123

$partial = &#34;9876543210&#34;;
say &#34;$string - $partial&#34;; ## -&gt; abc*9876543210*ABC - 987

$string = &#34;123|abc|456&#34;;
say &#34;$string - $partial&#34;; ## -&gt; 123|abc|456 - abc</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，即使我们将3个字符（123）替换为10（9876543210），别名在原始字符串中的位置和长度也相同。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_改变大小写">7.8. 改变大小写</h3>
<div class="paragraph">
<p>在练习 7.1 中，我们使用 <code>ord</code> 和 <code>chr</code> 将字母从大写改为小写，反之亦然，但是使用内置函数更容易。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">函数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小写</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标题大写</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tclc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标题小写</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大写</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">折叠大小写</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">wordcase</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单词大小写</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_lc小写">7.8.1. lc(小写)</h4>
<div class="paragraph">
<p>返回字符串的副本，其中所有字符都转换为小写。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;this is IT!&#34;.lc; # -&gt; this is it!</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tctitle_case">7.8.2. tc(Title Case)</h4>
<div class="paragraph">
<p>返回字符串的副本，其中第一个字符转换为标题大小写（如果标题大小写不可用，则转换为大写），其余字符保持不变。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;this is IT!&#34;.tc; # -&gt; This is IT!</code></pre>
</div>
</div>
<div class="paragraph">
<p>«Title Case» 与第一个字母的 «Upper Case» 几乎相同。 如果你感到好奇，请参阅 <a href="http://unicode.org/faq/casemap_charprop.html" class="bare">http://unicode.org/faq/casemap_charprop.html</a> 了解详细信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="_tclctitle_case_lower_case">7.8.3. tclc(Title Case Lower Case)</h4>
<div class="paragraph">
<p>返回字符串的副本，其中第一个字符转换为标题大小写（如果标题大小写不可用，则转换为大写），其余字符转换为小写。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;this is IT!&#34;.tclc; # -&gt; This is it!</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ucupper_case">7.8.4. uc(Upper Case)</h4>
<div class="paragraph">
<p>返回字符串的大写版本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;this is IT!&#34;.uc; # -&gt; THIS IS IT!</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_fcfold_case">7.8.5. fc(Fold Case)</h4>
<div class="paragraph">
<p>使用 Unicode «fold case» 方法返回字符串的版本。 建议仅将其用于字符串比较。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;this is IT!&#34;.fc; # -&gt; this is it!</code></pre>
</div>
</div>
<div class="paragraph">
<p>为什么推荐 «Case Folding»：我们可以将字符串转换为大写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;Saß&#34;.uc;  # -&gt; &#34;SASS&#34;
say &#34;Sass&#34;.uc; # -&gt; &#34;SASS&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>德语的小写字母 «double s» &#34;ß&#34; 转换为大写字母 &#34;SS&#34;（并且字符串的长度已更改）。 因此，如果我们比较字符串 &#34;Saß&#34;.uc 和 &#34;Sass&#34;.uc，它们是相等的。</p>
</div>
<div class="paragraph">
<p>转换为小写字母似乎更安全，而且我还没有找到一个不起作用的示例。 （请随时为我提供帮助。）但是，保证 «Case Folding» 能够正常工作。</p>
</div>
</div>
<div class="sect3">
<h4 id="_wordcase">7.8.6. wordcase</h4>
<div class="paragraph">
<p>返回字符串的副本，每个单词的第一个字符转换为大写，其余的转换为小写。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;this is IT!&#34;.wordcase; # -&gt; This Is It!</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>wordcase</code> 接受两个可选参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>:filter</code> - 代替内置 <code>wordcase</code> 使用的函数</p>
</li>
<li>
<p><code>:where</code>-一个布尔表达式，用于打开/关闭每个单词的转换</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;this is IT!&#34;.wordcase(:where({ .chars == 2 }) );              # -&gt; this Is It!
say &#34;this is IT!&#34;.wordcase(:filter(&amp;uc), :where({ .chars == 2 })); # -&gt; this IS IT!</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们在圆括号内的花括号中指定代码。 指定的过程不包含花括号，但带有 <code>&amp;</code> 前缀。</p>
</div>
<div class="paragraph">
<p>你为什么认为此函数没有正常的两个字母名称？</p>
</div>
<div class="paragraph">
<p><strong>练习 7.4</strong>
重写习题 7.1 中的 «swap-case»，以便它也转换 unicode 字母，即 a-z 以外的字母。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_x字符串重复运算符">7.9. x(字符串重复运算符)</h3>
<div class="paragraph">
<p>使用字符串重复运算符 <code>x</code> 将左侧的字符串重复右侧给出的次数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;123 &#34; x 2;  # -&gt; 123 123
say &#34;123 &#34; x pi; # -&gt; 123 123 123</code></pre>
</div>
</div>
<div class="paragraph">
<p>重复计数必须是数字（或可以转换为数字的数字），除非已经是整数，否则它将被截断。</p>
</div>
<div class="paragraph">
<p>不要将 <code>x</code> 用作乘法运算符。 不是。 在数字上使用它将对它们进行字符串化处理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>say 3 x 4; # -&gt; 3333
say 4 x 3; # -&gt; 444</pre>
</div>
</div>
<div class="paragraph">
<p>但是你可以使用 Unicode 乘法符号 <code>×</code>（带有代码点 «U+00D7»）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 3 × 4; # -&gt; 12
say 4 × 3; # -&gt; 12</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_succ">7.10. succ</h3>
<div class="paragraph">
<p>在数字上使用的 <code>succ</code>（后继）给我们的数字加一。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say pi.succ;  # -&gt; 4.141592653589793
say 109.succ; # -&gt; 110</code></pre>
</div>
</div>
<div class="paragraph">
<p>但这对字符串更有用（和更神奇）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;aa&#39;.succ; # -&gt; ab
say &#39;az&#39;.succ; # -&gt; ba
say &#39;α&#39;.succ;  # -&gt; β
say &#39;a9&#39;.succ; # -&gt; b0</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果字符串中没有点（句点或 <code>.</code>），则最后一个字母数字序列递增。 如果有一个或多个点，则第一个点之前的最后一个字母数字序列递增。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;a.a.a.a.a&#39;.succ;  # -&gt; b.a.a.a.a
say &#39;img001.png&#39;.succ; # -&gt; img002.png</code></pre>
</div>
</div>
<div class="paragraph">
<p>当到达字符范围的末尾（数字 0-9，字母 a-z 或其他 Unicode 范围）时，它将添加另一个字符（在数字情况下是正常的）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 99.succ;  # -&gt; 100
say &#39;z&#39;.succ; # -&gt; aa</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你已经拥有最高值，则什么都不会发生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say True.succ;  # -&gt; True
say False.succ; # -&gt; True
Inf.succ;       # -&gt; Inf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pred">7.11. pred</h3>
<div class="paragraph">
<p>数字上使用的 <code>pred</code>（前代）使我们的数字减一。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say pi.pred;  # -&gt; 2.141592653589793
say 100.pred; # -&gt; 99</code></pre>
</div>
</div>
<div class="paragraph">
<p>在字符串上使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;ab&#39;.pred; # -&gt; aa
say &#39;ba&#39;.pred; # -&gt; ax
say &#39;β&#39;.pred;  # -&gt; α
say &#39;b0&#39;.pred; # -&gt; a9</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果字符串中没有点（句号或 <code>.</code>），则最后一个字母数字序列递减。 如果有一个或多个点，则第一个点之前的最后一个字母数字序列将递减。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;b.a.a.a.a&#39;.pred;  # -&gt; a.a.a.a.a
say &#39;img002.png&#39;.pred; # -&gt; img001.png
say &#39;img000.png&#39;.pred; # -&gt; imf999.png</code></pre>
</div>
</div>
<div class="paragraph">
<p>但这不会减少字符数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;aaaa&#39;.pred; # -&gt; Decrement out of range ...
say &#39;100&#39;.pred;  # -&gt; 099</code></pre>
</div>
</div>
<div class="paragraph">
<p>（这与 <code>succ</code> 不同，后者在必要时添加另一个字符。）</p>
</div>
<div class="paragraph">
<p>如果你已经具有最低值，则将得到一个错误（如上所述）或相同的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say False.pred; # -&gt; False
say &#34;a&#34;.pred;   # -&gt; Decrement out of range ...
say -Inf.pred;  # -&gt; -Inf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_quoting">7.12. quoting</h3>
<div class="paragraph">
<p>我们在第 2.7.1 节&#34;字符串&#34;中描述了单引号和双引号，但是我们还有更多的引号构造：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">短形式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符串</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">结果</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">单引号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#39;ABC$a&#39;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ABC$a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有插值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Q</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Q#ABC$a# 或 Q{ABC$a}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ABC$a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有插值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">q</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">q*ABC$a*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ABC$a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有任何插值。 注意开始和结束字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">q:c</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">q:c/ABC$aX{$a}/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ABC12$aX12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">只有闭包被插值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">双引号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#34;ABC$a {$a}&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ABC12 12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">变量和闭包被插值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">qq</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">qq/ABC$a {$a}/&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ABC12 12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">变量和闭包被插值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">qw</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">引用单词; 查看 7.12.1 一节, qw(引用单词)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">qqw</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">引用单词(带插值); 查看 7.12.2 一节, qqw(带有插值的引用单词)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">qx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行程序, 查看 «高级 Raku» 课程</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">qqx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行程序, 查看 «高级 Raku» 课程</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>（鉴于我们在某处指定了 <code>my $a = 12</code>。）</p>
</div>
<div class="paragraph">
<p>闭包是在花括号中指定的东西。</p>
</div>
<div class="sect3">
<h4 id="_qw引用单词">7.12.1. qw(引用单词)</h4>
<div class="paragraph">
<p>这与在单引号字符串上应用 <code>words</code> 相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;1 $aaaaa 17&#39;.words; # -&gt; (1 $aaaaa 17)
say qw/1 $aaaaa 17/;     # -&gt; (1 $aaaaa 17)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_qqw带插值的引用单词">7.12.2. qqw(带插值的引用单词)</h4>
<div class="paragraph">
<p>这与在双引号字符串上应用 <code>words</code> 相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $aaaaa = &#34;X&#34;;
say &#34;1 $aaaaa 17&#34;words; # -&gt; (1 X 17)
say qqw/1 $aaaaa 17/;   # -&gt; (1 X 17)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_多行字符串heredocs">7.13. 多行字符串(Heredocs)</h3>
<div class="paragraph">
<p>打印多行字符串看起来不太好看，尤其是当我们需要嵌入换行符时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>print &#34;Line 1\nLine2\nline3\n&#34;;
# Line 1
# Line2
# line3</pre>
</div>
</div>
<div class="paragraph">
<p>一个更方便的方法是 heredoc：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say q:to/END/;
Here is
some multi-line
string
END</code></pre>
</div>
</div>
<div class="paragraph">
<p>heredoc 的内容总是从下一行开始。 结尾可以是任何文字字符串，只要我们预先指定即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say q:to/BLAH/;
Here is
some multi-line
string
BLAH</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果缩进了终止符（在本例中为 «END»），那么该缩进量将从字符串文字中删除。</p>
</div>
<div class="paragraph">
<p>这个 heredoc;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say q:to/END/;
    Here is
    some multi line
        string
    END</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Here is
some multi line
    string</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_heredocs_中的插值">7.13.1. heredocs 中的插值</h4>
<div class="paragraph">
<p>上面介绍的 heredocs 中没有任何内容。 但是我们可以使用第 7.12 节&#34;引用&#34;中描述的 <code>q</code>, <code>q:c</code> 和 <code>qq</code> 引用机制：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">开始</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">插值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">内容</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">结果</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">q:to/END/;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">nothing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$name and {$age}.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$name and {$age}.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">q:to:c/EOF/;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">只有闭包插值({} 中的变量)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$name and {$age}.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$name and 15.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">qq:to/EOF/;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">闭包和插值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$name and {$age}.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tom and 15.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>(在我们声明: <code>my $name = &#34;Tom&#34;; my $age = 15;</code> 的 地方。)</p>
</div>
</div>
<div class="sect3">
<h4 id="_缩进">7.13.2. 缩进</h4>
<div class="paragraph">
<p><code>indent</code> 方法由 heredocs 在内部使用来管理缩进，但可以直接使用（仅在字符串上）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;abc&#34;;
abc

&#34;abc&#34;.indent: 2;
  abc
&#34;abc&#34;.indent(3);
   abc
&#34;abc&#34;.indent: 10;
          abc</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_数组和列表">8. 数组和列表</h2>
<div class="sectionbody">
<div class="paragraph">
<p>数组是可变的，列表是不可变的。</p>
</div>
<div class="paragraph">
<p>创建数组并在方括号中显示（在输出中），并用括号显示列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say [1,2,4,5].^name; # -&gt; Array
&gt; say (1,2,4,5).^name; # -&gt; List</code></pre>
</div>
</div>
<div class="paragraph">
<p>将列表分配给数组变量会将其转换为数组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @something = (1,2,4,5); # -&gt; [1 2 4 5]
&gt; say @something.^name;      # -&gt; Array</code></pre>
</div>
</div>
<div class="paragraph">
<p>区别（和区别）并不重要，除非涉及到惰性列表。 没有延迟数组之类的东西，因此将延迟列表分配给数组会强制对其进行求值。</p>
</div>
<div class="paragraph">
<p>可以将列表分配给标量变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $something = (1,2,4,5); # -&gt; (1 2 4 5)
&gt; say $something.^name;      # -&gt; List</code></pre>
</div>
</div>
<div class="paragraph">
<p>将列表分配给标量变量将保留列表类型。 这意味着该变量是只读的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; $something[2] = 99;
Cannot modify an immutable List ((1 2 4 5))</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，例如 <code>say</code> 可以接收一个列表。 然后它将打印所有粘贴在一起的列表值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;ABC&#34; ~ &#34;123&#34; # -&gt; ABC123
say &#34;ABC, &#34;123&#34;   # -&gt; ABC123</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_列表操作符">8.1. ,(列表操作符)</h3>
<div class="paragraph">
<p>使用 <code>,</code>（逗号）列表运算符来生成列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;rune&#34;, &#34;helge&#34;, &#34;tom&#34;, &#34;jerry&#34;;
(rune helge tom jerry)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果可以使你感觉更好，请添加圆括号…​(圆括号只是分组运算符；请参见2.12.1，&#34;()(分组运算符)&#34;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (&#34;rune&#34;, &#34;helge&#34;, &#34;tom&#34;, &#34;jerry&#34;);
(rune helge tom jerry)</code></pre>
</div>
</div>
<div class="paragraph">
<p>字符串必须加引号，如上所示，但是如果值不包含空格，则可以使用缩写形式，如下一节所述。</p>
</div>
</div>
<div class="sect2">
<h3 id="_xxx引用单词">8.2. &lt;xxx&gt;(引用单词)</h3>
<div class="paragraph">
<p>这是 Quote Words 语法。 指定一个这样的字符串，它将转换为部分字符串的列表，并以空格（和空格，例如字符）作为分隔符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @a = &lt;Peter Paul Mary&gt;;  # -&gt; [Peter Paul Mary]
&gt; say @a.raku;                # -&gt; [&#34;Peter&#34;, &#34;Paul&#34;, &#34;Mary&#34;]
&gt; say &lt;rune helge tom jerry&gt;; # -&gt; (rune helge tom jerry)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另请参见第7.12.1节&#34;qw(Quote Words)&#34;。</p>
</div>
<div class="paragraph">
<p>请注意，变量不会插值；</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a =12;
&gt; say &lt;123 $a ss&gt;
(123 $a ss)</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个值看起来像一个数字，但是 Raku 是否将其当作一个值？ 我们可以检查：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &lt;123 $a ss&gt;.perl
(IntStr.new(123, &#34;123&#34;), &#34;\$a&#34;, &#34;ss&#34;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如 <code>IntStr</code> 的同种异体类型所报告的，它既是字符串，也是数字。 有关详细信息，请参见第6.6.2节&#34;IntStr和同种异体&#34;。</p>
</div>
<div class="paragraph">
<p>如果你不想使用同素异体字，请改用 <code>words</code>(请参见第7.4节&#34;words&#34;)，因为它会产生字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;123 $a ss&#34;.words.map( *.^name );
(Str Str Str)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_列表生成和异形体">8.2.1. 列表生成和异形体</h4>
<div class="paragraph">
<p>如果使用&#34;逗号运算符&#34;生成列表，则会得到要求的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1,2,3)[0].^name;       # -&gt; Int
&gt; say (&#34;1&#34;,&#34;2&#34;,&#34;3&#34;)[0].^name; # -&gt; Str</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果使用 <code>&lt;&gt;</code> 缩写形式，则将获得看起来像数字的事物的同种异体，如第6.6.2节&#34;IntStr和同种异体&#34;中所述。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &lt;1 2 3 4&gt;[0].^name; # -&gt; IntStr
&gt; say &lt;1.2 2 3&gt;[0].^name; # -&gt; RatStr
&gt; say &lt;A12 2 3&gt;[0].^name; # -&gt; Str</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_数组构造器">8.3. [](数组构造器)</h3>
<div class="paragraph">
<p>使用 <code>[</code> 和 <code>]</code> 数组构造器创建一个显式数组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say [1, 2, 3, 4].^name; # -&gt; Array</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，为数组变量（<code>@</code> 符号）分配某些内容将其强制为数组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @a = &lt;rune helge tom jerry&gt;;   # -&gt; [rune helge tom jerry]
&gt; say @a.^name;                     # -&gt; (Array)
&gt; say &lt;rune helge tom jerry&gt;.^name; # -&gt; (List)</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意优先级。 这是可行的，因为绑定运算符 <code>:=</code> 的优先级低于列表运算符 <code>,</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a := 1, 2, 3; # -&gt; (1 2 3)
&gt; say $a.^name;     # -&gt; List
&gt; say $a;           # -&gt; (1 2 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是用赋值运算符执行此操作无效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = 1, 2, 3; # -&gt; (1 2 3)
&gt; say $a.^name;    # -&gt; Int
&gt; say $a;          # -&gt; 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个值分配给 <code>$a</code>，然后返回。 然后，我们将 <code>2</code> 和 <code>3</code> 附加到该值以形成一个列表（返回并由 REPL 打印）。 但是该列表没有分配给变量，因此会丢失。</p>
</div>
<div class="paragraph">
<p>解决方法是，使用数组构造函数 <code>[]</code> 或分组运算符 <code>()</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = [1, 2, 3];  # -&gt; [1 2 3]
&gt; say $a.^name;       # -&gt; Array

&gt; my $b = (1, 2, 3);  # -&gt; (1 2 3)
&gt; say $b.^name;       # -&gt; List</code></pre>
</div>
</div>
<div class="paragraph">
<p>列表是只读的，因此 <code>$b</code> 本质上是常量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; $a[1] = 4; # -&gt; 4
&gt; say $a; # -&gt; [1 4 3]
&gt; $b[1] = 4;
Cannot modify an immutable List ((1 2 3))
  in block &lt;unit&gt; at &lt;unknown file&gt; line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>它对数组有作用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @a = 1, 2, 3; # -&gt; [1 2 3]
&gt; say @a;          # -&gt; [1 2 3]</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_手动创建异形体">8.3.1. 手动创建异形体</h4>
<div class="paragraph">
<p>我们可以创建一个具有显式(<code>IntStr.new(123, &#34;123&#34;</code>) 的同种异体，如上所示。</p>
</div>
<div class="paragraph">
<p>但这样做更容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = &lt;12&gt;; say $a.^name;   # -&gt; IntStr
&gt; my ba = &lt;12.1&gt;; say $b.^name; # -&gt; RatStr</code></pre>
</div>
</div>
<div class="paragraph">
<p>你不必指定同种异体类型（实际上不能）。 Raku会为你解决这个问题。</p>
</div>
<div class="paragraph">
<p>如果你在字符串（或变量）中包含值，则可以将其转换为同种异体，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = &#34;12&#34;; say $a.^name; # -&gt; Str
&gt; say &lt;&lt;$a&gt;&gt;.^name;           # -&gt; IntStr</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者你可以使用 <code>val</code> 例程:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say val($a).^name; # -&gt; IntStr</code></pre>
</div>
</div>
<div class="paragraph">
<p>它只作用于字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say val(&#34;12&#34;).^name;   # -&gt; IntStr
&gt; say val(&#34;12.1&#34;).^name; # -&gt; RatStr
&gt; say val(12).^name;
Value of type Int uselessly passed to val()</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>val</code> 无法用作方法。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_xxx带插值的单词引用">8.4. <a href="#xxx">[xxx]</a>(带插值的单词引用)</h3>
<div class="paragraph">
<p>如果我们将&#34;引号&#34;加倍，则可以进行插值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = 12;
&gt; say &lt;&lt;123 $a ss&gt;&gt;; # -&gt; (123 12 ss)</code></pre>
</div>
</div>
<div class="paragraph">
<p>带有 unicode 字符 <code>«</code> 和 <code>«</code> 的«法语引号»同样适用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say «123 $a ss»; # -&gt; (123 12 ss)</code></pre>
</div>
</div>
<div class="paragraph">
<p>查看章节 7.12.2, &#34;qqw(带插值的单词引用)&#34;</p>
</div>
</div>
<div class="sect2">
<h3 id="_empty">8.5. Empty</h3>
<div class="paragraph">
<p>使用 &#34;Empty&#34; 获取一个空列表。</p>
</div>
<div class="paragraph">
<p>所有这些都是相等的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">my @a;         # No values.
my @b = ();    # Explicit
my @c = Empty; # Also possible</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_列表元素">8.6. 列表元素</h3>
<div class="paragraph">
<p>你可以按索引访问单个项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (&#34;a&#34; .. &#34;z&#34;)[25]; # -&gt; z

&gt; my @d = &lt;helge tom barry&gt;; say @d[0];  # And NOT $d[0] as in perl5!
helge</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使我们使用了标量赋值，它也可以工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = [1, 2, 3, 4]; say $a[2]; # -&gt; 3
&gt; my $b = (1, 2, 3, 4); say $b[2]; # -&gt; 3</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pop_push_shift_unshift">8.7. pop / push / shift / unshift</h3>
<div class="paragraph">
<p>我们有一些运算符可从列表中添加或删除值：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">函数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pop</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remove one element from the end</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">push</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Add the element(s) at the end</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">shift</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remove one element from the beginning</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">unshift</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Add the element(s) at the beginning</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>初始化数组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = &lt;11 22 33 44 55&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>从末尾移除一个元素(<code>55</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@a.pop; # -&gt; 55</code></pre>
</div>
</div>
<div class="paragraph">
<p>在末尾添加一个元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@a.push(66);</code></pre>
</div>
</div>
<div class="paragraph">
<p>从开头移除一个元素(<code>11</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">@a.shift; # -&gt; 11</code></pre>
</div>
</div>
<div class="paragraph">
<p>在开头添加一个元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@a.unshift(77);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以通过 <code>push</code> 和 <code>unshift</code> 同时添加多个元素，如下所示：</p>
</div>
<div class="listingblock">
<div class="title">初始化数组</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = &lt;11 22 33 44&gt;;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">在末尾添加两个元素</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@a.push(55, 66);</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>pop</code> 和 <code>shift</code> 只会一次删除一项。</p>
</div>
<div class="sect3">
<h4 id="_elems列表大小">8.7.1. elems(列表大小)</h4>
<div class="paragraph">
<p>使用 <code>elems</code> 获取列表中元素的数量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $number-of-elements = @d.elems;
&gt; my $number-of-elements = elems @d;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该值是只读的，不能用于更改元素数。</p>
</div>
<div class="paragraph">
<p>没有 «length» 方法或函数。</p>
</div>
<div class="paragraph">
<p>我们还可以通过在数字上下文中计算列表来获取元素数量：…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say +(&#34;a&#34; .. &#34;z&#34;); # -&gt; 26</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>end</strong></p>
</div>
<div class="paragraph">
<p>使用 <code>end</code> 获取列表中最后一个元素的索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (&#34;a&#34; .. &#34;z&#34;).end; # -&gt; 25</code></pre>
</div>
</div>
<div class="paragraph">
<p>该值比 <code>elems</code> 返回的值小 1（因为第一个元素的索引或偏移量为0）。</p>
</div>
<div class="paragraph">
<p>对于空数组，它给出 <code>-1</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a; say @a.end; # -&gt; -1</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，列表中的元素数实际上是列表中最后定义的元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @a;
&gt; say @a.elems; # -&gt; 0
&gt; say @a.end;   # -&gt; -1

&gt; my @b = (1);
&gt; say @b.elems; # -&gt; 1
&gt; say @b.end;   # -&gt; 0

&gt; @b[10] = &#39;s&#39;;
&gt; say @a.elems; # -&gt; 10
&gt; say @a.end;   # -&gt; 11</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么我们可以用它们做什么呢？</p>
</div>
</div>
<div class="sect3">
<h4 id="_栈">8.7.2. 栈</h4>
<div class="paragraph">
<p>堆栈是一种易于实现且没有太多开销的数据结构，这就是为什么它在低级编程中被大量使用的原因。 添加到堆栈中的最后一个元素是第一个检索到的元素。</p>
</div>
<div class="paragraph">
<p>使用 <code>unshift</code> 和 <code>pop</code> 进行堆栈：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @stack = ...;

@stack.unshift($customer-id); # Add one element to the stack

my $current = @stack.pop;     # Get one element from the stack</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_队列">8.7.3. 队列</h4>
<div class="paragraph">
<p>队列是一种数据结构，其中条目按添加顺序返回。 这通常是你对待等待客户的方式。</p>
</div>
<div class="paragraph">
<p>使用 <code>push</code> 和 <code>shift</code> 制作队列：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @queue = ...;

@queue.push($customer-id);  # Add one element to the queue

my $current = @queue.shift; # Get one element from the queue</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_rotate列表旋转">8.8. rotate(列表旋转)</h3>
<div class="paragraph">
<p>列表旋转可以通过 <code>push/shift</code>（向左）和 <code>unshift/pop</code>（向右）来完成，但是使用内置的 <code>rotate</code> 更容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">(1,2,3,4,5,6).rotate; # Left. The same as rotate(1)
(2 3 4 5 6 1)

&gt; (1,2,3,4,5,6).rotate(2)
(3 4 5 6 1 2)

&gt; (1,2,3,4,5,6).rotate(-2) # Right
(5 6 1 2 3 4)</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>rotate</code> 不会更改原始列表，但会返回修改后的版本。</p>
</div>
</div>
<div class="sect2">
<h3 id="_列表的列表">8.9. 列表的列表</h3>
<div class="paragraph">
<p>Raku 不会自动展平列表（与 Perl 相对），因此将列表添加（通过 <code>push</code> 或 <code>unshift</code>）到列表中的结果是具有一个项目的列表-第二个列表：</p>
</div>
<div class="listingblock">
<div class="title">初始化数组</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = &lt;11 22 33 44&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">在数组最后添加两个元素</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @b = &lt;55 66&gt;; @a.push(@b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>可能不是你的想法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_展平列表">8.10. 展平列表</h3>
<div class="paragraph">
<p>如果要将第二个列表的各个值插入列表，请使用 <code>prepend</code>（而不是 <code>unshift</code> 和 <code>append</code>（而不是 <code>push</code>））：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @list1 = 1,2,3,4,5;
[1 2 3 4 5]

&gt; my @list2 = 8,9;
[8 9]

&gt; @list1.append(@list2); # push the individual values
[1 2 3 4 5 8 9]

&gt; @list1.prepend(@list2); # unshift the individual values
[8 9 1 2 3 4 5 8 9]</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 <code>append</code> 和 <code>prepend</code> 同时添加多个元素，此处显示为 <code>append</code>：</p>
</div>
<div class="listingblock">
<div class="title">初始化数组</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = &lt;11 22 33 44&gt;;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">在数组最后添加两个元素</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @b = &lt;55 66&gt;; @a.append(@b);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_数组切片">8.11. 数组切片</h3>
<div class="paragraph">
<p>我们可以访问几项（称为数组切片）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @a = 1,2,3,4,5,6,7,8,9,10,11,12,13;
&gt; @a[0 .. 9]; # The same as [0,1,2,3,4,5,6,7,8,9]
(1 2 3 4 5 6 7 8 9 10)</code></pre>
</div>
</div>
<div class="paragraph">
<p>它们不需要是连续的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say @a[0,9,2]; # - &gt; (1 10 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>数组切片是可写的，即我们可以为其赋值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @a = &lt;10 9 8 7 6 5 4 3 2 1 0&gt;;

&gt; say @a[2,4,6,8,10,0];       # -&gt; (8 6 4 2 0 10)
&gt; say @a[2,4,6,8,10,0].=sort; # -&gt; (0 2 4 6 8 10)
&gt; say @a;                     # -&gt; [10 9 0 7 2 5 4 3 6 1 8]</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们从一个数字从10到0的列表开始。然后我们选择了其中一些，给出了一个新的值列表。 然后，我们对该列表进行排序，然后将排序后的列表分配回去（使用赋值运算符 <code>=</code> 的 <code>.=</code> 形式）。 最后，我们显示结果。</p>
</div>
<div class="paragraph">
<p>另一个示例（可能会有帮助的插图）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @array = 10, 4, 1, 8, 12, 3;
&gt; my @indices = 0, 2, 5;
&gt; my @values = @array[@indices]; # -&gt; (10 1 3)
&gt; my @sorted = @values.sort;     # -&gt; (1 3 10)

&gt; @array[@indices] = @sorted;    # -&gt; (1 3 10)

&gt; say @array; # -&gt; [1 4 3 8 12 10]</code></pre>
</div>
</div>
<div class="paragraph">
<p>![img]()</p>
</div>
<div class="paragraph">
<p>我们可以把代码写的更紧凑:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @array = 10, 4, 1, 8, 12, 3;
&gt; @array[0,2,5].= sort;
&gt; say @array;

[1 4 3 8 12 10]</code></pre>
</div>
</div>
<div class="paragraph">
<p>尝试删除值并不能完全解决：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @a = 1..10;  # -&gt; [1 2 3 4 5 6 7 8 9 10]
&gt; @a[2,4,5] = (); # -&gt; ((Any) (Any) (Any))
&gt; say @a;         # -&gt; [1 2 (Any) 4 (Any) (Any) 7 8 9 10]</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是我们可以使用 <code>splice</code>，我们将在下一节中介绍。</p>
</div>
</div>
<div class="sect2">
<h3 id="_splice">8.12. splice</h3>
<div class="paragraph">
<p>使用 <code>splice</code> 从列表中删除一些元素。 返回删除的元素。</p>
</div>
<div class="paragraph">
<p>我们可以像这样从给定索引中删除到结尾：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; @a.splice(5); # Leave the first 5 items, and remove the rest.</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以指定要删除的项数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; @a.splice(5,2); # Leave the first 5 items, remove the next 2, and leave the rest.</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以插入另一个列表来代替我们删除的元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; @a.splice(5,2, @list); # Leave the first 5 items, remove the next 2 and replace
                         # with `@list`, and leave the rest as well.</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，替换列表的大小不必与已删除项目的数量相同。</p>
</div>
<div class="paragraph">
<p>替换值也可以指定为标量。</p>
</div>
<div class="paragraph">
<p>总结：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">代码</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@a 的值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@b 的值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">my @a = &#34;a&#34; .. &#34;n&#34;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[a b c d e f g h i j k l m n]</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">my @b = @a.splice(5)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[a b c d e]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[f g h i j k l m n]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">my @b = @a.splice(5,2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[a b c d e h i j k l m n]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[f g]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">my @b = @a.splice(5,2, &lt;A B C&gt;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[a b c d e A B C h i j k l m n]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[ f g]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">my @b = @a.splice(5,2, 9,9,9,9)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[a b c d e 9 9 9 9 h i j k l m n]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[f g]</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>请注意，在每次 <code>splice</code> 之前，我们都必须将 &#34;@a&#34; 重置为初始值。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>splice</code> 在列表中插入一个（或多个）新值，而无需通过将 <code>0</code> 指定为第二个参数来删除任何内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @b = @a.splice(10, 0, 3.14);
[]

&gt; say @a;
[a b c d e f g h i j 3.14 k l m n]</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_展平运算符">8.12.1. |(展平运算符)</h4>
<div class="paragraph">
<p>我们可以通过在列表前添加 <code>|</code> （竖线）来拼合列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @list1 = 1,2,3,4,5;
[1 2 3 4 5]

&gt; my @list2 = 8,9;
[8 9]

&gt; @list1.push(@list2);
[1 2 3 4 5 [8 9]]

&gt; @list1.push(|@list2); # push the individual values, and not the list
[1 2 3 4 5 8 9]</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，仅在顶层（而不是递归方式）执行展平。</p>
</div>
</div>
<div class="sect3">
<h4 id="_flat">8.12.2. flat</h4>
<div class="paragraph">
<p>或使用更冗长（和明确）的 <code>flat</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1, (2, (3, 4)), 5).flat;
(1 2 3 4 5)</code></pre>
</div>
</div>
<div class="paragraph">
<p>展平不会递归展平数组，而只是列表（如上所示）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @a = (1,2);            # -&gt; [1 2]
&gt; my @b = (1, 2, @a, 1, 2); # -&gt; [1 2 [1 2] 1 2]
&gt; @b.flat;                  # -&gt; (1 2 [1 2] 1 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用超运算符强制它使数组变平:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; @b».List.flat;  # Unicode version
&gt; @b&gt;&gt;.List.flat; # ASCII version</code></pre>
</div>
</div>
<div class="paragraph">
<p>超运算符将在&#34;高级 Raku&#34;课程中介绍。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_map">8.13. map</h3>
<div class="paragraph">
<p>使用 <code>map</code> 将一些代码应用于列表中的每个元素。 它使原始列表保持不变，并返回修改后的版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @a = 1..10;       # -&gt; [1 2 3 4 5 6 7 8 9 10]
&gt; @a.map({ $^a + 1 }); # -&gt; (2 3 4 5 6 7 8 9 10 11)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用花括号来传递代码块。 对每个值执行该块，并将结果放置在结果列表中。</p>
</div>
<div class="paragraph">
<p>请注意，<code>map</code> 仅关心其所用列表的顶层。 有关详细信息，请参见 <code>deepmap</code>(在第8.13.4节 &#34;deepmap&#34; 中)。</p>
</div>
<div class="sect3">
<h4 id="_占位符变量">8.13.1. 占位符变量</h4>
<div class="paragraph">
<p>twigil(请参见第2.2.2节&#34;Twigils&#34;) <code>^</code> 表示它是一个占位符变量。 只要有 twigil，它就可以随便命名。</p>
</div>
<div class="paragraph">
<p><strong>练习 8.1</strong>
这个代码的结果是什么:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1 .. 10).map({ $^a + $^b });</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关占位符变量的详细说明，请参见第10章，过程和第10.4节&#34;占位符变量&#34;。</p>
</div>
</div>
<div class="sect3">
<h4 id="_block_块儿">8.13.2. Block 块儿</h4>
<div class="paragraph">
<p>我们可以将任何代码块作为参数传递。 主题变量保存当前值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; @a.map( { .sqrt } );</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>map</code> 是惰性的，因此直到需要它们时才计算值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_whatever_star">8.13.3. *(Whatever Star)</h4>
<div class="paragraph">
<p>如果我们只需要一个方法调用，则可以使用  Whatever Star 节省一个花括号块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1..10).map( *.sqrt );
(1 1.4142135623730951 1.7320508075688772 2 2.23606797749979)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们也可以有简单的表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1..10).map(* + 1); # -&gt; (2 3 4 5 6 7 8 9 10 11)</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，当我们使用 Whatever Star 时，花括号是非法的。</p>
</div>
<div class="paragraph">
<p>而且我们可以对表达式取反（因此， Whatever Star 都不必成为表达式中的第一个字符）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1 .. 25).grep(! *.is-prime);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>grep</code> 在第8.21.1节&#34;grep&#34;中进行了描述。 它选择通过条件的值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_deepmap">8.13.4. deepmap</h4>
<div class="paragraph">
<p>使用 <code>deepmap</code> 可以将代码应用于列表中的每个元素，而不仅仅是像 <code>map</code> 那样在顶层应用。</p>
</div>
<div class="paragraph">
<p><code>map</code> 和 <code>deepmap</code> 之间的区别可以总结如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @a = ((1,2),(3,(4,5)));

&gt; @a.map( * +1 );     # -&gt; (3 3)
&gt; @a.deepmap( * +1 ); # -&gt; [(2 3) (4 (5 6))]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>deepmap</code> 递归遍历结构，向每个元素加一。</p>
</div>
<div class="paragraph">
<p><code>map</code> 仅看到第一级，即第一个是包含两个项目（1和2）的列表，然后是另一个包含两个项目（3和一个新列表（包含项目4和5））的列表。 <code>+1</code> 将值强制为数字，列表的数字值为大小。 所以我们得到2，因为它有2个项目。 下一个列表也有两个项目（一个值和一个新列表），因此还有2个。<code>+1</code> 给出最终结果（3,3）。</p>
</div>
<div class="paragraph">
<p>也有 <code>flatmap</code>（不建议使用），<code>nodemap</code> 和 <code>duckmap</code>。 详情参见《高级 Raku》课程。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sort">8.14. sort</h3>
<div class="paragraph">
<p>使用 <code>sort</code> 对列表进行排序。 它知道类型，因此在给定数字时将按数字排序，在给定字符串时将按字符串排序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1, 2, 11, 0, 3, -1).sort; # -&gt; (-1 0 1 2 3 11)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你混合使用数字和字符串，则会得到有趣的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1, 2, 11, 0, &#34;3&#34;, -1).sort; # -&gt; (-1 0 1 2 11 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们对字符串进行排序时，它使用 Unicode 规范中的字符顺序，这与英语字母(A-Z和a-z)的 Isolatin 和 ASCII 顺序相同。 因此，大写字母先于所有小写字母。</p>
</div>
<div class="paragraph">
<p>如果我们有一个单词列表，有些带有一个首字母大写，有些没有，那么我们将在小写之前得到大写单词。</p>
</div>
<div class="paragraph">
<p>我们可以通过给它一个自定义的比较代码块来告诉 <code>sort</code> 如何排序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">@words.sort( { $^a.fc cmp $^b.fc } );</code></pre>
</div>
</div>
<div class="paragraph">
<p>在比较它们之前，我们应用 <code>fc</code>（折叠式；请参见第7.8.5节&#34;fc(Fold Case)&#34;）将所有字符串转换为无大小写的版本。</p>
</div>
<div class="paragraph">
<p>块的内部指定了在编译器进行排序时如何比较任何两个元素； <code>$^a</code> 是第一个，<code>$^b</code> 是第二个。 我们使用这两个占位符变量名称（作为单个 <code>*</code> 无论星号如何均无效），并且如果需要，它们可以在表达式中多次使用。</p>
</div>
<div class="paragraph">
<p><code>cmp</code>(请参阅第3.7.1节&#34;cmp&#34;）是三向比较运算符，它为我们（或更确切地说，为排序）做着工作。</p>
</div>
<div class="paragraph">
<p>当我们内联指定比较代码时，需要花括号。 可以像这样为我们指定完成此过程的过程的引用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">.sort( &amp;compare-elements )</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果计算的代码比上面的简单示例更多，请执行此操作。</p>
</div>
<div class="paragraph">
<p>注意 <code>&amp;</code> 符号。 它告诉编译器传递对代码的引用。 如果我们跳过它，该过程将立即执行。</p>
</div>
<div class="paragraph">
<p>有关过程的介绍，请参见第10章，过程。</p>
</div>
<div class="paragraph">
<p>有一种感知排序版本叫 <code>collate</code>。 详情参见《高级 Raku》课程。</p>
</div>
</div>
<div class="sect2">
<h3 id="_reverse">8.15. reverse</h3>
<div class="paragraph">
<p>我们可以使用 reverse 方法翻转列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @num1 = 1 .. 10;
[1 2 3 4 5 6 7 8 9 10]

&gt; my @num2 = @num1.reverse
[10 9 8 7 6 5 4 3 2 1]</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们只是使用 <code>reverse</code> 来生成向下计数的范围，但这确实是我们应该使用序列的方式。 我们将在第16章，范围和序列中讨论它们。</p>
</div>
<div class="paragraph">
<p>我们可以对列表进行排序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @num3 = @num1.sort({$^b.fc &lt;=&gt; $^a.fc});</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_交换两个变量">8.15.1. 交换两个变量</h4>
<div class="paragraph">
<p>在一个«普通»编程语言中交换两个变量需要一个临时变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 1;
my $b = 2;

my $tmp = $a; $a = $b; $b = $tmp;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以用一个列表赋值来完成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">($a, $b) = ($b, $a);</code></pre>
</div>
</div>
<div class="paragraph">
<p>或使用 <code>reverse</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">($a, $b) .= reverse;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_数组限制">8.16. 数组限制</h3>
<div class="paragraph">
<p>我们可以指定一个数组的大小限制:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @d[10] = &lt;rune helge tom jerry&gt;;
[rune helge tom jerry]

&gt; my @d[3] = &lt;rune helge tom jerry&gt;;
Index 3 for dimension 1 out of range (must be 0..2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，限制是项的数量，而不是最后一项的索引。</p>
</div>
</div>
<div class="sect2">
<h3 id="_带类型的数组">8.17. 带类型的数组</h3>
<div class="paragraph">
<p>我们可以在数组的值上添加类型约束，如3.1节&#34;强类型&#34;所述:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my Int @values;
&gt; my @values of Int;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>of</code> 以获取类型约束:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my Int @values; say @values.of; # -&gt; (Int)
&gt; my @values; say @values.of;     # -&gt; (Mu)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_shaped_array">8.18. Shaped Array</h3>
<div class="paragraph">
<p>形数组是一个具有多个维度的数组。</p>
</div>
<div class="paragraph">
<p>我们访问这样一个形状数组中的单个单元格;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @a; @a[1;2;3]   = 2;
&gt; my @a; @a[1][2][3] = 2; # The same</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以像这样访问其中的&#34;一行&#34;:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; @a[1;2;*]; # -&gt; ((Any) (Any) (Any) 2) ## List
&gt; @a[1][2]; # -&gt; [(Any) (Any) (Any) 2]  ## Array</code></pre>
</div>
</div>
<div class="paragraph">
<p>不是类型上的细微差别。</p>
</div>
<div class="paragraph">
<p>而是整个数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; @a; # -&gt; [(Any) [(Any) (Any) [(Any) (Any) (Any) 2]]]</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_固定大小的数组">8.18.1. 固定大小的数组</h4>
<div class="paragraph">
<p>我们也可以限制形状数组的大小:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @a[3;3;3];
&gt; @a[3;3;3] = 12
Index 3 for dimension 3 out of range (must be 0..2)
  in block &lt;unit&gt; at &lt;unknown file&gt; line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>常规索引规则适用，因此第一项的索引（偏移量）为 <code>0</code>。</p>
</div>
<div class="paragraph">
<p>我们可以为形状数组分配一个列表列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt;  my @a[3;3] = ((1,2,3), (4,5,6), (7,8,9))
[[1 2 3] [4 5 6] [7 8 9]]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_shape">8.18.2. shape</h4>
<div class="paragraph">
<p>以列表形式返回数组的形状。 请注意，当我们仅给数组指定显式形状时，此方法有效。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">my @foo[2;3] = ( &lt; 1 2 3 &gt;, &lt; 4 5 6 &gt; ); # Array with fixed dimensions
say @foo.shape;                          # -&gt; (2 3)
my @bar = ( &lt; 1 2 3 &gt;, &lt; 4 5 6 &gt; );      # Normal array (of arrays)
say @bar.shape;                          # -&gt; (*)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_shaped_arrays_usage">8.18.3. Shaped Arrays Usage</h4>
<div class="paragraph">
<p>形状阵列可以像矩阵一样使用。 没有内置的运算符可以处理矩阵，因此像 «Math::Matrix» 这样的模块是更安全的选择。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_unique不重复的列表">8.19. unique(不重复的列表)</h3>
<div class="paragraph">
<p>使用 <code>unique</code> 获得列表的副本，但不重复：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1,1,2,3,4,5,1,6).unique
(1 2 3 4 5 6)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你知道列表已排序，请使用 <code>squish</code> 而不是 <code>unique</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1,1,2,3,4,5,5,6).squish # OK
(1 2 3 4 5 6)

&gt; (1,1,2,3,4,5,1,6).squish # Wrong usage.
(1 2 3 4 5 1 6)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_repeated">8.19.1. repeated</h4>
<div class="paragraph">
<p><code>repeated</code> 方法与 <code>unique</code> 方法相反，因为它仅返回重复项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1, 2, 1, 2, 3,4,5,6,1).repeated;
(1 2 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>每次重复，它们都会发生一次，并且列表不会排序。 我们可以修复重复项并对其进行排序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1, 2, 1, 2, 3,4,5,6,1).repeated.sort.squish;
(1 2)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_xx列表重复运算符">8.20. xx(列表重复运算符)</h3>
<div class="paragraph">
<p>使用 <code>xx</code> 重复左侧的列表或值，次数为右侧给出的次数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;abc&#34; xx 3
(abc abc abc)

&gt; &#34;abc &#34; xx 2
(abc abc)

&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该数字必须是整数，或者可以强制为整数的值。 零或负整数将返回一个空字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;abc&#34; xx 0;                  # -&gt; ()
&gt; my $a = (True, False) xx 3;  # -&gt; ((True False) (True False) (True False))
&gt; my $b = |(True, False) xx 3; # -&gt; (True False True False True False)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以通过在右边指定一个 <code>*</code>（一个&#34;Whatever Star&#34;）来生成一个无限列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $c = |(True, False) xx *</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关用例，请参见第16.3.6节&#34;列表重复运算符和序列&#34;。</p>
</div>
<div class="paragraph">
<p>注意与字符串重复运算符 <code>x</code> 相似（如第7.9节&#34;x(字符串重复运算符)&#34;所述）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_列表选择">8.21. 列表选择</h3>
<div class="paragraph">
<p>使用 <code>map</code> 将更改应用于所有值，并使用 <code>grep</code> 选择一些值。</p>
</div>
<div class="paragraph">
<p><code>grep</code> 返回一个列表。 如果只需要第一个值，请改用 <code>first</code>。 （请参见第8.21.2节&#34;first&#34;。）</p>
</div>
<div class="paragraph">
<p>如果你仅对至少存在一个匹配项感兴趣，那么 <code>any</code>（与第3.4.1节&#34;Nil &amp; Any&#34;中所述的&#34;Any&#34;都不相同）可能会有用。 有关详细信息，请参见《高级 Raku》课程。</p>
</div>
<div class="sect3">
<h4 id="_grep">8.21.1. grep</h4>
<div class="paragraph">
<p>使用 <code>grep</code> 从列表中选择一些值。</p>
</div>
<div class="paragraph">
<p>不可被3整除的整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1 .. 25).grep(* % 3);
(1 2 4 5 7 8 10 11 13 14 16 17 19 20 22 23 25)</code></pre>
</div>
</div>
<div class="paragraph">
<p>只选择非素数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1 .. 25).grep(! *.is-prime);
(1 4 6 8 9 10 12 14 15 16 18 20 21 22 24 25)</code></pre>
</div>
</div>
<div class="paragraph">
<p>只选择整数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1, 1.5, 2, 2.5, 3, 3.5, 4).grep(Int);
(1 2 3 4)</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 8.2</strong></p>
</div>
<div class="paragraph">
<p>获取所有两位数的质数，并计数。</p>
</div>
<div class="paragraph">
<p>提示：使用 <code>grep</code> 和 <code>is-prime</code>（请参阅第5.12节&#34;is-prime(素数)&#34;）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_first">8.21.2. first</h4>
<div class="paragraph">
<p><code>first</code> 方法（和函数）类似于 <code>grep</code>，不同之处在于它仅返回第一个匹配项。 如果你只需要一次匹配，请使用此选项，因为这样会更快。</p>
</div>
<div class="paragraph">
<p>在（包括）1000之后的第一个素数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1000 .. Inf).first(*.is-prime);
1009</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果未找到匹配项，则返回 <code>Nil</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (0.1 .. 0.9).first(*.is-prime);
Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有单独的 «last» 方法，但是使用可选的命名参数：<code>end</code> 表示搜索应从列表的末尾开始，而不是从头开始。</p>
</div>
<div class="paragraph">
<p>最高素数低于 1000:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1 ..^ 1000).first(:end, *.is-prime);
997</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_head">8.21.3. head</h4>
<div class="paragraph">
<p>从列表的开头返回指定的项目数。 如果未指定大小，则默认为1：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1 .. Inf).head
1

&gt; (-1 .. Inf).head(2)
(-1 0)

&gt; &lt;a b c d 12&gt;.head
a</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tail">8.21.4. tail</h4>
<div class="paragraph">
<p>从列表末尾返回指定数量的项目。 如果未指定大小，则默认为1：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &lt;a b c d 12&gt;.tail
12</code></pre>
</div>
</div>
<div class="paragraph">
<p>不要在无限列表上使用 <code>tail</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (-Inf .. Inf).tail
Cannot tail a lazy list
  in block &lt;unit&gt; at &lt;unknown file&gt; line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是 <code>head</code> 工作（我会说令人惊讶）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (-Inf .. Inf).head
-Inf</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_minmax">8.22. min/max</h3>
<div class="paragraph">
<p><code>min</code> 返回列表中的最小值, <code>max</code> 返回列表中的最大值。</p>
</div>
<div class="paragraph">
<p>使用数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1 .. 10).min; # -&gt; 1
&gt; max 1 .. 10;   # -&gt; 10
&gt; (1 .. *).max;  # -&gt; Inf</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &lt;aa a abc d f ff e&gt;.min; # -&gt; a
&gt; &lt;aa a abc d f ff e&gt;.max; # -&gt; ff</code></pre>
</div>
</div>
<div class="paragraph">
<p>它们也可以用作中缀运算符，并且可以堆叠：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say 8 min 10;                      # -&gt; 8
&gt; say 8 min 10 min 2 min 99 min -19; # -&gt; -19</code></pre>
</div>
</div>
<div class="paragraph">
<p>未定义的值将被忽略，因此以下代码也有效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (5, Nil, 100, 2).min; # -&gt; 2</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_随机值">8.23. 随机值</h3>
<div class="paragraph">
<p>随机值很重要，并且很难实现。 大多数编程语言都使用伪随机数，看起来有些随机，但实际上不是。 Raku 也不例外。 这足够好，除非你需要真正的随机性进行加密。</p>
</div>
<div class="sect3">
<h4 id="_rand">8.23.1. rand</h4>
<div class="paragraph">
<p><code>rand</code> 作为函数给出介于零（包含）和1（非包含）之间的伪随机数（<code>Num</code> 类型）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; rand; # -&gt; 0.4214056307236411
&gt; rand; # -&gt; 0.7753853239550014</code></pre>
</div>
</div>
<div class="paragraph">
<p>当用作值的方法时，它返回介于零（包含）和给定值（非包含）之间的伪随机数（类型为 <code>Num</code>）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; 100.rand; # -&gt; 51.322528184845</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 8.3</strong></p>
</div>
<div class="paragraph">
<p>编写代码，以选择介于10到99之间的随机整数（均包括在内）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_pick">8.23.2. pick</h4>
<div class="paragraph">
<p>随机值通常用作列表的索引。 Raku 有一个常规的选择，可用于列表（或范围）以从中获取随机元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; @colours.pick;   # From an array
&gt; (10 .. 99).pick; # From a range</code></pre>
</div>
</div>
<div class="paragraph">
<p>提示最后一个比我们在上面的练习中使用的 <code>rand</code> 代码更容易编写和理解。</p>
</div>
<div class="paragraph">
<p>如果该值用作数组索引，请直接在数组上使用 <code>pick</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (&#34;red&#34;, &#34;blue&#34;, &#34;green&#34;, &#34;yellow&#34;).pick</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以同时要求更多的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (10 .. 99).pick(10);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样可以从范围中随机选择10个值，而无需重复。 如果你想要多个值，请问：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (&#34;red&#34;, &#34;blue&#34;, &#34;green&#34;, &#34;yellow&#34;).pick(2);
(red yellow)</code></pre>
</div>
</div>
<div class="paragraph">
<p>此 <code>pick</code> 调用将不重复这些值。</p>
</div>
<div class="paragraph">
<p>如果你要求提供更多的价值，它将提供尽可能多的价值（无需抱怨）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (&#34;red&#34;, &#34;blue&#34;, &#34;green&#34;, &#34;yellow&#34;).pick(9);
(green yellow red blue)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果希望全部使用，请使用以下语法使其显而易见：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &lt;red blue green yellow&gt;pick(*);
(green yellow blue red)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一种以随机顺序对列表进行排序的简便方法。</p>
</div>
<div class="paragraph">
<p><strong>练习 8.4</strong></p>
</div>
<div class="paragraph">
<p>编写一段代码（在 <code>REPL</code> 中），该代码返回介于1和指定数字之间的随机质数。</p>
</div>
<div class="paragraph">
<p>使用100和1000作为限制。</p>
</div>
<div class="paragraph">
<p><strong>有重复的 pick</strong></p>
</div>
<div class="paragraph">
<p>通过应用循环可以实现重复：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1 .. 6).pick for ^3 5
2
5</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可以用于掷骰子很多次。</p>
</div>
<div class="paragraph">
<p>将它们放在一行上的小技巧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1 .. 6).pick.fmt(&#34;%d &#34;).print for ^10; say &#34;&#34;;
1 5 3 6 2 1 5 6 2 1

&gt; say join(&#34; &#34;, ( (1 .. 6).pick for ^10) );
5 4 3 6 4 4 4 5 6 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者我们可以使用列表重复运算符 <code>xx</code>(请参见第8.20节&#34;xx(列表重复运算符)&#34;):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1 .. 6).pick xx 10
(6 5 5 4 4 6 6 2 4 2)

&gt; say (1 .. 6).pick xx 10
(6 3 3 6 6 5 5 4 5 2)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_roll">8.23.3. roll</h4>
<div class="paragraph">
<p><code>roll</code> 旨在提醒你骰子的滚动。 它的行为与 <code>pick</code> 相同，只是它可以重复这些值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1..6).roll(3); # -&gt; (1 4 6)
&gt; (1..6).roll(3); # -&gt; (1 2 6)
&gt; (1..6).roll(3); # -&gt; (3 3 6)</code></pre>
</div>
</div>
<div class="paragraph">
<p>计数默认为1：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1..6).roll; # -&gt; 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果传递 <code>*</code> 作为计数，我们可以得到一个无限的惰性序列：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1..6).roll(*); # -&gt; (3 3 6 ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以在列表或类型对象的布尔值上使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (True, False).roll; # -&gt; True
&gt; Bool.roll;          # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们也可以作弊：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (True, True, False, False, False,).roll; # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 8.5</strong></p>
</div>
<div class="paragraph">
<p>生成一个随机的十个字符的字符串作为密码。 使用字母，数字和一些特殊字符（例如 «!» 和 «@»）。</p>
</div>
<div class="paragraph">
<p><strong>练习 8.6</strong></p>
</div>
<div class="paragraph">
<p>我们可以检查随机数生成器的质量，即分布是否均匀。</p>
</div>
<div class="paragraph">
<p>编写一个程序，在1..100范围内选择一百万个随机数，并打印一个频率表。</p>
</div>
<div class="paragraph">
<p>同时显示最小和最大计数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_srand">8.23.4. srand</h4>
<div class="paragraph">
<p>随机数并不是真正的随机数。 Raku 具有伪随机数序列，其随机性在于，编译器每次运行程序时都会通过调用 <code>srand</code> 在该序列中的不同位置启动。</p>
</div>
<div class="paragraph">
<p>我们可以自己调用 <code>srand</code> 来解决这个问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; srand(1234567890); say rand; say rand;
0.9168008342654074
0.297372052451493

&gt; srand(1234567890); say rand; say rand;
0.9168008342654074
0.297372052451493</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次重置，并且它从同一位置开始。</p>
</div>
<div class="paragraph">
<p>请注意，实际值可能会有所不同，具体取决于操作系统和编译器的版本，但是每次都会获得相同的序列。</p>
</div>
<div class="paragraph">
<p>用另一个整数值调用 <code>srand</code>，你将获得另一个序列。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; srand(112); (1 .. 6).pick.fmt(&#34;%d &#34;).print for ^10; say &#34;&#34;;
6 1 4 6 6 4 5 4 6 3

&gt; srand(112); (1 .. 6).pick.fmt(&#34;%d &#34;).print for ^10; say &#34;&#34;;
6 1 4 6 6 4 5 4 6 3</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>srand</code> 也影响 <code>pick</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; srand(1); (1..10).pick; # -&gt; 4
&gt; srand(1); (1..10).pick; # -&gt; 4
&gt; srand(1); (1..10).pick; # -&gt; 4</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_排列">8.24. 排列</h3>
<div class="paragraph">
<p>使用 <code>permutations</code> 来获取列表的所有可能排列：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &lt;a b c&gt;.permutations;
((a b c) (a c b) (b a c) (b c a) (c a b) (c b a))</code></pre>
</div>
</div>
<div class="paragraph">
<p>它关心位置，而不是实际值。 因此，重复值将导致排列重复：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; .say for &lt;a b b&gt;.permutations;
(a b b)
(a b b)
(b a b)
(b b a)
(b a b)
(b b a)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果用作带有数字值的函数，它将把该值视为一个范围。 例如 <code>permutations 3</code> 与 <code>permutations ^3</code> 相同（与 <code>permutations 0..2</code> 相同）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say permutations 3;
((0 1 2) (0 2 1) (1 0 2) (1 2 0) (2 0 1) (2 1 0))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 8.7</strong></p>
</div>
<div class="paragraph">
<p>编写一个程序，从 <code>permutations</code> 的输出中删除重复项。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &lt;a b b&gt;.permutations-without-duplicates; # Doesn&#39;t exist.
((a b b) (b a b) (b b a))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_组合">8.25. 组合</h3>
<div class="paragraph">
<p>使用 <code>combinations</code> 从列表中获取零和更多元素的所有可能组合：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &lt;a b c&gt;.combinations;
(() (a) (b) (c) (a b) (a c) (b c) (a b c))</code></pre>
</div>
</div>
<div class="paragraph">
<p>输入列表中的重复值是允许的，并且将导致结果重复：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &lt;a b b&gt;.combinations
(() (a) (b) (b) (a b) (a b) (b b) (a b b))</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是因为 <code>combinations</code> 使用的是位置，而不是实际值。</p>
</div>
<div class="paragraph">
<p>我们可以指定只需要给定数量的元素的组合：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &lt;a b c&gt;.combinations(1)
((a) (b) (c))</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以指定一个范围来选择长度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&lt;a b c&gt;.combinations(1..3)
((a) (b) (c) (a b) (a c) (b c) (a b c))</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为函数，我们将其数量作为参数。 例如。 3 将导致列表 <code>0..2</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; combinations 3
(() (0) (1) (2) (0 1) (0 2) (1 2) (0 1 2))</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以添加要选择的元素数量，作为值或范围：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; combinations 3,1;    # -&gt; ((0) (1) (2))
&gt; combinations 3,2;    # -&gt; ((0 1) (0 2) (1 2))
&gt; combinations 3,1..2; # -&gt; ((0) (1) (2) (0 1) (0 2) (1 2))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_but数组">8.26. but(数组)</h3>
<div class="paragraph">
<p>我们在第3.8节&#34;but(True 和 False, but …​)&#34;中引入了 <code>but</code> 运算符，并说明了它如何处理标量值。</p>
</div>
<div class="paragraph">
<p>它不适用于数组(<code>@</code>)：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @a = &lt;54 12&gt; but False; # -&gt; [54 12]
&gt; say @a.^name;              # -&gt; (Array)</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是（双关语意）如果我们将其分配给标量，它确实可以工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = &lt;54 12&gt; but False; # -&gt; (54 12)
&gt; say $a.^name;              # -&gt; (List+{&lt;anon|5&gt;})
&gt; say $a[0].^name;           # -&gt; (IntStr)
&gt; say $a[1].^name;           # -&gt; (IntStr)
&gt; say so $a;                 # -&gt; False

&gt; my $b = [54, 12] does False; # -&gt; [54 12]
&gt; say $a.^name;                # -&gt; (Array+{&lt;anon|4&gt;})</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_does数组">8.26.1. does(数组)</h4>
<div class="paragraph">
<p>这也适用于 <code>does</code> 运算符。</p>
</div>
<div class="paragraph">
<p>第3.8.1节&#34;does&#34;进行了介绍。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_合在一块儿">8.27. 合在一块儿</h3>
<div class="paragraph">
<p>假设你在手机（和 GPS）问世之前的某个时间遇到了一个废弃的火车站，并且非常需要知道该地点的名称。 问题在于电台名称以单独的字母显示，其中一些已经消失。</p>
</div>
<div class="paragraph">
<p>值得庆幸的是，他们躺在地上，一堆。 你将它们整理出来，但无法理解。</p>
</div>
<div class="paragraph">
<p>你碰巧是一名程序员，有一台笔记本电脑（在手机使用前的时间里…​），所以程序可以解决问题。</p>
</div>
<div class="paragraph">
<p>（或者你可以说这是一个地名测验。）</p>
</div>
<div class="paragraph">
<p>墙上的名字是 &#34;B??TO? ??N?R&#34;，缺少的字母是 AMNOOS。 打印所有可能的组合，阅读列表，看看是否有铃声响起。</p>
</div>
<div class="listingblock">
<div class="title">文件: name-quiz</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name    = &#34;B??TO? ??N?R&#34;;
   ##          012345678901
my $letters = &#34;AMNOOS&#34;;
my @name    = $name.comb;
my @letters = $letters.comb;
my @blanks  = (1,2,5,7,8,10);
for @letters.permutations.unique -&gt; @current {
    @name[@blanks] = @current;
    say @name.join;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序为你提供720条建议。 正确的是 &#34;BOSTON MANOR&#34;（如果可以找到的话）。</p>
</div>
<div class="paragraph">
<p>问号的硬编码索引不是最佳的。 在第10.9.1节&#34;单元过程&#34;中，我们将研究让程序为我们进行计算。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_对儿和散列">9. 对儿和散列</h2>
<div class="sectionbody">
<div class="paragraph">
<p>散列由成对儿的键和值组成。</p>
</div>
<div class="paragraph">
<p>在研究散列之前，我们先来看看 <code>Pair</code> 类型。</p>
</div>
<div class="sect2">
<h3 id="_pair">9.1. Pair</h3>
<div class="paragraph">
<p>哈希（以及我们将在 [高级 Raku] 课程中研究的一些其他类型）由一对键和值组成。<code>Pair</code> 是内置类型，它是单个键和值的组合。它们可以单独操作（单个 <code>Pair</code>），但通常更有用的数字较大。</p>
</div>
<div class="sect3">
<h4 id="_pair_构造器">9.1.1. ⇒ (Pair 构造器)</h4>
<div class="paragraph">
<p>我们可以使用 <code>Pair</code> 构造器 <code>⇒</code> 构造  <code>Pair</code>。我们可以使用 <code>Pair</code>, 但不是必须的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; Pair(1 =&gt; 2).WHAT
(Pair)

&gt; (1 =&gt; 2).WHAT # The same, but shorter
(Pair)

&gt; Pair.new(1, 2).WHAT # Without the &#34;fat arrow&#34;
(Pair)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
请注意，只要未引用的文本不包含空格，就允许它作为键：
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = (pi =&gt; pi);
pi =&gt; 3.141592653589793</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个 «pi» 被视为文本文本，第二个 «pi» 被视为内置 <code>pi</code> 常量。</p>
</div>
<div class="paragraph">
<p>我们可以以几种方式构造 <code>Pair</code>:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pair(&#39;key&#39; ⇒ &#39;value&#39;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如上所述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">(&#39;key&#39; ⇒ &#39;value&#39;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">同上</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pair.new(&#39;key&#39; ⇒ &#39;value&#39;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">同上。这是标准方式</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#39;key&#39; ⇒ &#39;value&#39;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不需要圆括号</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:key&lt;value&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">同样</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:foo(127)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">foo ⇒ 127 的简写</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:127foo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与 foo ⇒ 127 相同。当值是数字的时候才有效。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果该值是布尔值，我们可以缩短表达式：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:key</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">和 key ⇒ True 相同</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:!key</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">和 key ⇒ False 相同</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>我们可以将任何变量转换为 <code>Pair</code>，变量名称为键：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $age = 14;
&gt; my $p = :$age;
&gt; say $p; # -&gt; age =&gt; 10</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_key">9.1.2. key</h4>
<div class="paragraph">
<p>使用 <code>key</code> 获取 <code>Pair</code> 的键值(胖箭头的左侧):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = (1 =&gt; 2); # -&gt; 1 =&gt; 2
&gt; $a.key;           # -&gt; 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_value">9.1.3. value</h4>
<div class="paragraph">
<p>使用 <code>value</code> 获取 <code>Pair</code> 的值(胖箭头的右侧):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; $a.value; # -&gt; 2</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_antipair">9.1.4. antipair</h4>
<div class="paragraph">
<p>使用 <code>antipair</code> 交换 <code>Pair</code> 的键和值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (&#34;a&#34; =&gt; &#34;r&#34;).antipair; # -&gt; r =&gt; a</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hash">9.2. Hash</h3>
<div class="paragraph">
<p>如果 <code>Pair</code> 对象（零个，一个或多个），则哈希是一个集合，其中我们将键用作索引（查找）。我们可以给出一个哈希值，当我们像这样声明它时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my %trans = (&#34;a&#34; =&gt; &#34;1&#34;, &#34;b&#34; =&gt; &#34;9&#34;);

&gt; my %population = (Oslo           =&gt; 500_000,
                    Paris          =&gt; &#34;unknown&#34;,
                    &#34;Buenos Aires&#34; =&gt; &#34;too many&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>键（<code>⇒</code> 的左侧）可以不带引号指定 - 如果它们不包含空格的话。</p>
</div>
<div class="paragraph">
<p>我们可以跳过这个圆括号。</p>
</div>
<div class="paragraph">
<p>我们可以用列表填充哈希。它将第一个值作为键，第二个值作为值，等等：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my %a = (11 .. 20)
{11 =&gt; 12, 13 =&gt; 14, 15 =&gt; 16, 17 =&gt; 18, 19 =&gt; 20}</code></pre>
</div>
</div>
<div class="paragraph">
<p>列表中的项数必须是偶数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">{11 =&gt; 12, 13 =&gt; 14, 15 =&gt; 16, 17 =&gt; 18, 19 =&gt; 20}
&gt; my %a = (11 .. 21)
Odd number of elements found where hash initializer expected: Found 11 (implicit) elements: ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以从两个单独的列表创建哈希，一个用于键，另一个用于值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @keys = 1..10; &gt; my @vals = 91..100;
&gt; my %hash; %hash{@keys} = @vals;

&gt; say %hash;
{1 =&gt; 91, 10 =&gt; 100, 2 =&gt; 92, 3 =&gt; 93, 4 =&gt; 94, 5 =&gt; 95, 6 =&gt; 96, 7 =&gt; 97, 8 =&gt; 98, 9 =&gt; 99}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hash_构造器">9.3. Hash 构造器 {}</h3>
<div class="paragraph">
<p>仅当将哈希分配给标量时，才需要哈希构造函器 <code>{ …​ }</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $trans = {&#34;a&#34; =&gt; &#34;1&#34;, &#34;b&#34; =&gt; &#34;9&#34;};
{a =&gt; 1, b =&gt; 9}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，如果我们忘记了花括号，我们会得到一个 <code>Pair</code> 的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $trans = (&#34;a&#34; =&gt; &#34;1&#34;, &#34;b&#34; =&gt; &#34;9&#34;);
(a =&gt; 1, b =&gt; 9)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们将某些内容分配给哈希，则会强制将其强制为 <code>Pair</code> 对象，然后插入到哈希中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my %hash = 1..10; # -&gt; {1 =&gt; 2, 3 =&gt; 4, 5 =&gt; 6, 7 =&gt; 8, 9 =&gt; 10}</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要参数数是偶数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my %hash = 1..11;
Odd number of elements found where hash initializer expected: Found 11 (implicit) elements:
Last element seen: 11
    in block &lt;unit&gt; at &lt;unknown file&gt; line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用其它方式生成 <code>Pair</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %months = :jan(&#39;January&#39;), :feb(&#39;February&#39;), ...;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_哈希赋值和值">9.4. 哈希赋值和值</h3>
<div class="paragraph">
<p>如果我们赋值给哈希变量，则任何现有值都将丢失。我们可以添加新值，或更改现有值的值，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; %population{&#34;Buenos Aires&#34;} = &#34;too many&#34;;
&gt; %population&lt;Oslo&gt; = 500_000;
&gt; %population{&#34;Oslo&#34;}
  500000
&gt; %population&lt;Oslo&gt; # The same
  500000
&gt; say %population&lt;Buenos Aires&gt; # An error
  ((Any) (Any))</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一个等价于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say ( %population{&#34;Buenos&#34;}, %population{&#34;Aires&#34;} );
  ((Any) (Any))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_keys">9.5. keys</h3>
<div class="paragraph">
<p><code>keys</code> 方法给出(一组)所有键:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for %population.keys -&gt; $city {
    say &#34;City $city has %population{$_} people&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们也可以在列表上使用 <code>keys</code>，它将返回索引：</p>
</div>
<div class="paragraph">
<p>即使我们用 <code>Pair</code> 对象填充了列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">(1 =&gt; 2, 2 =&gt; 3, 4 =&gt; 5).keys
(0 1 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>keys</code> 按随机顺序提供键。如果需要顺序，则排序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; for %population.keys.sort -&gt; $city { ... }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
键返回的顺序是半随机的。只要哈希未更改，此顺序就保持不变（这意味着调用 <code>keys</code> 和 <code>values</code> 以相同的顺序提供值）。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_values">9.6. values</h3>
<div class="paragraph">
<p><code>values</code> 给出所有值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for %population.values -&gt; $population {
    say &#34;Unknown City with %population{$_} people&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，Pair 对象列表上的 <code>values</code> 返回所有内容，因为它使用索引作为键：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1 =&gt; 2, 2 =&gt; 3, 4 =&gt; 5).values
(1 =&gt; 2 2 =&gt; 3 4 =&gt; 5)</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了执行手动搜索之外，无法从哈希值开始并返回键。这是典型的&#34;大海捞针问题&#34;。我们将在第 10.13.4.2 节&#34;干草堆问题的针&#34;中了解程序时对此进行了解。</p>
</div>
</div>
<div class="sect2">
<h3 id="_kv_keys_values">9.7. kv (keys + values)</h3>
<div class="paragraph">
<p>我们可以使用 <code>kv</code> 方法（对于键值）同时获取键和值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for %population.kv -&gt; $city, $population {
    say &#34;City $city has $population people&#34;;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_带类型的_hash">9.8. 带类型的 Hash</h3>
<div class="paragraph">
<p>我们可以在哈希值上添加类型约束，如第 3.1 节&#34;强类型&#34;中所述：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my Int %h;
&gt; say %h.WHAT; # -&gt; (Hash[Int])
&gt; %h&lt;a&gt; = 12.1;
Type check failed in assignment to %h; expected Int but got Rat (12.1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以像这样指定约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my %h of Int;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以在哈希的键上添加类型约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my %h{Str};
&gt; say %h.WHAT; # -&gt; (Hash[Any,Str])</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以两个都用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my Int %h{Str};
&gt; say %h.WHAT; # -&gt; (Hash[Int,Str]) # The first is the keys, the second is the values</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们要求键是字符串，并且值是整数。</p>
</div>
<div class="sect3">
<h4 id="_keyof">9.8.1. keyof</h4>
<div class="paragraph">
<p><code>keyof</code> 将返回的键的类型约束。</p>
</div>
<div class="paragraph">
<p>没有键约束的哈希：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my %h; say %h.keyof; # -&gt; (Str(Any))</code></pre>
</div>
</div>
<div class="paragraph">
<p>带键约束的哈希:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my %h{Int}; say %h.keyof; # -&gt; (Int)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_of">9.8.2. of</h4>
<div class="paragraph">
<p><code>of</code> 返回的表示值的类型约束。</p>
</div>
<div class="paragraph">
<p>不限制值的哈希：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my %h; say %h.of; # -&gt; (Mu)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_shaped_hash">9.9. Shaped Hash</h3>
<div class="paragraph">
<p>定型哈希不像定型数组那样有意义（如第 8.17 节&#34;定型数组&#34;中所述）。</p>
</div>
<div class="paragraph">
<p>我们可以指定这样的形状：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my %hash{10;10;10};</code></pre>
</div>
</div>
<div class="paragraph">
<p>数字将被忽略，但我们不能使用比指定更多的索引（本例中为三个）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; %hash{&#34;A&#34;;&#34;E&#34;;&#34;C&#34;}
&gt; %hash{&#34;A&#34;;&#34;E&#34;;&#34;C&#34;}
&gt; %hash{&#34;A&#34;;&#34;E&#34;}
&gt; %hash{&#34;A&#34;;&#34;E&#34;;&#34;J&#34;;&#34;O&#34;} = &#34;A&#34;
Type Str does not support associative indexing.</code></pre>
</div>
</div>
<div class="paragraph">
<p>不过，错误消息有点令人困惑。</p>
</div>
<div class="paragraph">
<p>另请注意，我们可以为哈希分配任何值，而不仅仅是整数（就好像我们只有指定一个整数;例如，<code>my %hash{10};</code> - 和是指定整数被视为与 Int 相同）。</p>
</div>
<div class="paragraph">
<p>大小声明是非常无用的（除了上限），可以删除：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my %hash;
&gt; %hash{&#34;A&#34;; &#34;B&#34;; &#34;C&#34;} = 12;
&gt; %hash{&#34;A&#34;; &#34;B&#34;; &#34;D&#34;} = 13;</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么，什么是定型的哈希？让我们来看看：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say %hash; # -&gt; {A =&gt; {B =&gt; {C =&gt; 12, D =&gt; 13}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它是一种树状结构，哈希哈希的哈希。（我故意保持简单。)</p>
</div>
<div class="paragraph">
<p>![img]()</p>
</div>
<div class="paragraph">
<p>我们还可以像这样来指定它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my %hash;
&gt; %hash{&#34;A&#34;}{&#34;B&#34;}{&#34;C&#34;} = 12;
&gt; %hash{&#34;A&#34;}{&#34;B&#34;}{&#34;D&#34;} = 13;
&gt; say %hash; # -&gt; {A =&gt; {B =&gt; {C =&gt; 12, D =&gt; 13}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，当我们处理子树时，细微的差别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; %hash{&#34;A&#34;; &#34;B&#34;}; # -&gt; ({C =&gt; 12, D =&gt; 13}) # A list
&gt; %hash{&#34;A&#34;}{&#34;B&#34;}; # -&gt; {C =&gt; 12, D =&gt; 13}   # A hash</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_invert">9.10. invert</h3>
<div class="paragraph">
<p>我们可以使用 <code>invert</code> 来交换哈希的键和值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my %a = (1 =&gt; 2, 3 =&gt; 4); # -&gt; {1 =&gt; 2, 3 =&gt; 4}
&gt; my %b = %a.invert;        # -&gt; {2 =&gt; 1, 4 =&gt; 3}</code></pre>
</div>
</div>
<div class="paragraph">
<p>重复值将变为相同的键，但可以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my %a = (1 =&gt; 2, 3 =&gt; 4, 5 =&gt; 2); # -&gt; {1 =&gt; 2, 3 =&gt; 4, 5 =&gt; 2}
&gt; say %a.invert;                    # -&gt; (2 =&gt; 1 2 =&gt; 5 4 =&gt; 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们得到了 Pair 对象的列表，并且该列表不关心重复项。当我们将其分配给哈希时，重复的键将被压掉，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my %b = %a.invert; # -&gt; {2 =&gt; 5, 4 =&gt; 3}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们将 Pair 对象列表分配给哈希时，当我们有重复的键时，最后一个对象获胜。这是最后一个是任何人的猜测，因为哈希是无序的。（这意味着每次运行程序时，你都会得到不同的结果，从而得到细微的错误。</p>
</div>
</div>
<div class="sect2">
<h3 id="_antipairs">9.11. antipairs</h3>
<div class="paragraph">
<p>与在哈希上调用 <code>invert</code> 具有相同的效果。</p>
</div>
<div class="paragraph">
<p>但是在 <code>Pair</code> 对象列表中，它们有所不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1 =&gt; 2, 2 =&gt; 3, 4 =&gt; 5).antipairs # ((1 =&gt; 2) =&gt; 0 (2 =&gt; 3) =&gt; 1 (4 =&gt; 5) =&gt; 2)
(1 =&gt; 2, 2 =&gt; 3, 4 =&gt; 5).invert    # (2 =&gt; 1 3 =&gt; 2 5 =&gt; 4)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>antipairs</code> 使用列表索引作为键，使用 <code>Pair</code> 作为值，并交换它们。</p>
</div>
<div class="sect3">
<h4 id="_pairs">9.11.1. pairs</h4>
<div class="paragraph">
<p>使用 <code>pairs</code> 将散列转换为 <code>Pair</code> 对象列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %a = (1=&gt;2, 2=&gt;3); # -&gt; {1 =&gt; 2, 2 =&gt; 3}
%a.pairs;             # -&gt; (1 =&gt; 2 2 =&gt; 3)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_散列切片">9.12. 散列切片</h3>
<div class="paragraph">
<p>就像我们有数组切片一样(请参见第 8.11 节&#34;数组切片&#34;), 我们还有哈希切片:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %translate = ( one =&gt; &#34;ein&#34;, two =&gt; &#34;zwei&#34;, three =&gt; &#34;drei&#34; );
#  {one =&gt; ein, three =&gt; drei, two =&gt; zwei}

say %translate{&#34;two&#34;, &#34;one&#34;}
#  (zwei ein)

say %translate&lt;two one&gt; # This does not work on arrays.
#  (zwei ein)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果选择条件更复杂，请使用 <code>grep</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">%translate{%translate.keys.grep(*.chars == 3)}
#  (zwei ein)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_散列查询">9.13. 散列查询</h3>
<div class="paragraph">
<p>我们如何检查哈希中是否存在值？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h;
%h&lt;a&gt; = 0;     # =&gt; 0
%h&lt;b&gt; = False; # =&gt; False
%h&lt;c&gt; = Nil;   # =&gt; (Any)</code></pre>
</div>
</div>
<div class="paragraph">
<p>它们都在布尔上下文中计算为 <code>False</code>。</p>
</div>
<div class="paragraph">
<p>使用 <code>:exists</code> 副词:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">%h&lt;a&gt;:exists # =&gt; True
%h&lt;b&gt;:exists # =&gt; True
%h&lt;c&gt;:exists # =&gt; True
%h&lt;d&gt;:exists # =&gt; False</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_散列删除">9.14. 散列删除</h3>
<div class="paragraph">
<p>使用 <code>:delete</code> 副词从哈希表中删除条目:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h = a =&gt; 1, b =&gt; 2, c =&gt; 3
#  {a =&gt; 1, b =&gt; 2, c =&gt; 3}

%h&lt;b c&gt;:delete
#  (2 3)

%h&lt;a&gt;:delete
#  1</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回一个或多个已删除的值。</p>
</div>
</div>
<div class="sect2">
<h3 id="_散列重复值">9.15. 散列重复值</h3>
<div class="paragraph">
<p>哈希（显然）不允许使用相同的键重复值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %hash;
%hash&lt;M&gt; = 12;
%hash&lt;M&gt; = &#34;nobody&#34;;
say %hash&lt;M&gt;
# nobody</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是我们可以通过使用列表作为值来解决这个问题，并为其添加新的值。 我们可以通过 <code>push</code> 自动执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %hash;
%hash&lt;M&gt;.push(12);
say %hash&lt;M&gt;
#  [12]

%hash&lt;M&gt;.push(&#34;nobody&#34;);
say %hash&lt;M&gt;
#  [12 nobody]

say %hash&lt;M&gt;[1];
#  nobody</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是我们必须从一开始就这样做，因为第一次推送将删除已经存在的所有标量值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %hash;
%hash&lt;M&gt; = 12;
%hash&lt;M&gt;.push(&#34;nobody&#34;);
say %hash&lt;M&gt;
#  [nobody]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_散列用法">9.16. 散列用法</h3>
<div class="paragraph">
<p>我们在本章中显示的第一个代码段是一个哈希，其中我们在城市及其人口规模之间进行了映射。</p>
</div>
<div class="paragraph">
<p>我们可以尝试添加这些值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $total = 0;
for %population.values -&gt; $population {
    $total += $population;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于字符串值（“未知”和“太多”），这会导致运行时错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Cannot convert string to number: base-10 number must begin with valid digits or &#39;.&#39; in &#39;⏏too many&#39; (indicated by ⏏)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_sum_方法">9.16.1. «sum» 方法</h4>
<div class="paragraph">
<p>我们可以使用 <code>sum</code> 方法而不是遍历值：</p>
</div>
<div class="listingblock">
<div class="title">文件: population-sum (partial)</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $total = %population.values.sum;</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，由于非数字值，此操作失败。</p>
</div>
</div>
<div class="sect3">
<h4 id="_智能匹配">9.16.2. 智能匹配</h4>
<div class="paragraph">
<p>在添加值之前，我们可以使用智能匹配运算符 <code>~~</code>(在第 11.3 节&#34; ~~(智能匹配运算符)&#34;中介绍)来检查该值是否为 <code>Int</code>：</p>
</div>
<div class="listingblock">
<div class="title">文件: population-smartmatch (partial)</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for %population.values -&gt; $population {
    $total += $population if $population ~~ Int;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 <code>$population.isa(INT)</code>（请参见第3.7.8节&#34;isa&#34;），结果相同。</p>
</div>
<div class="paragraph">
<p>只要类型是 <code>Int</code>，它们都可以工作。 如果是例如 <code>Rat</code>，比较将失败-即使值本身是整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 5.0 ~~ Int; # -&gt; False</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_grep_和智能匹配">9.17. grep 和智能匹配</h3>
<div class="paragraph">
<p>在应用 <code>sum</code> 之前，我们可以使用 <code>grep</code> 摆脱非法值（和循环）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $total = %population.values.grep(* ~~ Int).sum;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将在&#34;高级 Raku&#34;课程中回到该示例。</p>
</div>
</div>
<div class="sect2">
<h3 id="_哈希方法">9.18. 哈希(方法)</h3>
<div class="paragraph">
<p>只要元素数量为偶数，我们就可以使用 <code>Hash</code> 方法将列表转换为哈希：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %hash = (1..10).Hash;
#  {1 =&gt; 2, 3 =&gt; 4, 5 =&gt; 6, 7 =&gt; 8, 9 =&gt; 10}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 9.1</strong>
如果我们删除 <code>.Hash</code> 部分会发生什么?</p>
</div>
<div class="paragraph">
<p>例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %hash = (1..10);</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 9.2</strong></p>
</div>
<div class="paragraph">
<p>如果有重复值会发生什么？</p>
</div>
<div class="paragraph">
<p>例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;1 2 1 3 1 4 1 5&gt;.Hash;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_but散列">9.19. but(散列)</h3>
<div class="paragraph">
<p>在第 8.26 节 &#34;but(Array)&#34;中，我们显示了 <code>but</code> 运算符不适用于数组(<code>@</code>)，但不适用于标量列表/数组(<code>$</code>)。</p>
</div>
<div class="paragraph">
<p>同样适用于哈希，但无效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %a = (54 =&gt; 12) does False; # -&gt; {54 =&gt; 12}
say %a.^name;                  # -&gt; Hash
say so %a:                     # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>这有效，但仅适用于整个数据结构（这是 <code>Pair</code> 对象的集合）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = (54 =&gt; 12) does False; # -&gt; 54 =&gt; 12
say $a.^name;                  # -&gt; Pair+{&lt;anon|5&gt;}
say so $a;                     # -&gt; False
say $a&lt;54&gt;;                    # -&gt; 12
say so $a&lt;54&gt;;                 # -&gt; True</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_does散列">9.19.1. does(散列)</h4>
<div class="paragraph">
<p>行为与 <code>but</code> 相同。 有关详细信息，请参见第 8.26 节&#34;but(Array)&#34;。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_过程">10. 过程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>过程是编写可维护代码的传统基本构建块，可将大型程序分解为较小的单元。 （对象定向是另一种方法，我们将在第17章，类中重新讨论。）</p>
</div>
<div class="sect2">
<h3 id="_不带参数的过程">10.1. 不带参数的过程</h3>
<div class="paragraph">
<p>定义这样的无参数过程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub hello {
    say &#34;Hello&#34;;
}

hello;   # Call it like this,
hello(); # or this.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_带参数的过程">10.2. 带参数的过程</h3>
<div class="paragraph">
<p>具有明确的参数列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add ($first-value, $second-value) {
    return $first-value + $second-value;
}

say add(1, 2); # Call it like this,
say add 1, 2;  # or this.</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意优先级，并使用圆括号避免混淆：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">say add(1, 2), 3; # -&gt; 33
say add 1, 2, 3;
===SORRY!=== Error while compiling:
Calling add(Int, Int, Int) will never work with declared signature ($first-value, $second-value)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们尝试使用文本字符串怎么办？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result = add &#34;10&#34;, 2; # -&gt; 12</code></pre>
</div>
</div>
<div class="paragraph">
<p>字符串&#34;10&#34;被强制为数字(10)，并且可以使用。</p>
</div>
<div class="paragraph">
<p>之所以有效，是因为&#34;10&#34;可以转换为数字。</p>
</div>
<div class="paragraph">
<p>但是，如果尝试某些无法转换的操作，则会出现运行时错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; my $result = add &#34;ten&#34;, 2;
Cannot convert string to number: base-10 number must begin with valid digits or &#39;.&#39; in &#39;⏏ten&#39; (indicated by ⏏)
    in sub add at &lt;unknown file&gt; line 1</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_10">10.3. @_</h3>
<div class="paragraph">
<p>我们可以使用没有签名的程序。 传递的所有参数都可以在 <code>@_</code> 变量中找到：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub test { .say for @_; }
test; # Nil
test 1, 2, 3;

# 1
# 2
# 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们具有过程签名，则 <code>@_</code> 不可用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; sub test ($arg) { .say for @_; }
Placeholder variable &#39;@_&#39; cannot override existing signature ------&gt; sub⏏ test ($al) { .say for @_; }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@_</code> 将列表弄平，但不会散列。 小心甚至更好：请勿使用。</p>
</div>
<div class="sect3">
<h4 id="_11">10.3.1. $_</h4>
<div class="paragraph">
<p>我们可以使用 <code>$_</code> 作为过程变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub x ($_) { .say; .say; } # 12
x(12)                      # 12</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_占位符变量_2">10.4. 占位符变量</h3>
<div class="paragraph">
<p>我们在第 8.13.1 节&#34;占位符变量&#34;中介绍了占位符变量。 它们可以与任何过程一起使用：</p>
</div>
<div class="listingblock">
<div class="title">文件: placeholder</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub test {
    say &#34;Argument 1: $^a&#34;; # -&gt; Argument 1: A
    say &#34;Argument 2: $^b&#34;; # -&gt; Argument 2: B
}

test(&#34;A&#34;, &#34;B&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们使用占位符变量时，它们就会存在。 它们是按字母顺序而不是第一次使用的顺序分配给值的。</p>
</div>
<div class="listingblock">
<div class="title">文件: placeholder2</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub test {
    say &#34;Argument 2: $^b&#34;; # -&gt; Argument 2: B
    say &#34;Argument 1: $^a&#34;; # -&gt; Argument 1: A
}

test(&#34;A&#34;, &#34;B&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1 .. 10).map({ $^a - $^b }); # -&gt; (-1 -1 -1 -1 -1)
(1 .. 10).map({ $^b - $^a }); # -&gt; (1 1 1 1 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这两行都包含两个和元素。 第一行采用第一个元素，然后减去第二个元素，得出 1-2、3-4、5-6、7-8 和 9-10。 第二行将顺序更改为 2-1、4-3、6-5、8-7 和 10-9。</p>
</div>
<div class="paragraph">
<p>请注意，在将占位符变量存在后，可以将它们称为普通变量（不带 <code>^</code>）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{ say $^a ~ $^b; say $b ~ $a; }(&#34;P&#34;,&#34;6&#34;)
# P6
# 6P</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">文件: placeholder3</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub test {
  say &#34;Argument 1: $^a&#34;;
  say &#34;Argument 2: $^b&#34;;

  say &#34;Normal variables: $a $b&#34;;
}

test(&#34;A&#34;, &#34;B&#34;);</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_命名占位符变量">10.4.1. 命名占位符变量</h4>
<div class="paragraph">
<p>我们可以使用命名占位符变量。 在符号和名称之间指定一个冒号：</p>
</div>
<div class="listingblock">
<div class="title">文件: placeholder-named</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub test {
    say &#34;Argument 1: $:first&#34;;  # -&gt; Argument 1: 12
    say &#34;Argument 2: $:second&#34;; # -&gt; Argument 2: 23
}

test(first =&gt; 12, second =&gt; 23);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_过程作为变量">10.5. 过程作为变量</h3>
<div class="paragraph">
<p>我们可以将对过程的引用存储在变量中，然后在以后执行它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;code = sub { say &#34;12345&#34;; }; #  sub { }
&amp;code();                         # 12345</code></pre>
</div>
</div>
<div class="paragraph">
<p>或在标量中（但不是）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $code = sub { say &#34;12345&#34;; } #  sub { }
$code()                         #  12345</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_anon">10.5.1. anon</h4>
<div class="paragraph">
<p>上面的匿名过程没有任何参数，可以很好地工作。 如果要引入参数，则必须将其命名为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;code = sub something($arg) { say $arg ~ &#34;123&#34;; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这给我们起了个名字，我们可以用它来调用过程（以正常方式）。 我们可以通过使用 <code>anon sub</code> 来防止这种情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">&gt; my &amp;code = anon sub something($arg) { say $arg ~ &#34;123&#34;; }
&gt; something;
===SORRY!=== Error while compiling:
Undeclared routine: something used at line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，如果你删除赋值，你将获得不可调用的匿名函数。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类型约束">10.6. 类型约束</h3>
<div class="paragraph">
<p>我们可以使用类型约束来防止将字符串自动转换为数字（并获得编译时错误）：</p>
</div>
<div class="listingblock">
<div class="title">文件: num-add-err</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add (Numeric $first-value, Numeric $second-value) {
    return $first-value + $second-value;
}

say add &#34;10&#34;, 2;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku num-add-err
===SORRY!=== Error while compiling ./num-add-err
Calling add(Str, Int) will never work with declared signature (Numeric $first-value,
Numeric $second-value) at ./num-add-err:7 ------&gt; say ⏏add &#34;10&#34;, 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>Numeric</code> 还允许使用未定义的值：</p>
</div>
<div class="listingblock">
<div class="title">文件: num-add-err2</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add (Numeric $first-value, Numeric $second-value) {
    return $first-value + $second-value;
}

my Numeric $a; my Numeric $b;

say add $a, $b;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku num-add-err2
Use of uninitialized value of type Numeric in numeric context
in sub add at ./num-add-err2 line 3
Use of uninitialized value of type Numeric in numeric context
in sub add at ./num-add-err2 line 3 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>解决方案是添加 <code>:D</code> 副词（请参见第3.5节&#34;:D(定义副词)&#34;):</p>
</div>
<div class="listingblock">
<div class="title">文件: num-add-err3</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add (Numeric:D $first-value, Numeric:D $second-value) {
    return $first-value + $second-value;
}

my Numeric $a; my Numeric $b;

say add $a, $b;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku num-add-err3
Parameter &#39;$first-value&#39; of routine &#39;add&#39; must be an object instance of type &#39;Numeric&#39;, not a type object of type &#39;Numeric&#39;. Did you forget a &#39;.new&#39;?
in sub add at ./num-add3 line 3
in block &lt;unit&gt; at ./num-add3 line 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>类型约束提供了更好的错误消息，并且在我们运行任何代码之前在编译时完成了检查（因此我们可以避免在可能导致文件系统或数据库混乱的中间程序崩溃）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_return">10.7. return</h3>
<div class="paragraph">
<p>使用 <code>return</code> 停止执行当前过程或方法，并将指定的值（如果有，否则为 <code>Nil</code>）提供给调用方（作为返回值）。</p>
</div>
<div class="paragraph">
<p>请注意，如果我们已经设置了相关的 Phasers（请参阅《高级Raku》课程），它们将在控制权返回给调用者之前运行。</p>
</div>
<div class="paragraph">
<p>如果我们指定了返回值约束(请参见第 10.7.2 节&#34;返回值约束&#34;)，将对照该值进行检查。 如果检查失败，则会引发异常。</p>
</div>
<div class="paragraph">
<p>请注意，<code>return</code> 是作为过程而不是关键字实现的，因此过程优先级规则适用。</p>
</div>
<div class="sect3">
<h4 id="_return_rw">10.7.1. return-rw</h4>
<div class="paragraph">
<p><code>return</code> 会返回一个值，而不是一个容器，并且你不能更改该值。</p>
</div>
<div class="paragraph">
<p>这将失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub abc { return 123; }
say ++abc();</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是我们可以使用 <code>return-rw</code>(如《返回读写》中所述)来获取可以更改的容器。</p>
</div>
<div class="paragraph">
<p>这也会失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub abc { return-rw 123; }
say ++abc(); # -&gt; 124</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <code>return-rw</code> 尝试返回容器，因此失败，并且由于没有容器，它返回值 <code>123</code>。 这是完全合法的，但是前缀 <code>++</code> 将失败。</p>
</div>
<div class="listingblock">
<div class="title">文件:  return-rw</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub abc {
    my $a = 123;
    return-rw $a;
}

say ++abc(); # -&gt; 124</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku return-rw
124</code></pre>
</div>
</div>
<div class="paragraph">
<p>这允许将过程调用用作匿名变量。 在实践中它可能不是很有用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_返回值约束">10.7.2. 返回值约束</h4>
<div class="paragraph">
<p>如第 10.6 节&#34;类型约束&#34;所示，我们可以对返回值以及输入值进行类型约束。</p>
</div>
<div class="paragraph">
<p>我们可以通过几种方式指定返回类型约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub X ($a, $b --&gt; Int)      { $a + $b }
sub X ($a, $b ) returns Int { $a + $b }
sub X ($a, $b ) of Int      { $a + $b }
my Int sub X ($a, $b)       { $a + $b }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果尝试返回不符合限制的值，则会得到异常。</p>
</div>
<div class="paragraph">
<p>可以返回一个明确的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub random( --&gt; 12 ) { rand }
say random; # -&gt; 12</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使存在返回类型约束，我们也可以将 <code>Nil</code> 作为错误值（或“我放弃”）返回：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub abc ( --&gt; Int) { Nil; }
abc; # -&gt; Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使我们坚持定义的返回值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub abc ( --&gt; Int:D) { Nil; }
abc; # -&gt; Nil</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_args">10.8. <code>@*ARGS</code></h3>
<div class="paragraph">
<p>我们可以使用动态变量 <code>@*ARGS</code> 从命令行获取输入：</p>
</div>
<div class="listingblock">
<div class="title">文件: hello-args</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;Hello, @*ARGS[0]!&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@*ARGS</code> 是带有参数的列表，其中 <code>@*ARGS[0]</code> 是第一个参数，依此类推。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; raku hello-args NPW
Hello, NPW</code></pre>
</div>
</div>
<div class="paragraph">
<p>占位符变量在这里会很好，但是由于我们没有过程，因此无法使用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_main">10.9. MAIN</h3>
<div class="paragraph">
<p>我们可以使用特殊的 <code>MAIN</code> 过程并声明过程参数，而不是访问 <code>@*ARGS</code>：</p>
</div>
<div class="listingblock">
<div class="title">文件: hello</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ($name) {
    say &#34;Hello, $name!&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>编译器将首先执行程序中的任何代码，然后再调用 <code>MAIN</code> 例程。 在 <code>MAIN</code> 之外具有任何代码通常不是一个好主意。</p>
</div>
<div class="paragraph">
<p>使用所需的名称和所需的名称声明 <code>MAIN</code>。 如果你给程序提供错误数量（或类型）的参数，程序将失败并显示用法消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku hello
  Usage:
hello &lt;name&gt;

$ raku hello all!
hello, all!

$ raku hello all you
Usage:
  hello &lt;name&gt;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_unit_过程">10.9.1. unit 过程</h4>
<div class="paragraph">
<p>我们可以改用 <code>unit procedure</code>，为我们节省一个块级：</p>
</div>
<div class="listingblock">
<div class="title">文件: hello-unit</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit sub MAIN ($name);

say &#34;Hello, $name!&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们只有一个过程时，这很有用，因为我们通常使用 <code>MAIN</code> 写简短程序。</p>
</div>
<div class="paragraph">
<p>另一方面，我们获得的是块级数量的减少，这在短程序中通常不是问题。</p>
</div>
<div class="paragraph">
<p><strong>练习 10.1</strong>
重写第 8.27 节&#34;将所有内容组合在一起&#34;中的名称测验程序，以便你可以指定任意名称和缺少的字母，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ name-quiz2 &#34;B??TO? ??N?R&#34; AMNOOS
$ name-quiz2 L??DON NO</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于名称中包含空格字符，因此第一行中名称的引号是必需的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_更好的用法信息">10.9.2. 更好的用法信息</h4>
<div class="paragraph">
<p>程序名称和变量名称可能无法全部说明。 在 <code>MAIN</code> 过程上方添加一个特殊的注释行：</p>
</div>
<div class="listingblock">
<div class="title">文件: hello-usage</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| Person to greet
sub MAIN ($name) {
    say &#34;Hello, $name!&#34;;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku hello-usage all you
Usage:
 hello-usage &lt;name&gt; -- Person to greet</code></pre>
</div>
</div>
<div class="paragraph">
<p>特殊注释也可以在 <code>MAIN</code> 过程之后指定：</p>
</div>
<div class="listingblock">
<div class="title">文件: hello-usage2</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ($name) {
    say &#34;Hello, $name!&#34;;
}
#= Person to greet</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>--doc</strong></p>
</div>
<div class="paragraph">
<p>如果使用 <code>#|</code> 表格，当我们要求编译器提供文档时，注释将显示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku --doc hello-usage
sub MAIN(
    $name,
)
Person to greet</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第二种形式上执行此操作（过程后为 <code>#=</code>）不起作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku --doc hello-usage2</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_why">10.10. WHY</h3>
<div class="paragraph">
<p>我们也可以为普通过程添加这样的注释，并使用 <code>WHY</code> 来获取它们：</p>
</div>
<div class="listingblock">
<div class="title">文件: usage</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| This is one
sub a1 { ; }

#| This is two
sub a2 { ; }
#= Still two

sub a3 { ; }

say &amp;a1.WHY;
say &amp;a2.WHY;
say &amp;a3.WHY;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku usage
This is one
This is two
Still two
No documentation available for type &#39;Sub&#39;.
Perhaps it can be found at https://docs.raku.org/type/Sub</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，我们必须在过程名称前加上 <code>&amp;</code> 前缀，以免执行过程，并对返回值应用 <code>WHY</code>。</p>
</div>
<div class="paragraph">
<p>实际上，我们可以对任何块执行此操作，只要它具有名称或指向它的指针即可。</p>
</div>
<div class="paragraph">
<p>块注释是内联文档子语言 <code>pod</code> 的一部分。 我们会回到&#34;高级 Raku&#34;课程。</p>
</div>
<div class="paragraph">
<p><code>WHY</code> 是从一个世界到另一个世界的桥梁…​</p>
</div>
<div class="sect3">
<h4 id="_带类型的_main">10.10.1. 带类型的 MAIN</h4>
<div class="paragraph">
<p>我们可以在传递给 <code>MAIN</code> 的参数中添加强类型，但是存在与第 6.6.1 节&#34;prompt&#34;中描述的相同问题，即字符串不带引号，因此编译器假定它们是字符串。 不带引号的数字可以是数字-或不带引号的字符串。</p>
</div>
<div class="paragraph">
<p>有了 <code>prompt</code>，我们可以通过用引号指定数字来强制编译器将其视为字符串来避免这种情况，但这在 shell 中不起作用，因为 shell 使用引号对文本进行分组并在将内容传递给程序之前将其删除 。</p>
</div>
<div class="paragraph">
<p>空格用于分隔参数，如果要在字符串中加空格，则必须用引号引起来。</p>
</div>
<div class="listingblock">
<div class="title">文件: args</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;Argument: «{ $_ }»&#34; for @*ARGS;</code></pre>
</div>
</div>
<div class="paragraph">
<p>并运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku args 123 &#34;456 789&#34; &#39;10 11 12&#39; 13
Argument: «123»
Argument: «456 789»
Argument: «10 11 12»
Argument: «13»</code></pre>
</div>
</div>
<div class="paragraph">
<p>两种类型（单精度和双精度）的 shell 均使用引号。</p>
</div>
<div class="paragraph">
<p>那么，我们如何指定引号，以使 shell 不用理会引号，然后将其发送给程序？</p>
</div>
<div class="paragraph">
<p>我们可以尝试同时使用单引号和双引号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku args &#34;&#39;456&#39;&#34; &#39;&#34;10&#34;&#39;
Argument: «&#39;456&#39;»
Argument: «&#34;10&#34;»</code></pre>
</div>
</div>
<div class="paragraph">
<p>那行得通。 至少对于 «bash»，我正在使用的 shell。 其他 shell 可能会有所不同。</p>
</div>
<div class="paragraph">
<p><strong>练习 10.2</strong>
编写一个程序，显示输入的类型，以及该类型的对象（或值）可用的方法的排序列表（按字母顺序）。</p>
</div>
<div class="paragraph">
<p>例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku type-methods &#34;3+4i&#34;
3+4i (of type ComplexStr) supports: (abs ACCEPTS acos acosec acosech acosh acotan acotanh asec asech asin asinh atan atan2 atanh base base-repeating Bool Bridge BUILDALL ceiling cis Complex conj cos cosec cosech cosh cotan cotanh denominator DUMP exp FatRat floor gist Int is-prime isNaN log log10 narrow new norm nude Num numerator Numeric raku polymod pred rand Range Rat Real roots round sec sech sign sin sinh sqrt Str succ tan tanh truncate unpolar WHICH)</code></pre>
</div>
</div>
<div class="paragraph">
<p>提示：请以例如 Int 类型开始并在 REPL 中试用。</p>
</div>
<div class="paragraph">
<p>我们获得的输入类型（如第 6.6.2.1 节&#34;Str 继承树&#34;中所示）是：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">普通类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">输入类型</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IntStr</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Num</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NumStr</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rat</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RatStr</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Complex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ComplexStr</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_签名">10.10.2. 签名</h4>
<div class="paragraph">
<p>显示的方法例如 <code>IntStr</code> 有一些重复项。 它们是由继承引起的，其中几个继承的类具有自己的版本。 实际上，这是不对列表进行排序的一个很好的理由。</p>
</div>
<div class="paragraph">
<p>这是一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say IntStr.^methods[1].^name;  # -&gt; Int
say IntStr.^methods[30].^name; # -&gt; Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们有没有办法判断一个方法属于哪个类？</p>
</div>
<div class="paragraph">
<p>签名方法为我们提供了答案，上下颠倒：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say IntStr.^methods[1].signature;  # -&gt; (IntStr:D: *%_)
say IntStr.^methods[30].signature; # -&gt; (Int: *%_ --&gt; Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个显然属于 <code>IntStr</code> 类，第二个显然属于 <code>Int</code> 类。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_intstr_问题">10.11. IntStr 问题</h3>
<div class="paragraph">
<p>这看起来很好, 对吗?</p>
</div>
<div class="listingblock">
<div class="title">文件: intstr-gotcha</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi MAIN (Int $number) {
    say &#34;Integer: $number&#34;;
}

multi MAIN (Str $string) {
    say &#34;String: $string&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku intstr-gotcha qwwe
String: qwwe</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是整型不起作用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku intstr-gotcha 12
Ambiguous call to &#39;MAIN(IntStr)&#39;; these signatures all match: :(Int $number)
:(Str $string)
in block &lt;unit&gt; at content/code/intstr-gotcha line 8</code></pre>
</div>
</div>
<div class="paragraph">
<p>问题在于我们得到了 <code>IntStr</code> 类型，并且由于它继承自 <code>Int</code> 和 <code>Str</code>，因此我们无法在 «MAIN» 候选对象之间进行选择。</p>
</div>
<div class="paragraph">
<p><strong>练习 10.3</strong>
解决这个问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_多重分派">10.12. 多重分派</h3>
<div class="paragraph">
<p>我们可以使用 <code>multi</code> 关键字指定具有不同参数列表（或&#34;签名&#34;）的过程的不同版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub do-something ($file1)         { ... }
multi sub do-something ($file1, $file2) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要，可以在指定 <code>multi</code> 时跳过 <code>sub</code>。</p>
</div>
<div class="paragraph">
<p>使用类型约束:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi add (Numeric $value1, Numeric $value2) { ... }
multi add (Str     $value1, Str     $value2) { ... }</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_存根运算符">10.12.1. 存根运算符</h4>
<div class="paragraph">
<p>我们可以指定占位符代码（也称为&#34;存根&#34;或«Yada,yada,yada»运算符，而不是普通代码。</p>
</div>
<div class="paragraph">
<p>该代码将编译，但是如果我们尝试执行它，将会抱怨：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">代码</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">动作</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">…​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fail</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">!!!</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">die</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">???</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">warn</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>它们将在«高级 Raku课程» 中介绍。</p>
</div>
<div class="paragraph">
<p><strong>yada</strong></p>
</div>
<div class="paragraph">
<p>我们可以使用 <code>yada</code> 检查过程是否存在存根：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub a { 1; }; say  &amp;a.yada; # -&gt; False;
sub b { ... }; say &amp;b.yada; # -&gt; True;
sub c { !!! }; say &amp;c.yada; # -&gt; True;
sub d { ??? }; say &amp;d.yada; # -&gt; True;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_斐波那契数">10.12.2. 斐波那契数</h4>
<div class="paragraph">
<p>这是前 10 个斐波那契数字：«1、2、3、5、8、13、21、34、55»。</p>
</div>
<div class="paragraph">
<p>第一个值是 1，第二个也是 1，其后每个值是两个先前值的和。</p>
</div>
<div class="paragraph">
<p>我选择显示以 1 开头的数字的版本。还有另一个以 0 开头的版本（索引已关闭）。 &#34;给我第三个斐波那契数&#34;的答案是 1 或 2。</p>
</div>
<div class="paragraph">
<p>这是一些打印给定斐波那契数的程序。</p>
</div>
<div class="paragraph">
<p>使用循环：</p>
</div>
<div class="listingblock">
<div class="title">文件: fibonacci-loop</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN (Int $n) {
    say fibonacci $n;
}

sub fibonacci (Int $n) {
    return 1 if $n == 1 or $n == 2;
    my @fib = (1, 1);

    for 2 .. $n -1 -&gt; $i {
        @fib[$i] = @fib[$i -1] + @fib[$i -2]
    }

    return @fib.tail;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用递归（一个反复调用自身的过程）：</p>
</div>
<div class="listingblock">
<div class="title">文件: fibonacci-recursive</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN (Int $n) {
    say fibonacci $n;
}

sub fibonacci (Int $n) {
    return 1 if $n == 1 or $n == 2;

    return fibonacci($n-1) + fibonacci($n-2)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>更短，实际上比循环版本更容易理解。</p>
</div>
<div class="paragraph">
<p>我们可以使用 <code>multi</code> 来排除前两个值：</p>
</div>
<div class="listingblock">
<div class="title">文件:  fibonacci-multi</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN (Int $n) {
    say fibonacci $n;
}

multi fibonacci (1) { 1 }
multi fibonacci (2) { 1 }

multi fibonacci (Int $n where $n &gt; 2) {
    fibonacci($n - 2) + fibonacci($n - 1)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么我们可以使用斐波那契数来做什么呢？ 除了炫耀我们的数学知识和 Raku 的力量外，也没什么。</p>
</div>
<div class="paragraph">
<p>(我们将在第 16.3.1 节&#34;斐波那契数列&#34;中展示更多。)</p>
</div>
<div class="paragraph">
<p>递归版本比循环版本慢。 我们将展示这一点，并在第15.5节&#34;计时斐波那契&#34;中说明原因。</p>
</div>
<div class="paragraph">
<p>«高级 Raku»课程中详细解释了多次调度。 在那里，我们介绍了 <code>proto</code>，以及将执行推迟到其他 <code>proto</code> 候选者的方法。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_过程参数">10.13. 过程参数</h3>
<div class="paragraph">
<p>默认情况下，传递给过程的值是只读的：</p>
</div>
<div class="listingblock">
<div class="title">文件: increment</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub increment ($value) {
    $value++;
    return $value;
}

my $number = increment(12);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku increment
  Cannot resolve caller postfix:&lt;++&gt;(Int);
  the following candidates match the type
  but require mutable arguments:
      (Mu:D $a is rw)
      (Int:D $a is rw)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_is_rw">10.13.1. is rw</h4>
<div class="paragraph">
<p>该错误消息给出了一个提示：<code>is rw</code>（«is read write»）。 这是一个特征，我们可以将其添加到参数中。</p>
</div>
<div class="paragraph">
<p>让我们尝试：</p>
</div>
<div class="listingblock">
<div class="title">文件: increment2</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub increment ($value is rw) {
    $value++;
    return $value;
}

my $number = increment(12);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku increment2
  Parameter &#39;$value&#39; expected a writable container,
  but got Int value
    in sub increment at increment2 line 3
    in block &lt;unit&gt; at increment2 line 9</code></pre>
</div>
</div>
<div class="paragraph">
<p>而且这也失败了。 问题是 <code>is rw</code> 告诉过程它可以更改调用代码中的变量，但是我们使用一个值对其进行了调用。 并且值不能更改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; 12 = 13;
  Cannot modify an immutable Int (12)
    in block &lt;unit&gt; at &lt;unknown file&gt; line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>这有作用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $value = 12;
my $result = increment($value);
say $value; # -&gt; 13</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，应该避免过程调用会在自身之外更改变量值而没有赋值的副作用。</p>
</div>
<div class="paragraph">
<p>如果你尝试调整传递的值，它将再次失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result = increment($value + 1);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_is_copy">10.13.2. is copy</h4>
<div class="paragraph">
<p><code>is copy</code> 特性是更简单的证明。 你将获得一个实变量，并将值的副本传递给它，并且可以随意更改它（副本）。</p>
</div>
<div class="listingblock">
<div class="title">文件: increment3</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub increment ($value is copy) {
    $value++;
    return $value;
}

say increment(12);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku increment3
13</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_可选参数">10.13.3. 可选参数</h4>
<div class="paragraph">
<p>可以为参数指定默认值，使其可选：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub do-something ($value, $optional = &#34;&#34;) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以拥有更多：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub do-something-else ($value, $optional1 = 5, $optional2 = $value * 2) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>不能为 <code>$optional2</code> 分配值，而不能为 <code>$optional1</code> 分配值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">do-something-else(11, 101);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_命名参数">10.13.4. 命名参数</h4>
<div class="paragraph">
<p>一个带有很多参数的过程可能是一个问题。 迟早有人会弄错参数的顺序。</p>
</div>
<div class="paragraph">
<p>通过在变量列表中以 <code>:</code>（冒号）作为前缀来指定命名实参，可以消除该问题，因为现在顺序无关紧要了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub aaa (:$a, :$b) { return 2*$a + $b; }
say aaa(a =&gt; 2, b =&gt; 3); # -&gt; 7
say aaa(b =&gt; 3, a =&gt; 2); # -&gt; 7</code></pre>
</div>
</div>
<div class="paragraph">
<p>命名参数使得可以具有许多可选参数，并且你可以根据需要使用任意数量的变量，而不必考虑顺序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub bbb (:$a = 12, :$b = 13, :$c = 12, :$d = 13 )
aaa(a =&gt; 1);
aaa(d =&gt; 3, a =&gt; 4);</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以混合使用普通（或位置）和命名参数，但位置参数必须排在首位：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub ccc ($a, $b, :$c, :$b) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>命名参数可能会让你想起 <code>Pair</code> 语法（请参见第9.1节&#34;Pair&#34;）。 这不是巧合，因为它们确实是 <code>Pair</code>。</p>
</div>
<div class="paragraph">
<p><strong>具名参数简写</strong></p>
</div>
<div class="paragraph">
<p>使用好的变量名可能会导致以下情况：</p>
</div>
<div class="listingblock">
<div class="title">文件: named</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub cost (:$height, :$width) {
    return $height * $width * 4;
}

my $height = 12;
my $width  = 512;

say cost(height =&gt; $height, width =&gt; $width);</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要变量名相同，我们可以将其缩短为：</p>
</div>
<div class="listingblock">
<div class="title">文件: named2(partial)</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say cost(:$height, :$width);</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku named
24576
$ raku named2
24576</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>大海捞针问题</strong></p>
</div>
<div class="paragraph">
<p>让我们回顾第9.6节&#34;值&#34;中介绍的&#34;大海捞针问题&#34;，从哈希中找到给定值的键。</p>
</div>
<div class="paragraph">
<p>这需要蛮力：</p>
</div>
<div class="listingblock">
<div class="title">文件: haystack</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub find-value-in-hash (%hash, $value, :$all = False, :$verbose = False) {
    say &#34;Looking for $value:&#34;;
    for %hash.kv -&gt; $key, $val {
        say &#34;- Checking $key&#34; if $verbose;
        if $val eq $value {
            say &#34;- Found it: $key -&gt; $val&#34;;
            last unless $all;
      }
    }
}

my %haystack = ( A =&gt; &#34;Bike&#34;,  Q =&gt; &#34;Beetle&#34;, &#34;#&#34; =&gt; &#34;Book&#34;, 12 =&gt; &#34;Needle&#34;,
                17 =&gt; &#34;Frog&#34;, 29 =&gt; &#34;DVD player (defective)&#34;, 76 =&gt; &#34;Bike&#34;);

find-value-in-hash(%haystack, &#34;Beetle&#34;);
find-value-in-hash(%haystack, &#34;Bike&#34;, :verbose);
find-value-in-hash(%haystack, &#34;Beetle&#34;);
find-value-in-hash(%haystack, &#34;Bike&#34;, :all);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我在这里使用了命名可选参数。</p>
</div>
<div class="paragraph">
<p>并运行它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku haystack
Looking for Beetle:
- Found it: Q -&gt; Beetle
Looking for Bike:
- Checking 17
- Checking 12
- Checking 29
- Checking Q
- Checking A
- Found it: A -&gt; Bike
Looking for Beetle:
- Found it: Q -&gt; Beetle
Looking for Bike:
- Found it: A -&gt; Bike
- Found it: 76 -&gt; Bike</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_命名强制参数">10.13.5. 命名强制参数</h4>
<div class="paragraph">
<p>我们可以使用 <code>is required</code> 特征将一个命名参数强制为必须参数, 或使用 <code>!</code> 简写形式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub ccc ($a, $b, :$c!, :$d is required) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这给出了一个很好的错误消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; ccc(1, 2);
Required named parameter &#39;c&#39; not passed in sub ccc at ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认值对于强制性参数毫无意义。 但是，编译器不会提出抗议。 所以 <code>:$d is required = False</code> 是合法的，即使默认值是无用的也是如此。</p>
</div>
</div>
<div class="sect3">
<h4 id="_副词">10.13.6. 副词</h4>
<div class="paragraph">
<p>在过程调用中指定命名参数时，可以使用其他副词语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub aa (:$a, :$b) { say &#34;A: $a B: $b&#34;; }

aa(a =&gt; 1, b =&gt; 2); # -&gt; A: 1 B: 2
aa(:a(1), :b(2));   # -&gt; A: 1 B: 2
aa(:1a,   :2b);     # -&gt; A: 1 B: 2

aa(a =&gt; &#34;r&#34;, b =&gt; &#34;h&#34;); # -&gt; A: r B: h
aa(:a&lt;r&gt; , :b&lt;h&gt;);      # -&gt; A: r B: h</code></pre>
</div>
</div>
<div class="paragraph">
<p>副词也可以与内置功能一起使用。</p>
</div>
<div class="paragraph">
<p>到目前为止，这些命名参数都已取值。 没有任何其他约束，也没有参数值，命名参数是布尔值。 没有值（没有约束）的副词形式为 <code>True</code>（因为这是 Pairs 所做的）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">aa(:a, :b); # -&gt; A: True B: True</code></pre>
</div>
</div>
<div class="paragraph">
<p>副词名称的前面的 <code>!</code> 使它成为 <code>False</code> 值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">aa(:a, :!b); # -&gt; A: True B: False</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 `%_` 来允许任何命名参数（就像我们可以使用 `@_` 来允许任何东西一样）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub named { say %_ }
named( name =&gt; &#39;Tom&#39; );             # -&gt; {name =&gt; Tom}
named( name =&gt; &#39;Phil&#39;, age =&gt; 12 ); # -&gt; {age =&gt; 12, name =&gt; Phil}
named;                              # -&gt; {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以结合命名和位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub both { say @_; say %_; }

both( 12, 13, name =&gt; &#34;Tom&#34;, age =&gt; 45 );
both( 12, name =&gt; &#34;Tom&#34;, age =&gt; 45, &#34;19C&#34; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>它们可以被混合，主要是增加了混乱。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_slurpy_运算符">10.14. <code>*</code> (Slurpy 运算符)</h3>
<div class="paragraph">
<p>如果我们尝试将标量传递给需要数组的过程，则会收到错误消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; sub a (@values) { say &#34;ok&#34;; }
&gt; a(1,2,3,4,5);
===SORRY!=== Error while compiling:
Calling a(Int, Int, Int, Int, Int) will never work with declared signature (@values) ------&gt; &lt;BOL&gt;⏏a(1,2,3,4,5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以通过使用一个稀疏（或“可变参数”）数组纠正过程签名，以将所有剩余的标量值作为列表获取。 在列表参数之前添加 `*`: <code>*@values</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub a (*@values) { say &#34;ok&#34;; }
a(1,2,3,4,5); # ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过确保始终使用列表作为参数来调用该过程，可以避免此问题，但是不适用于在命令行上传递的参数（因为它们始终是标量值）。 有关详细信息，请参见下一部分。</p>
</div>
<div class="paragraph">
<p>或者，我们可以删除签名，并在过程主体中访问 <code>@_</code>。</p>
</div>
<div class="sect3">
<h4 id="_slurpy_main">10.14.1. Slurpy MAIN</h4>
<div class="paragraph">
<p>在命令行中传递的参数始终是标量，但是我们可以使用 Slurpy 数组通过在 list 参数之前添加 `*` 来捕获所有参数：<code>*@words</code>：</p>
</div>
<div class="listingblock">
<div class="title">文件: words</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN (*@words) {
    @words.grep({ .contains(&#34;a&#34;) }).say;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku words absn kakak alala 9099 00 00
(absn kakak alala)

$ raku words
()</code></pre>
</div>
</div>
<div class="paragraph">
<p>吞噬参数允许零参数，这不是一件好事。</p>
</div>
<div class="paragraph">
<p>我们可以强迫它至少要求一个参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ($word1, *@words) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>祝你解释代码好运…​</p>
</div>
<div class="paragraph">
<p>使用类型约束给出不言自明的代码：</p>
</div>
<div class="listingblock">
<div class="title">文件: words2</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| One or more words to search for lines with the letter &#39;a&#39;
sub MAIN (*@words where @words.elems &gt;= 1) {
    @words.grep({ .contains(&#34;a&#34;) }).say;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>(而且添加明确的使用注释当然也没有什么坏处。)</p>
</div>
<div class="paragraph">
<p><code>contains</code> 做你心中所想； 检查左侧的字符串是否包含右侧的字符串。 查看有关详细信息，请参见第 11.4.2 节&#34;contains(部分字符串)&#34;。</p>
</div>
<div class="paragraph">
<p>我们可以稍微完善一下 <code>where</code> 条件：</p>
</div>
<div class="listingblock">
<div class="title">文件: words3 (partial)</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN (*@words where so @words)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_再谈随机素数">10.14.2. 再谈随机素数</h4>
<div class="paragraph">
<p>让我们回顾一下在练习 8.3 中编写的随机素数代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1 .. 100).grep(*.is-prime).pick.say;  # -&gt; 13
(1 .. 1000).grep(*.is-prime).pick.say; # -&gt; 1861</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以将其重写为程序，以上限为参数：</p>
</div>
<div class="listingblock">
<div class="title">文件: random-prime</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ($upper-limit) {
    (1 .. $upper-limit).grep(*.is-prime).pick.say;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku random-prime aaaaa
Cannot convert string to number: base-10 number must
begin with valid digits or &#39;.&#39; in &#39;⏏aaa&#39; (indicated by ⏏)
in sub MAIN at random-prime line 3
in block &lt;unit&gt; at random-prime line 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在输入参数中添加 <code>Int</code> 约束，则会得到更好的错误消息：</p>
</div>
<div class="listingblock">
<div class="title">文件: random-prime2 (partial)</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN (Int $upper-limit)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku random-prime2 aaaaa
Usage:
  random-prime2 &lt;upper-limit&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Int</code> 约束确保仅允许整数。 但是负整数呢？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku random-prime2 -100
Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>不，素数都是正数。</p>
</div>
<div class="paragraph">
<p>如果你不知道，REPL 可以为你提供帮助：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (-17).is-prime
False</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>(1 .. -100)</code> 构造将尝试生成从 1 到 -100 的整数。 那是不可能的，所以返回 <code>Nil</code>（一个空列表）。 然后，我们从一个空列表中选择一个随机值，得到 <code>Nil</code>。</p>
</div>
<div class="paragraph">
<p>如果你听说过序列(例如 <code>1 …​ -100</code>)； 是的，他们会在这里工作的，不，这没关系。 稍后我们将介绍序列。</p>
</div>
<div class="paragraph">
<p>最好将负输入值设为非法，这是可能的。</p>
</div>
<div class="paragraph">
<p>我们可以添加一个约束：</p>
</div>
<div class="listingblock">
<div class="title">文件: random-prime3</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN (Int $upper-limit where * &gt; 0) {
    (1 .. $upper-limit).grep(*.is-prime).pick.say;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku random-prime3 -100
Usage:
  random-prime2 &lt;upper-limit&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 的 <code>UInt</code> 类型为 «Unsigned Int»，我们当然可以使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_更好的错误信息">10.14.3. 更好的错误信息</h4>
<div class="paragraph">
<p>用法消息并没有真正告知我们合法值。 例如我们可以将变量重命名为 <code>$upper-limit-as-a-positive-integer-larger-than-zero</code>。</p>
</div>
<div class="paragraph">
<p>但是谁愿意输入这样的变量名呢？ 我们可以在用法消息中添加文本，如下所示：</p>
</div>
<div class="listingblock">
<div class="title">文件: random-prime4</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| A random prime number between 1 and ...
sub MAIN (Int $upper-limit where * &gt; 0) {
    (1 .. $upper-limit).grep(*.is-prime).pick.say;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将用法行放置在过程之前。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku random-prime4 -100
Usage:
  random-prime2 &lt;upper-limit&gt; -- A random prime \
  number between 1 and the given integer upper limit</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 10.4</strong></p>
</div>
<div class="paragraph">
<p>随机素数程序有什么问题？</p>
</div>
<div class="paragraph">
<p>重写程序以避免此问题。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_块重新访问">10.15. 块重新访问</h3>
<div class="paragraph">
<p>我们在第 4.1 节&#34;块&#34;中介绍了块，并将其定义为：«块是被视为整体的代码的集合。 一对大括号内设置了块。»</p>
</div>
<div class="paragraph">
<p>我们可以将它们赋值给变量，然后执行它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $block = { &#34;Hello, $_.&#34;; };
say $block(&#34;Thomas&#34;); # Hello, Thomas.</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们有一个参数，传入 <code>$_</code>。</p>
</div>
<div class="paragraph">
<p>我们可以使用占位符变量（如第10.4节&#34;占位符变量&#34;中所述），就像过程。 如果我们要传递不止一个参数，则它们很有用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $block = { &#34;Hello, $^a $^b.&#34;; };
say $block(&#34;Thomas&#34;, &#34;Mann&#34;); # Hello, Thomas Mann.</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_12">10.15.1. →</h4>
<div class="paragraph">
<p>我们还可以将命名变量中的参数传递给块（与过程一样），<code>→</code> 和块之间有签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $add = -&gt; $a, $b = 2 { $a + $b };
say $add(40); # 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>可选参数（具有默认值）起作用，如上所示(<code>$b = 2</code>)。</p>
</div>
<div class="paragraph">
<p>过程本质上是命名块。 但它们还有一些额外的花哨，主要是多重分派(请参见 10.12，&#34;多重分派“)。 还有更好的语法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_is_rw_2">10.15.2. &lt;→ / is rw</h4>
<div class="paragraph">
<p>默认情况下，变量是只读的，但是我们可以使用 <code>is rw</code> 副词使它们变为读写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $swap = -&gt; $a is rw, $b is rw { ($a, $b) = ($b, $a) };
my ($a, $b) = (2, 4);
$swap($a, $b);
say $a; # -&gt; 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者我们可以使用双向箭头 <code>&lt;→</code> 代替单向箭头，但是这会将所有参数变为读写。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $swap = &lt;-&gt; $a, $b { ($a, $b) = ($b, $a) };</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_调用在变量中指定的过程">10.16. 调用在变量中指定的过程</h3>
<div class="paragraph">
<p>我们可以调用一个在变量中具有名称的过程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub AAA { say &#34;ok&#34;; }
my $sub = &#34;AAA&#34;;
&amp;::($sub)(); # -&gt; ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用调度表是一个更好的解决方案：</p>
</div>
<div class="listingblock">
<div class="title">文件: dispatch-table</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub aaa {
    say &#34;12345&#34;;
}

sub bbb {
    say &#34;FOOBAR&#34;;
}

my %table;

%table{&#34;a&#34;} = &amp;aaa();
%table{&#34;b&#34;} = &amp;bbb();

&amp;(%table&lt;a&gt;);  # Execute &#34;aaa&#34;

my $p = &#34;b&#34;;

&amp;(%table{$p}); # Execute &#34;bbb&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以调用存储在变量中的方法。 请参见第17.21节&#34;调用变量中指定的方法&#34;。</p>
</div>
</div>
<div class="sect2">
<h3 id="_过程中的过程">10.17. 过程中的过程</h3>
<div class="paragraph">
<p>可以将过程定义放在另一个过程中。 结果是内部过程仅在外部过程内部可见（在范围内），并且只能由该过程调用。</p>
</div>
<div class="listingblock">
<div class="title">文件: procedure-procedure</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub A {
    say &#34;I am A&#34;;
    B;
}

sub B {
    say &#34;I am B&#34;;
}

A;
B;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">文件: procedure-procedure2</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub A {
    say &#34;I am A&#34;;
    B;
}

sub B {
    say &#34;I am B&#34;;
}

A;
B; # This is line 15</code></pre>
</div>
</div>
<div class="paragraph">
<p>左边的一个起作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku procedure-procedure
I am A
I am B
I am B</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是正确的代码在程序的最后一行给出了编译错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku procedure-procedure2
===SORRY!=== Error while compiling procedure-procedure2 Undeclared name:
      B used at line 15</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_正则表达式介绍">11. 正则表达式介绍</h2>
<div class="sectionbody">
<div class="paragraph">
<p>正则表达式是一种子语言，具有自己的语法和规则…​</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>有些人在遇到问题时会想：“我知道，我会使用正则表达式。”现在，他们有两个问题了。
— <a href="http://regex.info/blog/2006-09-15/247" class="bare">http://regex.info/blog/2006-09-15/247</a></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>处理此“问题”的一种方法是首先避免使用正则表达式。</p>
</div>
<div class="paragraph">
<p>本章介绍一些典型的正则表达式，然后介绍存在它们的非正则表达式替代方案。非正则表达式的替代品通常要快得多。</p>
</div>
<div class="paragraph">
<p>矛盾的是，非正则表达式替代品非常容易替换几乎不容易搞砸的正则表达式，而实际上可以使用替代品的更高级的正则表达式显然没有它们。</p>
</div>
<div class="paragraph">
<p>如果你在本章中使用了非正则表达式版本，那么在将来某个时候实际需要制作正则表达式时，你将处于不利地位。</p>
</div>
<div class="paragraph">
<p>Raku 更喜欢名称 «Regex»（和复数 «Regexes»）而不是 «Regular Expressions»，因为它们早已与 «regular» 起源不同。你可能会看到两个名字。 （建议使用名称“模式”和“规则”，但并没有流行。你可能会在较早的博客文章中碰到它们。）</p>
</div>
<div class="sect2">
<h3 id="_什么是正则表达式">11.1. 什么是正则表达式?</h3>
<div class="paragraph">
<p>正则表达式是一种与表达式匹配的方式（可以通过多种方式进行解释），而不是静态文本。</p>
</div>
<div class="paragraph">
<p>我们可以从第10.9节 &#34;MAIN&#34; 中的 &#34;hello&#34; 程序开始。</p>
</div>
<div class="listingblock">
<div class="title">文件: hello</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ($name) {
    say &#34;Hello, $name!&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的任务是对其进行调整，以使消息因名称而异：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果名称是 «Steve», «Neve» 或 «Barry»，我们打印 «Go away, &lt;name&gt;!»。</p>
</li>
<li>
<p>如果名称的长度为5个字符，中间的字符为元音，则我们打印 &#34;Hello, &lt;name&gt;. Whatsup?»</p>
</li>
<li>
<p>对于所有其他名称，我们打印 «Hello, &lt;name&gt;»</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">文件: hello-nonregex</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ($name) {
    if $name eq &#34;Steve&#34; or $name eq &#34;Neve&#34; or $name eq &#34;Barry&#34; {
      say &#34;Go away, $name!&#34;;
    }
    elsif $name.chars == 5 and ($name.substr(2,1) eq &#34;a&#34;
                            or $name.substr(2,1)  eq &#34;e&#34;
                            or $name.substr(2,1)  eq &#34;i&#34;
                            or $name.substr(2,1)  eq &#34;o&#34;
                            or $name.substr(2,1) eq &#34;u&#34;)
    {
        say &#34;Hello, $name. Whatsup?&#34;;
    } else {
        say &#34;Hello, $name!&#34;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>到目前为止，一切都很好。 很多代码，但是可以用。 但是，如果我们决定只坚持名称中的字母（一个5个字符的字母）怎么办？</p>
</div>
<div class="paragraph">
<p>我们可以将其重写为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">elsif $name ~~ /^ \w\w &lt;[aeiou]&gt; \w\w $/</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>«/» 字符标记正则表达式的开始和结束，默认情况下，空格和换行符都会被忽略。 «^»字符绑定到字符串的开头，«$» 绑定到字符串的结尾。</p>
</li>
<li>
<p>«\w» 匹配一个»单词字符»，它或多或少是我们想要的（一个字母）。</p>
</li>
<li>
<p>«&lt;[aeiou]&gt;» 是一个字符组，我们匹配其中给定的字符之一。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当你掌握 Regex 的知识时，它会更紧凑，更容易理解。</p>
</div>
</div>
<div class="sect2">
<h3 id="_制作正则表达式">11.2. 制作正则表达式</h3>
<div class="paragraph">
<p>生成正则表达式的最简单方法是将其放在两个 <code>/</code> 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/abc/
/12345/</code></pre>
</div>
</div>
<div class="paragraph">
<p>独立的正则表达式（像这样）与 <code>$_</code>（主题变量）匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; $_ = &#34;abc&#34;; say so /abc/; # -&gt; True
&gt; say so /abcd/; # -&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 <code>given</code>(参见章节4.12 &#34;given&#34;) 为我们设置 <code>$_</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say so /abc/ given &#34;abc&#34;; # -&gt; True</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_智能匹配运算符">11.3. ~~ (智能匹配运算符)</h3>
<div class="paragraph">
<p>«Smartmatch 运算符» ~~ 是 Regexes 的基础。 我们可以使用它来比较几乎所有内容和几乎所有其他内容（而不仅仅是 Regex）。</p>
</div>
<div class="paragraph">
<p>如果我们与 <code>$_</code> 匹配（如上一节所述），则可以删除 <code>~~</code>。 这些都是等价的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; $_ ~~ m/1234/;
&gt; $_ ~~ /1234/;
&gt; /1234/;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_m">11.3.1. m/…​/</h4>
<div class="paragraph">
<p>我们在正则表达式中添加 <code>m</code> 前缀（用于 «match»），可以将斜杠（<code>/</code>）与其他任何字符互换。 如果我们在正则表达式本身中有一个斜杠，这将很有用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; m|/usr/bin/|;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用带有开始和结束版本的字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; m{123};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_否定智能匹配运算符">11.3.2. !~ (否定智能匹配运算符)</h4>
<div class="paragraph">
<p>使用 «否定的智能匹配运算符» !~ 反转匹配。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_部分字符串">11.4. 部分字符串</h3>
<div class="paragraph">
<p>我们可以检查给定的字符串是否包含另一个字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say so &#34;12345&#34; ~~ /23/; # -&gt; True
&gt; say so &#34;12345&#34; ~~ /33/; # -&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以跳过右侧的斜线，但这会改变含义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say so &#34;12345&#34; ~~ &#34;23&#34;; # -&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们正在智能匹配两个字符串，这与普通字符串比较相同，因为它们不相等，因此返回 <code>False</code>。</p>
</div>
<div class="paragraph">
<p>我们可以将左侧放在变量中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $val = &#34;12345&#34;;
&gt; say so $val ~~ /23/; # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用正则表达式执行相同的操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $b = /23/;
&gt; say so &#34;12345&#34; ~~ $b; # -&gt; True
&gt; say $b.WHAT;          # -&gt; (Regex)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以将一个类型进行比较：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say so &#34;12345&#34; ~~ Int; # -&gt; False
&gt; say so 12345 ~~ Int;   # -&gt; True</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_regex类型">11.4.1. Regex(类型)</h4>
<div class="paragraph">
<p>我们可以使用类型系统:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my Regex $b = /23/;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_contains部分字符串">11.4.2. contains(部分字符串)</h4>
<div class="paragraph">
<p>部分字符串是如此有用，以至于我们有专门的 <code>contains</code> 函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;12345&#34;.contains(&#34;23&#34;); # -&gt; True
&gt; &#34;12345&#34;.contains(&#34;33&#34;); # -&gt; False</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_index部分字符串">11.4.3. index(部分字符串)</h4>
<div class="paragraph">
<p>使用 <code>index</code> 获取一个字符串在另一个字符串中的位置。 如果找到，它将返回索引，否则返回 <code>NIL</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;12345&#34;.index(&#34;1&#34;); # -&gt; 0
&gt; &#34;12345&#34;.index(&#34;0&#34;); # -&gt; Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个字符的位置（或偏移量）为 0，因此请注意返回值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&#34;12345&#34;.index(&#34;1&#34;).defined; # -&gt; True
&#34;12345&#34;.index(&#34;0&#34;).defined; # -&gt; False

so &#34;12345&#34;.index(&#34;1&#34;); # -&gt; False
so &#34;12345&#34;.index(&#34;0&#34;); # -&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p>TIPS: 如果你不需要该职位，请使用 <code>contains</code>。 然后，你不必担心定义性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_rindex部分字符串">11.4.4. rindex(部分字符串)</h4>
<div class="paragraph">
<p><code>rindex</code> 与 <code>index</code> 类似, 但是从右侧搜索, 给出上一次匹配的位置:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;121212121&#34;.index(1); # -&gt; 0
&gt; &#34;121212121&#34;.rindex(1); # -&gt; 8</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_indices部分字符串">11.4.5. indices(部分字符串)</h4>
<div class="paragraph">
<p><code>indices</code> 类似于 <code>index</code>，但是搜索在另一个字符串中出现的所有字符串。 如果找不到，它将返回一个空列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;banana&#34;.indices(&#34;a&#34;);      # -&gt; (1 3 5)
&gt; say &#34;banana&#34;.indices(&#34;ana&#34;);    # -&gt; (1)
&gt; say &#34;banana&#34;.indices(&#34;ana&#34;, 2); # -&gt; (3)
&gt; say &#34;banana&#34;.indices(&#34;b&#34;);      # -&gt; (0)
&gt; say &#34;banana&#34;.indices(&#34;X&#34;);      # -&gt; ()</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果指定了可选参数 <code>:overlap</code>，则搜索将从字符串中的下一个位置继续，而不是默认情况下在匹配之后：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;banana&#34;.indices(&#34;ana&#34;);               # -&gt; (1)
&gt; say &#34;banana&#34;.indices(&#34;ana&#34;, :overlap);     # -&gt; (1 3)
&gt; say &#34;aaaaaaaaaa&#34;.indices(&#34;aaa&#34;);           # -&gt; (0 3 6)
&gt; say &#34;aaaaaaaaaa&#34;.indices(&#34;aaa&#34;, :overlap); # -&gt; (0 1 2 3 4 5 6 7)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_字符串的开头或结尾">11.5. 字符串的开头或结尾</h3>
<div class="paragraph">
<p>上一节中的正则表达式将匹配，无论在字符串中的何处找到它。 我们可以使用锚来强制匹配仅考虑字符串的开始，结束或两者。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">锚点</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">例子</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">^</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/^123/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">只匹配字符串的开头</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/345$/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">只匹配字符串的结尾</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_starts_with部分字符串">11.5.1. starts-with(部分字符串)</h4>
<div class="paragraph">
<p>从字符串的开头匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say so &#34;12345&#34; ~~ /^23/;  # -&gt; False
&gt; say so &#34;12345&#34; ~~ /^123/; # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 <code>starts-with</code> 代替:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;12345&#34;.starts-with(&#34;23&#34;);   # -&gt; False
&gt; &#34;12345&#34;.starts-with(&#34;123&#34;);  # -&gt; True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ends_with部分字符串">11.5.2. ends-with(部分字符串)</h4>
<div class="paragraph">
<p>从字符串的末尾匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say so &#34;12345&#34; ~~ /123$/; # -&gt; False
&gt; say so &#34;12345&#34; ~~ /45$/;  # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 <code>ends-with</code> 代替:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;12345&#34;.ends-with(&#34;123&#34;); # -&gt; False
&gt; &#34;12345&#34;.ends-with(&#34;45&#34;);  # -&gt; True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_equal">11.5.3. equal</h4>
<div class="paragraph">
<p>我们可以使用两个锚，这与使用 <code>eq</code> 的普通字符串比较具有相同的意义（因为我们还没有使用过任何Regex特殊字符）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say so &#34;12345&#34; ~~ /^12345$/; # -&gt; True
&gt;        &#34;12345&#34; eq &#34;12345&#34;;   # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者甚至:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;12345&#34; ~~ &#34;12345&#34;; # -&gt; True</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_正则表达式元字符">11.6. 正则表达式元字符</h3>
<div class="paragraph">
<p>在正则表达式中，按字母顺序输入字母数字字符（字母和数字）和下划线（_），忽略空格，其他所有字符都是具有特殊含义的元字符。</p>
</div>
<div class="paragraph">
<p>Regexes中的空格和换行符默认情况下会被忽略，因此可以随意添加它们以增强可读性。</p>
</div>
<div class="paragraph">
<p>我们可以通过引号（带反斜杠）来获得文字元字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say so &#34;12/34&#34; ~~ /2\/3/; # -&gt; True</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_match_对象">11.7. $/(Match 对象)</h3>
<div class="paragraph">
<p><code>$/</code> 对象保存上一次正则表达式匹配的结果（如果没有匹配，则为 <code>Nil</code>）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;12345&#34; ~~ /12/; say $/; # -&gt; 「12」
&gt; &#34;12345&#34; ~~ /67/; say $/; # -&gt; Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意有趣的尖括号。 当我们打印匹配对象时使用它们，以提醒我们 <code>$/</code> 是匹配对象，而不是字符串。</p>
</div>
<div class="paragraph">
<p>使用显式字符串化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say $/.Str; # -&gt; 12
&gt; say ~$/;    # -&gt; 12</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>put</code>（请参见第6.3.3节&#34;put 与 say&#34;）会进行字符串化，并隐藏了问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;12345&#34; ~~ /12/; put $/; # -&gt; 12</code></pre>
</div>
</div>
<div class="paragraph">
<p>将匹配对象传递给期望字符串的代码可能会导致错误。 如果有问题的代码通过 Nativecall 使用外部库，则该程序几乎肯定会崩溃。</p>
</div>
<div class="paragraph">
<p>Nativecall 将在&#34;高级 Raku&#34;课程中详细介绍。</p>
</div>
</div>
<div class="sect2">
<h3 id="_特殊字符">11.8. 特殊字符</h3>
<div class="paragraph">
<p><code>.</code>(单个点)只匹配一个字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say so &#34;12345&#34; ~~ /1.3.5/; # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以在任何字符后添加一个量词：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">量词</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">贪婪性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配零次或一次</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配一次或多次</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配零次、一次或多次</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">** nnumber</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">精确匹配 «number» 次</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">** min..max</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最少匹配 «min» 次, 最多匹配 «max» 次</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>注意，某些量词（如所示）使匹配贪婪。 只要它能够匹配表达式，它就会尽可能匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say so &#34;111111111111112345&#34; ~~ /1+2345/; # -&gt; True
&gt; say so &#34;111111111111112345&#34; ~~ /1+2345/; # -&gt; True

&gt; say so &#34;12345&#34; ~~ /123459/;              # -&gt; False
&gt; say so &#34;12345&#34; ~~ /123459*/;             # -&gt; True

&gt; say so &#34;011111111111111234&#34; ~~ /01 ** 1..20 234/; # -&gt; True
&gt; say so &#34;011111111111111234&#34; ~~ /01 ** 1..10 234/; # -&gt; False</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_捕获和分组">11.9. 捕获和分组</h3>
<div class="paragraph">
<p>到目前为止，我们仅展示了如何匹配（或不匹配），但是我们可以将匹配分为几个部分。</p>
</div>
<div class="sect3">
<h4 id="_捕获">11.9.1. ()(捕获)</h4>
<div class="paragraph">
<p>我们可以使用圆括号来捕获匹配项，并稍后将它们引用为 <code>$0</code>，<code>$1</code>（依此类推）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;12345&#34; ~~ /(2)(.4)/;
&gt; say $0.Str; # -&gt; 2
&gt; say $1.Str; # -&gt; 34</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 match 对象代替 <code>$0</code>，<code>$1</code>（依此类推）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say $/
「234」
  0 =&gt; 「2」
  1 =&gt; 「34」</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以查找单个匹配项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say $/[1].Str; # -&gt; 23456</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也可以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say $[1].Str; # -&gt; 23456</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_捕获编号">11.9.2. 捕获编号</h4>
<div class="paragraph">
<p>圆括号对儿从零开始从左到右编号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;0: $0; 1: $1&#34; if &#39;abc&#39; ~~ /(a) b (c)/; # -&gt; 0: a; 1: c</code></pre>
</div>
</div>
<div class="paragraph">
<p>捕获可以嵌套，并根据级别编号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if &#39;abc&#39; ~~ / ( a (.) (.) ) / {
    say &#34;Outer: $0&#34;;              # -&gt; Outer: abc
    say &#34;Inner: $0[0] and $0[1]&#34;; # -&gt; Inner: b and c
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>匹配对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say $/;
「abc」
  0 =&gt; 「abc」
   0 =&gt; 「b」
   1 =&gt; 「c」</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_非捕获分组">11.9.3. [](非捕获分组)</h4>
<div class="paragraph">
<p>如果我们不需要捕获，可以跳过它。 我们的 Regex 需要它们进行分组，但是我们可以改用非捕获括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $valid-ipv4 = /^ [\d ** 1..3] ** 4 % &#39;.&#39; $/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不捕获的好处：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>匹配对象不会被未使用的东西弄乱</p>
</li>
<li>
<p>比捕获更快</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_捕获标记">11.9.4. &lt;()&gt;(捕获标记)</h4>
<div class="paragraph">
<p>当我们有一个匹配项时，无论我们使用了多少个捕获（如果有），匹配对象都会包含整个字符串。</p>
</div>
<div class="paragraph">
<p>通过使用 <code>&lt;(</code> 和/或 <code>)&gt;</code> 标记，我们可以防止部分匹配最终出现在 match 对象中：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">标记</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;(</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不捕获该标记之前的东西</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">)&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不捕获该标记之后的东西</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;abc&#39; ~~ / a &lt;( b )&gt; c/; # -&gt; 「b」
say &#39;abc&#39; ~~ / a ( b ) c/;   # -&gt; 「abc」; 0 =&gt; 「b」</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">prematch / .postmatch</div>
<p>使用捕获标记时，有可能在匹配之前和之后获得字符串的一部分。 在 match 对象上使用 <code>prematch</code> 和/或 <code>postmatch</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#39;abc&#39; ~~ / a &lt;( b )&gt; c/; # -&gt; 「b」
&gt; say $/.prematch;             # -&gt; a
&gt; say $/.postmatch;            # -&gt; c</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些方法返回字符串（而不是匹配的对象）。</p>
</div>
<div class="paragraph">
<div class="title">orig/.target</div>
<p>无论捕获标记如何，我们也可以获取原始字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#39;abc&#39; ~~ / a &lt;( b )&gt; c/; # -&gt; 「b」
&gt; say $/.orig;                 # -&gt; abc
&gt; say $/.target                # -&gt; abc</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>orig</code> 返回一个对象，而 <code>target</code> 返回它的字符串化版本。 当我们从字符串（&#39;abc&#39;）开始时，它们都在此处返回字符串。</p>
</div>
<div class="paragraph">
<p>还有其他可用于匹配对象的方法。 有关详细信息，请参见 <a href="https://docs.raku.org/type/Match#Methods。" class="bare">https://docs.raku.org/type/Match#Methods。</a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_字符类">11.10. 字符类</h3>
<div class="paragraph">
<p>我们可以使用字符类来匹配不同种类的字符。</p>
</div>
<div class="paragraph">
<p>我们在以下定义了前导反斜杠(称为«反斜杠字符类»)：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">否定</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\n</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">换行符(查看6.1章换行中的 $?NL)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\N</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\t</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">制表符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\T</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\h</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">水平空白符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\H</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\v</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">垂直空白符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\V</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空白符(水平或垂直)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\S</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数字(包括 unicode 数字)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\D</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">单词字符;字母,数字或下划线(包括 unicode 字母和数字)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\W</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>除非与量词结合使用，否则它们将完全匹配一个字符。 否定的版本匹配所有内容-除了普通版本。</p>
</div>
<div class="paragraph">
<p><code>\s</code> 匹配换行符和空白符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say so &#34;abc abf&#34; ~~ /\s/;   # -&gt; True;
&gt; say so &#34;abcXabf&#34; ~~ /\s/;   # -&gt; False;
&gt; say so &#34;abcXabf\n&#34; ~~ /\s/; # -&gt; True;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还有更冗长的命名字符类。 最有用的是：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">别名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;alnum&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;alpha&gt; 加上 &lt;digit&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;alpha&gt;</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字母字符,包括下划线</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;blank&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\h</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">水平空白符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;cntrl&gt;</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;digit&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">十进制数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;graph&gt;</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;alnum&gt; 加上 &lt;punct&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;lower&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Ll&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小写字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;print&gt;</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;graph&gt; 加上 &lt;space&gt;, 但是不含 &lt;cntrl&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;space&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">空白符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;upper&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Lu&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大写字符</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;xdigit&gt;</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">十进制数字 [0-9A-Fa-f]</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>有关完整列表，请参见 <a href="https://docs.raku.org/language/regexes#Predefined_character_classes。" class="bare">https://docs.raku.org/language/regexes#Predefined_character_classes。</a></p>
</div>
<div class="paragraph">
<p>我们没有显示仅代表字母的字符类。 我们在 Unicode 类别中有几种可以使用的类别。 最有用的（在很长的列表中）是：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">短</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">长</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:L&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Letter&gt;</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Ll&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Lowercase_Letter&gt;</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Lu&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Uppercase_Letter&gt;</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:N&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Number&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配数字, unicode 数字和 «1⁄2» 这样的东西。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:P&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Punctuation&gt; 或 &lt;:punct&gt;</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:S&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Symbol&gt;</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Sc&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;:Currency_Symbol&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配 «£», «$», «€» 和其它货币符号。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>有关完整列表，请参见 <a href="https://docs.raku.org/language/regexes#Unicode_properties。" class="bare">https://docs.raku.org/language/regexes#Unicode_properties。</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;1234sksjsjsjs1919&#34; ~~ /(&lt;:N&gt;+)/;       # $0 -&gt; 「1234」
&gt; &#34;1234sksjsjsjs1919&#34; ~~ /(&lt;:N&gt;+)(&lt;:L&gt;)/; # $0 -&gt; 「1234」, $1 -&gt; 「s」</code></pre>
</div>
</div>
<div class="paragraph">
<p>仅计算字符串中的字符数：</p>
</div>
<div class="listingblock">
<div class="title">文件: letter-count</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ($string) {
    my $count = $string.comb.grep(* ~~ /&lt;:L&gt;/).elems;

    say &#34;The string contains $count letters.&#34;;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku letter-count 12Aw
The string contains 2 letters.

$ raku letter-count 12Aw#@ß
The string contains 3 letters</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，我们可以缩短选择位：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $count = $string.comb.grep(/&lt;:L&gt;/).elems;</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于 Unicode 的进一步阅读:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.raku.org/language/regexes#Unicode_properties" class="bare">https://docs.raku.org/language/regexes#Unicode_properties</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Unicode_character_property" class="bare">https://en.wikipedia.org/wiki/Unicode_character_property</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们可以通过在 <code>:</code>(冒号)和类名之间的插入来 <code>!</code>(感叹号)否定它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so &#34;1234sksjsjsjs1919&#34; ~~ /&lt;:!L&gt;/; # -&gt; True
say so &#34;abcdefghijklmnopq&#34; ~~ /&lt;:!L&gt;/; # -&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以组合几个 Unicode 类别。 在尖括号里面用 <code>+</code> 来将它们加起来（作为集合并集），或用 <code>-</code> 减去右侧(差集):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so &#34;1234sksjsjsjs1919&#34;  ~~ /&lt;:!L-:N&gt;/;  # -&gt; False
say so &#34;1234sksjsjsjs1919.&#34; ~~ /&lt;:!L-:N&gt;/; # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个检查不是字母(<code>!L</code>)的所有字符，然后删除数字。 那让我们一无所有。 第二个相同，但是只剩下一个句点(<code>.</code>)。</p>
</div>
<div class="sect3">
<h4 id="_uniprop">11.10.1. uniprop</h4>
<div class="paragraph">
<p>使用 <code>uniprop</code> 可以显示给定字符串中第一个字符的 Unicode 类别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; &#34;a&#34;.uniprop; # -&gt; Ll
&gt; &#34;A&#34;.uniprop; # -&gt; Lu
&gt; &#34;ß&#34;.uniprop; # -&gt; Ll
&gt; &#39;$&#39;.uniprop; # -&gt; Sc</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以检查特定的属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;a&#39;.uniprop(&#39;Alphabetic&#39;); # -&gt; True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_uniprops">11.10.2. uniprops</h4>
<div class="paragraph">
<p>使用 <code>uniprops</code> 获取字符串中每个字符的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;Fix 10!&#34;.uniprops;           # -&gt; (Lu Ll Ll Zs Nd Nd Po)
&#34;Fix 10!&#34;.uniprops(&#34;Letter&#34;); # -&gt; (1 1 1 0 0 0 0)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_自定义字符类">11.11. 自定义字符类</h3>
<div class="paragraph">
<p>我们可以使用 <code>&lt;[</code> 和 <code>]&gt;</code> 指定我们自己的字符类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;abcdefghijklmn&#34; ~~ /(&lt;[fed]&gt;+)/; # $0 -&gt; 「def」</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意字符类本身只匹配一个字符。</p>
</div>
<div class="paragraph">
<p>我们可以否定字符类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;abcdefghijklmn&#34; ~~ /(&lt;-[fed]&gt;+)/; # $0 -&gt; 「abc」</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 <code>-</code> 组合字符类(与 Unicode 属性一样), 并使用范围:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;1234567890&#34; ~~ /(&lt;[1..9] - [5]&gt;+)/; # $0 -&gt; 「1234」</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_非贪婪">11.12. 非贪婪</h3>
<div class="paragraph">
<p>我们已经证明某些正则表达式量词是贪婪的，因为它们尽可能地匹配。 我们可以通过在贪婪量词后面添加 <code>?</code> 使它们变得非贪婪（或节俭）:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;12345A&#34; ~~ /(\d*?)/;  # $0 -&gt; 「」 # zero or more gives zero.
&#34;12345A&#34; ~~ /(\d+?)/;  # $0 -&gt; 「1」 # one or more gives zero.
&#34;12345A&#34; ~~ /(\d+?)A/; # $0 -&gt; 「12345」</code></pre>
</div>
</div>
<div class="paragraph">
<p>如上例所示，非贪婪仅适用于向右方向。 我们仍然从头开始匹配（如果可能的话），并获取所有数字。</p>
</div>
<div class="sect3">
<h4 id="_用法">11.12.1. 用法</h4>
<div class="paragraph">
<p>我们可以用一个简单的（如愚蠢的）html 解析器来说明这一点。 我们要提取图像标签：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;AAA &lt;img src=&#39;12.png&#39; alt=&#39;High Noon&#39;&gt; BBB&#34; ~~ /(\&lt;img\s.*\&gt;)/;
# 0 =&gt; 「&lt;img src=&#39;12.png&#39; alt=&#39;High Noon&#39;&gt;」</code></pre>
</div>
</div>
<div class="paragraph">
<p>我添加了 <code>\s</code>，以便我们不匹配另一个名称相似的标签。 （不应该有任何蜜蜂，但是通常通过将 html 标签重命名为未使用的标签来注释掉 html 标签。浏览器会忽略未知标签，我们也应该这样做。）</p>
</div>
<div class="paragraph">
<p>这看起来很有希望。 但是 <code>.*</code> 是贪婪的，如果有更多的话，它将一直持续到行中的最后一个 <code>&gt;</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;AAA &lt;img src=&#39;12.png&#39; alt=&#39;High Noon&#39;&gt; BBB &lt;b&gt;CCC&lt;/b&gt; DDD&#34; ~~ /(\&lt;img\s.*\&gt;)/;
# 0 =&gt; 「&lt;img src=&#39;12.png&#39; alt=&#39;High Noon&#39;&gt; BBB &lt;b&gt;CCC&lt;/b&gt;」</code></pre>
</div>
</div>
<div class="paragraph">
<p>非贪婪:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;AAA &lt;img src=&#39;12.png&#39; alt=&#39;High Noon&#39;&gt; BBB &lt;b&gt;CCC&lt;/b&gt;&#34; ~~ /(\&lt;img\s.*?\&gt;)/;
#「&lt;img src=&#39;12.png&#39; alt=&#39;High Noon&#39;&gt;」</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_向后引用">11.13. 向后引用</h3>
<div class="paragraph">
<p>可以在正则表达式中引用我们已经与 <code>$0</code>，<code>$1</code> 等匹配的东西。</p>
</div>
<div class="paragraph">
<p>«img» 标签没有结束标签，例如 «b»。 我们可以尝试编写一个通用的匹配任何标签的正则表达式，并一直持续到匹配结束标签为止。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;This is &lt;b&gt;bold &lt;em&gt;and cursive&lt;/em&gt; and not&lt;/b&gt;.&#34; ~~ /\&lt;(.*?)\&gt;(.*)\&lt;\/$0\&gt;/
#「&lt;b&gt;bold &lt;em&gt;and cursive&lt;/em&gt; and not&lt;/b&gt;」
# 0 =&gt; 「b」
# 1 =&gt; 「bold &lt;em&gt;and cursive&lt;/em&gt; and not」</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">练习 11.1</div>
<div class="content">
<pre>这个正则表达式有一个问题。问题是什么?</pre>
</div>
</div>
<div class="sect3">
<h4 id="_ignorecase_i">11.13.1. :ignorecase / :i</h4>
<div class="paragraph">
<p>我们可以用 <code>:ignorecase</code>(和缩写形式 <code>:i</code>) 副词指定不区分大小写的匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so &#34;abcdefghijkl&#34; ~~ /EFG/;    # -&gt; False
say so &#34;abcdefghijkl&#34; ~~ /:i EFG/; # -&gt; True</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用正则表达式">11.14. 使用正则表达式</h3>
<div class="paragraph">
<p>正则表达式通常以斜杠开头和结束。 例如  <code>/abc/</code>。 （我们将在«高级Raku»课程中介绍其他方法。）</p>
</div>
<div class="paragraph">
<p>我们仅看到与字符串匹配的正则表达式。 但是它们也可以用来更改我们应用它们的字符串。</p>
</div>
<div class="paragraph">
<p>我们可以通过不同的方式将正则表达式应用于字符串：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">函数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">查看章节</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">m/…​/</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配 $_</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11.3.1, m/…​/</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rx/…​/</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Regex 对象</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/…​/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">match</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Regex 对象(<code>rx/…​/</code> 的短形式)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11.2, 制造正则表达式</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">s/…​/…​/</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">就地替换</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11.15, 字符串替换</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">S/…​/…​/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">subst</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">非破坏性替换</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11.15.2 subst(字符串替换) 和 11.15.3 S/…​/…​/(字符串替换)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tr/…​/…​/</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">就地翻译</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11.17, 翻译</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TR/…​/…​/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">trans</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">非破坏性翻译</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11.17.2 trans(翻译) 和 11.17.4, TR/…​/…​/(翻译)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>除了第三个定界符(<code>/…​/</code>)外，我们都可以对它们使用任何定界符（而不是 <code>/</code>）。 请注意，打开和关闭字符的版本(例如 <code>{</code> 和 <code>[</code>)仅适用于匹配项。</p>
</div>
<div class="paragraph">
<p>替换和翻译使用三个斜杠，但第三个应为斜杠并不清楚。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>`match` 方法在&#34;高级 Raku&#34;课程中介绍。</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_字符串替换">11.15. 字符串替换</h3>
<div class="paragraph">
<p>使用字符串替换将一个字符序列替换为另一字符序列。</p>
</div>
<div class="sect3">
<h4 id="_s字符串替换">11.15.1. s/…​/…​/(字符串替换)</h4>
<div class="paragraph">
<p><code>s/…​/…​/</code> 运算符在左侧变量上进行更改:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = &#34;one two three four&#34;;
$s ~~ s/two/zero/;
say $s; # -&gt; one zero three four</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，替换只发生一次。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = &#34;one one one one&#34;;
$s ~~ s/one/zero/;
say $s; # -&gt; zero one one one</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_global_g">11.15.2. :global / :g</h4>
<div class="paragraph">
<p>我们可以指定 <code>:global</code>（或 <code>:g</code> 简短形式）副词来尽可能多地进行替换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = &#34;one one one one&#34;;
$s ~~ s:g/one/zero/;
say $s; # -&gt; zero zero zero zero</code></pre>
</div>
</div>
<div class="paragraph">
<p>它不能递归工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = &#34;111111111111&#34;;
$s ~~ s:g/11/1/;
say $s; # -&gt; 111111</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的字符计数程序的另一种形式：</p>
</div>
<div class="listingblock">
<div class="title">文件: letter-count-remove</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ($string is copy) {
    $string ~~ s:g/&lt;-:L&gt;+//;

    say &#34;The string contains { $string.chars } letters.&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们删除所有不是字母的内容，然后计算剩余的内容。</p>
</div>
</div>
<div class="sect3">
<h4 id="_subst字符串替换">11.15.3. subst(字符串替换)</h4>
<div class="paragraph">
<p><code>subst</code> 返回调用字符串，其中第一个字符串被第二个字符串替换（如果找不到匹配项，则返回原始字符串）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = &#34;one two three four&#34;;
my $t = $s.subst(&#34;two&#34;, &#34;zero&#34;);
say $s; # -&gt; one two three four
say $t; # -&gt; one zero three four</code></pre>
</div>
</div>
<div class="paragraph">
<p>它不会更改被调用的字符串或变量，因此我们可以这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t = &#34;one two three four&#34;.subst(&#34;two&#34;, &#34;zero&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>除非使用 <code>:g</code>（全局）副词，否则替换仅执行一次：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;1010101010101020202020202020&#34;.subst(&#34;10&#34;, &#34;X&#34;)
# X10101010101020202020202020</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;1010101010101020202020202020&#34;.subst(:g, &#34;10&#34;, &#34;X&#34;)
# XXXXXXX20202020202020</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要更改我们所调用的变量，请把新值赋值回来：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$variable .= subst($replace, $with);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_s字符串替换_2">11.15.4. S/…​/…​/(字符串替换)</h4>
<div class="paragraph">
<p><code>s/…​/…​/</code> 更改在其上使用的字符串。 如果要保持字符串不变，请改用 <code>S/…​/…​/</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#34;one two three four&#34;;
my $t = S/two/zero/;
say $t; # -&gt; one zero three four
say $_; # -&gt; one two three four</code></pre>
</div>
</div>
<div class="paragraph">
<p>你不能将智能匹配与 <code>S/…​/…​/</code> 运算符一起使用（甚至不能在 <code>$_</code> 上显式使用）。</p>
</div>
<div class="paragraph">
<p>但是我们可以使用 <code>given</code> 隐式设置 <code>$_</code>（请参见第4.12节&#34;given&#34;）:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t = S/two/zero/ given &#34;one two three four&#34;;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_替换调优">11.15.5. 替换调优</h4>
<div class="paragraph">
<p>我们可以用 <code>:x</code> 副词指定要替换的数量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># targeted substitution. Number of times to substitute. Returns back unmodified.
$str.subst(/foo/, &#34;no subst&#34;, :x(0));
$str.subst(/foo/, &#34;bar&#34;, :x(1)); #replace just the first occurrence.</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以用 <code>:nth</code> 副词指定要替换的匹配项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$str.subst(/foo/, &#34;bar&#34;, :nth(3)); # replace nth match alone. Replaces the third foo.
#  Returns Hey foo foo bar</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_副词_2">11.16. 副词</h3>
<div class="paragraph">
<p>正则表达式副词）我们可以使用副词来更改正则表达式的工作方式：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">副词</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">短形式</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">On</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:continue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:c</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从哪里开始搜索</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:exhaustive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有可能的匹配,包括重叠匹配</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:global</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:g</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有匹配, 不仅仅是第一个。查看 11.15.1.1, &#34;:global/:g&#34;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ignorecase</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:i</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">R</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">查看 11.13.1,&#34;:ignorecase/:i&#34;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ignoremark</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:m</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">R</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">只比较基字符串。见下文。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:overlap</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ov</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">和 <code>:exhaustive</code> 一样, 但是每个起始位置只有一个</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:pos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:p</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从指定位置(子串索)锚定匹配</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ratchet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:r</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">R</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不回溯</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:samecase</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ii</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">S</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配时忽略大小写，但将其应用于替换。 见下文。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:samemark</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:mm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">S</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">和 <code>:ignoremark</code> 一样，并将重音应用于替换。 见下文。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:samespace</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ss</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">S</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">和 <code>:sigspace</code> 一样，并将空格替换。 见下文。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:sigspace</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">R</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使空白有意义。 见下文。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>«On» 列意味着:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>M - 仅用于匹配</p>
</li>
<li>
<p>R - 用于所有正则表达式</p>
</li>
<li>
<p>S - 仅用于替换</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>«参见下文»没有显示的副词未在本书中显示。 有关详细信息，请参见 <a href="https://docs.raku.org/language/regexes#Adverbs。" class="bare">https://docs.raku.org/language/regexes#Adverbs。</a></p>
</div>
<div class="sect3">
<h4 id="_ignoremark_m">11.16.1. :ignoremark / :m</h4>
<div class="paragraph">
<p>正则表达式：仅比较基字符，忽略重音符号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so /:ignoremark abc/ given &#34;åbc&#34;; # -&gt; True
say so /:ignoremark abc/ given &#34;øbc&#34;; # -&gt; False
say so /:ignoremark obc/ given &#34;øbc&#34;; # -&gt; True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_samemark_mm">11.16.2. :samemark / :mm</h4>
<div class="paragraph">
<p>仅替换：和 <code>:ignoremark</code> 一样，并将重音应用于替换。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say S:samemark:global/a/o/ given &#34;åbäcà&#34;; # -&gt; o̊böcò</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_samecase_ii">11.16.3. :samecase / :ii</h4>
<div class="paragraph">
<p>仅替换：匹配时忽略大小写，但将其应用于替换。 因此，«abc» 和 «Abc» 将与 «abc»，«Abc»，«ABC» 等匹配。 替换字符串的大小写与匹配中指定的大小写相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say S:samecase/abc/def/ given &#34;xABCxabcABx&#34;; # -&gt; xDEFxabcABx</code></pre>
</div>
</div>
<div class="paragraph">
<p>与常规替换比较：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say S/abc/def/ given &#34;xABCxabcABx&#34;; # -&gt; xABCxdefABx</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sigspace_s">11.16.4. :sigspace / :s</h4>
<div class="paragraph">
<p>正则表达式: 让空白有意义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so &#34;abc abc&#34; ~~ /abc abc/; # -&gt; False (as «/abcabc/» does not match)
say so &#34;abc abc&#34; ~~ /:sigspace abc abc/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，第一个空格（在副词和正则表达式中的第一个 «a» 字母之间）用作分隔符，将被忽略。</p>
</div>
</div>
<div class="sect3">
<h4 id="_samespace_ss">11.16.5. :samespace /:ss</h4>
<div class="paragraph">
<p>仅替换：和 <code>:sigspace</code> 一样，并将空白替换。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say S:samespace/a ./c d/ given &#34;a b&#34;;  # -&gt; c d
say S:samespace/a ./c d/ given &#34;a\tb&#34;; # -&gt; c\td</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_翻译">11.17. 翻译</h3>
<div class="paragraph">
<p>翻译是用一个字符替换另一个字符的过程。</p>
</div>
<div class="sect3">
<h4 id="_tr翻译">11.17.1. tr/…​/…​/(翻译)</h4>
<div class="paragraph">
<p><code>tr/…​/…​/</code> 运算符在左侧变量上进行更改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = &#34;1234567890&#34;;
$s ~~ tr/129/ABx/; # -&gt; AB345678x0</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们没有指定足够的替换字符，则使用最后一个（重用）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = &#34;1234567890&#34;;
$s ~~ tr/129/A/; # -&gt; AA345678A0</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以移除字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = &#34;1234567890&#34;;
$s ~~ tr:delete/129//; # -&gt; 3456780</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_trans翻译">11.17.2. trans(翻译)</h4>
<div class="paragraph">
<p>使用 <code>trans</code> 将一个字符换成另一个，指定一个 <code>Pair</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;abcabc&#34;.trans(&#34;a&#34; =&gt; &#34;1&#34;); # -&gt; 1bc1bc</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以同时进行多个翻译：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;abcabc&#34;.trans(&#34;a&#34; =&gt; &#34;1&#34;, &#34;b&#34; =&gt; &#34;9&#34;); # -&gt; 19c19c</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们 还可以使用散列:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %trans = (&#34;a&#34; =&gt; &#34;1&#34;, &#34;b&#34; =&gt; &#34;9&#34;);
say &#34;abcabc&#34;.trans(%trans); # -&gt; 19c19c</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以使用范围:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;secret text&#34;.trans( [&#39;a&#39; .. &#39;z&#39;] =&gt; [&#39;b&#39; .. &#39;z&#39;, &#39;a&#39;] );</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rotate_13">11.17.3. Rotate 13</h4>
<div class="listingblock">
<div class="title">练习 11.2</div>
<div class="content">
<pre>最古老的著名加密算法是&#34;Rotate 13&#34;，从罗马帝国就知道了。

相同的功能进行加密和解密，因为（罗马）字母中有26个字符。 （罗马人没有&#34;j&#34;和&#34;v&#34;, 因此他们只有 24 个字符，但我们将忽略这一历史性异常。）

实现«rotate13»。

仅处理 a-z 和 A-Z。 其他所有字符均保持不变。

把字符串 &#34;Hello, raku programmers&#34; 翻译为 &#34;Uryyb,enxh cebtenzzref!&#34; 反之亦然。</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tr翻译_2">11.17.4. TR/…​/…​/(翻译)</h4>
<div class="paragraph">
<p><code>tr/…​/…​/</code> 运算符更改其使用的字符串。 如果要保持字符串不变，请使用 <code>TR/…​/…​/</code> 代替：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = &#34;one two three four&#34;;
my $t = TR/oe/xx/;
say $t; # -&gt; xnx twx thrxx fxur
say $_; # -&gt; one two three four</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_trimtrim_leadingtrim_trailing">11.18. trim/trim-leading/trim-trailing</h3>
<div class="paragraph">
<p>删除前导和/或尾随空格是一项常见任务。 因此 Raku 具有以下函数：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">函数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">trim</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">移除前导和尾部空格</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">trim-leading</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">移除前导空格</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">trim-trailing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">移除尾部空格</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;X&#34; ~ &#34; 123 &#34; ~ &#34;X&#34;;               # -&gt; X 123 X
say &#34;X&#34; ~ &#34; 123 &#34;.trim ~ &#34;X&#34;;          # -&gt; X123X
say &#34;X&#34; ~ &#34; 123 &#34;.trim-trailing ~ &#34;X&#34;; # -&gt; X 123X
say &#34;X&#34; ~ &#34; 123 &#34;.trim-leading ~ &#34;X&#34;;  # -&gt; X123 X</code></pre>
</div>
</div>
<div class="paragraph">
<p>我已将它们用作方法，但它们也可以用作函数。</p>
</div>
<div class="listingblock">
<div class="title">练习 11.3</div>
<div class="content">
<pre>写一个 trim-leading, trim-trailing 和 trim 的正则表达式版本:</pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">正则表达式用法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$y = $x.trim-leading</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$x ~~ /XXXX/; $y = $0.Str;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$y = $x.trim-trailing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$x ~~ /XXXX/; $y = $0.Str;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$y = $x.trim</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$x ~~ /XXXX/; $y = $0.Str;</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_split_和_grep">11.19. split 和 grep</h3>
<div class="paragraph">
<p>请注意，<code>split</code>（请参见第7.3节，“ split”）和 <code>grep</code>（请参见第8.20.1节，&#34;grep&#34;）可以使用正则表达式作为参数（而不是普通字符串）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @words = $text.split(/\s/);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这解决了我们在第 7.3 节 &#34;split&#34; 中指出的多空格问题。</p>
</div>
<div class="paragraph">
<p>任何两位数字，其中第二个是 «2»：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1..100).grep: /^(\d)2$/; # -&gt; (12 22 32 42 52 62 72 82 92)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_注释_2">11.20. 注释</h3>
<div class="paragraph">
<p>我们可以在正则表达式中放置注释。 不建议使用内联注释，因为建议你使用换行符。</p>
</div>
<div class="paragraph">
<p>代替：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;12345&#34; ~~ /(2)(.4)/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>像这样写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;12345&#34; ~~ /(2)  # A literal &#34;2&#34;
            (.4) # Any character followed by a literal &#34;4&#34;
           /;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_模块">12. 模块</h2>
<div class="sectionbody">
<div class="paragraph">
<p>模块是一种有用的封装技术，可以将较大的任务分解为更易于实现的较小部分，从而使整个事情成为可能。</p>
</div>
<div class="paragraph">
<p>如果有人编写了一个模块来满足你的需求或其中的一部分，请使用该模块，而不要自己重新设计轮子。 这样可以节省你的时间和精力。</p>
</div>
<div class="paragraph">
<p>模块的质量和成熟度相差很多，其中一些可能不再维护。 如果有更多选择，使用哪个模块本身就是一本书的主题。 与使用设计不良的模块相比，最好自己编写代码。</p>
</div>
<div class="sect2">
<h3 id="_预编译">12.1. 预编译</h3>
<div class="paragraph">
<p>模块在安装时进行编译。 当程序使用模块时，将加载预编译的版本-这样可以加快程序的编译速度。</p>
</div>
<div class="paragraph">
<p>无法预编译程序，但是你可以将代码（或至少其中的大部分）移至一个或多个模块。 你应该对较大的应用程序执行此操作，但不要因为启动速度有所提高（或多或少是虚构的）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_用_zef_管理模块">12.2. 用 zef 管理模块</h3>
<div class="paragraph">
<p>模块，管理）你需要一个模块管理器来安装，列出，更新和删除模块。 <code>zef</code> 是应该使用的唯一模块管理器。</p>
</div>
<div class="paragraph">
<p>不会维护旧的模块管理器 <code>panda</code>，因此不应使用它。</p>
</div>
<div class="sect3">
<h4 id="_zef_list">12.2.1. zef list</h4>
<div class="paragraph">
<p>使用 <code>zef list --installed</code> 命令获取已安装模块的列表。</p>
</div>
<div class="paragraph">
<p>这是一个非常简短的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ zef list --installed
===&gt; Found via /usr/local/share/perl6/site ①
App::Mi6:ver&lt;0.2.2&gt;:auth&lt;cpan:SKAJI&gt; ②
Bailador:ver&lt;0.0.15&gt;:auth&lt;github:Bailador&gt; ③
Linenoise:ver&lt;0.1.1&gt;:auth&lt;Rob Hoelz&gt; ④
Shell::Command ⑤
p6doc:ver&lt;1.002001&gt; ⑥
zef:ver&lt;0.5.3&gt;:auth&lt;github:ugexe&gt;:api&lt;0&gt; ⑦</code></pre>
</div>
</div>
<div class="paragraph">
<p>① zef告诉我们它在哪里找到模块。
② 具有版本(«ver»)和作者(«auth»)且带有单个冒号前缀的模块。 作者是 CPAN 用户名。
③ 如上所述，但作者是 github 项目名称。
④ 作者为文本字符串。
⑤ 此作者暂无作者或版本。
⑥ 此作者暂无作者。
⑦ 作者是 GitHub 用户名。 注意新标签 «api»。 我们将在&#34;高级 Raku&#34;课程中进行讨论。</p>
</div>
<div class="paragraph">
<p>模块可能具有版本(<code>:ver</code>)和作者(<code>:auth</code>)部分。 这样就可以安装一个模块的多个版本，你可以选择使用哪个（或更多）版本。 （有关详细信息，请参见第12.3节&#34;使用模块(use)&#34;。)</p>
</div>
</div>
<div class="sect3">
<h4 id="_cpan_vs_github">12.2.2. CPAN vs GitHub</h4>
<div class="paragraph">
<p>Raku 模块最初仅在 GitHub 上托管，但在 2018 年添加了对 CPAN(《综合 Perl 存档网络》)的支持。</p>
</div>
<div class="paragraph">
<p>GitHub 是一台服务器，Raku 社区在脱机时遭受了损失。 CPAN 是站点的分布式网络，因此单个服务器上的问题不会影响模块存储库。</p>
</div>
<div class="paragraph">
<p><code>zef</code> 支持 GitHub 和 CPAN。 请注意，模块名称中的 &#34;auth&#34; 字段只是一个文本字段，因此即使 &#34;auth&#34; 字段使用 «github:»，也可以将模块托管在 CPAN 上。</p>
</div>
</div>
<div class="sect3">
<h4 id="_zef_search">12.2.3. zef search</h4>
<div class="paragraph">
<p>使用 <code>zef search</code> 可搜索名称或描述中具有给定字符串的模块。</p>
</div>
<div class="paragraph">
<p>例如。 <code>zef search www</code>：</p>
</div>
<div class="paragraph">
<p>输出相当宽，但这是最后一个：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">只是一个内部计数器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">From</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">来自于哪个仓库</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Zef::Repository::Ecosystems&lt;p6c&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Package</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包(模块)的名字</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">WWW:ver&lt;1.005003&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">短的描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">带有 JSON 解码器的简单的 HTTPS 客户端</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>请注意，可用模块的本地列表将首先更新。 也可以使用 <code>zef update</code> 手动完成此步骤。</p>
</div>
<div class="paragraph">
<p>如果你以 root 用户身份安装了 Raku 和 zef，则可能必须在 zef 命令前加上 sudo 前缀：<code>sudo zef …​</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_zef_install">12.2.4. zef install</h4>
<div class="paragraph">
<p>使用 <code>zef install</code> 来安装模块。 如果测试通过，它将下载指定的模块，运行测试并安装它。 如果模块具有未安装的依赖项（其他模块），则将首先安装它们。</p>
</div>
<div class="paragraph">
<p>例如。 <code>zef install WWW</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ zef install WWW
===&gt; Searching for: WWW</code></pre>
</div>
</div>
<div class="paragraph">
<p>它从更新可用模块的本地列表开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">===&gt; Updating cpan mirror: https://raw.githubusercontent.com/ugexe/Perl6- ecosystems/master/cpan1.json
===&gt; Updating p6c mirror: http://ecosystem-api.p6c.org/projects1.json
===&gt; Updated cpan mirror: https://raw.githubusercontent.com/ugexe/Perl6- ecosystems/master/cpan1.json
===&gt; Updated p6c mirror: http://ecosystem-api.p6c.org/projects1.json</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，它以递归方式检查依赖关系：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">===&gt; Searching for missing dependencies: HTTP::UserAgent, IO::Socket::SSL
===&gt; Searching for missing dependencies: DateTime::Parse, Encode, IO::Capture::Simple, Test::Util::ServerPort, OpenSSL</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，它为两个不遵循规则的模块发出警告：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">===&gt; Extraction: Failed to find a META6.json file for Encode:ver&lt;0.0.2&gt;:auth&lt;github:sergot&gt; -- failure is likely
===&gt; Extraction: Failed to find a META6.json file for IO::Capture::Simple -- failure is likely</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后测试所有模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">===&gt; Testing: DateTime::Parse:ver&lt;0.9.1&gt;
===&gt; Testing [OK] for DateTime::Parse:ver&lt;0.9.1&gt;
===&gt; Testing: Encode:ver&lt;0.0.2&gt;:auth&lt;github:sergot&gt;
===&gt; Testing [OK] for Encode:ver&lt;0.0.2&gt;:auth&lt;github:sergot&gt;
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后安装它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">===&gt; Installing: DateTime::Parse:ver&lt;0.9.1&gt;
===&gt; Installing: Encode:ver&lt;0.0.2&gt;:auth&lt;github:sergot&gt;
===&gt; Installing: OpenSSL:ver&lt;0.1.21&gt;:auth&lt;github:sergot&gt;
===&gt; Installing: IO::Socket::SSL:ver&lt;0.0.1&gt;:auth&lt;github:sergot&gt;
===&gt; Installing: IO::Capture::Simple
===&gt; Installing: Test::Util::ServerPort:ver&lt;0.0.1&gt;:auth&lt;github:jonathanstowe&gt;
===&gt; Installing: HTTP::UserAgent:ver&lt;1.1.46&gt;:auth&lt;github:sergot&gt;
===&gt; Installing: WWW:ver&lt;1.005003&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，某些模块具有许多依赖关系，而这些依赖关系可能具有自己的依赖关系。 如果这些依赖项之一具有不通过的测试，则不会安装任何内容。</p>
</div>
<div class="paragraph">
<p>测试失败并不一定意味着所涉及的模块已损坏，因为Raku一直在不断发展，并且模块作者可能无法跟上所有更改。 但这也可能恰恰意味着该模块已损坏。</p>
</div>
<div class="paragraph">
<p>即使测试失败，也可以强制安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install --force WWW</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，不知道测试为什么失败，这不是一个好主意。</p>
</div>
</div>
<div class="sect3">
<h4 id="_zef_depends">12.2.5. zef depends</h4>
<div class="paragraph">
<p>使用 <code>zef depends</code> 可获取给定模块的依赖项列表。 该列表是递归的，即它遵循依赖关系的依赖关系，依此类推。</p>
</div>
</div>
<div class="sect3">
<h4 id="_zef_upgrade">12.2.6. zef upgrade</h4>
<div class="paragraph">
<p>使用 <code>zef upgrade</code> 可以升级到指定模块的最新版本。 请注意，此功能是 beta。</p>
</div>
<div class="paragraph">
<p>如果不带参数使用，它将尝试升级所有已安装的模块。</p>
</div>
</div>
<div class="sect3">
<h4 id="_zef_uninstall">12.2.7. zef uninstall</h4>
<div class="paragraph">
<p>使用 <code>zef uninstall</code> 来删除已安装的模块。</p>
</div>
<div class="paragraph">
<p>请注意，它只会删除你要的内容。 最初由于以下原因安装的所有模块, 依赖关系不会受到影响。</p>
</div>
</div>
<div class="sect3">
<h4 id="_web_搜索">12.2.8. Web 搜索</h4>
<div class="paragraph">
<p><code>zef search</code> 不是浏览模块的最佳方法。 但是我们可以使用 Raku Modules 网站 <a href="https://modules.raku.org/" class="bare">https://modules.raku.org/</a></p>
</div>
<div class="paragraph">
<p><strong>练习 12.1</strong>
单击某些标签以获得结构感。</p>
</div>
<div class="paragraph">
<p>做一些搜索。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用模块use">12.3. 使用模块(use)</h3>
<div class="paragraph">
<p>我们告诉程序我们将使用带有 <code>use</code> 关键字的模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use DBIish;     # Top level namespace
use My::Module; # Two levels of namespaces</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们未指定版本，则 Raku 将加载最新版本-如果安装了多个版本。 （“最新”的概念仅基于版本号，因此，如果你有两个具有相同名称（由 «auth» 字段区分）的合法模块，则将使用版本号最高的模块。 模块（使用 <code>zef upgrade</code>）可能会更改最新版本。）</p>
</div>
<div class="paragraph">
<p>如果要确保使用模块的特定版本，请按以下方式指定它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use DBIish:ver&lt;0.5.17&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>坚持使用未安装的特定版本将失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">use DBIish:ver&lt;0.5.18&gt;;
Could not find DBIish:ver&lt;0.5.18&gt; at line 1 in:
/home/arne/.perl6
/usr/local/share/perl6/site
/usr/local/share/perl6/vendor
/usr/local/share/perl6
CompUnit::Repository::AbsolutePath«94631019616016»
CompUnit::Repository::NQP«94631041192904»
CompUnit::Repository::Perl5«94631041192864»
in any statement_control at /usr/local/share/nqp/lib/Perl6/Grammar.moarvm line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>这对于显示已安装模块的位置列表很有帮助。</p>
</div>
<div class="paragraph">
<p>«CompUnit::Repository» 主要处理预编译。 有关更多信息，请参见《高级 Raku》课程。</p>
</div>
<div class="paragraph">
<p>你可以检查是否使用 REPL 安装了模块：</p>
</div>
<div class="paragraph">
<p>未安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; use Data::TextOrBinary
Could not find Data::TextOrBinary at line 1 in: ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>安装了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; use WWW
Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>或在命令行上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku -MData::TextOrBinary -e &#34;say &#39;ok&#39;;&#34;
===SORRY!===
Could not find Data::TextOrBinary at line 1 in: ...</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku -MWWW -e &#34;say &#39;ok&#39;;&#34;
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以删除 <code>-e</code> 部分，但是如果安装了模块，它将为你提供REPL模式。 你可以使用以下模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku -MWWW
&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 12.2</strong>
从 CPAN 安装模块 «Math::Trig», 并使用其中的内容编写一个简短的程序。</p>
</div>
</div>
<div class="sect2">
<h3 id="_编写模块">12.4. 编写模块</h3>
<div class="paragraph">
<p>在第 15 章，编写模块中，我们将展示如何在本地放置模块，而无需使用 <code>zef</code> 安装模块。</p>
</div>
<div class="paragraph">
<p>在&#34;高级 Raku&#34; 课程中，我们将展示如何遵循规则编写模块，以便可以将其上传到 CPAN 以供 <code>zef</code> 使用并进行公共安装。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_文件和目录">13. 文件和目录</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_输入输出_io">13.1. 输入输出 - IO</h3>
<div class="paragraph">
<p>在类似 Unix 的系统上，我们具有以下预定义的文件句柄：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">名称</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件句柄</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">STDIN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*IN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标准输入</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">STDOUT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*OUT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标准输出</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">STDERR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*ERR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标准错误</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_note">13.1.1. note</h4>
<div class="paragraph">
<p><code>note</code> 打印到 STDERR（与 <code>$*ERR.say</code> 本质上相同）。 不要在文件句柄上使用它！</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Without \n</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">With \n</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">To</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stringification</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">note</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*ERR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">.gist</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在 REPL 中 <code>note</code> 可能会让你吃惊:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; note False
False
True</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>False</code> 输出已发送到 STDERR。 由于该代码未在 STDOUT 上显示任何内容，因此 REPL 显示了最后一条语句的结果。 <code>note</code> 成功（因为我们尚未关闭 STDERR），并返回 <code>True</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_读取文件">13.2. 读取文件</h3>
<div class="paragraph">
<p>读取文件的正常方法是先打开文件，读取内容，然后关闭文件。 我们当然可以这样做，但是我们不必这样做。</p>
</div>
<div class="sect3">
<h4 id="_io_lines">13.2.1. IO.lines</h4>
<div class="paragraph">
<p>使用文件名上的 <code>IO.lines</code> 来获取内容（作为懒惰的行列表）。</p>
</div>
<div class="paragraph">
<p>读取指定的文件，并显示其中带有 «a» 的行：</p>
</div>
<div class="listingblock">
<div class="title">文件: echo-file-contains</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ($file-name) {
    for $file-name.IO.lines -&gt; $line {
        say $line if $line.contains(&#34;a&#34;);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>读取文件的全部内容后，隐式文件句柄将关闭。 因此，请提防循环过早退出的情况（例如，程序在文件中查找某个字符串，并在找到该字符串时执行 <code>last</code> 操作）。</p>
</div>
<div class="paragraph">
<p>当文件句柄超出范围时，它们将自动关闭，但是在大型程序中，范围的结束可能还有很长的路要走。</p>
</div>
<div class="paragraph">
<p>我们可以使用 <code>grep</code>（并把 <code>conntains</code> 移动到那里）来避免循环：</p>
</div>
<div class="listingblock">
<div class="title">文件: echo-file-contains2</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">sub MAIN ($file-name) {
    .say for $file-name.IO.lines.grep( *.contains(&#34;a&#34;) );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我已经使用循环在显示的每一行之后获取换行符，但是我们也可以通过使用列表上的 <code>join</code> 来避免这种情况：</p>
</div>
<div class="listingblock">
<div class="title">文件: echo-file-contains3</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">sub MAIN ($file-name) {
    $file-name.IO.lines.grep( *.contains(&#34;a&#34;) ).join(&#34;\n&#34;).say;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住，如果第一个参数是 &#34;Whatever Star&#34;，我们可以（实际上必须）忽略 <code>grep</code> 参数中的花括号。</p>
</div>
<div class="paragraph">
<p>我们可以这样写：<code>grep({.contains(&#34;a&#34;)})</code>。</p>
</div>
<div class="paragraph">
<p>花一点时间看一下这三个版本。 其中哪一个最容易理解？ 如果你更喜欢另一个，为什么？</p>
</div>
</div>
<div class="sect3">
<h4 id="_limit">13.2.2. limit</h4>
<div class="paragraph">
<p>如果只对文件的特定部分感兴趣，请指定最大行数，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; $file-name.IO.lines(10);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_io_words">13.2.3. IO.words</h4>
<div class="paragraph">
<p>这与 <code>IO.lines</code> 相同，但是内容一次返回一个单词（而不是一次返回一行）。</p>
</div>
<div class="paragraph">
<p>请注意，如第7.4节&#34;words&#34;中所述，单词可能无法满足你的要求。</p>
</div>
</div>
<div class="sect3">
<h4 id="_lines">13.2.4. lines</h4>
<div class="paragraph">
<p>在上一节中，我们已经使用 <code>lines</code> 作为 <code>IO</code> 对象上的方法，但是我们也可以将 <code>lines</code> 用作没有参数的过程。 这将读取在命令行上指定的文件的内容：</p>
</div>
<div class="listingblock">
<div class="title">文件: echo-all</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for lines;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不需要 <code>MAIN</code>，它将处理尽可能多的文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku echo-all /etc/*</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果一个或多个文件是目录，我们将收到警告：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&#39;NPW18/&#39; is a directory, cannot do &#39;.open&#39; on a directory in block &lt;unit&gt; at echo-all line 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，像这样使用时，我们无法获取文件名，也无法获取一个文件的结尾而下一个文件的开头。 （但请参阅第13.3.3.1节&#34;$*ARGFILES&#34;以获取解决方法。）</p>
</div>
<div class="paragraph">
<p>如果我们在不带参数的情况下调用该程序，它将等待输入，并逐字复制回该程序。 使用 <code>&lt;Control-c&gt;</code> 退出。</p>
</div>
<div class="paragraph">
<p>我们可以根据需要将输入传递给它，这些行是相等的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku echo-all file1.txt file2.txt
$ cat file.txt file2.txt | raku echo-all</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使 <code>echo-file-contains3</code> 程序更短：</p>
</div>
<div class="listingblock">
<div class="title">文件: echo-grep</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">lines.grep( *.contains(&#34;a&#34;) }).say;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用一个 Slurpy 数组来获取文件名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN (*@files) {
    lines.grep({ .contains(&#34;a&#34;) }).say;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们仅为使用情况消息添加了 <code>MAIN</code>。 参数（在 <code>@files</code> 中）将被忽略。</p>
</div>
<div class="paragraph">
<p>请注意，slurpy 参数允许使用零参数，因此该程序的行为与 «echo-grep» 相同。 这意味着将永远不会触发使用消息（因此，使用MAIN是无用的）。</p>
</div>
<div class="paragraph">
<p>有关如何修复它的信息，请参见第10.14节&#34;*(Slurpy运算符)&#34;。</p>
</div>
</div>
<div class="sect3">
<h4 id="_slurp">13.2.5. slurp</h4>
<div class="paragraph">
<p>使用 <code>slurp</code> 一次性读取整个文件:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $content = slurp &#34;/home/raku/bin/echo-file&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 中的所有字符串都使用 Unicode，但是可以使用其他编码读取（和转换）文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $contents = slurp &#34;/home/arne/echo.c&#34;, enc =&gt; &#34;latin1&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关支持的编码的更多信息：<a href="https://docs.raku.org/routine/encoding" class="bare">https://docs.raku.org/routine/encoding</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_openclose">13.2.6. open/close</h4>
<div class="paragraph">
<p>我们可以打开文件（<code>open</code>），对其进行处理，然后再关闭（<code>close</code>）：</p>
</div>
<div class="paragraph">
<p>该程序将读取一个指定为参数的文件，并打印所有包含字母&#34;a&#34;的行：</p>
</div>
<div class="listingblock">
<div class="title">文件: echo-file-MAIN</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">sub MAIN ($file-name) {
    my $fh = open $file-name;
    for $fh.lines -&gt; $line {
        say $line if $line.contains(&#34;a&#34;);
    }
    $fh.close;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>lines</strong></p>
</div>
<div class="paragraph">
<p>我在打开的文件句柄上使用过 <code>lines</code> 来读取内容，一次只能读取一行。</p>
</div>
<div class="paragraph">
<p><strong>练习13.1</strong></p>
</div>
<div class="paragraph">
<p>编写文件转换程序。 输入采用latin1（iso-latin-1），输出采用 Unicode（utf-8）。</p>
</div>
<div class="paragraph">
<p>提示：不要尝试写入文件（因为我们尚未显示如何执行该操作）。 写到屏幕（STDOUT）没问题，我们可以使用shell像这样为我们保存它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku isolatin2unicode isolatinfile &gt; unicodefile</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_写文件">13.3. 写文件</h3>
<div class="paragraph">
<p>如果给定的话，我们可以扩展文件转换程序以写入文件。 与以前一样，程序的第一个参数是要读取的文件名，第二个参数（如果有）是要写入的文件名。</p>
</div>
<div class="paragraph">
<p>如果我们不指定第二个参数，它将像以前一样显示在屏幕上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku isolatin2unicode4 isolatinfile unicodefile
$ raku isolatin2unicode4 isolatinfile &gt; unicodefile</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用文件句柄，以写模式打开文件，然后在文件句柄上使用 <code>say</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $fh = open :w, &#39;/tmp/some-file.txt&#39;;
&gt; $fh.say(&#34;Hello&#34;);
&gt; $fh.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>$fh.say</code> 需要使用括号或冒号语法（例如 <code>$fh.say: &#34;Hello&#34;</code>）。</p>
</div>
<div class="paragraph">
<p>记住副词语法（请参见第10.13.6节&#34;副词&#34;）； <code>:w</code> 与 <code>w ⇒ True</code> 相同。</p>
</div>
<div class="paragraph">
<p>但是，我们将改为使用 <code>spurt</code> 命令。 它与 <code>lines</code> 相反，因为它会将我们提供的所有文本写入指定的文件。</p>
</div>
<div class="paragraph">
<p>当我们创建文件时，文件许可权是从 Unix 之类的系统上的系统 <code>umask</code> 中复制的。 Windows 不支持 <code>umask</code> 值或文件权限。
无法在打开或突然通话中更改模式，但请参阅《高级 Raku》课程中 <code>chmod</code> 的说明部分。</p>
</div>
<div class="sect3">
<h4 id="_spurt">13.3.1. spurt</h4>
<div class="paragraph">
<p>使用 <code>spurt</code> 写入文件，并自动打开和关闭文件句柄。</p>
</div>
<div class="listingblock">
<div class="title">文件: isolatin2unicode4</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN ($file-in, $file-out = &#34;&#34;) {
    $file-out
      ?? spurt $file-out, slurp $file-in, enc =&gt; &#34;latin1&#34;
      !! say slurp $file-in, enc =&gt; &#34;latin1&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以写 <code>$file-out = Nil</code>，但是可以使用空字符串。</p>
</div>
<div class="paragraph">
<p>没有任何类型的错误检查，那么可能会出错吗？</p>
</div>
<div class="paragraph">
<p><strong>spurt overwrite</strong></p>
</div>
<div class="paragraph">
<p>请注意，<code>spurt</code> 会愉快地覆盖现有文件，而不会发出警告。</p>
</div>
<div class="paragraph">
<p>如果文件存在，我们可以指示它失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">spurt $out, :createonly, slurp $in, enc =&gt; &#34;latin1&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你感到困惑，可以添加括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">spurt($out, :createonly, slurp($in, enc =&gt; &#34;latin1&#34;));</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>spurt append</strong></p>
</div>
<div class="paragraph">
<p><code>spurt</code> 还具有追加模式，其中文本被添加到现有文件的末尾：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">spurt $file-out, :append, slurp $file-in, enc =&gt; &#34;latin1&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在写入日志文件时，这很有用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_复习_prompt">13.3.2. 复习 prompt</h4>
<div class="paragraph">
<p><code>prompt</code>，如6.6.1所示，&#34;prompt&#34; 与 <code>$*IN.get</code> 相同，带有可选的文本输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">sub prompt-reimplemented ($message = &#34;&#34;) {
    $*OUT.say $message if $message;
    return $*IN.get;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">文件: prompt</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = prompt &#34;What&#39;s your name? &#34;;
say &#34;Hi, $name! Nice to meet you!&#34;;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_get">13.3.3. get</h4>
<div class="paragraph">
<p><code>get</code> 从指定的文件句柄读取一行。 如果没有更多输入可用，则返回 <code>Nil</code>。</p>
</div>
<div class="paragraph">
<p>从标准输入读取一行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">my $line = $*IN.get;</code></pre>
</div>
</div>
<div class="paragraph">
<p>从文件中读取一行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open &#39;filename&#39;;
my $line = $fh.get;
$fh.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>$*ARGFILES</strong></p>
</div>
<div class="paragraph">
<p>一个单独的 <code>get</code>（在文件句柄上不使用它）的行为就像 <code>lines</code>。</p>
</div>
<div class="paragraph">
<p>它将从命令行中给出的文件中读取，如果没有给出 <code>$*IN</code> 代替。</p>
</div>
<div class="paragraph">
<p>魔术是由 <code>$*ARGFILES</code> 在幕后执行的。</p>
</div>
<div class="paragraph">
<p>我们可以在 <code>$*ARGFILES</code> 上使用 <code>handles</code> 来获取每个参数的文件句柄：</p>
</div>
<div class="listingblock">
<div class="title">文件: argfile-handle</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $_ for $*ARGFILES.handles;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku argfile-handle person args ack6
person -&gt; IO::Handle&lt;&#34;person&#34;.IO&gt;(opened)
args -&gt; IO::Handle&lt;&#34;args&#34;.IO&gt;(opened)
ack6 -&gt; IO::Handle&lt;&#34;ack6&#34;.IO&gt;(opened)</code></pre>
</div>
</div>
<div class="paragraph">
<p>指定不存在的文件会导致程序崩溃：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku argfile-handle person sjsjsjsjsjs
person -&gt; IO::Handle&lt;&#34;person&#34;.IO&gt;(opened)
Failed to open file /home/raku/sjsjsjsjsjs: No such file or directory
  in block &lt;unit&gt; at ./argfile-handle line 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，即使未打开这些句柄，它们也被报告为打开状态（如果我们尝试从中读取）。 如果尝试读取，则会收到错误消息“无法在二进制模式下处理”，这是错误的。</p>
</div>
<div class="paragraph">
<p>实际发生的情况是，在调用 <code>handles</code> 方法时，这些句柄是打开的，但之后它们是关闭的：</p>
</div>
<div class="listingblock">
<div class="title">文件: argfile-handle2</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">my @handles = $*ARGFILES.handles;

for @handles { say $_ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku argfile-handle2 person args ack6
IO::Handle&lt;&#34;person&#34;.IO&gt;(closed)
IO::Handle&lt;&#34;args&#34;.IO&gt;(closed)
IO::Handle&lt;&#34;ack6&#34;.IO&gt;(closed)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 <code>handles</code> 来编写一个 zip 程序，该程序从作为参数给出的每个文件中取一行，然后继续进行直到写完所有内容：</p>
</div>
<div class="listingblock">
<div class="title">文件: zip-merge</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">my @handles = $*ARGFILES.handles;

.open for @handles;

while @handles {
    my $handle = @handles.shift;
    say $handle.get;
    @handles.push($handle) unless $handle.eof;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，我们必须手动打开文件才能正常工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku zip-merge person-say3 repeat repeat2</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序的命名不太精细，可能会帮助你记住 <code>zip</code> 运算符（请参阅《高级 Raku》课程。）</p>
</div>
<div class="paragraph">
<p>我们不能使用它，因为它将在行数最少的文件结束时停止。 但我们可以使用 <code>roundrobin</code> 运算符（我们将在&#34;高级 Raku&#34;课程中介绍）。</p>
</div>
<div class="paragraph">
<p>很难正确地做到这一点，但是这个单行程序有效：</p>
</div>
<div class="listingblock">
<div class="title">文件: roundrobin</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$*ARGFILES.handles.eager».open».lines.&amp;roundrobin.flat.map: *.put</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&gt;&gt;</code> 是超级运算符（我们将在&#34;高级 Raku&#34;课程中介绍）。 它可以并行工作要素。 我会把它留给读者练习，以弄清楚它为什么起作用。</p>
</div>
<div class="paragraph">
<p>（此代码段由 Brad Gilbert 编写。请参见 <a href="https://stackoverflow.com/questions/53639771/perl-6-argfiles-binds-binary-mode" class="bare">https://stackoverflow.com/questions/53639771/perl-6-argfiles-binds-binary-mode</a>）。</p>
</div>
<div class="paragraph">
<p>如果在特殊的 <code>MAIN</code> 函数中使用 <code>$*ARGFILES</code>，它将从 <code>$*IN</code> 读取。 （这适用于版本6.d（及更高版本）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_getc">13.3.4. getc</h4>
<div class="paragraph">
<p>使用 <code>getc</code> 从指定的文件句柄读取单个字符。 如果不带句柄使用，子例程格式默认为 <code>$*ARGFILES</code>，如果在命令行上未指定文件，则该子例程格式再次默认为 STDIN。</p>
</div>
<div class="paragraph">
<p>如果没有更多可用输入，则返回 <code>Nil</code>；如果以二进制模式在文件句柄上使用，则抛出异常。</p>
</div>
<div class="listingblock">
<div class="title">文件: getc</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">my $char;

repeat {
    print &#34;&gt; &#34;; $char = getc;
    say &#34;Character: $char&#34;;
} while $char ne &#34;Q&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它一直循环，直到我们输入&#34;Q&#34;字符为止。</p>
</div>
<div class="paragraph">
<p>运行它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku getc
&gt; asdQw
Character: a
&gt; Character: s
&gt; Character: d
&gt; Character: Q</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于终端设置为&#34;已缓冲&#34;，因此在按回车键之前它不会执行任何操作。 然后它将获取所有字符，在每个字符之后都显示 «&gt;» 提示符，如我们所见。</p>
</div>
<div class="paragraph">
<p>在 Linux 系统上，我们应该能够使用 <code>stdbuf</code> 命令关闭程序的缓冲，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ stdbuf --input=0 raku getc</code></pre>
</div>
</div>
<div class="paragraph">
<p>但这至少在我的计算机上不起作用。</p>
</div>
<div class="paragraph">
<p>Unicode 和组合字符（请参见第7.1.2节&#34;组合字符&#34;）也是一个问题，因为它们位于基础字符之后。 这意味着 <code>getc</code> 将至少等待两个字符，然后再返回第一个字符。 如果第二个不是组合字符，则返回第一个。 如果它是一个组合字符，只要它们都在组合字符中（因为我们可以有很多），<code>getc</code> 将继续读取字符-否则我们将遇到文件结尾。</p>
</div>
</div>
<div class="sect3">
<h4 id="_readchars">13.3.5. readchars</h4>
<div class="paragraph">
<p>使用 <code>readchars</code> 方法从文件句柄中读取最多指定数量的字符（字素）。 如果已在二进制模式下打开文件句柄，它将引发异常。</p>
</div>
<div class="listingblock">
<div class="title">文件: readchars</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">my $file = $*TMPDIR.add(&#39;foo.txt&#39;);

$file.IO.spurt: &#34;This is a test...\n&#34; x 25;

given $file.IO.open {
    say &#34;A:&#34; ~ .readchars: 5; # OUTPUT:
    say &#34;B:&#34; ~ .readchars: 90;
    say &#34;C:&#34; ~ .readchars;
    .close;
    $file.unlink;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们不指定字符数，则使用特定于实现的数字。 Rakudo 使用 <code>$*DEFAULT-READ-ELEMS</code>，即 <code>65536</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_移除文件">13.4. 移除文件</h3>
<div class="paragraph">
<p>到目前为止，我们一直在读写文件。 编写文件通常会创建它们，当然我们也可以删除它们。</p>
</div>
<div class="paragraph">
<p>使用取消链接删除文件，链接或符号链接。 目录只能使用rmdir删除（请参见第13.8.7节&#34;rmdir&#34;）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; unlink(&lt;A B C D&gt;);
&gt; unlink &#34;A&#34;.IO, &#34;B&#34;.IO, &#34;C&#34;.IO, &#34;D&#34;.IO;</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于文件系统的限制，返回列表包括所有文件，但那些文件会引起问题（缺少权限或目录）。</p>
</div>
<div class="paragraph">
<p>作为一种方法，成功时返回 <code>True</code>，否则返回 <code>X::IO::Unlink</code> 失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;A&#34;.IO.unlink;</code></pre>
</div>
</div>
<div class="paragraph">
<p>删除不存在的文件为 <code>True</code>。</p>
</div>
<div class="paragraph">
<p>我们可以通过这种紧凑的方式获取错误消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say .exception.message without &#39;bar&#39;.IO.unlink;
Failed to remove the file [...] illegal operation on a directory</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_临时文件">13.5. 临时文件</h3>
<div class="paragraph">
<p>临时文件应放置在适当的位置，以免混乱具有正常内容的目录。 用于临时文件的目录也可能会不时进行自动清理。</p>
</div>
<div class="paragraph">
<p>使用常规文件操作（创建，写入，读取，删除）。</p>
</div>
<div class="sect3">
<h4 id="_tmpdir">13.5.1. tmpdir</h4>
<div class="paragraph">
<p>使用 <code>$*SPEC.tmpdir</code> 或 <code>$*TMPDIR</code> 动态变量来查找系统临时目录。 如果系统找不到当前目录，它们将默认为当前目录。</p>
</div>
<div class="paragraph">
<p>良好的做法是在以后删除临时文件，但是在清理程序之前可能会发生程序崩溃或过早终止的情况。</p>
</div>
</div>
<div class="sect3">
<h4 id="_filetemp_模块">13.5.2. File::Temp 模块</h4>
<div class="paragraph">
<p>最好使用 «File::Temp» 模块，因为它可以隐藏细节并为你做好簿记和清理工作。 特别是在程序过早终止的情况下删除临时文件。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_文件测试">13.6. 文件测试</h3>
<div class="paragraph">
<p>我们确实应该在程序中添加错误检测（和恢复）。 尝试从不存在的文件中读取将失败，并终止程序。</p>
</div>
<div class="paragraph">
<p>我们可以通过 <code>IO</code> 对象(<code>&#34;file-name&#34;.IO.d</code>)，文件句柄（<code>$fh.d</code>）或使用智能匹配(<code>&#34;file-name&#34;.IO ~~ :d</code>):</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不存在</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Is it a directory?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True/False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fail</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">e</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Does it exists?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True/False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">f</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Is it a file?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True/False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fail</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">l</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Is it a symlink?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True/False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fail</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">r</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Is it readable?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True/False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fail</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Is it readable and writeable?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True/False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fail</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rwx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Is it readable, writeable and executable?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True/False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fail</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">File size (in bytes)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fail</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Is it writeable?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True/False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fail</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Is it executable?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True/False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fail</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">z</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">File size zero?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True/False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fail</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果文件不存在，大多数文件将失败（带有 <code>X::IO::DoesNotExist</code>）。</p>
</div>
<div class="paragraph">
<p>请注意，如果在目录中使用 <code>s</code> 和 <code>z</code>，则结果可能非零，但这取决于操作系统。</p>
</div>
<div class="paragraph">
<p>示例（假设文件存在，并且我们先完成了 <code>my $fh = &#34;/tmp/A&#34;.IO.open</code>）：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IO 方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件句柄方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">智能匹配</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">结果</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#34;/tmp/A&#34;.IO.d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$fh.d (see note)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#34;/tmp/A&#34;.IO ~~ :d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#34;/tmp/A&#34;.IO.e</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$fh.e</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#34;/tmp/A&#34;.IO ~~ :e</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#34;/tmp/A&#34;.IO.f</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$fh.f</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#34;/tmp/A&#34;.IO ~~ :f</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#34;/tmp/A&#34;.IO.s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$fh.s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#34;/tmp/A&#34;.IO ~~ :s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">126976</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>请注意，我们无法打开目录，因此检查文件句柄是否为目录永远无法返回 <code>True</code>。</p>
</div>
<div class="sect3">
<h4 id="_签名中的文件测试">13.6.1. 签名中的文件测试</h4>
<div class="paragraph">
<p>让我们回顾第13.2.1节&#34;IO.lines&#34;中的&#34;echo-file-contains3&#34;。 如果我们指定一个不存在的文件，则会出现运行时错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$raku echo-file-contains3 SSSS
Failed to open file /home/raku/SSSS: No such file or directory ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以添加类型检查和类似的 <code>multi</code> 检查：</p>
</div>
<div class="listingblock">
<div class="title">文件: echo-file-contains4</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">multi sub MAIN ($file-name where $file-name.IO.f) {
    $file-name.IO.lines.grep( *.contains(&#34;a&#34;) ).join(&#34;\n&#34;).say;
}

multi sub MAIN (*@args) {
    say &#34;Oh, no! Please specify one file.&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二个 <code>multi MAIN</code> 捕获了这样的情况：除了一个参数即现有文件以外，我们还指定了其他任何内容。</p>
</div>
<div class="paragraph">
<p>«echo-file-contains3» 给出的错误信息非常好，终止程序可能是正确的选择。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_二进制文件">13.7. 二进制文件</h3>
<div class="paragraph">
<p>换行（请参阅第6.1节，&#34;换行&#34;）和 Unicode 归一化（请参阅第7.1节，&#34;Unicode&#34;）会破坏二进制文件的读取（和写入）。</p>
</div>
<div class="paragraph">
<p>当我们以 Unicode 模式阅读时，该程序将阻塞非法序列。 我们可以通过使用 <code>utf8-c8</code> 编码来避免这种情况，因为它会以不变的方式传递字节。</p>
</div>
<div class="paragraph">
<p>但是二进制文件应该以二进制模式读取：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $buffer = slurp $filename, :bin;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_buf">13.7.1. Buf</h4>
<div class="paragraph">
<p>当我们以二进制模式读取文件时，我们得到一个 <code>Buf</code>（缓冲区）作为回报。</p>
</div>
<div class="paragraph">
<p>我们可以使用 <code>slurp</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">my $buffer = slurp $filename, :bin;
for @$buffer { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者手动打开(<code>open</code>)并读取(<code>read</code>)。</p>
</div>
<div class="paragraph">
<p><strong>read</strong></p>
</div>
<div class="paragraph">
<p><code>read</code> 读取指定的字节数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">if my $fh = open $path, :bin {
    my Buf $buffer = $fh.read( $count );
    my $third_byte = $buffer[2];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>read</code> 也适用于非二进制文件，但是这样做会导致 Unicode 字符分解。</p>
</div>
<div class="paragraph">
<p>十六进制转储文件：</p>
</div>
<div class="listingblock">
<div class="title">文件: file-show</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">constant NL = 9252.chr; # This is the Unicode &#34;N/L&#34; symbol
constant BOX = 9617.chr; # This is a Unicode gray box

sub MAIN ($file where $file.IO.r) {
    my $fh = open $file, :bin;
    while my Buf $buf = $fh.read(10) {
    my $ascii = &#34;&#34;;
    my $elems = @$buf.elems;
    for @$buf -&gt; $byte {
        print $byte.fmt(&#34;%02X &#34;);
        if $byte eq any(10,13) {
            $ascii ~= NL;
        } else {
            $ascii ~= 31 &lt; $byte &lt; 127 ?? $byte.chr !! BOX;
        }
    }

    print &#34; &#34; x 10 - $elems; # Fill the last line
    say &#34;| $ascii&#34;;
    }

    $fh.close;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_blob">13.7.2. Blob</h4>
<div class="paragraph">
<p>二进制数据也可以存储在 <code>Blob</code> 中（《二进制大对象》）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $blob = Blob.new([1, 2, 3]);
Blob:0x&lt;01 02 03&gt;

&gt; my $blob = Blob.new([255, 2, 3]);
Blob:0x&lt;ff 02 03&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>值的范围是 <code>0 ..255</code>。超出该范围的值将被截断（对它们应用 <code>% 256</code>）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $blob = Blob.new([256, 2, -1]);
Blob:0x&lt;00 02 ff&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以重写«file-show»以使用 <code>Blob</code>：</p>
</div>
<div class="paragraph">
<p>更改此行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">while my Buf $buf = $fh.read(10)</code></pre>
</div>
</div>
<div class="paragraph">
<p>为这个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">while my $buf = Blob.new($fh.read(10))</code></pre>
</div>
</div>
<div class="paragraph">
<p>(它可以作为 «file-show-blob» 使用。)</p>
</div>
<div class="paragraph">
<p><code>Blob</code> 是 <code>Buf</code> 的不变版本。</p>
</div>
<div class="paragraph">
<p><strong>练习 13.2</strong></p>
</div>
<div class="paragraph">
<p>编写文件比较程序。 它使用两个文件名，并进行二进制比较。</p>
</div>
<div class="paragraph">
<p>用法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">./file-equal enum-red enum-redX
No such file enum-redX

$ raku file-equal enum-red enum-red
The files are equal

$ raku file-equal enum-red enum-fixed
Files differ (different sizes)

$ raku file-equal hello-usage hello-usage2
Files differ</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_写二进制文件">13.7.3. 写二进制文件</h4>
<div class="paragraph">
<p>使用 <code>Buf</code> 和 <code>write</code> 写二进制文件:</p>
</div>
<div class="listingblock">
<div class="title">文件: write-buf</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">unit sub MAIN ($file-name);

if my $fh = open $file-name, :w, :bin {
    my $buf = Buf.new: 82, 97, 107, 117, 100, 111, 10;
    $fh.write: $buf;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为一个 <code>blob</code>:</p>
</div>
<div class="listingblock">
<div class="title">文件: write-blob</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">unit sub MAIN ($file-name);

if my $fh = open $file-name, :w, :bin {
    my $blob = Blob.new: 82, 97, 107, 117, 100, 111, 10;
    $fh.write: $blob;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一些测试:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku write-buf X1
$ raku write-blob X2
$ raku file-equal X1 X2
The files are equal</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在非二进制文件（文本文件）上使用 <code>write</code>，但是这可能会导致非法的 <code>Unicode</code> 序列。 或是你要使用的任何文本编码中的非法序列。 （请注意，可以使用 Raku 不支持的编码来编写文本文件，但是最好是实现该支持。）</p>
</div>
</div>
<div class="sect3">
<h4 id="_检测二进制文件">13.7.4. 检测二进制文件</h4>
<div class="paragraph">
<p>没有内置的方法来检测文件是否为二进制文件，但是我们可以使用模块 <code>Data::TextOrBinary</code>。</p>
</div>
<div class="paragraph">
<p>安装 <code>Data::TextOrBinary</code> 模块（如果尚未安装）。 （可能是 «sudo zef» 代替，具体取决于你的设置）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">zef install Data::TextOrBinary</code></pre>
</div>
</div>
<div class="paragraph">
<p>另请查看 12.2, &#34;使用 zef 管理模块&#34;。</p>
</div>
<div class="listingblock">
<div class="title">文件: binary</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">use Data::TextOrBinary;

sub MAIN ($file) {
    if $file.IO.d {
        say &#34;Directory.&#34;;
    } elsif $file.IO.e {
        is-text($file.IO)
          ?? say &#34;Text file.&#34;
          !! say &#34;Binary file.&#34;;
    } else {
        say &#34;File doesn&#39;t exist.&#34;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该模块的工作方式是从文件中读取前 4096 个字节，然后查找文本文件中未出现的字符。</p>
</div>
<div class="paragraph">
<p>我们可以使用 «test-bytes» 参数指定要读取的字节数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">my $text = is-text($filename.IO, test-bytes =&gt; 8192);</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关详细信息，请参见 <a href="https://github.com/jnthn/p6-data-textorbinary" class="bare">https://github.com/jnthn/p6-data-textorbinary</a>。</p>
</div>
<div class="paragraph">
<p>使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku binary axxxx
File doesn&#39;t exist.

$ raku binary num-add-err
Text file.

$ raku binary _old/
Directory.

$ raku binary /bin/false
Binary file.</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，如果二进制内容未放在前面，该程序可能会将一些 pdf 文件报告为文本（本书就是其中的一个例子）。 增加测试字节值可以解决此问题。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_目录">13.8. 目录</h3>
<div class="paragraph">
<p>目录是我们存储文件的地方。 和目录。</p>
</div>
<div class="sect3">
<h4 id="_envpath">13.8.1. %*ENV&lt;PATH&gt;</h4>
<div class="paragraph">
<p>最重要的目录是路径，即PATH环境变量，可作为 <code>%*ENV&lt;PATH&gt;</code> 使用。 它是一个字符串，其中包含用冒号分隔的目录列表，shell在其中按指定顺序查找要执行的程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say %*ENV&lt;PATH&gt;;
/home/arne/bin:/home/arne/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin :/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</code></pre>
</div>
</div>
<div class="paragraph">
<p>更好的格式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say %*ENV&lt;PATH&gt;.split(&#34;:&#34;).join(&#34;\n&#34;);
/home/arne/bin
/home/arne/.local/bin
/usr/local/sbin
/usr/local/bin
/usr/sbin
/usr/bin
/sbin
/bin
/usr/games
/usr/local/games
/snap/bin</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dir">13.8.2. dir</h4>
<div class="paragraph">
<p>使用不带参数的 <code>dir</code> 为我们提供当前目录的全部内容（不带特殊目录 «.» 和 «..»），作为 <code>IO</code> 对象的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; dir
(&#34;src&#34;.IO &#34;RakuExplained.html&#34;.IO)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以指定一个目录:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; chdir &#34;/&#34;
&gt; dir &#34;home&#34;
(&#34;home/arne&#34;.IO)

&gt; dir &#34;/home&#34;
(&#34;/home/arne&#34;.IO)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果给出一个相对目录（不是以 «/» 开头），则会得到一个相对于当前目录的列表。</p>
</div>
</div>
<div class="sect3">
<h4 id="_indir">13.8.3. indir</h4>
<div class="paragraph">
<p>使用 <code>indir</code> 命令可以在指定目录中执行代码，并将当前目录设置为该目录。</p>
</div>
<div class="paragraph">
<p>我们可以使用 <code>indir</code> 列出所有可用的程序（在路径中）。 该路径不是递归的，因此将忽略该路径中指定目录内的目录。</p>
</div>
<div class="paragraph">
<p>我们从路径开始，将其（在冒号分隔符上）拆分为每个部分，并在其上进行迭代：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">for %*ENV&lt;PATH&gt;.split(&#34;:&#34;) -&gt; $directory {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在循环内部，我们从跳过不存在的目录开始，因为我们允许路径中有垃圾（实际上通常是）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">next unless $directory.IO.d; # Is this a directory?</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们有一个新循环。 我们在目录（<code>$directory</code>）上使用 <code>indir</code> 并在其中运行 <code>dir</code> 命令（指定为 <code>&amp;dir</code>，一个引用）。 <code>dir</code> 命令为我们提供了该目录中的文件（和目录）列表。 我们添加排序以给出排序列表。 这是区分大小写的类型，但是可以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for indir($directory, &amp;dir).sort -&gt; $file {</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们跳过目录，因为我们只在寻找文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">next if $file.d;</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，如果当前用户可执行文件，则显示文件（具有完整路径）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">  say &#34;$directory/$file&#34; if $file.x;
 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>say</code> 为我们将 <code>IO.Path</code> 对象转换为字符串。</p>
</div>
<div class="paragraph">
<p>整个程序：</p>
</div>
<div class="listingblock">
<div class="title">文件: list-path</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for %*ENV&lt;PATH&gt;.split(&#34;:&#34;) -&gt; $directory {
    next unless $directory.IO.d; # Is this a directory?
    for indir($directory, &amp;dir).sort -&gt; $file {
        next if $file.d;
        say &#34;$directory/$file&#34; if $file.x;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它以查看适合你的程序。</p>
</div>
</div>
<div class="sect3">
<h4 id="_cwd">13.8.4. $*CWD</h4>
<div class="paragraph">
<p>Raku 将当前目录保留在特殊的 <code>$*CWD</code> 变量中。 不建议手动更改它。</p>
</div>
<div class="paragraph">
<p><code>indir</code> 确实确实会自动更改 <code>$*CWD</code> 的值，但是在指定目录中运行命令后，它也会将其更改回原值。</p>
</div>
<div class="paragraph">
<p><strong>练习 13.3</strong></p>
</div>
<div class="paragraph">
<p>Unix 程序 <code>which</code> 为提供了给定程序的完整路径。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ which less
/usr/bin/less

$ which pwd
/bin/pwd</code></pre>
</div>
</div>
<div class="paragraph">
<p>用 Raku 编写该程序（并称其为&#34;which6&#34;）。 使用 «list-path» 作为起点。</p>
</div>
<div class="paragraph">
<p>它应该仅报告第一个匹配。</p>
</div>
<div class="paragraph">
<p><strong>练习 13.4</strong></p>
</div>
<div class="paragraph">
<p>你的路径中有重复的程序（具有相同名称的程序）可能表明存在问题，因为将执行第一个程序（在路径中），而这可能不是你想要的。</p>
</div>
<div class="paragraph">
<p>编写一个遍历路径的程序，报告重复项。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku check-path fido
- /usr/bin/fido
- /opt/bin/gecco/fido false
- /bin/false
- /home/raku/fakebin/false</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 «which6» 作为起始点。</p>
</div>
<div class="paragraph">
<p>请注意，大多数 shell 程序都有几个内置命令，而不是路径中类似的程序。</p>
</div>
<div class="paragraph">
<p><strong>练习 13.5</strong></p>
</div>
<div class="paragraph">
<p>扩展 «check-path»，比较文件以查看它们是否相同。 符号链接，硬链接或精确副本。</p>
</div>
<div class="paragraph">
<p>提示：重用练习13.2中的 «file-equal» 。</p>
</div>
<div class="paragraph">
<p>可以假设我们只有同一程序的两个版本。 但是，如果要允许两个以上的版本，可以只将第二个和第三个与第一个进行比较。</p>
</div>
<div class="paragraph">
<p>样本输出（节略）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku check-path-duplicates
print
- /usr/local/bin/print
- /usr/bin/print - Not equal
touch
- /usr/bin/touch
- /bin/touch - Equal
Found 19 duplicates and 12 different programs.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用_indir_递归">13.8.5. 使用 indir 递归</h4>
<div class="paragraph">
<p>可以谨慎使用 <code>indir</code>。</p>
</div>
<div class="paragraph">
<p>这是一个程序，列出了从当前目录开始的每个可读目录中的每个可读文件，递归地：</p>
</div>
<div class="listingblock">
<div class="title">文件: indir-loop</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">unit sub MAIN; my @dirs = &#34;.&#34;;
while (@dirs) {
    check-dir(@dirs.shift);
}

sub check-dir ($dir) {
    say &#34;Reading dir: $dir&#34;;
    for indir($dir, &amp;dir).sort -&gt; $current {
        next unless $current.IO.r; # Skip files/directories we cannot read
        $current.IO.d
          ?? @dirs.push(&#34;$dir/$current&#34;)
          !! say &#34;File: $dir/$current&#34;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它将对文件（和目录）进行排序，并首先进行宽度处理（在遍历目录之前显示目录中的所有文件）。 我们使用要检查的目录列表来执行此操作，并在遇到新目录时将新目录添加到末尾。</p>
</div>
<div class="paragraph">
<p>我选择将其编程为循环，而不是递归编程，因为我想在目录之前列出文件。</p>
</div>
<div class="paragraph">
<p>这里我们有一个递归版本：</p>
</div>
<div class="listingblock">
<div class="title">文件: indir-recursive</div>
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">unit sub MAIN; check-dir(&#34;.&#34;);
sub check-dir ($dir) {
    say &#34;Reading dir: $dir&#34;;
    for indir($dir, &amp;dir).sort -&gt; $current {
        next unless $current.IO.r; # Skip files/directories we cannot read
        $current.IO.d
          ?? check-dir(&#34;$dir/$current&#34;)
          !! say &#34;File: $dir/$current&#34;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>排序顺序不是很好，但是我们可以通过在目录之前对文件进行排序来解决此问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for indir($dir, &amp;dir).sort({ +$^a.IO.d ~ $^a cmp +$^b.IO.d ~ $^b }) -&gt; $current</code></pre>
</div>
</div>
<div class="paragraph">
<p>排序将 <code>IO.d</code> 应用于文件，并将结果转换为带有 <code>+</code> 前缀的数字（0或1）。 然后，它附加文件名。 结果是所有文件的前缀都为&#34;0&#34;，目录的前缀为&#34;1&#34;。 因此，我们先获取文件（按排序顺序），再获取目录（也按排序顺序）。 输出应与 «indir-loop» 完全相同。</p>
</div>
<div class="paragraph">
<p>整个程序可以作为&#34;indir-recursive2&#34;使用。</p>
</div>
<div class="paragraph">
<p><strong>练习 13.6</strong></p>
</div>
<div class="paragraph">
<p>Unix 程 «grep» 可以用来搜索文件中的字符串，但是命令行参数的语法不是用户友好的。</p>
</div>
<div class="paragraph">
<p>编写&#34;ack&#34;程序是为了使此任务更容易，并且具有适合程序员的功能。 （查找它，因为它确实有用。）</p>
</div>
<div class="paragraph">
<p>编写一个程序&#34;ack6&#34;，从当前目录中递归搜索所有非二进制文件，查找指定的字符串。</p>
</div>
<div class="paragraph">
<p>提示：从 «indir-recursive2» 开始。</p>
</div>
</div>
<div class="sect3">
<h4 id="_mkdir">13.8.6. mkdir</h4>
<div class="paragraph">
<p>使用 <code>mkdir</code> 创建一个目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; mkdir &#34;misc&#34;;
&gt; mkdir &#34;misc&#34;.IO;
&gt; &#34;misc&#34;.IO.mkdir;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它可以采用可选的权限参数（或模式），最好以八进制形式指定，例如 <code>mkdir &#34;misc&#34;, 0o777</code>。 在 Windows 上将忽略此值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; mkdir &#34;misc&#34;, 0o777;
[a]</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，模式值将与系统&#34;umask值&#34;或&#34;mkdir&#34;程序进行&#34;或&#34;运算。 没有办法覆盖它。</p>
</div>
<div class="paragraph">
<p>它也可以创建路径（类似于Unix «mkdir -p» 命令）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; mkdir &#34;a/b/c/d/e&#34;;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rmdir">13.8.7. rmdir</h4>
<div class="paragraph">
<p>使用 <code>rmdir</code> 函数删除一个或多个目录。 它只会删除空目录，并返回实际删除的目录列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; rmdir(&lt;a b c d e&gt;);
[a b]</code></pre>
</div>
</div>
<div class="paragraph">
<p>当用作方法时，如果能够删除目录，它将返回 <code>True</code>；如果无法删除目录，则将抛出 <code>X::IO::Rmdir</code> 异常。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; &#34;a&#34;.IO.rmdir; # -&gt; True
&gt; &#34;c&#34;.IO.rmdir; # -&gt; Failed to remove the directory ...</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_日期和时间">14. 日期和时间</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 对于日期和时间有非常好的内置支持。</p>
</div>
<div class="sect2">
<h3 id="_time">14.1. time</h3>
<div class="paragraph">
<p>使用 <code>time</code> 来获取自从 1970.1.1 以来的秒数(Unix 中的开始时间, 也是为人所知的纪元):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; time; # -&gt; 1542530698</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回的值是一个 Int。</p>
</div>
<div class="paragraph">
<p>这是传统的 Unix 方式，并且已由 POSIX 标准化。</p>
</div>
<div class="paragraph">
<p>与 CPU 周期相比，一秒是很长的时间，因此在计时代码时几乎没有用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_now">14.2. now</h3>
<div class="paragraph">
<p>使用 <code>now</code> 来获取自从 1970.1.1 开始的当前时间的秒数(带小数部分)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; now; # -&gt; Instant:1532015558.371171</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回值是 <code>Instant</code> 类型的对象。</p>
</div>
</div>
<div class="sect2">
<h3 id="_润秒">14.3. 润秒</h3>
<div class="paragraph">
<p>如果你关心润秒，请注意 <code>now</code> 可以处理润秒，而 <code>time</code> 则不然。</p>
</div>
<div class="paragraph">
<p>润秒是不时插入的“额外”的秒数，以纠正偏差。</p>
</div>
<div class="paragraph">
<p>结果是 <code>time</code> 和 <code>now</code> 使用的值之间略有差异。 我们实际上可以显示它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say &#34;{ time } - { now }&#34;;
1542532489 - Instant:1542532526.274499
&gt; say &#34;{ time } - { now.Int }&#34;; 1542532500 - 1542532537</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_instant">14.4. Instant</h3>
<div class="paragraph">
<p>请注意，如果我们想从日期对象中推断出日期等，则必须有一个Instant对象（而不是POSIX时间值）。</p>
</div>
<div class="sect3">
<h4 id="_date">14.4.1. Date</h4>
<div class="paragraph">
<p>使用 <code>Date</code> 方法可从 <code>Instant</code> 获取一个 <code>Date</code> 对象。</p>
</div>
<div class="paragraph">
<p><code>Date</code> 对象将字符串字符串化为具有年，月和日的日期字符串，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; say now.Date;   # -&gt; 2018-11-18
&gt; say Date.today; # -&gt; 2018-11-18</code></pre>
</div>
</div>
<div class="paragraph">
<p>年份使用4位数字，月份和日期分别使用2位数字。
我们可以通过将其指定为字符串，Int数组或命名参数列表来为任何日期创建Date对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $date = Date.new(&#34;2018-10-01&#34;);
&gt; my $date = Date.new(2018, 10, 1);
&gt; my $date = Date.new(year =&gt; 2018, month =&gt; 12, day =&gt; 10);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以对 <code>Date</code> 对象使用很多方法。 这是最有用的（我们从 <code>$d = Date.new(2018,10,1)</code> 开始）：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">结果</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">year</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">年份</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">month</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">月份(1..12)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">day</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">月中的某天</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">is-leap-year</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018 不是闰年</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">day-of-month</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">和 <code>day</code> 一样</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">day-of-week</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">周几(1=周一 .. 7=周日)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">day-of-year</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">274</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一年中的第 274 天</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">days-in-month</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">31</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">月中的天数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">week-number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">40</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">星期数(1..53)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">week-year</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">周号所属的年份（请参阅下面的注释）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">week</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(2018 40)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>week-year</code> 和 <code>week-number</code> 的列表</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">weekday-of-month</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">本月发生这一天的次数（包括这一天）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">yyyy-mm-dd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2019-10-01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与 <code>Str</code> 和 <code>gist</code> 相同</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>TIPS: 跨度为两年的一周属于大部分（或星期四）的一年。 该星期可能属于上一年（一月）或下一年（十二月）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; Date.new(2017,1,1).week;   # -&gt; (2016 52)
&gt; Date.new(2018,12,31).week; # -&gt; (2019 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下方法返回一个新的 <code>Date</code> 对象（我们从 <code>$d = Date.new(2018,10,10)</code> 开始）：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">结果</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">earlier(days ⇒ 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-10-08</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">减去给定的天数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">earlier(week ⇒ 1)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-10-01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">减去给定的星期数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">earlier(month ⇒ 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-08-10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">减去给定的月数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">earlier(year ⇒ 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2016-10-11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">减去给定的年数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">later(days ⇒ 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-10-12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加上给定的天数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">later(week ⇒ 1)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-10-17</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加上给定的星期数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">later(month ⇒ 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-12-10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加上给定的月数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">later(year ⇒ 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2020-10-10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加上给定的年数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">truncated-to(&#39;year&#39;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-01-01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">截取到某年的第一天</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">truncated-to(&#39;month&#39;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-10-01</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">截取到某月的第一天</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">truncated-to(&#39;week&#39;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-01-08</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">截取到某周的第一天</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">succ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-10-11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">下一天</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pred</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-10-09</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">前一天</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>earlier</code> 和 <code>later</code> 的参数可以以单数或复数形式给出：（day 或 days，week 或 weeks，month 或 months，year 或 years）。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>带有参数的方法仅需一个，但是可以将它们堆叠起来：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $date = Date.new(2018,10,10).later(years =&gt; 10).later(days =&gt; 4);</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_练习">练习</h5>
<div class="paragraph">
<p>如果不带参数调用，Unix命令“ cal”显示当前月份。 当前日期突出显示。
将其实现为“ cal6”。 不支持参数，请跳过突出显示。
周日应该是一周的第七天，因此请同时进行修复。</p>
</div>
</div>
<div class="sect4">
<h5 id="_练习_2">练习</h5>
<div class="paragraph">
<p>扩展«cal6»，使其采用月份和年份的可选值。 例如。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku cal6-param --month=2 --year=2020</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_datetime">14.4.2. DateTime</h4>
<div class="paragraph">
<p><code>DateTime</code> 对象具有日期（作为 <code>Date</code> 对象），还具有秒，分钟和小时的字段。 时间在内部以 UTC 格式（以前称为 GMT 或英国标准时间）保存。</p>
</div>
<div class="paragraph">
<p>我们可以使用 <code>DateTime.now</code>-或 <code>Instant</code> 对象（使用 <code>now</code> 函数）获取一个新的 <code>DateTime</code> 对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say DateTime.now; # -&gt; 2018-11-18T23:46:22.609982+01:00
&gt; say now.DateTime; # -&gt; 2018-11-18T22:46:22.609982Z</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们打印这些值，则会得到不同的结果，如上所示。 时间相同，但是显示方式不同。 我们将回到那个（时区）。</p>
</div>
<div class="paragraph">
<p>首先，我们来看一下 <code>DateTime</code> 构造函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> my $date-time = DateTime.new(year   =&gt; 2018,
                              month  =&gt; 10,
                              day    =&gt; 20,
                              hour   =&gt; 16,
                              minute =&gt; 1,
                              second =&gt; 10);

my Date $date = Date.now;
my $date-time2 = DateTime.new($date, hour   =&gt; 16,
                                     minute =&gt; 1,
                                     second =&gt; 10);

my $date-time3 = DateTime.new(now);  # An Instant object
my $date-time4 = DateTime.new(time); # An integer
my $date-time5 = DateTime.new(&#34;2018-11-18T23:46:22.609982+01:00&#34;);
my $date-time6 = DateTime.new(&#34;2018-11-18T22:46:22.609982Z&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，秒是唯一可以包含小数部分的字段。</p>
</div>
<div class="paragraph">
<p>日期部分的格式与 <code>Date</code> 对象的格式相同：«year-month-date»（具有4、2和2位数字）。 然后是时间部分之前的 «T»。 时间部分：«hour:minute:seconds»（带有2、2和2位数字）。 秒也可以是小数部分。 最后一部分是时区。 它可以是表示 UTC 的字母 «Z»（如 «Zulu» 中的字母），也可以是时区的描述，以偏移 «hours:minutes»（2位和2位数字）表示。 时间以当地时区显示，我们可以通过减去此时差来获得 UTC 时间。</p>
</div>
<div class="paragraph">
<p><code>DateTime</code> 对象支持与 <code>Date</code> 对象（第14.4.1节“日期”中的两个表）相同的方法，以及（我们以 <code>DateTime.new(&#34;2018-11-18T23:46:22.609982+01:00&#34;)</code>）：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">结果</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hour</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">22</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小时</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">minute</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">46</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">分钟</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">second</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">22.609982</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">秒数, 如果有小数就带小数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">whole-second</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">22</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">秒数, 截断为整数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">timezone</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3600</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时区, 以秒为单位的 UTC 偏移量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">offset</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3600</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与 <code>timezone</code> 相同</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">offset-in-minutes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时区, 以分钟为单位的 UTC 偏移量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">offset-in-hours</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时区, 以小时为单位的 UTC 偏移量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Str</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-11- 18T23:46:22.609982 +01:00</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为日期和时间的字符串</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">代表时间和日期的 <code>Instant</code> 对象</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">posix</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POSIX 值(自 1970.1.1 以来的秒数)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对象的日期部分。 当心时区</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">utc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DateTime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个新的 <code>DateTime</code> 对象, 时区被设置为 UTC</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">in-timezone</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DateTime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个新的 <code>DateTime</code> 对象, 以指定的时区</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">local</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DateTime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个新的 <code>DateTime</code> 对象, 以本地时区</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>除了对这些的扩展参数支持之外：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">结果</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">earlier(second ⇒ 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-11-18T23:46:20.609982+01:00</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">减去给定的秒数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">earlier(minute ⇒ 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-11-18T23:44:22.609982+01:00</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">减去给定的分钟数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">earlier(hour ⇒ 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-11-18T21:46:22.609982+01:00</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">减去给定的小时数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">later(second ⇒ 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-11-18T23:46:24.609982+01:00</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加上给定的秒数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">later(minute ⇒ 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-11-18T23:48:22.609982+01:00</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加上给定的分钟数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">later(hour ⇒ 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-11-19T01:46:22.609982+01:00</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加上给定的小时数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">truncated-to(&#39;second&#39;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-11-18T23:46:22+01:00</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">截断为整秒数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">truncated-to(&#39;minute&#39;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-11-18T23:46:00+01:00</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">截断为整分钟数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">truncated-to(&#39;hour&#39;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-11-18T23:00:00+01:00</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">截断为整小时数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">truncated-to(&#39;day&#39;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018-11-18T00:00:00+01:00</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">截断为整天数</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>值2只是一个例子。</p>
</div>
<div class="paragraph">
<p>TIPS: 可以以单数形式或复数形式给出 <code>earlier</code> 和 <code>later</code> 的参数：（second 或 seconds，minute 或 minutes，hour 或 hours，day 或 days，week 或 weeks，month 或 months，year 或 years）。</p>
</div>
<div class="paragraph">
<p>我们还有一个 <code>clone</code>，它提供 <code>DateTime</code> 对象的副本，其中包含指定字段的新值（如果有）。 这些字段与 <code>new</code> 调用的字段相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $much-later = DateTime.now.clone(year =&gt; 2045);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_时区">14.4.3. 时区</h4>
<div class="paragraph">
<p>新的构造函数采用可选参数 <code>timezone ⇒ &lt;seconds&gt;</code>，在此我们将时区指定为相对于 UTC（或 GMT）的偏移量（以秒为单位）。 如果未指定，则使用动态变量 <code>$*TZ</code>（«时区»）的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say $*TZ; # -&gt; 3600 (in Oslo, Norway)</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>DateTime.now</code> 为我们添加了时区，但 <code>now.DateTime</code> 没有。</p>
</div>
</div>
<div class="sect3">
<h4 id="_自定义格式化">14.4.4. 自定义格式化</h4>
<div class="paragraph">
<p>当我们使用 <code>DateTime.new</code> 或 <code>DateTime.now</code> 时，我们也可以指定自定义格式器。 它的工作是格式化字符串化的日期和时间：</p>
</div>
<div class="listingblock">
<div class="title">文件：datetime</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub custom-formatter (DateTime $dt) {
    sprintf &#39;%02d.%02d.%04d %02d:%02d:%02d&#39;, $dt.day, $dt.month, $dt.year, $dt.hour, $dt.minute, $dt.whole-second;
}

say DateTime.now;
say DateTime.now(formatter =&gt; &amp;custom-formatter);
say DateTime.now(formatter =&gt; &amp;custom-formatter).later(year =&gt; 1);</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它表明自定义格式化程序被新对象继承：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku datetime
2018-11-20T12:18:36.963003+01:00
20.11.2018 12:18:36
20.11.2019 12:18:36</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_从_posix_到_instant">14.4.5. 从 POSIX 到 Instant</h4>
<div class="paragraph">
<p>我们可以从 POSIX 值转换为 Instant：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $intant = Instant.from-posix: $posix-time;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们本可以在 «time-leap» 中使用这一事实：</p>
</div>
<div class="listingblock">
<div class="title">文件: time-leap2</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $time = time;
my $now = Instant.from-posix: $time;
say &#34;Number of leap seconds added after 1.1.1970: &#34; ~ $now.Int - $time;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们得到与本章前面相同的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku text/code/time-leap2
Number of leap seconds added after 1.1.1970: 37</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_计时器">14.5. 计时器</h3>
<div class="paragraph">
<p>我们可以计算执行一个程序或其一部分所花费的时间。</p>
</div>
<div class="sect3">
<h4 id="_给程序计时">14.5.1. 给程序计时</h4>
<div class="paragraph">
<p>在类似 Unix 的系统上，我们可以使用 «time» 程序来查看运行一个程序需要多长时间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ time raku random-prime 10 7
  real    0m0,138s
  user    0m0,164s
  sys     0m0,031s
$ time raku random-prime 10000 8089
  real    0m1,419s
  user    0m1,458s
  sys     0m0,024s</code></pre>
</div>
</div>
<div class="paragraph">
<p>(«real»值是实际时间，«user» 是编译器使用的时间的一部分，«sys» 是系统调用（在操作系统中）使用的时间。)</p>
</div>
<div class="paragraph">
<p>TIPS: 第10.14.2节“重访了随机素数”中介绍了 «random-prime» 程序。 重要的一点是，你提供的数字越大，完成所需的时间就越长。</p>
</div>
<div class="paragraph">
<p>注意，我们为所有时间计时。 raku 的启动，读取源文件（和任何模块），编译程序并最终执行它。</p>
</div>
<div class="paragraph">
<p>每次运行该程序时，实际值都会有所不同，这取决于同时进行的操作。 另一台计算机可以提供完全不同的值，因此进行比较时要小心。</p>
</div>
<div class="paragraph">
<p>当我们要比较事物时，此方法不是很有用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_给代码计时">14.5.2. 给代码计时</h4>
<div class="paragraph">
<p>我们可以在编译器自身内部给执行代码计时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $start = now;
# do-something;
say &#34;Time used: { $start - now }&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们只想给单个块计时, 我们可以将其写为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># do-something;
say &#34;Time used: { now - INIT now }&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>INIT</code> 是程序执行相位器（或块），在程序编译之后和执行之前执行。</p>
</div>
<div class="paragraph">
<p>我们可以使用相位器在不同时间自动执行代码。 有很多。 有关详细信息，请参见 <a href="https://docs.raku.org/language/phasers。" class="bare">https://docs.raku.org/language/phasers。</a></p>
</div>
<div class="paragraph">
<p>与使用 «time» 时一样，由于运行时间会有所不同，因此代码应定时计时几次。 实际值不是很有用，但是可以将它们与其他值进行比较-并用于比较不同的实现。
我们可以实现它的功能：</p>
</div>
<div class="listingblock">
<div class="title">文件: time-me(部分)</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub time-me (&amp;code, $iterations = 100) {
    my @time;

    for ^$iterations {
        my $start = now;
        &amp;code();
        my $stop = now; @time.push($stop - $start);
    }

    return @time.sum / @time.elems;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后进行一些测试，在其中增加一个匿名状态变量（我们将在第16.6.2节“ $ / @ /％（匿名状态变量）中进行描述）。它们在调用之间保留其值，在此代码中基本上用作计数器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub a {
    $++ for 10000;
}

sub b {
    ++$ for 10000;
}

say &#34;a: &#34; ~ time-me(&amp;a, 10000);
say &#34;b: &#34; ~ time-me(&amp;b, 10000);</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; $raku time-me
a:4.481019762283224e-05
b:4.395750332005312e-05</code></pre>
</div>
</div>
<div class="paragraph">
<p>科学记法很难阅读，尤其是难以比较。 因此，我们添加了一个可选的乘数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub time-me (&amp;code, $iterations = 100, $multiplier = 1)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">return $multiplier * @time.sum / @time.elems;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;a:&#34; ~ time-me(&amp;a, 10000, 1000);
say &#34;b:&#34; ~ time-me(&amp;b, 10000, 1000);</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它会提供更好的（人类可读的）值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku time-me
a:0.044137168141592915
b:0.04315050652893645</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们有了一个非常基本的计时框架。 我们可以将其变成一个模块，而且确实可以。 在第15章中，编写模块。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_编写模块_2">15. 编写模块</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们在第14.5.2节&#34;计时代码&#34;中建立了一个非常基本的计时框架。 我们可以将其转换为一个模块，但是由于已经有两个模块可以执行此操作，因此可以重新设计轮子：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Test::Performance</p>
</li>
<li>
<p>Benchmark</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但是我们还是会做…​</p>
</div>
<div class="sect2">
<h3 id="_unit_模块">15.1. unit 模块</h3>
<div class="paragraph">
<p>指定模块的通常方法是使用 <code>module</code> 关键字后跟一个块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">module xxxx {
    # Code here;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是我们可以通过使用 <code>unit module</code> 来节省一个块级别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module xxxx;
# Code here;</code></pre>
</div>
</div>
<div class="paragraph">
<p>就像我们指定一个 <code>procedure</code>（请参见10.9.1，&#34;unit procedure&#34;）或一个类（请参见17.12.2，&#34;unit class&#34;）一样。</p>
</div>
</div>
<div class="sect2">
<h3 id="_is_exportt">15.2. is exportt</h3>
<div class="paragraph">
<p>我们必须在签名后标记要导出的可用于外部使用的过程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub time-me (&amp;code, :$iterations = 100, :$multiplier = 1) is export { ... }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pm6">15.3. pm6</h3>
<div class="paragraph">
<p>Raku 模块的文件名扩展名为 &#34;pm6&#34;（如 «Perl Module 6» 中一样。重命名为 Raku 的语言将影响此扩展名和其他文件扩展名。）请注意，过去也使用了 «pm»。 较旧的模块可能仍会这样做。 建议仅使用《 pm6》，因为如果有人试图使用 Perl 5 中的模块，则会给出更好的错误消息。</p>
</div>
<div class="listingblock">
<div class="title">文件: lib/Time-Code.pm6</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.c;

unit module Time-Code;

sub time-me (&amp;code, :$iterations = 100, :$multiplier = 1) is export {

    my @time;
    for ^$iterations {
        my $start = now;
        &amp;code();
        my $stop = now; @time.push($stop - $start);
    }

    return $multiplier * @time.sum / @time.elems;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_use_lib">15.4. use lib</h3>
<div class="paragraph">
<p>使用 <code>use lib</code> 可以指定编译器应在其中查找模块的其他位置。</p>
</div>
<div class="paragraph">
<p>正常（建议）使用例如 在开发模块时 <code>use lib &#34;lib&#34;</code>，因为这样可以更轻松地进行动态测试。 （我们稍后将讨论的测试框架将使用此技术，因为 <code>zef</code> 在安装模块之前会运行测试（否则不会找到模块）。</p>
</div>
<div class="paragraph">
<p>你必须从 «lib» 所在的目录中运行该程序，此程序才能起作用。</p>
</div>
<div class="paragraph">
<p>请注意，如果从另一个位置也有 «lib» 目录的位置运行程序，则可能是一个安全问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ pwd # -&gt; /home/raku
$ raku code/chapter12/check-path</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 «check-path» 程序具有 <code>use lib &#34;lib&#34;</code> 语句，它将告诉编译器查看 «/home/raku/lib» 目录（而不是 «/home/raku/code/chapter12»）。</p>
</div>
<div class="paragraph">
<p>以及使用它的程序（同样来自第14.5.2节&#34;计时代码&#34;）。</p>
</div>
<div class="listingblock">
<div class="title">文件: time-me-module</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use lib &#34;lib&#34;;
use Time-Code;

sub a {
    $++ for 10000;
}

sub b {
    ++$ for 10000;
}

my $iterations = 1000;
my $multiplier = 1000;

say &#34;a: &#34; ~ time-me(&amp;a, :$iterations, :$multiplier);
say &#34;b: &#34; ~ time-me(&amp;b, :$iterations, :$multiplier);</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它，以及没有模块的旧版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku time-me-module
a: 0.04731108696221918
b: 0.04730277517929529

$raku time-me
a: 0.04462623946451714
b: 0.0447062423500612</code></pre>
</div>
</div>
<div class="paragraph">
<p>计时框架的模块版本稍慢一些（约5％）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_斐波纳契记时">15.5. 斐波纳契记时</h3>
<div class="paragraph">
<p>我们可以对斐波那契数列程序（请参见10.12.2，“斐波那契数列”）和序列（请参见16.3.1，“斐波那契数列”）进行计时。</p>
</div>
<div class="listingblock">
<div class="title">文件: fibonacci-time</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use lib &#34;lib&#34;;
use Time-Code;

my $fibonacci := (1, 1, { $^a + $^b } ... Inf);

sub MAIN (Int $n, :$iterations = 100, :$multiplier = 1) {
    say &#34;Fib     $n: &#34; ~ time-me({ &amp;fibonacci($n) }, :$iterations, :$multiplier);
    say &#34;Fib Rec $n: &#34; ~ time-me({ &amp;fibonacci-recursive($n) }, :$iterations, :$multiplier);
    say &#34;Fib Mul $n: &#34; ~ time-me({ &amp;fibonacci-multi($n) }, :$iterations, :$multiplier);
    say &#34;Fib Seq $n: &#34; ~ time-me({ $fibonacci[$n] }, :$iterations, :$multiplier);
}

sub fibonacci (Int $n) {
    return 1 if $n == 1 or $n == 2;

    my @fib = (1, 1);

    for 2 .. $n -1 -&gt; $i {
        @fib[$i] = @fib[$i -1] + @fib[$i -2]
    }

    return @fib.tail;
}

sub fibonacci-recursive (Int $n) {
    return 1 if $n == 1 or $n == 2;
    return fibonacci-recursive($n-1) + fibonacci-recursive($n-2)
}

multi fibonacci-multi (1) { 1 }
multi fibonacci-multi (2) { 1 }
multi fibonacci-multi (Int $n where $n &gt; 2) {
    fibonacci-multi($n - 2) + fibonacci-multi($n - 1)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku fibonacci-time --mul=1000 12
Fib     12: 0.17109426818938775
Fib Rec 12: 0.28062656376560663
Fib Mul 12: 4.763127095776541
Fib Seq 12: 0.05405135328930629</code></pre>
</div>
</div>
<div class="paragraph">
<p>计算第十二个斐波那契数与循环和递归几乎需要相同的时间。 <code>multi</code> 版本速度较慢。</p>
</div>
<div class="paragraph">
<p>而且，相比起来 Sequence 很快。（但问题是，我们将计时运行了 100 次，最后 99 次是我们从序列中检索了一个缓存的值。）</p>
</div>
<div class="paragraph">
<p>我们可以运行一次代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku fibonacci-time --mul=1000 --iter=1 12
Fib     12: 1.686145939074689
Fib Rec 12: 0.8542231594091491
Fib Mul 12: 8.122685764523933
Fib Seq 12: 1.4559518704264895</code></pre>
</div>
</div>
<div class="paragraph">
<p>不要相信这些数字（递归版本突然比循环版本快），因为我们只运行了一次代码。 但是 Sequence 版本的计时更为现实。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku fibonacci-time --mul=1000 20
Fib     20: 0.19579672840493245
Fib Rec 20: 7.5705065387054296
Fib Mul 20: 220.8083508932559
Fib Seq 20: 0.06156730344760013</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们计算第 20 个数字时，递归版本的速度会大大降低，而 <code>multi</code> 版本的速度甚至会更慢。</p>
</div>
<div class="sect3">
<h4 id="_练习_3">15.5.1. 练习</h4>
<div class="paragraph">
<p>为什么递归版本比循环版本慢？</p>
</div>
<div class="paragraph">
<p>TIPS: 请注意，计时模块不会返回或显示我们正在计时的过程中返回的值。 因此，也要正常运行代码，以确保返回的值正确（或者至少我们对所有它们都得到相同的错误-因此它们同样是错误的）。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_字典">15.6. 字典</h3>
<div class="paragraph">
<p>在本节中，你将需要一个合法单词词典。 Ubuntu Linux 具有以下词典：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>/usr/share/dict/american-english (the «wamerican» package)</p>
</li>
<li>
<p>/usr/share/dict/british-english (the «wenglish» package)</p>
</li>
<li>
<p>/usr/share/dict/ngerman (the «wngerman» package)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>英文字典中有诸如“安倍”之类的条目，我们会忽略它们，因为它们包含非单词字符。</p>
</div>
<div class="paragraph">
<p>如果你没有安装词典文件，请找到并下载。 它必须是一个文本文件，每行一个单词。 只要你熟悉所选的语言，选择哪种语言都没关系。</p>
</div>
<div class="sect3">
<h4 id="_练习_4">15.6.1. 练习</h4>
<div class="paragraph">
<p>编写一个模块 «Dictionary»，该模块将加载指定的词典文件（具有完整路径），并返回所有单词的哈希值。</p>
</div>
<div class="paragraph">
<p>编写简短的测试程序。</p>
</div>
<div class="paragraph">
<p>«回文词是单词，数字，短语或其他字符序列，它们向前或向后读取相同，例如，madam，racecar 或数字 10801。”（来源：https://en.wikipedia.org/wiki/Palindrome）</p>
</div>
</div>
<div class="sect3">
<h4 id="_练习_5">15.6.2. 练习</h4>
<div class="paragraph">
<p>使用 «Dictionary» 模块编写一个程序，该程序可以在字典中打印回文。</p>
</div>
</div>
<div class="sect3">
<h4 id="_练习_6">15.6.3. 练习</h4>
<div class="paragraph">
<p>使用 «Dictionary» 模块编写程序，该程序检查字典中每个单词的反向版本是否也是有效单词。</p>
</div>
<div class="paragraph">
<p>«字谜是通过重新排列不同单词或短语的字母而形成的单词或短语，通常只使用所有原始字母一次。 例如，可以将 anagram 单词重新排列为 &#34;nag a ram&#34;，或者将 &#34;binary&#34; 单词重新排列为 &#34;brainy&#34;。»（来源：https://en.wikipedia.org/wiki/Anagram）</p>
</div>
</div>
<div class="sect3">
<h4 id="_练习_7">15.6.4. 练习</h4>
<div class="paragraph">
<p>使用 «Dictionary» 模块编写程序，该程序检查指定为程序参数的单词的字谜。</p>
</div>
</div>
<div class="sect3">
<h4 id="_练习_8">15.6.5. 练习</h4>
<div class="paragraph">
<p>很容易重写字谜检查程序来检查字典中的所有单词，而不是单个单词作为参数。</p>
</div>
<div class="paragraph">
<p>这是一个好主意吗？</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_范围和序列">16. 范围和序列</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果尚未阅读 Ranges 的介绍，请参见第4.2节&#34;Ranges（简短介绍）&#34;。</p>
</div>
<div class="paragraph">
<p>范围是相当有限的，但是序列（几乎）没有任何限制。</p>
</div>
<div class="sect2">
<h3 id="_范围">16.1. 范围</h3>
<div class="paragraph">
<p>范围运算符 <code>..</code> 给出了一系列连续递增的整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1 .. 5).WHAT; # -&gt; (Range)
&gt; say (1 .. 5);      # -&gt; 1..5</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lazy">16.2. lazy</h3>
<div class="paragraph">
<p>值通常在定义它们时计算。 Raku 将其称为&#34;急迫的&#34;，并添加了第二种类型，称为&#34;懒惰的&#34;。</p>
</div>
<div class="paragraph">
<p>惰性数据结构由某种类型的值组成，但是只有在实际需要它们时（如在访问中一样），才计算各个值。</p>
</div>
<div class="paragraph">
<p>范围（以及稍后将介绍的序列）是惰性的，因此只有在实际需要它们时才计算值。</p>
</div>
<div class="paragraph">
<p>这样就可以拥有无限（或无限）的范围：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1 .. Inf).WHAT;  # -&gt; (Range)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_is_lazy">16.2.1. is-lazy</h4>
<div class="paragraph">
<p>如果不确定某个值，变量或数据结构是惰性的还是急切的，请使用 <code>is-lazy</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1 .. Inf).is-lazy; # -&gt; True
&gt; say &#34;A String&#34;.is-lazy; # -&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们将范围分配给数组，则将对其进行计算：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @range = 1 .. 10;  # -&gt; [1 2 3 4 5 6 7 8 9 10]
&gt; say @range.is-lazy;   # -&gt; False
&gt; say @range.WHAT;      # &gt; (Array)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以尝试无限范围：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @range = 1 .. Inf; # -&gt; [...]
&gt; say @range.WHAT;      # -&gt; (Array)
&gt; say @range.is-lazy;   # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>这给出了一个惰性列表。 仅当它不急切时才是默认值。</p>
</div>
<div class="paragraph">
<p>也可以使用 <code>lazy</code> 关键字强制表达式是惰性的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_lazy_2">16.2.2. lazy</h4>
<div class="paragraph">
<p>使用 <code>lazy</code> 关键字强制表达式为惰性的。</p>
</div>
<div class="paragraph">
<p>它几乎可以用于任何事物，但是循环是最有用的构造。</p>
</div>
<div class="listingblock">
<div class="title">文件: lazy</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $numbers := lazy for ^Inf { $_ };

say $numbers[0];
say $numbers[10];

.say for $numbers;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这给了我们无限循环。 通常，计数器变量（从 <code>0</code> 到 <code>Inf</code>）在 <code>$_</code> 中可用。 块中的最后一个表达式是惰性列表中的值。</p>
</div>
<div class="paragraph">
<p>如果我们在块内执行某些操作，例如 例如：{ &#34;dummy$<em>&#34; } 或 <code>{ pi * $</code></em><code> - e }</code>。</p>
</div>
<div class="paragraph">
<div class="title">TIP</div>
<p>TIPS: 查看 lazy vs gather/take 获取更复杂的例子。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infinite">16.2.3. infinite</h4>
<div class="paragraph">
<p>我们可以使用 <code>infinite</code> 来检查 <code>Range</code> 是否是无限的，或者将开始和/或结束声明为无限（使用 <code>Inf</code>，<code>*</code> 或 <code>∞</code>）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1 .. Inf).infinite; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，我们不能在 <code>@array</code> 上使用 <code>infinite</code>，因为在赋值时它会被强制转换为列表。</p>
</div>
</div>
<div class="sect3">
<h4 id="_列表强制转换">16.2.4. 列表强制转换</h4>
<div class="paragraph">
<p>我们可以把范围强制转换为列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1 .. Inf).WHAT;         # -&gt; (Range)
&gt; say (1 .. Inf).List.WHAT;    # -&gt; (List)
&gt; say (1 .. Inf).List.is-lazy; # -&gt; True
&gt; say (1 .. 100).is-lazy;      # -&gt; False
&gt; say (1 .. 100).List.is-lazy; # -&gt; False</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_eager">16.2.5. eager</h4>
<div class="paragraph">
<p>使用 <code>eager</code> 强制计算范围（或序列或惰性列表）中的值。 它将返回值作为列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1 .. Inf).eager</code></pre>
</div>
</div>
<div class="paragraph">
<p>这有效（或挂起，具体取决于你的观点）。 该表达式将永远运行，没有任何可见的结果。
 
练习16.1如果我们坐下来等待无限个列表崩溃，首先发生的事情是：
- 内存不足（数组中的元素过多）？
- 值对于整数来说太大吗？</p>
</div>
</div>
<div class="sect3">
<h4 id="_is_int">16.2.6. is-int</h4>
<div class="paragraph">
<p>使用 <code>is-int</code>（仅适用于 <code>Range</code>！）告诉我们 <code>Range</code> 是否仅包含整数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1 .. 10).is-int;    # -&gt; True
&gt; say (&#39;A&#39; .. &#39;Z&#39;).is-int; # -&gt; False</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_字符串中的范围">16.2.7. 字符串中的范围</h4>
<div class="paragraph">
<p>这有效:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; .print for (&#34;a&#34; .. &#34;z&#34;); say &#34;&#34;; # Add a newline at the end.
abcdefghijklmnopqrstuvwxyz</code></pre>
</div>
</div>
<div class="paragraph">
<p>或字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (&#34;aa&#34; .. &#34;bb&#34;).WHAT;  # -&gt; (Range)
&gt; say (&#34;aa&#34; .. &#34;bb&#34;).eager; # -&gt; (aa ab ba bb)</code></pre>
</div>
</div>
<div class="paragraph">
<p>你期望的是  &#34;aa&#34; .. &#34;az&#34;, &#34;ba&#34;, &#34;bb&#34; 吗?</p>
</div>
<div class="paragraph">
<p>范围运算符现在不再需要字母。 一切都是 Unicode 字符，因此它将完全满足你的要求。 （它迭代第一个字符直到到达目标，然后在第二个字符中执行相同的操作，依此类推。）</p>
</div>
<div class="paragraph">
<p>请注意，Raku 关于如何从 &#34;aa&#34; 到 &#34;bb&#34; 进行计数的想法可能不适合你的需求。</p>
</div>
</div>
<div class="sect3">
<h4 id="_minmax_2">16.2.8. minmax</h4>
<div class="paragraph">
<p>也可以使用 «minmax» 运算符构造一个范围。</p>
</div>
<div class="paragraph">
<p>它采用两个值，并返回从值的最低到最高的范围，而不管给定的顺序如何：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># numeric comparison
10 minmax 3; # 3..10

# string comparison
&#39;10&#39; minmax &#39;3&#39;; # &#34;10&#34;..&#34;3&#34;
&#39;z&#39; minmax &#39;k&#39;; # &#34;k&#34;..&#34;z&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>顺序由 «cmp» 运算符确定。</p>
</div>
<div class="paragraph">
<p>如果最小值和最大值一致，则运算符将返回由相同值构成的范围：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1 minmax 1; # 1..1</code></pre>
</div>
</div>
<div class="paragraph">
<p>当应用于列表时，minmax 运算符将计算所有可用值中的最低和最高值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(10,20,30) minmax (0,11,22,33);     # 0..33
(&#39;a&#39;,&#39;b&#39;,&#39;z&#39;) minmax (&#39;c&#39;,&#39;d&#39;,&#39;w&#39;); # &#34;a&#34;..&#34;z&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，当应用于哈希时，它会按照 <code>cmp</code> 方式比较：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %winner = points =&gt; 30, misses =&gt; 10;
my %loser = points =&gt; 20, misses =&gt; 10;
%winner cmp %loser;      # More
%winner minmax %loser;
# ${:misses(10), :points(20)}..${:misses(10), :points(30)}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_序列">16.3. 序列</h3>
<div class="paragraph">
<p>序列是用 <code>…​</code> 生成的，而不是用 <code>..</code> 生成范围的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1 .. Inf).WHAT;   # -&gt; (Range)
&gt; say (1 .. Inf)[^10];   # -&gt; (1 2 3 4 5 6 7 8 9 10)

&gt; say (1 ... Inf).WHAT;  # -&gt; (Seq)
&gt; say (1 ... Inf)[^10];  # -&gt; (1 2 3 4 5 6 7 8 9 10)</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以在 Raku 中构造的每个范围也可以按顺序排列，但不能相反。</p>
</div>
<div class="paragraph">
<p>序列（和范围）是惰性的。 仅在需要时才计算这些值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1..10).WHAT;         # -&gt; (Range)
&gt; say (1..10).reverse;      # -&gt; (10 9 8 7 6 5 4 3 2 1)
&gt; say (1..10).reverse.WHAT; # -&gt; (Seq)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 可以为我们生成序列：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1, {$_ * 2} ... *)[^10]; # -&gt; (1 2 4 8 16 32 64 128 256 512)
&gt; (2, {$_ - 2} ... *)[^10]; # -&gt; (2 0 -2 -4 -6 -8 -10 -12 -14 -16)</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者我们可以给它足够的值来理解模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1, 2, 4 ... Inf)[^10]; # -&gt; (1 2 4 8 16 32 64 128 256 512)
&gt; (2, 4 ... Inf)[^10];    # -&gt; (2 4 6 8 10 12 14 16 18)
&gt; (2, 0 ... -Inf)[^10];   # -&gt; (2 0 -2 -4 -6 -8 -10 -12 -14 -16)
&gt; (1 ... -10)[^10];       # -&gt; (1 0 -1 -2 -3 -4 -5 -6 -7 -8)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_斐波那契数列">16.3.1. 斐波那契数列</h4>
<div class="paragraph">
<p>我们可以使用相当高级的规则来生成值。</p>
</div>
<div class="paragraph">
<p>还记得斐波那契数字（来自第10.12.2节“斐波那契数字”）吗？ 在这里，它们是一个序列：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1, 1, * + * ... *)[^10];           # -&gt; (1 1 2 3 5 8 13 21 34 55)
&gt; say (1, 1, { $^a + $^b } ... Inf)[^10]; # -&gt; (1 1 2 3 5 8 13 21 34 55)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>* + *</code> 部分表示使用两个占位符值计算第三个值并将它们相加。 占位符位于当前值的左侧，因此在这种情况下，第一个和第二个值（这就是为什么必须明确指定它们的原因）。 <code>…​ *</code> 部分表示这将永远持续下去（这与Inf相同）。</p>
</div>
<div class="paragraph">
<p>第二个示例使用显式的占位符变量，在这里我们几乎可以对值进行任何处理。</p>
</div>
</div>
<div class="sect3">
<h4 id="_绑定_vs_赋值">16.3.2. 绑定 vs 赋值</h4>
<div class="paragraph">
<p>在序列上推荐使用绑定 <code>:=</code> 而不是通常的赋值(<code>=</code>)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $fibonacci := 0, 1, * + * ... *;
&gt; say $fibonacci.is-lazy; # -&gt; True
&gt; say $fibonacci[10];     # -&gt; 55</code></pre>
</div>
</div>
<div class="paragraph">
<p>斐波那契数列可以从 1 开始（直到现在为止一样），也可以从 0 开始。数学家不同意正确的答案。 1 是最常用的起始值。</p>
</div>
<div class="paragraph">
<p>绑定仅适用于标量。 如果希望变量看起来像数组，请使用赋值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @fibonacci = 0, 1, * + * ... *;
&gt; @fibonacci.is-lazy
True

&gt; @fibonacci[10]
55</code></pre>
</div>
</div>
<div class="paragraph">
<p>绑定在惰性数据结构（作为序列）上效果更好，因为赋值可能会导致对数据结构进行计算（或者可以说是“非惰性化”）。</p>
</div>
<div class="paragraph">
<p>如果你想知道。 这是合法的（但不是个好主意）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $a = (1..10)
1..10

&gt; $a[8]
9</code></pre>
</div>
</div>
<div class="paragraph">
<p>该列表（在这种情况下为范围）将是只读的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_lazy_3">16.3.3. lazy</h4>
<div class="paragraph">
<p>使用 <code>lazy</code> 强制范围（或序列）尽可能地保持惰性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my @range = (1 .. 10);
(1 2 3 4 5 6 7 8 9 10)

&gt; my @range = (1 .. 10).lazy;
[...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，赋值给数组会导致对范围进行计算。 将其分配给标量可以避免这种情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $range = (1 .. 10);
1..10

&gt; $range.WHAT;
(Range)</code></pre>
</div>
</div>
<div class="paragraph">
<p>总结：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Eager 数据类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lazy 数据类型</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">my @x = (1 .. 10)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">my @x = (1 .. 10)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">my $x = (1 .. 10)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">my $x = (1 .. 10)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">my $x := (1 .. 10)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">my $x := (1 …​ 10)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>无限范围和顺序总是很懒。 因此，如果我们将 <code>Inf</code> 更改为 10，则所有内容最终都会出现在“惰性数据类型”列中。</p>
</div>
</div>
<div class="sect3">
<h4 id="_内存友好">16.3.4. 内存友好</h4>
<div class="paragraph">
<p>无限范围和序列的内存占用量很低，因为它只会根据需要生成值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; say (1..Inf)[10] # Parens required, as «Inf[10]» isn&#39;t a thing.
9</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在惰性范围（或列表或序列）上进行 <code>pick</code> 会强制对其进行计算。 如果它是无限的，则将不起作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; (1 .. Inf).pick; # -&gt; Nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>运气不好！</p>
</div>
</div>
<div class="sect3">
<h4 id="_flip_flop_序列">16.3.5. Flip-Flop 序列</h4>
<div class="paragraph">
<p>是否可以制作触发器序列？ 每次我们问某件事时，会改变主意的事情吗？</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Raku 有一个名为 <code>ff</code> 的触发器运算符和一个名为 <code>fff</code> 的变体。 它们将在&#34;高级 Raku&#34;课程中介绍。 它们的含义与我们在此描述的含义不同。
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $flip-flop := (True, False, !* ... *);

&gt; (True, False, !* ... *)[^10]
(True False True False True False True False True False)</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者这个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $flip-flop := (True, {! $_ } ... *);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个序列永远不会达到无限（或者说：“永不尝试达到无限”），但是生成器甚至可以这样工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $i = 0;
&gt; say &#34;I like potatos: &#34; ~ $flip-flop[$i++] for ^10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们不能对序列使用 shift，而只能迭代：</p>
</div>
<div class="listingblock">
<div class="title">文件: flip-flop-sequence</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $flip-flop := (True, False, !* ... *);

say &#34;I like potatos: $_.&#34; for $flip-flop</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; raku flip-flop-sequence I like potatos: True.
I like potatos: False.
I like potatos: True.
I like potatos: False.

...</code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序将永远运行。 使用&lt;Control-c&gt;停止它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_列表重复运算符和序列">16.3.6. 列表重复运算符和序列</h4>
<div class="paragraph">
<p>像这样使用时，我们可以使用列表重复运算符 <code>xx</code> 获得相同的序列（请参见第8.19节&#34;`xx`（列表重复运算符）&#34;）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; my $flip-flop = |(True, False) xx *

&gt; $flip-flop.WHAT
(Seq)

&gt; $flip-flop.is-lazy
True</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>|</code> 在将列表弄平之前，它是必不可少的，因为否则我们将获得具有 <code>(True, False)</code> 的无限子列表。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_state">16.4. state</h3>
<div class="paragraph">
<p>用 <code>state</code> 声明状态变量（而不是普通的 <code>my</code>）。</p>
</div>
<div class="paragraph">
<p>仅在程序第一次进入 <code>state</code> 行时才进行初始化，并且此行将被忽略之后，使其保持旧值。</p>
</div>
<div class="paragraph">
<p>我们可以使用状态变量实现 Flip.Flop，并将所有内容包装在过程中。</p>
</div>
<div class="paragraph">
<p>我们可以通过跟踪索引的过程来访问 Flip.Flop 序列。 状态变量的初始化仅完成一次，它将在两次调用之间保留该值：</p>
</div>
<div class="listingblock">
<div class="title">文件: flip-flop-sequence-wrapped</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $flip-flop := (True, False, !* ... *);

sub flip-flop {
    state $index = 0; # Only executed once!
    return $flip-flop[$index++];
}

say flip-flop for ^10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们完全不需要序列：</p>
</div>
<div class="listingblock">
<div class="title">文件: flip-flop-procedure</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub flip-flop {
    state $state = False; # Only executed once!
    $state = ! $state;
    return $state;
}

say flip-flop for ^10;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_truly_随机_flip_flop">16.5. Truly 随机 Flip-Flop</h3>
<div class="paragraph">
<p>«flip-flop» 的第一个版本是可以预见的，因为它总是以 <code>True</code> 开头。</p>
</div>
<div class="paragraph">
<p>很容易解决这个问题，因此，如果第一个值为 <code>True</code> 或 <code>False</code>，则它是完全随机的：</p>
</div>
<div class="listingblock">
<div class="title">文件: flip-flop-procedure2</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub flip-flop {
    state $state = (True, False).pick; # Only executed once!
    $state = ! $state;
    return $state;
}

say flip-flop for ^10;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_flip_flop_问题">16.6. flip-flop 问题</h3>
<div class="paragraph">
<p>如果在一个上下文中使用，«flip-flop» 的行为将符合预期。 相反的例子：</p>
</div>
<div class="listingblock">
<div class="title">文件: flip-flop-problems</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub flip-flop {
    state $state = (True, False).pick; # Only executed once!
    $state = ! $state;
    return $state;
}

sub free-lunch {
    say &#34;I&#39;m { flip-flop() ?? &#34;for&#34; !! &#34;against&#34; } free lunches&#34;;
}

sub free-dinner {
    say &#34;I&#39;m { flip-flop() ?? &#34;for&#34; !! &#34;against&#34; } free dinners&#34;;
}

for ^5 {
    free-dinner;
    free-lunch;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">I&#39;m against free dinners
I&#39;m for free lunches
I&#39;m against free dinners
I&#39;m for free lunches
I&#39;m against free dinners
I&#39;m for free lunches
I&#39;m against free dinners
I&#39;m for free lunches
I&#39;m against free dinners
I&#39;m for free lunches</code></pre>
</div>
</div>
<div class="paragraph">
<p>该计划根本不会改变位置，但是反对免费晚餐，并且始终免费午餐。</p>
</div>
<div class="paragraph">
<p>有什么建议吗？</p>
</div>
<div class="sect3">
<h4 id="_flip_flop_重新设计">16.6.1. Flip-Flop 重新设计</h4>
<div class="paragraph">
<p>需要进行彻底的重新设计。</p>
</div>
<div class="paragraph">
<p>显而易见的方法是创建一个类，并使用该类的实例（对象）。 我们将在下一章中说明。</p>
</div>
<div class="paragraph">
<p>（我们尚未完成范围。）</p>
</div>
</div>
<div class="sect3">
<h4 id="_匿名状态变量">16.6.2. $/@/% (匿名状态变量)</h4>
<div class="paragraph">
<p>可以使用匿名状态变量 <code>$</code> 代替显式 <code>state $xxxx</code>（请参见第16.4节“状态”），但是（显然）只能有一个。</p>
</div>
<div class="listingblock">
<div class="title">文件: state</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub something {
    my $ = 0; # Only executed once!
    return $++;
}

say something for ^10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序将在各自的行上打印数字 0 至 9。</p>
</div>
<div class="paragraph">
<p>如果我们对零作为初始值感到满意，则实际上可以跳过声明。 使用时，匿名状态变量将神奇地弹出。</p>
</div>
<div class="listingblock">
<div class="title">文件: state2</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub something {
    return $++;
}

say something for ^10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>数组 <code>@</code> 和哈希 <code>%</code> 版本也可用。 因此，在某种程度上，你可以根据需要拥有多个变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; %&lt;name&gt; = 12;
&gt; %&lt;city&gt; = &#34;Oslo&#34;;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这看起来类似于匹配项（请参见第11.9.1节&#34;()(捕获)&#34;），在这里我们可以使用 <code>$[0]</code> 获得第一个匹配项。 但是匿名状态数组中的第一个值是 <code>@[0]</code>。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gathertake">16.7. gather/take</h3>
<div class="paragraph">
<p>让我们看看制作序列的另一种方法 <code>gather</code> 与 <code>take</code>。</p>
</div>
<div class="paragraph">
<p><code>gather</code> 以一个块作为参数，并收集（或“gather”）使用 <code>take</code> 指定的值。
.文件: gather1</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = gather  {
    take 1; take 5; take 42;
}

say @a;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku gather1
[1 5 42]</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，所有值都是一次计算的。 我们可以这样做，但结果相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 5, 43;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们需要一个惰性序列，可以通过绑定到标量来完成：
.文件: gather2</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a := gather {
    take 1 while 1;
}

say &#34;1: $a[1]&#34;;
say &#34;40: $a[40]&#34;;
say &#34;4: $a[4]&#34;;

my $count = 0;
for $a -&gt; $item {
    last if $count++ &gt;= 10;
    say $item;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku gather2
1: 1
40: 1
4: 1
1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤</code></pre>
</div>
</div>
<div class="paragraph">
<p>循环之前的三个 <code>say</code> 语句将其用作惰性列表，并根据需要将其扩展。</p>
</div>
<div class="paragraph">
<p>另一方面，循环产生一个序列，一旦消耗掉这些值就将其忘记（循环进入下一个迭代）。 因此，循环之后，<code>$a</code> 用尽，如果尝试访问它，它将失败。</p>
</div>
<div class="paragraph">
<p>我们可以删除花括号（如果需要），因为在该块中只有一个表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a := gather take 1 while 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>将序列赋值给数组不是一个好主意，因为它将尝试计算无限序列。 该代码将永远运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = gather take 1 while 1;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">文件 : flip-flop-sequence</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $flip-flop := (True, False, !* ... *);

say &#34;I like potatos: $_.&#34; for $flip-flop</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里使用 gather/take
.文件 flip-flop-gather</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $flip-flop := gather loop { take True; take False; }

say &#34;I like potatos: $_.&#34; for $flip-flop;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以改用状态变量：</p>
</div>
<div class="listingblock">
<div class="title">文件: flip-flop-gather2</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $flip-flop := gather loop { state $state = False;
                               $state = ! $state;
                               take $state;
                             }

say &#34;I like potatos: $_.&#34; for $flip-flop</code></pre>
</div>
</div>
<div class="paragraph">
<p>循环仍然存在，因此此版本可提供更多代码，而没有任何明显的好处。 但是我们也可以在此处添加随机起始值：</p>
</div>
<div class="listingblock">
<div class="title">文件: flip-flop-gather3</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $flip-flop := gather loop { state $state = (True, False).pick;
                               $state = ! $state;
                               take $state;
                             }

say &#34;I like potatos: $_.&#34; for $flip-flop</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是我们之前没有显示的序列。 因此，让我们尝试按顺序进行操作。</p>
</div>
<div class="paragraph">
<p>我们可以缩短定义（在 «flip-flop-sequence» 中）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $flip-flop := (True, False, !* ... *); # Old
my $flip-flop := (True, !* ... *);        # New</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，我们将第一个值随机化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $flip-flop := ( (True, False).pick, !* ... *);</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如这个无限循环所示：</p>
</div>
<div class="listingblock">
<div class="title">文件: flip-flop-sequence2</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $flip-flop := ( (True, False).pick, !* ... *);

say &#34;I like potatos: $_.&#34; for $flip-flop</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_lazy_vs_gathertake">16.7.1. lazy vs gather/take</h4>
<div class="paragraph">
<p>注意，如果代码只有一个 <code>take</code>，则可以使用 <code>lazy</code>（请参见16.2，“惰性”）代替 <code>gather/take</code>。</p>
</div>
<div class="paragraph">
<p><code>lazy</code> 版的 flop-gather2 看起来像这样</p>
</div>
<div class="listingblock">
<div class="title">文件: flip-flop-lzay</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $flip-flop := lazy loop {
    state $state = False;
    $state = ! $state;
}

say &#34;I like potatos: $_.&#34; for $flip-flop;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这还是原始的，以方便比较：</p>
</div>
<div class="listingblock">
<div class="title">文件: flip-flop-gather2</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $flip-flop := gather loop { state $state = False;
                               $state = ! $state;
                               take $state;
                             }

say &#34;I like potatos: $_.&#34; for $flip-flop</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_一副牌">16.7.2. 一副牌</h4>
<div class="paragraph">
<p>一副纸牌由 52 张纸牌组成，分别是黑桃，梅花，红桃和方块四种类型的各 13 张（值 1 至 13）。</p>
</div>
<div class="paragraph">
<p>Unicode 具有以下类型的字符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;♠ ♣ ♠ ♦&gt; -&gt; $type # spade, club, heart, diamond</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是它们很难打印，因此我们会坚持使用名称的首字母。</p>
</div>
<div class="listingblock">
<div class="title">文件: deck</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @deck;

for &lt;S C H D&gt; -&gt; $type # Spade, Club, Heart, Diamond {
    @deck.push(&#34;$type$_&#34;) for 1 .. 13;
}

say @deck.join(&#34;,&#34;);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku deck
S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,S11,S12,S13,C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,
H1,H2,H3,H4,H5,H6,H7,H8,H9,H10,H11,H12,H13,D1,D2,D3,D4,D5,D6,D7,D8,D9,D10,D11,D12,D13</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 16.2</strong>
使用 <code>map</code> 而不是两个循环重写 «deck» 程序。</p>
</div>
<div class="paragraph">
<p><strong>练习 16.3</strong>
使用 <code>gather/take</code> 重写  «deck» 程序。</p>
</div>
<div class="paragraph">
<p>一副纸牌如果排序就没什么用了。 我们可以使用 <code>pick(*)</code> 来洗牌（以随机顺序返回值）：
.文件: deck-random</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @deck;

for &lt;S C H D&gt; -&gt; $type # Spade, Club, Heart, Diamond {
    @deck.push(&#34;$type$_&#34;) for 1 .. 13;
}

say @deck.pick(*).join(&#34;,&#34;);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku deck-random C6,S4,S6,H6,S1,C12,D8,C7,C8,S2,S5,C5,D13,H3,S7,S3,S11,H8,C4,H11,D9,D4,C10,D10,H9,D5,D3 ,H12,C11,D11,H7,D12,D6,S13,H4,C9,C2,S8,D2,D7,H10,C3,D1,S10,S9,H1,H2,H13,H5,C1,S12,C13

$ raku deck-random S6,H7,S5,D8,S1,H12,C1,H13,C13,C11,S10,C5,H8,D5,H10,D3,H2,S4,H11,C6,C3,D1,D12,D11,D2,S7 ,H5,D13,D9,S11,C12,C7,H4,S8,H1,D6,H3,C9,D7,D10,H9,S3,S9,H6,C10,S13,D4,S2,C4,S12,C2,C8</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
请注意，使用 <code>pick</code>（请参见8.22.2，&#34;pick&#34;）从我们的牌组中选择一张牌不是一个好主意，因为它会将牌留在牌组中。 （以便我们稍后可以再次绘制它们。）
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用循环(<code>for @deck ..</code> 或在其上使用 <code>shift</code>)。</p>
</div>
<div class="paragraph">
<p>另一种方法是使用 <code>grab</code>，这将在《高级 Raku》课程中进行介绍。</p>
</div>
</div>
<div class="sect3">
<h4 id="_take_rw">16.7.3. take-rw</h4>
<div class="paragraph">
<p>使用 <code>take-rw</code> 将给定项目返回到封闭的 <code>gather</code> 块，而无需引入新的容器。 它绑定到原始数组中的位置，并且可以更改：</p>
</div>
<div class="listingblock">
<div class="title">文件: flip-flip</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @flip-flop = |(True, False) xx 8; say @flip-flop;

sub flipflop (@list) {
    gather for @list
    {
        take-rw $_;
    }
}

for flipflop(@flip-flop) {
    $_ = True if $_ == False;
}

say @flip-flop;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$raku flip-flip
[True False True False True False True False True False True False True False True False]
[True True True True True True True True True True True True True True True True]</code></pre>
</div>
</div>
<div class="paragraph">
<p>小心使用。 如果我们给它一个列表，它将失败（带有“不能为一个不可变的值分配”错误消息），因为我们不能更改不可变的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for flipflop((True, False, True, False)) {
    $_ = True if $_ == False;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_闭包">16.8. 闭包</h3>
<div class="paragraph">
<p>我们在一个块中定义一个词法变量（一个my变量）。 该变量通常在块结束时会消失，但是窍门是我们在引用的过程中使用它（也超出了范围）。 此引用存储在此块外部。</p>
</div>
<div class="paragraph">
<p>有关详细信息，请参见 <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming）。" class="bare">https://en.wikipedia.org/wiki/Closure_(computer_programming）。</a></p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在本书的前面，我们使用术语“关闭”来表示字符串中大括号内的文本。 那是一个 Raku 的名字，有点不幸。 但是另一方面，它是一种闭包，因为它会评估其中的表达式并将其返回到闭包死亡后继续存在的外部。
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="_flip_flop">16.8.1. Flip-Flop</h4>
<div class="paragraph">
<p>在讨论类之前，我们将讨论闭包（在下一章中）。
.文件: flip-flop-closure</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub gen-flip-flop {
    my $state = Bool.pick;

    sub flip-flop {
        $state = ! $state; return ! $state;
    }

    return &amp;flip-flop; 4
}

my $lunch = gen-flip-flop;
my $dinner = gen-flip-flop;
say &#34;Lunch: &#34; ~ $lunch();
say &#34;Dinner: &#34; ~ $dinner();
say &#34;Dinner: &#34; ~ $dinner();
say &#34;Lunch: &#34; ~ $lunch();
say &#34;Lunch: &#34; ~ $lunch();</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们建立了一个外部程序。
我们放置状态变量（现在是通常的 <code>my</code>-variable）
及其内部的触发器程序。
此外部过程返回指向内部过程的指针（使用 <code>&amp;</code> 前缀）。
然后，我们设置了生成器的两个实例。 变量包含指向过程的指针。
使用parens语法调用过程。…​</p>
</div>
<div class="paragraph">
<p><strong>练习 16.4</strong>
是否可以和/或明智地使用 <code>take-rw</code>（请参见第16.7.3节&#34;take-rw&#34;）来生成闭包？</p>
</div>
</div>
<div class="sect3">
<h4 id="_可选的开始值">16.8.2. 可选的开始值</h4>
<div class="paragraph">
<p>初始值是完全随机的。 我们可以对其进行修改以采用可选的起始值：
.文件: flip-flop-closure2 (diff)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub gen-flip-flop (Bool $state is copy = Bool.pick)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $dinner = gen-flip-flop(True);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_闭包_vs_类">16.8.3. 闭包 vs 类</h4>
<div class="paragraph">
<p>每个闭包都可以由一个类替换，因此可以随意使用类。</p>
</div>
<div class="paragraph">
<p>但是事实却并非如此。 类比闭包可以做的更多。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_类">17. 类</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们使用 <code>class</code> 关键字定义类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Person {
    # 把内容放到这里
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_has">17.1. has</h3>
<div class="paragraph">
<p>类变量是使用 <code>has</code> 关键字来声明的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Person {
    has Bool $.is-taxpayer;
    has Bool $!is-happy;
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_私有属性">17.1.1. !(私有属性)</h4>
<div class="paragraph">
<p>符号(<code>$</code>)和名称(在本例中为 <code>is-taxpayer</code>)之间的感叹号(<code>!</code>)表示属性(变量)是私有的，不能在类外部访问。</p>
</div>
<div class="paragraph">
<p>(实际上，我们可以为其他类提供显式访问；请参见第 17.13.1 节&#34;trusts&#34;。)</p>
</div>
</div>
<div class="sect3">
<h4 id="_公共属性">17.1.2. .(公共属性)</h4>
<div class="paragraph">
<p>使用点(<code>.</code>)而不是感叹号(<code>!</code>)使属性(变量)公开。</p>
</div>
<div class="paragraph">
<p>Flip-Flop 作为一个类实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Flip-Flop {
    has Bool $!state = Bool.pick;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_new">17.2. new</h3>
<div class="paragraph">
<p>我们需要两个 flip-flop 实例，并使用每个类支持的内置 <code>new</code> 方法来获取它们。 我们忽略了给类变量赋值，它将默认为 <code>True</code> 或 <code>False</code> 的随机值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Flip-Flop {
    has Bool $!state = Bool.pick;
}

my $lunch  = Flip-Flop.new();
my $dinner = Flip-Flop.new();</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_存根类">17.2.1. 存根类</h4>
<div class="paragraph">
<p>我们必须声明一个类，然后才能使用（或引用）它。 如果我们希望类之间互相引用，那将是一个问题。</p>
</div>
<div class="paragraph">
<p>一种解决方案是前向类声明(也称为«存根类», 因为我们使用的是 10.12.1 &#34;存根运算符&#34;)。 看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Parent { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要我们在使用类之前指定了类的内容，就可以使用存根类。</p>
</div>
<div class="paragraph">
<p>另一个解决方案是确保我们以正确的顺序指定它们，以便在我们声明它们之前不引用它们。</p>
</div>
<div class="paragraph">
<p>当我们具有相互依赖性（或循环数据结构）时，必须使用存根类：</p>
</div>
<div class="listingblock">
<div class="title">文件: stubbed-class</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Parent { ... }

class Child  { has Parent $.parent; }

class Parent { has Child $.child;   }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_method">17.3. method</h3>
<div class="paragraph">
<p>我们需要一种提供状态并翻转存储值的方法。 我称它为 «flip-flop»：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Flip-Flop {
    has Bool $!state = Bool.pick;

    method flip-flop {
        $!state = ! $!state;
        return $!state;
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_方法调用">17.3.1. .(方法调用)</h4>
<div class="paragraph">
<p>然后，我们将不得不重写 «free-lunch» 和 «free-dinner» 程序。</p>
</div>
<div class="paragraph">
<p>我们使用 <code>.</code> 以及在对象(<code>$lunch</code>)上的方法名称(<code>.flip-flop</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub free-lunch {
    say &#34;I&#39;m  { $lunch.flip-flop ?? &#34;for&#34; !! &#34;against&#34; } free lunches&#34;;
}

sub free-dinner {
    say &#34;I&#39;m { $dinner.flip-flop ?? &#34;for&#34; !! &#34;against&#34; } free dinners&#34;;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">free-lunch;  # True
free-dinner; #        True
free-dinner; #        False
free-dinner; #        True
free-lunch;  # False
free-lunch;  # True
free-dinner; #        False
free-lunch;  # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>我已将结果添加为注释，以表明程序可以按预期工作。</p>
</div>
<div class="paragraph">
<p>完整程序如下：</p>
</div>
<div class="listingblock">
<div class="title">文件: flip-flop-class</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Flip-Flop {
    has Bool $!state = Bool.pick;

    method flip-flop {
        $!state = ! $!state;
        return  $!state;
    }
}

my $lunch = Flip-Flop.new();
my $dinner = Flip-Flop.new();

sub free-lunch {
    say &#34;I&#39;m { $lunch.flip-flop ?? &#34;for&#34; !! &#34;against&#34; } free lunches&#34;;
}

sub free-dinner {
    say &#34;I&#39;m { $dinner.flip-flop ?? &#34;for&#34; !! &#34;against&#34; } free dinners&#34;;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">free-lunch;  # True
free-dinner; #        True
free-dinner; #        False
free-dinner; #        True
free-lunch;  # False
free-lunch;  # True
free-dinner; #        False
free-lunch;  # False</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_冒号语法">17.3.2. 冒号语法</h4>
<div class="paragraph">
<p>还有一种用于调用方法的冒号语法，使它们看起来像过程调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$lunch.flip-flop;
flip-flop($lunch:); # The same</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果方法接收参数，则只需添加它们即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$obj.method(1);
method($obj:, 1); # The same</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_命名参数_2">17.4. 命名参数</h3>
<div class="paragraph">
<p>默认构造函数(<code>new</code> 方法)仅支持命名参数。 因此，如果要覆盖随机初始值，则必须这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $lunch = Flip-Flop.new(state =&gt; False);
my $dinner = Flip-Flop.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>但这是行不通的。 初始值仍然是随机的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_公开的类变量">17.5. 公开的类变量</h3>
<div class="paragraph">
<p>内置的默认构造函数仅适用于公共变量，因此我们必须将变量从私有更改为公开：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">has Bool $.state = Bool.pick; # public</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，公共变量对公众可见（类外部的程序代码）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $lunch.state;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，这通常不是一个好主意。</p>
</div>
<div class="paragraph">
<p>我们可以读取公共对象变量，但是不能更改它们。</p>
</div>
<div class="sect3">
<h4 id="_is_rw_3">17.5.1. is rw</h4>
<div class="paragraph">
<p>我们可以允许使用 <code>is rw</code>（读写）trait 来更改公共变量，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">has Bool $.state is rw = Bool.pick;</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于我们而言，这将是一个坏主意。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_self">17.6. self</h3>
<div class="paragraph">
<p>如果你需要访问方法中的当前对象，请使用 <code>self</code>。</p>
</div>
<div class="paragraph">
<p>有关示例，请参见下一部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="_自定义_new">17.7. 自定义 «new»</h3>
<div class="paragraph">
<p>如果我们可以从外部访问对象变量是一个问题，请将它们设为私有并编写一个自定义的 <code>new</code> 构造函数：</p>
</div>
<div class="listingblock">
<div class="title">文件: flip-flop-class-new (partially)</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Flip-Flop {
    has Bool $!state;

    method new (:$start = Bool.pick) {
        self.bless(state =&gt; :$start);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我已将变量更改为私有，并将默认值移至 <code>new</code> 方法，以便它可以处理和不使用参数。</p>
</div>
<div class="paragraph">
<p>我还将构造函数中使用的名称从 «state» 更改为 «start»，因为从用户角度来看，这是一个更好的名称。 在类内部，«state» 很有意义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $lunch = Flip-Flop.new(start =&gt; False);
my $dinner = Flip-Flop.new;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_bless">17.7.1. bless</h4>
<div class="paragraph">
<p><code>bless</code> 是低级对象构造函数。 它创建一个与请求者相同类型的新对象（给与 <code>self</code>），并填充命名的参数。</p>
</div>
<div class="paragraph">
<p>这对于自定义构造函数很有用（作为上一节中的 <code>new</code> 方法）。 但是自定义 <code>Build</code> 方法（请参阅下一节）通常更好。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_自定义_build">17.8. 自定义 BUILD</h3>
<div class="paragraph">
<p>我们可以尝试使用 <code>BUILD</code> 代替，默认情况下调用 <code>new</code>：</p>
</div>
<div class="listingblock">
<div class="title">文件: flip-flop-class-BUILD (partially)</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Flip-Flop {
    has Bool $!state;
    submethod BUILD (:$!state = Bool.pick) { }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>BUILD</code> 也必须处理缺少的值，因此我们将默认初始化移到那里。 <code>BUILD</code> 没有正文，因为具有相同名称的变量会自动映射。 因为我一直保持名字状态。</p>
</div>
<div class="paragraph">
<p><code>submethod</code> 是一种 <code>method</code>，但子类不会继承它。 有关更多信息，请参见 17.14.3，&#34;submethod&#34; 和 17.14, &#34;继承&#34;部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="_错误的起始值">17.9. 错误的起始值</h3>
<div class="paragraph">
<p>«flip-flop» 方法翻转值，然后返回。 结果是我们获得的第一个值与我们指定为起始值的相反。</p>
</div>
<div class="paragraph">
<p>正常的解决方案是在更改值之前保存该值，但是由于我们有一个布尔值，所以我们可以避免反转（翻转）返回的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method flip-flop {
    $!state = ! $!state;
    return ! $!state;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>很多感叹号!</p>
</div>
<div class="paragraph">
<p>完整程序：</p>
</div>
<div class="listingblock">
<div class="title">文件: flip-flop-class-new2</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Flip-Flop {
    has Bool $!state;

    method flip-flop {
        $!state = ! $!state;
        return ! $!state;
    }

    method new (:$start = Bool.pick) {
        self.bless(state =&gt; $start);
    }
}

my $lunch = Flip-Flop.new(start =&gt; False);
my $dinner = Flip-Flop.new;

sub free-lunch {
    say &#34;I&#39;m { $lunch.flip-flop ?? &#34;for&#34; !! &#34;against&#34; } free lunches&#34;;
}

sub free-dinner {
    say &#34;I&#39;m { $dinner.flip-flop ?? &#34;for&#34; !! &#34;against&#34; } free dinners&#34;;
}

free-lunch;
free-dinner;
free-dinner;
free-dinner;
free-lunch;
free-lunch;
free-lunch;
free-dinner;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_对象比较">17.10. 对象比较</h3>
<div class="paragraph">
<p>如果我们比较两个对象，我们在比较什么？
.文件: flip-flop-test (partial)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $lunch = Flip-Flop.new(start =&gt; False);
my $dinner = Flip-Flop.new(start =&gt; False);

say $dinner eq $lunch; # -&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p>答案：我们检查它们是否是同一对象。 在这种情况下，显然不是。</p>
</div>
<div class="sect3">
<h4 id="_eqv等价">17.10.1. eqv(等价)</h4>
<div class="paragraph">
<p>我们可以将它们与等价运算符 <code>eqv</code> 进行比较。</p>
</div>
<div class="paragraph">
<p>如果两个参数的类型，结构和值相同，则此运算符返回 <code>True</code>：</p>
</div>
<div class="listingblock">
<div class="title">文件: flip-flop-test (partial)</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $dinner eqv $lunch; # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些对象可能具有相同的值，但它们不是同一对象。 想像一下，在同一所幼儿园有两个名为 «Fred» 的孩子。 他们不是同一个孩子，无论同一个名字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = Person.new(name =&gt; &#34;Arne&#34;);
my $b = Person.new(name =&gt; &#34;Bente&#34;);

say $a eq $b; # -&gt; False

my $c = $a
say $a eq $c # -&gt; True

$c.name = &#34;Charlie&#34;;
say $c.name # -&gt; Charlie
say $a.name # -&gt; Charlie</code></pre>
</div>
</div>
<div class="paragraph">
<p>在下一节中，我们将回到本类。</p>
</div>
<div class="paragraph">
<p>在对象列表上使用 <code>unique</code>（请参见第8.18节&#34;unique(无重复的列表)&#34;）之前，请牢记这一点。</p>
</div>
</div>
<div class="sect3">
<h4 id="_13">17.10.2. ===</h4>
<div class="paragraph">
<p>使用值标识运算符 <code>`===</code> 来检查两个参数是否是同一对象，而无需考虑容器化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my class A { };
my $a = A.new;
say $a === $a;       # -&gt; True
say A.new === A.new; # -&gt; False
say A === A;         # -&gt; True
my $b := $a;
say $a === ba;       # -&gt; True</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关在值上使用 <code>===</code> 的说明，请参见第 3.7.7节 &#34;&#34;===&#34;。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_person_类">17.11. Person 类</h3>
<div class="paragraph">
<p>上一节中提示的 «Person» 类如下所示：</p>
</div>
<div class="listingblock">
<div class="title">文件: person</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Person {
    has Str $.name; ①
    has Str $.birtdate; ②

    has Person $.father; ③
    has Person $.mother; ④
    has Person $.spouse; ⑤
    has Person @.child; ⑥

    method new (:$name, :$birthdate) {
        self.bless(:$name, :$birthdate); 11
    }
}

my $tom = Person.new(name =&gt; &#34;Tom&#34;, birthdate =&gt; &#34;12 Jan 1970&#34;); ⑦ ⑧
my $lisa = Person.new(name =&gt; &#34;Lisa&#34;, birthdate =&gt; &#34;21 Mar 1969&#34;);

my $john = Person.new(name =&gt; &#34;John&#34;, birthdate =&gt; &#34;5 Apr 1998&#34;);
my $peter = Person.new(name =&gt; &#34;Peter&#34;, birthdate =&gt; &#34;23 Oct 2001&#34;);

my $mary = Person.new(name =&gt; &#34;Mary&#34;, birthdate =&gt; &#34;12 Mar 2000&#34;);

say $tom.birthdate; # 12 Jan 1970 ⑨
say $mary.name;     # Mary ⑨</code></pre>
</div>
</div>
<div class="paragraph">
<p>① 一个公共变量，因此默认的 &#34;new&#34; 将为我们处理。
② 如上所述。 也是一个字符串，因为我们还没有讨论日期（日期对象）。
③ 一个人有一个（或没有）父亲。
④ 一个人有一个（或没有）母亲。</p>
</div>
<div class="paragraph">
<p>⑤ 一个人有一个（或没有）配偶。
⑥ 一个人没有一个或多个孩子。
⑦ 最后，我们设置了5个 Person 对象。
⑧ 我们使用默认的 «new» 构造函数，并忽略关系字段。
⑨ 只是为了证明它确实有效。
10我已经编写了一个构造函数，因此我们无法指定关系字段。
11当字段与变量具有相同的名称时，我们可以使用这种缩写形式。</p>
</div>
<div class="paragraph">
<p>我本可以将关系字段设为私有(例如，&#34;$!father&#34; 而不是 &#34;$.father&#34;)，而不是编写新的构造函数，以使其无法在 &#34;new&#34; 调用中进行设置。</p>
</div>
<div class="paragraph">
<p>但这会限制我们以后的工作，因此我们会坚持与公众保持联系。</p>
</div>
<div class="paragraph">
<p><strong>练习 17.1</strong></p>
</div>
<div class="paragraph">
<p>编写以下方法 «set-father», «set-mother», 和 «set-spouse»  以设置各个字段。 忽略 <code>@.child</code> 字段。</p>
</div>
<div class="paragraph">
<p>添加以下代码以检查其是否正常运行（无错误执行）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$tom.set-spouse($lisa);
$lisa.set-spouse($tom);

$john.set-father($tom);
$john.set-mother($lisa);

$peter.set-father($tom);
$peter.set-mother($lisa);

$peter.set-spouse($mary);
$mary.set-spouse($peter);

say $tom.spouse.name;
say $john.mother.name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>数据结构/依赖关系应如下所示：</p>
</div>
<div class="paragraph">
<p>如果丽莎有一个父亲，我们可以使用 «$john.mother.father.name» 来获得他的名字。 她没有（在我们的数据结构中），因此该程序将终止。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$tom.spouse.name; # -&gt; lisa
$tom.father.name; # -&gt; program termination</code></pre>
</div>
</div>
<div class="paragraph">
<p>不是很健壮。 这表明我们确实不应该直接访问字段（而是使用方法）。 我们稍后会再讲。</p>
</div>
<div class="paragraph">
<p>在我们的班级中，配偶是一对一的关系，我们通过分别指定两个方向在数据结构中将其设置为双向关系。 可能会搞砸这样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$peter.set-spouse($mary);
$mary.set-spouse($tom); # Tom vs Peter

$peter.spouse.name;               # -&gt; Mary
$peter.spouse.spouse.name;        # -&gt; Tom
$peter.spouse.spouse.spouse.name; # -&gt; Lisa</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 17.2</strong>
简化 «set-spouse» 以建立两个关系，以便我们可以这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$tom.set-spouse($lisa);
# $lisa.set-spouse($tom);

$peter.set-spouse($mary);
# $mary.set-spouse($peter);</code></pre>
</div>
</div>
<div class="paragraph">
<p>添加此行以检查其是否有效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $lisa.spouse.name; # Tom</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>练习 17.3</strong>
编写方法 &#34;add-child&#34; 以添加到 &#34;child&#34; 字段。</p>
</div>
<div class="paragraph">
<p>添加以下代码以检查其是否正常运行（无错误执行）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$tom.add-child($john);
$tom.add-child($peter);

$lisa.add-child($john);
$lisa.add-child($peter);</code></pre>
</div>
</div>
<div class="paragraph">
<p>编写显示它们的方法 «show-children» ，并像这样使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$tom.show-children;
$mary.show-children;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这应该给出以下输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Tom has a child named John.
Tom has a child named Peter.
Mary has no children.</code></pre>
</div>
</div>
<div class="paragraph">
<p>孩子们的清单就是一个列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$tom.add-child($peter);
$tom.add-child($peter);
$tom.add-child($peter);
$tom.add-child($peter);</code></pre>
</div>
</div>
<div class="paragraph">
<p>防止重复的最简单方法是在将新子项添加到列表之后，在列表中应用唯一性：</p>
</div>
<div class="listingblock">
<div class="title">文件: person-children2 (partial)</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method add-child (Person $child) {
    @!child.push($child);
    @!child.=unique;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样只会删除重复的对象（请参见 17.10，&#34;对象比较&#34;），因此可以让多个人同名（尽管众所周知，在实践中会造成混淆）。</p>
</div>
<div class="paragraph">
<p><strong>练习 17.4</strong>
就像我们对配偶所做的那样，简化了父子关系的设置。</p>
</div>
<div class="paragraph">
<p>重写 «set-father» 和 «set-mother» 以为我们调用 «add-child» ，以便我们可以删除程序中的 «add-child»  调用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_输出_2">17.12. 输出</h3>
<div class="paragraph">
<p>如果我们尝试打印对象会怎样？</p>
</div>
<div class="paragraph">
<p>我们可以试试。 我写了一个小程序来做那个（作为 «person-say» 用）。 它所做的只是定义 «Person» 类，设置 «Tom»，然后这些行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $tom;
say $tom.raku;
say $tom.gist;
say $tom.Str;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_私有方法">17.13. 私有方法</h3>
<div class="paragraph">
<p>方法可以是私有的, 只要在方法名前面加上一个感叹号 <code>!</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method !explode { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在类本身之外不能调用它们。 在类内部这样调用他们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">self!explode;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_trusts">17.13.1. trusts</h4>
<div class="paragraph">
<p>我们可以允许其他类访问类中的私有方法和属性。</p>
</div>
<div class="paragraph">
<p>我们要信任的类必须已经声明，并且可以使用 <code>trusts</code> 关键字为其授予访问权限：</p>
</div>
<div class="listingblock">
<div class="title">文件: class-trust</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Owner { ... }; ①

class Car { ①
    trusts Owner;

    has Str $.type = &#34;no name&#34;;
    method !sell { say &#34;The $.type is sold.&#34; } ②
}

class Owner {  ①
    has Str $.name = &#34;no name&#34;;
    has Car $!car = Car.new(type =&gt; &#34;Volvo X1&#34;); ④

    method sell-car { $!car!Car::sell; } ⑥
    method get-car  { $!car; }
}

my Owner $o = Owner.new(name =&gt; &#34;Tom Jones&#34;); ③

$o.sell-car; ⑤

say $o.get-car.type; ⑦

# $o.get-car!sell;

# $o.get-car!Car::sell;</code></pre>
</div>
</div>
<div class="paragraph">
<p>① <code>Owner</code> 类引用 <code>Car</code> 类，因此必须首先声明 <code>Car</code>。 这带来了一个问题，因为 <code>trusts Owner</code> 要求必须首先声明 <code>Owner。 但是，我们可以摆脱存根类。
② `Car</code> 类具有允许 <code>Owner</code> 调用的私有方法 <code>sell</code>。
③ 我们建立了一个新的 <code>Owner</code> 对象，
④ 这也设置了一个新 <code>Car</code>，由 <code>Owner</code> 链接。
⑤ 然后，我们从 <code>Owner</code> 对象出售汽车。
⑥ 我们必须在方法(<code>sell</code>)之前加上完整的类名（<code>Car::sell</code>）。
⑦ 我们可以访问汽车类型，因为这是公共属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># $o.get-car!sell;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在程序中取消注释此行会产生错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">===SORRY!=== Private method call to sell must be fully qualified with the package
containing the method</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以尝试解决问题（使用类名），然后取消注释此行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># $o.get-car!Car::sell;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它也失败了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">===SORRY!=== Cannot call private method &#39;sell&#39; on package Car because it does not
  trust GLOBAL</code></pre>
</div>
</div>
<div class="paragraph">
<p>语法正确，但是主程序不受信任。 错误消息给出了提示，因此我们可以尝试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Car {
    trusts Owner;
    trusts GLOBAL;
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过此更改，它可以工作。 现在，我们可以从本身（<code>Car</code> 类），<code>Owner</code> 类和主程序出售汽车，但不能从其他任何类别（如果有）出售汽车。</p>
</div>
</div>
<div class="sect3">
<h4 id="_trusts方法">17.13.2. trusts(方法)</h4>
<div class="paragraph">
<p>使用 <code>trusts</code> 作为获取发起者信任的类的列表的方法。</p>
</div>
<div class="paragraph">
<p>我们可以将以下代码添加到程序中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">print &#34;Owner trusts:&#34;; print &#34; &#34; ~ .^name for Owner.^trusts; say &#34;&#34;;
print &#34;Car trusts:&#34;;   print &#34; &#34; ~ .^name for Car.^trusts; say &#34;&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Owner trusts:
Car trusts: Owner</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_继承">17.14. 继承</h3>
<div class="paragraph">
<p>继承是类中代码重用的主要机制。 一个类（称为子类）可以从一个或多个类（称为父类或基类）继承。</p>
</div>
<div class="paragraph">
<p>父类中的所有子元素（子方法（请参见下文）和私有方法除外）均被继承。 如果子类使用相同的名称定义属性或方法，则使用此版本。</p>
</div>
<div class="sect3">
<h4 id="_is">17.14.1. is</h4>
<div class="paragraph">
<p>继承是通过 <code>is</code> 关键字指定的。</p>
</div>
<div class="paragraph">
<p>让我们回顾一下 «Person» 课程。 我们可以添加几个新类，像这样重用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Adult is Person {
    has Str $.employer;
}

class Child is Person {
    has Str $.school;
}

class Pensioner is Person {
    ;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个类可以从一个以上的父类中继承，或者通过从本身使用继承的类中继承（依此类推）。</p>
</div>
<div class="paragraph">
<p>或直接这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class SeaPlane is Plane is Boat {
    has Int $.pontoons;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>继承循环是我们已知的问题，最终我们从自身继承。 我们无法从尚未声明的类中继承（就像使用 <code>trusts</code> 一样；请参见第17.12.1节 &#34;trusts&#34;），这一事实使得很难犯此错误。</p>
</div>
<div class="paragraph">
<p>存根类将不起作用：</p>
</div>
<div class="listingblock">
<div class="title">文件: inheritance-loop</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Mammal { ... }; ①
class Person is Mammal { has Str $.name; } ②
class Mammal is Person { has Str $.city; } ③</code></pre>
</div>
</div>
<div class="paragraph">
<p>① 我们必须存根，因为  «is Person» 会失败
② 由于尝试从存根类继承而失败
③ 我们永远不会走这么远</p>
</div>
<div class="paragraph">
<p>如果删除第2行，则由于 <code>is Person</code> 部分而导致错误。 我们无法在存根类上添加继承：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">===SORRY!=== Redeclaration of symbol &#39;Mammal&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，不可能建立循环继承。</p>
</div>
</div>
<div class="sect3">
<h4 id="_also_is">17.14.2. also is</h4>
<div class="paragraph">
<p>我们也可以在类主体中使用 <code>also is</code>，而不是在头部中使用 <code>is</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class SeaPlane {
    also is Plane;
    also is Boat;

    has Int $.pontoons;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>多重继承的问题是，如果我们继承的两个类都添加了一个具有相同名称的方法，该怎么办？ 我们应该使用哪个？ Raku 没有让程序员影响其选择操作的机制。 这是建议改用角色的主要原因（请参见第17.14节&#34;角色&#34;）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_submethod">17.14.3. submethod</h4>
<div class="paragraph">
<p><code>submethod</code> 是一种方法，但子类不会继承它。 （名称是指 <code>submethod</code> 的作用域与过程（子）相同的事实。</p>
</div>
<div class="paragraph">
<p>它通常用于自定义 <code>BUILD</code> 方法（如第17.7节&#34;自定义 BUILD&#34; 中所述）。</p>
</div>
<div class="paragraph">
<p>如果我们要确保必须为子类指定方法，它们也可能很有用，例如父版本不合适，并且你希望将其作为公共方法使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Person {
    has Str $.birthdate; # On the form &#34;yyyy-mm-dd&#34;
    submethod age { Int((now.Date - Date.new($!birthdate))/365) }
}

class Woman is Person {
    ;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>向女人询问年龄的情况会引起例外。</p>
</div>
<div class="paragraph">
<p><strong>练习17.5</strong></p>
</div>
<div class="paragraph">
<p>我们计算一个人的年龄的方法是错误的（因为我们假设每年有365天）。 修理它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_rebless">17.14.4. rebless</h4>
<div class="paragraph">
<p>使用 <code>Metamodel::Primitives.rebless</code> 方法更改对象的类型。 仅当新类型是对象原始类型的子类型时，此方法才有效。</p>
</div>
<div class="paragraph">
<p>让我们回顾一下 Person/Woman 的例子，将其简化为最低限度：</p>
</div>
<div class="listingblock">
<div class="title">文件: rebless</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Person          { ; }
class Woman is Person { ; }

my $tom  = Person.new;
my $lisa = Woman.new;

say $tom.^name;  # -&gt; Person
say $lisa.^name; # -&gt; Woman

Metamodel::Primitives.rebless($tom, Woman);
# -&gt; New type Woman for Person is not a mixin type

say $tom.^name; # -&gt; Woman

## See https://stackoverflow.com/questions/44486985/how-can-i-rebless-an-object-in-perl-6
## https://stackoverflow.com/questions/59845201/raku-rebless-doesnt-work-with-inhertited-classes-anymore</code></pre>
</div>
</div>
<div class="paragraph">
<p>待办事项：这曾经有用，但现在已经不行了（Raku 2019.11）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku rebless
Person
Woman
New type Woman for Person is not a mixin type
  in block &lt;unit&gt; at rebless line 12</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_角色">17.15. 角色</h3>
<div class="paragraph">
<p>角色使我们可以将属性和方法附加到类上，而无需继承。 当角色的内容是类唯一的共同点时，这很有用。</p>
</div>
<div class="paragraph">
<p>它们表现为一种宏，将其添加到类中（或以普通的 OO 术语混入），它们成为类的一部分-我们无法检测到它们是作为角色添加而不是被添加的。 在类本身中声明。</p>
</div>
<div class="paragraph">
<p>一个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Doors {
    has Int $.number-of-doors;
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_does对象">17.15.1. does(对象)</h4>
<div class="paragraph">
<p>使用 <code>does</code> 关键字将角色添加到类中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Car does Doors {
    has Int $.wheels;
    has Bool $.has-automatic-transmission;
}

class House does Doors {
    has Int $.floors;
    has Int $.rooms;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以将角色应用于对象（在运行时）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Windows {}
my $c = Car.new; # -&gt; Car.new
$c does Doors;   # -&gt; Car+{Doors}.new
$c does Windows  # -&gt; Car+{Doors}+{Windows}.new</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_also_does">17.15.2. also does</h4>
<div class="paragraph">
<p>我们也可以在类主体中使用 <code>also does</code>，而不是在 head 中使用 <code>does</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Car {
    also does Doors;
    has Int $.wheels;
    has Bool $.has-automatic-transmission;
}

class House {
    also does Doors;
    has Int $.floors;
    has Int $.rooms;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_but对象">17.15.3. but(对象)</h4>
<div class="paragraph">
<p>在第3.8节&#34;but(True 和 False, but …​)&#34;中，我们展示了 <code>but</code>(和 <code>does</code>)如何与其他标量值上的标量值一起使用。 应用除布尔值以外的任何内容都无法真正解决。</p>
</div>
<div class="paragraph">
<p>我们可以以相同的方式应用角色。</p>
</div>
<div class="listingblock">
<div class="title">文件: but-role</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 41 but Doors;
say $a ~ &#34; &#34; ~ $a.doors();

my $b = 42;
say $b ~ &#34; &#34; ~ ( $b.^can(&#34;doors&#34;) ?? $b.doors() !! &#34;-&#34; );</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>but</code> 关键字与 <code>does</code> 相似。 区别在于 <code>does</code> 会将其添加到给定的变量，类或对象中，而 <code>but</code> 将其应用于其副本。 在处理对象时，我们在类内部使用 <code>does</code>，但在对象上使用 <code>but</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_can">17.15.4. ^can</h4>
<div class="paragraph">
<p><code>$b</code> 没有角色，并且在其上调用 <code>.doors</code> 将终止程序。 我们可以通过在调用该方法之前检查该方法是否存在（使用 <code>.^can</code> 方法）来避免这种情况。</p>
</div>
<div class="paragraph">
<p>运行它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku but-role
41 No doors
42 -</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>but</code> 将角色应用于具有 REPL 的对象或值，但在 REPL 中不起作用</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_多重分派_2">17.16. 多重分派</h3>
<div class="paragraph">
<p>我们可以使用 <code>multi</code> 关键字指定方法的不同版本（与过程一样；请参见第 10.12 节&#34;多重分派&#34;），并带有不同的参数列表（或&#34;签名&#34;）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method do-something ($file1)         { ... }
multi method do-something ($file1, $file2) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了我们从类中获得的内置分派机制之外，还可以进行多种分派，因为我们可以在不同类的对象上使用相同的方法名称，并使它们的行为有所不同。</p>
</div>
<div class="listingblock">
<div class="title">文件: class-multi</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Fly {
    # Attributes
    method kill { say &#34;Fly killed&#34;; }
}

class Process {
    # Attributes
    method kill { say &#34;Process killed&#34;; };
}

my $a = Fly.new;
my $b = Process.new;

.kill for $a, $b;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku class-multi
Fly killed
Process killed</code></pre>
</div>
</div>
<div class="paragraph">
<p>不要忘记 <code>method</code> 关键字，因为 <code>multi</code> 本身就是 <code>multi sub</code> 的缩写。</p>
</div>
</div>
<div class="sect2">
<h3 id="_fallback_方法">17.17. Fallback 方法</h3>
<div class="paragraph">
<p>我们可以用特殊的 <code>FALLBACK</code> 名称定义一个方法，如果我们调用一个不存在的方法，它将被使用：</p>
</div>
<div class="listingblock">
<div class="title">文件: fallback</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Stupid {
    method FALLBACK ($name) {
        say &#34;You invoked $name, but it doesn&#39;t exist.&#34;;
    }

    method hello {
        say &#34;Hi.&#34;;
    }
}

my Stupid $s = Stupid.new;

$s.some-method-that-doesn&#39;t-exist;
$s.hello;
$s.hi;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku fallback
You invoked some-method-that-doesn&#39;t-exist, but it doesn&#39;t exist.
Hi.
You invoked hi, but it doesn&#39;t exist.</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有 <code>FALLBACK</code> 方法，则调用不存在的方法将产生运行时错误。</p>
</div>
<div class="paragraph">
<p>如果我们实际上是想调用一个现有的方法但是却键入错误，那么拥有 <code>FALLBACK</code> 方法将隐藏此错误消息。</p>
</div>
<div class="paragraph">
<p>我们也可以有论点。 只需在带有方法名称的参数后指定它们（通常称为 <code>$name</code>）。</p>
</div>
<div class="paragraph">
<p><code>multi method</code> 支持不同的签名：</p>
</div>
<div class="listingblock">
<div class="title">文件: fallback-multi</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Stupid {
    multi method FALLBACK ($name, Str $person) {
        say &#34;Hi, $person.&#34;;
    }

    multi method FALLBACK ($name) {
        say &#34;You invoked $name, but it doesn&#39;t exist.&#34;;
    }

    method hello {
        say &#34;Hi.&#34;;
    }
}

my Stupid $s = Stupid.new;

$s.some-method-that-doesn&#39;t-exist;
$s.some-method-that-doesn&#39;t-exist(&#34;Tom&#34;);
$s.hello;
$s.hi;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku fallback-multi
You invoked some-method-that-doesn&#39;t-exist, but it doesn&#39;t exist.
Hi, Tom.
Hi.
You invoked hi, but it doesn&#39;t exist.</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 slurpy 参数来捕获所有内容(请参见10.14.1节&#34;Slurpy MAIN&#34;)：</p>
</div>
<div class="listingblock">
<div class="title">文件: fallback-catchall</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Stupid {
    multi method FALLBACK ($name, *@arguments) {
        say &#34;Method: $name&#34;;
        say &#34;- Arg: $_&#34; for @arguments;
    }
}

my Stupid $s = Stupid.new;

$s.some-method-that-doesn&#39;t-exist(&lt;1 2 3&gt;);
$s.hello;
$s.hi(706);</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku fallback-catchall
Method: some-method-that-doesn&#39;t-exist
- Arg: 1
- Arg: 2
- Arg: 3
Method: hello
Method: hi
- Arg: 706</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_14">17.18. .?</h3>
<div class="paragraph">
<p>我们可以使用特殊的 <code>.?</code> 如果不确定方法是否可用于对象，则调用方法。 如果是，则执行；如果不是，则返回 <code>Nil</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {};
my $a = A.new;
say $a.foo-bar;  # -&gt; No such method &#39;foo-bar&#39; for invocant of type &#39;A&#39;
say $a.?foo-bar; # -&gt; Nil</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_15">17.19. .+</h3>
<div class="paragraph">
<p>如果我们有一个子类在基类中重新定义了一个方法，则在子类的对象上调用该方法将使用子类版本。 我们可以使用 <code>.+</code> 语法来调用它们：</p>
</div>
<div class="listingblock">
<div class="title">文件: all-methods</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    method hi { say &#34;Hi!&#34;; }
}

class B is A {
    method hi { say &#34;Hello!&#34;; }
}

my $x = B.new;

$x.hi;
say &#34;....&#34;;
$x.+hi;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; raku all-methods
Hello!
....
Hello!
Hi!</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果该方法不存在，则会引发异常。</p>
</div>
<div class="paragraph">
<p>我们忽略了返回值，但是它们是可用的。 最后一个给出了一个列表，在这里值是(<code>True</code> <code>True</code>)。</p>
</div>
<div class="paragraph">
<p>调用的顺序是从当前类开始，然后嵌套。 我们可以使用 <code>^mro</code> 方法（请参见第3.2节&#34;`^mro`（方法解析顺序）”）以查看“方法解析顺序”：</p>
</div>
<div class="listingblock">
<div class="title">文件: all-methods-mro (partial)</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = B.new;

say $x.^mro; # -&gt; ((B) (A) (Any) (Mu))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_16">17.20. .*</h3>
<div class="paragraph">
<p>与 <code>.+</code> 一样，不同之处在于如果该方法不存在（而不是引发异常），它将返回一个空列表。</p>
</div>
</div>
<div class="sect2">
<h3 id="_handles代理">17.21. handles(代理)</h3>
<div class="paragraph">
<p>代理是在类之间建立关系的另一种方法。 我们使当前类中的另一个类的方法可用（一种导入）。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参见 <a href="https://en.wikipedia.org/wiki/Delegation_(面向对象编程)。" class="bare">https://en.wikipedia.org/wiki/Delegation_(面向对象编程)。</a></p>
</div>
<div class="listingblock">
<div class="title">文件: delegation</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Baby {
    has $.name;
    method cry($times) { say &#34;Waah! &#34; x $times; }
}

my $tim = Baby.new(name =&gt; &#39;Tim&#39;);
say $tim.name; # -&gt; Tim
$tim.cry(5);   # -&gt; Waah! Waah! Waah! Waah! Waah!

class BabySitter {
    has $.name;
    has Baby $.baby handles (baby_name =&gt; &#39;name&#39;); ① ②
}

my $teenager = BabySitter.new(name =&gt; &#39;Lisa&#39;, baby =&gt; $tim); ③

say $teenager.name;      # -&gt; Lisa
say $teenager.baby_name; # -&gt; Tim  ③</code></pre>
</div>
</div>
<div class="paragraph">
<p>① «BabySitter» 类具有 «Baby» 属性，
②，我们提供了一种方法  «baby_name»  变量。 它被（通过 <code>handles</code>）委托给 «Baby» 类中的 <code>name</code> 方法。
③ 调用它。</p>
</div>
<div class="paragraph">
<p>请注意，我们必须重命名方法（为 &#34;«baby_name»&#34;），因为它们都使用 &#34;name&#34;。 如果方法名称不冲突，我们可以改为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">has Baby $.baby handles &#39;name&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们也可以继承几种方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">as Baby $.baby handles &lt;name bedtime diaper-type&gt;&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>代理的替代方法是直接访问对象。 例如。</p>
</div>
<div class="listingblock">
<div class="title">文件: delegation-no (partial)</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $teenager.baby.name; # -&gt; Tim</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_调用在变量中指定的方法">17.22. 调用在变量中指定的方法</h3>
<div class="paragraph">
<p>我们可以通过将变量放在双引号中（进行插值），然后添加 <code>()</code> 来调用指定为字符串（在变量中）的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;{pi}.{$_}: &#34; ~ pi.&#34;$_&#34;() for &lt;Int Real Str&gt;;
# 3.141592653589793.Int: 3
# 3.141592653589793.Real: 3.141592653589793
# 3.141592653589793.Str: 3.141592653589793</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_存根类_2">17.22.1. 存根类</h4>
<div class="paragraph">
<p>我们必须声明一个类，然后才能使用（或引用）它。 如果我们希望类之间互相引用，那将是一个问题。</p>
</div>
<div class="paragraph">
<p>一种解决方案是前向类声明(也称为&#34;存根类&#34;，因为我们使用的是 10.12.1 &#34;存根运算符&#34;)。 看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Parent { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要我们在使用类之前指定了类的内容，就可以使用存根类。</p>
</div>
<div class="paragraph">
<p>另一个解决方案是确保我们以正确的顺序指定它们，以便在我们声明它们之前不对其进行引用。</p>
</div>
<div class="paragraph">
<p>当我们具有相互依赖性（或循环数据结构）时，必须使用存根类：</p>
</div>
<div class="listingblock">
<div class="title">文件: stubbed-class</div>
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Parent { ... }
class Child  { has Parent $.parent; }
class Parent { has Child $.child; }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_docker">18. Docker</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Docker（一种轻量级的容器技术）是获取和运行Raku（Windows除外）的最简单方法，至少仅用于测试。 （当然，如果你不想在系统上安装Raku。）</p>
</div>
<div class="paragraph">
<p>由于Raku的开发非常活跃，每月发布一次，因此在升级本地安装的Raku版本之前，最好先通过Docker检查具有较新版本的程序。</p>
</div>
<div class="paragraph">
<p>如果你不想安装Rakudo Star，那么使用Docker是一个不错的选择。</p>
</div>
<div class="paragraph">
<p>我不建议在 Windows 上使用 Docker，因为它需要 Win 10 Pro。 使用 VirtualBox 是一种解决方法。</p>
</div>
<div class="paragraph">
<p>如果你仍然想去，请参阅 <a href="https://docs.docker.com/docker-for-windows/install/" class="bare">https://docs.docker.com/docker-for-windows/install/</a>。</p>
</div>
<div class="sect2">
<h3 id="_使用_docker_安装_rakudo_star">18.1. 使用 Docker 安装 Rakudo Star</h3>
<div class="paragraph">
<p>有一些 Rakudo 可公开获得的 Docker 镜像：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">镜像名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">操作系统</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">URRL(获取更多信息)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rakudo-star</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ubuntu (Linux)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/perl6/docker" class="bare">https://github.com/perl6/docker</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">jjmerelo/alpine-perl6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Alpine (Linux)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://hub.docker.com/r/jjmerelo/alpine-perl6/" class="bare">https://hub.docker.com/r/jjmerelo/alpine-perl6/</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">moritzlenz/perl6-regex-alpine</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Alpine (Linux)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://hub.docker.com/r/moritzlenz/perl6-regex-alpine/" class="bare">https://hub.docker.com/r/moritzlenz/perl6-regex-alpine/</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">jjmerelo/rakudo-nostar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Debian (Linux)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://hub.docker.com/r/jjmerelo/rakudo-nostar" class="bare">https://hub.docker.com/r/jjmerelo/rakudo-nostar</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">jjmerelo/perl6-doc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Debian (Linux)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/perl6/doc" class="bare">https://github.com/perl6/doc</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Ubuntu 版本是一个相当大的 Ubuntu 系统，而 Alpine 版本则是一个更加紧凑的发行版。 Alpine 应该更快，并使用更少的内存。 但是它有一些限制，我们稍后会再讲。</p>
</div>
<div class="paragraph">
<p>我们可以通过一个操作下载并运行 Docker 映像（假设首先安装了 Docker）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ docker run -it rakudo-star
Unable to find image &#39;rakudo-star:latest&#39; locally
latest: Pulling from library/rakudo-star
693502eb7dfb: Already exists
081cd4bfd521: Pull complete
c3439586dbe8: Pull complete
Digest: sha256:eac1ce2634c62857ee7e5e3f23b215 ...
Status: Downloaded newer image for rakudo-star:latest
To exit type &#39;exit&#39; or &#39;^D&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，它会检查镜像是否已下载，如果尚未下载，则进行下载。 然后在运行容器之前进行校验和测试。</p>
</div>
<div class="paragraph">
<p>最后一行是 REPL 提示。</p>
</div>
<div class="paragraph">
<p>如果收到错误消息（权限被拒绝），请以超级用户身份运行程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ sudo docker run -it rakudo-star</code></pre>
</div>
</div>
<div class="paragraph">
<p>或修复权限：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ sudo usermod -a -G docker $USER</code></pre>
</div>
</div>
<div class="paragraph">
<p>你必须注销然后再次登录才能使此更改生效。 如果不起作用，请重新启动。</p>
</div>
<div class="paragraph">
<p>或者，如果你想使用 Alpine：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ docker run -it jjmerelo/alpine-perl6
To exit type &#39;exit&#39; or &#39;^D&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Docker 首次运行此命令时将下载指定的 Docker 镜像，然后将使用本地副本。</p>
</div>
<div class="paragraph">
<p>使用 <code>docker pull</code> 检查是否有可用的较新版本，然后下载该版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ docker pull rakudo-star
$ docker pull jjmerelo/alpine-perl6</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_docker_shell">18.1.1. docker shell</h4>
<div class="paragraph">
<p>我们已经展示了如何使用 Docker 在 REPL 模式下运行 Raku。</p>
</div>
<div class="paragraph">
<p>但是可以登录到容器，以便你可以运行程序。 使用此命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ docker run -it -v $(pwd):/opt rakudo-star bash</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将在 Docker 文件系统内为你提供 bash(shell) 提示，并且你运行命令的目录为 /opt。</p>
</div>
<div class="paragraph">
<p>只需转到该目录并运行它们，即可将其用于测试本地程序。</p>
</div>
<div class="paragraph">
<p>请注意，这不适用于 Alpine（因为&#34;bash&#34;在容器中不可用）。 因此，如果你想运行 «bash»，请使用 Ubuntu。</p>
</div>
<div class="paragraph">
<p>也可以直接运行本地程序。 例如。 当前目录中的 &#34;hello-world&#34; 程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ docker run -it -v $(pwd):/opt rakudo-star /opt/hello-world
Hello, World!</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，当前目录(在 Docker 内部)不会设置为 <code>/opt</code>，如果程序假定它是从其所在的目录运行的，则可能会导致问题。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_答案">19. 答案</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_第一章">19.1. 第一章</h3>

</div>
<div class="sect2">
<h3 id="_第二章">19.2. 第二章</h3>

</div>
<div class="sect2">
<h3 id="_第三章">19.3. 第三章</h3>

</div>
<div class="sect2">
<h3 id="_第四章">19.4. 第四章</h3>

</div>
<div class="sect2">
<h3 id="_第五章">19.5. 第五章</h3>

</div>
<div class="sect2">
<h3 id="_第六章">19.6. 第六章</h3>

</div>
<div class="sect2">
<h3 id="_第七章">19.7. 第七章</h3>

</div>
<div class="sect2">
<h3 id="_第八章">19.8. 第八章</h3>

</div>
<div class="sect2">
<h3 id="_第九章">19.9. 第九章</h3>

</div>
<div class="sect2">
<h3 id="_第十章">19.10. 第十章</h3>

</div>
<div class="sect2">
<h3 id="_第十一章">19.11. 第十一章</h3>

</div>
<div class="sect2">
<h3 id="_第十二章">19.12. 第十二章</h3>

</div>
<div class="sect2">
<h3 id="_第十三章">19.13. 第十三章</h3>

</div>
<div class="sect2">
<h3 id="_第十四章">19.14. 第十四章</h3>

</div>
<div class="sect2">
<h3 id="_第十五章">19.15. 第十五章</h3>

</div>
<div class="sect2">
<h3 id="_第十六章">19.16. 第十六章</h3>

</div>
<div class="sect2">
<h3 id="_第十七章">19.17. 第十七章</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_小心">20. 小心</h2>
<div class="sectionbody">
<div class="paragraph">
<p>有许多重要的注意事项。</p>
</div>
<div class="sect2">
<h3 id="_length">20.1. length</h3>
<div class="paragraph">
<p>没有 «length» 方法。</p>
</div>
<div class="paragraph">
<p>在字符串上使用 <code>chars</code> (查看 7.1.1 &#34;chars&#34;)方法, 在列表上使用 <code>elems</code> (查看 8.7.1, &#34;elems(列表大小))方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_对象不是字符串">20.2. 对象不是字符串</h3>
<div class="paragraph">
<p>匹配对象在执行任何操作之前应转换为字符串。</p>
</div>
<div class="paragraph">
<p>IO 对象也应如此。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$*TMPDIR;              # &#34;/tmp&#34;.IO
$*TMPDIR.say;          # &#34;/tmp&#34;.IO
$*TMPDIR ~ &#34;/myfile&#34;;  # /tmp/myfile</code></pre>
</div>
</div>
<div class="paragraph">
<p>它们可能会自动转换为字符串，也可能不会自动转换为字符串。</p>
</div>
</div>
<div class="sect2">
<h3 id="_另请参考">20.3. 另请参考</h3>
<div class="paragraph">
<p>另请参考: <a href="https://docs.raku.org/language/traps" class="bare">https://docs.raku.org/language/traps</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_语法汇总">20.4. 语法汇总</h3>
<div class="paragraph">
<p>程序使用的其他特殊字符的摘要； 在头部，身体或调用（调用）中。</p>
</div>
<div class="paragraph">
<p><strong>With variables</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">语法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">位置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">查看所在章节</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:$a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Head</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">命名参数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.13.4, &#34;具名参数&#34;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:$a!</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Head</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">强制命名参数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.13.5, &#34;强制命名参数&#34;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:$a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invocation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">命名参数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.13.4, &#34;命名参数&#34;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$:a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Body</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">命名占位符变量</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.4.1, &#34;命名占位符变量&#34;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$a:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invocation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用过程语法调用的方法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">17.2.2, &#34;冒号语法&#34;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>With Names Arguments</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">语法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">位置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">查看所在章节</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invocation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">命名参数为 <code>True</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.13.6, &#34;副词&#34;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:!a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invocation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">命名参数为 <code>False</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.13.6, &#34;副词&#34;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>短形式的 $, @ 和 %</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">语法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">查看所在章节</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$&lt;aa&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">查找命名匹配</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">查看 «高级 Raku» 课程</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%&lt;aa&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在状态散列 <code>%</code> 中查找散列值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16.6.2, &#34;$/@/%(匿名状态变量)&#34;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>其它</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">语法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所在位置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">查看所在章节</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FOOBAR:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在循环里面或前面</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个标签</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.17.5, &#34;标签&#34;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:12(&#34;12345&#34;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何地方</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12 进制数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5.1, &#34;八进制,十六进制,二进制…​&#34;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:13&lt;12345&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任何地方</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">13 进制数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5.1, &#34;八进制,十六进制,二进制…​&#34;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FOO.BAR: 12, 13;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法调用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传递参数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12.2.2, &#34;冒号语法&#34;</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_raku_背景和历史">21. Raku 背景和历史</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Perl 1 至 4 版本从 1987 年至 1993 年发布。</p>
</div>
<div class="paragraph">
<p>Perl 5 版于 1994 年发布。它是一个完全重写，并且所有新功能都终止了 Perl 4 的使用。 今天，Perl 5 正在积极开发中。</p>
</div>
<div class="paragraph">
<p>更多信息：<a href="https://en.wikipedia.org/wiki/Perl" class="bare">https://en.wikipedia.org/wiki/Perl</a></p>
</div>
<div class="paragraph">
<p>Perl 版本 6 是 2000 年构想的。它首先邀请 Perl 社区提出更改建议。 这个过程非常耗时，因为一切都是（现在仍然是）由志愿者完成的。</p>
</div>
<div class="paragraph">
<p>它原本是 Perl 的新版本，但是多年来，很明显 Perl 5 将继续存在-并且正在积极维护中。</p>
</div>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Perl_6" class="bare">https://en.wikipedia.org/wiki/Perl_6</a>
<a href="https://en.wikipedia.org/wiki/Raku_(programming_language）" class="bare">https://en.wikipedia.org/wiki/Raku_(programming_language）</a></p>
</div>
<div class="paragraph">
<p>首席开发人员于 2019 年 10 月做出将语言重命名为 Raku 的决定，但要完全实施更改尚需时日。</p>
</div>
<div class="sect2">
<h3 id="_6_a_和_6_b">21.1. 6.a 和 6.b</h3>
<div class="paragraph">
<p>Alpha 和 Beta 版本分别称为 &#34;6.a&#34; 和 &#34;6.b&#34;。</p>
</div>
<div class="paragraph">
<p>请勿使用它们，因此，如果你有其中之一，请升级。</p>
</div>
</div>
<div class="sect2">
<h3 id="_6_c">21.2. 6.c</h3>
<div class="paragraph">
<p>第一个稳定版本（版本 6.c）于 2015 年 12 月 25 日发布。</p>
</div>
</div>
<div class="sect2">
<h3 id="_6_d">21.3. 6.d</h3>
<div class="paragraph">
<p>下一版本(6.d)于 2018 年 11 月发布。</p>
</div>
</div>
<div class="sect2">
<h3 id="_6_e">21.4. 6.e</h3>
<div class="paragraph">
<p>该版本尚未发布，但是正在开发中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_关于版本">21.5. 关于版本</h3>
<div class="paragraph">
<p>对于 Perl 5（和大多数其他解释语言），你只有一个版本。 如果你升级到较新的版本，那么你已经拥有了。 对于已安装的模块也是如此。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，你可以安装一个模块的多个版本。 默认情况下，程序将使用最新版本（版本号最高的版本），但是你可以选择显式使用特定版本。</p>
</div>
<div class="paragraph">
<p>这也适用于语言本身。 6d 具有一些破坏与 6c 兼容性的新功能。 你可以通过显式执行旧的 6c 语义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.c;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果这样做，代码将永远锁定在该版本上。 如果你使用模块，请注意，较新的版本（因为你对其进行了升级）可能会使用 6d 中的功能，并且可能会 <code>use v6d;</code> 语句。</p>
</div>
<div class="paragraph">
<p>这样可以解决问题，因为程序的不同部分最终可能使用同一模块的不同版本。 但是，这可能是开发人员的噩梦。</p>
</div>
<div class="paragraph">
<p>Rakudo 实现在主要版本之间获得了新功能，但是重大更改隐藏在 «PREVIEW» 标签之后。 因此，如果你想使用将成为 «6.e» 版本一部分的内容，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.e.PREVIEW;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请勿在生产代码中使用该代码。 发布 «6.e» 后，你应该更新 <code>use</code> 语句：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.e;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，如果指定版本，则代码将在该版本下运行。</p>
</div>
<div class="paragraph">
<p>如果你未指定版本，则将获得最新版本(«PREVIEW» 版本除外)。</p>
</div>
</div>
</div>
</div>

</article>


    

  </main><section class="site__search">
    <label class="site__form">
        <p class="form__label">Search around the site</p> 
        <input class="site__search-bar form__input" type="text">
    </label>
    <div class="site__search-bar-results"></div>
</section>
  
  <footer class="site__footer">
    
    
    <p class="footer__sign">© 2020 ohmyraku</p></footer>
    

    <link rel="stylesheet" href="https://ohmyraku.github.io/css/prism.min.css"> 
    
    

    
    <script>
        window.addEventListener("load", function () {
            const script = document.createElement("script");
            script.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
            script.async = true

            document.head.appendChild(script);
        })
    </script>





<script defer type="text/javascript" src="https://ohmyraku.github.io/js/script.80368e52cf9dd9e602bf5e846e392520e70607ee948e4316b49e90236e76aa56f529c21ebfc37cf22abaa49b54d8ffe2ae2368212cbeeb22de989716b6575a49.js" integrity="sha512-gDaOUs&#43;d2eYCv16EbjklIOcGB&#43;6UjkMWtJ6QI252qlb1KcIev8N88iq6pJtU2P/iriNoISy&#43;6yLemJcWtldaSQ=="></script>



</body>
</html>