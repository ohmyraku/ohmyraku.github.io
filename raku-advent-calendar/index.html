<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Raku Advent Calendar :: 山川异域, 风月同天</title>

<meta name="author" content="ohmyraku">
<meta name="application-name" content="山川异域, 风月同天">
<meta name="description" content="1. 第一天 – Raku 鬼精灵: 圣诞节实用指南 看看他们！同事、朋友和亲近的家人都在开心地笑着。他们都在享受着使用 Raku 的 6.c “圣诞”版编程的乐趣。给力的并发原语, 核心文法, 还有非常棒的对象模型。它让我印象深刻！
 但是等一下…​ 就一秒。我有个想法。一个可怕的想法。我想到了一个鬼主意! 我们可以在他们的&#34;圣诞&#34;上捣乱。需要的只有一点花招。哈哈哈哈哈哈！！
 欢迎来到 2017 年的 Raku 圣诞日历！每天，从今天直到圣诞节，我们都会有一篇很赞的关于 Raku 的博客推送到你面前。
 今天，我们会展示我们淘气的一面并且故意地做些淘气的事情。确实，这有点用，但是淘气点更快乐。我们开始吧！
 1.1. But True does False 你听过 but 操作符吗？一个好玩的东西：
 say True but False ?? &#39;Tis true&#39; !! &#39;Tis false&#39;; # OUTPUT: «Tis false␤» my $n = 42 but &#39;forty two&#39;; say $n; # OUTPUT: «forty two␤» say $n &#43; 7; # OUTPUT: «49␤»   它是一个中缀操作符，它首先拷贝它左边的对象，然后把它右边提供的 role 混进这个拷贝中：">
<meta name="robots" content="noodp"/>
<meta name="generator" content="Hugo 0.79.0" />
<meta name="referrer" content="no-referrer" />
<meta name="format-detection" content="telephone=no">

<link rel="canonical" href="https://ohmyraku.github.io/raku-advent-calendar/" />


<link rel="icon" href="https://ohmyraku.github.io/logo.png" />

<link rel="stylesheet" href="https://ohmyraku.github.io/scss/main.min.84f71d25d375c522a861bb4719728ce6839cf3635b15ca0c7a1b4d799c2dc3399a1d6cb46058a9d8fdbebe9156a8857279cfdeb70aa3862e629de234b5a41fa1.css" integrity="sha512-hPcdJdN1xSKoYbtHGXKM5oOc82NbFcoMehtNeZwtwzmaHWy0YFip2P2&#43;vpFWqIVyec/etwqjhi5ineI0taQfoQ==">
<script>

const theme = window.localStorage.getItem('theme'); 
if (theme && theme !== "1") {
    document.documentElement.classList.add('theme-' + theme);
}
</script>


</head>
<body>
  <main class="site__content">
    <div class="site__page">
  <nav class="site__breadcrumbs">
    <a class="site__breadcrumb" href="https://ohmyraku.github.io/">山川异域, 风月同天</a><a class="site__breadcrumb--active" href="https://ohmyraku.github.io/raku-advent-calendar/">Raku Advent Calendar</a>
</nav>

<h1 class="page__title">Raku Advent Calendar</h1>
  <div class="page__meta">
    <p>
    
    <span class="page__date">
    on <time datetime="2020-02-05T15:26:52&#43;08:00">2020-02-05</time>
    
    </span>
    </p>

    

    
    </div>
</div>


<div class="page__toc">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#_第一天_raku_鬼精灵_圣诞节实用指南">1. 第一天 – Raku 鬼精灵: 圣诞节实用指南</a>
      <ul>
        <li><a href="#_but_true_does_false">1.1. But True does False</a></li>
        <li><a href="#_wrapping_it_up">1.2. Wrapping It Up</a></li>
        <li><a href="#_看不见的斗篷">1.3. 看不见的斗篷</a></li>
        <li><a href="#_ho_ho_ho">1.4. Ho-Ho-Ho</a></li>
        <li><a href="#_结论">1.5. 结论</a></li>
      </ul>
    </li>
    <li><a href="#_第二天_raku_符号_变量和容器">2. 第二天-Raku: 符号, 变量和容器</a>
      <ul>
        <li><a href="#_把钱拿出来">2.1. 把钱拿出来</a></li>
        <li><a href="#_我们祝你有一个愉快的列表圣诞">2.2. 我们祝你有一个愉快的列表圣诞</a></li>
        <li><a href="#_thats_your_assignment">2.3. That’s Your Assignment</a></li>
        <li><a href="#_positionlly">2.4. Position@lly</a></li>
        <li><a href="#_the_one_and_only">2.5. The One and Only</a></li>
        <li><a href="#_decont">2.6. Decont</a></li>
        <li><a href="#_不要让它溜走">2.7. 不要让它溜走</a></li>
        <li><a href="#_i_want_less">2.8. I Want Less</a></li>
        <li><a href="#_defaulting_on_default_defaults">2.9. Defaulting on Default Defaults</a></li>
        <li><a href="#_自定义">2.10. 自定义</a></li>
        <li><a href="#_这就是全部伙计">2.11. 这就是全部，伙计</a></li>
        <li><a href="#_结论_2">2.12. 结论</a></li>
      </ul>
    </li>
    <li><a href="#_第三天_letterops_with_raku">3. 第三天 – LetterOps with Raku</a>
      <ul>
        <li><a href="#_规模">3.1. 规模</a></li>
        <li><a href="#_markdown_来拯救">3.2. Markdown 来拯救</a></li>
        <li><a href="#_使用_raku_处理_markdown">3.3. 使用 Raku 处理 Markdown</a></li>
        <li><a href="#_需要更多的结构">3.4. 需要更多的结构</a></li>
        <li><a href="#_这里的玩具是重要的">3.5. 这里的玩具是重要的</a></li>
        <li><a href="#_还没有">3.6. 还没有</a></li>
        <li><a href="#_包起来">3.7. 包起来</a></li>
      </ul>
    </li>
    <li><a href="#_第四天_使用_grammars_进行解析">4. 第四天-使用 Grammars 进行解析</a>
      <ul>
        <li><a href="#_理解_grammars">4.1. 理解 Grammars</a></li>
        <li><a href="#_递归下降分析法和优先级">4.2. 递归下降分析法和优先级</a></li>
        <li><a href="#_左递归和其他陷阱">4.3. 左递归和其他陷阱</a></li>
        <li><a href="#_始于简单">4.4. 始于简单</a></li>
        <li><a href="#_组装完整的_grammars">4.5. 组装完整的 Grammars</a></li>
        <li><a href="#_调试_grammars">4.6. 调试 Grammars</a></li>
        <li><a href="#_解析空白和注释">4.7. 解析空白和注释</a></li>
        <li><a href="#_保存状态">4.8. 保存状态</a></li>
        <li><a href="#_使用动态变量实现词法作用域">4.9. 使用动态变量实现词法作用域</a></li>
        <li><a href="#_总结">4.10. 总结</a></li>
        <li><a href="#_解构_json">4.11. 解构 JSON</a></li>
        <li><a href="#_在块儿中使用签名">4.12. 在块儿中使用签名</a></li>
        <li><a href="#_你甚至可以解构对象">4.13. 你甚至可以解构对象!</a></li>
        <li><a href="#_结论_3">4.14. 结论</a></li>
      </ul>
    </li>
    <li><a href="#_第六天_raku_书籍">5. 第六天-Raku 书籍</a></li>
    <li><a href="#_第七天_测试所有的东西">6. 第七天 – 测试所有的东西</a>
      <ul>
        <li><a href="#_it_depends">6.1. It depends…</a></li>
        <li><a href="#_懒惰和不耐烦">6.2. 懒惰和不耐烦</a></li>
        <li><a href="#_晾干">6.3. 晾干</a></li>
      </ul>
    </li>
    <li><a href="#_第八天_adventures_in_nqp_land_hacking_the_rakudo_compiler">7. 第八天 - Adventures in NQP Land: Hacking the Rakudo Compiler</a>
      <ul>
        <li><a href="#_背景">7.1. 背景</a></li>
        <li><a href="#_not_quite_perl_nqp">7.2. Not Quite Perl (NQP)</a></li>
        <li><a href="#_进入战壕">7.3. 进入战壕</a></li>
        <li><a href="#_工作区和工具">7.4. 工作区和工具</a></li>
        <li><a href="#_hacking">7.5. Hacking</a></li>
        <li><a href="#_测试">7.6. 测试</a></li>
        <li><a href="#_文档">7.7. 文档</a></li>
        <li><a href="#_nqp_经验教训">7.8. NQP 经验教训</a></li>
        <li><a href="#_成功">7.9. 成功！</a></li>
        <li><a href="#_总结_2">7.10. 总结</a></li>
        <li><a href="#_参考">7.11. 参考</a></li>
        <li><a href="#_附录">7.12. 附录</a></li>
        <li><a href="#_主要的_raku_pod_渲染器">7.13. 主要的 Raku POD 渲染器</a></li>
      </ul>
    </li>
    <li><a href="#_第九天_http_and_web_sockets_with_cro">8. 第九天 – HTTP and Web Sockets with Cro</a>
      <ul>
        <li><a href="#_响应式管道">8.1. 响应式管道</a></li>
        <li><a href="#_http_服务器简单的方法">8.2. HTTP 服务器，简单的方法</a></li>
        <li><a href="#_通向幸福的途径">8.3. 通向幸福的途径</a></li>
        <li><a href="#_中间件变得更容易">8.4. 中间件变得更容易</a></li>
        <li><a href="#_这只是一个供应链supply_chain">8.5. 这只是一个供应链(Supply chain)</a></li>
        <li><a href="#_哦和websockets">8.6. 哦，和WebSockets？</a></li>
        <li><a href="#_综上所述">8.7. 综上所述</a></li>
      </ul>
    </li>
    <li><a href="#_第十天_wrapping_rats">9. 第十天 – Wrapping Rats</a></li>
    <li><a href="#_第十一天_raku_中所有的星号">10. 第十一天-Raku 中所有的星号</a>
      <ul>
        <li><a href="#_1_乘法">10.1. 1. 乘法</a></li>
        <li><a href="#_2_幂">10.2. 2. 幂</a></li>
        <li><a href="#_3_零或多次重复">10.3. 3. 零或多次重复</a></li>
        <li><a href="#_4_min_到_max_次重复">10.4. 4. Min 到 Max 次重复</a></li>
        <li><a href="#_5_吞噬参数">10.5. 5. 吞噬参数</a></li>
        <li><a href="#_6_吨吨吨吨吨吨吨">10.6. 6. 吨吨吨吨吨吨吨</a></li>
        <li><a href="#_7_动态作用域">10.7. 7. 动态作用域</a></li>
        <li><a href="#_8_编译变量">10.8. 8. 编译变量</a></li>
        <li><a href="#_9_all_methods">10.9. 9. All methods</a></li>
        <li><a href="#_10_whatever">10.10. 10. Whatever</a></li>
        <li><a href="#_11_whatevercode">10.11. 11. WhateverCode</a></li>
        <li><a href="#_作业">10.12. 作业</a></li>
        <li><a href="#_附加题">10.13. 附加题</a></li>
      </ul>
    </li>
    <li><a href="#_第十二天_the_year_of_raku_books">11. 第十二天 – The Year of Raku Books</a></li>
    <li><a href="#_第十三天_使用_raku_挖掘维基百科">12. 第十三天 - 使用 Raku 挖掘维基百科</a>
      <ul>
        <li><a href="#_介绍">12.1. 介绍</a></li>
        <li><a href="#_grammar_和_actions_难学吗">12.2. Grammar 和 Actions 难学吗?</a></li>
        <li><a href="#_第一根火柴">12.3. 第一根火柴</a></li>
        <li><a href="#_第二根火柴">12.4. 第二根火柴</a></li>
        <li><a href="#_第三根火柴">12.5. 第三根火柴</a></li>
        <li><a href="#_面向对象">12.6. 面向对象</a></li>
        <li><a href="#_w_is_your_friend">12.7. &lt;|w&gt; is your friend</a></li>
      </ul>
    </li>
    <li><a href="#_第十五天_带有_promise_的简单网络爬虫">13. 第十五天-带有 Promise 的简单网络爬虫</a>
      <ul>
        <li><a href="#_结论是">13.1. 结论是</a></li>
      </ul>
    </li>
    <li><a href="#_第十六天_raku_性能改进">14. 第十六天-Raku 性能改进</a></li>
    <li><a href="#_第十七天_关于消息传递">15. 第十七天-关于消息传递</a>
      <ul>
        <li><a href="#_为什么要传递消息">15.1. 为什么要传递消息</a></li>
        <li><a href="#_传递什么信息">15.2. 传递什么信息</a></li>
        <li><a href="#_强制性的你好世界">15.3. 强制性的你好，世界</a></li>
        <li><a href="#_一些更有用的东西">15.4. 一些更有用的东西</a></li>
        <li><a href="#_保持主题">15.5. 保持主题</a></li>
        <li><a href="#_但是生命比amqp更重要">15.6. 但是，生命比AMQP更重要</a></li>
        <li><a href="#_把它包起来">15.7. 把它包起来</a></li>
      </ul>
    </li>
    <li><a href="#_第十八天_raku_支持的工作流">16. 第十八天-Raku 支持的工作流</a></li>
    <li><a href="#_第十九天_language_independent_validation_rules_livr_for_raku">17. 第十九天-Language Independent Validation Rules (LIVR) for Raku</a>
      <ul>
        <li><a href="#_livr_介绍">17.1. LIVR 介绍</a></li>
        <li><a href="#_livr和raku">17.2. LIVR和Raku</a></li>
        <li><a href="#_livr_链接">17.3. LIVR 链接</a></li>
      </ul>
    </li>
    <li><a href="#_第二十天_宏的进阶">18. 第二十天-宏的进阶</a></li>
    <li><a href="#_第二十一天_数独与junctions和集合">19. 第二十一天-数独与Junctions和集合</a>
      <ul>
        <li><a href="#_junctions量子逻辑测试">19.1. Junctions：量子逻辑测试</a></li>
        <li><a href="#_集合对象的集合">19.2. 集合：对象的集合</a></li>
        <li><a href="#_关于对象的说明">19.3. 关于对象的说明</a></li>
      </ul>
    </li>
    <li><a href="#_第二十二天_raku_d_的特性">20. 第二十二天-Raku.d 的特性</a>
      <ul>
        <li><a href="#_在创建时调整对象">20.1. 在创建时调整对象</a></li>
        <li><a href="#_并发性改进">20.2. 并发性改进</a></li>
        <li><a href="#_unicode_goodies">20.3. Unicode goodies</a></li>
        <li><a href="#_跳过值">20.4. 跳过值</a></li>
        <li><a href="#_of_bufs_and_blobs">20.5. Of Bufs and Blobs</a></li>
        <li><a href="#_测试测试测试">20.6. 测试，测试，测试！</a></li>
        <li><a href="#_这是怎么回事">20.7. 这是怎么回事</a></li>
        <li><a href="#_main_函数">20.8. MAIN 函数</a></li>
        <li><a href="#_嵌入_raku">20.9. 嵌入 Raku</a></li>
        <li><a href="#_礼品袋的底部">20.10. 礼品袋的底部</a></li>
        <li><a href="#_赶上雪橇的时间">20.11. 赶上雪橇的时间</a></li>
      </ul>
    </li>
    <li><a href="#_第二十三天_raku_高尔夫">21. 第二十三天-Raku 高尔夫</a>
      <ul>
        <li><a href="#_一些基本的例子">21.1. 一些基本的例子</a></li>
        <li><a href="#_numbers">21.2. Numbers</a></li>
        <li><a href="#_条件">21.3. 条件</a></li>
        <li><a href="#_打字很难让我们使用一些预定义的字符串">21.4. 打字很难，让我们使用一些预定义的字符串！</a></li>
        <li><a href="#_base_16_base_36_nah_base_0x10ffff">21.5. Base 16? Base 36? Nah, Base 0x10FFFF!</a></li>
        <li><a href="#_所有的好事都必须结束可怕的事情_更是如此">21.6. 所有的好事都必须结束;可怕的事情 - 更是如此</a></li>
      </ul>
    </li>
    <li><a href="#_第二十四天_解魔方">22. 第二十四天-解魔方</a>
      <ul>
        <li><a href="#_介绍_2">22.1. 介绍</a></li>
        <li><a href="#_符号">22.2. 符号</a></li>
        <li><a href="#_算法">22.3. 算法</a></li>
        <li><a href="#_设计一个模块">22.4. 设计一个模块</a></li>
        <li><a href="#_代码">22.5. 代码</a></li>
      </ul>
    </li>
    <li><a href="#_第二十五天_圣诞奖金_并发http服务器实施和scripter的方法">23. 第二十五天-圣诞奖金 - 并发HTTP服务器实施和scripter的方法</a>
      <ul>
        <li><a href="#_raku_范式">23.1. Raku 范式</a></li>
        <li><a href="#_raku_supplies_就像一个_v12_引擎">23.2. Raku Supplies 就像一个 V12 引擎</a></li>
        <li><a href="#_wap6_的结构">23.3. Wap6 的结构</a></li>
        <li><a href="#_wap6_的核心">23.4. Wap6 的核心</a></li>
        <li><a href="#_webservices">23.5. Webservices</a></li>
        <li><a href="#_当客户端请求静态文件时">23.6. 当客户端请求静态文件时</a></li>
        <li><a href="#_结语">23.7. 结语</a></li>
      </ul>
    </li>
    <li><a href="#_第一天_移植_vigilance将raku与标准工具集成在一起">24. 第一天 - 移植 Vigilance，将Raku与标准工具集成在一起</a>
      <ul>
        <li><a href="#_shebang_和导入">24.1. Shebang 和导入</a></li>
        <li><a href="#_命令行选项">24.2. 命令行选项</a></li>
        <li><a href="#_io_读写文件">24.3. IO: 读写文件</a></li>
        <li><a href="#_获得md5校验和">24.4. 获得MD5校验和</a></li>
        <li><a href="#_结束之前的思考">24.5. 结束之前的思考</a></li>
      </ul>
    </li>
    <li><a href="#_第二天_like_6_perls_in_a_pod_document_everything">25. 第二天 – Like 6 Perls in a Pod: document everything</a></li>
    <li><a href="#_大多数人都可以阅读源代码但每个人都可以阅读文档">26. 大多数人都可以阅读源代码，但每个人都可以阅读文档。</a></li>
    <li><a href="#_pod_6_stands_for_plain_old_documentation_for_raku">27. Pod 6 stands for “Plain Old documentation for Raku”</a></li>
    <li><a href="#_给模块添加文档">28. 给模块添加文档</a></li>
    <li><a href="#_回到生产">29. 回到生产</a></li>
    <li><a href="#_第三天_raku_跳转到那儿">30. 第三天 – Raku – 跳转到那儿</a></li>
    <li><a href="#_第四天_献给新年的_raku_pod_新功能">31. 第四天 - 献给新年的 Raku Pod 新功能</a>
      <ul>
        <li><a href="#_介绍_3">31.1. 介绍</a></li>
        <li><a href="#_准备">31.2. 准备</a></li>
        <li><a href="#_背景_2">31.3. 背景</a></li>
        <li><a href="#_rakudo_nqp_grammar_和_actions_学到的东西">31.4. Rakudo NQP grammar 和 actions: 学到的东西</a></li>
        <li><a href="#_总结_3">31.5. 总结</a></li>
        <li><a href="#_左还是右">31.6. 左还是右？</a></li>
        <li><a href="#_参数">31.7. 参数</a></li>
        <li><a href="#_动态范围">31.8. 动态范围</a></li>
        <li><a href="#_宏里面的变量">31.9. 宏里面的变量</a></li>
      </ul>
    </li>
    <li><a href="#_第六天_懒惰精灵与勤劳精灵">32. 第六天 - 懒惰精灵与勤劳精灵</a>
      <ul>
        <li><a href="#_lazy_slack">32.1. Lazy slack</a></li>
        <li><a href="#_尽力追赶">32.2. 尽力追赶</a></li>
        <li><a href="#_use_the_right_elf">32.3. Use the right elf</a></li>
      </ul>
    </li>
    <li><a href="#_第七天_细胞自动机">33. 第七天 – 细胞自动机</a>
      <ul>
        <li><a href="#_为学习而做">33.1. 为学习而做</a></li>
        <li><a href="#_走在前面">33.2. 走在前面</a></li>
        <li><a href="#_制作东西">33.3. 制作东西</a></li>
        <li><a href="#_改变">33.4. 改变</a></li>
        <li><a href="#_改变邻居">33.5. 改变邻居</a></li>
        <li><a href="#_优化机会">33.6. 优化机会？</a></li>
        <li><a href="#_其他变化">33.7. 其他变化？</a></li>
        <li><a href="#_这有用吗">33.8. 这有用吗？</a></li>
      </ul>
    </li>
    <li><a href="#_第八天_让你的_raku_grammar_紧凑一点">34. 第八天 — 让你的 Raku grammar 紧凑一点</a>
      <ul>
        <li><a href="#_1_拆分_actions">34.1. 1.拆分 actions</a></li>
        <li><a href="#_使用_multi_方法">34.2. 使用 multi 方法</a></li>
        <li><a href="#_3_让_perl_完成这项工作">34.3. 3. 让 Perl 完成这项工作</a></li>
        <li><a href="#_4_使用_multi_rules_和_multi_tokens">34.4. 4. 使用 multi-rules 和 multi-tokens</a></li>
      </ul>
    </li>
    <li><a href="#_第九天_raku_中的常量">35. 第九天 - Raku 中的常量</a>
      <ul>
        <li><a href="#_如何制作一个常数">35.1. 如何制作一个常数</a></li>
        <li><a href="#_从模块导出常量">35.2. 从模块导出常量</a></li>
        <li><a href="#_在程序中使用模块">35.3. 在程序中使用模块</a></li>
        <li><a href="#_最后对代码维护进行了一些注释">35.4. 最后，对代码维护进行了一些注释</a></li>
      </ul>
    </li>
    <li><a href="#_第十天_跳转_开启你的工作流">36. 第十天 - 跳转, 开启你的工作流</a></li>
    <li><a href="#_第十一天_使用_raku_测试你的时刻表">37. 第十一天 - 使用 Raku 测试你的时刻表</a></li>
    <li><a href="#_第十二天_构建灵活的_grammar">38. 第十二天 - 构建灵活的 grammar</a></li>
    <li><a href="#_第十三天_使用_cro_和_debian_从头构建_web_服务">39. 第十三天 - 使用 Cro 和 Debian 从头构建 Web 服务</a>
      <ul>
        <li><a href="#_安装_rakudo_raku_编译器">39.1. 安装 Rakudo Raku 编译器</a></li>
        <li><a href="#_安装_cro_服务">39.2. 安装 Cro 服务</a></li>
        <li><a href="#_cro_实战">39.3. Cro 实战</a></li>
        <li><a href="#_总结_4">39.4. 总结</a></li>
      </ul>
    </li>
    <li><a href="#_第十四天_使用_raku_设计小航天器">40. 第十四天 - 使用 Raku 设计(小)航天器</a>
      <ul>
        <li><a href="#_寻找共同点">40.1. 寻找共同点</a></li>
        <li><a href="#_asn_1_和限制">40.2. <code>ASN.1</code> 和限制</a></li>
        <li><a href="#_逐步建设问题答案">40.3. 逐步建设。问题答案。</a></li>
      </ul>
    </li>
    <li><a href="#_第十五天_使用_raku_构建小型航天器">41. 第十五天 - 使用 Raku 构建(小型)航天器</a>
      <ul>
        <li><a href="#_炫耀长耳朵">41.1. 炫耀长耳朵</a></li>
        <li><a href="#_类型类型类型">41.2. 类型，类型，类型</a></li>
        <li><a href="#_进步进化序列化">41.3. 进步，进化，序列化！</a></li>
        <li><a href="#_如果有时间进行编码总会有时间进行解码">41.4. 如果有时间进行编码，总会有时间进行解码</a></li>
        <li><a href="#_what_oclock_supply_oclock">41.5. What o’clock? Supply o’clock!</a></li>
      </ul>
    </li>
    <li><a href="#_第十六天_检查你的列表俩次">42. 第十六天 - 检查你的列表俩次</a>
      <ul>
        <li><a href="#_从命令行了解_raku">42.1. 从命令行了解 Raku</a></li>
        <li><a href="#_就像拔牙">42.2. 就像拔牙?</a></li>
        <li><a href="#_一种强大的沉默的类型">42.3. 一种强大的，沉默的类型</a></li>
        <li><a href="#_精灵类型不匹配_弥补改进的错误处理">42.4. 精灵类型不匹配 - 弥补改进的错误处理</a></li>
        <li><a href="#_我们不会去直到我们得到一些">42.5. 我们不会去，直到我们得到一些！</a></li>
        <li><a href="#_跑步者走上了这条路">42.6. 跑步者走上了这条路。</a></li>
      </ul>
    </li>
    <li><a href="#_第17天_通往幸福的编译之路">43. 第17天 - 通往幸福的编译之路</a>
      <ul>
        <li><a href="#_marcus_junius_brute_forcethe_younger">43.1. Marcus Junius Brute Force（The Younger）</a></li>
        <li><a href="#_我让路径遍历少了以及所有其他路径">43.2. 我让路径遍历少了（以及所有其他路径）</a></li>
        <li><a href="#_在方程式中思考">43.3. 在方程式中思考</a></li>
        <li><a href="#_第四语言">43.4. 第四语言</a></li>
        <li><a href="#_结论_5">43.5. 结论</a></li>
      </ul>
    </li>
    <li><a href="#_第十八天_一棵_avg_格式的圣诞树">44. 第十八天 - 一棵 AVG 格式的圣诞树</a>
      <ul>
        <li><a href="#_关于svg并创建它">44.1. 关于SVG并创建它</a></li>
        <li><a href="#_我们抽象吧">44.2. 我们抽象吧！</a></li>
        <li><a href="#_让我们延伸">44.3. 让我们延伸！</a></li>
        <li><a href="#_一个重构点">44.4. 一个重构点</a></li>
        <li><a href="#_一个进一步的抽象">44.5. 一个进一步的抽象</a></li>
        <li><a href="#_最后是我们的树">44.6. 最后是我们的树</a></li>
      </ul>
    </li>
    <li><a href="#_第十九天_交互式桌面应用">45. 第十九天 - 交互式桌面应用</a>
      <ul>
        <li><a href="#_骰子滚动">45.1. 骰子滚动</a></li>
        <li><a href="#_简单的_gtksimple">45.2. 简单的 GTK::Simple</a></li>
        <li><a href="#_网格布局">45.3. 网格布局</a></li>
        <li><a href="#_交互">45.4. 交互</a></li>
        <li><a href="#_把它们放在一起">45.5. 把它们放在一起</a></li>
        <li><a href="#_最后的想法">45.6. 最后的想法</a></li>
      </ul>
    </li>
    <li><a href="#_第二十天_raku_中的命题组合">46. 第二十天 - Raku 中的命题组合</a></li>
    <li><a href="#_你如何以数学方式包装礼物">47. 你如何以数学方式包装礼物？</a>
      <ul>
        <li><a href="#_一个立方体卡罗尔">47.1. 一个立方体卡罗尔</a></li>
        <li><a href="#_sat_a_clause的令人满意的故事">47.2. SAT-a-Clause的令人满意的故事</a></li>
        <li><a href="#_比你想知道的3d礼品包装更多">47.3. 比你想知道的3D礼品包装更多</a></li>
      </ul>
    </li>
    <li><a href="#_把它包起来_2">把它包起来</a>
      <ul>
        <li><a href="#_第二十一天_一个红色的圣诞老人">48. 第二十一天 - 一个红色的圣诞老人</a></li>
        <li><a href="#_第二十二天_测试_cro_http_api">49. 第二十二天 - 测试 Cro HTTP API</a></li>
        <li><a href="#_第二十三天_blin很快就到圣诞节了">50. 第二十三天 - Blin，很快就到圣诞节了！</a></li>
        <li><a href="#_第二十四天_使用_raku_进行主题建模">51. 第二十四天 - 使用 Raku 进行主题建模</a></li>
        <li><a href="#_raku_中的异步和并发入门">52. Raku 中的异步和并发入门</a></li>
        <li><a href="#_promise">53. Promise</a></li>
        <li><a href="#_supply_块">54. Supply 块</a></li>
        <li><a href="#_channel">55. Channel</a></li>
        <li><a href="#_线程">56. 线程</a></li>
        <li><a href="#_raku_调度器">57. Raku 调度器</a></li>
        <li><a href="#_react_块">58. React 块</a></li>
        <li><a href="#_lock_类">59. Lock 类</a></li>
        <li><a href="#_atomic_integer">60. Atomic Integer</a></li>
        <li><a href="#_分而治之模式">61. 分而治之模式</a></li>
        <li><a href="#_并行的_map_reduce_模式">62. 并行的 Map-Reduce 模式</a></li>
        <li><a href="#_保留你的线程或不保留">63. 保留你的线程或不保留</a></li>
        <li><a href="#_监控模式">64. 监控模式</a></li>
        <li><a href="#_比较并交换标量">65. 比较并交换标量</a></li>
        <li><a href="#_拆解异步问题">66. 拆解异步问题</a></li>
        <li><a href="#_信号量">67. 信号量</a></li>
        <li><a href="#_比较_react_与_tap">68. 比较 react 与 tap</a></li>
        <li><a href="#_supply_反压">69. Supply 反压</a></li>
        <li><a href="#_无锁的线程安全结构">70. 无锁的线程安全结构</a></li>
        <li><a href="#_拆解并发问题">71. 拆解并发问题</a></li>
        <li><a href="#_并行循环执行">72. 并行循环执行</a></li>
        <li><a href="#_asynchronous_socket">73. Asynchronous Socket</a></li>
        <li><a href="#_异步锁">74. 异步锁</a></li>
        <li><a href="#_异步进程间通信">75. 异步进程间通信</a></li>
        <li><a href="#_第一天_为什么_raku_是_advent_code_的理想语言">76. 第一天 - 为什么 Raku 是 Advent Code 的理想语言？</a></li>
        <li><a href="#_第二天_perl_is_dead_long_live_perl_and_raku">77. 第二天 - Perl is dead. Long live Perl and Raku.</a></li>
        <li><a href="#_使用_raku_进行文化编程">78. 使用 Raku 进行文化编程</a></li>
        <li><a href="#_第四天_使用_raku_grammars_解析_clojure_命名空间形式">79. 第四天 - 使用 Raku grammars 解析 Clojure 命名空间形式</a></li>
        <li><a href="#_第六天_declarative_apis_easy_peasy_with_raku">80. 第六天 - Declarative APIs, easy peasy with Raku</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div>

</div>

<article class="page__content" >
<div class="sect1">
<h2 id="_第一天_raku_鬼精灵_圣诞节实用指南">1. 第一天 – Raku 鬼精灵: 圣诞节实用指南</h2>
<div class="sectionbody">
<div class="paragraph">
<p>看看他们！同事、朋友和亲近的家人都在开心地笑着。他们都在享受着使用 Raku 的 6.c “圣诞”版编程的乐趣。给力的并发原语, 核心文法, 还有非常棒的对象模型。它让我印象深刻！</p>
</div>
<div class="paragraph">
<p>但是等一下…​ 就一秒。我有个想法。一个可怕的想法。我想到了一个鬼主意! 我们可以在他们的&#34;圣诞&#34;上捣乱。需要的只有一点花招。哈哈哈哈哈哈！！</p>
</div>
<div class="paragraph">
<p>欢迎来到 2017 年的 Raku 圣诞日历！每天，从今天直到圣诞节，我们都会有一篇很赞的关于 Raku 的博客推送到你面前。</p>
</div>
<div class="paragraph">
<p>今天，我们会展示我们淘气的一面并且故意地做些淘气的事情。确实，这有点用，但是淘气点更快乐。我们开始吧！</p>
</div>
<div class="sect2">
<h3 id="_but_true_does_false">1.1. But True does False</h3>
<div class="paragraph">
<p>你听过 <code>but</code> 操作符吗？一个好玩的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say True but False ?? &#39;Tis true&#39; !! &#39;Tis false&#39;;
# OUTPUT: «Tis false␤»

my  $n = 42 but &#39;forty two&#39;;
say $n;     # OUTPUT: «forty two␤»
say $n + 7; # OUTPUT: «49␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>它是一个中缀操作符，它首先拷贝它左边的对象，然后把它右边提供的 role 混进这个拷贝中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = 42 but role Evener {
    method is-even { self %% 2 }
}
say $n.is-even; # OUTPUT: «True␤»
say $n.^name;   # OUTPUT: «Int+{Evener}␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的前俩个例子中的那些不是 roles。<code>but</code> 操作符有种便捷的写法：如果 but 右边的东西不是 role，它就会给你创建一个！那个 role 只会有一个方法，以右侧对象的 <code>^name</code> 命名，并且那个方法只会简单地返回那个给定的对象。因此，这…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put True but &#39;some boolean&#39;; # OUTPUT: «some boolean␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>等价于：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put True but role {
    method ::(BEGIN &#39;some boolean&#39;.^name) {
        &#39;some boolean&#39;
    }
} # OUTPUT: «some boolean␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.^name</code> 在我们的字符串上返回 <code>Str</code>， 因为它是一个 <code>Str</code> 对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;some boolean&#39;.^name;  # OUTPUT: «Str␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以那个 role 提供了一个叫做 <code>Str</code> 的方法, 在非 <code>Str</code> 对象上调用该方法以获取字符串值的输出, 使我们的布尔值变成修改过的字符串化的表示。</p>
</div>
<div class="paragraph">
<p>举个例子，字符串 <code>0</code> 在 Rakudo Raku 中是 <code>True</code> 但是在 Perl 5 中是 <code>False</code>。使用 <code>but</code> 操作符, 我们能修改字符串的行为，让它表现的像 Perl 5 版本那样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Perl5Str {
    method Bool {
        nextsame unless self eq &#39;0&#39;;
        False
    }
}
sub perlify { $^v but Perl5Str };

say so perlify &#39;meows&#39;; # OUTPUT: «True␤»
say so perlify &#39;0&#39;;     # OUTPUT: «False␤»
say so perlify &#39;&#39;;      # OUTPUT: «False␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Perl5Str</code> 这个 role 提供了供 <code>so</code>  子例程调用的  <code>.Bool</code> 方法。在这个方法里面，我们使用 <code>nextsame</code> 子例程重新分派了原来的 <code>.Bool</code> 方法，除非那个字符串是 <code>0</code>, 那时我们仅仅返回 <code>False</code>。</p>
</div>
<div class="paragraph">
<p><code>but</code> 操作符有一个兄弟： <code>does</code> 中缀操作符。它们的行为相似，但是它不拷贝。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $o = class { method stuff { &#39;original&#39; } }.new;
say $o.stuff;  # OUTPUT: «original␤»

$o does role { method stuff { &#39;modded&#39; } };
say $o.stuff; # OUTPUT: «modded␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序中的某些东西是全局可访问的，而在有些实现（例如 Rakudo）中，某些常量被缓存了。这意味着我们可以在程序的不同部分变得很淘气，而那些圣诞节的庆祝者们甚至不知道发生了什么！</p>
</div>
<div class="paragraph">
<p>假如我们覆写了 <code>prompt</code> 子例程的读方法会怎么样？他们喜欢圣诞节？我们来给他们一些圣诞树：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$*IN does role { method get { &#34;🎄 {callsame} 🎄&#34; } }

my $name = prompt &#34;Enter your name: &#34;;
say &#34;You entered your name as: $name&#34;;

# OUTPUT
# Enter your name: (typed by user:) Zoffix Znet
# You entered your name as: 🎄 Zoffix Znet 🎄</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使我们把代码粘贴到模块中该覆盖也会起作用。 我们也可以把它提升一个档次，弄乱枚举和缓存的常量，虽然这个顽皮的举动可能将无法跨越模块边界和其他特定实现的缓存失效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">True does False;
say 42 ?? &#34;tis true&#34; !! &#34;tis false&#34;;
# OUTPUT: «tis true␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>到目前为止，这还没有达到想要的效果，但是让我们试着把我们的数字强制为 <code>Bool</code> 值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">True does False;
say 42.Bool ?? &#34;tis true&#34; !! &#34;tis false&#34;;
# OUTPUT: «tis false␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们做到了！ 而现在，对于最后的格林奇 - 值得接触，我们将混淆数字计算的数值结果。 Rakudo 缓存 <code>Int</code> 常量。 当用不同类型的数字计算时，Infix <code>+</code> 运算符也使用 <a href="https://github.com/raku/doc/issues/1690">internal-ish-ish</a> <code>.Bridge</code> 方法。 所以，让我们重写常量上的 <code>.Bridge</code> 来返回一些奇怪的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">BEGIN 42 does role { method Bridge { 12e0 } }
say 42 + 15;   # OUTPUT: «57␤»
say 42 + 15e0; # OUTPUT: «27␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是善意的邪恶，肯定会毁了圣诞节，但这只是开始…​</p>
</div>
</div>
<div class="sect2">
<h3 id="_wrapping_it_up">1.2. Wrapping It Up</h3>
<div class="paragraph">
<p>没有包装的礼物，会是什么样的圣诞节？ 哦，对于礼物，我们将有 Raku 的 <a href="https://docs.raku.org/type/Routine">Routine</a> 类型的 <a href="https://docs.raku.org/routine/wrap">.wrap</a> 方法包装他们，哦，太好了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use soft;
sub foo { say &#39;in foo&#39; }
&amp;foo.wrap: -&gt; | {
    say &#39;in the wrap&#39;;
    callsame;
    say &#39;back in the wrap&#39;;
}
foo;

# OUTPUT:
# in the wrap
# in foo
# back in the wrap</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用 <code>use soft</code> 编译指令来防止不必要的内联，否则这些内联会干扰我们的包装。然后，我们使用一个我们想要包装成一个名词的例程，通过它和 <code>＆</code> sigil 来使用它，并调用带有一个<a href="https://docs.raku.org/type/Callable"><code>Callable</code></a>的 <a href="https://docs.raku.org/routine/wrap"><code>.wrap</code></a> 方法。</p>
</div>
<div class="paragraph">
<p>给定的 <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a> 的签名必须与包装的例程（或其 <code>proto</code> 原型，如果它是一个 multi）兼容;否则我们将无法正确调度程序并使用参数调用包装器。在上面的例子中，我们只是使用匿名的 <a href="https://docs.raku.org/type/Capture"><code>Capture</code></a>（<code>|</code>）来接受所有可能的参数。</p>
</div>
<div class="paragraph">
<p>在 <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a> 里面，我们有两个 <a href="https://docs.raku.org/routine/say"><code>say</code></a> 调用，并使用 <a href="https://rakudo.party/post/Raku-But-Heres-My-Dispatch-So-Callwith-Maybe">callsame</a> 例程来调用下一个可用的调度候选者，这正好是我们原来的例程。这很方便，因为我们试图在包装器中按照它的名字来调用 <code>foo</code> ，我们将从头开始调度，导致无限的调度循环。</p>
</div>
<div class="paragraph">
<p>既然方法是 <a href="https://docs.raku.org/type/Routine">Routine</a>，我们也可以把它们包装起来。我们可以使用 <code>.^lookup</code> 元方法来获取 <a href="https://docs.raku.org/type/Method"><code>Method</code></a> 对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">IO::Handle.^lookup(&#39;print&#39;).wrap: my method (|c) {
    my &amp;wrapee = nextcallee;
    wrapee self, &#34;🎄 Ho-ho-ho! 🎄\n&#34;;
    wrapee self, |c
};

print &#34;Hello, World!\n&#34;;

# OUTPUT:
# 🎄 Ho-ho-ho! 🎄
# Hello, World!</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们从 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 类型中获取 <a href="https://docs.raku.org/routine/print">.print</a> 方法，然后包装它。我们希望在方法内部使用 <code>self</code>，所以我们使用独立的方法（<code>my method …</code>）来代替块或子例程。我们想使用 <code>self</code> 的原因是能够调用我们包装的方法来打印我们的 Christmassy 消息。因为我们的方法是分离的，<a href="https://rakudo.party/post/Raku-But-Heres-My-Dispatch-So-Callwith-Maybe">callwith</a> 和相关的例程将需要与其他参数一起自我馈送，以确保我们继续分派给正确的对象。</p>
</div>
<div class="paragraph">
<p>在 wrap 中，我们使用 <code>nextcallee</code> 例程来获得原始的方法。如果它是一个 <code>multi</code>，我们将得到 <code>proto</code>，而不是一个与原始参数最匹配的特定候选者，所以相比传统的例程，下一个 <a href="https://rakudo.party/post/Raku-But-Heres-My-Dispatch-So-Callwith-Maybe#haveyoutriedtocallthemwith…​">candidate ordering</a> 候选排序在 wrap 中略有不同。我们把 <code>nextcallee</code> 放到一个变量中，因为我们想多次调用它，调用它将例程从调度栈中移出。在第一个调用中，我们打印了我们的 Christmass 信息，而在第二个调用中，我们只是 slip 我们的原始参数的 <a href="https://docs.raku.org/type/Capture">Capture</a>（<code>|c</code>），完成了原来想要发生的调用。</p>
</div>
<div class="paragraph">
<p>感谢 <a href="https://docs.raku.org/routine/wrap">.wrap</a>，我们可以改变甚至完全重新定义子程序和方法的行为，当你的朋友尝试使用它们的时候肯定会很快乐。哈哈哈！</p>
</div>
</div>
<div class="sect2">
<h3 id="_看不见的斗篷">1.3. 看不见的斗篷</h3>
<div class="paragraph">
<p>我们到目前为止所玩的技巧是非常可怕的，但它们太明显，太…​明显。 由于 Raku 具有极好的 Unicode 支持，所以我认为我们应该搜索大量的 Unicode 字符来获得一些有趣的恶作剧。 特别是，我们正在寻找不是空白的隐形字符。 我们的目的只有一个就足够了，但是这四个在我的电脑上是相当隐蔽的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[⁠] U+2060 WORD JOINER [Cf]
[⁡] U+2061 FUNCTION APPLICATION [Cf]
[⁢] U+2062 INVISIBLE TIMES [Cf]
[⁣] U+2063 INVISIBLE SEPARATOR [Cf]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 支持可以由任何字符组成的自定义术语和操作符，除了空格之外。 例如，这是我的专利耸肩操作符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;¯\(°_o)/¯&gt; {
    ($^a, $^b).pick
}

say &#39;Coke&#39; ¯\(°_o)/¯ &#39;Pepsi&#39;;
# OUTPUT: «Pepsi␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个由非标识字符组成的术语（我们也可以在定义中使用真实的字符）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub term:«\c[family: woman woman boy boy]» {
    &#39;♫ We— are— ♪ faaaamillyyy ♬&#39;
}
say 👩‍👩‍👦‍👦;
# OUTPUT: «♫ We— are— ♪ faaaamillyyy ♬»</code></pre>
</div>
</div>
<div class="paragraph">
<p>用我们看不见的非空白字符，我们可以使无形的操作符和术语！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:«\c[INVISIBLE TIMES]» { $^a × $^b }
my \r = 42;

say &#34;Area of the circle is &#34; ~ π⁢r²;
# OUTPUT: «Area of the circle is 5541.76944093239␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们来创建一个 <code>Jolly</code> 模块，它将导出一些不可见的术语和操作符。 然后我们把它们撒在我们的 Christmassy朋友的代码中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module Jolly;

sub   term:«\c[INVISIBLE TIMES]» is export { 42 }
sub  infix:«\c[INVISIBLE TIMES]» is export {
    $^a × $^b
}
sub prefix:«\c[INVISIBLE SEPARATOR]» (|)
    is looser(&amp;[,]) is export
{
    say &#34;Ho-ho-ho!&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们对术语和中缀操作符使用了相同的字符。 这很好，因为 Raku 对操作符有相当严格的期望，反之亦然，所以它会知道我们什么时候使用该术语或何时使用中缀操作符。 下面是由此产生的 Grinch 代码，以及它产生的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">⁣say 42⁢⁢;

# OUTPUT:
# 1764
# Ho-ho-ho!</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将确保调试的乐趣！ 以下是该行代码中的字符列表，供您查看我们使用隐形好东西的位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for &#39;⁣say 42⁢⁢;&#39;.uninames;

# OUTPUT:
# INVISIBLE SEPARATOR
# LATIN SMALL LETTER S
# LATIN SMALL LETTER A
# LATIN SMALL LETTER Y
# SPACE
# DIGIT FOUR
# DIGIT TWO
# INVISIBLE TIMES
# INVISIBLE TIMES
# SEMICOLON</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ho_ho_ho">1.4. Ho-Ho-Ho</h3>
<div class="paragraph">
<p>圣诞节时的生产力下降到停滞状态。 人们心中都有节日和新年。 在所有代码中看到大量的 TODO 注释并不让我感到惊讶。 但是如果我们能够发现并投诉他们呢？ 只要有人感到懒惰，没有什么比 Grinch 更像编程了！</p>
</div>
<div class="paragraph">
<p>Raku 有俚语。 这是一个实验性的功能，目前还没有一个官方支持的接口，但是，对于我们的目的来说，它会做的很好。</p>
</div>
<div class="paragraph">
<p>使用俚语，可以在词法上改变 Raku 的文法，并引入语言特性和行为，就像 Raku 核心开发者一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">BEGIN $*LANG.refine_slang: &#39;MAIN&#39;,
    role SomeExtraGrammar {
        token term:sym&lt;meow&gt; {
            &#39;This is not a syntax error&#39;
        }
    },
    role SomeExtraActions {
        method EXPR (Mu $/) {
            say &#34;Parsed expression: &#34; ~ $/;
            nextsame
        }
    }

This is not a syntax error;
say &#39;hehe&#39;

# OUTPUT:
# Parsed expression: This is not a syntax error
# Parsed expression: &#39;hehe&#39;
# Parsed expression: say &#39;hehe&#39;
# hehe</code></pre>
</div>
</div>
<div class="paragraph">
<p>俚语功能的“实验性”部分主要在于不得不依靠 <a href="https://github.com/rakudo/rakudo/blob/master/src/Raku/Grammar.nqp">core Grammar</a> 和 <a href="https://github.com/rakudo/rakudo/blob/master/src/Raku/Actions.nqp">core Actions</a> 的结构;目前没有官方保证这些将保持不变，这使得俚语变得脆弱。</p>
</div>
<div class="paragraph">
<p>对于我们调皮的 Grinchy 技巧，我们将修改注释的行为，如果我们读取代码来追踪调用 <a href="https://github.com/rakudo/rakudo/blob/79390147ac6b874f7c01c5818520cc5b31bde042/src/Raku/Grammar.nqp#L700-L702">the comment token</a> 的代码，我们会发现它实际上是重新定义的 <a href="https://github.com/rakudo/rakudo/blob/79390147ac6b874f7c01c5818520cc5b31bde042/src/Raku/Grammar.nqp#L652-L666">ws</a> token 的一部分，正如您可能从每天都知道的 Raku 文法除其他外，负责语法规则中的空白匹配。</p>
</div>
<div class="paragraph">
<p>这个问题稍微复杂一些，因为 <code>ws</code> 是一个基石标记，与 <code>comp_unit</code>，<code>statementlist</code> 和 <code>statement</code> 一起，它不能在 mainline（例程和块之外的代码）中修改。原因是在使用这些令牌的股票版本解析主线之后，俚语被加载。<code>statement</code>  token 内的标记甚至可以在 mainline 中更改，因为 <code>statement</code>  标记会 reblesses 文法，但是 <code>ws</code> 不会获得如此的奢侈。</p>
</div>
<div class="paragraph">
<p>既然我们已经开始深入到底了…​…​足够的话了！我们来写代码吧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">BEGIN $*LANG.refine_slang: &#39;MAIN&#39;, role {
    token comment:sym&lt;todo&gt; {
        &#39;#&#39; \s* &#39;TODO&#39; &#39;:&#39;? \s+ &lt;( \N*
        { die &#34;Ho-ho-ho! I think you were&#34;
            ~ &#34; meant to finish &#34; ~ $/ }
    }
}

sub business-stuff {
    # TODO: business stuff
}

# OUTPUT:
# ===SORRY!===
# Ho-ho-ho! I think you were meant to finish business stuff</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用 <a href="https://docs.raku.org/language/phasers">BEGIN phaser</a> 在编译时进行俚语修改，因为我们试图影响如何进一步编译。</p>
</div>
<div class="paragraph">
<p>我们添加了一个新的 <code>proto</code> 标记： <code>comment:sym&lt;todo&gt;</code> 到核心 Raku 文法，匹配类似于常规注释匹配的内容，除了它还寻找我们的 Christmassy 朋友决定离开的 <code>TODO</code>。 <code>\N*</code> 原子捕获用户在 <code>TODO</code> 之后键入的字符串，匹配捕获标记指示编译器将存储在 <code>$/</code> 变量中的匹配对象内的捕获文本中的以前匹配的东西排除在外。</p>
</div>
<div class="paragraph">
<p>在 token 的末尾，我们简单地使用一个代码块来告诉用户完成他们的 TODO 的消息。 很狡猾！</p>
</div>
<div class="paragraph">
<p>由于我们宁愿用户不注意我们的诡计，让我们将俚语粘贴到目标代码将要加载的模块中。 我们只是稍微调整一下原来的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># File: ./Jolly.pm6
sub EXPORT {
    $*LANG.refine_slang: &#39;MAIN&#39;, role {
        token comment:sym&lt;todo&gt; {
            &#39;#&#39; \s* &#39;TODO&#39; &#39;:&#39;? \s+ &lt;( \N*
            { die &#34;Ho-ho-ho! I think you were&#34;
                ~ &#34; meant to finish &#34; ~ $/ }
        }
    }

    Map.new
}

# File: ./script.p6
use lib &lt;.&gt;;
use Jolly;

sub business-stuff {
    # TODO: business stuff
}

# OUTPUT:
# ===SORRY!===
# Ho-ho-ho! I think you were meant to finish business stuff</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们希望俚语在脚本的编译时运行，而不是在模块中，所以我们删除了 <code>BEGIN</code> phaser，而是将代码固定在 <a href="https://docs.raku.org/language/modules#index-entry-sub_EXPORT">sub EXPORT</a> 中，在脚本编译过程中使用该模块时运行。 <code>Map.new</code> 就是我喜欢在 <code>EXPORT</code>  sub 中写 <code>{}</code>，以表示我们不希望导出任何符号。 在我们的脚本中，我们现在只需要使用模块，俚语被激活。真棒！</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论">1.5. 结论</h3>
<div class="paragraph">
<p>今天，我们开始淘气的 Grinches 2017 年的 Raku 的降临日历和搞乱用户的程序。 我们使用 <code>but`和 `does</code> 操作符来改变对象。 包装的方法和子程序与我们的自定义例程，实现额外的功能。 做出隐形术语和操作符。 甚至突变语言本身来做我们的竞标。</p>
</div>
<div class="paragraph">
<p>在接下来的 23 天里，我们会看到更多的 Raku Advent 文章，所以一定要回头看看。 也许，到这一切的尽头，我们的 Grinchy 心将长大三个尺寸…​</p>
</div>
<div class="paragraph">
<p>-Ofun</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二天_raku_符号_变量和容器">2. 第二天-Raku: 符号, 变量和容器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>对容器的基本理解对于在 Raku 中进行愉快的编程是至关重要的。它们无处不在，不仅影响你获得的变量类型，还决定了 <a href="https://docs.raku.org/type/List"><code>List</code></a> 和 <a href="https://docs.raku.org/type/Map"><code>Map</code></a> 在迭代时的行为方式。</p>
</div>
<div class="paragraph">
<p>今天，我们将学习什么是容器，以及如何使用它们，但是首先，我希望你暂时忘记你对 Raku 的符号和变量的所有知识或怀疑，特别是如果你来自 Perl 5 的背景。 忘记一切。</p>
</div>
<div class="sect2">
<h3 id="_把钱拿出来">2.1. 把钱拿出来</h3>
<div class="paragraph">
<p>在 Raku 中，变量以 <code>$</code> 符号为前缀，用绑定运算符（<code>:=</code>）赋值。 像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $foo := 42;
say &#34;The value is $foo&#34;; # OUTPUT: «The value is 42␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你已经按照我的建议来忘记你所知道的一切，那么学习 <a href="https://docs.raku.org/type/List"><code>List</code></a> 和 <a href="https://docs.raku.org/type/Hash"><code>Hash</code></a> 类型也是一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $ordered-things := &lt;foo bar ber&gt;;
my $named-things   := %(:42foo, :bar&lt;ber&gt;);

say &#34;$named-things&lt;foo&gt; bottles of $ordered-things[2] on the wall&#34;;
# OUTPUT: «42 bottles of ber on the wall␤»

.say for $ordered-things;  # OUTPUT: «foo␤bar␤ber␤»
.say for $named-things;    # OUTPUT: «bar =&gt; ber␤foo =&gt; 42␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>了解这一点，你可以写出各种各样的程序，所以如果你开始觉得有太多的东西需要学习，记住你不需要一次学习所有东西。</p>
</div>
</div>
<div class="sect2">
<h3 id="_我们祝你有一个愉快的列表圣诞">2.2. 我们祝你有一个愉快的列表圣诞</h3>
<div class="paragraph">
<p>让我们试着用我们的变量做更多的事情。 想要更改列表中的值并不罕见。 到目前为止我们的表现如何呢？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list := (1, 2, 3);
$list[0] := 100;
# OUTPUT: «Cannot use bind operator with this left-hand side […] »</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管我们可以绑定到变量，但是如果我们试图绑定到某个值，我们会得到一个错误，无论这个值是来自 <a href="https://docs.raku.org/type/List"><code>List</code></a> 还是只是一个字面值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1 := 100;
# OUTPUT: «Cannot use bind operator with this left-hand side […] »</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是为什么列表是不可变的。 然而，这是一个实现愿望的季节，所以我们希望有一个可变的<a href="https://docs.raku.org/type/List"><code>List</code></a>！</p>
</div>
<div class="paragraph">
<p>我们需要掌握的是一个 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 对象，因为绑定操作符可以使用它。 顾名思义，一个 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 存储一个东西。 你不能通过 <a href="https://docs.raku.org/routine/new"><code>.new</code></a> 方法实例化一个 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a>，但是我们可以通过声明一些词法变量来得到它们。 不需要费心给他们的名字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list := (my $, my $, my $);
$list[0] := 100;
say $list; # OUTPUT: «(100 (Any) (Any))␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出中的 <code>(Any)</code> 是容器的默认值（稍后一点）。 上面，似乎我们设法在 <a href="https://docs.raku.org/type/List"><code>List</code></a> 创建后将一个值绑定到列表的元素上，我们不是吗？ 确实我们做了，但是…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list := (my $, my $, my $);
$list[0] := 100;
$list[0] := 200;
# OUTPUT: «Cannot use bind operator with this left-hand side […] »</code></pre>
</div>
</div>
<div class="paragraph">
<p>绑定操作用一个新的值（<code>100</code>）代替 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器，所以如果我们试图再次绑定，我们又回到了原来的方括号那个，试图绑定到一个值，而不是一个容器。</p>
</div>
<div class="paragraph">
<p>我们需要一个更好的工具。</p>
</div>
</div>
<div class="sect2">
<h3 id="_thats_your_assignment">2.3. That’s Your Assignment</h3>
<div class="paragraph">
<p>绑定运算符有一个表亲：赋值运算符（<code>=</code>）。 我们不用一个绑定操作符替换我们的 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器，而是使用赋值操作符来赋值或者“存储”我们在容器中的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list := (my $ = 1, my $ = 2, my $ = 3);
$list[0] = 100;
$list[0] = 200;
say $list;
# OUTPUT: «(200 2 3)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以从一开始就指定我们的原始值，并且可以随时用其他值替换它们。 我们甚至可以变得时髦，并在每个容器上放置不同的类型约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list := (my Int $ = 1, my Str $ = &#39;2&#39;, my Rat $ = 3.0);
$list[0] = 100; # OK!
$list[1] = 42;  # Typecheck failure!

# OUTPUT: «Type check failed in assignment;
#    expected Str but got Int (42) […] »</code></pre>
</div>
</div>
<div class="paragraph">
<p>这有些放纵，但有一件事可以使用类型约束：<code>$list</code> 变量。 我们将其限制为 <a href="https://docs.raku.org/type/Positional"><code>Positional</code></a> 角色，以确保它只能保持 <a href="https://docs.raku.org/type/Positional"><code>Positional</code></a> 类型，就像 <a href="https://docs.raku.org/type/List"><code>List</code></a> 和 <a href="https://docs.raku.org/type/Array"><code>Array</code></a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Positional $list := (my $ = 1, my $ = &#39;2&#39;, my $ = 3.0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>不知你咋想的，但是这对我来说看起来非常冗长。 幸运的是，Raku 有语法来简化它！</p>
</div>
</div>
<div class="sect2">
<h3 id="_positionlly">2.4. Position@lly</h3>
<div class="paragraph">
<p>首先，让我们摆脱变量的显式类型约束。 在 Raku 中，您可以使用 <code>@</code> 而不是 <code>$</code> 作为符号来表示您希望变量受到角色 <a href="https://docs.raku.org/type/Positional"><code>Positional</code></a> 的类型约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @list := 42;
# OUTPUT: «Type check failed in binding;
#   expected Positional but got Int (42) […] »</code></pre>
</div>
</div>
<div class="paragraph">
<p>其次，我们将使用方括号来代替圆括号来存储我们的 <a href="https://docs.raku.org/type/List"><code>List</code></a>。 这告诉编译器创建一个 <a href="https://docs.raku.org/type/Array"><code>Array</code></a> 而不是一个 <a href="https://docs.raku.org/type/List"><code>List</code></a>。 <a href="https://docs.raku.org/type/Array"><code>Array</code></a>s 是可变的，它们将每个元素自动粘贴到 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器中，就像我们在前一节中手动操作一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @list := [1, &#39;2&#39;, 3.0];
@list[0] = 100;
@list[0] = 200;
say @list;
# OUTPUT: «[200 2 3]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的代码变得更短了，但我们可以折腾更多的字符。 就像赋值给`$<code>-sigiled 变量而不是绑定一样，你可以赋值给</code>@` -sigiled 变量来获得一个自由的 <a href="https://docs.raku.org/type/Array"><code>Array</code></a>。 如果我们切换到赋值，我们可以完全摆脱方括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @list = 1, &#39;2&#39;, 3.0;</code></pre>
</div>
</div>
<div class="paragraph">
<p>好，简洁。</p>
</div>
<div class="paragraph">
<p>类似的想法背后是 <code>％</code> - 和 <code>&amp;</code> 符号化的变量。 <code>％</code> sigil 意味着 <a href="https://docs.raku.org/type/Associative"><code>Associative</code></a> 角色的类型约束，并为赋值提供相同的快捷方式（给你一个 <a href="https://docs.raku.org/type/Hash"><code>Hash</code></a>），并为这些值创建 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器。 对于角色 <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a> 和赋值的 <code>＆</code>-sigiled变量类型 - 行为类似于 <code>$</code> sigils，给出一个可以修改其值的自由 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my  %hash = :42foo, :bar&lt;ber&gt;;
say %hash;  # OUTPUT: «{bar =&gt; ber, foo =&gt; 42}␤»

my &amp;reversay = sub { $^text.flip.say }
reversay &#39;6 lreP ♥ I&#39;; # OUTPUT: «I ♥ Raku␤»

# store a different Callable in the same variable
&amp;reversay = *.uc.say;  # a WhateverCode object
reversay &#39;I ♥ Raku&#39;; # OUTPUT: «I ♥ PERL 6␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_one_and_only">2.5. The One and Only</h3>
<div class="paragraph">
<p>之前我们知道赋值给 <code>$</code> -sigiled 变量会给你一个免费的 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器。 由于标量，顾名思义，只包含一个东西…​…​如果你把一个 <a href="https://docs.raku.org/type/List"><code>List</code></a> 放到 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 中会发生什么？ 毕竟，当你试图这样做的时候，宇宙仍然没有被扼杀：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my  $listish = (1, 2, 3);
say $listish; # OUTPUT: «(1 2 3)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样的行为可能使 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 看起来似乎是一个用词不当，但它确实把整个列表视为一个东西。 我们可以通过几种方式观察其差异。 我们来比较绑定到 <code>$</code> -sigiled 变量的 <a href="https://docs.raku.org/type/List"><code>List</code></a>（所以不包含 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a>）和赋值给 <code>$</code> -sigiled 变量（自动 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器）的 <a href="https://docs.raku.org/type/List"><code>List</code></a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Binding:
my  $list := (1, 2, 3);
say $list.perl;
say &#34;Item: $_&#34; for $list;

# OUTPUT:
# (1, 2, 3)
# Item: 1
# Item: 2
# Item: 3


# Assignment:
my $listish = (1, 2, 3);
say $listish.perl;
say &#34;Item: $_&#34; for $listish;

# OUTPUT:
# $(1, 2, 3)
# Item: 1 2 3</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/routine/perl"><code>.perl</code></a> 方法给了我们一个额外的见解，并在第二个 <a href="https://docs.raku.org/type/List"><code>List</code></a> 之前显示了一个 <code>$</code>，以表明它在 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 中是集装箱化的。 更重要的是，当我们用 <code>for</code> 循环迭代我们的 <a href="https://docs.raku.org/type/List"><code>List</code></a>s 时，第二个 <a href="https://docs.raku.org/type/List"><code>List</code></a> 结果只有一个迭代：整个 <a href="https://docs.raku.org/type/List"><code>List</code></a> 作为一个项目！ <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 没有辜负它的名字。</p>
</div>
<div class="paragraph">
<p>这种行为不仅仅是学术上的兴趣。 回想一下，<a href="https://docs.raku.org/type/Array"><code>Array</code></a>s（和<a href="https://docs.raku.org/type/Hash"><code>Hash</code></a>es）为它们的值创建<a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器。 这意味着如果我们嵌套东西，即使我们选择一个单独的列表或散列在里面存储着 <a href="https://docs.raku.org/type/Array"><code>Array</code></a>（或 <a href="https://docs.raku.org/type/Hash"><code>Hash</code></a>），并试图迭代它，它将只被视为一个单一的项目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @stuff = (1, 2, 3), %(:42foo, :70bar);
say &#34;List Item: $_&#34; for @stuff[0];
say &#34;Hash Item: $_&#34; for @stuff[1];

# OUTPUT:
# List Item: 1 2 3
# Hash Item: bar  70
# foo 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样的推理（即 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器中的列表和散列是单个项目）适用于当您试图压扁 <a href="https://docs.raku.org/type/Array"><code>Array</code></a> 的元素或将它们作为参数传递给 <a href="https://docs.raku.org/type/Signature#index-entry-parameter_%2A%40-parameter_%2A%2525_slurpy_argument_%28Signature%29-Slurpy_%28A.K.A._Variadic%29_Parameters">slurpy</a> 参数时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @stuff = (1, 2, 3), %(:42foo, :70bar);
say flat @stuff;
# OUTPUT: «((1 2 3) {bar =&gt; 70, foo =&gt; 42})␤»

-&gt; *@args { @args.say }(@stuff)
# OUTPUT: «[(1 2 3) {bar =&gt; 70, foo =&gt; 42}]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>正是这种行为可以将 Raku 初学者推上墙，特别是那些来自 Perl 5 自动展平语言的人。然而，现在我们知道为什么会出现这种行为，我们可以改变它！</p>
</div>
</div>
<div class="sect2">
<h3 id="_decont">2.6. Decont</h3>
<div class="paragraph">
<p>如果 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器是罪魁祸首，我们所要做的就是删除它。 我们需要将我们的列表和哈希值去容器化，或者简称为 “decont”。 在你的 Raku 之旅中，你可以找到几种方法来完成这个工作，但是为此设计的一个方法就是 decont methodop（<code>&lt;&gt;</code>）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @stuff = (1, 2, 3), %(:42foo, :70bar);
say &#34;Item: $_&#34; for @stuff[0]&lt;&gt;;
say &#34;Item: $_&#34; for @stuff[1]&lt;&gt;;

# OUTPUT:
# Item: 1
# Item: 2
# Item: 3
# Item: bar   70
# Item: foo   42</code></pre>
</div>
</div>
<div class="paragraph">
<p>它很容易记住：它看起来像一个被挤压的盒子（一个被踩踏的容器）。 在通过索引到 <a href="https://docs.raku.org/type/Array"><code>Array</code></a> 中检索我们的容器化项目之后，我们附加了 decont 并从 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器中移除了内容，导致我们的循环遍历它们中的每个项目。</p>
</div>
<div class="paragraph">
<p>如果您希望一次去除 <a href="https://docs.raku.org/type/Array"><code>Array</code></a> 中的每个元素，只需使用超运算符（<code>»</code>，或 <code>&gt;&gt;</code>，如果您更喜欢使用 ASCII）就可以使用 decont：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @stuff = (1, 2, 3), %(:42foo, :70bar);
say flat @stuff»&lt;&gt;;
# OUTPUT: «(1 2 3 bar =&gt; 70 foo =&gt; 42)␤»

-&gt; *@args { @args.say }(@stuff»&lt;&gt;)
# OUTPUT: «[1 2 3 bar =&gt; 70 foo =&gt; 42]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>随着容器被删除，我们的列表和散列就像我们想要的那样变平。 当然，我们可以避免使用 <a href="https://docs.raku.org/type/Array"><code>Array</code></a>，而将原始 <a href="https://docs.raku.org/type/List"><code>List</code></a> 绑定到变量上。 由于 <a href="https://docs.raku.org/type/List"><code>List</code></a> 没有把它们的元素放入容器，所以没有任何东西可以去除：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @stuff := (1, 2, 3), %(:42foo, :70bar);
say flat @stuff;
# OUTPUT: «(1 2 3 bar =&gt; 70 foo =&gt; 42)␤»

-&gt; *@args { @args.say }(@stuff)
# OUTPUT: «[1 2 3 bar =&gt; 70 foo =&gt; 42]␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_不要让它溜走">2.7. 不要让它溜走</h3>
<div class="paragraph">
<p>当我们在这里的时候，值得注意的是，当他们想要执行decont（我们不是在传递参数给 <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a> 的时候使用它）时，许多人使用 *slip*运算符（<code>|</code>）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @stuff = (1, 2, 3), (4, 5);
say &#34;Item: $_&#34; for |@stuff[0];

# OUTPUT:
# Item: 1
# Item: 2
# Item: 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然它可以完成工作，但可能会引入微妙的 bugs，这些 bug 可能很难追查到。 尝试在这里找到一个，在一个程序中迭代了一个无限的非负整数列表，并打印那些素数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $primes = ^∞ .grep: *.is-prime;
say &#34;$_ is a prime number&#34; for |$primes;</code></pre>
</div>
</div>
<div class="paragraph">
<p>放弃？ 这个程序会导致内存泄漏…​ 非常缓慢。 尽管我们遍历了无限的项目列表，但这不是问题，因为 <a href="https://docs.raku.org/routine/grep"><code>.grep</code></a> 方法返回的 <a href="https://docs.raku.org/type/Seq"><code>Seq</code></a> 对象不会保留已经迭代的项目，因此内存使用永远不会增长。</p>
</div>
<div class="paragraph">
<p>有问题的部分是我们的 <code>|</code>  slip 操作符。 它将我们的 <a href="https://docs.raku.org/type/Seq"><code>Seq</code></a> 转换成一个 <a href="https://docs.raku.org/type/Slip"><code>Slip</code></a> ，这是一个 <a href="https://docs.raku.org/type/List"><code>List</code></a> 类型，并且保存我们已经消耗的所有的值。 如果您希望在 <a href="http://hisham.hm/htop/"><code>htop</code></a> 中看到增长，那么这个程序的修改版本会更快地增长：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># CAREFUL! Don&#39;t consume all of your resources!
my $primes = ^∞ .map: *.self;
Nil for |$primes;</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们再试一次，但是这次使用 decont 方法 op：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $primes = ^∞ .map: *.self;
Nil for $primes&lt;&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>内存使用现在是稳定的，程序可以坐在那里迭代直到时间结束。 当然，因为我们知道这是 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器导致的容器化，我们希望在这里避免它，所以我们可以简单地将 <a href="https://docs.raku.org/type/Seq"><code>Seq</code></a> 绑定到变量上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $primes := ^∞ .map: *.self;
Nil for $primes;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_i_want_less">2.8. I Want Less</h3>
<div class="paragraph">
<p>如果你讨厌符号，Raku 会得到一些你可以微笑的东西：无符号的变量。 只要在声明中加一个反斜杠的前缀，表示你不想要讨厌的符号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my \Δ = 42;
say Δ²; # OUTPUT: «1764␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>你不会得到任何这样的变量的自由 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a>，因此，在声明期间，绑定或赋值给他们没有任何区别。 它们的行为类似于将值绑定到 <code>$</code> -sigiled 变量的行为，包括绑定 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a>s 并使变量可变：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my \Δ = my $ = 42;
Δ = 11;
say Δ²; # OUTPUT: «121␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个更常见的地方，你可能会看到这样的变量是作为例程的参数，在这里，这意味着你想把 <code>is raw</code> trait 应用到参数上。 这在 <a href="https://docs.raku.org/type/Signature#index-entry-%2B_%28Single_Argument_Rule_Slurpy%29"><code>+</code> positional slurpy</a> 参数的含义也是存在的（不需要反斜杠），如果它是 <code>is raw</code> 的，意味着你将不会得到不需要的 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器，因为它是一个 <a href="https://docs.raku.org/type/Array"><code>Array</code></a>，因为它具有 <code>@</code> sigil：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub sigiled ($x is raw, +@y) {
    $x = 100;
    say flat @y
}

sub sigil-less (\x, +y) {
    x = 200;
    say flat y
}

my $x = 42;
sigiled    $x, (1, 2), (3, 4); # OUTPUT: «((1 2) (3 4))␤»
say $x;                        # OUTPUT: «100␤»

sigil-less $x, (1, 2), (3, 4); # OUTPUT: «(1 2 3 4)␤»
say $x;                        # OUTPUT: «200␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defaulting_on_default_defaults">2.9. Defaulting on Default Defaults</h3>
<div class="paragraph">
<p>容器提供的一个很棒的功能是默认值。 你可能听说过在 Raku 中，`Nil`表示缺少一个值，而不是一个值。 容器默认值就是它的作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x is default(42);
say $x;   # OUTPUT: «42␤»

$x = 10;
say $x;   # OUTPUT: «10␤»

$x = Nil;
say $x;   # OUTPUT: «42␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个容器的默认值是使用 <a href="https://docs.raku.org/type/Variable#index-entry-trait_is_default_%28Variable%29-trait_is_default"><code>is default</code> trait</a> 给它的。 它的参数是在编译时计算的，每当容器缺少一个值时，就使用结果值。 由于 <code>Nil</code> 的工作是表明这一点，因此将 <code>Nil</code> 分配到容器中将导致容器包含其默认值，而不是 <code>Nil</code>。</p>
</div>
<div class="paragraph">
<p>可以给 <a href="https://docs.raku.org/type/Array"><code>Array</code></a> 和 <a href="https://docs.raku.org/type/Hash"><code>Hash</code></a> 容器赋予默认值，如果你希望你的容器在字面上包含 <code>Nil</code>，当没有值时，只需要指定 <code>Nil</code> 作为默认值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a is default&lt;meow&gt; = 1, 2, 3;
say @a[0, 2, 42]; # OUTPUT: «(1 3 meow)␤»

@a[0]:delete;
say @a[0];        # OUTPUT: «meow␤»

my %h is default(Nil) = :bar&lt;ber&gt;;
say %h&lt;bar foos&gt;; # OUTPUT: «(ber Nil)␤»

%h&lt;bar&gt;:delete;
say %h&lt;bar&gt;       # OUTPUT: «Nil␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>容器的默认值有一个默认的默认值：容器上的显式类型约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say my Int $y; # OUTPUT: «(Int)␤»
say my Mu  $z; # OUTPUT: «(Mu)␤»

say my Int $i where *.is-prime; # OUTPUT: «(&lt;anon&gt;)␤»
$i.new; # OUTPUT: (exception) «You cannot create […]»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有明确的类型约束，默认的默认值是一个 <a href="https://docs.raku.org/type/Any"><code>Any</code></a> 类型的对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say my $x;    # OUTPUT: «(Any)␤»
say $x = Nil; # OUTPUT: «(Any)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，您可能在可选参数的例程签名中使用的默认值不是容器默认值，将 <code>Nil</code> 分配给子例程参数或分配给参数不会使用签名中的默认值。</p>
</div>
</div>
<div class="sect2">
<h3 id="_自定义">2.10. 自定义</h3>
<div class="paragraph">
<p>如果容器的标准行为不适合您的需求，您可以使用 <a href="https://docs.raku.org/type/Proxy"><code>Proxy</code></a> 类型创建自己的容器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $collector := do {
    my @stuff;
    Proxy.new: :STORE{ @stuff.push: @_[1] },
               :FETCH{ @stuff.join: &#34;|&#34;   }
}

$collector = 42;
$collector = &#39;meows&#39;;
say $collector; # OUTPUT: «42|meows␤»

$collector = &#39;foos&#39;;
say $collector; # OUTPUT: «42|meows|foos␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>接口有点笨重，但它完成了工作。我们使用 <a href="https://docs.raku.org/routine/new"><code>.new</code></a> 方法创建 <a href="https://docs.raku.org/type/Proxy"><code>Proxy</code></a> 对象，该方法需要两个必需的命名参数：<code>STORE</code> 和 <code>FETCH</code>，每个都带一个 <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a>。</p>
</div>
<div class="paragraph">
<p>每当从容器中读取一个值时，<code>FETCH`<a href="https://docs.raku.org/type/Callable">`Callable</a></code> 被调用，这可能比直接看到的次数多出现一次：在上面的代码中，当容器通过调度和例程这两个调用渗透时，<code>FETCH`<a href="https://docs.raku.org/type/Callable">`Callable</a></code> 被调用10次。 <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a> 被调用一个单一的位置参数：<a href="https://docs.raku.org/type/Proxy"><code>Proxy</code></a> 对象本身。</p>
</div>
<div class="paragraph">
<p>无论何时将值存储到我们的容器中（例如，使用赋值运算符（<code>=</code>）），<code>STORE</code> <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a> 都会被调用。 <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a> 的第一个位置参数是 <a href="https://docs.raku.org/type/Proxy"><code>Proxy</code></a> 对象本身，第二个参数是存储的值。</p>
</div>
<div class="paragraph">
<p>我们希望 <code>STORE</code> 和 <code>FETCH</code>  <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a> 共享 <code>@stuff</code> 变量，所以我们使用 <a href="https://docs.raku.org/syntax/do"><code>do</code> statement prefix</a> 和一个代码块来很好地包含它。</p>
</div>
<div class="paragraph">
<p>我们将我们的 <a href="https://docs.raku.org/type/Proxy"><code>Proxy</code></a> 绑定到一个变量，其余的只是正常的变量用法。输出显示我们的自定义容器提供的改变过的行为。</p>
</div>
<div class="paragraph">
<p>Proxies 也可以方便地作为返回值来提供具有可变属性的额外行为。例如，这里有一个属性，从外部看来只是一个正常的可变属性，但实际上强制它的值从 <a href="https://docs.raku.org/type/Any"><code>Any</code></a> 任何类型变为 <a href="https://docs.raku.org/type/Int"><code>Int</code></a> 类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Foo {
    has $!foo;
    method foo {
        Proxy.new: :STORE(-&gt; $, Int() $!foo { $!foo }),
                   :FETCH{ $!foo }
    }
}

my $o = Foo.new;
$o.foo = &#39; 42.1e0 &#39;;
say $o.foo; # OUTPUT: «42␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>很甜蜜！ 如果你想要一个更好的接口的 <a href="https://docs.raku.org/type/Proxy"><code>Proxy</code></a> 与一些更多的功能，请检查 <a href="http://modules.raku.org/dist/Proxee">Proxee</a> 模块。</p>
</div>
</div>
<div class="sect2">
<h3 id="_这就是全部伙计">2.11. 这就是全部，伙计</h3>
<div class="paragraph">
<p>那关于这一切。 在 Raku 中你将会看到的剩下的动物是 “twigils”：名称前带有两个符号的变量，但是就容器而言，它们的行为与我们所介绍的变量相同。 第二个符号只是表示附加信息，如变量是隐含的位置参数还是命名参数…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub test { say &#34;$^implied @:parameters[]&#34; }
test &#39;meow&#39;, :parameters&lt;says the cat&gt;;
# OUTPUT: «meow says the cat␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>…​或者该变量是私有属性还是公共属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">with class Foo {
    has $!foo = 42;
    has @.bar = 100;
    method what&#39;s-foo { $!foo }
}.new {
    say .bar;       # OUTPUT: «[100]␤»
    say .what&#39;s-foo # OUTPUT: «42␤»
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而，这是另一天的旅程。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论_2">2.12. 结论</h3>
<div class="paragraph">
<p>Raku 有一个丰富的变量和容器系统，与 Perl 5 有很大的不同。理解它的工作方式是非常重要的，因为它会影响列表和哈希行为的迭代和展开方式。</p>
</div>
<div class="paragraph">
<p>赋值给变量提供了有价值的快捷方式，例如提供<a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a>，<a href="https://docs.raku.org/type/Array"><code>Array</code></a>或<a href="https://docs.raku.org/type/Hash"><code>Hash</code></a> 容器，具体取决于符号。 如果您需要，绑定到变量允许您绕过这样的快捷方式。</p>
</div>
<div class="paragraph">
<p>在 Raku 中存在无符号变量，它们与具有绑定功能的 <code>$</code> -sigiled 变量具有相似的行为。 当用作参数时，这些变量的行为就像应用了 <code>is raw</code> trait一样。</p>
</div>
<div class="paragraph">
<p>最后，容器可以有默认值，可以创建自己的自定义容器，可以绑定到变量或从例程返回。</p>
</div>
<div class="paragraph">
<p>节日快乐！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第三天_letterops_with_raku">3. 第三天 – LetterOps with Raku</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_规模">3.1. 规模</h3>
<div class="paragraph">
<p>“规模！规模就是一切！“。</p>
</div>
<div class="paragraph">
<p>当圣诞老人的声音传到他们身上时，精灵散落在四面八方。</p>
</div>
<div class="paragraph">
<p>“这个 operation 是为三十四个孩子准备的？现在我们有无数的！大人也送信！“</p>
</div>
<div class="paragraph">
<p>小精灵 Buzzius 站了出来，喷出“但现在我们有电脑！”，又回到他精灵的追求。</p>
</div>
<div class="paragraph">
<p>“他们有什么好处？请告诉我，如果我仍然需要阅读每一封信，我该怎么办？“。</p>
</div>
<div class="paragraph">
<p>小精灵 Diodius 短暂地从藏身处抬起头，说：“告诉孩子们发一封文字信”。</p>
</div>
<div class="paragraph">
<p>圣诞老人停止了叫喊，并抓住了他有胡子的下巴。 “我可以做到这一点”。早期的儿童采用者就像这样发了一封信。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Dear Santa: I have been a good boy so I want you to bring me a collection of scythes and an ocean liner with a captain and a purser and a time travel machine and instructions to operate it and I know I haven&#39;t been so good at times but that is why I&#39;m asking the time machine so that I can make it good and well and also find out what happened on July 13th which I completely forgot.</code></pre>
</div>
</div>
<div class="paragraph">
<p>“我能做到吗？”。圣诞老人重复自己。他必须从单线混乱中提取一份礼物清单。例如，除以 <code>and</code>。</p>
</div>
<div class="paragraph">
<p>当然，使用 Raku 可以使用 <code>$þ</code> 作为变量，甚至可以<a href="https://en.wikipedia.org/wiki/Runic_(Unicode_block">使用</a>) <code>our $ᚣ= True</code> 作为标准，这是他最喜欢的语言。在一行中，您可以获得所有块，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[ &#34;Dear Santa: I have been a good boy so I want you to bring me a collection of scythes&#34;, &#34;an ocean liner with a captain&#34;, &#34;a purser&#34;, &#34;a time travel machine&#34;, &#34;instructions to operate it&#34;, &#34;I know I haven&#39;t been so good at times but that is why I&#39;m asking the time machine so that I can make it good&#34;, &#34;well&#34;, &#34;also find out what happened on July 13th which I completely forgot.\n&#34; ]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>/\s* «and» \s*/</code> regexp 使用了 `and`s 并且移除了空格，创建了一组句子。这些句子可能包含或不包含客户希望圣诞老人带来的东西。这让圣诞老人又一次咆哮起来。 “规模和结构！我们需要扩展，我们需要结构！“</p>
</div>
</div>
<div class="sect2">
<h3 id="_markdown_来拯救">3.2. Markdown 来拯救</h3>
<div class="paragraph">
<p>“马修斯投了出来。”每个人都知道 <a href="https://help.github.com/articles/basic-writing-and-formatting-syntax/">Markdown</a>。这是文字，为结构引入了几个标志。“</p>
</div>
<div class="paragraph">
<p>奥克斯正在努力晋升为第二级的精灵，他说。 “用Elvish-est的语言，榆树。你知道，这是精灵，但对于一封信“</p>
</div>
<div class="paragraph">
<p>“我可以做到这一点，”圣诞老人说。精灵喜欢他可以做的方法。所以他安装了所有东西，并做了这个小程序</p>
</div>
<div class="paragraph">
<p>圣诞老人安静了约 30 秒。然后再次听到了他的咆哮。</p>
</div>
<div class="paragraph">
<p>“永远，你听到我说话了吗？我从来不想再听到复活节兔子或其他邪恶生物的这种产卵。“</p>
</div>
<div class="paragraph">
<p>离屏幕最近的那些精灵观察到大量的红色，但不是很好的红色，没有任何类似于工作代码。所以他们给了鲁道夫一张便条（红红的鼻子驯鹿）一张便条，他用一只小鹿角忠实地扛着它。</p>
</div>
<div class="paragraph">
<p>“那么我们应该回到 Raku 吗？”</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_raku_处理_markdown">3.3. 使用 Raku 处理 Markdown</h3>
<div class="paragraph">
<p>圣诞老人发现了 <code>Text::Markdown</code>，他立即安装了该模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install Text::Markdown</code></pre>
</div>
</div>
<div class="paragraph">
<p>它有Text，它有Markdown，它承诺处理它，这是他所需要的。所以他向他的客户群通报说，如果你希望这个人在你的烟囱里拿着一个装有好东西的麻袋，那么今年就需要降价了。</p>
</div>
<div class="paragraph">
<p>早期的采用者再一次回答了这个问题</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku"># Dear Santa

I have been a good boy so I want you to bring me a collection of
scythes and an ocean liner with a captain and a purser and a time
travel machine and instructions to operate it and I know I haven&#39;t
been so good at times but that is why I&#39;m asking the time machine so
that I can make it good and well and also find out what happened on
July 13th which I completely forgot.</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么，这是降价，是不是？这是妥善处理和所有。 “正确处理一封信很重要”，圣诞老人大声说道，大声说道，只是让鲁道夫惊呆了，鲁道夫是唯一一个挂着的人。 “它给结构。让我们检查一下信件是否有这个“。</p>
</div>
<div class="paragraph">
<p>“哇！”圣诞老人说。然后，“哇”。只需几行代码即可阅读并理解文档的结构，另一行则检查是否至少有一个是标题。如果是这样，它会表示真。这是真的。</p>
</div>
<div class="paragraph">
<p>圣诞老人很高兴一小会儿。他抓住了鲁道夫脖子的后背，这让他感到惊讶。然后他停止了这样做。鲁道夫抬起头来，只是稍微支撑了他的后腿，感到不快。</p>
</div>
</div>
<div class="sect2">
<h3 id="_需要更多的结构">3.4. 需要更多的结构</h3>
<div class="paragraph">
<p>圣诞老人发现了这封信：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku"># Dude

=== Welll...

I have been a naughty person


=== Requests

Well...</code></pre>
</div>
</div>
<div class="paragraph">
<p>妥善处理和一切，他不能浪费他的时间与不好的人。规模。和资源。资源只能用于好人，而不是坏人。坏人不好，就是这样。所以回到编码，鲁道夫溜走寻找地衣糖或任何东西，他出示了这样的：</p>
</div>
<div class="paragraph">
<p>圣诞老人对第二个标题之后的段落提取技巧以及他能够很好地使用他所喜爱的Thorn信件这一事实感到自豪。他还喜欢函数式编程，在Lisp中咬牙切齿。所以他创建了这个最初是假的翻转开关，但是当它正在处理的元素是一个标题并且其级别是两个时，翻转开关。他也很高兴他可以用标记的文本顶部的分层结构来做这种事情。</p>
</div>
<div class="paragraph">
<p>此外，他可以检查该标题（行为）与下一行之间的任何段落中是否出现“好”字。而且任何一个都很酷。其中一个段落提到的很好就足够了。最后一行将首先返回一个布尔值数组，如果其中一个包含好的话，它最终将会声明为True。否则为假。适合从坏的方面挑选好的东西。</p>
</div>
<div class="paragraph">
<p>圣诞老人很开心。 -ier。但仍然。</p>
</div>
</div>
<div class="sect2">
<h3 id="_这里的玩具是重要的">3.5. 这里的玩具是重要的</h3>
<div class="paragraph">
<p>所以他真正想要的是玩具清单。在再次请求改变信件格式，他可以做的，因为他是圣诞老人，每个人都希望他的圣诞节免费的东西，他开始接收这种结构的信件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku"># Dear Santa

=== Behavior

I have been a good boy


=== Requests

And this is what I want

 - scythes
 - an ocean liner with a captain and a purser
 - a time travel machine and instructions to operate it</code></pre>
</div>
</div>
<div class="paragraph">
<p>他们在结构上的自发性缺乏。而且结构很好。你可以得到一个请求列表：</p>
</div>
<div class="paragraph">
<p>这实际上是链表列表处理表达式的一个不清晰的列表。在这之前的这句话有一个列表提及几乎一样坏。但让我们看看那里发生了什么。</p>
</div>
<div class="paragraph">
<p>首先在列表中，我们仅使用正则表达式和东西来获取请求标题后面的内容。我们本可能已经把它归结为对Str的转变，但是我们已经失去了结构。结构很重要，圣诞老人永远不会厌倦这一点。接下来，我们只提取那些实际上是列表的元素，将所有绒毛都取出来。</p>
</div>
<div class="paragraph">
<p>而事实恰恰是，结构太多这样的事情。该列表包含具有元素的元素。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">那或Text </dt>
<dd>
<p>Markdown可以做一个大改造。这篇文章的作者正在将他的特别愿望清单放在这里。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_还没有">3.6. 还没有</h3>
<div class="paragraph">
<p>但几乎。我们有这个名单，现在圣诞老人发现像时间旅行机器和星期一这样的事情。他不能在精灵工厂订购周一。他必须阅读每一件事情。但不用担心。这也可以照顾到：</p>
</div>
<div class="paragraph">
<p>简单来说，这个程序会遍历愿望清单中保存的项目清单，并检查产品性能。它是一种产品吗？它走了。你是在问上周五晚上，你完全错过了什么？它不，也不敢浪费圣诞老人的时间，男孩。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">这件事的要点在于使用全新的Wikidata </dt>
<dd>
<p>API模块的Wikidata查询。此模块只是将内容发送到Wikidata API并将其作为对象返回。相信与否，这就是SPARQL查询的作用：将项目名称插入到查询中，进行查询，并在返回的元素数量不为零时返回true。产品在你的指尖！在几行代码中！现在，他可以将所有东西链接在一起，并从包含此信件的信件中获取</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku"> - Morning sickness
 - Scythe
 - Mug</code></pre>
</div>
</div>
<div class="paragraph">
<p>只有你们可以从当地，市中心，妈妈和流行商店订购的其中两件，这是圣诞老人实际上偷偷购买所有东西的地方，因为他大量购买，并且他得到了很好的交易。</p>
</div>
<div class="paragraph">
<p>圣诞老人微微一笑，精灵，驯鹿和几只海雀在那里没有任何理由就爆发出大声的欢呼声。然后，他们往下看</p>
</div>
</div>
<div class="sect2">
<h3 id="_包起来">3.7. 包起来</h3>
<div class="paragraph">
<p>圣诞老人和 Raku 是一个很好的比赛，因为他们都是在圣诞节的时候来的。圣诞老人发现你可以自己做很多有用的事情，或者使用最近可用的优质模块之一。</p>
</div>
<div class="paragraph">
<p>不过，这位作者在给圣诞老人的信中将包括一些帮助，以继续介绍由他维护的这篇文章中使用的两个模块，这些模块需要更多有经验的编码人员进行测试，扩展或者重新编写。但他很高兴地看到，使用Raku可以直接完成处理给圣诞老人的信件等世俗和略微神圣的事情。你也应该这样做。</p>
</div>
<div class="paragraph">
<p>这篇文章的代码和样例可以从 <a href="https://github.com/JJ/santa-markdown">GitHub</a> 获得。也是这个文本。帮助和建议非常受欢迎。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第四天_使用_grammars_进行解析">4. 第四天-使用 Grammars 进行解析</h2>
<div class="sectionbody">
<div class="paragraph">
<p>下面是从 <a href="https://www.apress.com/us/book/9781484232279">Parsing with Raku Regexes and Grammars: A Recursive Descent into Parsing</a> 这本书里面提取出来的一章, 作者是 Moritz Lenz, 由 Apress Media 出版社出版。版权经过允许。</p>
</div>
<div class="paragraph">
<p>这本书马上就要出版了。至少该书的电子版这个月应该可以购买, 纸质版的可以在 <a href="https://smile.amazon.com/dp/1484232275/">亚马逊</a> 预定了。原本最迟会在 2018 年元月发出, 但是幸运的是, 圣诞节你就可以看到了。</p>
</div>
<div class="paragraph">
<p>下面你会看到第九章, 使用 Grammars 进行解析。前面的章节详细探讨了创建正则表达式块儿、正则表达式怎么和 Raku 代码进行交互、匹配对象、正则力学、常用正则技术，还有重用和组合正则。你可以通过阅读<a href="https://docs.raku.org/language/regexes">正则表达式官方文档</a>来获取更多关于正则的背景。</p>
</div>
<div class="paragraph">
<p>后面的章节涵盖了 action 类和对象, 怎么报告高质量的解析错误, Unicode 支持, 最后还有三个案例研究。</p>
</div>
<div class="paragraph">
<p>现在, 尽情享受吧！</p>
</div>
<div class="paragraph">
<p>Grammar 是众人皆知的用于解析的瑞士军刀。</p>
</div>
<div class="paragraph">
<p>在本章中，我们将更详细地探讨它们。 最重要的是，我们将讨论如何利用他们的威力。</p>
</div>
<div class="sect2">
<h3 id="_理解_grammars">4.1. 理解 Grammars</h3>
<div class="paragraph">
<p>Grammars 实现了自顶向下的解析方法。 入口点，通常是 <code>TOP</code> regex 正则表达式，它知道粗粒度的结构，并调用下降到繁复细节的更深一步的正则表达式。 也会涉及到递归。 例如，如果解析算术表达式，则操作符可以是一对括号内的任意表达式。</p>
</div>
<div class="paragraph">
<p>这是一个自顶向下的结构，或者更确切地说是一个<a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">递归下降分析方法</a>。 如果不涉及回溯，我们称之为*预测分析法*，因为在字符串中的每个位置，我们确切地知道我们在寻找什么 - 我们可以预测下一个 token 将会是什么（即使我们只能预测它可能是一组可选分支的其中之一）。</p>
</div>
<div class="paragraph">
<p>结果匹配树在结构上完全对应于 grammar 中正则表达式的调用结构。 让我们考虑解析一个只包含运算符 <code>*</code>，`+`和用于分组的括号的算术表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MathExpression {
    token TOP    { &lt;sum&gt; }
    rule sum     { &lt;product&gt;+ %  &#39;+&#39; }
    rule product { &lt;term&gt;+ % &#39;*&#39; }
    rule term    { &lt;number&gt; | &lt;group&gt; }
    rule group   { &#39;(&#39; &lt;sum&gt; &#39;)&#39; }
    token number { \d+ }
}

say MathExpression.parse(&#39;2 + 4 * 5 * (1 + 3)&#39;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>从 Grammar 本身，你已经可以看到递归的可能性：<code>sum</code> 调用 <code>product</code>，<code>product</code> 调用 <code>term</code>，<code>term</code> 调用 <code>group</code>，<code>group</code> 再次调用 <code>sum</code>。 这允许解析任意深度的嵌套表达式。</p>
</div>
<div class="paragraph">
<p>解析上面的例子产生下面的匹配对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">⌜2 + 4 * 5 * (1 + 3)⌟
 sum =&gt; ⌜2 + 4 * 5 * (1 + 3)⌟
  product =&gt; ⌜2 ⌟
   term =&gt; ⌜2 ⌟
    number =&gt; ⌜2⌟
  product =&gt; ⌜4 * 5 * (1 + 3)⌟
   term =&gt; ⌜4 ⌟
    number =&gt; ⌜4⌟
   term =&gt; ⌜5 ⌟
    number =&gt; ⌜5⌟
   term =&gt; ⌜(1 + 3)⌟
    group =&gt; ⌜(1 + 3)⌟
     sum =&gt; ⌜1 + 3⌟
      product =&gt; ⌜1 ⌟
       term =&gt; ⌜1 ⌟
        number =&gt; ⌜1⌟
      product =&gt; ⌜3⌟
       term =&gt; ⌜3⌟
        number =&gt; ⌜3⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想知道某个特定的数字是如何解析的，你可以通过查找当前行上缩进较少的行来追踪路径。 例如，数字 <code>1</code> 由 token <code>number`解析，调用自 `term</code>，再调用自 <code>product</code>，以此类推。</p>
</div>
<div class="paragraph">
<p>我们可以通过从 token <code>number</code> 引发异常来验证这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    token number {
        (\d+)
        { die &#34;how did I get here?&#34; if $0 eq &#39;1&#39; }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这确实显示了回溯中的调用链，其中最直接的上下文是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">how did I get here?
  in regex number at bt.p6 line 9
  in regex term at bt.p6 line 5
  in regex product at bt.p6 line 4
  in regex sum at bt.p6 line 3
  in regex group at bt.p6 line 6
  in regex term at bt.p6 line 5
  in regex product at bt.p6 line 4
  in regex sum at bt.p6 line 3
  in regex TOP at bt.p6 line 2
  in block &lt;unit&gt; at bt.p6 line 13</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个语法只使用 tokens 和 rules，所以不涉及回溯，而 grammar 是一个预测分析法。 这是相当典型的。 没有回溯或在几个地方有回溯时, 许多 grammars 都工作正常。</p>
</div>
</div>
<div class="sect2">
<h3 id="_递归下降分析法和优先级">4.2. 递归下降分析法和优先级</h3>
<div class="paragraph">
<p><code>MathExpression</code> grammar 有两个结构相同的 rules：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule sum { &lt;product&gt;+ %  &#39;+&#39; }
rule product { &lt;term&gt;+ % &#39;*&#39; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是, 我们也可以写成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule  expression { &lt;operator&gt;+ % &lt;term&gt; }
token operator   {  &#39;*&#39; | &#39;+&#39; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者甚至使用前一章讨论的 <code>proto token</code> 构造来解析不同的操作符。我选择第一种更重复的方法的原因是它使匹配结构对应于运算符 <code>*</code> 和 <code>+</code> 的优先级。</p>
</div>
<div class="paragraph">
<p>当计算数学表达式 <code>1 + 2 * 5</code> 时，数学家和大多数编程语言首先计算 <code>2 * 5</code>，因为 <code>*</code> 运算符的优先级高于 <code>+</code>。然后将结果代入表达式，成为 <code>1 + 10</code>，最后得到 <code>11</code>。</p>
</div>
<div class="paragraph">
<p>当用 grammar 的第一个版本解析这样的表达式的时候，解析树的结构表示这个分组：它具有 - 作为最高级 - 单个 sum，操作数是 <code>1</code> 和 <code>2 * 5</code>。</p>
</div>
<div class="paragraph">
<p>这是有代价的：对于每个优先级我们需要一个单独的 rule 和名字，并且所产生的结果匹配对象的嵌套层级, 每个优先级至少有一级。而且，稍后增加更多的优先级并不是微不足道的，而且很难通用。如果您不愿意接受这些成本，则可以使用具有单个 token 的平级模型来解析所有运算符。如果您需要能反映优先级的结构，则可以编写代码将列表转换为树。这通常被称为<a href="https://en.wikipedia.org/wiki/Operator-precedence_parser">运算符优先级解析器</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_左递归和其他陷阱">4.3. 左递归和其他陷阱</h3>
<div class="paragraph">
<p>为了避免无限递归，你必须注意，每个可能的递归循环至少将游标位置推进了一个字符。在 <code>MathExpression</code> grammar 中，唯一可能的递归循环是 <code>sum</code>→<code>product</code>→<code>term</code>→<code>group</code>→<code>sum</code>，并且 <code>group</code> 只有在消耗了一个初始开口圆括号 <code>(</code> 时才匹配。</p>
</div>
<div class="paragraph">
<p>如果递归不消耗字符，则它被称为*左递归*，并且需要特殊的语言支持, 这个 Raku 并不支持。一个例子是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token a { &lt;a&gt;? &#39;a&#39; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>它本该与正则表达式 <code>a+</code> 匹配相同的输入，但是却无限循环而不前进。</p>
</div>
<div class="paragraph">
<p>避免左递归的一个常用技巧是有一个可以按照从通用（这里是 <code>sum</code>）到特定（<code>number</code>）顺序排序正则表达式的结构。当正则表达式偏离该顺序时（例如 <code>group `调用 `sum</code>），你只需要关心并检查消耗的字符。</p>
</div>
<div class="paragraph">
<p>无限循环的另一个潜在来源是在量词化能匹配空字符串的正则表达式时。在解析允许某些内容为空的语言时可能会发生这种情况。例如，在 UNIX shell 中，你可以在给变量赋值的时候把右侧置空：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">VAR1=value
VAR2=</code></pre>
</div>
</div>
<div class="paragraph">
<p>在为 UNIX shell 命令编写 grammar 时，编写一个可能匹配空字符串的 <code>token string { \w* }</code> 可能会很冒险。 在允许多于一个字符串字面值的情况下，<code>&lt;string&gt;+</code> 就会挂起，因为实际的正则表达式 <code>[\w*]+</code> 试图无限次地匹配一个零宽度的字符串。</p>
</div>
<div class="paragraph">
<p>一旦你意识到了这个问题，解决方案就变得非常简单：将 token 更改为不允许空字符串（<code>token string { \w+ }</code>），并显式地处理允许空字符串的情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    token assignment {
        &lt;variable&gt; &#39;=&#39; &lt;string&gt;?
    }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_始于简单">4.4. 始于简单</h3>
<div class="paragraph">
<p>即使 grammar 是自上而下工作的，但是开发的时候最好开自下而上。 一开始，grammar 的总体结构往往是不明显的，但是你通常知道*末端* token：那些能直接匹配文本而不需要调用其他 subrules 的 token。</p>
</div>
<div class="paragraph">
<p>在前面的解析数学表达式的例子中，你可能一开始不知道如何安排解析 sums 和 products 的 rules，但你很可能知道必须在某个时候解析数字，所以一开始你可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MathExpression {
    token number { \d+ }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这并不是很多，但也不是很复杂，这是程序员有时在遇到新问题领域时克服挑战的一种很好的方式。 当然，一旦你有了 token，就可以开始写一些测试了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MathExpression {
    token number { \d+ }
}

multi sub MAIN(Bool :$test!) {
    use Test;
    plan 2;
    ok MathExpression.parse(&#39;1234&#39;, :rule&lt;number&gt;),
        &#39;&lt;number&gt; parses 1234&#39;;
    nok MathExpression.parse(&#39;1+4&#39;, :rule&lt;number&gt;),
        &#39;&lt;number&gt; does not parse 1+4&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，您可以以自己的方式创建更复杂的表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MathExpression {
    token number { \d+ }
    rule product { &lt;number&gt;+ % &#39;*&#39; }
}

multi sub MAIN(Bool :$test!) {
    use Test;
    plan 5;
    ok MathExpression.parse(&#39;1234&#39;, :rule&lt;number&gt;),
        &#39;&lt;number&gt; parses 1234&#39;;
    nok MathExpression.parse(&#39;1+4&#39;, :rule&lt;number&gt;),
        &#39;&lt;number&gt; does not parse 1+4&#39;;

    ok MathExpression.parse(&#39;1234&#39;, :rule&lt;product&gt;),
        &#39;&lt;product&gt; can parse a simple number&#39;;
    ok MathExpression.parse(&#39;1*3*4&#39;, :rule&lt;product&gt;),
        &#39;&lt;product&gt; can parse three terms&#39;;
    ok MathExpression.parse(&#39;1 * 3&#39;, :rule&lt;product&gt;),
        &#39;&lt;product&gt; and whitespace&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在测试的早期包含空白是值得的。 上面的例子看起来是无害的，但最后那个测试实际上失败了。 没有 rule 匹配 <code>1</code> 和 <code>*</code> 之间的空格。 在 <code>&lt;number&gt;</code> 和 <code>+</code> 量词之间的正则表达式中添加一个空格使测试再次通过，因为空格插入了一个隐式的 <code>&lt;.ws&gt;</code> 调用。</p>
</div>
<div class="paragraph">
<p>如果你从最简单的开始，尽快抓住这些细节，就很容易理解。 如果不是从上到下写下整个 grammar，你就会花很多时间去调试为什么一些看起来很简单的东西会导致解析失败, 比如额外的空格。</p>
</div>
</div>
<div class="sect2">
<h3 id="_组装完整的_grammars">4.5. 组装完整的 Grammars</h3>
<div class="paragraph">
<p>一旦你为词法分析编写了基本的 tokens，你可以进行合并。 通常，tokens 不会在匹配的边界处解析空白，因此组合它们的 rules 会这样做。</p>
</div>
<div class="paragraph">
<p>在上一节的 <code>MathExpression</code> 示例中，<code>rule product</code> 直接地调用了 <code>number</code>, 即使我们现在知道最终版本使用了一个中间步骤，也就是 rule <code>term</code>，它也可以解析用圆括号围起来的表达式。 引入这个额外的步骤不会使我们为 <code>product</code> 编写的测试失效，因为它在早期版本中匹配的字符串仍然匹配。 从处理语言子集的 grammar 开始，引入更多层是自然发生的，稍后将扩展。</p>
</div>
</div>
<div class="sect2">
<h3 id="_调试_grammars">4.6. 调试 Grammars</h3>
<div class="paragraph">
<p>对于正则表达式或 Grammar，有两种失败模式：它们可以匹配，当它不应该匹配（误报）时，或者它应该匹配（错误否定）时可能匹配失败。通常，误报更容易理解，因为您可以检查生成的匹配对象，并查看哪些正则表达式匹配了字符串的哪一部分。</p>
</div>
<div class="paragraph">
<p>有一个方便的工具来调试误报：<code>Grammar::Tracer</code> 模块。如果将模块加载到包含 grammar 的文件中，则运行该 grammar 会生成诊断信息，以帮助您找出匹配出错的位置。</p>
</div>
<div class="paragraph">
<p>请注意，这只是开发人员的诊断工具; 如果你想给终端用户更好的错误信息，请阅读第 11 章的改进建议。</p>
</div>
<div class="paragraph">
<p>您需要安装 Raku 的 <code>Grammar::Debugger</code> 模块，其中还包含 <code>Grammar::Tracer</code>。如果您使用 <code>moritzlenz/raku-regex-alpine</code> 的 docker 镜像，这已经为您完成了。如果您通过其他方法安装了Raku，则需要在命令行上运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install Grammar::Debugger</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果尚未安装 <code>zef</code>，请按照 <a href="https://github.com/ugexe/zef#installation">zef GitHub页面</a> 上的安装说明进行操作。</p>
</div>
<div class="paragraph">
<p>让我们来看一下 TadeuszSośnierz 写的 Raku 模块 <a href="https://github.com/tadzik/raku-Config-INI">Config::INI</a>。 它包含以下 <a href="https://github.com/tadzik/raku-Config-INI/blob/master/lib/Config/INI.pm">grammar</a>（这儿稍微重新格式化了）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar INI {
    token TOP {
        ^ &lt;.eol&gt;* &lt;toplevel&gt;?  &lt;sections&gt;* &lt;.eol&gt;* $
            }
    token toplevel { &lt;keyval&gt;* }
    token sections { &lt;header&gt; &lt;keyval&gt;* }
    token header   { ^^ \h* &#39;[&#39; ~ &#39;]&#39; $&lt;text&gt;=&lt;-[ \] \n ]&gt;+
                     \h* &lt;.eol&gt;+ }
    token keyval   { ^^ \h* &lt;key&gt; \h* &#39;=&#39; \h* &lt;value&gt;? \h*
                     &lt;.eol&gt;+ }
    regex key      { &lt;![#\[]&gt; &lt;-[;=]&gt;+ }
    regex value    { [ &lt;![#;]&gt; \N ]+ }
    token eol      { [ &lt;[#;]&gt; \N* ]? \n }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设我们想知道为什么它不解析下面的一段输入文本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a = b
[foo]
c: d</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以, 在该 grammar 之前, 我们插入下面这一行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Grammar::Tracer;</code></pre>
</div>
</div>
<div class="paragraph">
<p>之后，添加一小段调用该 grammar 的 <code>.parse</code> 方法的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">INI.parse(q:to/EOF/);
a = b
[foo]
c: d
EOF</code></pre>
</div>
</div>
<div class="paragraph">
<p>这产生了一个可观的，但相当丰富的输出。</p>
</div>
<div class="paragraph">
<p>每个条目由一个正则表达式的名称组成，比如 <code>TOP</code> 或者 <code>eol</code>（&#34;end of line&#34; 的缩写），后面跟着它调用的正则表达式的缩进后的输出。 每个正则表达式后面都有一个包含星号（<code><strong></strong></code><strong>）和 <code>MATCH</code> 后跟正则表达式匹配到的字符串片段这样的行; 如果正则表达式失败，则 <code></code></strong> 号后面跟的是 <code>FAIL</code>。</p>
</div>
<div class="paragraph">
<p>让我们一块一块地查看输出，即使它成块地出现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">TOP
|  eol
|  * FAIL
|  toplevel
|  |  keyval
|  |  |  key
|  |  |  * MATCH &#34;a &#34;
|  |  |  value
|  |  |  * MATCH &#34;b&#34;
|  |  |  eol
|  |  |  * MATCH &#34;\n&#34;
|  |  |  eol
|  |  |  * FAIL
|  |  * MATCH &#34;a = b\n&#34;
|  |  keyval
|  |  |  key
|  |  |  * FAIL
|  |  * FAIL
|  * MATCH &#34;a = b\n&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这告诉我们，<code>TOP</code> 调用了 <code>eol</code>，它没有匹配。 由于 <code>eol</code> 的调用是用 <code>*</code> 量化的，所以这不会导致 <code>TOP</code> 的匹配失败。 <code>TOP</code> 然后调用了 <code>key</code>, 匹配到文本 &#34;a&#34;, 调用 <code>value</code>, 匹配到文本 &#34;b&#34;。 然后 <code>eol</code> 正则表达式继续匹配换行符，在第二次尝试时失败（因为在一行中没有两个换行符）。 这会导致初始的 <code>keyval</code> token 匹配成功。 第二次调用 <code>keyval</code> 匹配很快（在调用 <code>key</code> 中）。 然后，<code>toplevel</code> token 的匹配成功进行，消耗了字符串 &#34;a = b \ n&#34;。</p>
</div>
<div class="paragraph">
<p>到目前为止，这一切看起来都和预期的一样。 现在我们来看看第二部分的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">|  sections
|  |  header
|  |  |  eol
|  |  |  * MATCH &#34;\n&#34;
|  |  |  eol
|  |  |  * FAIL
|  |  * MATCH &#34;[foo]\n&#34;
|  |  keyval
|  |  |  key
|  |  |  * MATCH &#34;c: d\n&#34;
|  |  * FAIL
|  * MATCH &#34;[foo]\n&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TOP</code> 接下来调用 <code>sections</code>，其中 token <code>header</code> 成功匹配了字符串 <code>&#34;[foo] \ n&#34;</code>。 然后，<code>keyval</code> 调用 <code>key</code>，它匹配了 <code>&#34;c: d\n&#34;</code> 整行。 等等，这是不对的，是吗？ 我们可能期望 <code>key</code> 只匹配 <code>c</code>。 我当然不希望它匹配最后的换行符。 输入中缺少等号会导致 regex 引擎永远不会调用 regex <code>value</code>。 但是由于 <code>keyval</code> 再次用星号 <code>*</code> 量词进行量化，因此调用正则表达式 <code>sections</code> 的匹配成功地匹配了 header <code>&#34;[foo]\n&#34;</code>。</p>
</div>
<div class="paragraph">
<p><code>Grammar::Tracer</code> 输出的最后一部分如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">|  sections
|  |  header
|  |  * FAIL
|  * FAIL
|  eol
|  * FAIL
* FAIL</code></pre>
</div>
</div>
<div class="paragraph">
<p>从这里开始都是 <code>FAIL</code>。第二次调用 <code>sections</code> 再次尝试解析 header，但其下一个输入仍然是 <code>&#34;c: d\n&#34;</code>，所以失败了。正如 token <code>TOP</code> 中字符串末尾的锚点 <code>$</code> 一样，在 <code>parse</code> 方法中总体匹配失败。</p>
</div>
<div class="paragraph">
<p>所以我们已经知道正则表达式 <code>key</code> 匹配整行 <code>c: d\n</code>，但是因为没有等号（<code>=</code>）跟在后面，所以 token <code>keyval</code> 解析不了这一行。由于没有其他正则表达式（特别是没有 <code>header</code>）匹配它，这是匹配失败的地方。</p>
</div>
<div class="paragraph">
<p>从这个例子中你可以看到，<code>Grammar::Tracer</code> 使我们能够精确定位解析失败发生的位置，尽管我们必须仔细查看它的输出以找到它。在终端中运行时，会自动获取彩色输出，其中 <code>FAIL</code> 为红色，<code>MATCH</code> 为绿色背景，token 名称以粗体白色（而不是通常的灰色）输出。这样可以更容易地从底部扫描（失败的匹配通常会留下一条红色的 <code>FAIL</code>），直到尾部成功的匹配，然后在匹配和失败之间的边界附近查看。</p>
</div>
<div class="paragraph">
<p>由于调试带来了巨大的精神负担，而且 <code>Grammar::Tracer</code> 的输出趋向于快速增长，所以通常建议将失败的输入减少到最小的样本。在上述情况下，我们可以删除输入字符串的第一行，并保存十行 <code>Grammar::Tracer</code> 输出来查看。</p>
</div>
</div>
<div class="sect2">
<h3 id="_解析空白和注释">4.7. 解析空白和注释</h3>
<div class="paragraph">
<p>如前所述，解析无关紧要的空格的惯用方法是调用 <code>&lt;.ws&gt;</code>，通常隐式地使用 rule 中的空格。 默认的 <code>ws</code> 实现 <code>&lt;!ww&gt;\s*</code> 对许多语言都适用，但是它有其局限性。</p>
</div>
<div class="paragraph">
<p>在数量惊人的文件格式和计算机语言中，也有 <code>&lt;.ws&gt;</code> 占用的空白是有意义的。 这些包括 INI 文件（换行符通常表示一个新的键/值对），Python 和 YAML（缩进用于分组），CSV（换行符表示新记录）以及 Makefile（缩进要求是制表符）。</p>
</div>
<div class="paragraph">
<p>在这些情况下，最好的做法在你自己的 grammar 中重写 <code>ws</code> 来匹配只有不重要的空格。 让我们来看看第二个简约的 INI 解析器，它是从上一节中描述的独立开发的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar INIFile {
    token TOP { &lt;section&gt;* }
    token section {
        &lt;header&gt;
        &lt;keyvalue&gt;*
    }
    rule header {
        &#39;[&#39;  &lt;-[ \] \n ]&gt;+ &#39;]&#39; &lt;.eol&gt;
    }
    rule keyvalue {
        ^^
        $&lt;key&gt;=[\w+]
        &lt;[:=]&gt;
        $&lt;value&gt;=[&lt;-[\n;#]&gt;*]
        &lt;.eol&gt;
    }
    token ws { &lt;!ww&gt; \h* }
    token eol {
        \n [\h*\n]*
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它解析简单的 INI 配置文件就像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">[db]
driver: mysql
host: db01.example.com
port: 122
username: us123
password: s3kr1t</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意这个 grammar 如何使用两条路径来解析空格：自定义的 <code>ws</code> token 只匹配水平空白（空格和制表符），单独的 <code>eol</code> token 匹配(significant)换行符。 <code>eol</code> token 还吞噬了只包含空格的更多行。</p>
</div>
<div class="paragraph">
<p>如果语言支持注释，并且不希望它们出现在解析树中，则可以使用 <code>ws</code> token 或 <code>eol</code>（或其等价物）来解析它们。 哪一个取决于哪里允许注释。 在 INI 文件中，它们只允许出现在键值对之后，或者它们自己单独占一行，所以 <code>eol</code> 将是合适的地方。 相比之下，SQL 允许在每个允许空格的地方进行注释，所以在 <code>ws</code> 中解析它们是很自然的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># comment parsing for SQL:
token ws { &lt;!ww&gt; \s* [ &#39;--&#39; \N* \n ]* }

# comment parsing for INI files:
token eol { [ [ &lt;[#;]&gt; \N* ]? \n ]+ }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_保存状态">4.8. 保存状态</h3>
<div class="paragraph">
<p>一些更有趣的数据格式和语言要求解析器存储事物（至少暂时）以便能够正确地解析它们。 一个恰当的例子是C编程语言，另一个例子是受其语法启发的（例如C ++和Java）。 这样的语言允许表单类型variable = initial_value的变量声明，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">int x = 42;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是有效的语法，但只有当第一个单词是一个类型名称。 相反，这将是无效的，因为x不是一个类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">int x = 42;
x y = 23;</code></pre>
</div>
</div>
<div class="paragraph">
<p>从这些例子中可以清楚地看到，解析器必须有它所知道的所有类型的记录。 由于用户也可以在他们的代码文件中声明类型，解析器必须能够更新这个记录。</p>
</div>
<div class="paragraph">
<p>许多语言还要求在引用符号（变量，类型和函数）之前进行声明。 这也需要语法来跟踪已经声明的内容和没有的内容。 这个已经声明的记录（以及什么是一个类型，也可能不是其他元信息）被称为符号表。</p>
</div>
<div class="paragraph">
<p>我们不考虑解析完整的C语言，而是考虑一种极简主义语言，它只允许分配数字列表和变量给变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a = 1
b = 2
c = a, 5, b</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们不强加声明规则，写一个语法是很容易的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar VariableLists {
    token TOP        { &lt;statement&gt;* }
    rule  statement  { &lt;identifier&gt; &#39;=&#39; &lt;termlist&gt; \n }
    rule  termlist   { &lt;term&gt; * % &#39;,&#39; }
    token term       { &lt;identifier&gt; | &lt;number&gt; }
    token number     { \d+ }
    token identifier { &lt;:alpha&gt; \w* }
    token ws         { &lt;!ww&gt; \h* }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们要求变量只能在赋值之后才能使用，所以下面的输入将是无效的，因为在第二行中没有声明b的地方：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a = 1
c = a, 5, b
b = 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了维护一个符号表，我们需要三个新的元素：符号表的声明，一些代码，当赋值语句被解析时，将一个变量名添加到符号表中，最后检查一个变量是否已经被声明 我们在一个术语列表中遇到它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar VariableLists {
    token TOP {
        :my %*SYMBOLS;
        &lt;statement&gt;*
    }
    token ws { &lt;!ww&gt; \h* }
    rule statement {
        &lt;identifier&gt;
        { %*SYMBOLS{ $&lt;identifier&gt; } = True }
        &#39;=&#39; &lt;termlist&gt;
        \n
    }
    rule termlist { &lt;term&gt; * % &#39;,&#39; }
    token term { &lt;variable&gt; | &lt;number&gt; }
    token variable {
        &lt;identifier&gt;
        &lt;?{ %*SYMBOLS{ $&lt;identifier&gt; } }&gt;
    }
    token number { \d+ }
    token identifier { &lt;:alpha&gt; \w* }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在令牌TOP中，：my％* SYMBOLS声明一个变量。 正则表达式中的声明以冒号（:)开始，以分号（;）结尾。 在它们之间，它们看起来像Raku中的正常声明。％sigil表示该变量是一个散列 - 一个字符串键到值的映射。 *使它成为一个动态变量 - 一个变量，不仅限于当前范围，而且对于从当前范围调用的代码（或正则表达式，也是代码）也是可见的。 由于这是一个非常大的范围，所以在大写字母中选择一个变量是自定义的。</p>
</div>
<div class="paragraph">
<p>第二部分，在符号表中添加一个符号，发生在规则声明中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    rule statement {
        &lt;identifier&gt;
        { %*SYMBOLS{ $&lt;identifier&gt; } = True }
        &#39;=&#39; &lt;termlist&gt;
        \n
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>大括号内是常规的（非正则表达式）Raku代码，所以我们可以使用它来操作哈希％* SYMBOLS。 表达式$ &lt;identifier&gt;访问变量name2的捕获。 因此，如果此规则解析变量a，则此语句将设置％* SYMBOLS {&#39;a&#39;} = True。</p>
</div>
<div class="paragraph">
<p>代码块的位置是相关的。 把它放在调用termlist之前意味着当术语列表被解析时变量已经是已知的，所以它接受像a = 2，a这样的输入。 如果我们首先调用termlist，这种输入被拒绝。</p>
</div>
<div class="paragraph">
<p>说到拒绝，这部分发生在令牌变量。 term现在调用新的标记变量（以前它直接称为标识符），并且变量验证该符号是在之前声明的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    token term { &lt;variable&gt; | &lt;number&gt; }
    token variable {
        &lt;identifier&gt;
        &lt;?{ %*SYMBOLS{ $&lt;identifier&gt; } }&gt;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可能还记得在前面的例子中，&lt;？{…​}&gt;执行一段Raku代码，如果它返回一个假值，则解析失败。 如果$ &lt;identifier&gt;不在％SYMBOLS中，这正是发生的情况。 在这个时候，令牌的非回溯性是很重要的。 如果被解析的变量是abc，并且变量a在％* SYMBOLS中，则回溯将尝试&lt;identifier&gt;的较短匹配，直到它碰到a，然后成功3。</p>
</div>
<div class="paragraph">
<p>由于在标记TOP中声明了％* SYMBOLS，所以当您尝试从语法外调用除TOP之外的其他规则时，必须复制此声明。 没有像我的％* SYMBOLS ;,一个像这样的调用声明</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">VariableLists.parse(&#39;abc&#39;, rule =&gt; &#39;variable&#39;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>dies with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Dynamic variable %*SYMBOLS not found</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用动态变量实现词法作用域">4.9. 使用动态变量实现词法作用域</h3>
<div class="paragraph">
<p>许多编程语言都有一个词汇范围的概念。 范围是程序中符号可见的区域。 如果范围仅由文本的结构（而不是程序的运行时功能）决定，我们称之为范围词法。</p>
</div>
<div class="paragraph">
<p>范围通常可以嵌套。 在一个作用域中声明的变量在这个作用域中是可见的，在所有的内部嵌套作用域中（除非内部作用域声明了一个名称相同的变量，在这种情况下，内部声明隐藏了外部作用域）。</p>
</div>
<div class="paragraph">
<p>回到列表和作业的玩具语言，我们可以引入一对花括号来表示一个新的范围，所以这是有效的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a = 1
b = 2
{
    c = a, 5, b
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但下一个例子是无效的，因为它只在内部范围内声明b，所以它在外部范围内是不可见的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a = 1
{
    b = 2
}
c = a, 5, b</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了在语法中实现这些规则，我们可以利用一个重要的观察：语法中的动态范围对应于它分析的文本中的词法范围。 如果我们有一个正则表达式块来解析范围的分隔符以及范围内的事物，那么它的动态范围就局限于它所调用的所有正则表达式（直接或间接），这也是它的范围 匹配输入文本。</p>
</div>
<div class="paragraph">
<p>我们来看看如何实现动态范围：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar VariableLists {
    token TOP {
        :my %*SYMBOLS;
        &lt;statement&gt;*
    }
    token ws { &lt;!ww&gt; \h* }
    token statement {
        | &lt;declaration&gt;
        |  &lt;block&gt;
    }
    rule declaration {
        &lt;identifier&gt;
        { %*SYMBOLS{ $&lt;identifier&gt; } = True; }
        &#39;=&#39; &lt;termlist&gt;
        \n
    }
    rule block {
        :my %*SYMBOLS = CALLERS::&lt;%*SYMBOLS&gt;;
        &#39;{&#39; \n*
            &lt;statement&gt;*
        &#39;}&#39; \n*
    }
    rule termlist { &lt;term&gt; * % &#39;,&#39; }
    token term { &lt;variable&gt; | &lt;number&gt; }
    token variable {
        &lt;identifier&gt;
        &lt;?{ %*SYMBOLS{ $&lt;identifier&gt; } }&gt;
    }
    token number { \d+ }
    token identifier { &lt;:alpha&gt; \w* }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个语法的前一个版本有一些变化：规则语句已被重命名为声明，新的规则语句分析声明或块。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">所有有趣的位都发生在块规则中。 该行：my％* SYMBOLS = CALLERS </dt>
<dd>
<p>&lt;％* SYMBOLS&gt;; 声明一个新的动态变量％* SYMBOLS并用该变量的前一个值初始化它。 CALLERS :: &lt;％* SYMBOLS&gt;通过调用者和调用者的调用者等查找变量％* SYMBOLS，从而查找对应于外部作用域的值。 初始化创建散列的副本，以便对一个副本的更改不会影响其他副本。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>让我们来看看当这个语法解析下面的输入时会发生什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a = 1
b = 2
{
    c = a, 5, b
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前两行之后，％* SYMBOLS的值为{a ⇒ True，b ⇒ True}。 当规则块解析第三行的开放大括号时，它会创建％* SYMBOLS的副本。 第四行的c的声明将对c ⇒ True插入到％* SYMBOLS的副本中。 在规则块解析最后一行的结束大括号之后，它将成功退出，并且％* SYMBOLS的副本将超出范围。 这给我们留下了早期版本的％* SYMBOLS（只有键a和b），当TOP退出时，它们超出了范围。</p>
</div>
<div class="paragraph">
<p>通过显式符号表进行范围确定</p>
</div>
<div class="paragraph">
<p>使用动态变量来管理符号表通常工作得很好，但是有一些边缘情况下更明确的方法效果更好。 这样的边缘情况包括那些符号太多以至于复制变得非常昂贵的情况，或者必须检查多于最顶端的范围的情况，或者复制符号表是不切实际的。</p>
</div>
<div class="paragraph">
<p>因此，可以为符号表编写一个类（在最简单的情况下，它使用一个数组作为范围的堆栈），在进入和离开范围时，在声明一个变量时，以及为了检查一个变量是否为 在一个范围内已知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class SymbolTable {
    has @!scopes = {}, ;
    method enter-scope() {
        @!scopes.push({})
    }
    method leave-scope() {
        @!scopes.pop();
    }
    method declare($variable) {
        @!scopes[*-1]{$variable} = True
    }
    method check-declared($variable) {
        for @!scopes.reverse -&gt; %scope {
            return True if %scope{$variable};
        }
        return False;
    }
}

grammar VariableLists {
    token TOP {
        :my $*ST = SymbolTable.new();
        &lt;statement&gt;*
    }
    token ws { &lt;!ww&gt; \h* }
    token statement {
        | &lt;declaration&gt;
        |  &lt;block&gt;
    }
    rule declaration {
        &lt;identifier&gt;
        { $*ST.declare( $&lt;identifier&gt; ) }
        &#39;=&#39; &lt;termlist&gt;
        \n
    }
    rule block {
        &#39;{&#39; \n*
            { $*ST.enter-scope() }
            &lt;statement&gt;*
            { $*ST.leave-scope() }
        &#39;}&#39; \n*
    }
    rule termlist { &lt;term&gt; * % &#39;,&#39; }
    token term { &lt;variable&gt; | &lt;number&gt; }
    token variable {
        &lt;identifier&gt;
        &lt;?{ $*ST.check-declared($&lt;identifier&gt;) }&gt;
    }
    token number { \d+ }
    token identifier { &lt;:alpha&gt; \w* }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>SymbolTable类具有私有数组属性@！作用域，它使用包含单个空散列的列表进行初始化。输入一个作用域意味着在这个数组的顶部推一个空的散列，当离开这个作用域的时候，它会通过pop方法调用再次被删除。变量声明将其名称添加到最顶端的散列@ @ scopes [* - 1]。</p>
</div>
<div class="paragraph">
<p>检查变量的存在不能只考虑最顶端的散列，因为变量被继承到内部作用域。在这里，我们以相反的顺序遍历所有的范围，从最内层到最外层的范围。遍历的顺序与简单的布尔检查无关，但是如果您需要查找与该变量相关的信息，则遵守此顺序以引用正确的顺序非常重要。</p>
</div>
<div class="paragraph">
<p>令牌TOP创建类SymbolTable的新对象，声明调用声明方法，令牌变量调用方法检查声明。规则块在解析语句列表之前调用进入范围，之后保留范围。这个工作，但只有当语句列表可以被成功解析;如果不是，规则块在管理调用离开范围之前失败。</p>
</div>
<div class="paragraph">
<p>对于这种情况，Raku有一个安全特性：如果在LEAVE语句前添加一个语句，那么在例程退出时，Raku可以在所有可能的情况下调用它（即使抛出异常）。由于LEAVE相位器只能在正则代码中使用，而不能在正则表达式中使用，所以我们需要将正则表达式包装在一个方法中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    method block {
        $*ST.enter-scope();
        LEAVE $*ST.leave-scope();
        self.block_wrapped();
    }
    rule block_wrapped {
        &#39;{&#39; \n*
            &lt;statement&gt;*
        &#39;}&#39; \n*
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们拥有与动态变量相同的鲁棒性，并且以更多的代码和更多的努力为代价，可以更灵活地向符号表添加额外的代码。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结">4.10. 总结</h3>
<div class="paragraph">
<p>Raku 的 Grammar 是编写递归下降解析器的一种声明方式。 如果没有回溯，他们就是可预测的; 在每一个时刻，我们都知道我们想要的 token 列表。</p>
</div>
<div class="paragraph">
<p>Grammar 的递归性带来了左递归的风险，即递归路径不消耗任何字符的情况，从而导致无限循环。</p>
</div>
<div class="paragraph">
<p>尽管 Grammar 是自上而下的，但是他们通常是从下到上写出来的：从词法分析开始，然后转向解析更大的结构。</p>
</div>
<div class="paragraph">
<p>复杂语言成功和精确的解析需要额外的状态。 我们已经看到了如何在 grammar 中使用动态变量来保存状态，它们的作用域如何对应于输入的词法作用域，以及如何将符号表写入并集成到 grammars 中。</p>
</div>
<div class="paragraph">
<p>1、就像一把瑞士军刀一样，但是功能更强大。
2、在这一点上，<code>identifier</code> 不会解析其周围的空白是至关重要的。 因此，token 不关心空白的原则和调用这些 token 的 rules 解析空白。
3、在这种情况下，这将是无害的，因为没有其他 rule 可以匹配变量的其余部分，导致解析错误。 但是在更复杂的情况下，这种无意的回溯会导致语法维护人员非常困惑的错误。</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.wordpress.com/2017/12/04/day-08-parsing-with-grammars-book-extract/">Day 4 – Parsing with Grammars</a>
== 第五天 - 使用 Raku 签名解构参数</p>
</div>
<div class="paragraph">
<p>在许多其他关键的 Raku 特性中，我认为 <a href="https://docs.raku.org/type/Signature">Signatures</a> 是众多&#34;杀手级&#34;特性之一。 它们的功能如此丰富而强大，我怀疑关于如何使用它们可以写一整本书。 我想探索一下我原来忽略但是非常珍惜的一些特定功能。</p>
</div>
<div class="paragraph">
<p>您可能已经看到了基本的子程序签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub myfunc($x, $y, $z) {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它给函数声明了 3 个标量参数, 并在函数体里面给了它们 <strong>$x</strong>, <strong>$y</strong>, <strong>$z</strong> 的名字。</p>
</div>
<div class="paragraph">
<p>太简单了。</p>
</div>
<div class="paragraph">
<p>你可以更有爱心, 给它们加上指定的类型:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub myfunc(Str $x, Int $y, Rat $z) {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用笑脸符号 <code>:D</code> 让参数值是有定义的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub myfunc(Str:D $x, Int:D $y, Rat:D $z) {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有很多其它花哨的说明符你可以使用，在这里我不深入了。</p>
</div>
<div class="paragraph">
<p>但是如果你的参数更复杂呢？ （不是 <a href="https://docs.raku.org/type/Complex">Complex</a> - 虽然它也起作用..）</p>
</div>
<div class="paragraph">
<p>For example, you might want to restrict a specific parameter to a Positional argument like an Array, or an Associative one like a Hash using the respective sigils, @ or %.
例如，你可能想要将特定的参数限制为像 Array 这样的 Positional 参数，或者使用相应的 @ 或 ％ 符号将这个参数限制为像 Hash 这样的关联参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub myfunc(%h) {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我可以使用一个散列来调用该函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">myfunc(%( a =&gt; 1, b =&gt; &#39;this&#39;, c =&gt; 2.2));</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我想验证那些特定的字段是否存在，我可以把代码放在函数的顶部来做到这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub myfunc(%h) {
    die &#34;a must be an Int&#34; unless %h&lt;a&gt; ~~ Int;
    die &#34;b must be a Str&#34;  unless %h&lt;b&gt; ~~ Str;
    die &#34;c must be a Rat&#34;  unless %h&lt;c&gt; ~~ Rat;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我还想简化引用那些字段的方式，我可以将它们赋值给其他变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub myfunc(%h) {
    die &#34;a must be an Int&#34; unless %h&lt;a&gt; ~~ Int;
    die &#34;b must be a Str&#34;  unless %h&lt;b&gt; ~~ Str;
    die &#34;c must be a Rat&#34;  unless %h&lt;c&gt; ~~ Rat;

    my $a = %h&lt;a&gt;;
    my $b = %h&lt;b&gt;;
    my $c = %h&lt;c&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有点无聊，对吗？</p>
</div>
<div class="paragraph">
<p>Perl 签名参数解构来拯救你了！ 我们可以在子例程签名自身中做所有的事情 - 只要放一个子签名(sub-signature)在后面即可。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub myfunc(%h (Int :$a, Str :$b, Rat :$c)) {...}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_解构_json">4.11. 解构 JSON</h3>
<div class="paragraph">
<p>相当不错，但如果你有<strong>更</strong>复杂的东西呢？</p>
</div>
<div class="paragraph">
<p>假如说一块儿有嵌套结构的 JSON，某些部分可能缺失了, 它们需要默认值, 等等。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use JSON::Fast;
my $item = from-json(q:to/END/);
    {
        &#34;book&#34; : {
            &#34;title&#34;  : &#34;A Christmas Carol&#34;,
            &#34;author&#34; : &#34;Charles Dickens&#34;
        },
        &#34;count&#34; : 12,
        &#34;tags&#34; : [ &#34;christmas&#34;, &#34;santa&#34;]
    }
    END</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>q:to/END/</code> 是一个 Raku <a href="https://docs.raku.org/language/quoting#index-entry-quote_heredocs_%3Ato-Heredocs%3A_%3Ato">heredoc</a>，它直接在文本中直到 END，然后我们可以使用 <a href="https://github.com/timo/json_fast">JSON::Fast</a> 的 <code>from-json()</code> 将其解析为 perl 中的数据结构。 你可以在函数签名中描述整个 JSON 结构，以便接收以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub myfunc(% (:%book (Str:D :$title, Str:D :$author), Int :$count,
              :@tags ($first-tag, *@other-tags)) )
{...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，在函数体中，我可以将这些部分引用为 <code>$title</code>，<code>$author</code>，<code>$count`和 `@tags</code>。 为了方便起见，我还将标签分成了 <code>$first-tag</code> 和 <code>@other-tags</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_在块儿中使用签名">4.12. 在块儿中使用签名</h3>
<div class="paragraph">
<p>当然，签名对于子程序来说是幻想的，但是你也可以在块儿(Block)中使用签名和解构。 假设你有一个上面的 JSON 条目的数组，并希望通过一个 <code>for</code> 循环遍历它们？ 只需在 <code>for</code> 的尖号块中使用解构签名即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @itemlist -&gt; % (:%book (Str:D :$title, Str:D :$author), Int :$count,
                    :@tags ($first-tag, *@other-tags))
{
    say &#34;$title, $author, $count, @tags[], $first-tag, @other-tags[]&#34;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意在这种情况下，我甚至不需要散列本身，所以我省略了散列的名称，仅使用 <code>％</code> 作为匿名散列（关联）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_你甚至可以解构对象">4.13. 你甚至可以解构对象!</h3>
<div class="paragraph">
<p>你有没有试过遍历一组对象，你所做的第一件事是调用一些访问器来获取一些属性？ 当然，你可以使用 <code>.attribute</code> 和 主题化的迭代器，但是使用子签名，你可以做更多。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Book {
    has $.title;
    has $.author;
    has $.count;
    has @.tags;
}

my @booklist =
    Book.new(title =&gt; &#39;A Christmas Carol&#39;,
             author =&gt; &#39;Charles Dickens&#39;,
             count =&gt; 12,
             tags =&gt; &lt;ghost christmas&gt;),

    Book.new(title =&gt; &#39;A Visit from St. Nicholas&#39;,
             author =&gt; &#39;Clement Clarke Moore&#39;,
             count =&gt; 4,
             tags =&gt; &lt;santa christmas&gt;);

for @booklist -&gt; Book $b (:$title,:$author, :$count, :@tags) {
    say &#34;$title, $author, $count, @tags[]&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您想检查类型或定义，或设置默认值，您都可以在签名中正确地执行。 如果您不喜欢对象属性的名称，则可以使用别名来重命名它们, 你开心就行。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论_3">4.14. 结论</h3>
<div class="paragraph">
<p>我发现解构参数在与数据库查询结果和 JSON 交互中非常有用。 您可以使用任何其他签名特性，包括指定类型，定义，可选性，默认值，使用别名重命名，使用子集约束或“where”从句，slurpies等。</p>
</div>
<div class="paragraph">
<p>节日快乐！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第六天_raku_书籍">5. 第六天-Raku 书籍</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rakuadvent.wordpress.com/2017/12/06/" class="bare">https://rakuadvent.wordpress.com/2017/12/06/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第七天_测试所有的东西">6. 第七天 – 测试所有的东西</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 与其大姐姐 Perl 5一样，具有很悠久的测试传统。当您安装任何 Perl 模块时，安装程​​序通常会运行该模块的测试套件。当然，作为新兴的 Raku 模块作者，您需要创建自己的测试套件。或者，也许你会在创建模块<strong>之前</strong>勇于创建测试套件。这实际上有几个好处，其中最主要的是你的第一个用户，甚至在它被写之前。</p>
</div>
<div class="paragraph">
<p>但在实际代码之前，我想提一下我经常使用的两个 shell 别名 -</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">alias 6=&#39;raku -Ilib&#39;
alias 6p=&#34;prove -e&#39;raku -Ilib&#39;&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些别名使我可以快速运行测试文件，而不必去安装我的代码。如果我在项目目录中，我可以运行</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ 6 t/01-core.t
ok 1 - call with number
ok 2 - call with text
ok 3 - call with formatted string
1..3</code></pre>
</div>
</div>
<div class="paragraph">
<p>它会告诉我我运行了哪些测试以及它们是否全部通过。就像它的大姐姐Perl 5一样，Raku使用’t /&#39;目录作为测试文件，并按照惯例使用后缀&#39;.t’来区分测试文件和软件包或脚本。它还有一个内置的单元测试模块，我们在上面使用。如果我们正在测试sprintf（）内部，它可能看起来像</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Test;

ok sprintf(1), &#39;call with number&#39;;
ok sprintf(&#34;text&#34;), &#39;call with text&#39;;
ok sprintf(&#34;%d&#34;,1), &#39;call with formatted string&#39;;

done-testing;</code></pre>
</div>
</div>
<div class="paragraph">
<p>ok和done-testing功能会自动导出给我们。我在这里使用规范的Raku风格，而不是太依赖括号。在这种情况下，我确实需要使用圆括号来确保sprintf（）不会“认为”“空调用”是它的参数。</p>
</div>
<div class="paragraph">
<p>OK只需要两个参数，你想要测试的真实性，以及一个可选的消息。如果第一个参数是任何评估为True的东西，则测试通过。否则…​…​你知道。该消息只是描述测试的文本。它纯粹是可选的，但当测试失败时它可以很方便，因为您可以在测试文件中搜索该字符串并快速找到问题。不过，如果你像作者一样，行号更有价值，所以当你看到的时候</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">not ok 1 - call with number
# Failed test &#39;call with number&#39;
# at test.t line 4
ok 2 - call with text
ok 3 - call with formatted string
1..3</code></pre>
</div>
</div>
<div class="paragraph">
<p>在您的测试中，您可以立即跳转到测试文件的第4行并开始编辑以找出问题所在。当你的测试文件变得越来越大时，这会变得更有用，例如我正在编写的Common Lisp版本（格式）的测试，每个测试文件超过200个测试并且不断增长。</p>
</div>
<div class="paragraph">
<p>最后，完成测试只是告诉测试模块我们已经完成了测试，没有更多的测试来了。当你刚刚开始时，这很方便，你不断尝试你的API，添加和更新测试。没有测试计数器来更新每次或任何其他机制来跟踪。</p>
</div>
<div class="paragraph">
<p>当然，这是可选的，但其他工具可能会在最后使用&#39;1..3’来证明您的测试实际上已经完成。 Jenkins的单元测试和其他系统也可能需要这个工具。</p>
</div>
<div class="sect2">
<h3 id="_it_depends">6.1. It depends…</h3>
<div class="paragraph">
<p>你对’是’的定义是什么。如果你只关心某件事情的真实性，好的测试是好的，但有时你需要深入一点。 Raku就像它的大姐姐一样可以帮助你。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">is 1 + 1, 2, &#39;prop. 54.43, Principia Mathematica&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不只是检查你的测试的真实性，它会检查它的价值。虽然你可以很容易地写这个</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">ok 1 + 1 == 2, &#39;prop. 54.43, Principia Mathematica&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用是使你的意图明确，你关注的是表达式1 + 1是否等于2;与同一语句的ok版本一样，目前还不清楚您是在测试&#39;1 + 1’部分还是&#39;==&#39;运算符。</p>
</div>
<div class="paragraph">
<p>这两个测试本身可能占据您测试需求的80％，处理基本列表和哈希时相对安全，如果您真的需要复杂的测试，那么它的大姐姐正在站在脚边，准备处理复杂的哈希阵列组合。</p>
</div>
</div>
<div class="sect2">
<h3 id="_懒惰和不耐烦">6.2. 懒惰和不耐烦</h3>
<div class="paragraph">
<p>有时你会有一个巨大的字符串，你只需要检查一下它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">ok &#39;Lake Char­gogg­a­gogg­man­chaugg­a­gogg­chau­bun­a­gung­a­maugg&#39; ~~ &#39;manchau&#39;, &#39;my side&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你当然可以在这里使用~~运算符。就像&#39;1 + 1 == 2’一样，但是你的意图可能并不明确。你可以使用类似的方法来明确你的意图。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">like &#39;Lake Char­gogg­a­gogg­man­chaugg­a­gogg­chau­bun­a­gung­a­maugg&#39;,
     /manchau/, &#39;my side&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>并没有~~悬在你的船边。</p>
</div>
</div>
<div class="sect2">
<h3 id="_晾干">6.3. 晾干</h3>
<div class="paragraph">
<p>在美丽的Lake Chargoggagoggmanchauggagoggchaubunagungamaugg度过一段时间后，你可能想把你的衣服拧干。测试文件往往会增长，特别是回归测试。你可能会发现自己写作</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">is sprintf( &#34;%s&#34;, &#39;1&#39; ), &#39;1&#39;, &#34;%s formats numbers&#34;;
is sprintf( &#34;%s&#34;, &#39;⅑&#39; ), &#39;⅑&#39;, &#34;%s formats fractions&#34;;
is sprintf( &#34;%s&#34;, &#39;Ⅷ&#39; ), &#39;Ⅷ&#39;, &#34;%s formats graphemes&#34;;
is sprintf( &#34;%s&#34;, &#39;三&#39; ), &#39;三&#39;, &#34;%s formats CJKV&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这很好，复制和粘贴（特别是从StackOverflow）是一个悠久的传统，没有错。不过考虑一下，当你使用“％d”而不是“％s”添加更多测试时会发生什么情况，并且由于所有这些字符串都是数字，因此您只需复制并粘贴该块，将“％s”更改为“％d”，然后继续。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">is sprintf( &#34;%s&#34;, &#39;1&#39; ), &#39;1&#39;, &#34;%s formats numbers&#39;;
# ...

is sprintf( &#34;%d, &#39;1&#39; ), &#39;1&#39;, &#34;%d formats numbers&#39;;
# ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以现在你已经有了两组测试，名称相同。而不是编辑所有新的“％d”测试，如果我们不必首先重复自己的话，这会不会很好？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subtest &#39;%s&#39;, {
    is sprintf( &#34;%s&#34;, &#39;1&#39; ), &#39;1&#39;, &#34;formats numbers&#34;;
    is sprintf( &#34;%s&#34;, &#39;⅑&#39; ), &#39;⅑&#39;, &#34;formats fractions&#34;;
    is sprintf( &#34;%s&#34;, &#39;Ⅷ&#39; ), &#39;Ⅷ&#39;, &#34;formats graphemes&#34;;
    is sprintf( &#34;%s&#34;, &#39;三&#39; ), &#39;三&#39;, &#34;formats CJKV&#34;;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在你只需要在两个地方而不是三个地方进行编辑。如果这激发了您对测试的兴趣，我鼓励您在我的个人网站上查看<a href="http://theperlfisher.blogspot.cz/2017/11/test-all-things.html">测试所有事情</a>以获得更高级的测试范例和更高级的 Raku 代码。另外不要忘记关注明天的 Raku Advent 发布！</p>
</div>
<div class="paragraph">
<p>谢谢你，快乐的黑客！</p>
</div>
<div class="paragraph">
<p>DrForr 又名 Jeff Goff，<a href="http://theperlfisher.blogspot.cz/">Perl Fisher</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第八天_adventures_in_nqp_land_hacking_the_rakudo_compiler">7. 第八天 - Adventures in NQP Land: Hacking the Rakudo Compiler</h2>
<div class="sectionbody">
<div class="paragraph">
<p>对旧圣诞节经典“圣诞节十二天”的道歉，我给你一个 Raku 版本的第一行：</p>
</div>
<div class="paragraph">
<p>在圣诞节的第一天，我真正的爱给了 pod 树上的 Perl 表格…​…​</p>
</div>
<div class="paragraph">
<p>但是我得到的表格不是很漂亮！</p>
</div>
<div class="sect2">
<h3 id="_背景">7.1. 背景</h3>
<div class="paragraph">
<p>我与 Raku 的第一次真正联系是在 2015 年春天，当时我决定检查它的状态，发现它已经准备好迎接黄金时段。在获得了该语言的一些经验之后，我开始在我可以提供帮助的地方贡献文档。我对文档的第一个贡献是清理其中没有很好呈现的表格。在我对本地主机上的 pod 表进行实验期间，我尝试了下表格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">=begin table
-r0c0  r0c1
=end table</code></pre>
</div>
</div>
<div class="paragraph">
<p>这导致 Raku 抛出一个丑陋的, LTA（非常搓）的异常消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">&#34;===SORRY!=== Cannot iterate object with P6opaque representation&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我解决了这个问题，但它让我感觉不爽，所以我开始调查 pod 和 tables 的内部。这导致我在 <a href="https://github.com/rakudo/rakudo/blob/master/src/Raku/Pod.nqp">github.com/rakudo/src/Raku/Pod.nqp</a> 中发现了问题的根源。</p>
</div>
<div class="paragraph">
<p>事实上，许多 pod 表格问题的真正问题最终都出现在该文件中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_not_quite_perl_nqp">7.2. Not Quite Perl (NQP)</h3>
<div class="paragraph">
<p>nqp 是用于构建 Rakudo Raku 编译器的中间语言。它的 git 仓库在<a href="https://github.com/raku/nqp">这里</a>。本文的其余部分是关于修改 rakudo 编译器中的 nqp 代码，其仓库地址在<a href="https://github.com/rakudo/rakudo">这里</a>。 Rakudo 在<a href="http://rakudo.org/">这里</a>也有一个网站。</p>
</div>
<div class="paragraph">
<p>在走得太远之前，我首先阅读有关 Rakudo 和 NQP 的可用信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Jonathan Worthington’s (JWs) 的幻灯片课程 <a href="http://edumentab.github.io/rakudo-and-nqp-internals-course/">Rakudo and NQP Internals</a></p>
</li>
<li>
<p><a href="https://github.com/raku/nqp/blob/master/docs/ops.markdown">NQP opcodes</a></p>
</li>
<li>
<p><a href="https://github.com/raku/nqp/blob/master/docs/built-ins.md">NQP built-in routines</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后我开始通过编写和运行一些这样的小型 nqp 文件来练习nqp编码（文件 “hello.nqp”）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nqp" data-lang="nqp">say(&#34;Hello, world!&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>当它被执行时，会给出预期的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ nqp hello.nqp
Hello, world!</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>say()</code> 是不需要 <code>nqp::</code> 前缀的少数 nqp opcodes 之一。</p>
</div>
</div>
<div class="sect2">
<h3 id="_进入战壕">7.3. 进入战壕</h3>
<div class="paragraph">
<p><code>rakudo/src/Raku/Pod.nqp</code> 文件中包含的 <code>Raku::Pod</code> 类的用途是将 pod grammar 匹配并将它们转换为 <code>rakudo/src/core/Pod.pm</code> 中的 Raku pod 类定义，供 Raku 领地上的渲染者进一步处理。对于表格，表示以 Raku 文档设计中描述的任何合法 pod 格式表示的内容概要 S26，Raku 测试套件规范和 Raku 文档必须转换为 Raku <strong>Pod::Block::Table</strong> 类如文件 <a href="https://github.com/rakudo/rakudo/blob/master/src/core/Pod.pm">rakudo/src/core/Pod.pm</a> 中所述，使用此格式的对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">configuration information
a header line with N cells
M content lines, each with N cells</code></pre>
</div>
</div>
<div class="paragraph">
<p>我希望 nqp 表格 pod 处理功能非常强大，能够自动修复某些格式问题（给作者一个警告），或者抛出一个异常（优雅）并提供问题的详细信息，以便作者修复 pod 输入。</p>
</div>
</div>
<div class="sect2">
<h3 id="_工作区和工具">7.4. 工作区和工具</h3>
<div class="paragraph">
<p>我需要两个克隆版本库：rakudo 和 roast。我还需要在 github 上复刻那些相同的git 仓库，所以我可以为我的更改创建 pull 请求（PR）。我在 CPAN 模块 <a href="https://metacpan.org/pod/distribution/App-GitGot/bin/got">App::GitGot</a> 中找到了非常方便的 Perl 5 工具。使用 <strong>got</strong> 允许我轻松设置所有四个仓库。 （请注意，got 得要求其目标 repo 不存在于所需的本地目录或用户的github 帐户中。）配置完成后，我去了一个合适的目录以包含两个 repos 并执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">got fork https://github.com/rakudo/rakudo.git
got fork https://github.com/raku/roast.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>这导致了一个子目录rakudo和 roast 包含克隆仓库和 rakudo 和 roast github 帐户上的新复刻。在 rakudo 目录中，可以看到用于轻松创建 PR 的默认设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ git remote -v
origin  git@github.com:tbrowder/rakudo.git (fetch)
origin  git@github.com:tbrowder/rakudo.git (push)
upstream    https://github.com/rakudo/rakudo.git (fetch)
upstream    https://github.com/rakudo/rakudo.git (push)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 roast 仓库中有类似的结果。</p>
</div>
<div class="paragraph">
<p>接下来，我将 roast 仓库作为 rakudo 的子目录（“rakudo/t/spec”）重命名，所以它作为本地 rakudo 的一个子集。</p>
</div>
<div class="paragraph">
<p>最后，我创建了几个 bash 脚本，以便于在本地 repo 目录中配置 rakudo 进行安装，设置环境并运行测试：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>rakudo-local-config.sh</p>
</li>
<li>
<p>run-table-tests.sh</p>
</li>
<li>
<p>set-rakudo-envvars.sh</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>（请参阅 <a href="https://github.com/tbrowder/nqp-tools">https://github.com/tbrowder/nqp-tools</a> 上提到的所有脚本。）</p>
</div>
<div class="paragraph">
<p>要完成本地工作环境，您需要安装一些本地模块，以便您必须更改路径并安装 zef 安装程序的本地副本。在 rakudo 目录中执行以下步骤（来自 <a href="https://rakuadvent.wordpress.com/mentions/zoffix/">@Zoffix</a> 的建议）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">git clone https://github.com/ugexe/zef
export PATH=`pwd`/install/bin:$PATH
cd zef; raku -Ilib bin/zef install .
cd ..
export PATH=`pwd`/install/share/raku/site/bin:$PATH
zef install Inline::Perl5</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后安装您需要的其他模块，例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">zef install Debugger::UI::CommandLine
zef install Grammar::Debugger</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hacking">7.5. Hacking</h3>
<div class="paragraph">
<p>现在开始黑客入侵。准备好构建时，执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">make
make install</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>make install</code> 步骤非常关键，否则，在我们设置的本地环境中，将不会找到新的 Raku 可执行文件。</p>
</div>
<div class="paragraph">
<p>调试于我来说很费力，每次重建需要大约三分钟。调试器（raku-debug-m）会非常有用，但我无法安装所需的 <code>Debbugger::UI::CommandLine</code> 模块，因此它可以被本地安装的 <code>raku-debug-m</code> 识别。我使用的主要方法是插入print 语句，并使用 raku 的 <code>--ll-exception</code> 选项。值得注意的是，这位作者是一位 Raku 新手，犯了很多错误，并且并不总是记得修复，因此有了这篇文章。 （注意我可能会使用调试工具，但在我开始的时候，我没有要求帮助，也没有提供上面提供的建议。）</p>
</div>
</div>
<div class="sect2">
<h3 id="_测试">7.6. 测试</h3>
<div class="paragraph">
<p>不言而喻，一个好的 PR 将包括对变化的测试。我总是创建一个与我的 rakudo 分支同名的 roast 分支。然后我提交了两个 PR，我指的是 rakudo PR 中的 toast PR，反之亦然。我注意到 toast PR，它需要伴生 rakudo PR 通过所有测试。</p>
</div>
<div class="paragraph">
<p>见参考文献5 了解更多有关专门测试脚本的详细信息，以进行欺骗和其他深奥测试事宜。</p>
</div>
</div>
<div class="sect2">
<h3 id="_文档">7.7. 文档</h3>
<div class="paragraph">
<p>我尝试将我的修复程序保留在最新的 <a href="https://docs.raku.org/language/tables">Raku pod 表格文档</a>中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_nqp_经验教训">7.8. NQP 经验教训</h3>
<div class="ulist">
<ul>
<li>
<p>LTA 错误消息是生活中的事实，例如，“无法调用此对象…​”，这可能是由很多事情造成的，包括拼写错误的标识符（提交 NQP 问题，早期报告可能不会很快修复）。</p>
</li>
<li>
<p>确保所有 nqp 操作码都有 <code>nqp::</code> 前缀（除了少数内置函数）</p>
</li>
<li>
<p>在 nqp 专用沙箱中练习新代码。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_成功">7.9. 成功！</h3>
<div class="paragraph">
<p>现在我已经接受并合并了两个主要的Raku POD（和 toast）PR，并且我正在研究一个更“容易”的，我将在本周完成。 这些 PR 是：</p>
</div>
<div class="paragraph">
<p>1.Rakudo PR＃1240
这个 <a href="https://github.com/rakudo/rakudo/pull/1240">Rakudo PR</a>  为 RT＃124403，＃128221，＃132341，＃13248和＃129862提供了修复程序。它伴随着 toast <a href="https://github.com/raku/roast/pull/353">PR＃353</a>。</p>
</div>
<div class="paragraph">
<p>这个 PR 允许上面的问题表格被正确渲染。它还添加了有问题的表的警告，添加了 Rakudo 环境变量RAKUDO_POD6_TABLE_DEBUG 以帮助用户调试表（请参阅文档，<a href="https://docs.raku.org/programs/00-running#Environment_Variables">用户调试</a>），并允许具有空列的短行正确呈现。</p>
</div>
<div class="paragraph">
<p>2.Rakudo PR＃1287
这个 <a href="https://github.com/rakudo/rakudo/pull/1287">Rakudo PR</a> 为 Rakudo repo 问题＃1282提供了一个解决方案。它伴随着 roast <a href="https://github.com/raku/roast/pull/361">PR＃361</a>。 （请注意，roast PR＃361 尚未合并。）</p>
</div>
<div class="paragraph">
<p>这个 PR 允许表格视觉列分隔符（&#39;|&#39;）和（&#39;+&#39;）作为单元格数据通过在 pod 源中转义它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_2">7.10. 总结</h3>
<div class="ulist">
<ul>
<li>
<p>Raku pod相对于Perl 5来说是一个很大的改进，但它还没有完全实现。</p>
</li>
<li>
<p>在 Rakudo Perl的内部工作是有益的（并且很有趣），但是准备让你的手变脏！</p>
</li>
<li>
<p>Raku 社区是一个很好的团队。</p>
</li>
<li>
<p>我喜欢 Rakudo Raku。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>圣诞快乐，Hacking 快乐！</p>
</div>
</div>
<div class="sect2">
<h3 id="_参考">7.11. 参考</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>JWs Raku debugger <a href="https://rakuadvent.wordpress.com/2012/12/05/a-perl-6-debugger/">Advent article</a></p>
</li>
<li>
<p>JWs Rakudo debugger module <a href="https://github.com/jnthn/rakudo-debugger">Debugger::UI::CommandLine</a></p>
</li>
<li>
<p>JWs grammar debugger module <a href="https://github.com/jnthn/grammar-debugger">Grammar::Debugger</a></p>
</li>
<li>
<p><a href="https://github.com/raku/roast/blob/master/README.md">Testing Rakudo</a></p>
</li>
<li>
<p><a href="https://github.com/raku/roast/blob/master/CONTRIBUTING.md">Contributing to roast</a></p>
</li>
<li>
<p><a href="https://help.github.com/categories/collaborating-with-issues-and-pull-requests/">Github guide to pull requests (PRs)</a></p>
</li>
<li>
<p><a href="https://docs.raku.org/">Raku documentation (<strong>docs</strong>)</a></p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_附录">7.12. 附录</h3>
<div class="paragraph">
<p>POD 工具</p>
</div>
<div class="ulist">
<ul>
<li>
<p>raku –doc=MODULE # where ‘MODULE’ is ‘HTML’, ‘Text’, 或其它合适的模块</p>
</li>
<li>
<p>p6doc</p>
</li>
<li>
<p>raku –ll-exception</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_主要的_raku_pod_渲染器">7.13. 主要的 Raku POD 渲染器</h3>
<div class="ulist">
<ul>
<li>
<p>Pod::To::Text (part of the rakudo core)</p>
</li>
<li>
<p><a href="https://github.com/raku/Pod-To-HTML">Pod::To::HTML</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第九天_http_and_web_sockets_with_cro">8. 第九天 – HTTP and Web Sockets with Cro</h2>
<div class="sectionbody">
<div class="paragraph">
<p>礼物不仅仅是圣诞节的时候才有。今年夏天，在瑞士 Perl 工作室 - 精美地坐落在阿尔卑斯山 - 我有幸透露了 <a href="http://cro.services/">Cro</a>。 Cro 是一组用于在 Raku 中构建服务的库，以及一些用于 stub，run 和跟踪服务的开发工具。 Cro 主要关注使用 HTTP（包括HTTP/2.0）和 Web 套接字构建服务，但可以提供对 ZeroMQ 的早期支持，并计划在未来推出一系列其他选项。</p>
</div>
<div class="sect2">
<h3 id="_响应式管道">8.1. 响应式管道</h3>
<div class="paragraph">
<p>Cro 遵循 Perl 的设计原则，使简单的事情变得简单，并且让困难的事情变得可能。就像 Git 一样，Cro 可以被认为是具有瓷器（使简单的事情变得简单）和管道（使困难的事情成为可能）。管道水平由组成管道的组件组成。这些组件具有不同的形状，例如源，传输和下沉。这是一个将 HTTP 请求转换为 HTTP 响应的转换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro;
use Cro::HTTP::Request;
use Cro::HTTP::Response;

class MuskoxApp does Cro::Transform {
    method consumes() { Cro::HTTP::Request }
    method produces() { Cro::HTTP::Response }
    method transformer(Supply $pipeline --&gt; Supply) {
        supply whenever $pipeline -&gt; $request {
            given Cro::HTTP::Response.new(:$request, :200status) {
                .append-header: &#34;Content-type&#34;, &#34;text/html&#34;;
                .set-body: &#34;Muskox Rocks!\n&#34;.encode(&#39;ascii&#39;);
                .emit;
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，让我们用一个 TCP 监听器，一个 HTTP 请求解析器和一个 HTTP 响应序列化器来编写它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::TCP;
use Cro::HTTP::RequestParser;
use Cro::HTTP::ResponseSerializer;

my $server = Cro.compose:
    Cro::TCP::Listener.new(:port(4242)),
    Cro::HTTP::RequestParser.new,
    MuskoxApp,
    Cro::HTTP::ResponseSerializer;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">这将返回一个Cro </dt>
<dd>
<p>Service，我们现在可以启动，并在Ctrl + C时停止：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$server.start;
react whenever signal(SIGINT) {
    $server.stop;
    exit;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行。然后 <code>curl</code> 它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ curl http://localhost:4242/
Muskox Rocks!</code></pre>
</div>
</div>
<div class="paragraph">
<p>不错。但是如果我们想要一个HTTPS服务器呢？如果我们有方便的关键和证书文件，这只是一个用TLS监听器替换TCP监听器的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::TLS;

my $server = Cro.compose:
    Cro::TLS::Listener.new(
        :port(4242),
        :certificate-file(&#39;certs-and-keys/server-crt.pem&#39;),
        :private-key-file(&#39;certs-and-keys/server-key.pem&#39;)
    ),
    Cro::HTTP::RequestParser.new,
    MuskoxApp,
    Cro::HTTP::ResponseSerializer;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行。然后 <code>curl -k</code> 它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ curl -k https://localhost:4242/
Muskox Rocks!</code></pre>
</div>
</div>
<div class="paragraph">
<p>和中间件？这只是构成管道的另一个组成部分。或者，从另一个角度来看，对于Cro，一切都是中间件。即使请求解析器或响应序列化器可以很容易地被替换，如果需要的话（这听起来像是一件奇怪的事情需要，但这实际上是实现FastCGI会涉及的）。</p>
</div>
<div class="paragraph">
<p>所以，这就是克罗的方式。它还需要大量的样板才能在此级别上工作。带上瓷器！</p>
</div>
</div>
<div class="sect2">
<h3 id="_http_服务器简单的方法">8.2. HTTP 服务器，简单的方法</h3>
<div class="paragraph">
<p>Cro::HTTP::Server 类摆脱了构建 HTTP 处理管道的样板。从前面的例子变成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro;
use Cro::HTTP::Server;

class MuskoxApp does Cro::Transform {
    method consumes() { Cro::HTTP::Request }
    method produces() { Cro::HTTP::Response }
    method transformer(Supply $pipeline --&gt; Supply) {
        supply whenever $pipeline -&gt; $request {
            given Cro::HTTP::Response.new(:$request, :200status) {
                .append-header: &#34;Content-type&#34;, &#34;text/html&#34;;
                .set-body: &#34;Muskox Rocks!\n&#34;.encode(&#39;ascii&#39;);
                .emit;
            }
        }
    }
}

my $server = Cro::HTTP::Server.new: :port(4242), :application(MuskoxApp);
$server.start;
react whenever signal(SIGINT) {
    $server.stop;
    exit;
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">这里没有魔法;它真的只是一个更方便的方式来组成一条管线。虽然这只是对HTTP / 1. *的节省，但HTTP / 2.0管道涉及更多的组件，而支持这两者的管道仍然更为复杂。相比之下，配置Cro </dt>
<dd>
<p>HTTP :: Server可以轻松地完成支持HTTP / 1.1和HTTP / 2.0的HTTPS：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %tls =
    :certificate-file(&#39;certs-and-keys/server-crt.pem&#39;),
    :private-key-file(&#39;certs-and-keys/server-key.pem&#39;);
my $server = Cro::HTTP::Server.new: :port(4242), :application(MuskoxApp),
    :%tls, :http&lt;1.1 2&gt;;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_通向幸福的途径">8.3. 通向幸福的途径</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Cro中的Web应用程序最终总是将HTTP请求转换为HTTP响应的转换。然而，想要以完全相同的方式处理所有请求的情况非常罕见。通常，不同的URL应该路由到不同的处理程序。输入Cro </dt>
<dd>
<p>HTTP :: Router：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::HTTP::Router;
use Cro::HTTP::Server;

my $application = route {
    get -&gt; {
        content &#39;text/html&#39;, &#39;Do you like dugongs?&#39;;
    }
}

my $server = Cro::HTTP::Server.new: :port(4242), :$application;
$server.start;
react whenever signal(SIGINT) {
    $server.stop;
    exit;
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">路由块返回的对象执行Cro </dt>
<dd>
<p>Transform角色，这意味着它可以很好地与Cro.compose（…​）配合使用。然而，使用路由器编写应用程序会更方便一些！让我们看看更仔细一点：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; {
    content &#39;text/html&#39;, &#39;Do you like dugongs?&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，get是说这个处理程序只处理HTTP GET请求。尖头块的空签名意味着不需要URL段，所以该路由仅适用于/。然后，而不是必须做一个响应对象实例，添加一个头，并编码一个字符串，内容函数完成这一切。</p>
</div>
<div class="paragraph">
<p>路由器是为了利用Raku签名而建立的，同时也可以让Raku程序员感觉自然。路由段通过声明参数来建立，而文字串段恰好匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;product&#39;, $id {
    content &#39;application/json&#39;, {
        id =&gt; $id,
        name =&gt; &#39;Arctic fox photo on canvas&#39;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用curl进行快速检查表明，它还负责为我们序列化JSON：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ curl http://localhost:4242/product/42
{&#34;name&#34;: &#34;Arctic fox photo on canvas&#34;,&#34;id&#34;: &#34;42&#34;}</code></pre>
</div>
</div>
<div class="paragraph">
<p>JSON正文序列化程序由内容类型激活。这是可能的，也很简单，可以实现并插入自己的身体序列器。</p>
</div>
<div class="paragraph">
<p>想要捕获多个网址段？ Slurpy参数也可以工作，这对于服务静态资产时可以很方便地与静态结合使用，也许深层次的多级目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;css&#39;, *@path {
    static &#39;assets/css&#39;, @path;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可选参数适用于可能提供或可能不提供的段。使用子集类型来限制允许的值也可以。 Int只接受URL段中的值以整数形式解析的请求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;product&#39;, Int $id {
    content &#39;application/json&#39;, {
        id =&gt; $id,
        name =&gt; &#39;Arctic fox photo on canvas&#39;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>命名参数用于接收查询字符串参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;search&#39;, :$query {
    content &#39;text/plain&#39;, &#34;You searched for $query&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将填充在这样的请求中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ curl http://localhost:4242/search?query=llama
You searched for llama</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些也可以是类型约束和/或需要的（命名参数在Raku中默认是可选的）。 Cro路由器试图帮助你做好HTTP，方法是给出一个404错误来匹配一个URL段，405（方法不允许），当段匹配但是使用了错误的方法时，400当方法和段很好时，但查询字符串有问题。通过使用is标头并且是cookie特征的命名参数也可以用于接受和/或限制标头和cookie。</p>
</div>
<div class="paragraph">
<p>路由器将所有路由编译成Raku语法，而不是一次一个地浏览路由。这意味着路线将使用NFA进行匹配，而不是一次一个地突破。此外，这意味着应用Raku最长的文字前缀规则，因此：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;product&#39;, &#39;index&#39; { ... }
get -&gt; &#39;product&#39;, $what { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使您按照相反的顺序编写了这些请求，它们总是会优先选择这两项中的第一项作为/ product / index的请求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;product&#39;, $what { ... }
get -&gt; &#39;product&#39;, &#39;index&#39; { ... }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_中间件变得更容易">8.4. 中间件变得更容易</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">有趣的是，HTTP中间件只是一个Cro </dt>
<dd>
<p>Transform，但如果Cro是所有产品的话，那么写起来会不太有趣。令人高兴的是，有一些更简单的选择。路径块可以包含块之前和之后的块，这些块将在块中的任何路由处理之前和之后运行。因此，可以将HSTS标头添加到所有响应中：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $application = route {
    after {
        header &#39;Strict-transport-security&#39;, &#39;max-age=31536000; includeSubDomains&#39;;
    }
    # Routes here...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者对没有授权标头的所有请求使用HTTP 403 Forbidden进行响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $application = route {
    before {
        unless .has-header(&#39;Authorization&#39;) {
            forbidden &#39;text/plain&#39;, &#39;Missing authorization&#39;;
        }
    }
    # Routes here...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其行为如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ curl http://localhost:4242/
Missing authorization
$ curl -H&#34;Authorization: Token 123&#34; http://localhost:4242/
&lt;strong&gt;Do you like dugongs?&lt;/strong&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_这只是一个供应链supply_chain">8.5. 这只是一个供应链(Supply chain)</h3>
<div class="paragraph">
<p>所有的Cro实际上只是构建一系列Raku Supply对象的一种方式。尽管中间件块之前和之后都很方便，但将中间件作为转换编写，无论何时使用语法，都可以访问Raku电源的全部功能。因此，如果您需要使用会话令牌进行请求并对会话数据库进行异步调用，并且只有发出请求才能进行进一步处理（或者重定向到登录页面），则可以这样做 - 阻止其他请求（包括同一连接上的请求）。</p>
</div>
<div class="paragraph">
<p>事实上，Cro完全是根据更高级别的Raku并发功能构建的。没有明确的线程，也没有明确的锁定。相反，所有并发都是以Raku Supply和Promise的形式表示的，并且由Raku运行时库决定，以便在多个线程上扩展应用程序。</p>
</div>
</div>
<div class="sect2">
<h3 id="_哦和websockets">8.6. 哦，和WebSockets？</h3>
<div class="paragraph">
<p>事实证明，Raku提供的地图非常适合网络套接字。事实上，很好，Cro在API方面的增加相对较少。以下是一个（过度）简单的聊天服务器后端的外观：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $chat = Supplier.new;
get -&gt; &#39;chat&#39; {
    # For each request for a web socket...
    web-socket -&gt; $incoming {
        # We start this bit of reactive logic...
        supply {
            # Whenever we get a message on the socket, we emit it into the
            # $chat Supplier
            whenever $incoming -&gt; $message {
                $chat.emit(await $message.body-text);
            }
            # Whatever is emitted on the $chat Supplier (shared between all)
            # web sockets), we send on this web socket.
            whenever $chat -&gt; $text {
                emit $text;
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">请注意，这样做需要使用Cro </dt>
<dd>
<p>HTTP :: Router :: WebSocket;导入提供网络套接字功能的模块。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_综上所述">8.7. 综上所述</h3>
<div class="paragraph">
<p>这只是对Cro所提供的内容的一瞥。没有空间讨论HTTP和Web套接字客户端，用于存根和运行项目的cro命令行工具，提供用于执行相同操作的Web UI的Cro Web工具，或者如果您将CRO_TRACE = 1粘贴到您的环境中，您可以获得大量有关请求和响应处理的多汁调试细节。</p>
</div>
<div class="paragraph">
<p>要了解更多信息，请查看Cro文档，其中包括关于构建单页应用程序的教程。如果你有更多的问题，最近在Freenode上创建了#cro IRC频道</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十天_wrapping_rats">9. 第十天 – Wrapping Rats</h2>
<div class="sectionbody">
<div class="paragraph">
<p>沿着烟囱向下是一件危险的事情。</p>
</div>
<div class="paragraph">
<p>烟囱可能很窄，很高，有时候建造得不够好。</p>
</div>
<div class="paragraph">
<p>今年，圣诞老人想要做好准备。因此，他正在将烟囱检查与交付礼物结合起来。</p>
</div>
<div class="paragraph">
<p>烟囱检查涉及确保每层砖都处于正确的高度; 即砂浆层的高度是一致的，并且砖的高度也是一致的。</p>
</div>
<div class="paragraph">
<p>例如，对于 2¼” 高的砖和厚度为 ⅜” 的砂浆，测量序列应该如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">                       🎅
                      ─██─
                       ||
 layer                                      total
       ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
  2¼   ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
       ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
   ⅜                                        ‾‾???
       ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░
  2¼   ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░
       ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░
   ⅜                                        ‾‾5⅝
       ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░
  2¼   ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░
       ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░
   ⅜                                        ‾‾3
       ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░
  2¼   ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░
       ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░
   ⅜   _____________________________________‾‾⅜</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个计划是让精灵们下降到烟囱的底部，手中拿着卷尺，然后回来，确保每个砖块的顶部恰好位于卷尺上的正确位置。</p>
</div>
<div class="paragraph">
<p>一个名叫猫王的特殊精灵已经自己写了一个程序来帮助完成计算这个高度序列的任务。</p>
</div>
<div class="paragraph">
<p>因为懒惰，猫王甚至不想添加上述任何分数，并希望程序完成所有工作。他也不想花费精力去找出每层高度的公式。幸运的是，他正在使用 Raku，它将 unicode 分数转换为有理数（类型为 <code>Rat</code>），并且还有一个序列运算符（<code>…​</code>），它根据前几项计算出算术序列。</p>
</div>
<div class="paragraph">
<p>所以，猫王在程序中的第一个片段看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @heights = 0, ⅜, 3, 5+⅝ ... *;

say @heights[^10].join(&#39;, &#39;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这给了他需要的前10个高度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">0, 0.375, 3, 5.625, 8.25, 10.875, 13.5, 16.125, 18.75, 21.375</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然这是正确的，但很难使用。卷尺只有几分之一英寸，而不是小数。猫王真正想要的输出是分数。</p>
</div>
<div class="paragraph">
<p>幸运的是，他知道使用 <code>join</code> 将 <code>Rat`s 转换为字符串，通过调用 `Rat</code> 类的 <code>Str</code> 方法完成将 <code>Rat</code> 转换为 <code>Str</code>。因此，通过修改 <code>Rat.Str</code> 的行为，他认为可以使输出更漂亮。</p>
</div>
<div class="paragraph">
<p>他决定这样做的方式是包装(<code>wrap</code>) <code>Str</code> 方法（又名使用装饰器模式），如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Rat.^find_method(&#39;Str&#39;).wrap:
  sub ($r) {
    my $whole = $r.Int || &#34;&#34;;
    my $frac = $r - $whole;
    return &#34;$whole&#34; unless $frac &gt; 0;
    return &#34;$whole&#34; ~ &lt;⅛ ¼ ⅜ ½ ⅝ ¾ ⅞&gt;[$frac * 8 - 1];
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>换句话说，当把 <code>Rat</code> 字符串化时，除非有小数部分，否则返回整个部分。然后将小数部分视为八分之一数，并将其用作数组中的索引以查找正确的 unicode 分数。</p>
</div>
<div class="paragraph">
<p>他将这一点与他的第一个程序结合起来，以获得这样的高度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">0, ⅜, 3, 5⅝, 8¼, 10⅞, 13½, 16⅛, 18¾, 21⅜</code></pre>
</div>
</div>
<div class="paragraph">
<p>“万岁!” 他想。 “正是我需要的。”</p>
</div>
<div class="paragraph">
<p>圣诞老人看了看这个程序，并说：“猫王，这很聪明，但还不够。虽然大多数砖块的尺寸是 ⅛ 的倍数，但砂浆水平可能并非如此。你也可以让你的程序处理这些情况吗？“</p>
</div>
<div class="paragraph">
<p>“当然”，猫王苦笑着说。然后他将这一行添加到他的包装函数中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">return &#34;$whole {$frac.numerator}⁄{$frac.denominator}&#34;
   unless $frac %% ⅛;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用“可被整除”操作符（<code>%%</code>），以确保分数可以平分为八分之一，并且如果不是只显式地打印分子和分母。然后，对于 ⅕” 厚的砂浆，序列为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @heights = 0, ⅕,
                 ⅕ + 2+¼ + ⅕,
                 ⅕ + 2+¼ + ⅕
                   + 2+¼ + ⅕ ... *;
say @heights[^10].join(&#39;, &#39;);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">0,  1⁄5, 2 13⁄20, 5 1⁄10, 7 11⁄20, 10, 12 9⁄20, 14 9⁄10, 17 7⁄20, 19 4⁄5</code></pre>
</div>
</div>
<div class="paragraph">
<p>“实际上”，圣诞老人说，“现在在我看来，也许这没有用 - 卷尺只有十六分之一英寸，所以最好四舍五入到十六分之一英寸。”</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2017/12/tape-measure.jpg?w=1570">img</a></p>
</div>
<div class="paragraph">
<p>猫王加了一个 <code>round</code> 调用来结束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Rat.^find_method(&#39;Str&#39;).wrap:
  sub ($r) {
        my $whole = $r.Int || &#39;&#39;;
        my $frac = $r - $whole;
        return &#34;$whole&#34; unless $frac &gt; 0;
        my $rounded = ($frac * 16).round/16;
        return &#34;$whole&#34; ~ &lt;⅛ ¼ ⅜ ½ ⅝ ¾ ⅞&gt;[$frac * 8 - 1] if $rounded %% ⅛;
        return &#34;$whole {$rounded.numerator}⁄{$rounded.denominator}&#34;;
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这给了他：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">0,  3⁄16, 2⅝, 5⅛, 7 9⁄16, 10, 12 7⁄16, 14⅞, 17¼, 19 13⁄16</code></pre>
</div>
</div>
<div class="paragraph">
<p>他向 Elvira 精灵展示了他的程序，他说：“真是巧合，我写了一个几乎完全一样的程序！除此之外，我也想知道砖层的底部在哪里。我无法使用序列运算符来完成此操作，因为它不是算术级数，但是我可以使用 lazy gather 和匿名有状态变量！就像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my \brick = 2 + ¼;
my \mortar = ⅜;
my @heights = lazy gather {
    take 0;
    loop { take $ += $_ for mortar, brick }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Elvira 的程序产生了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">0, ⅜, 2⅝, 3, 5¼, 5⅝, 7⅞, 8¼, 10½, 10⅞</code></pre>
</div>
</div>
<div class="paragraph">
<p>即砖层的顶部和底部：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">                     \ 🎅 /
                       ██
                       ||
 layer                                      total
       ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
  2¼   ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
       ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
   ⅜                                        ‾‾8¼
       ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░‾‾7⅞
  2¼   ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░
       ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░
   ⅜                                        ‾‾5⅝
       ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░‾‾5¼
  2¼   ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░
       ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░
   ⅜                                        ‾‾3
       ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░‾‾2⅝
  2¼   ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░
       ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░
   ⅜   _____________________________________‾‾⅜
                                            ‾‾0</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了他们的程序在手，精灵检查了烟囱，圣诞老人在另一个节日期间没有受伤。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十一天_raku_中所有的星号">10. 第十一天-Raku 中所有的星号</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在今年的 Raku Advent Calendar 中, 雪花被今天的博客文章承包了。 我们将检阅使用了 <code><strong></strong></code><strong> 字符的结构。 在 Raku 中，根据上下文的不同，您可以叫它星星（或者，如果你愿意的话，可以叫它星号）或者 *whatever</strong>。</p>
</div>
<div class="paragraph">
<p>Raku 不是一个隐秘的编程语言， 在许多方面它的语法比 Perl 5 更加一致。另一方面，有些地方需要花时间来开启对语法的信心。</p>
</div>
<div class="paragraph">
<p>让我们看看 <code><strong></strong></code><strong> 的不同用法，从最简单的开始，旨在了解最烧脑的例如 <code></code></strong><code> ** *</code>。</p>
</div>
<div class="paragraph">
<p>前两种用法很简单，不需要太多的讨论：</p>
</div>
<div class="sect2">
<h3 id="_1_乘法">10.1. 1. 乘法</h3>
<div class="paragraph">
<p>单个星号用于乘法。严格来讲, 这是一个中缀操作符 <code>infix:&lt;*&gt;</code>, 它的返回值为 <code>Numeric</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say 20 * 18; # 360</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_幂">10.2. 2. 幂</h3>
<div class="paragraph">
<p>两个星号 <code><strong></strong></code><strong> 是幂操作符。再次, 这是一个中缀操作符 <code>infix:&lt;</code></strong><code>&gt;</code>, 它返回 <code>Numeric</code> 结果, 计算两个给定值点幂。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say pi ** e; # 22.4591577183611</code></pre>
</div>
</div>
<hr/>
<div class="paragraph">
<p>正则表达式中同样也使用了两个标记（<code><strong></strong></code><strong> 或 <code></code></strong><code>*</code>），它们表示不同的东西。 Raku 的一个特点是它可以很容易地在不同的语言之间切换。 正则表达式和 grammar 都是这样的内部语言的例子，其中同样的符号在 Raku 中可能意味着不同的含义。</p>
</div>
</div>
<div class="sect2">
<h3 id="_3_零或多次重复">10.3. 3. 零或多次重复</h3>
<div class="paragraph">
<p><code>*</code> 号量词这个语法条目和 Perl 5 中点行为类似: 允许原子的零次或多次重复。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my $weather = &#39;*****&#39;;
my $snow = $weather ~~ / (&#39;*&#39;*) /;
say &#39;Snow level is &#39; ~ $snow.chars; # Snow level is 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然, 我们还在这儿看到了同一个字符的另一种用法, <code>*</code> 字面量。</p>
</div>
</div>
<div class="sect2">
<h3 id="_4_min_到_max_次重复">10.4. 4. Min 到 Max 次重复</h3>
<div class="paragraph">
<p>两个 <code>**</code> 号是另一个量词的一部分，它指定了最小和最大重复次数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my $operator = &#39;..&#39;;
say &#34;&#39;$operator&#39; is a valid Raku operator&#34;
    if $operator ~~ /^ &#39;.&#39; ** 1..3 $/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，预计这个点会被重复一次，两次或三次; 不多也不少。</p>
</div>
<div class="paragraph">
<p>让我们超前一点儿，以 <code>Whatever</code> 符号的角色（剧场中的角色，而不是 Raku 的面向对象编程）使用星号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my $phrase = &#39;I love you......&#39;;
say &#39;You are so uncertain...&#39;
    if $phrase ~~ / &#39;.&#39; ** 4..* /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>范围的第二个端点是打开的，这个正则表达式接受所有其中包含四个点以上的短语。</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_吞噬参数">10.5. 5. 吞噬参数</h3>
<div class="paragraph">
<p>在子例程签名的数组参数之前的星号意味着吞噬参数 - 将单独的标量参数吞噬进单个数组中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">list-gifts(&#39;chocolade&#39;, &#39;ipad&#39;, &#39;camelia&#39;, &#39;raku&#39;);

sub list-gifts(*@items) {
    say &#39;Look at my gifts this year:&#39;;
    .say for @items;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>哈希也允许吞噬参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">dump(alpha =&gt; &#39;a&#39;, beta =&gt; &#39;b&#39;); # Prints:
                                 # alpha = a
                                 # beta = b

sub dump(*%data) {
    for %data.kv {say &#34;$^a = $^b&#34;}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，与 Perl 5 不同的是，如果您省略函数签名中的星号，代码将无法编译，因为 Raku 就是说一不二：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Too few positionals passed; expected 1 argument but got 0</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_6_吨吨吨吨吨吨吨">10.6. 6. 吨吨吨吨吨吨吨</h3>
<div class="paragraph">
<p><code>**@</code> 也能工作，但是当你传递数组或列表的时候请注意其中的区别。</p>
</div>
<div class="paragraph">
<p>带一颗星星：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my @a = &lt; chocolade ipad &gt;;
my @b = &lt; camelia raku &gt;;

all-together(@a, @b);
all-together([&#39;chocolade&#39;, &#39;ipad&#39;], [&#39;camelia&#39;, &#39;raku&#39;]);
all-together(&lt; chocolade ipad &gt;, &lt; camelia raku &gt;);

sub all-together(*@items) {
    .say for @items;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>目前，无论参数列表传递的方式如何，每个礼物都被单独打印了出来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">chocolade
ipad
camelia
raku
chocolade
ipad
camelia
raku
chocolade
ipad
camelia
raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>带俩颗星星：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">keep-groupped(@a, @b);
keep-groupped([&#39;chocolade&#39;, &#39;ipad&#39;], [&#39;camelia&#39;, &#39;raku&#39;]);
keep-groupped(&lt; chocolade ipad &gt;, &lt; camelia raku &gt;);

sub keep-groupped(**@items) {
    .say for @items;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次，<code>@items</code> 数组只有两个元素，反映了参数的结构类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">[chocolade ipad]
[camelia raku]</code></pre>
</div>
</div>
<div class="paragraph">
<p>或</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">(chocolade ipad)
(camelia raku)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_7_动态作用域">10.7. 7. 动态作用域</h3>
<div class="paragraph">
<p><code>*</code> twigil，引入了动态作用域。 动态变量和全局变量很容易搞混淆，所以最好测试下面的代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">sub happy-new-year() {
    &#34;Happy new $*year year!&#34;
}

my $*year = 2018;
say happy-new-year(); # 输出 Happy new 2018 year!</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你省略了星号, 那么代码就运行不了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">Variable &#39;$year&#39; is not declared</code></pre>
</div>
</div>
<div class="paragraph">
<p>更正它的唯一方法是将 <code>$year</code> 的定义移到函数定义的上面。 使用动态变量 <code>$*year</code>，函数被调用的地方定义了结果。 <code>$*year</code> 变量在子例程的外部作用域中是不可见的，但是在动态作用域内是可见的。</p>
</div>
<div class="paragraph">
<p>对于动态变量，将新值赋给现有变量还是创建新变量并不重要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">sub happy-new-year() {
    &#34;Happy new $*year year!&#34;
}

my $*year = 2018;
say happy-new-year();

{
    $*year = 2019;        # New value
    say happy-new-year(); # 2019
}

{
    my $*year = 2020;     # New variable
    say happy-new-year(); # 2020
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_8_编译变量">10.8. 8. 编译变量</h3>
<div class="paragraph">
<p>Raku 提供了许多伪动态常量, 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say $*PERL;      # Raku (6.c)
say @*ARGS;      # Prints command-line arguments
say %*ENV&lt;HOME&gt;; # Prints home directory</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_9_all_methods">10.9. 9. All methods</h3>
<div class="paragraph">
<p><code>.*</code> postfix 伪操作符调用给定名称的所有方法，名称可以在给定的对象中找到，并返回一个结果列表。 在微不足道的情况下，你会得到一个学术上荒诞不羁的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">6.*perl.*say; # (6 Int.new)</code></pre>
</div>
</div>
<div class="paragraph">
<p>带星号的代码与不带星号代码有些不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">pi.perl.say; # 3.14159265358979e0 (notice the scientific
             # format, unlike pi.say)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.*</code> postfix 的真正威力来自于继承。 它有时有助于揭示真相：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">class Present {
    method giver() {
        &#39;parents&#39;
    }
}

class ChristmasPresent is Present {
    method giver() {
        &#39;Santa Claus&#39;
    }
}

my ChristmasPresent $present;

$present.giver.say;             # Santa Claus
$present.*giver.join(&#39;, &#39;).say; # Santa Claus, parents</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个星号就差别很大!</p>
</div>
<hr/>
<div class="paragraph">
<p>现在，到了 Raku 最神秘的部分。接下来的两个概念，<code>Whatever</code> 和 <code>WhateverCode</code> 类，很容易混淆在一起。 让我们试着做对吧。</p>
</div>
</div>
<div class="sect2">
<h3 id="_10_whatever">10.10. 10. Whatever</h3>
<div class="paragraph">
<p>单个星号 <code>*</code> 能表示任何东西(<code>Whatever</code>)。 <code>Whatever</code> 在 Raku 中是一个预定义好的类, 它在某些有用的场景下引入了一些规定好的行为。</p>
</div>
<div class="paragraph">
<p>例如，在范围和序列中，最后的 <code>*</code> 表示无穷大。 我们今天已经看到了一个例子。 这是另一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">.say for 1 .. *;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个单行程序具有非常高的能量转换效率，因为它产生了一个递增整数的无限列表。 如果你要继续，请按 <code>Ctrl + C</code>。</p>
</div>
<div class="paragraph">
<p>范围 <code>1 .. *</code> 与 <code>1 .. Inf</code> 相同。 您可以清楚地看到，如果您跳转到 Rakudo Raku 源文件并在 <a href="https://github.com/rakudo/rakudo/blob/master/src/core/Range.pm">src/core/Range.pm</a> 文件的 <code>Range</code> 类的实现中找到如下定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">multi method new(Whatever \min,Whatever \max,:$excludes-min,:$excludes-max){
    nqp::create(self)!SET-SELF(-Inf,Inf,$excludes-min,$excludes-max,1);
}
multi method new(Whatever \min, \max, :$excludes-min, :$excludes-max) {
    nqp::create(self)!SET-SELF(-Inf,max,$excludes-min,$excludes-max,1);
}
multi method new(\min, Whatever \max, :$excludes-min, :$excludes-max) {
    nqp::create(self)!SET-SELF(min,Inf,$excludes-min,$excludes-max,1);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这三个 multi 构造函数描述了三种情况：<code>* .. <strong></strong></code><strong>，<code></code></strong><code> .. $n</code> 和 <code>$n .. *</code>，它们被立即转换为 <code>-Inf .. Inf</code>，<code>-Inf .. $n</code> 和 <code>$n .. Inf</code>。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>作为一个圣诞故事，这里有一个小小的插曲，表明 <code>*</code> 不仅仅是一个 <code>Inf</code>。 有两个到 <a href="https://github.com/rakudo/rakudo/blob/master/src/core/Whatever.pm">src/core/Whatever.pm</a> 的提交：</p>
</div>
</blockquote>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>首先，2015年9月16日，&#34;<a href="https://github.com/rakudo/rakudo/commit/425845d723afb60d80dcca55b509ff1c1f9b303c#diff-ac169f9e5137f98d305f3cae4c0c4d07" class="bare">https://github.com/rakudo/rakudo/commit/425845d723afb60d80dcca55b509ff1c1f9b303c#diff-ac169f9e5137f98d305f3cae4c0c4d07</a>:&#34;</p>
</div>
</blockquote>
</div>
<div class="literalblock">
<div class="content">
<pre>  my class Whatever {
      multi method ACCEPTS(Whatever:D: $topic) { True }
      multi method perl(Whatever:D:) { &#39;*&#39; }
+     multi method Numeric(Whatever:D:) { Inf }
  }</pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>几周之后, 在2015年10月23日，&#34;<a href="https://github.com/rakudo/rakudo/commit/4e35e807c5f0c8ac134e1ed87b4b9343966d0d8d#diff-ac169f9e5137f98d305f3cae4c0c4d07">* no longer defaults to Inf</a>&#34;，这是为了保护其他 dwimmy 情况下的扩展性:</p>
</div>
</blockquote>
</div>
<div class="literalblock">
<div class="content">
<pre>  my class Whatever {
      multi method ACCEPTS(Whatever:D: $topic) { True }
      multi method perl(Whatever:D:) { &#39;*&#39; }
-     multi method Numeric(Whatever:D:) { Inf }
  }</pre>
</div>
</div>
<div class="paragraph">
<p>回到我们更实际的问题，让我们创建自己的使用 whatever 符号 <code>*</code> 的类，。 下面是一个简单的例子，它带有一个接收 <code>Int</code> 值或者 <code>Whatever</code> 的 multi-方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">class N {
    multi method display(Int $n) {
        say $n;
    }

    multi method display(Whatever) {
        say 2000 + 100.rand.Int;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第一种情况下，该方法只是打印该值。 第二种方法是打印一个在 2000 到 2100 之间的随机数。 因为第二种方法的唯一参数是 <code>Whatever</code>，所以签名中不需要变量。</p>
</div>
<div class="paragraph">
<p>下面是你如何使用这个类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my $n = N.new;
$n.display(2018);
$n.display(*);</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个调用回显它的参数，而第二个调用打印某些随机的东西。</p>
</div>
<div class="paragraph">
<p><code>Whatever</code> 符号可以作为一个裸的 <code>Whatever</code>。 假如，你创建一个 <code>echo</code> 函数，并将 <code>*</code> 传递给它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">sub echo($x) {
    say $x;
}

echo(2018); # 2018
echo(*);    # *</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次，没有魔术发生，该程序打印一个星号。</p>
</div>
<div class="paragraph">
<p>现在我们正处在一个四两拨千斤的节骨眼上。</p>
</div>
</div>
<div class="sect2">
<h3 id="_11_whatevercode">10.11. 11. WhateverCode</h3>
<div class="paragraph">
<p>最后, 我们来谈谈 <code>WhateverCode</code>。</p>
</div>
<div class="paragraph">
<p>取一个数组然后打印出它的最后一个元素。如果你使用 Perl 5 的风格来做, 你会键入 <code>@a[-1]</code> 那样的东西。在 Raku 中, 那会产生错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Unsupported use of a negative -1 subscript
to index from the end; in Raku please
use a function such as *-1</code></pre>
</div>
</div>
<div class="paragraph">
<p>编译器建议使用一个函数, 例如 <code>*-1</code>。它是函数吗？是的, 更准确的说, 它是一个 <code>WhateverCode</code> 块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say (*-1).WHAT; # (WhateverCode)</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 打印数组的后半部分:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my @a = &lt; one two three four five six &gt;;
say @a[3..*]; # (four five six)</code></pre>
</div>
</div>
<div class="paragraph">
<p>数组的索引的范围是 <code>3 .. *</code>。 <code>Whatever</code> 作为 range 的右端意味着从数组中取出所有剩余的元素。 <code>3 .. *</code> 的类型是 <code>Range</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say (3..*).WHAT; # (Range)</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，减少一个元素。 我们已经看到，要指定最后一个元素，必须要使用诸如 <code>*-1</code> 的函数。 在 range 的右端可以做同样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say @a[3 .. *-2]; # (four five)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个时候，发生了所谓的 <code>Whatever-柯里化</code>，<code>Range</code> 变成了 <code>WhateverCode</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say (3 .. *-2).WHAT; # (WhateverCode)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>WhateverCode</code> 是一个内置的 Raku 类名称; 它可以很容易地用于方法分派。 让我们更新上一节中的代码，并添加一个方法变体，它需要一个 <code>WhateverCode</code> 参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">class N {
    multi method display(Int $n) {
        say $n;
    }

    multi method display(Whatever) {
        say 2000 + 100.rand.Int;
    }

    multi method display(WhateverCode $code) {
        say $code(2000 + 100.rand.Int);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，参数列表中的星号要么落入 <code>display(Whatever)</code>, 要么落入 <code>display(WhateverCode)</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">N.display(2018);     # display(Int $n)

N.display(*);        # display(Whatever)

N.display(* / 2);    # display(WhateverCode $code)
N.display(* - 1000); # display(WhateverCode $code)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们再来看看 <code>display</code> 方法中的签名:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">multi method display(WhateverCode $code)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$code</code> 参数被用作方法内的函数引用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say $code(2000 + 100.rand.Int);</code></pre>
</div>
</div>
<div class="paragraph">
<p>该函数需要一个参数，但它会去哪里？ 或者换句话说，函数体是什么，在哪里？ 我们将该方法调用为 <code>N.display(* / 2)</code> 或 <code>N.display(* - 1000)</code>。 答案是 <code>* / 2</code> 和 <code>* - 1000</code> 都是函数！ 还记得编译器关于使用诸如 <code>*-1</code> 之类的函数的提示吗？</p>
</div>
<div class="paragraph">
<p>这里的星号成为第一个函数参数，因此 <code>* / 2</code> 相当于 <code>{$^a / 2}</code>，而 <code>*-1000</code> 相当于 <code>{$^a - 1000}</code>。</p>
</div>
<div class="paragraph">
<p>这是否意味着可以在 <code>$^a</code> 的旁边使用 <code>$^b</code>? 当然！ 使 <code>WhateverCode</code> 块接受两个参数。 你如何指出其中的第二个？ 毫不惊喜，再用一个星号！ 让我们将 <code>display</code> 方法的第四个变体添加到我们的类中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">multi method display(WhateverCode $code
                     where {$code.arity == 2}) {
    say $code(2000, 100.rand.Int);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，使用 <code>where</code> 块来缩小调度范围，只选择那些有两个参数的 <code>WhateverCode</code> 块。 完成此操作后，方法调用中将允许含有两个雪花：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">N.display( * + * );
N.display( * - * );</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些调用定义了用于计算结果的函数 <code>$code</code>。 所以，<code>N.display(* + *)</code> 背后的实际操作如下：<code>2000 + 100.rand.Int</code>。</p>
</div>
<div class="paragraph">
<p>需要更多的雪花吗？ 多添加点星星：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">N.display( * * * );
N.display( * ** * );</code></pre>
</div>
</div>
<div class="paragraph">
<p>类似地, 里面实际的计算是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">2000 * 100.rand.Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>和</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">2000 ** 100.rand.Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>恭喜！ 你现在可以像编译器那样毫不费力地解析 <code>* ** *</code> 结构了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_作业">10.12. 作业</h3>
<div class="paragraph">
<p>到目前为止，Raku 给了我们很多圣诞礼物。 让我们回过头来做一下练习并回答一下问题：下面代码中的每个星号在意味着什么？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my @n =
    ((0, 1, * + * ... *).grep: *.is-prime).map: * * * * *;
.say for @n[^5];</code></pre>
</div>
</div>
<div class="paragraph">
<p>D’哦。 我建议我们从转换代码开始来摆脱所有的星号，并使用不同的语法。</p>
</div>
<div class="paragraph">
<p>序列运算符 <code>…​</code> 之后的 <code>*</code> 意味着无限地生成序列，所以用 <code>Inf</code> 来代替它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">((0, 1, * + * ... Inf).grep: *.is-prime).map: * * * * *</code></pre>
</div>
</div>
<div class="paragraph">
<p>生成器函数中的两个星号 <code>* + *</code> 可以用一个带有两个显式参数的 lambda 函数来替换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">((0, 1, -&gt; $x, $y {$x + $y} ... Inf).grep:
    *.is-prime).map: * * * * *</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，简单的语法交替。 用带圆括号的方法调用替换 <code>.grep</code>。 它的参数 <code><strong>.is-prime</strong></code><strong> 变成一个代码块，并且星号被替换为默认变量 <code>$_</code>。 请注意，代码使用 <code></code></strong> 时不需要花括号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">(0, 1, -&gt; $x, $y {$x + $y} ... Inf).grep({
    $_.is-prime
}).map: * * * * *</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，与 <code>.map</code> 相同的技巧：但是这次这个方法有三个参数，因此，你可以编写 <code>{$^a * $^b * $^c}</code> 而不是 <code>* * * * *</code>，这里是新的 完整程序的变体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my @n = (0, 1, -&gt; $x, $y {$x + $y} ... Inf).grep({
        $_.is-prime
    }).map({
        $^a * $^b * $^c
    });
.say for @n[^5];</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在很明显，代码打印了三个斐波那契素数组积的前五个。</p>
</div>
</div>
<div class="sect2">
<h3 id="_附加题">10.13. 附加题</h3>
<div class="paragraph">
<p>在教科书中，最具挑战性的任务是用 <code>*</code> 标记的。 这里有几个由你自己来解决。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1. Raku 中的 <code>chdir(&#39;/&#39;)</code> 和 <code>＆*chdir(&#39;/&#39;)</code> 有什么区别？</p>
</li>
<li>
<p>2. 解释下面的 Raku 代码并修改它以展示其优点：<code>.say for 1 …​ **</code>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>❄❄❄</p>
</div>
<div class="paragraph">
<p>今天就这样了。 我希望你喜欢 Raku 的强大功能和表现力。今天，我们只谈到了一个 ASCII 字符。 想象一下，如果考虑到该语言在当今编程语言中提供了最好的 Unicode 支持，Raku 的 Universe 是多么的庞大。</p>
</div>
<div class="paragraph">
<p>今天享受 Raku，并传播这个词！ 请继续关注 Raku Advent Calendar; 更多的文章正在等待你的关注，明天就要来了。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十二天_the_year_of_raku_books">11. <a href="https://rakuadvent.wordpress.com/2017/12/12/day-12-the-year-of-perl-6-books/">第十二天 – The Year of Raku Books</a></h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_第十三天_使用_raku_挖掘维基百科">12. 第十三天 - 使用 Raku 挖掘维基百科</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_介绍">12.1. 介绍</h3>
<div class="paragraph">
<p>大家好!</p>
</div>
<div class="paragraph">
<p>今天，让我介绍一下如何用 Raku 挖掘维基百科的 Infobox。</p>
</div>
<div class="paragraph">
<p>维基百科信息框在自然语言处理中扮演着非常重要的角色，并且有许多应用程序可以利用维基百科信息框：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>构建知识库（例如 DBpedia[0]）</p>
</li>
<li>
<p>排名属性的重要性[1]</p>
</li>
<li>
<p>问答[2]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>其中，我将重点讨论信息框提取问题，并演示如何使用 Grammars 和 Actions 解析信息框的复杂结构。</p>
</div>
</div>
<div class="sect2">
<h3 id="_grammar_和_actions_难学吗">12.2. Grammar 和 Actions 难学吗?</h3>
<div class="paragraph">
<p>不，他们不是！</p>
</div>
<div class="paragraph">
<p>你只需要知道五件事情：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Grammar</p>
</li>
<li>
<p><strong>token</strong> 是最基础的一个。你通常使用它。</p>
</li>
<li>
<p><strong>rule</strong> 让空白符有意义。</p>
</li>
<li>
<p><strong>regex</strong> 让匹配引擎回溯。</p>
</li>
<li>
<p>Actions</p>
</li>
<li>
<p><strong>make</strong> 准备一个对象用于返回当 made calls on it。</p>
</li>
<li>
<p><strong>made</strong> 在它的调用者身上调用并返回准备好的对象。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>欲了解更多信息, 请查看: <a href="https://docs.raku.org/language/grammars">https://docs.raku.org/language/grammars</a></p>
</div>
<div class="sect3">
<h4 id="_什么是_infobox">12.2.1. 什么是 Infobox?</h4>
<div class="paragraph">
<p>你有没有听过 &#34;Infobox&#34; 这个词?</p>
</div>
<div class="paragraph">
<p>对于那些没听说过的人，我会简单地解释一下。</p>
</div>
<div class="paragraph">
<p>理解信息框的一个简单方法是使用一个真实的例子：</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2017/11/rakuinfobox.png">img</a></p>
</div>
<div class="paragraph">
<p>你可以看到，信息框会在页面的右上方显示页面主题的属性-值对儿。例如, 在这个例子中, 它说 Raku 的设计者 (ja: 設計者)是 Larry Wall(ja: ラリー・ウォール)。</p>
</div>
<div class="paragraph">
<p>欲了解更多信息, 请查看: <a href="https://en.wikipedia.org/wiki/Help:Infobox">https://en.wikipedia.org/wiki/Help:Infobox</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_第一个例子_raku">12.2.2. 第一个例子: Raku</h4>
<div class="paragraph">
<p>首先要说的是，我将使用日文维基百科而不是英文维基百科演示解析技术。</p>
</div>
<div class="paragraph">
<p>主要原因是解析日文维基百科是我的$ dayjob :)</p>
</div>
<div class="paragraph">
<p>第二个原因是我想要展示 Raku 如何轻松地处理 Unicode 字符串。</p>
</div>
<div class="paragraph">
<p>然后，让我们开始解析 <a href="https://ja.wikipedia.org/wiki/Perl_6">Raku 文章</a>中的信息框！</p>
</div>
<div class="paragraph">
<p>用 wiki 标记写的文章的代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">{{Comp-stub}}

{{Infobox プログラミング言語
|名前             = Raku
|ロゴ             = [[Image:Camelia.svg|250px]]
|パラダイム       = [[マルチパラダイムプログラミング言語|マルチパラダイム]]
|登場時期         = [[2015年]]12月25日
|設計者           = [[ラリー・ウォール]]
|最新リリース     = Rakudo Star 2016.04
|型付け           = [[動的型付け]], [[静的型付け]]
|処理系           = [[Rakudo]]
|影響を受けた言語 = [[Perl|Perl 5]], [[Smalltalk]], [[Haskell]], [[Ruby]]
|ライセンス       = [[Artistic License 2]]
|ウェブサイト     = [https://raku.org/ Raku.org]
}}
{{プログラミング言語}}

&#39;&#39;&#39;Raku&#39;&#39;&#39;（パールシックス）は、[[ラリー・ウォール]]により設計された[[オブジェクト指向]][[スクリプト言語]]である。

Rakuは、[[2000年]]に[[Perl]]の次期メジャーバージョンとして設計が始められ、[[2015年]]12月25日に公式のRaku正式安定版がリリースされた。しかし、言語仕様は現在のPerl (Perl 5)と互換性がなく、既存のPerl 5のソフトウェアをRaku用に「アップグレ
ード」するのは極めて困難である。したがって現在はPerl 5とRakuは別の言語であると考えられており、RakuはPerl 5の次期バージョンではないとされている。換言すれば、RakuはPerl 5から移行対象とはみなされていない。</code></pre>
</div>
</div>
<div class="paragraph">
<p>代码有三个有问题的部分：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>信息框块后面有多余的元素，例如模板 <code>{{プログラミング言語}}</code> 和以 <code>&#39;&#39;&#39;Raku&#39;&#39;&#39;</code> 开头的主句。</p>
</li>
<li>
<p>我们必须区分三种类型的 token: 锚点文本（例如: <code><a id="Rakudo"></a></code>）, 原始文本（例如： <code>Rakudo Star 2016.04</code>）, 网站链接
（例如： <code>[<a href="https://raku.org/" class="bare">https://raku.org/</a> Raku.org]</code>）。</p>
</li>
<li>
<p>信息框不从文章的顶部位置开始。在这个例子中, <code>{{Comb-stub}}</code> 在文章的顶部。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>好的，接下来我将演示如何按照 Grammar，Actions，Caller（即调用 Grammar 和 Actions 的代码部分）的顺序来解决上述问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="_grammar">12.2.3. Grammar</h4>
<div class="paragraph">
<p>解析信息框的 Grammar 代码如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Infobox::Grammar {
    token TOP { &lt;infobox&gt; .+ } # (#1)
    token infobox { &#39;{{Infobox&#39; &lt;.ws&gt; &lt;name&gt; \n &lt;propertylist&gt; &#39;}}&#39; }
    token name { &lt;-[\n]&gt;+ }
    token propertylist {
        [
            | &lt;property&gt; \n
            | \n
        ]+
    }
    token property {
        &#39;|&#39; &lt;key=.key-content&gt; &#39;=&#39; &lt;value=.value-content-list&gt;
    }

    token key-content { &lt;-[=\n]&gt;+ }
    token value-content-list {
        &lt;value-content&gt;+
    }
    token value-content { # (#6)
        [
            | &lt;anchortext&gt;
            | &lt;weblink&gt;
            | &lt;rawtext&gt;
            | &lt;delimiter&gt;
        ]+
    }
    token anchortext { &#39;[[&#39; &lt;-[\n]&gt;+? &#39;]]&#39;        } # (#2)
    token weblink    { &#39;[&#39; &lt;-[\n]&gt;+? &#39;]&#39;          } # (#3)
    token rawtext    { &lt;-[\|\[\]\n、\,\&lt;\&gt;\}\{]&gt;+ } # (#4)
    token delimiter  { [ &#39;、&#39; | &#39;,&#39; ]             } # (#5)
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>问题 1 的答案:</p>
</li>
<li>
<p>使用 <code>.+</code> 来匹配多余的部分。(#1)</p>
</li>
<li>
<p>问题 2 的答案:</p>
</li>
<li>
<p>准备 3 种类型的 tokens: 锚文本(#2), 网站链接(#2), 和原始文本(#4)。</p>
</li>
<li>
<p>tokens 可能被分隔符（例如: <code>,</code>）分割, 所以准备分割符 token。(#5)</p>
</li>
<li>
<p>将 token 值-内容表示为四个 token 的任意长度序列（即，锚点文本，网站链接，原始文本，分隔符）。(#6)</p>
</li>
<li>
<p>问题 3 的答案:</p>
</li>
<li>
<p>没有特别的事情要提及。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_actions">12.2.4. Actions</h4>
<div class="paragraph">
<p>Actions 的代码如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Infobox::Actions {
    method TOP($/) { make $&lt;infobox&gt;.made }
    method infobox($/) {
        make %( name =&gt; $&lt;name&gt;.made, propertylist =&gt; $&lt;propertylist&gt;.made )
    }
    method name($/) { make ~$/.trim }
    method propertylist($/) {
        make $&lt;property&gt;&gt;&gt;.made
    }
    method property($/) {
        make $&lt;key&gt;.made =&gt; $&lt;value&gt;.made
    }
    method key-content($/) { make $/.trim }
    method value-content-list($/) {
        make $&lt;value-content&gt;&gt;&gt;.made
    }
    method value-content($/) { # (#1)
        my $rawtext = $&lt;rawtext&gt;&gt;&gt;.made&gt;&gt;.trim.grep({ $_ ne &#34;&#34; });

        make %(
            anchortext =&gt; $&lt;anchortext&gt;&gt;&gt;.made,
            weblink =&gt; $&lt;weblink&gt;&gt;&gt;.made,
            rawtext =&gt; $rawtext.elems == 0 ?? $[] !! $rawtext.Array
        );
    }
    method anchortext($/) {
        make ~$/;
    }
    method weblink($/) {
        make ~$/;
    }
    method rawtext($/) {
        make ~$/;
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>问题 2 的解决方法:</p>
</li>
<li>
<p>使 token value-content 由三个键组成：anchortext，weblink 和 rawtext。</p>
</li>
<li>
<p>问题 1 和 3的解决方法:</p>
</li>
<li>
<p>没有特别的事情要提及。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_caller">12.2.5. Caller</h4>
<div class="paragraph">
<p>Caller 部分的代码如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @lines = $*IN.lines;
while @lines {
    my $chunk = @lines.join(&#34;\n&#34;); # (#1)
    my $result = Infobox::Grammar.parse($chunk, actions =&gt; Infobox::Actions).made; # (#2)
    if $result&lt;name&gt;:exists {
        $result&lt;name&gt;.say;
        for @($result&lt;propertylist&gt;) -&gt; (:$key, :value($content-list)) { # (#3)
            $key.say;
            for @($content-list) -&gt; $content {
                $content.say;
            }
        }
    }
    shift @lines;
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>问题 3 的解决方法:</p>
</li>
<li>
<p>逐行阅读文章并制作一个包含当前行和最后一行之间的行的块。 （＃1）</p>
</li>
<li>
<p>如果解析器确定：</p>
</li>
<li>
<p>该块不包含信息框，它返回一个未定义的值。接收未定义值的好方法之一是使用 <code>$</code> 符号。(#2)</p>
</li>
<li>
<p>该块包含信息框，它返回一个定义的值。使用 <code>@()</code> contextualizer 并迭代结果。(#3)</p>
</li>
<li>
<p>问题 1 和 2 的解决方法：</p>
</li>
<li>
<p>没有特别的事情要提及。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_运行解析器">12.2.6. 运行解析器</h4>
<div class="paragraph">
<p>你准备好了吗？
是时候运行第一个例子了！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku parser.p6 &lt; raku.txt
プログラミング言語
名前
{anchortext =&gt; [], rawtext =&gt; [Raku], weblink =&gt; []}
ロゴ
{anchortext =&gt; [[[Image:Camelia.svg|250px]]], rawtext =&gt; [], weblink =&gt; []}
パラダイム
{anchortext =&gt; [[[マルチパラダイムプログラミング言語|マルチパラダイム]]], rawtext =&gt; [], weblink =&gt; []}
登場時期
{anchortext =&gt; [[[2015年]]], rawtext =&gt; [12月25日], weblink =&gt; []}
設計者
{anchortext =&gt; [[[ラリー・ウォール]]], rawtext =&gt; [], weblink =&gt; []}
最新リリース
{anchortext =&gt; [], rawtext =&gt; [Rakudo Star 2016.04], weblink =&gt; []}
型付け
{anchortext =&gt; [[[動的型付け]] [[静的型付け]]], rawtext =&gt; [], weblink =&gt; []}
処理系
{anchortext =&gt; [[[Rakudo]]], rawtext =&gt; [], weblink =&gt; []}
影響を受けた言語
{anchortext =&gt; [[[Perl|Perl 5]] [[Smalltalk]] [[Haskell]] [[Ruby]]], rawtext =&gt; [], weblink =&gt; []}
ライセンス
{anchortext =&gt; [[[Artistic License 2]]], rawtext =&gt; [], weblink =&gt; []}
ウェブサイト
{anchortext =&gt; [], rawtext =&gt; [], weblink =&gt; [[https://raku.org/ Raku.org]]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们看到的例子可能对您来说太简单了。让我们挑战更难的！</p>
</div>
</div>
<div class="sect3">
<h4 id="_第二个例子_阿尔伯特爱因斯坦">12.2.7. 第二个例子: 阿尔伯特爱因斯坦</h4>
<div class="paragraph">
<p>作为第二个例子，我们来解析<a href="https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%AB%E3%83%99%E3%83%AB%E3%83%88%E3%83%BB%E3%82%A2%E3%82%A4%E3%83%B3%E3%82%B7%E3%83%A5%E3%82%BF%E3%82%A4%E3%83%B3">阿尔伯特爱因斯坦</a>的信息框。</p>
</div>
<div class="paragraph">
<p>用 wiki 标记写的文章的代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">{{Infobox Scientist
|name = アルベルト・アインシュタイン
|image = Einstein1921 by F Schmutzer 2.jpg
|caption = [[1921年]]、[[ウィーン]]での[[講義]]中
|birth_date = {{生年月日と年齢|1879|3|14|no}}
|birth_place = {{DEU1871}}&lt;br&gt;[[ヴュルテンベルク王国]][[ウルム]]
|death_date = {{死亡年月日と没年齢|1879|3|14|1955|4|18}}
|death_place = {{USA1912}}&lt;br /&gt;[[ニュージャージー州]][[プリンストン (ニュージャージー州)|プリンストン]]
|residence = {{DEU}}&lt;br /&gt;{{ITA}}&lt;br&gt;{{CHE}}&lt;br /&gt;{{AUT}}(現在の[[チェコ]])&lt;br /&gt;{{BEL}}&lt;br /&gt;{{USA}}
|nationality = {{DEU1871}}、ヴュルテンベルク王国（1879-96）&lt;br /&gt;[[無国籍]]（1896-1901）&lt;br /&gt;{{CHE}}（1901-55）&lt;br /&gt;{{AUT1867}}（1911-12）&lt;br /&gt;{{DEU1871}}、{{DEU1919}}（1914-33）&lt;br /&gt;{{USA1912}}（1940-55）
| spouse      = [[ミレヴァ・マリッチ]]&amp;nbsp;(1903-1919)&lt;br /&gt;{{nowrap|{{仮リンク|エルザ・アインシュタイン|en|Elsa Einstein|label=エルザ・レーベンタール}}&amp;nbsp;(1919-1936)}}
| children    = [[リーゼル・アインシュタイン|リーゼル]] (1902-1903?)&lt;br /&gt;[[ハンス・アルベルト・アインシュタイン|ハンス
・アルベルト]] (1904-1973)&lt;br /&gt;[[エドゥアルト・アインシュタイン|エドゥアルト]] (1910-1965)
|field = [[物理学]]&lt;br /&gt;[[哲学]]
|work_institution = {{Plainlist|
* [[スイス特許庁]] ([[ベルン]]) (1902-1909)
* {{仮リンク|ベルン大学|en|University of Bern}} (1908-1909)
* [[チューリッヒ大学]] (1909-1911)
* [[プラハ・カレル大学]] (1911-1912)
* [[チューリッヒ工科大学]] (1912-1914)
* [[プロイセン科学アカデミー]] (1914-1933)
* [[フンボルト大学ベルリン]] (1914-1917)
* {{仮リンク|カイザー・ヴィルヘルム協会|en|Kaiser Wilhelm Society|label=カイザー・ヴィルヘルム研究所}} (化学・物理学研究所長, 1917-1933)
* [[ドイツ物理学会]] (会長, 1916-1918)
* [[ライデン大学]] (客員, 1920-)
* [[プリンストン高等研究所]] (1933-1955)
* [[カリフォルニア工科大学]] (客員, 1931-33)
}}
|alma_mater = [[チューリッヒ工科大学]]&lt;br /&gt;[[チューリッヒ大学]]
|doctoral_advisor = {{仮リンク|アルフレート・クライナー|en|Alfred Kleiner}}
|academic_advisors = {{仮リンク|ハインリヒ・フリードリヒ・ウェーバー|en|Heinrich Friedrich Weber}}
|doctoral_students =
|known_for = {{Plainlist|
*[[一般相対性理論]]
*[[特殊相対性理論]]
*[[光電効果]]
*[[ブラウン運動]]
*link:E=mc&lt;sup&gt;2&lt;/sup&gt;[[E=mc2|質量とエネルギーの等価性]]
*[[アインシュタイン方程式]]
*[[ボース分布関数]]
*[[宇宙定数]]
*[[ボース＝アインシュタイン凝縮]]
*[[EPRパラドックス]]
*{{仮リンク|古典統一場論|en|Classical unified field theories}}
}}
| influenced  = {{Plainlist|
* {{仮リンク|エルンスト・G・シュトラウス|en|Ernst G. Straus}}
* [[ネイサン・ローゼン]]
* [[レオ・シラード]]
}}
|prizes = {{Plainlist|
*{{仮リンク|バーナード・メダル|en|Barnard Medal for Meritorious Service to Science}}(1920)
*link:1921[[ノーベル物理学賞]]
*link:1921[[マテウチ・メダル]]
*link:1925[[コプリ・メダル]]
*link:1926[[王立天文学会ゴールドメダル]]
*link:1929[[マックス・プランク・メダル]]
}}
|religion =
|signature = Albert Einstein signature 1934.svg
|footnotes =
}}
{{thumbnail:begin}}
{{thumbnail:ノーベル賞受賞者|1921年|ノーベル物理学賞|光電効果の法則の発見等}}
{{thumbnail:end}}
&#39;&#39;&#39;アルベルト・アインシュタイン&#39;&#39;&#39;&lt;ref group=&#34;†&#34;&gt;[[日本語]]における表記には、他に「アル{{Underline|バー}}ト・アインシュine|バー}}ト・アイン{{Underline|ス}}タイン」（[[英語]]の発音由来）がある。&lt;/ref&gt;（{{lang-de-short|Albert Einstein}}&lt;ref ɛrt ˈaɪnˌʃtaɪn}} &#39;&#39;&#39;ア&#39;&#39;&#39;ルベルト・&#39;&#39;&#39;ア&#39;&#39;&#39;インシュタイン、&#39;&#39;&#39;ア&#39;&#39;&#39;ルバート・&#39;&#39;&#39;ア&#39;&#39;&#39;インシュタイン&lt;/ref&gt;&lt;ref group=&#34;†&#34;taɪn}} &#39;&#39;&#39;ア&#39;&#39;&#39;ルバ（ー）ト・&#39;&#39;&#39;ア&#39;&#39;&#39;インスタイン、&#39;&#39;&#39;ア&#39;&#39;&#39;ルバ（ー）&#39;&#39;&#39;タ&#39;&#39;&#39;インスタイン&lt;/ref&gt;&lt;ref&gt;[http://dictionary.rein Einstein] (Dictionary.com)&lt;/ref&gt;&lt;ref&gt;[http://www.oxfordlearnersdictionaries.com/definition/english/albert-einstein?q=Albert+Einstein Albert Einstein] (Oxford Learner&#39;s Dictionaries)&lt;/ref&gt;、[[1879年]][[3月14日]] - [[1955年]][[4月18日]]）ツ]]生まれの[[理論物理学者]]である。</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你所看到的，这里有五个新问题：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>一些模板</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>包含换行符;并且</p>
</li>
<li>
<p>是嵌套的(例如. <code>{{nowrap|{{仮リンク|…​}}…​}}</code>)</p>
</li>
</ol>
</div>
</li>
<li>
<p>某些 attribute-value 对是空的。</p>
</li>
<li>
<p>attribute-value 对的一些 value-sides</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>包含中断标签;并且</p>
</li>
<li>
<p>由不同类型的 token 组成（例如，anchortext 和 rawtext）。所以你需要添加位置信息来表示 tokens 之间的依赖关系。</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>我将按照 Grammar，Actions 的顺序展示如何解决上述问题。</p>
</div>
<div class="paragraph">
<p>Caller 的代码与前一个相同。</p>
</div>
</div>
<div class="sect3">
<h4 id="_grammar_2">12.2.8. Grammar</h4>
<div class="paragraph">
<p>Grammar 代码如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Infobox::Grammar {
    token TOP { &lt;infobox&gt; .+ }
    token infobox { &#39;{{Infobox&#39; &lt;.ws&gt; &lt;name&gt; \n &lt;propertylist&gt; &#39;}}&#39; }
    token name { &lt;-[\n]&gt;+ }
    token propertylist {
        [
            | &lt;property&gt; \n
            | \n
        ]+
    }
    token property {
        [
            | &#39;|&#39; &lt;key=.key-content&gt; &#39;=&#39; &lt;value=.value-content-list&gt;
            | &#39;|&#39; &lt;key=.key-content&gt; &#39;=&#39; # (#4)
        ]
    }

    token key-content { &lt;-[=\n]&gt;+ }
    token value-content-list {
        [
            | &lt;value-content&gt; &lt;br&gt; # (#6)
            | &lt;value-content&gt;
            | &lt;br&gt;
        ]+
    }
    token value-content-list-nl { # (#1)
        [
            | &lt;value-content&gt; &lt;br&gt; # (#7)
            | &lt;value-content&gt;
            | &lt;br&gt;
        ]+ % \n
    }
    token value-content {
        [
            | &lt;anchortext&gt;
            | &lt;weblink&gt;
            | &lt;rawtext&gt;
            | &lt;template&gt;
            | &lt;delimiter&gt;
            | &lt;sup&gt;
        ]+
    }
    token br { # (#5)
        [
            | &#39;&lt;br /&gt;&#39;
            | &#39;&lt;br/&gt;&#39;
            | &#39;&lt;br&gt;&#39;
        ]
    }
    token template {
        [
            | &#39;{{&#39; &lt;-[\n]&gt;+? &#39;}}&#39;
            | &#39;{{nowrap&#39; &#39;|&#39; &lt;value-content-list&gt; &#39;}}&#39; # (#3)
            | &#39;{{Plainlist&#39; &#39;|&#39; \n &lt;value-content-list-nl&gt; \n &#39;}}&#39; # (#2)
        ]
    }
    token anchortext { &#39;[[&#39; &lt;-[\n]&gt;+? &#39;]]&#39; }
    token weblink { &#39;[&#39; &lt;-[\n]&gt;+? &#39;]&#39; }
    token rawtext { &lt;-[\|\[\]\n、\,\&lt;\&gt;\}\{]&gt;+ }
    token delimiter { [ &#39;、&#39; | &#39;,&#39; | &#39;&amp;nbsp;&#39; ] }
    token sup { &#39;&lt;sup&gt;&#39; &lt;-[\n]&gt;+? &#39;&lt;/sup&gt;&#39;}
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>问题 1.1 的解决方法：</p>
</li>
<li>
<p>创建 token <strong>value-content-list-nl</strong>，它是 value-content-list token 的换行符分隔版本。使用<a href="https://docs.raku.org/language/regexes#Modified_quantifier:_%,_%%">修改量词</a> <code>％</code> 来表示这种序列是很有用的。 （＃1）</p>
</li>
<li>
<p>创建 token 模板。在这一个中，定义一个代表 <a href="https://en.wikipedia.org/wiki/Template:Plainlist">Plainlist 模板</a> 的序列。 （＃2）</p>
</li>
<li>
<p>问题 1.2 的解决方法：</p>
</li>
<li>
<p>使 token 模板能够调用 token value-content-list。此修改触发递归调用并捕获嵌套结构，因为 token value-content-list 包含 token 模板。 （＃3）</p>
</li>
<li>
<p>问题 2 的解决方法：</p>
</li>
<li>
<p>在 token <strong>property</strong> 中，定义一个 value-side 为空的序列（即以&#39;=&#39;结尾的序列）。 （＃4）</p>
</li>
<li>
<p>问题 3.1 的解决方法:</p>
</li>
<li>
<p>创建 token br（＃5）
 - 让 token br 遵循两个 token 中的 token value-content：</p>
</li>
<li>
<p>token value-content-list （＃6）</p>
</li>
<li>
<p>token-content-list-nl（＃7）</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_actions_2">12.2.9. Actions</h4>
<div class="paragraph">
<p>Action 代码如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Infobox::Actions {
    method TOP($/) { make $&lt;infobox&gt;.made }
    method infobox($/) {
        make %( name =&gt; $&lt;name&gt;.made, propertylist =&gt; $&lt;propertylist&gt;.made )
    }
    method name($/) { make $/.trim }
    method propertylist($/) {
        make $&lt;property&gt;&gt;&gt;.made
    }
    method property($/) {
        make $&lt;key&gt;.made =&gt; $&lt;value&gt;.made
    }
    method key-content($/) { make $/.trim }
    method value-content-list($/) {
        make $&lt;value-content&gt;&gt;&gt;.made
    }
    method value-content($/) {
        my $rawtext = $&lt;rawtext&gt;&gt;&gt;.made&gt;&gt;.trim.grep({ $_ ne &#34;&#34; });

        make %(
            anchortext =&gt; $&lt;anchortext&gt;&gt;&gt;.made,
            weblink =&gt; $&lt;weblink&gt;&gt;&gt;.made,
            rawtext =&gt; $rawtext.elems == 0 ?? $[] !! $rawtext.Array,
            template =&gt; $&lt;template&gt;&gt;&gt;.made;
        );
    }
    method template($/) {
        make %(body =&gt; ~$/, from =&gt; $/.from, to =&gt; $/.to); # (#1)
    }
    method anchortext($/) {
        make %(body =&gt; ~$/, from =&gt; $/.from, to =&gt; $/.to); # (#2)
    }
    method weblink($/) {
        make %(body =&gt; ~$/, from =&gt; $/.from, to =&gt; $/.to); # (#3)
    }
    method rawtext($/) {
        make %(body =&gt; ~$/, from =&gt; $/.from, to =&gt; $/.to); # (#4)
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>问题 3.2 的解决方法：</p>
</li>
<li>
<p>调用 make 时，分别使用 Match.from 和 Match.to 来获取匹配开始位置和匹配结束位置。 （＃1〜＃4）</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_运行解析器_2">12.2.10. 运行解析器</h4>
<div class="paragraph">
<p>该跑了！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ raku parser.p6 &lt; einstein.txt
Scientist
name
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; アルベルト・アインシュタイン, from =&gt; 27, to =&gt; 42}], template =&gt; [], weblink =&gt; []}
image
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; Einstein1921 by F Schmutzer 2.jpg, from =&gt; 51, to =&gt; 85}], template =&gt; [], weblink =&gt; []}
caption
{anchortext =&gt; [{body =&gt; [[1921年]], from =&gt; 97, to =&gt; 106} {body =&gt; [[ウィーン]], from =&gt; 107, to =&gt; 115} {body =&gt; [[講義]], from =&gt; 117, to =&gt; 123}], rawtext =&gt; [{body =&gt; , from =&gt; 96, to =&gt; 97} {body =&gt; での, from =&gt; 115, to =&gt; 117} {body =&gt; 中, from =&gt; 123, to =&gt; 124}], template =&gt; [], weblink =&gt; []}
birth_date
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 138, to =&gt; 139}], template =&gt; [{body =&gt; {{生年月日と年齢|1879|3|14|no}}, from =&gt; 139, to =&gt; 163}], weblink =&gt; []}
birth_place
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 178, to =&gt; 179}], template =&gt; [{body =&gt; {{DEU1871}}, from =&gt; 179, to =&gt; 190}], weblink =&gt; []}
{anchortext =&gt; [{body =&gt; [[ヴュルテンベルク王国]], from =&gt; 194, to =&gt; 208} {body =&gt; [[ウルム]], from =&gt; 208, to =&gt; 215}], rawtext =&gt; [], template =&gt; [], weblink =&gt; []}
death_date
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 229, to =&gt; 230}], template =&gt; [{body =&gt; {{死亡年月日と没年齢|1879|3|14|1955|4|18}}, from =&gt; 230, to =&gt; 263}], weblink =&gt; []}
death_place
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 278, to =&gt; 279}], template =&gt; [{body =&gt; {{USA1912}}, from =&gt; 279, to =&gt; 290}], weblink =&gt; []}
{anchortext =&gt; [{body =&gt; [[ニュージャージー州]], from =&gt; 296, to =&gt; 309} {body =&gt; [[プリンストン (ニュージャージー州)|プリンストン]], from =&gt; 309, to =&gt; 338}], rawtext =&gt; [], template =&gt; [], weblink =&gt; []}
residence
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 351, to =&gt; 352}], template =&gt; [{body =&gt; {{DEU}}, from =&gt; 352, to =&gt; 359}], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [], template =&gt; [{body =&gt; {{ITA}}, from =&gt; 365, to =&gt; 372}], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [], template =&gt; [{body =&gt; {{CHE}}, from =&gt; 376, to =&gt; 383}], weblink =&gt; []}
{anchortext =&gt; [{body =&gt; [[チェコ]], from =&gt; 400, to =&gt; 407}], rawtext =&gt; [{body =&gt; (現在の, from =&gt; 396, to =&gt; 400} {body =&gt; ), from =&gt; 407, to =&gt; 408}], template =&gt; [{body =&gt; {{AUT}}, from =&gt; 389, to =&gt; 396}], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [], template =&gt; [{body =&gt; {{BEL}}, from =&gt; 414, to =&gt; 421}], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [], template =&gt; [{body =&gt; {{USA}}, from =&gt; 427, to =&gt; 434}], weblink =&gt; []}
nationality
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 449, to =&gt; 450} {body =&gt; ヴュルテンベルク王国（1879-96）, from =&gt; 462, to =&gt; 481}], template =&gt; [{body =&gt; {{DEU1871}}, from =&gt; 450, to =&gt; 461}], weblink =&gt; []}
{anchortext =&gt; [{body =&gt; [[無国籍]], from =&gt; 487, to =&gt; 494}], rawtext =&gt; [{body =&gt; （1896-1901）, from =&gt; 494, to =&gt; 505}], template =&gt; [], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; （1901-55）, from =&gt; 518, to =&gt; 527}], template =&gt; [{body =&gt; {{CHE}}, from =&gt; 511, to =&gt; 518}], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; （1911-12）, from =&gt; 544, to =&gt; 553}], template =&gt; [{body =&gt; {{AUT1867}}, from =&gt; 533, to =&gt; 544}], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; （1914-33）, from =&gt; 582, to =&gt; 591}], template =&gt; [{body =&gt; {{DEU1871}}, from =&gt; 559, to =&gt; 570} {body =&gt; {{DEU1919}}, from =&gt; 571, to =&gt; 582}], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; （1940-55）, from =&gt; 608, to =&gt; 617}], template =&gt; [{body =&gt; {{USA1912}}, from =&gt; 597, to =&gt; 608}], weblink =&gt; []}
spouse
{anchortext =&gt; [{body =&gt; [[ミレヴァ・マリッチ]], from =&gt; 634, to =&gt; 647}], rawtext =&gt; [{body =&gt; , from =&gt; 633, to =&gt; 634} {body =&gt; (1903-1919), from =&gt; 653, to =&gt; 664}], template =&gt; [], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [], template =&gt; [{body =&gt; {{nowrap|{{仮リンク|エルザ・アインシュタイン|en|Elsa Einstein|label=エルザ・レーベンタール}}&amp;nbsp;(1919-1936)}}, from =&gt; 670, to =&gt; 754}], weblink =&gt; []}
children
{anchortext =&gt; [{body =&gt; [[リーゼル・アインシュタイン|リーゼル]], from =&gt; 771, to =&gt; 793}], rawtext =&gt; [{body =&gt; , from =&gt; 770, to =&gt; 771} {body =&gt; (1902-1903?), from =&gt; 793, to =&gt; 806}], template =&gt; [], weblink =&gt; []}
{anchortext =&gt; [{body =&gt; [[ハンス・アルベルト・アインシュタイン|ハンス・アルベルト]], from =&gt; 812, to =&gt; 844}], rawtext =&gt; [{body =&gt; (1904-1973), from =&gt; 844, to =&gt; 856}], template =&gt; [], weblink =&gt; []}
{anchortext =&gt; [{body =&gt; [[エドゥアルト・アインシュタイン|エドゥアルト]], from =&gt; 862, to =&gt; 888}], rawtext =&gt; [{body =&gt; (1910-1965), from =&gt; 888, to =&gt; 900}], template =&gt; [], weblink =&gt; []}
field
{anchortext =&gt; [{body =&gt; [[物理学]], from =&gt; 910, to =&gt; 917}], rawtext =&gt; [{body =&gt; , from =&gt; 909, to =&gt; 910}], template =&gt; [], weblink =&gt; []}
{anchortext =&gt; [{body =&gt; [[哲学]], from =&gt; 923, to =&gt; 929}], rawtext =&gt; [], template =&gt; [], weblink =&gt; []}
work_institution
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 949, to =&gt; 950}], template =&gt; [{body =&gt; {{Plainlist|
* [[スイス特許庁]] ([[ベルン]]) (1902-1909)
* {{仮リンク|ベルン大学|en|University of Bern}} (1908-1909)
* [[チューリッヒ大学]] (1909-1911)
* [[プラハ・カレル大学]] (1911-1912)
* [[チューリッヒ工科大学]] (1912-1914)
* [[プロイセン科学アカデミー]] (1914-1933)
* [[フンボルト大学ベルリン]] (1914-1917)
* {{仮リンク|カイザー・ヴィルヘルム協会|en|Kaiser Wilhelm Society|label=カイザー・ヴィルヘルム研究所}} (化学・物理学研究所長, 1917-1933)
* [[ドイツ物理学会]] (会長, 1916-1918)
* [[ライデン大学]] (客員, 1920-)
* [[プリンストン高等研究所]] (1933-1955)
* [[カリフォルニア工科大学]] (客員, 1931-33)
}}, from =&gt; 950, to =&gt; 1409}], weblink =&gt; []}
alma_mater
{anchortext =&gt; [{body =&gt; [[チューリッヒ工科大学]], from =&gt; 1424, to =&gt; 1438}], rawtext =&gt; [{body =&gt; , from =&gt; 1423, to =&gt; 1424}], template =&gt; [], weblink =&gt; []}
{anchortext =&gt; [{body =&gt; [[チューリッヒ大学]], from =&gt; 1444, to =&gt; 1456}], rawtext =&gt; [], template =&gt; [], weblink =&gt; []}
doctoral_advisor
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 1476, to =&gt; 1477}], template =&gt; [{body =&gt; {{仮リンク|アルフレート・ク
ライナー|en|Alfred Kleiner}}, from =&gt; 1477, to =&gt; 1516}], weblink =&gt; []}
academic_advisors
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 1537, to =&gt; 1538}], template =&gt; [{body =&gt; {{仮リンク|ハインリヒ・フリ
ードリヒ・ウェーバー|en|Heinrich Friedrich Weber}}, from =&gt; 1538, to =&gt; 1593}], weblink =&gt; []}
doctoral_students
Nil
known_for
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 1627, to =&gt; 1628}], template =&gt; [{body =&gt; {{Plainlist|
*[[一般相対性理論]]
*[[特殊相対性理論]]
*[[光電効果]]
*[[ブラウン運動]]
*link:E=mc&lt;sup&gt;2&lt;/sup&gt;[[E=mc2|質量とエネルギーの等価性]]
*[[アインシュタイン方程式]]
*[[ボース分布関数]]
*[[宇宙定数]]
*[[ボース＝アインシュタイン凝縮]]
*[[EPRパラドックス]]
*{{仮リンク|古典統一場論|en|Classical unified field theories}}
}}, from =&gt; 1628, to =&gt; 1861}], weblink =&gt; []}
influenced
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 1877, to =&gt; 1878}], template =&gt; [{body =&gt; {{Plainlist|
* {{仮リンク|エルンスト・G・シュトラウス|en|Ernst G. Straus}}
* [[ネイサン・ローゼン]]
* [[レオ・シラード]]
}}, from =&gt; 1878, to =&gt; 1968}], weblink =&gt; []}
prizes
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 1978, to =&gt; 1979}], template =&gt; [{body =&gt; {{Plainlist|
*{{仮リンク|バーナード・メダル|en|Barnard Medal for Meritorious Service to Science}}(1920)
*link:1921[[ノーベル物理学賞]]
*link:1921[[マテウチ・メダル]]
*link:1925[[コプリ・メダル]]
*link:1926[[王立天文学会ゴールドメダル]]
*link:1929[[マックス・プランク・メダル]]
}}, from =&gt; 1979, to =&gt; 2181}], weblink =&gt; []}
religion
Nil
signature
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; Albert Einstein signature 1934.svg, from =&gt; 2206, to =&gt; 2241}], template =&gt; [], weblink =&gt; []}
footnotes
Nil</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_结论_4">12.2.11. 结论</h4>
<div class="paragraph">
<p>我演示了信息框的解析技术。如果您有机会将 Wikipedia 用作 NLP 的资源，我强烈建议您创建自己的解析器。它不仅会加深你对 Raku 的理解而且还会加深关于维基百科知识的理解。</p>
</div>
<div class="paragraph">
<p>再见！</p>
</div>
</div>
<div class="sect3">
<h4 id="_引文">12.2.12. 引文</h4>
<div class="paragraph">
<p>[0] Lehmann，Jens 等人。 “DBpedia—​一种从维基百科中提取的大型多语言知识库。”Semantic Web 6.2（2015）：167-195。</p>
</div>
<div class="paragraph">
<p>[1]阿里，Esraa，Annalina Caputo 和 SéamusLawless。 “使用学习排序的实体属性排名”。</p>
</div>
<div class="paragraph">
<p>[2]莫拉莱斯，阿尔瓦罗等人。 “学会回答维基百科信息框的问题。”2016年自然语言处理实证方法会议论文集。 2016年</p>
</div>
</div>
<div class="sect3">
<h4 id="_license">12.2.13. License</h4>
<div class="paragraph">
<p>所有来自维基百科的资料都是根据Creative Commons Attribution-ShareAlike 3.0 Unported License 授权使用的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Itsuki丰田，日本的网页开发人员。
== <a href="https://rakuadvent.wordpress.com/2017/12/14/day-14-the-little-match-girl-building-and-testing-big-grammars-in-perl-6/">第十四天-在 Raku 中构建和测试 Big Grammars</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Raku Grammars 很棒，但在项目中使用它们会是什么样呢？在圣诞节前和圣诞节后，我的经历是一个令人心酸的故事。你可以在<a href="https://github.com/albastev/Grammar-Modelica/tree/parse_modelica_library">这里</a>找到版本库。我不是来自计算机科学背景，所以也许它看起来很简陋，但是当我学习 Raku Grammars 时，这是我的困难和胜利。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_第一根火柴">12.3. 第一根火柴</h3>
<div class="paragraph">
<p>就像卖火柴的小女孩一样，我们的故事发生在圣诞节前。卖火柴的小女孩的任务是在圣诞节前夕销售一捆火柴棍（实际上是新年，我确实回去读了那个故事。圣诞节更适合 Raku），而我的任务是从 Modelica 模型中提取注释渲染为矢量图形。现在，Modelica 是一个非常棒的面向对象的建模语言，除了提及其附录中包含一个具体语法部分的非常好的<a href="https://www.modelica.org/documents/ModelicaSpec34.pdf">规范文档</a>（pdf）之外，我将完全理解它。仔细阅读本节，我意识到“语法元符号”和“词法单位”看起来像我最近读过的一篇博客文章中的 Raku Grammars，并且急于尝试。</p>
</div>
<div class="paragraph">
<p>来自 Modelica 的示例具体语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">class-definition :
[ encapsulated ] class-prefixes
class-specifier</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku <strong>rule</strong> 的示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule class_definition {
  [&lt;|w&gt;&#39;encapsulated&#39;&lt;|w&gt;]?
  &lt;class_prefixes&gt;
  &lt;class_specifier&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就像卖火柴的小女孩划第一颗火柴一样，第一次看到了一个超越她现实的奇妙世界。一个温暖的小炉子。然后它熄灭了。</p>
</div>
<div class="paragraph">
<p>它非常接近，我把它放到了一个文本编辑器中，并且用一些 Raku 的东西替换了不是 Raku 的部分，以查看它是否会运行。它没有运行。我砍掉了它，我指出了不同的位来解决更小的块。无处不在的空白符号，正则表达式，标记，规则。我能够解析某些部分，其他部分神秘地没有起效。回顾过去，这一定很糟糕。与此同时，我们一起破解传统的正则表达式来提取注释，并将我的 Grammar 放在架子上。</p>
</div>
</div>
<div class="sect2">
<h3 id="_第二根火柴">12.4. 第二根火柴</h3>
<div class="paragraph">
<p>不久之后，发布了 Grammar::Profiler 和 Grammar::Debugger，并且我受到启发，决定再试一试。我被授予了对我的规则出乎意料表现的很好的见解。我能够比以前更深入地理解 grammar。第二支火柴一直亮着，我有一场盛宴。然后它熄灭了。</p>
</div>
<div class="paragraph">
<p>在调试器中，我陷入了回溯的深渊。分析器一直运行，因为它一次又一次地陷入泥潭。我能够走得更远，但最终遇到了一堵墙。成功似乎非常接近，但我自己的经历中有太多缺失的部分，并且有文档让我度过难关。</p>
</div>
</div>
<div class="sect2">
<h3 id="_第三根火柴">12.5. 第三根火柴</h3>
<div class="paragraph">
<p>时间流逝，圣诞节来了。我有了新的职位，有时间做个人项目。我有不断改进的 <a href="https://docs.raku.org/language/grammars">Grammar 文档</a>来指导我。我已经阅读了使用遗留代码高效工作的书。这足以让我再次迎难而上。</p>
</div>
</div>
<div class="sect2">
<h3 id="_面向对象">12.6. 面向对象</h3>
<div class="paragraph">
<p>这对我来说是最大的突破。当我从文档中了解到 Tokens，rules 和  regex 都是有趣的外观方法时，我突然发现了所有的东西。当我回到家时，我立即检查我是否可以重写 TOP，并检查是否可以将 Grammar 方法变为 role。两人都很愉快地工作，而且我在做生意。我可以把它分成块，而不是一个单一的，全有或全无的 grammar。这极大地改进了代码的组织和可测试性。</p>
</div>
<div class="paragraph">
<p>其中一个特别突出的问题是，我能够将 Grammar 整齐地分解成与 Modelica 规范中相应的角色。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">lib
----Grammar
--------Modelica
------------LexicalConventions.pm6
------------ClassDefinition.pm6
------------Extends.pm6
------------ComponentClause.pm6
------------Modification.pm6
------------Equations.pm6
------------Expressions.pm6
--------Modelica.pm6</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Unit testing: one layer at a time</strong></p>
</div>
<div class="paragraph">
<p>面向对象开辟了一个明智的单元测试方案，并通过将Modelica的部分内容传递到语法中，使我摆脱了临时测试的无稽之谈。您可以像继承其他任何类一样继承和重写语法。这允许您分别测试每个规则或标记，将您的语法分割为一口大小的层。您只需使用要测试的规则或标记覆盖TOP，并使用占位符方法覆盖任何依赖关系。</p>
</div>
<div class="paragraph">
<p>Expressions.pm6中表达式的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
  [
  &lt;|w&gt;&#39;if&#39;&lt;|w&gt; &lt;expression&gt; &lt;|w&gt;&#39;then&#39;&lt;|w&gt; &lt;expression&gt; [
  &lt;|w&gt;&#39;elseif&#39;&lt;|w&gt; &lt;expression&gt; &lt;|w&gt;&#39;then&#39;&lt;|w&gt; &lt;expression&gt;
  ]*
  &lt;|w&gt;&#39;else&#39;&lt;|w&gt; &lt;expression&gt;
  ]
  ||
  &lt;simple_expression&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里我们看到表达式取决于它自己和simple_expression。为了测试，我们用一个占位符替换了通常的simple_expression规则。在这种情况下，它只是匹配字符串’simple_expression&#39;。</p>
</div>
<div class="paragraph">
<p>从Expressions.t覆盖测试语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar TestExpression is Grammar::Modelica {
    rule TOP {^ &lt;expression&gt; $}
    rule simple_expression { &#39;simple_expression&#39; }
}
ok TestExpression.parse(&#39;simple_expression&#39;);
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你可以分离代码中有问题的部分时，回归测试也会更加愉快，并创建一个专门针对它的重写语法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_w_is_your_friend">12.7. &lt;|w&gt; is your friend</h3>
<div class="paragraph">
<p>在我的第一次努力中，试图让Modelica保留字等正常工作的东西是我“存在的一些障碍”之一。在找到单词边界匹配标记&lt;| w&gt;后，这个改变了。当我在每边击打一个时，它可以工作，无论是在空白区还是标点符号旁边。</p>
</div>
<div class="paragraph">
<p>从ComponentClause.pm6：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule type_prefix {
  [&lt;|w&gt;[ &#39;flow&#39; || &#39;stream&#39; ]&lt;|w&gt;]?
  [&lt;|w&gt;[ &#39;discrete&#39; || &#39;parameter&#39; || &#39;constant&#39; ]&lt;|w&gt;]?
  [&lt;|w&gt;[ &#39;input&#39; || &#39;output&#39; ]&lt;|w&gt;]?
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_token_rule_and_regex">12.7.1. Token, rule and regex</h4>
<div class="paragraph">
<p>现在有很好的文档，但是我也会简要介绍一下我的经验。我发现规则和它的：sigspace魔术是大多数时候最好的选择。令牌在需要严格控制格式的情况下很有用。</p>
</div>
<div class="paragraph">
<p>正则表达式用于回溯。对于Modelica，我发现它是无益的，可能是因为它被设计成单通口语。令牌和规则在我认为我需要的地方工作。所有的单元测试都在我将它们删除后通过，并且语法成功了四个Modelica标准库文件。只有在需要时才使用它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_以开始结束">12.7.2. 以开始结束</h4>
<div class="paragraph">
<p>另一个让我感到沮丧的是类定义语法。 Modelica使用形式some_identifier …​结束some_identifier的类。如何确保在开始和结束时使用相同的标识符对我来说很麻烦。幸运的是，Raku允许您在语法方法中使用捕获。下面的（&lt;IDENT&gt;）捕获将填充$ 0，然后可以用它来确保我们的long_class_specifier以适当的标识符结束。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule long_class_specifier {
  [(&lt;IDENT&gt;) &lt;string_comment&gt; &lt;composition&gt; &lt;|w&gt;&#39;end&#39;&lt;|w&gt; $0 ]
  ||
  [&lt;|w&gt;&#39;extends&#39;&lt;|w&gt; (&lt;IDENT&gt;) &lt;class_modification&gt;? &lt;string_comment&gt; &lt;composition&gt; &lt;|w&gt;&#39;end&#39;&lt;|w&gt; $0 ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Integration Testing: lighting all the matches at once</strong></p>
</div>
<div class="paragraph">
<p>在我的单元测试全部过去后，我感到有点不安。当然，它可以解析我设计的测试案例，但它对真正的Modelica会如何呢？颤抖的手，我从他的Modelica电子书中提供了一些Michael Tiller的示例代码。有效！没有摆弄我忽略的微妙东西，没有有趣的解析错误或永恒的回溯。只是成功。</p>
</div>
<div class="paragraph">
<p>现在，星星偶尔会对齐。奇迹确实发生。充分巧妙的单元测试可以非常好地预防错误。我已经有足够的时间来验证了。回顾Damian Conway的演讲，我决定针对整个Modelica标准库运行它。并不是所有的CPAN，但305个文件都比我迄今尝试过的仅仅两个示例模型要好。</p>
</div>
<div class="paragraph">
<p>我编写了脚本，将它指向了Modelica目录，并将它解雇了。它通过图书馆搅动，喘息一下。 150次失败。现在这是熟悉的领域。经过几次迭代后，当我在parse_modelica_library分支上运行它时，我的性能下降到了66次。我只是通过一个失败的文件，找出有问题的代码，并为其编写回归测试。</p>
</div>
<div class="paragraph">
<p>所以，最后小火柴女郎点燃了她捆绑的其余部分。然后，她死了。不要死，但可以同时点亮所有305场比赛，例如/ parseThemAll.p6：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!raku

use v6;
use Test;
use lib &#39;../lib&#39;;
use Grammar::Modelica;


plan 305;

sub light($file) {
  my $fh = open $file, :r;
  my $contents = $fh.slurp-rest;
  $fh.close;

  my $match = Grammar::Modelica.parse($contents);
  say $file;
  ok $match;
}

sub MAIN($modelica-dir) {
    say &#34;directory: $modelica-dir&#34;;
    die &#34;Can&#39;t find directory&#34; if ! $modelica-dir.IO.d;

    # modified from the lovely docs at
    # https://docs.raku.org/routine/dir
    my @stack = $modelica-dir.IO;
    my @files;
    while @stack {
      for @stack.pop.dir -&gt; $path {
        light($path) if $path.f &amp;&amp; $path.extension.lc eq &#39;mo&#39;;
        @stack.push: $path if $path.d;
      }
    }
    # faster to do in parallel
    @files.race.map({light($_)});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我会看到在圣诞节前我能说服多少。那么也许我会弄清楚如何编写一些规则来构建QAST。</p>
</div>
<div class="paragraph">
<p>圣诞节快乐！</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十五天_带有_promise_的简单网络爬虫">13. <a href="https://rakuadvent.wordpress.com/2017/12/15/a-simple-web-spider-with-promises/">第十五天-带有 Promise 的简单网络爬虫</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>承诺，承诺
去年夏天，我申请了一项编程工作，面试官要求我编写一个程序来抓取给定的域，只在该域中的链接之后，找到它引用的所有页面。我被允许以任何语言编写程序，但我选择使用Go语言执行任务，因为这是该公司使用的主要语言。这对于并发编程来说是一个理想的任务，并且Go具有非常好的现代化功能，即使有些低级别的并发支持。网络蜘蛛中的主要工作是执行与在域中发现的唯一锚链接相同的次数，即在每个页面上执行HTTP GET并解析页面文本以获取新链接。这个任务可以并行安全地完成，因为没有可能（除非你做得很糟糕），任何调用爬取代码都会干扰其他任何调用。</p>
</div>
<div class="paragraph">
<p>Go和Raku的创造者受到安东尼霍尔爵士1978年的开创性工作“沟通顺序过程”的启发，但值得注意的是，Raku代码更加简洁，因此更容易隐藏到博客文章中。事实上，Go设计者总是将他们的结构称为“并发原语”。 Go为我的作业应用程序编写的并发spider代码大约有200行，而在Raku中大小不到这个大小的一半。</p>
</div>
<div class="paragraph">
<p>下面我们来看看如何在Raku中实现一个简单的Web爬虫。内置的Promise类允许您启动，调度和检查异步计算的结果。所有你需要做的就是给Promise.start方法一个代码引用，然后调用await方法，这会阻塞，直到promise完成执行。然后您可以测试结果方法以确定承诺是否已被保留或中断。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">您可以通过将其保存到本地文件中来运行本文中的代码，例如网络spider.p6。如果您希望抓取https网站，请使用zef安装HTML </dt>
<dd>
<p>Parser :: XML和HTTP :: UserAgent以及IO :: Socket :: SSL。我会提醒你，SSL支持目前看起来有点狼狈，所以最好坚持http站点。 Raku程序中的MAIN子程序存在时表示一个独立程序，这就是执行开始的地方。 MAIN的参数表示命令行参数。我编写了这个程序，以便默认情况下它会抓取Perlmonks站点，但是您可以覆盖它，如下所示：</p>
<div class="literalblock">
<div class="content">
<pre>$ raku web-spider.p6 [–domain=http://example.com]</pre>
</div>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>简单的Raku域蜘蛛</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use HTML::Parser::XML;
use XML::Document;
use HTTP::UserAgent;

sub MAIN(:$domain=&#34;http://www.perlmonks.org&#34;) {

    my $ua =  HTTP::UserAgent.new;
    my %url_seen;
    my @urls=($domain);

    loop {
        my @promises;
        while ( @urls ) {
            my $url = @urls.shift;
            my $p = Promise.start({crawl($ua, $domain, $url)});
            @promises.push($p);
        }
        await Promise.allof(@promises);
        for @promises.kv -&gt; $index, $p {
            if $p.status ~~ Kept {
                my @results =  $p.result;
                for @results {
                    unless %url_seen{$_} {
                        @urls.push($_);
                        %url_seen{$_}++;
                    }
                }
            }
        }
        # Terminate if no more URLs to crawl
        if @urls.elems == 0 {
            last;
        }
    }
    say %url_seen.keys;
}

# Get page and identify urls linked to in it. Return urls.
sub crawl($ua, $domain, $url) {
    my $page = $ua.get($url);
    my $p = HTML::Parser::XML.new;
    my XML::Document $doc = $p.parse($page.content);
    # URLs to crawl
    my %todo;
    my @anchors = $doc.elements(:TAG&lt;a&gt;, :RECURSE);
    for @anchors -&gt; $anchor {
        next unless $anchor.defined;
        my $href =  $anchor.attribs&lt;href&gt;;

        # Convert relative to absolute urls
        if $href.starts-with(&#39;/&#39;) or $href.starts-with(&#39;?&#39;) {
            $href = $domain ~ $href;
        }

        # Get unique urls from page
        if $href.starts-with($domain) {
              %todo{$href}++;
        }
    }
    my @urls = %todo.keys;

    return @urls;
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_结论是">13.1. 结论是</h3>
<div class="paragraph">
<p>并发编程总是会有很多陷阱，从竞争状态到资源匮乏和死锁，但我认为很显然，Raku 已经使得这种编程形式更容易被大家接受。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十六天_raku_性能改进">14. <a href="https://rakuadvent.wordpress.com/2017/12/16/day-16-%F0%9F%8E%B6-deck-the-halls-with-perf-improvements-%F0%9F%8E%B6/">第十六天-Raku 性能改进</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>在英国，我们缺乏感恩节给圣诞节带来了新的一年，感谢和反思。为此，我想围绕Raku性能的状态放置一些我已经坐了一段时间的零碎片断，这些片断强调了这个过程需要付出多少努力。我不确定更广泛的编程社区对正在发生的努力的速度和数量表示赞赏。</p>
</div>
<div class="paragraph">
<p>我不是核心开发人员，但自2010年推出Rakudo *之后，我一直是Raku的低级用户。通常情况下，已经进入Rakudo的努力被未知的努力所掩盖。人们重新审视Rakudo Raku时尤其如此，他可能会想象下一个圣诞节将会如何。但是Raku在历史上证明，在下一个圣诞节之前，事情总会有所改善，无论您选择哪个圣诞节，</p>
</div>
<div class="paragraph">
<p>回到2014年的圣诞节，我写了一篇关于为什么我认为Raku能够完成生物信息学工作的出色文章。那篇文章中没有提到的是，为什么在Rakudo上实现Raku根本没有准备好去做任何严肃的生物信息学。表演真的没有！我在Raku中的第一次尝试（当Parrot虚拟机完全使用时）让我执行了几十分钟的简单操作，我期望它是毫秒级的性能。这很遗憾，因为我没有跟踪时间。但这当然不是一个好起点。</p>
</div>
<div class="paragraph">
<p>然而，快速转发到2014年和MoarVM，我觉得自己写这篇来临邮件感觉很舒服，因为我知道在作为用户的4年中有多少改进。而且，所有的发展都是在完成语言定义和正确的实施。然而，我是一直在等待perf到达那里的用户。我认为大部分时间到了。为此，我要感谢所有核心开发者所付出的巨大的日常努力。观看它展现出令人难以置信的动力。对我来说，这个圣诞节是圣诞节的目标，它已经到来。 👏🏻🎊</p>
</div>
<div class="paragraph">
<p>我一直在为我的BioInfo模块运行和计时测试，这些模块对生物序列数据进行了多年的基本操作。它以非常糟糕的方式做到了这一点。在紧密循环中分配和丢弃哈希时出现了很多错误等等。但是我已经将这些代码留给了现在 - 在五年多的时间里。悄悄地进行私人基准测试，偶尔鼓励在IRC频道看到大幅飞跃的努力。 Sub 10s是一个很大的！它从30/40秒突然发生。在我暗示IRC一个地方，我的代码在分析时特别慢，这是一次跳跃！</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2017/12/bioinfo_runtime.png">img</a></p>
</div>
<div class="paragraph">
<p>这是一个长期观点，如果我放大去年的这一年，可以看到，如果时间不是很长，整个系数的性能仍然在提高。</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2017/12/bioinfo_runtime_2017.png">img</a></p>
</div>
<div class="paragraph">
<p>请记住，所有这些配置文件都不是来自Rakudo编译器的发布版本，而是来自当天的HEAD。所以偶尔会有一些奇怪的表现回归，正如你上面看到的，通常不会留下来发布。</p>
</div>
<div class="paragraph">
<p>发生什么了？情况如何变好？有几个原因。 Raku中的许多算法选择和核心功能都已经在源代码级别（更晚些时候）逐步和积极地进行了优化。但支持Rakudo的MoarVM虚拟机的优化能力也得到了提高，并且可以降低到原生代码和内联专用版本的代码。这部分得益于2014年以来Rakudo Raku提供的-profile选项，它提供了所有这些信息。</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2017/12/bioinfo_frame_optimisations.png">img</a></p>
</div>
<div class="paragraph">
<p>在上面关于MoarVM如何处理我编译过的Raku测试的代码框的情节中，应该很清楚的是，自从今年夏天以来，有相当多的框架被JIT编译，解释较少，并且几乎所有专用框架（橙色）结束原生JIT（绿色）。如果您想了解更多有关“spesh”MoarVM代码专门工具的最新工作，您可以在他的博客上阅读Jonathan Worthington的4篇文章。 Baart Weigmans还有一篇博客概述了他在JIT编译器方面的工作，最近还谈到了许多尚未登陆的新功能，希望能让许多新开发人员加入并帮助改进JIT。所以如果这对你来说是一件有趣的事情，我建议你查看一下上面的链接。</p>
</div>
<div class="paragraph">
<p>所以这是我的基准和我的目标，其中大部分是围绕数据结构创建和解析。但是，数字作品等其他内容呢？那也保持了吗？没有任何人推动，就像我推动我对事情可以改进的地方的看法。答案是肯定的！</p>
</div>
<div class="paragraph">
<p>曾几何时，早在2013年，一位名叫Tim King的绅士就开始对Raku中的素数感兴趣.Tim对他发现的性能颇为不满。正确如此。他从以下漂亮的代码开始：</p>
</div>
<div class="paragraph">
<p>通过定义一个素数的交叉点找到任何素数，真是一个不错的优雅解决方案！但是蒂姆惊讶地发现联赛很慢，上面的代码让他看到了前1000个素数。今天，超级高级代码需要0.96s。</p>
</div>
<div class="paragraph">
<p>对于基于联结的代码的缓慢程度，蒂姆继续做更标准的迭代方法感到不满。 Tim在这些帖子后不久就从网上消失。但他留下了我继续留下的遗产。他的主要基准测试代码和我对时间结果的适应性可以在这个要点中找到。以下是另一张图表，其中显示了每个超过100次试验找到前1000个素数所需的平均时间。 2015年的垂直线是较高的标准偏差。</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2017/12/timking_primes.png">img</a></p>
</div>
<div class="paragraph">
<p>再次以最近的放大视图（最新的数据点让我担心一点，我以某种方式搞砸了…​…​）</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2017/12/timking_primes_2017_improvement.png">img</a></p>
</div>
<div class="paragraph">
<p>上面的收敛到一个点，是启动和停止Rakudo运行时和MoarVM的开销。发现素数并不是它曾经的努力，它比Rakudo的开始稍微慢一些。无论您选择的代码解决方案的级别和优雅程度如何，至少要快一个数量级。</p>
</div>
<div class="paragraph">
<p>好吧，我们已经看到MoarVM获得了一些闪亮的新运动部件。但是像Liz，jnthn，Zoffix以及最近在字符串Samcv世界中开发人员已经付出了巨大的努力，以改进MoarVM和Rakudo在算法上实际上正在做的事情。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>旁注：我相信我根本不会做大多数其他开发人员的正义，特别是在这篇文章中忽略了JVM的努力。我建议每个人都去，并检查提交日志，看看有多少人现在参与使Rakudo更快，更好，更强大。我确定他们想在本文的底部看到您的感谢！</pre>
</div>
</div>
<div class="paragraph">
<p>因此，节省你一份查看提交日志的工作我已经做了一些挖掘，看看自上个圣诞节以来与提高性能有关的提交。 N％或Nx更快的东西。如下所示：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>3c6277c77 Have .codes use nqp::codes op. 350% faster for short strings</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>ee4593601 Make Baggy (^) Baggy about 150x faster</pre>
</div>
</div>
<div class="paragraph">
<p>这两项承诺将以一年的核心发展时间表推动编程项目的发展。但是，今年，它们仅仅是数百次提交中的两次。</p>
</div>
<div class="paragraph">
<p>下面是一些提交数量的直方图以及他们提到的性能的百分比和x乘数的增加。你可以用上面的代码自己grep日志。在2016年有一些更令人兴奋的收益值得检查。</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2017/12/percent_improvements_since_xmas2016.png">img</a></p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2017/12/x_improvements_since_xmas2016.png">img</a></p>
</div>
<div class="paragraph">
<p>这仅仅是2017年的性能提升承诺，几乎每天都会有更多的降落。这甚至不包括许多来自Zoffix授予的I / O性能收益，因为它们在之前/之后并不总是基准。 2016年同样密集，一些疯狂的&gt; 1000倍的改进。今年只有十个左右提交，提高40倍！看到这真是令人印象深刻。至少对我来说。我认为这对项目的许多人来说并不明显，他们正在完成多少。记住这些是单数提交。有些甚至在一年中复合改进！</p>
</div>
<div class="paragraph">
<p>我会把它留在这里。但是真的很感谢核心开发者，你们所有人。这是一个很棒的观看和等待体验。但现在是时候在2018年继续使用一些Raku代码了！终于圣诞节了。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十七天_关于消息传递">15. <a href="https://rakuadvent.wordpress.com/2017/12/17/something-about-messaging-but-i-couldnt-think-of-a-snappier-title/">第十七天-关于消息传递</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_为什么要传递消息">15.1. 为什么要传递消息</h3>
<div class="paragraph">
<p>当我第一次开始考虑写今年的 Advent 文章时，我反思我在过去的十二个月里并没有真正写过大量的 Raku，与往年相比，我似乎写了大量的模块。我一直在做的事情（至少在我的日常工作中）正在考虑和实施大量使用某些消息传递系统的应用程序。所以我认为将这些想法引入 Raku 会很有趣。</p>
</div>
<div class="paragraph">
<p>作为一种“胶水语言”，Perl一直享有盛誉，Raku 具有与之竞争的功能，最显着的是响应式和并发功能，因此非常适合创建基于消息的集成服务。</p>
</div>
</div>
<div class="sect2">
<h3 id="_传递什么信息">15.2. 传递什么信息</h3>
<div class="paragraph">
<p>现在我的脚下就是优秀的<a href="http://www.enterpriseintegrationpatterns.com/">企业集成模式</a>，尽管它现在已经有近15年的历史了，但我仍然建议任何有兴趣（或工作于）该领域的人。然而，它是一个重量级的书（字面上，它在硬书中的重量接近一点五公斤），所以我用它来提醒自己不要试图在这个主题上详尽无遗，以免这会变成一本书本身。</p>
</div>
<div class="paragraph">
<p>有相当多的自由和商业管理消息系统，使用一系列开放和专有的协议，但我将限制自己到我熟悉的 <a href="https://www.rabbitmq.com/">RabbitMQ</a>，并且在 Raku 中由 <a href="https://github.com/retupmoca/P6-Net-AMQP">Net::AMQP</a> 支持。</p>
</div>
<div class="paragraph">
<p>如果你想亲自尝试一下这些例子，你将需要访问一个 RabbitMQ 代理（它可以作为大多数操作系统发行版的包），但是你可以使用 <a href="https://hub.docker.com/_/rabbitmq/">Docker Image</a>，它看起来工作得很好。</p>
</div>
<div class="paragraph">
<p>您还需要安装 Net::AMQP，这可以通过以下方式完成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install Net::AMQP</code></pre>
</div>
</div>
<div class="paragraph">
<p>在示例中，我将使用 RabbitMQ 服务器的默认连接详细信息（即代理正在本地主机上运行，​​并且默认 <code>guest</code> 处于活动状态），如果您需要提供不同的详细信息，则可以更改 Net::AMQP 的构造函数以反映适当的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = Net::AMQP.new(
  host =&gt; &#39;localhost&#39;,
  port =&gt; 5672,
  login =&gt; &#39;guest&#39;,
  password =&gt; &#39;guest&#39;,
  vhost =&gt; &#39;/&#39;
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>一些示例可能需要其他模块，但我会在介绍时介绍它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="_强制性的你好世界">15.3. 强制性的你好，世界</h3>
<div class="paragraph">
<p>RabbitMQ实现了由AMQP v0.9规范描述的丰富的代理体系结构，由ActiveMQ实现的最新的v1.0规范取消了大部分规定的代理语义，以至于它基本上是一种不同的协议，它共享一个类似的电线格式。</p>
</div>
<div class="paragraph">
<p>发送消息（生产者）的最简单可能的例子可能是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Net::AMQP;

my $n = Net::AMQP.new;

await $n.connect;
my $channel = $n.open-channel(1).result;
my $exchange = $channel.exchange.result;
$exchange.publish(routing-key =&gt; &#34;hello&#34;, body =&gt; &#34;Hello, World&#34;.encode);
await $n.close(&#34;&#34;, &#34;&#34;);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">这演示了RabbitMQ和Net </dt>
<dd>
<p>AMQP的大部分核心功能。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>首先你会注意到许多方法返回一个Promise，它将大部分保留在实际的返回值中，这反映了代理的异步性质，它发送（大多数情况但不是全部）确认消息（AMQP说法中的方法，）当操作在服务器上完成时。</p>
</div>
<div class="paragraph">
<p>这里的连接建立到代理的网络连接并且协商某些参数，如果网络连接失败，提供的凭证不正确或者服务器拒绝某个其他连接，则返回一个Promise，如果成功或失败，它将保留一个真值原因。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">开放通道打开一个逻辑代理通信通道，在这个通道中交换消息，您可以在应用程序中使用多个通道。当服务器确认后，返回的Promise将保留在初始化的Net </dt>
<dd>
<p>AMQP :: Channel对象中。</p>
</dd>
<dt class="hdlist1">通道对象上的交换方法返回一个Net </dt>
<dd>
<p>AMQP :: Exchange对象，在AMQP模型中，所有消息都发布到交换机上，根据交换机的定义，代理可以将消息路由到一个或多个队列由此消息可能被另一客户消耗。在这个简单的例子中，我们将使用默认交换（名为amq.default。）</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>发布方法是在交换对象上调用的，它没有返回值，因为它只是简单的触发和遗忘，代理不会确认收到和交付，否则队列与发布消息的行为是分离的。顾名思义，路由密钥参数是由代理用来确定将消息路由到哪个队列（或多个队列）。在这个例子中使用默认交换的情况下，交换的类型是直接的，这基本上意味着消息传递到具有与路由密钥匹配的名称的队列中的一个消费者。正文总是一个Buf，并且可以是任意长度，在这种情况下，我们使用的是编码字符串，但它可以同样编码为JSON，MessagePack或BSON blob，无论适合消费应用程序。事实上可以提供内容类型和内容编码参数，如果应用程序的设计需要它，消息将传递给消费者，但代理本身完全不知道有效内容的内容。还有其他可选参数，但在这个例子中不需要。</p>
</div>
<div class="paragraph">
<p>当然，我们也需要阅读我们发布的消息（消费者）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Net::AMQP;

my $n = Net::AMQP.new;

my $connection = $n.connect.result;

react {
    whenever $n.open-channel(1) -&gt; $channel {
        whenever $channel.declare-queue(&#34;hello&#34;) -&gt; $queue {
            $queue.consume;
            whenever $queue.message-supply.map( -&gt; $v { $v.body.decode }) -&gt; $message {
                say $message;
                $n.close(&#34;&#34;, &#34;&#34;);
                done();
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们使用的是一个命名队列，而不是像我们在制作人那样在交易所进行操作;如果队列尚不存在，declare-queue将导致队列被创建，并且代理默认将该队列绑定到默认交换，“绑定”实质上意味着发送到交换的消息可以被路由到队列取决于交换类型，消息的路由键以及可能来自消息的其他元数据。在这种情况下，默认交换的“直接”类型将导致消息被路由到与路由密钥相匹配的队列（如果存在的话，如果消息不存在，消息将被无声地丢弃）。</p>
</div>
<div class="paragraph">
<p>当您准备好开始接收消息时调用消费方法，它将返回一个Promise，该Promise将与“消费者标签”一起保存，该标签将消费者唯一标识给服务器，但由于我们不需要它，因此我们可以忽略它。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">一旦我们调用了消费（并且代理发送了确认），那么路由到我们队列的消息将作为Net </dt>
<dd>
<p>AMQP :: Queue :: Message对象发送到由消息供应返回的Supply，但是因为我们对这个例子中的消息元数据不感兴趣映射被用来创建具有消息的解码体的新的Supply;这是安全的，因为在这种情况下，您可以保证您将接收utf-8编码，但是在真实世界的应用程序中，如果您不控制发送者，您可能希望在处理身体方面更强壮一些（当与第三方应用程序集成时通常是这种情况）。发布消息时提供的内容类型和内容编码在Message对象的headers属性（一个Hash）中可用，但它们不是必需的因此您可能需要考虑适合您的应用的替代方案。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在这个例子中，连接被关闭，并且在接收到第一条消息之后退出响应，但实际上您可能需要删除这些行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$n.close(&#34;&#34;, &#34;&#34;);
done();</code></pre>
</div>
</div>
<div class="paragraph">
<p>从内到外，如果你想退出一个信号例如添加：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">whenever signal(SIGINT) {
    $n.close(&#34;&#34;, &#34;&#34;);
    done();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在反应区的最高层。但是，如果您选择退出程序，则应始终在连接对象上调用close，因为这会在代理日志中引发警告消息，如果不这样做，可能会使管理服务器的人感到不安。</p>
</div>
<div class="paragraph">
<p>我们当然可以用类似的方式在生产者示例中使用反应语法，但是它会增加冗长的好处，但是在一个更大的程序中，例如，您可能正在处理一个Supply，它可以很好地工作很好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Net::AMQP;

my $supply = Supply.from-list(&#34;Hello, World&#34;, &#34;Bonjour le monde&#34;, &#34;Hola Mundo&#34;);
my $n = Net::AMQP.new;

react {
    whenever $n.connect {
        whenever $n.open-channel(1) -&gt; $channel {
            whenever $channel.exchange -&gt; $exchange {
                whenever $supply.map(-&gt; $v { $v.encode }) -&gt; $body {
                    $exchange.publish(routing-key =&gt; &#34;hello&#34;, :$body );
                    LAST {
                        $n.close(&#34;&#34;, &#34;&#34;);
                        done();
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_一些更有用的东西">15.4. 一些更有用的东西</h3>
<div class="paragraph">
<p>你可能会认为“这一切都很好，但这不是我不能做的事情，比如说，一个HTTP客户端和一个小型Web服务器”，好吧，你得到可靠的排队，未读消息的持久性等等，但是，对于简单的应用程序来说，它可能会被过度杀死，直到您添加了将消息发送给多个可能未知的消费者的需求为止。这种模式是使用“扇出”交换类型，它将向绑定到交换的所有队列传递消息。</p>
</div>
<div class="paragraph">
<p>在这个例子中，我们需要声明自己的队列，以便我们可以指定类型，但是生产者不会变得更加复杂：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Net::AMQP;

my $n = Net::AMQP.new;
my $con =  await $n.connect;
my $channel = $n.open-channel(1).result;
my $exchange = $channel.declare-exchange(&#39;logs&#39;, &#39;fanout&#39;).result;
$exchange.publish(body =&gt; &#39;Hello, World&#39;.encode);
await $n.close(&#34;&#34;, &#34;&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里唯一的区别是我们使用声明交换而不是在通道上交换来获得我们发送消息的交换，这样做的好处是使交换在指定类型的代理上创建已经存在，这在这里很有用，因为我们不需要依赖事先创建的交换（使用命令行工具rabbitmqctl或通过web管理界面），但它同样返回一个Promise，它将与Exchange交换目的。您可能还注意到，这里的路由密钥没有被传递给发布方法，这是因为对于扇出交换，路由密钥被忽略，并且消息被传递到绑定到交换机的所有消耗队列。</p>
</div>
<div class="paragraph">
<p>消费者代码与我们的原始消费者同样不存在差异：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Net::AMQP;

my $n = Net::AMQP.new;

my $connection = $n.connect.result;

react {
    whenever $n.open-channel(1) -&gt; $channel {
        whenever $channel.declare-exchange(&#39;logs&#39;, &#39;fanout&#39;) -&gt; $exchange {
            whenever $channel.declare-queue() -&gt; $queue {
                whenever $queue.bind(&#39;logs&#39;) {
                    $queue.consume;
                    whenever $queue.message-supply.map( -&gt; $v { $v.body.decode }) -&gt; $message {
                        say $*PID ~ &#34; : &#34; ~ $message;
                    }
                }
                whenever signal(SIGINT) {
                    say $*PID ~ &#34; exiting&#34;;
                    $n.close(&#34;&#34;, &#34;&#34;);
                    done();
                }

            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>交换的声明与生产者示例中声明的方式相同，这非常方便，因此您不必担心启动程序的顺序，第一次运行将创建队列，但是如果您在消费者启动之前运行生产者，发送的消息将被丢弃，因为默认情况下没有路由它们。这里我们还声明了一个没有提供名称的队列，这会创建一个“匿名”队列（该名称由代理组成），因为队列的名称在此路由消息中不起作用案件。</p>
</div>
<div class="paragraph">
<p>您可以提供一个队列名称，但如果名称重复，那么这些消息将以“先到先得”的方式路由到具有相同名称的队列，这可能不是预期的行为（尽管可能并可能有用。）</p>
</div>
<div class="paragraph">
<p>同样在这种情况下，队列必须明确地绑定到我们已经声明的交易所，在第一个例子中，默认交易所的绑定是由代理自动执行的，但在大多数情况下，您将不得不在队列上使用绑定交易所的名称。与许多方法一样，绑定返回一个Promise，当代理确认操作已完成时将保留Promise（尽管在这种情况下，值不重要）。</p>
</div>
<div class="paragraph">
<p>您应该能够根据需要启动尽可能多的消费者，并且他们都将按照发送的顺序接收所有消息。当然，在真实世界的应用程序中，消费者可能是用各种不同语言编写的完全不同的程序。</p>
</div>
</div>
<div class="sect2">
<h3 id="_保持主题">15.5. 保持主题</h3>
<div class="paragraph">
<p>一种常见模式是一组消费者，他们只对发布到特定交易所的某些消息感兴趣，其典型例子可能是记录系统，其中有专门针对不同日志级别的消费者。 AMQP提供了一种话题交换类型，允许通过生产者提供的路由密钥上的模式匹配将消息路由到特定的队列。</p>
</div>
<div class="paragraph">
<p>最简单的生产者可能是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Net::AMQP;

multi sub MAIN(Str $message = &#39;Hello, World&#39;, Str $level = &#39;application.info&#39;) {
	my $n = Net::AMQP.new;
	my $con =  await $n.connect;
	my $channel = $n.open-channel(1).result;
	my $exchange = $channel.declare-exchange(&#39;topic-logs&#39;, &#39;topic&#39;).result;
	$exchange.publish(routing-key =&gt; $level, body =&gt; $message.encode);
	await $n.close(&#34;&#34;, &#34;&#34;);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这应该从前面的例子中相当清楚，除了在这种情况下，我们将交换声明为主题类型，并且还提供将由代理用于匹配消费队列的路由密钥。</p>
</div>
<div class="paragraph">
<p>消费者代码本身又与前面的例子非常相似，只不过它会在命令行上列出一些用于匹配发送到交换机的路由密钥的模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Net::AMQP;

multi sub MAIN(*@topics ) {
    my $n = Net::AMQP.new(:debug);
    unless @topics.elems {
        say &#34;will be displaying all the messages&#34;;
        @topics.push: &#39;#&#39;;
    }
    my $connection = $n.connect.result;
    react {
        whenever $n.open-channel(1) -&gt; $channel {
            whenever $channel.declare-exchange(&#39;topic-logs&#39;, &#39;topic&#39;) -&gt; $exchange {
                whenever $channel.declare-queue() -&gt; $queue {
                    for @topics -&gt; $topic {
                        await $queue.bind(&#39;topic-logs&#39;, $topic);
                    }
                    $queue.consume;
                    my $body-supply = $queue.message-supply.map( -&gt; $v { [ $v.routing-key, $v.body.decode ] }).share;
                    whenever $body-supply -&gt; ( $topic , $message ) {
                            say $*PID ~ &#34; : [$topic]  $message&#34;;
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里基本上与前面的消费者示例的唯一区别是（除了提供给交换声明的类型）该主题提供给绑定方法。该主题可以是一个简单模式，其中＃将匹配任何提供的路由密钥，并且行为将与扇出交换相同，否则*可以在绑定主题的任何部分用作通配符，以匹配任何字符在这个例子中，在这个例子中，应用程序*将匹配使用路由关键字application.info或application.debug发送的消息。</p>
</div>
<div class="paragraph">
<p>如果有多于一个队列使用相同的模式绑定，则它们的行为也会像绑定到扇出交换机一样。如果绑定模式既不包含哈希也不包含星号字符，那么队列的行为就好像它被绑定到一个直接交换的那个名称的队列一样（也就是说它将有先到先服务基础。）</p>
</div>
</div>
<div class="sect2">
<h3 id="_但是生命比amqp更重要">15.6. 但是，生命比AMQP更重要</h3>
<div class="paragraph">
<p>当然。 Raku反应模型的优点在于可以将上面提到的供应商提供的各种源集成到您的生产者代码中，并且类似地，消费者可以将消息推送到另一个传输机制。</p>
</div>
<div class="paragraph">
<p>我很高兴地发现，当我想到这个例子的时候，下面的工作是正常的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use EventSource::Server;
use Net::AMQP;
use Cro::HTTP::Router;
use Cro::HTTP::Server;

my $supply = supply {
	my $n = Net::AMQP.new;
	my $connection = $n.connect.result;
	whenever $n.open-channel(1) -&gt; $channel {
		whenever $channel.declare-queue(&#34;hello&#34;) -&gt; $queue {
			$queue.consume;
			whenever $queue.message-supply.map( -&gt; $v { $v.body.decode }) -&gt; $data {
				emit EventSource::Server::Event.new(type =&gt; &#39;hello&#39;, :$data);
			}
		}
	}
};

my $es = EventSource::Server.new(:$supply);

my $application = route {
	get -&gt; &#39;greet&#39;, $name {
		content &#39;text/event-stream; charset=utf-8&#39;, $es.out-supply;
	}
}
my Cro::Service $hello = Cro::HTTP::Server.new:
	:host, :port, :$application;
$hello.start;

react whenever signal(SIGINT) { $hello.stop; exit; }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">这是EventSource </dt>
<dd>
<p>Server中的示例的变体，您当然可以修改它以使用上面讨论的任何交换类型。它应该适用于第一个例子中的生产者代码。而且（如果你是这么说服的话），你可以用一小段node.js代码（或者在一些面向浏览器的javascript中）来消费事件：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">	var EventSource = require(&#39;eventsource&#39;);

	var event = process.argv[2] || &#39;message&#39;;

	console.info(event);
	var v = new EventSource(&#39; http://127.0.0.1:10000&#39;);

	v.addEventListener(event, function(e) {
		console.info(e);

	}, false);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_把它包起来">15.7. 把它包起来</h3>
<div class="paragraph">
<p>在输入第一段之后，我总结道，在一篇短文中，我永远无法做到这个主题正义，所以我希望你认为这是一个开胃菜，我不认为我会永远找到时间来写书，它可能值得。但是我确实有基于 <a href="https://github.com/jonathanstowe/Raku-RMQ-Examples">RabbitMQ 教程</a>的所有示例，因此请检查并随意贡献。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十八天_raku_支持的工作流">16. <a href="https://rakuadvent.wordpress.com/2017/12/18/raku-powered-work-flow/">第十八天-Raku 支持的工作流</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>保持流畅的编码可能是一个挑战。分心和讨厌的句法错误是潜在的流量瓶颈。</p>
</div>
<div class="paragraph">
<p>然后是7 +/- 2短期内存限制，我们都必须耍弄。与计算机不同，我们不能仅仅增加更多的硬件来增加大脑工作内存缓冲区的大小 - 至少目前还没有。保持流量需要管理这个缓冲区以避免井喷。幸运的是，我们有电脑帮助。</p>
</div>
<div class="paragraph">
<p>自计算开始以来，使用计算机扩展记忆的想法一直存在。早在1945年，Vannevar Bush就设想了一种Memex（MEMory EXtender），这是一种“扩大了对个人记忆的贴心补充”。</p>
</div>
<div class="paragraph">
<p>在2017年，卑微的文本文件可以像一个穷人的memex。该文本文件包含三个部分的时间轴：过去，现在和下一个。这有点像改变日志，但也有未来。过去的部分会随着时间的推移填满，包含完成的任务和信息供以后召回。现在部分可帮助您专注于手头的任务，而下一部分将排队完成将来要完成的任务。</p>
</div>
<div class="paragraph">
<p>任务通过三种状态：do（+ next），done（！now）和done（-past）。</p>
</div>
<div class="paragraph">
<p>为了保持畅通，你有时需要快速回忆一些事情，记下将来要做的事情，并专注于现在的进步。保留一个123.do文件可以帮助您减轻编码时的认知负担。</p>
</div>
<div class="paragraph">
<p>123.do文件的格式很简单，因此您可以直接使用文本编辑器对其进行破解，并使用此Raku语法进行描述。</p>
</div>
<div class="paragraph">
<p>这是驱动它的Raku命令行模块。</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2017/12/tty.gif?w=652&amp;zoom=2">img</a></p>
</div>
<div class="paragraph">
<p>安装它只需:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">shell&gt; zef install Do123
shell&gt; 123 +7 Merry Christmas
shell&gt; 123 +13 Happy New Year</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十九天_language_independent_validation_rules_livr_for_raku">17. <a href="https://rakuadvent.wordpress.com/2017/12/19/day-19-language-independent-validation-rules-livr-for-raku/">第十九天-Language Independent Validation Rules (LIVR) for Raku</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>我刚刚将 LIVR <a href="https://modules.raku.org/dist/LIVR:cpan:KOORCHIK">移植</a>到了 Raku。在 Raku 中编写代码非常有趣。而且，LIVR 的测试套件让我能够在 Raku 的 Email::Valid 模块中发现 bug，而在 Rakudo 中则发现另一个 bug。更有趣的是，不仅仅实现了一个模块，而且还帮助其他开发人员进行了一些测试:)</p>
</div>
<div class="paragraph">
<p>什么是 LIVR？ LIVR 代表“语言独立验证规则”。所以，它就像 “<a href="https://mustache.github.io/">Mustache</a>” ，但在验证的世界。所以，LIVR 由以下几部分组成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://livr-spec.org/">LIVR规范</a></p>
</li>
<li>
<p><a href="http://livr-spec.org/introduction/implementations.html">针对不同语言的实现</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/LIVR/tree/master/test_suite">通用测试套件</a>，用于检查实现是否正常工作。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>LIVR 有如下语言的实现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/koorchik/Validator-LIVR">Perl 5 (LIVR 2.0)</a> available at <a href="https://metacpan.org/pod/Validator::LIVR">CPAN</a>, 维护者 <a href="https://github.com/koorchik">@koorchik</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/raku-livr">Raku (LIVR 2.0)</a> available at <a href="https://modules.raku.org/dist/LIVR:cpan:KOORCHIK">CPAN</a>, 维护者 <a href="https://github.com/koorchik">@koorchik</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/js-validator-livr">JavaScript (LIVR 2.0)</a> available at <a href="https://www.npmjs.com/package/livr">npm</a>, 维护者 <a href="https://github.com/koorchik">@koorchik</a></p>
</li>
<li>
<p><a href="https://github.com/WebbyLab/php-validator-livr">PHP (LIVR 2.0)</a> available at <a href="https://packagist.org/packages/validator/livr">packagist</a>, 维护者 <a href="https://github.com/WebbyLab">@WebbyLab</a></p>
</li>
<li>
<p><a href="https://github.com/asholok/python-validator-livr">Python (LIVR 2.0)</a> available at <a href="https://pypi.python.org/pypi/LIVR">pypi</a>, 维护者 <a href="https://github.com/asholok">@asholok</a></p>
</li>
<li>
<p><a href="https://github.com/Prots/olifer">OLIFER Erlang (LIVR 2.0)</a>, 维护者 <a href="https://github.com/Prots">@Prots</a></p>
</li>
<li>
<p><a href="https://github.com/erlangbureau/liver">LIVER Erlang (LIVR 2.0)</a>, 维护者 <a href="https://github.com/erlangbureau">@erlangbureau</a></p>
</li>
<li>
<p><a href="https://github.com/vlbaluk/java-validator-livr">Java (LIVR 2.0)</a>, 维护者 <a href="https://github.com/vlbaluk">@vlbaluk</a></p>
</li>
<li>
<p><a href="https://github.com/maktwin/ruby-validator-livr">Ruby (LIVR 0.4, previous version)</a> at <a href="https://rubygems.org/gems/livr">rubygems</a>, 维护者 <a href="https://github.com/maktwin">@maktwin</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我会在这里给你一个关于LIVE的简短介绍，但是对于细节，我强烈推荐阅读这篇文章 <a href="http://blog.webbylab.com/language-independent-validation-rules-library/">“LIVR – Data Validation Without Any Issues”</a></p>
</div>
<div class="sect2">
<h3 id="_livr_介绍">17.1. LIVR 介绍</h3>
<div class="paragraph">
<p>数据验证是一项非常普遍的任务。我确信每个开发者都会一次又一次面对它。尤其是，当您开发Web应用程序时，这一点很重要。这是一条通用规则 - 绝对不要相信用户的输入。看起来，如果任务如此普遍，应该有大量的图库。是的，但它是很难找到一个理想的。有些库做了太多事情（如 HTML 表单生成等），其他库很难扩展，有些没有分层数据支持等。</p>
</div>
<div class="paragraph">
<p>而且，如果您是一名 Web 开发人员，则可能需要在服务器和客户端上进行相同的验证。</p>
</div>
<div class="paragraph">
<p>在 WebbyLab 中，我们主要使用 3 种编程语言 -  Perl，JavaScript，PHP。因此，对我们来说，重用跨语言的类似验证方法是理想的选择。</p>
</div>
<div class="paragraph">
<p>因此，决定创建一个可以跨不同语言工作的通用验证器。</p>
</div>
<div class="sect3">
<h4 id="_验证器要求">17.1.1. 验证器要求</h4>
<div class="paragraph">
<p>在尝试了大量的验证库之后，我们对我们想要解决的问题有了一些想法。以下是验证器的要求：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>规则是声明式并独立于语言的。因此，验证规则只是一个数据结构，而不是方法调用等。您可以对其进行转换，在对其他数据结构进行更改时进行更改</p>
</li>
<li>
<p>每个字段的任何数量的规则</p>
</li>
<li>
<p>验证器应该返回所有字段的错误。例如，我们想突出显示表单中的所有错误</p>
</li>
<li>
<p>剪掉所有没有描述验证规则的字段。 （否则，你不能依赖你的验证，如果验证器不符合这个属性，总有一天你会遇到安全问题）</p>
</li>
<li>
<p>可以验证复杂的层次结构。特别适用于 JSON APIs</p>
</li>
<li>
<p>易于描述和理解验证</p>
</li>
<li>
<p>返回可理解的错误代码（既不是错误消息也不是数字代码）</p>
</li>
<li>
<p>易于实现自己的规则（通常你会在每个项目中有几个）</p>
</li>
<li>
<p>规则应该能够改变结果输出（例如，“trim”，“nested_object”）</p>
</li>
<li>
<p>多用途（用户输入验证，配置验证等）</p>
</li>
<li>
<p>Unicode 支持</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_livr规范">17.1.2. LIVR规范</h4>
<div class="paragraph">
<p>由于该任务设置为独立于编程语言（某种胡须/句柄的东西）创建验证器，但在数据验证领域内，我们从规范的组成开始。</p>
</div>
<div class="paragraph">
<p>规范的目标是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>标准化数据描述格式。</p>
</li>
<li>
<p>描述每个实现必须支持的最小验证规则集。</p>
</li>
<li>
<p>标准化错误代码。</p>
</li>
<li>
<p>成为所有实现的单个基本文档。</p>
</li>
<li>
<p>具有一组测试数据，可以检查实现是否符合规范。</p>
</li>
<li>
<p>基本思想是验证规则的描述必须看起来像数据方案，并且尽可能与数据类似，但是使用规则而不是值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>该规范可在 <a href="http://livr-spec.org/" class="bare">http://livr-spec.org/</a> 获得。</p>
</div>
<div class="paragraph">
<p>这是基本的介绍。更多细节在我上面提到的文章中。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_livr和raku">17.2. LIVR和Raku</h3>
<div class="paragraph">
<p>让我们玩得开心，玩一段代码。我将通过几个例子，并在每个例子后提供一些内部细节。所有示例的源代码都可以在 <a href="https://github.com/koorchik/raku-livr-advent-calendar-post/tree/master/examples">GitHub</a> 上找到</p>
</div>
<div class="paragraph">
<p>首先，从 CPAN 安装 Raku 的 LIVR 模块</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install LIVR</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>示例1：注册数据验证</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use LIVR;

# Automatically trim all values before validation
LIVR::Validator.default-auto-trim(True);

my $validator = LIVR::Validator.new(livr-rules =&gt; {
    name      =&gt; &#39;required&#39;,
    email     =&gt; [ &#39;required&#39;, &#39;email&#39; ],
    gender    =&gt; { one_of =&gt; [&#39;male&#39;, &#39;female&#39;] },
    phone     =&gt; { max_length =&gt; 10 },
    password  =&gt; [ &#39;required&#39;, {min_length =&gt; 10} ],
    password2 =&gt; { equal_to_field =&gt; &#39;password&#39; }
});

my $user-data = {
    name      =&gt; &#39;Viktor&#39;,
    email     =&gt; &#39;viktor@mail.com&#39;,
    gender    =&gt; &#39;male&#39;,
    password  =&gt; &#39;mypassword123&#39;,
    password2 =&gt; &#39;mypassword123&#39;
}


if my $valid-data = $validator.validate($user-data) {
    # $valid-data is clean and does contain only fields
    # which have validation and have passed it
    $valid-data.say;
} else {
    my $errors = $validator.errors();
    $errors.say;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>那么，如何理解规则？</strong></p>
</div>
<div class="paragraph">
<p>这个想法很简单。每条规则都是一个散列. key  - 验证规则的名称。value - 一个参数数组。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    name  =&gt; { required =&gt; [] },
    phone =&gt; { max_length =&gt; [10] }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但如果只有一个参数，则可以使用较短的形式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    phone =&gt; { max_length =&gt; 10 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有参数，则可以将规则的名称作为字符串传递：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    name =&gt; &#39;required&#39;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在数组中给字段传递一个规则列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    name =&gt; [ &#39;required&#39;, { max_length =&gt; 10 } ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，规则将陆续应用。因此，在这个例子中，首先，“required” 规则将被应用，“max_length” 之后，并且只有当 “required” 成功通过时。</p>
</div>
<div class="paragraph">
<p>这里是 <a href="http://livr-spec.org/validation-rules/how-it-works.html">LIVR 规范的细节</a>。</p>
</div>
<div class="paragraph">
<p>你可以在<a href="http://livr-spec.org/validation-rules.html">这里</a>找到标准规则的列表。</p>
</div>
<div class="paragraph">
<p>例2：分层数据结构的验证</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use LIVR;

my $validator = LIVR::Validator.new(livr-rules =&gt; {
    name  =&gt; &#39;required&#39;,
    phone =&gt; {max_length =&gt; 10},
    address =&gt; {&#39;nested_object&#39; =&gt; {
        city =&gt; &#39;required&#39;,
        zip  =&gt; [&#39;required&#39;, &#39;positive_integer&#39;]
    }}
});

my $user-data = {
    name  =&gt; &#34;Michael&#34;,
    phone =&gt; &#34;0441234567&#34;,
    address =&gt; {
        city =&gt; &#34;Kiev&#34;,
        zip  =&gt; &#34;30552&#34;
    }
}

if my $valid-data = $validator.validate($user-data) {
    # $valid-data is clean and does contain only fields
    # which have validation and have passed it
    $valid-data.say;
} else {
    my $errors = $validator.errors();
    $errors.say;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>这个例子中有趣的是什么？</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>模式（验证规则）形状与数据形状非常相似。例如，读取比 JSON Schema 容易得多。</p>
</li>
<li>
<p>看起来 “nested_object” 是一种特殊的语法，但它不是。验证器在 “required”，“nested_object”，“max_length” 之间没有任何区别。所以，核心非常小，您可以轻松地使用自定义规则引入新功能。</p>
</li>
<li>
<p>通常你想重用复杂的验证规则，比如 “address”，并且可以使用别名来完成。</p>
</li>
<li>
<p>您将收到分层错误消息。例如，如果您错过 city 和 name，错误对象将显示 <code>{name ⇒&#39;REQUIRED&#39;，address ⇒ {city ⇒&#39;REQUIRED&#39;}}</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_别名">17.2.1. 别名</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use LIVR;

LIVR::Validator.register-aliased-default-rule({
    name  =&gt; &#39;short_address&#39;, # names of the rule
    rules =&gt; {&#39;nested_object&#39; =&gt; {
        city =&gt; &#39;required&#39;,
        zip  =&gt; [&#39;required&#39;, &#39;positive_integer&#39;]
    }},
    error =&gt; &#39;WRONG_ADDRESS&#39; # custom error (optional)
});

my $validator = LIVR::Validator.new(livr-rules =&gt; {
    name    =&gt; &#39;required&#39;,
    phone   =&gt; {max_length =&gt; 10},
    address =&gt; &#39;short_address&#39;
});

my $user-data = {
    name  =&gt; &#34;Michael&#34;,
    phone =&gt; &#34;0441234567&#34;,
    address =&gt; {
        city =&gt; &#34;Kiev&#34;,
        zip  =&gt; &#34;30552&#34;
    }
}

if my $valid-data = $validator.validate($user-data) {
    # $valid-data is clean and does contain only fields
    # which have validation and have passed it
    $valid-data.say;
} else {
    my $errors = $validator.errors();
    $errors.say;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你愿意，你可以只为你的验证器实例注册别名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use LIVR;

my $validator = LIVR::Validator.new(livr-rules =&gt; {
    password =&gt; [&#39;required&#39;, &#39;strong_password&#39;]
});

$validator.register-aliased-rule({
    name  =&gt; &#39;strong_password&#39;,
    rules =&gt; {min_length =&gt; 6},
    error =&gt; &#39;WEAK_PASSWORD&#39;
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>示例3：数据修改，流水线</strong>
有规则可以做数据修改。以下是他们的列表：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>trim</p>
</li>
<li>
<p>to_lc</p>
</li>
<li>
<p>to_uc</p>
</li>
<li>
<p>remove</p>
</li>
<li>
<p>leave_only</p>
</li>
<li>
<p>default</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你可以在这里<a href="http://livr-spec.org/validation-rules/modifiers.html">阅读细节</a>。</p>
</div>
<div class="paragraph">
<p>用这种方法，你可以创建某种管道。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use LIVR;

my $validator = LIVR::Validator.new(livr-rules =&gt; {
    email =&gt; [ &#39;trim&#39;, &#39;required&#39;, &#39;email&#39;, &#39;to_lc&#39; ]
});

my $input-data = { email =&gt; &#39; EMail@Gmail.COM &#39; };
my $output-data = $validator.validate($input-data);

$output-data.say;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>这里重要的是什么？</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>正如我之前提到的，对于验证器来说，任何规则都没有区别。它以同样的方式处理 “trim”，“default”，“required”，“nested_object”。</p>
</li>
<li>
<p>规则一个接一个地应用。规则的输出将被传递给下一个规则的输入。这就像一个 bash 管道 <code>echo &#39; <a href="mailto:EMail@Gmail.COM">EMail@Gmail.COM</a> &#39; | trim | required | email | to_lc</code></p>
</li>
<li>
<p><code>$input-data</code> <strong>永远不会</strong>改变 <code>$output-data</code> 是验证后使用的数据。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>示例4：自定义规则</strong></p>
</div>
<div class="paragraph">
<p>您可以使用别名作为自定义规则，但有时这还不够。编写自己的自定义规则绝对没问题。你可以用自定义规则做几乎所有事情。</p>
</div>
<div class="paragraph">
<p>通常，我们在每个项目中都有 1-5 个自定义规则。此外，您可以将自定义规则组织为单独的可重用模块（甚至可以将其上传到 CPAN）。</p>
</div>
<div class="paragraph">
<p><strong>那么，如何为 LIVR 编写自定义规则？</strong></p>
</div>
<div class="paragraph">
<p>这里是’strong_password’的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use LIVR;

my $validator = LIVR::Validator.new(livr-rules =&gt; {
    password =&gt; [&#39;required&#39;, &#39;strong_password&#39;]
});

$validator.register-rules( &#39;strong_password&#39; =&gt;  sub (@rule-args, %builders) {
    # %builders - are rules from original validator
    # to allow you create new validator with all supported rules
    # my $validator = LIVR::Validator.new(livr-rules =&gt; $livr).register-rules(%builders).prepare();
    # See &#34;nested_object&#34; rule implementation for example
    # https://github.com/koorchik/raku-livr/blob/master/lib/LIVR/Rules/Meta.pm6#L5

    # Return closure that will take value and return error
    return sub ($value, $all-values, $output is rw) {
        # We already have &#34;required&#34; rule to check that the value is present
        return if LIVR::Utils::is-no-value($value); # so we skip empty values

        # Return value is a string
        return &#39;FORMAT_ERROR&#39; if $value !~~ Str &amp;&amp; $value !~~ Numeric;

        # Return error in case of failed validation
        return &#39;WEAK_PASSWORD&#39; if $value.chars &lt; 6;

        # Change output value. We want always return value be a string
        $output = $value.Str;
        return;
    };
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>查看更多示例的现有规则实现:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/koorchik/raku-livr/blob/master/lib/LIVR/Rules/Common.pm6">Common rules</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/raku-livr/blob/master/lib/LIVR/Rules/Numeric.pm6">Numeric rules</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/raku-livr/blob/master/lib/LIVR/Rules/String.pm6">String rules</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/raku-livr/blob/master/lib/LIVR/Rules/Special.pm6">Special rules</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/raku-livr/blob/master/lib/LIVR/Rules/Modifiers.pm6">Modifiers rules</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/raku-livr/blob/master/lib/LIVR/Rules/Meta.pm6">Meta rules</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>示例5：Web 应用程序</strong></p>
</div>
<div class="paragraph">
<p>LIVR 适用于 REST API。通常，很多 REST API 在返回可理解的错误方面存在问题。如果您的 API 用户将收到 HTTP 错误 500，它不会帮助他。更好的时候，他会得到类似的错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">{
    &#34;name&#34;: &#34;REQUIRED&#34;,
    &#34;phone&#34;: &#34;TOO_LONG&#34;,
    &#34;address&#34;: {
        &#34;city&#34;: &#34;REQUIRED&#34;,
        &#34;zip&#34;: &#34;NOT_POSITIVE_INTEGER&#34;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而不仅仅是“服务器错误”。</p>
</div>
<div class="paragraph">
<p>所以，让我们试着做一个带有两个端点的小型 Web 服务：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>GET /notes → get list of notes</p>
</li>
<li>
<p>POST /notes → create a note</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您需要为其安装 Bailador：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install Bailador</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们来创建一些服务。我更喜欢带有 “run”模板方法的服务中的 “Command”模式。</p>
</div>
<div class="paragraph">
<p>我们将有 2 项服务：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Service::Notes::Create</p>
</li>
<li>
<p>Service::Notes::List</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>服务使用示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %CONTEXT = (storage =&gt; my @STORAGE);

my %note = title =&gt; &#39;Note1&#39;, text =&gt; &#39;Note text&#39;;

my $new-note = Service::Notes::Create.new(
    context =&gt; %CONTEXT
).run(%note);

my $list = Service::Notes::Create.new(
    context =&gt; %CONTEXT
).run({});</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了上下文，你可以注入任何依赖关系。 “run” 方法接受用户传递的数据。</p>
</div>
<div class="paragraph">
<p>以下是创建笔记服务的源代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Service::Base;
my $LAST_ID = 0;
class Service::Notes::Create is Service::Base {
    has %.validation-rules = (
        title =&gt; [&#39;required&#39;, {max_length =&gt; 20} ],
        text  =&gt; [&#39;required&#39;, {max_length =&gt; 255} ]
    );

    method execute(%note) {
        %note&lt;id&gt; = $LAST_ID++;
        $.context&lt;storage&gt;.push(%note);

        return %note;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>和 Service::Base 类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use LIVR;
LIVR::Validator.default-auto-trim(True);

class Service::Base {
    has $.context = {};

    method run(%params) {
        my %clean-data = self!validate(%params);
        return self.execute(%params);
    }

    method !validate($params) {
        return $params unless %.validation-rules.elems;

        my $validator = LIVR::Validator.new(
            livr-rules =&gt; %.validation-rules
        );

        if my $valid-data = $validator.validate($params) {
            return $valid-data;
        } else {
            die $validator.errors();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>“run” 方法保证所有过程都被保留：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>数据已经过验证。</p>
</li>
<li>
<p>“execute” 仅在验证后才会调用。</p>
</li>
<li>
<p>“execute” 将只收到干净的数据。</p>
</li>
<li>
<p>在验证错误的情况下引发异常。</p>
</li>
<li>
<p>在调用“execute”之前可以检查权限。</p>
</li>
<li>
<p>可以执行额外的工作，如缓存验证器对象等。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这是<a href="https://github.com/koorchik/raku-livr-advent-calendar-post/tree/master/examples/example5-restapi">完整的工作示例</a>。</p>
</div>
<div class="paragraph">
<p>运行应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku app.pl6</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建一个 note：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">curl -H &#34;Content-Type: application/json&#34; -X POST -d &#39;{&#34;title&#34;:&#34;New Note&#34;,&#34;text&#34;:&#34;Some text here&#34;}&#39; http://localhost:3000/notes</code></pre>
</div>
</div>
<div class="paragraph">
<p>检查验证：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">curl -H &#34;Content-Type: application/json&#34; -X POST -d &#39;{&#34;title&#34;:&#34;&#34;,&#34;text&#34;:&#34;&#34;}&#39; http://localhost:3000/notes</code></pre>
</div>
</div>
<div class="paragraph">
<p>获取notes列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">curl http://localhost:3000/notes</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_livr_链接">17.3. LIVR 链接</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/koorchik/raku-livr-advent-calendar-post/tree/master/examples">The source code of all examples</a></p>
</li>
<li>
<p>文章 <a href="http://blog.webbylab.com/language-independent-validation-rules-library/">“LIVR – Data Validation Without Any Issues”</a></p>
</li>
<li>
<p><a href="http://livr-spec.org/">LIVR specifications and docs (the latest version – 2.0)</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/LIVR/tree/master/test_suite">Universal test suite</a></p>
</li>
<li>
<p>你可以在线玩 <a href="http://webbylab.github.io/livr-playground/">LIVR Playground</a></p>
</li>
<li>
<p>你可以在线玩 <a href="http://livr-multi-playground.webbylab.com/">LIVR Multi-Language Playground</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我希望你会喜欢 LIVR。我会很感激任何反馈。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十天_宏的进阶">18. <a href="https://rakuadvent.wordpress.com/2017/12/20/day-20-advancements-in-macrotechnologies/">第二十天-宏的进阶</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>你好！</p>
</div>
<div class="paragraph">
<p>请允许我，在出现日历的这一天，一个小切线。我不会直接谈论一个很酷的熟练的Raku特性。相反，我会打开一个小窗口，讨论可能会发生什么 - 希望在某些时候！</p>
</div>
<div class="paragraph">
<p>如果你像我一样，在Rakudo上继续了几年的进步，你在版本中经常看到这一点：&gt;一些不太有效的功能包括：&gt;  - 高级宏</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">那么，这究竟意味着什么？ Raku确实有宏，但它们目前的限制超出了人们通常想要做的。这并不是说它们目前是无用的，它们仍然是有用的，从前几年出现的其他帖子到OO </dt>
<dd>
<p>Monitor使用宏来提前报告拼写错误。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>输入007. 007是“具有宏观许可的小型实验语言”。这是什么意思？！这是一种用于对宏进行调试和实验的语言，因此当他们被集成到Raku中时，他们的设计就已经准备好并经过战斗测试。</p>
</div>
<div class="paragraph">
<p>那么，它有什么？ 007试图模仿Raku的“强大”部分，因此我们不会为完全不同的语言设计宏。这意味着阶段，中缀操作员，（MOP和正则表达式的要点）。</p>
</div>
<div class="paragraph">
<p>它是什么样子的？ 007的核心就是喜欢Raku.然而，它的确存在一些问题。让我们来看看你想写的最重要的片段：FizzBu​​zz。注意：此博客帖子中的所有代码片段都是可执行的007代码，而不是Raku代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my n = 1;
while n &lt;= 100 {
    if n %% 15 {
        say(&#34;FizzBuzz&#34;);
    }
    else if n %% 3 {
        say(&#34;Fizz&#34;);
    }
    else if n %% 5 {
        say(&#34;Buzz&#34;);
    }
    else {
        say(n);
    }
    n = n + 1;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>什么？你不在乎吗？很明显，我确实答应过你的宏。我们将看看一个简单的宏“name”，它返回最后一个索引对象的名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">macro name(expr) {
    if expr ~~ Q::Postfix::Property {
        expr = expr.property;
    }
    if expr !~~ Q::Identifier {
        throw new Exception {
            message: &#34;Cannot turn a &#34; ~ type(expr) ~ &#34; into a name&#34;
        };
    }
    return quasi { expr.name };
}

my info = {
    foo: &#34;Bond&#34;,
    bar: {
        baz: &#34;James Bond&#34;
    },
};

say(name(info));           # info
say(name(info.foo));       # foo
say(name(info.bar.baz));   # baz</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以，你可能会在这里“WAT”。你是对的 - 这个要点缺少一些解释。宏的一个最重要的功能是访问AST（抽象语法树）。宏需要能够混淆代码的结构（如Lisp），而不是代码文本（如C）。 Q ::类型是代表程序形状的标准化类型。他们并不特别需要表示编译器/解释器如何考虑代码，但他们需要保持稳定，因为我们正在编写我们的代码 - 我们的宏 - 针对这种内省API。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">在这个代码示例中，我们使用了两种Q类型：表示点访问的Q </dt>
<dd>
<p>Postfix :: Property和表示标识符的Q :: Identifier。首先，我们检查我们是否有财产。如果是这种情况，我们提取点右侧的内容（记住，a.b.c是（a.b）.c）。然后我们检查我们是否结束了一个标识符（而不是一个数字），并打印出来。这是例如我们如何才能实现C＃的操作符名称，而不必为语言添加任何内容！</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>几天前，masak ++发布了一篇名为“三年过去”的博客文章，标志着007的第三个生日。虽然有些地区仍然非常粗糙，但它看起来越来越像一种可用的语言，日复一日。</p>
</div>
<div class="paragraph">
<p>接下来我们要看的是正在解析的实现。下面是它的外观：（这个例子适用于PR，但是现在使用特殊外壳）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">macro statement:() is parsed(/&#34;whoa!&#34;/) {
    return quasi @ Q::Statement {
        say(&#34;whoa!&#34;);
    }
};

whoa!;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也可能是我们希望他们在Raku中看起来…​…​或者不是？讨论仍在进行中！鼓励你加入自行车…​…​讨论:-)。这种语言还很年轻，需要大量的丰富功能，以及它的高级功能和简单功能。</p>
</div>
<div class="paragraph">
<p>在我向你提供大量的元乐趣之前，这里是007想要达到目前坐落在分支中的一个里程碑：实现infix：&lt;ff&gt;作为库的一部分（如果你不确定，Raku文档如果在这里适用），而不是语言的一部分。代码在这里！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># our infix macro takes a lhs (left hand side) and a rhs (right hand side).
macro infix:&lt;ff&gt;(lhs, rhs) is tighter(infix:&lt;=&gt;) {
    my active = False; # our current value when starting
    return quasi {
        if {{{lhs}}} {
            active = True; # if the bit on the left is true, we switch to active mode
        }
        my result = active; # the result we are returning
        if {{{rhs}}} {
            active = False; # if the bit on the right is true, we switch to inactive mode
        }
        result; # return the result stored *before* the rhs ran.
    };
}

my values = [&#34;A&#34;, &#34;B&#34;, &#34;A&#34;, &#34;B&#34;, &#34;A&#34;];
for values -&gt; v {
    if v == &#34;B&#34; ff v == &#34;B&#34; {
        say(v);
    }
    else {
        say(&#34;x&#34;);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是今天！如果您需要更多，请随时查看教程或示例文件夹。如果你想了解意愿，我们也有路线图。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十一天_数独与junctions和集合">19. <a href="https://rakuadvent.wordpress.com/2017/12/21/day-21-sudoku-with-junctions-and-sets/">第二十一天-数独与Junctions和集合</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 中有许多核心元素为您提供强大的工具，以简洁而强大的方式完成任务。其中两个是具有许多特征的联结和集合，但也是截然不同的。为了演示这些功能，我将介绍如何将它们用于一个简单的问题，Sudoku拼图。</p>
</div>
<div class="paragraph">
<p>数独：进修
所以对于那些不知道数独谜题的人来说，它是一个9乘9的网格，它提供了一些填充了数字1-9的单元格。目标是填充数字在1和9之间的所有单元格，所以没有任何行，列或子广场具有多于一个的数字。</p>
</div>
<div class="paragraph">
<p>有几种方法来表示一个数独谜题，我个人最喜欢的是 9×9 嵌套数组，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @game = [
    [4,0,0,0,0,0,0,0,0],
    [0,9,0,3,4,6,0,5,0],
    [5,8,0,0,9,0,0,0,6],
    [0,4,0,8,1,3,0,0,9],
    [0,0,0,5,0,4,0,0,0],
    [8,0,0,6,2,9,0,4,0],
    [3,0,0,0,5,0,0,6,2],
    [0,5,0,9,3,2,0,8,0],
    [0,0,0,0,0,0,0,0,1]
];</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，没有赋值的单元格被赋值为0，这样所有的单元格都有一个赋值给它们的整数值。使用这种格式要记住的主要事情是你需要使用@game [$ y] [$ x]而不是@game [$ x] [$ y]来引用单元格，</p>
</div>
<div class="sect2">
<h3 id="_junctions量子逻辑测试">19.1. Junctions：量子逻辑测试</h3>
<div class="paragraph">
<p>在 Raku 中使用 Junction 的最简单方法之一是逻辑测试。 Junction可以表示您想要测试的值的选择。例如 ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if ( 5 &lt; 1|10 &lt; 2 ) { say &#34;Spooky&#34; } else { say &#34;Boo&#34; }
Spooky</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，这不仅证明了操作符链（经验丰富的程序员可能已经看起来很困惑），而且对于5 &lt;10和1 &lt;2，任何连接点（1 | 10）的计算结果都为True。这样，连接点可以非常已经很强大了，当你为它们分配一个变量容器时，它变得非常有趣。</p>
</div>
<div class="paragraph">
<p>我们希望能够在我们的数独游戏中做出的一个测试就是看它是否已满。我的意思是每个单元格的赋值都大于0.完整的拼图可能无法正确完成，但每个单元格都有一个猜测。另一种方法是，没有任何单元格的值为0.因此，我们可以定义一个Junction并将其存储在一个标量变量中，我们可以在任何时候测试它以查看拼图是否已满。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $full-test = none( (^9 X ^9).map(-&gt; ($x,$y) {
    @game[$y][$x];
} ) );
say so $full-test == 0;
False</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，游戏中仍然有0个数字，因此看看$ full-test是否等于0，结果为False。请注意，如果没有将结果强制转换为布尔值，只有当所有这些值都为False时，才会得到等于0的单元格的细分。</p>
</div>
<div class="paragraph">
<p>还要注意使用^ 9和X运算符来生成0到8的两个范围，然后使用这两个9个字符的列表的叉积来列出所有可能的X，Y坐标的列表。这就是这种强大的简单性，这是我喜欢Raku的原因之一。但我离题了。</p>
</div>
<div class="paragraph">
<p>这种方法的优点是，一旦你定义了Junction，你就不需要修改它。如果您更改存储在数组中的值，那么连接将会查看新的值（注意，这仅适用于更新单个单元格，如果用新的数组替换整个子数组，您将打破连接点）。</p>
</div>
<div class="paragraph">
<p>所以这是一个简单的使用连接点，因此存储一个可以重复使用的多变量测试。但是当你意识到连接点中的值本身就是连接点时，它会变得更有趣。</p>
</div>
<div class="paragraph">
<p>让我们看看更复杂的测试，如果拼图中的每一行，每列和每个数字中只有一个，则拼图就完成了。为了做这个测试，我们需要三个帮助函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset Index of Int where 0 &lt;= * &lt;= 8;
sub row( Index $y ) {
    return (^9).map( { ( $_, $y ) } );
}
sub col( Index $x ) {
     return (^9).map( { ( $x, $_ ) } );
}
multi sub square( Index $sq ) {
    my $x = $sq % 3 * 3;
    my $y = $sq div 3 * 3;
    return self.square( $x, $y );
}
multi sub square( Index $x, Index $y ) {
     my $tx = $x div 3 * 3;
     my $ty = $y div 3 * 3;
     return ( (0,1,2) X (0,1,2) ).map( -&gt; ( $dx, $dy ) {
        ( $tx + $dx, $ty + $dy )
    } );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，我们在这里定义一个索引作为0到8之间的值，然后定义我们的子索引来返回一个列表列表，其中子列表是一对X和Y索引。请注意，我们的平方函数可以接受一个或两个位置参数。在单个参数中，我们定义了0在左上角然后从左到右，8是右下角的子广场。两个参数版本给出了给定单元格（包括它自己）的正方形单元格列表。</p>
</div>
<div class="paragraph">
<p>所以在这些地方我们可以为每一行，列和方块定义我们的一个（）列表。一旦我们拥有了它们，我们就可以将它们放入一个全部（）连接点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $complete-all = all(
     (^9).map(
        {
            |(
                one( row( $_ ).map( -&gt; ( $x, $y ) {
                    @game[$y][$x]
                } ) ),
                one( col( $_ ).map( -&gt; ( $x, $y ) {
                    @game[$y][$x]
                } ) ),
                one( square( $_ ).map( -&gt; ( $x, $y ) {
                    @game[$y][$x]
                } ) )
            )
        }
    )
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦我们进行了测试，看看这个难题是否完整，那就很简单了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [&amp;&amp;] (1..9).map( so $complete-all == * );
False</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们测试1到9的每个可能的单元格值，对于交叉点，在每种情况下，如果所有的一个（）连接仅包含一个值，则这将为真。然后，我们使用[]缩减元运算符来链接这些结果以给出最终的真/假值（如果所有结果均为真，否则为真）。再次，这个测试可以在您向单元格添加值时重新使用，并且只有在拼图完成且正确时才会返回True。</p>
</div>
<div class="paragraph">
<p>我们再一次将复杂的测试归结为一行代码。我们的$ complete-all变量需要定义一次，然后在会话的其余部分有效。</p>
</div>
<div class="paragraph">
<p>这种嵌套联结测试可以达到很多级别，最后一个例子是如果我们想测试当前的难题是否有效。我的意思是它没有完成，但它没有任何重复的数字和行，列或方块。我们可以再次为此创建一个Junction，对于每一行，每列或每个方块，如果其中一个或没有一个单元格设置为每个可能的值，则它是有效的。因此，我们创建的Junction类似于$ complete-全部。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$valid-all = all(
    (^9).map(
        {
            |(
                one(
                    none( row( $_ ).map( -&gt; ( $x, $y ) {
                        @game[$y][$x]
                    } ) ),
                    one( row( $_ ).map( -&gt; ( $x, $y ) {
                        @game[$y][$x]
                    } ) )
                ),
                one(
                    none( col( $_ ).map( -&gt; ( $x, $y ) {
                        @game[$y][$x]
                    } ) ),
                    one( col( $_ ).map( -&gt; ( $x, $y ) {
                        @game[$y][$x]
                    } ) )
                ),
                one(
                    none( square( $_ ).map( -&gt; ( $x, $y ) {
                        @game[$y][$x]
                    } ) ),
                    one( square( $_ ).map( -&gt; ( $x, $y ) {
                        @game[$y][$x]
                    } ) )
                )
            )
        }
    )
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>有效性测试与完整性测试基本相同。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [&amp;&amp;] (1..9).map( so $valid-all == * );
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了在这种情况下我们的谜题是有效的，所以我们得到一个真实的结果。</p>
</div>
</div>
<div class="sect2">
<h3 id="_集合对象的集合">19.2. 集合：对象的集合</h3>
<div class="paragraph">
<p>虽然结点对测试值很有用，但如果我们想尝试解决这个难题，它们就不那么有用。但是Raku有另一种类型的集合，可以派上用场。套装（及其相关类型的手袋和混合物）可让您收集物品，然后对其进行数学设定操作，以找出不同套装之间的互动方式。</p>
</div>
<div class="paragraph">
<p>作为一个例子，我们将定义一个可能的函数，它返回给定单元格可能的值。如果单元格具有设置的值，我们将返回空列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub possible( Index $x, Index $y, @game ) {
    return () if @game[$y][$x] &gt; 0;

    (
        (1..9)
            (-)
        set(
            ( row($y).map( -&gt; ( $x, $y ) {
                @game[$y][$x]
            } ).grep( * &gt; 0 ) ),
            ( col($x).map( -&gt; ( $x, $y ) {
                @game[$y][$x]
            } ).grep( * &gt; 0 ) ),
            ( square($x,$y).map( -&gt; ( $x, $y ) {
                @game[$y][$x]
            } ).grep( * &gt; 0 ) )
        )
    ).keys.sort;
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们发现数字1到9与由给定单元格所在的行，列和平方值组成的集合之间的差异。我们使用grep忽略具有0值的单元格。 As Sets将他们的细节存储为无序的键/值对，我们得到这些键，然后对它们进行排序以保持一致性。请注意，这里我们使用的是运算符的ascii（ - ）版本，我们也可以使用Unicode版本。</p>
</div>
<div class="paragraph">
<p>我们可以将该集合定义为来自行，列和平方的每个结果的并集，并且结果将是相同的。在这种情况下，我们也使用square的两个参数版本。</p>
</div>
<div class="paragraph">
<p>应该指出的是，这是可能值最简单的定义，没有附加的逻辑进行，但即使这个简单的结果，我们也可以做最简单的求解算法。如果是这种情况，我们会在网格中的每个单元格中循环，如果它有1个可能的值，我们可以将该值设置为该值。在这种情况下，我们将循环，获取要设置的单元列表，然后遍历列表并设置值。如果要设置的列表为空或拼图完成，则停止。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @updates;
repeat {
    @updates = (^9 X ^9).map( -&gt; ($x,$y) {
        ($x,$y) =&gt; possible($x,$y,@game)
    } ).grep( *.value.elems == 1 );
    for @updates -&gt; $pair {
        my ( $x, $y ) = $pair.key;
        @game[$y][$x] = $pair.value[0];
    }
} while ( @updates.elems &gt; 0 &amp;&amp;
          ! [&amp;&amp;] (1..9).map( so $complete-all == * ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，我们列出了对的列表，其中关键是x，y坐标，值是可能的值。然后我们删除所有那些没有一个价值的东西。这一直持续到没有找到具有单个可能值的细胞或者谜题已完成为止。</p>
</div>
<div class="paragraph">
<p>找到解决方案的另一种方法是获得只出现在给定，行，列或方块的一组可能性中的值。例如，如果我们有以下可能性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1,2,3),(2,3,4),(),(),(4,5),(),(),(2,3,4),()</code></pre>
</div>
</div>
<div class="paragraph">
<p>1和5只在每行出现一次。我们可以利用对称集合差分算子和算子链来得到它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1,2,3) (^) (2,3,4) (^) () (^) () (^) (4,5) (^) () (^) () (^) (2,3,4) (^) ()
set(1 5)</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，在这种情况下，我们可以在列表中使用简化元运算符</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [(^)] (1,2,3),(2,3,4),(),(),(4,5),(),(),(2,3,4),()
set(1 5)</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以在这种情况下，算法很简单（在这种情况下，我只是覆盖行，列和方形代码基本相同）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @updates;
for ^9 -&gt; $idx {
    my $only = [(^)] row($idx).map( -&gt; ( $x,$y ) {
        possible($x,$y,@game)
    } );
    for $only.keys -&gt; $val {
        for row($idx) -&gt; ($x,$y) {
            if $val (elem) possible($x,$y,@game) {
                @updates.push( ($x,$y) =&gt; $val );
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们可以遍历与上面类似的更新数组。结合这两种算法可以自己解决大量的数独难题并简化其他难题。</p>
</div>
<div class="paragraph">
<p>请注意，我们必须进行两次传球，首先我们得到我们正在查找的数字，然后我们必须查看每一行并找出数字出现的位置。为此，我们使用（elem）运算符。集合也可以使用关联引用来引用，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say set(1,5){1}
True</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_关于对象的说明">19.3. 关于对象的说明</h3>
<div class="paragraph">
<p>因此，迄今为止所有的例子都使用了基本整数。但是没有任何东西阻止你在连接和集合中使用对象。有几件事要记住，虽然，集合使用===身份运算符进行测试。大多数对象都不能通过身份检查，除非你已经克隆了它们或者已经定义了WHICH方法以便能够进行比较。</p>
</div>
<div class="paragraph">
<p>对于数独谜题，您可能需要创建一个CellValue类，用于存储该数字是否为谜题中的初始值之一。如果你这样做，尽管你需要覆盖WHICH并使其返回Cell的Integer值。只要你在这种情况下身体检查技术无效（两个不同的CellValues可能具有相同的值，但不会是同一个对象），那么你可以将它们放入集合中。</p>
</div>
<div class="paragraph">
<p>我希望你已经发现了这个有趣的东西，Junctions和Sets是Raku的许多不同部分中的两个，它们可以帮助你轻松完成复杂的任务。如果您对代码感兴趣，可以使用以下基于对象的版本进行安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install Game::Sudoku</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十二天_raku_d_的特性">20. <a href="https://rakuadvent.wordpress.com/2017/12/22/day-22-features-of-perl-6-d/">第二十二天-Raku.d 的特性</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>所以我们就是这样。 Rakudo Raku第一次正式发布两年后，或者更准确的说是6.c。自从马特奥茨从那时起就开始关注性能的提升之后，圣诞老人认为要对此进行对比，描述自那时起实施的6.d的新功能。因为有很多，圣诞老人不得不做出选择。</p>
</div>
<div class="sect2">
<h3 id="_在创建时调整对象">20.1. 在创建时调整对象</h3>
<div class="paragraph">
<p>您创建的任何课程现在都可以使用TWEAK方法。在新的类的新实例的所有其他初始化完成之前，这个方法将被调用。一个简单的，有点人为的例子，其中一个类A有一个属性，默认值是42，但如果在创建对象时指定了默认值，它应该更改该值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    has $.value = 42;
    method TWEAK(:$value = 0) { # default prevents warning
        # change the attribute if the default value is specified
        $!value = 666 if $value == $!value;
    }
}
# no value specified, it gets the default attribute value
dd A.new;              # A.new(value =&gt; 42)

# value specified, but it is not the default
dd A.new(value =&gt; 77); # A.new(value =&gt; 77)

# value specified, and it is the default
dd A.new(value =&gt; 42); # A.new(value =&gt; 666)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_并发性改进">20.2. 并发性改进</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Rakudo Raku的并发功能在引擎盖下看到了许多改进。其中一些暴露为新功能。最显着的是Lock </dt>
<dd>
<p>Async（一个返回Promise的非阻塞锁）和原子操作符。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在大多数情况下，您不需要直接使用它们，但是如果您正在编写使用并发功能的程序，那么您可能知道原子操作符。经常发生的逻辑错误，特别是如果你在Pumpking Perl 5中使用线程，是因为在Rakudo Raku中没有对共享变量的隐式锁定。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my int $a;
    await (^5).map: {
        start { ++$a for ^100000 }
    }
    say $a; # something like 419318</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么为什么没有显示500000？原因是我们有5个线程同时递增相同的变量。由于增量由读步骤，增量步骤和写步骤组成，因此一个线程与另一个线程同时执行读取步骤变得非常容易。因此失去了一个增量。在我们有原子操作符之前，做上述代码的正确方法是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">   my int $a;
    my $l = Lock.new;
    await (^5).map: {
       start {
           for ^100000 {
               $l.protect( { ++$a } )
           }
       }
    }
    say $a; # 500000</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会给你正确的答案，但速度至少要慢20倍。</p>
</div>
<div class="paragraph">
<p>现在我们有了原子变量，上面的代码就变成了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">   my atomicint $a;
    await (^5).map: {
        start { ++⚛$a for ^100000 }
    }
    say $a; # 500000</code></pre>
</div>
</div>
<div class="paragraph">
<p>这非常类似于原始（不正确）的代码。这至少是使用Lock.protect的正确代码的6倍。</p>
</div>
</div>
<div class="sect2">
<h3 id="_unicode_goodies">20.3. Unicode goodies</h3>
<div class="paragraph">
<p>太多了，太多了。例如，现在可以使用≤，≥，≠作为Unicode版本的⇐，&gt; =和！=（完整列表）。</p>
</div>
<div class="paragraph">
<p>您现在还可以通过指定字形的Unicode名称来创建字形，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;BUTTERFLY&#34;.parse-names; # 🦋</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者在运行时创建Unicode名称字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t = &#34;THUMBS UP SIGN, EMOJI MODIFIER FITZPATRICK TYPE&#34;;
print &#34;$t-$_&#34;.parse-names for 3..6; # 👍🏼👍🏽👍🏾👍🏿</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者整理而不是仅仅排序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># sort by codepoint value
say &lt;ä a o ö&gt;.sort; # (a o ä ö)
# sort using Unicode Collation Algorithm
say &lt;ä a o ö&gt;.collate; # (a ä o ö)</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者使用unicmp而不是cmp：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;a&#34; cmp &#34;Z&#34;; # More
say &#34;a&#34; unicmp &#34;Z&#34;; # Less</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者您现在可以使用任何Unicode数字匹配变量（$ 1为$ 1），负数（-1为-1）和基数基数（：3（“22”）为3（“22”））。</p>
</div>
<div class="paragraph">
<p>圣诞老人认为Rakudo Raku拥有世界上任何编程语言的最佳Unicode支持！</p>
</div>
</div>
<div class="sect2">
<h3 id="_跳过值">20.4. 跳过值</h3>
<div class="paragraph">
<p>您现在可以在Seq和Supply上调用.skip跳过正在生成的多个值。与.head和.tail一起，这给了你Iterables和Supplies充足的操作性。</p>
</div>
<div class="paragraph">
<p>顺便说一下，.head现在也会带一个WhateverCode，所以你可以指明除了最后N以外的所有值（例如.head（*  -  3）会给你除了最后三个以外的所有值）。 .tail也是如此（例如.tail（*  -  3）会为您提供除前三个之外的所有值）。</p>
</div>
<div class="paragraph">
<p>对迭代器角色的一些补充使得迭代器可以更好地支持.skip功能。如果一个迭代器可以更有效地跳过一个值而不是实际产生它，它应该实现skip-one方法。派生于此的是可以由迭代器提供的跳过至少和跳过至少拉一个方法。</p>
</div>
<div class="paragraph">
<p>使用.skip查找第1000个素数的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (^Inf).grep(*.is-prime)[999]; # 7919</code></pre>
</div>
</div>
<div class="paragraph">
<p>与</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (^Inf).grep(*.is-prime).skip(999).head; # 7919</code></pre>
</div>
</div>
<div class="paragraph">
<p>后者的CPU效率略高一些，但更重要的是内存效率更高，因为它不需要保留内存中的前999个素数。</p>
</div>
</div>
<div class="sect2">
<h3 id="_of_bufs_and_blobs">20.5. Of Bufs and Blobs</h3>
<div class="paragraph">
<p>Buf变得更像一个Array，因为它现在支持.push，.append，.pop，.unshift，.prepend，.shift和.splice。它也变得更像Str，增加了一个subbuf-rw（类似于.substr-rw），例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $b = Buf.new(100..105);
$b.subbuf-rw(2,3) = Blob.new(^5);
say $b.perl; # Buf.new(100,101,0,1,2,3,4,105)</code></pre>
</div>
</div>
<div class="paragraph">
<p>您现在也可以使用给定数量的元素和模式来分配Buf或Blob。或者用.reallocate改变Buf的大小：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $b = Buf.allocate(10,(1,2,3));
say $b.perl; # Buf.new(1,2,3,1,2,3,1,2,3,1)
$b.reallocate(5);
say $b.perl; # Buf.new(1,2,3,1,2)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_测试测试测试">20.6. 测试，测试，测试！</h3>
<div class="paragraph">
<p>Test.pm的计划子例程现在还采用可选的：skip-all参数来指示文件中的所有测试都应该跳过。或者您可以拨打救助中止测试运行，将其标记为失败。或者将PERL6_TEST_DIE_ON_FAIL环境变量设置为真值，以指示您希望测试一旦第一次测试失败就立即结束。</p>
</div>
</div>
<div class="sect2">
<h3 id="_这是怎么回事">20.7. 这是怎么回事</h3>
<div class="paragraph">
<p>您现在可以通过调用Kernel.cpu-cores来反思计算机中CPU内核的数量。程序启动后使用的CPU数量在Kernel.cpu-usage中可用，但您可以使用VM.osname轻松检查操作系统的名称。</p>
</div>
<div class="paragraph">
<p>就好像这还不够，还有一个新的遥测模块，您需要在需要时加载，就像测试模块一样。遥测模块提供了许多可直接使用的基元，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Telemetry;
say T&lt;wallclock cpu max-rss&gt;; # (138771 280670 82360)</code></pre>
</div>
</div>
<div class="paragraph">
<p>它显示自程序启动以来的微秒数，所用CPU的微秒数以及调用时正在使用的内存数量。</p>
</div>
<div class="paragraph">
<p>如果你想得到你的程序中发生的事情的报告，你可以使用管理单元，并在程序完成时显示报告。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Telemetry;
snap;
Nil for ^10000000;  # something that takes a bit of time</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果将显示在STDERR上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Telemetry Report of Process #60076
Number of Snapshots: 2
Initial/Final Size: 82596 / 83832 Kbytes
Total Time:           0.55 seconds
Total CPU Usage:      0.56 seconds
No supervisor thread has been running

wallclock  util%  max-rss
   549639  12.72     1236
--------- ------ --------
   549639  12.72     1236

Legend:
wallclock  Number of microseconds elapsed
    util%  Percentage of CPU utilization (0..100%)
  max-rss  Maximum resident set size (in Kbytes)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想要每秒1次的程序状态，你可以使用snapper：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Telemetry;
snapper;
Nil for ^10000000;  # something that takes a bit of time</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Telemetry Report of Process #60722
Number of Snapshots: 7
Initial/Final Size: 87324 / 87484 Kbytes
Total Time:           0.56 seconds
Total CPU Usage:      0.57 seconds
No supervisor thread has been running

wallclock  util%  max-rss
   103969  13.21      152
   101175  12.48
   101155  12.48
   104097  12.51
   105242  12.51
    44225  12.51        8
--------- ------ --------
   559863  12.63      160

Legend:
wallclock  Number of microseconds elapsed
    util%  Percentage of CPU utilization (0..100%)
  max-rss  Maximum resident set size (in Kbytes)</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有更多选项可用，例如以.csv格式获取输出。</p>
</div>
</div>
<div class="sect2">
<h3 id="_main_函数">20.8. MAIN 函数</h3>
<div class="paragraph">
<p>您现在可以通过设置％* SUB-MAIN-OPTS中的选项来修改MAIN参数的处理方式。默认的USAGE消息现在可以在MAIN中作为$ * USAGE动态变量使用，所以如果你愿意，你可以改变它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_嵌入_raku">20.9. 嵌入 Raku</h3>
<div class="paragraph">
<p>两个新功能使嵌入Rakudo Raku更易于处理：
现在可以设置＆* EXIT动态变量来指定调用exit（）时要执行的操作。</p>
</div>
<div class="paragraph">
<p>将环境变量RAKUDO_EXCEPTIONS_HANDLER设置为“JSON”将引发JSON中的异常，而不是文本，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ RAKUDO_EXCEPTIONS_HANDLER=JSON raku -e &#39;42 = 666&#39;
{
  &#34;X::Assignment::RO&#34; : {
    &#34;value&#34; : 42,
    &#34;message&#34; : &#34;Cannot modify an immutable Int (42)&#34;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_礼品袋的底部">20.10. 礼品袋的底部</h3>
<div class="paragraph">
<p>在翻看仍然相当完整的礼品袋的同时，圣诞老人发现了以下较小的惊悚片：</p>
</div>
<div class="paragraph">
<p>本地字符串数组现在实现（我的str @a）
IO :: CatHandle允许您将多个数据源抽象为单个虚拟IO :: Handle
parse-base（）执行base（）的相反操作</p>
</div>
</div>
<div class="sect2">
<h3 id="_赶上雪橇的时间">20.11. 赶上雪橇的时间</h3>
<div class="paragraph">
<p>圣诞老人想留下来告诉你更多有关已添加的内容，但是没有足够的时间来做到这一点。如果您真的想了解新功能的最新情况，您应该查看Changelog中的Additions部分，这些部分随每个Rakudo编译器版本一起更新。</p>
</div>
<div class="paragraph">
<p>所以，明年再来抓你！</p>
</div>
<div class="paragraph">
<p>来自美好的祝福</p>
</div>
<div class="paragraph">
<p>🎅🏾</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十三天_raku_高尔夫">21. <a href="https://rakuadvent.wordpress.com/2017/12/23/day-23-the-wonders-of-raku-golf/">第二十三天-Raku 高尔夫</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>啊，圣诞节！还有什么比和你的朋友与家人一起坐在桌子旁边玩高尔夫球代码还好呢！ …​等等，什么？</p>
</div>
<div class="paragraph">
<p>哦，对，这还不是圣诞节。但是你可能想要为它做好准备！</p>
</div>
<div class="paragraph">
<p>如果你还没有注意到，有一个不错的网站可以玩高尔夫球代码：<a href="https://code-golf.io/">https://code-golf.io/</a>。这个网站很酷的地方是，它不仅仅只支持 perl 6！在撰写本文时，它还支持其他 6 种语言。嗯…​</p>
</div>
<div class="paragraph">
<p>无论如何，因为我在那个网站的成绩还不错，我会分享一些我觉得最好的解决方案。所有的 trickety-hackety，unicode-cheatery 和 mind-blowety。在我们看来，也许我们甚至会看到即使在代码高尔夫中，perl 6 也非常<a href="https://raw.githubusercontent.com/raku/marketing/master/TablePosters/6lang-Concise/v1—​6lang-Concise—​square.png">简洁</a>易读。也就是说，如果你很难将你的圣诞愿望放在一张卡片上，那么可能会放得下一行 perl 6 代码。</p>
</div>
<div class="paragraph">
<p>我不会提供完整的解决方案，不会破坏你的圣诞乐趣，但我会给你足够的提示，以提出有竞争力的解决方案。</p>
</div>
<div class="paragraph">
<p>这个圣诞节我就是想让你得到一些乐趣。所以你先下载一份 <a href="https://raku.org/downloads/">rakudo</a>，以确保你可以跟随。稍后我们会有一些南瓜派，我们会<a href="https://www.youtube.com/watch?v=Y51JyG7M3dw#t=26s">做一些颂歌</a>。如果您在运行 perl 6 时遇到任何问题，可以在 freenode 上加入 <a href="https://docs.raku.org/webchat.html">＃raku 频道</a>以获得一些帮助。这就是说，<a href="https://code-golf.io/">https://code-golf.io/</a> 本身为你提供了一个很好的编辑器来编写和评估你的代码，所以应该没有问题。</p>
</div>
<div class="sect2">
<h3 id="_一些基本的例子">21.1. 一些基本的例子</h3>
<div class="paragraph">
<p>让我们以<a href="https://code-golf.io/pascals-triangle">帕斯卡三角形</a>任务为例。我听到了，我听到了！圣诞节前的数学，这太残酷了。残忍，但很有必要。</p>
</div>
<div class="paragraph">
<p>只有一个你必须知道的基本技巧。如果从 Pascal 三角形中取出任何一行，将它移动一个元素，然后用原始行对结果进行 zip-sum，就会得到下一行！</p>
</div>
<div class="paragraph">
<p>所以如果你有一行数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">1 3 3 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>你所做的只是把它移到右边：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">0 1 3 3 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>并将其与原始行相加：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">1 3 3 1
+ + + +
0 1 3 3 1
=
1 4 6 4 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>就是如此容易！所以我们还是写代码吧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for ^16 { put (+combinations($^row,$_) for 0..$row) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>你看！简单的很！</p>
</div>
<div class="paragraph">
<p>哦…​…​等等，这有一个完全不同的解决方案。好吧，让我们来看看：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.put for 1, { |$_,0 Z+ 0,|$_ } ... 16</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
1 6 15 20 15 6 1
1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1
1 9 36 84 126 126 84 36 9 1
1 10 45 120 210 252 210 120 45 10 1
1 11 55 165 330 462 462 330 165 55 11 1
1 12 66 220 495 792 924 792 495 220 66 12 1
1 13 78 286 715 1287 1716 1716 1287 715 286 78 13 1
1 14 91 364 1001 2002 3003 3432 3003 2002 1001 364 91 14 1
1 15 105 455 1365 3003 5005 6435 6435 5005 3003 1365 455 105 15 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>啊哈！ 我们做到了。 所以究竟是怎么回事儿？ 那么，在 perl 6 中，你可以用一个非常简单的语法创建 <code>2,4,8 …​ ∞</code> 这样的序列。 通常你会让它自己计算序列，但你也可以提供一个代码块来求值。 这太棒了！ 在其他语言中，你经常需要一个带有状态变量的循环，而序列操作符为你做了所有的事情！ 这个功能可能单独需要一篇<a href="https://raku.party/post/Perl-6-Seqs-Drugs-and-Rock-n-Roll">文章</a>或<a href="https://raku.party/post/Perl-6-Seqs-Drugs-and-Rock-n-Roll—​Part-2">𝍪</a>。</p>
</div>
<div class="paragraph">
<p>其余的只是一个 for 循环和 <a href="https://docs.raku.org/routine/put">put</a> 调用。 这里唯一的技巧就是理解它使用的是列表，所以当你指定序列的端点时，它实际上是检查元素的数量。 另外，您需要用 <code>|</code> 来展平列表。</p>
</div>
<div class="paragraph">
<p>如果删除空格并应用本文中提到的所有技巧，这应该会让您的字符数为 26。 这相当有竞争力。</p>
</div>
<div class="paragraph">
<p>同样，其他任务通常有相当直接的解决方案。 例如，对于 <a href="https://code-golf.io/evil-numbers">Evil NUmbers</a>，你可以写这样的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.base(2).comb(~1) %% 2 &amp;&amp; .say for ^50</code></pre>
</div>
</div>
<div class="paragraph">
<p>删除一些空格，应用一些技巧，你几乎就达到要求了。</p>
</div>
<div class="paragraph">
<p>我们再举一个例子：<a href="https://code-golf.io/pangram-grep">Pangram Grep</a>。在这里我们可以使用 <a href="https://docs.raku.org/language/setbagmix">set操作符</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">‘a’..‘z’ ⊆ .lc.comb &amp;&amp; .say for @*ARGS</code></pre>
</div>
</div>
<div class="paragraph">
<p>基本上，几乎所有的 perl 6 解决方案看起来都是真正的代码。这是额外的-1角色，需要额外的眼睛疼痛，但你没有来这里听简洁，对吧？是时候变脏了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_numbers">21.2. Numbers</h3>
<div class="paragraph">
<p>让我们来谈谈数字吧！ 1 ² ③ ٤ ⅴ ߆…  <strong>咳嗽</strong>。 你看，在 perl 6 中，任何数字字符（具有相应的数值属性）都可以在源代码中使用。 该功能的目的是让我们得到一些好处，如 ½ 和其他整洁的东西，但这意味着，而不是写 50 你可以写 ㊿。 有些高尔夫平台会以 UTF-8 编码来计算字节数，所以看起来你没有赢得任何东西。 但是 <code>1000000000000</code> 和 ` 𖭡` 呢？ 在任何情况下，<a href="https://code-golf.io/">code-golf.io</a> 都可以识别 unicode，所以这些字符的长度都是 1。</p>
</div>
<div class="paragraph">
<p>所以你可能会想，你能用这种方式写出哪些数字？ 你试试看：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">-0.5 0.00625 0.025 0.0375 0.05 0.0625 0.083333 0.1
0.111111 0.125 0.142857 0.15 0.166667 0.1875 0.2
0.25 0.333333 0.375 0.4 0.416667 0.5 0.583333 0.6
0.625 0.666667 0.75 0.8 0.833333 0.875 0.916667 1
1.5 2 2.5 3 3.5 4 4.5 5 5.5 6 6.5 7 7.5 8 8.5 9 10
11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27
28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44
45 46 47 48 49 50 60 70 80 90 100 200 300 400 500
600 700 800 900 1000 2000 3000 4000 5000 6000 7000
8000 9000 10000 20000 30000 40000 50000 60000 70000
80000 90000 100000 200000 216000 300000 400000
432000 500000 600000 700000 800000 900000 1000000
100000000 10000000000 1000000000000</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着，例如，在某些情况下，如果需要否定结果，则可以节省 1 个字符。有很多方法可以使用，我只会提到一个特定的情况。其余的你自己去找，以及如何找到可用于任何特定值的实际字符（提示：循环所有 0x10FFFF 字符并检查它们的 `.unival`s）。</p>
</div>
<div class="paragraph">
<p>例如，当打高尔夫时，你想略去不必要的空白，所以也许你会想写一些这样的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 5max3  # ERROR</code></pre>
</div>
</div>
<div class="paragraph">
<p>这当然不起作用，我们也不能责怪编译器没有解决这个混乱问题。但是，试试这个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ⑤max③  # OUTPUT: «5␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>哇噢！这在许多其他情况下会起作用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_条件">21.3. 条件</h3>
<div class="paragraph">
<p>如果有很好的高尔夫语言，但不是 Raku. 我的意思是，看看这个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">puts 10&lt;30?1:2   # ruby</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 &lt;30??1!!2 # perl 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 的三元操作符不仅多需要俩个字符，而且 <code>&lt;</code> 运算符周围还要有一些必要的的空白字符！他们有什么问题，对吧？他们怎么敢设计一种无代码高尔夫语言?!</p>
</div>
<div class="paragraph">
<p>那么，我们可以通过某些方法解决它。其中之一是链式操作符。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 5&gt;3&gt;say(42)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 5≤3，则不需要进行其他比较，因此它不会运行它。这样我们可以节省至少一个字符。在略有相关的说明中，请记住，junctions 也可能派上用场：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ‘yes!’ if 5==3|5</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，不要忘记 unicode 操作符：<code>≥</code>，<code>≤</code>，<code>≠</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_打字很难让我们使用一些预定义的字符串">21.4. 打字很难，让我们使用一些预定义的字符串！</h3>
<div class="paragraph">
<p>你不会相信这有时是多么的有用。想要打印所有棋子的名字？好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (‘♔’…‘♙’)».uniname».words»[2]
#   KING QUEEN ROOK BISHOP KNIGHT PAWN</code></pre>
</div>
</div>
<div class="paragraph">
<p>这仅仅节省了几个字符，但有时可以将解决方案的大小减半。但是，不要停在那里，想想错误消息，方法名称等。你还能挽回什么？</p>
</div>
</div>
<div class="sect2">
<h3 id="_base_16_base_36_nah_base_0x10ffff">21.5. Base 16? Base 36? Nah, Base 0x10FFFF!</h3>
<div class="paragraph">
<p><a href="https://code-golf.io/φ">其中一项任务</a>告诉我们打印 φ 的前1000个小数位。那么，这很容易！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ‘1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374847540880753868917521266338622235369317931800607667263544333890865959395829056383226613199282902678806752087668925017116962070322210432162695486262963136144381497587012203408058879544547492461856953648644492410443207713449470495658467885098743394422125448770664780915884607499887124007652170575179788341662562494075890697040002812104276217711177780531531714101170466659914669798731761356006708748071013179523689427521948435305678300228785699782977834784587822891109762500302696156170025046433824377648610283831268330372429267526311653392473167111211588186385133162038400522216579128667529465490681131715993432359734949850904094762132229810172610705961164562990981629055520852479035240602017279974717534277759277862561943208275051312181562855122248093947123414517022373580577278616008688382952304592647878017889921990270776903895321968198615143780314997411069260886742962267575605231727775203536139362’</code></pre>
</div>
</div>
<div class="paragraph">
<p>是的！！！</p>
</div>
<div class="paragraph">
<p>好吧，这需要 1000 多个字符…​…​当然，我们可以尝试计算它，但这不完全符合<a href="https://rakuadvent.wordpress.com/2017/12/01/">圣诞节的精神</a>。我们想作弊。</p>
</div>
<div class="paragraph">
<p>如果我们看一下 <a href="https://docs.raku.org/type/Int#method_polymod">polymod</a> 的文档，有一点提示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @digits-in-base37 = 9123607.polymod(37 xx *); # Base conversion</code></pre>
</div>
</div>
<div class="paragraph">
<p>嗯…​…​这样就给了我们任意数量的数字。我们可以走多高？那么，这取决于我们想要存储数字的形式。鉴于 code-golf.io 计算码位，我们可以使用base 0x10FFFF（即使用所有可用的码位）。或者，在这种情况下，我们将使用base 0x10FFFE，<a href="https://docs.raku.org/language/traps#All_Text_is_Normalized_By_Default">因为</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">☠☠☠⚠⚠⚠ WARNING! WARNING! WARNING! ⚠⚠⚠☠☠☠
THIS WILL MAKE YOUR COMPUTER IMPLODE!
UNICODE STRINGS ARE SUBJECT TO NORMALIZATION SO YOUR
DATA WILL NOT BE PRESERVED. HIDE YOUR KIDS, HIDE YOUR
WIFE. HIDE YOUR KIDS, HIDE YOUR WIFE. HIDE YOUR KIDS,
HIDE YOUR WIFE. AND HIDE YOUR HUSBAND.
☠☠☠⚠⚠⚠ WARNING! WARNING! WARNING! ⚠⚠⚠☠☠☠</code></pre>
</div>
</div>
<div class="paragraph">
<p>当应用于我们的常数时，它应该给出这样的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">󻁾񤍠򷒋󜹕󘶸񙦅񨚑򙯬񗈼𢍟𪱷򡀋𢕍򌠐񘦵𔇆򅳒򑠒󌋩򯫞򶝠򚘣򣥨񫵗𿞸􋻩񱷳󟝐󮃞󵹱񿢖𛒕𺬛󊹛󲝂򺗝𭙪񰕺𝧒򊕆𘝞뎛􆃂򊥍񲽤򩻛󂛕磪󡯮끝򰯬󢽈󼿶󘓥򮀓񽑖򗔝󃢖񶡁􁇘󶪼񌍌񛕄񻊺򔴩寡񿜾񿸶򌰘񡇈򦬽𥵑󧨑򕩃򳴪񾖾򌯎󿥐񱛦𱫞𵪶򁇐󑓮򄨠򾎹𛰑𗋨䨀򡒶𰌡򶟫񦲋𧮁􍰍񲍚񰃦𦅂󎓜󸾧󉦩󣲦򄉼񿒣𸖉񿡥󬯞嗟𧽘񿷦򠍍🼟򇋹񖾷𖏕񟡥󜋝􋯱񤄓򭀢򌝓𱀉𫍡󬥝򈘏򞏡񄙍𪏸࿹𺐅񢻳򘮇𐂇񘚡ந򾩴󜆵𰑕򰏷񛉿򢑬򭕴𨬎󴈂􋵔򆀍񖨸􂳚󽡂󎖪񡉽񕧣񎗎򝤉򡔙񆔈󖾩󅾜񋩟򝼤񯓦󐚉񟯶򄠔𦔏򲔐o</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们如何翻转操作？在其中一次 <a href="https://github.com/rakudo/rakudo/wiki/Monthly-Bug-Squash-Day">squashathons</a> 我找到一张关于我以前不知道的功能的票。基本上，票据说 Rakudo 正在做它不应该做的事情，这当然是我们下一次会被滥用的事情。但现在我们处于相对理智的范围之内：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ‘1.’,:1114110[‘o򲔐𦔏򄠔񟯶󐚉񯓦򝼤񋩟󅾜󖾩񆔈򡔙򝤉񎗎񕧣񡉽󎖪󽡂􂳚񖨸򆀍􋵔󴈂𨬎򭕴򢑬񛉿򰏷𰑕󜆵򾩴ந񘚡𐂇򘮇񢻳𺐅࿹𪏸񄙍򞏡򈘏󬥝𫍡𱀉򌝓򭀢񤄓􋯱󜋝񟡥𖏕񖾷򇋹🼟򠍍񿷦𧽘嗟󬯞񿡥𸖉񿒣򄉼󣲦󉦩󸾧󎓜𦅂񰃦񲍚􍰍𧮁񦲋򶟫𰌡򡒶䨀𗋨𛰑򾎹򄨠󑓮򁇐𵪶𱫞񱛦󿥐򌯎񾖾򳴪򕩃󧨑𥵑򦬽񡇈򌰘񿸶񿜾寡򔴩񻊺񛕄񌍌󶪼􁇘񶡁󃢖򗔝񽑖򮀓󘓥󼿶󢽈򰯬끝󡯮磪󂛕򩻛񲽤򊥍􆃂뎛𘝞򊕆𝧒񰕺𭙪򺗝󲝂󊹛𺬛𛒕񿢖󵹱󮃞󟝐񱷳􋻩𿞸񫵗򣥨򚘣򶝠򯫞󌋩򑠒򅳒𔇆񘦵򌠐𢕍򡀋𪱷𢍟񗈼򙯬񨚑񙦅󘶸󜹕򷒋񤍠󻁾’.ords]</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，字符串必须相反。除此之外，它看起来非常好。 192 个字符包括解码器。</p>
</div>
<div class="paragraph">
<p>这对于打印另外可计算的常量来说并不是一个好主意，但考虑到解码器的长度和数据的相对密集的打包率，这在其他任务中很方便。</p>
</div>
</div>
<div class="sect2">
<h3 id="_所有的好事都必须结束可怕的事情_更是如此">21.6. 所有的好事都必须结束;可怕的事情 - 更是如此</h3>
<div class="paragraph">
<p>这是关于这篇文章的。更多代码高尔夫技巧我已经启动了这个存储库：<a href="https://github.com/AlexDaniel/6lang-golf-cheatsheet">https://github.com/AlexDaniel/6lang-golf-cheatsheet</a></p>
</div>
<div class="paragraph">
<p>希望能在 <a href="https://code-golf.io/">https://code-golf.io/</a> 上看到你！无论是否使用 perl 6，我都希望看到我提交的所有内容都被打败了。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十四天_解魔方">22. <a href="https://rakuadvent.wordpress.com/2017/12/24/">第二十四天-解魔方</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_介绍_2">22.1. 介绍</h3>
<div class="paragraph">
<p>我在圣诞节的愿望清单上有一个速度魔方，我真的很兴奋。 :)我想分享一些Raku代码的热情。</p>
</div>
<div class="paragraph">
<p>我在89年从高中毕业，所以我恰好是在青少年时期拥有魔方的合适年龄。我记得试图在巴士上炫耀，让我的时间缩短到不到一分钟。我在80年代从当地的一家玩具店拿到了一本小册子，其中展示了一个关于如何解决我记忆的立方体的算法。我再也没有这本小册子了。多年来我一直坚持，但从来没有达到竞争水平。</p>
</div>
<div class="paragraph">
<p>在过去的几个月里，YouTube根据我对立体声频道的兴趣，向我推荐了一些立方体视频;看到世界纪录在5秒以内，使我一分钟的旧时间看起来很慢。</p>
</div>
<div class="paragraph">
<p>我所讲过的每个人都可以解决魔方问题，他们使用的算法与我所学的算法不同，而在立体魔法中讨论的方法却与众不同。不过，这种先进的版本似乎被定期制定世界记录的人们普遍使用。</p>
</div>
<div class="paragraph">
<p>拾取这个算法并不难，我找到了几个视频，尤其是描述如何解决最后一层的视频。这样做了几天之后，我将步骤转录为几个笔记，其中列出了步骤列表，以及每个步骤的关键部分：所需的方向，然后是该步骤的各个转弯。然后，我可以参考我的笔记本的一个页面，而不是一个30分钟的视频，并且在几天后，记住了以下步骤：能够从记谱法移动到仅仅做这些移动是一个很大的加速。</p>
</div>
<div class="paragraph">
<p>一周后，我能够在两分钟内使用新方法可靠地解决问题;退后一步，但在休息时间里一周的努力并不坏。从那以后（几个星期后），我一直下到1:20以下。再次，这是初学者的方法，没有任何先进的技术，而且我可以在不查看立方体的情况下完成各个算法步骤。 （尽管如此，我仍然有很长的路要走。）</p>
</div>
</div>
<div class="sect2">
<h3 id="_符号">22.2. 符号</h3>
<div class="paragraph">
<p>关于移动符号的快速注释 - 考虑到您将立方体的一边保持在顶部，一边朝向您，相对边是：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>L (Left) R (Right) U (Up) D (Down) F (Front) B (Back)</pre>
</div>
</div>
<div class="paragraph">
<p>如果在步骤中看到一个单独的字母，如B，则表示顺时针转动该面（相对于立方体的中心，而不是您）。如果你在信里加了一个&#39;&#39;，那就意味着逆时针方向，所以R’会让最上面的部分下来，而R会让底部的部分出现。</p>
</div>
<div class="paragraph">
<p>此外，您可能必须翻转两次，写成U2; （顺时针或逆时针无关紧要，因为它从起点开始为180º。）</p>
</div>
</div>
<div class="sect2">
<h3 id="_算法">22.3. 算法</h3>
<div class="paragraph">
<p>我正在使用的初学者算法有以下基本步骤：</p>
</div>
<div class="paragraph">
<p>1.白色十字架2.白色拐角3.第二层4.黄色十字架5.黄色边缘6.黄色拐角7.定位黄色拐角</p>
</div>
<div class="paragraph">
<p>如果您对每个步骤的具体内容感到好奇，您可以浏览Rubik的wiki或上面链接的YouTube视频。该算法的更高级版本（由Jessica Fridrich提供的CFOP）允许您合并步骤，具有处理特定立方体状态的特定“快捷方式”，或者解决任何颜色作为第一面，而不仅仅是白色。</p>
</div>
</div>
<div class="sect2">
<h3 id="_设计一个模块">22.4. 设计一个模块</h3>
<div class="paragraph">
<p>当我开始研究这个模块时，我知道我希望能够以某种熟悉算法的人熟悉的方式展示每一步所需的位置，并且让各个步骤也是自然的，就像是：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>F.R.U.Rʼ.Uʼ.Fʼ</pre>
</div>
</div>
<div class="paragraph">
<p>我也希望能够转储立方体的现有状态;现在作为文本，但最终也能够将其与视觉表示相结合，</p>
</div>
<div class="paragraph">
<p>我们需要能够判断立方体是否已解决;我们需要能够检查相对于当前方向的棋子，并且能够改变我们的方向。</p>
</div>
<div class="paragraph">
<p>由于我要开始渲染立方体状态的能力，然后快速添加转向两侧的能力，我选择了一个内部结构，使其变得相当容易。</p>
</div>
</div>
<div class="sect2">
<h3 id="_代码">22.5. 代码</h3>
<div class="paragraph">
<p>github上提供了该模块的最新版本。这里介绍的代码来自最初的版本。</p>
</div>
<div class="paragraph">
<p>Raku允许您创建Enumerations，因此您可以在代码中使用实际的单词而不是查找值，所以让我们从一些我们需要的内容开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Side «:Up(&#39;U&#39;) :Down(&#39;D&#39;) :Front(&#39;F&#39;) :Back(&#39;B&#39;) :Left(&#39;L&#39;) :Right(&#39;R&#39;)»;
enum Colors «:Red(&#39;R&#39;) :Green(&#39;G&#39;) :Blue(&#39;B&#39;) :Yellow(&#39;Y&#39;) :White(&#39;W&#39;) :Orange(&#39;O&#39;)»;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这个语法，我们可以直接在我们的代码中使用Up，并且它的关联值是U.</p>
</div>
<div class="paragraph">
<p>我们需要一个类，以便我们可以存储属性并拥有方法，所以我们的类定义具有：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Cube::Three {
    has %!Sides;
    ...
    submethod BUILD() {
        %!Sides{Up}    = [White  xx 9];
        %!Sides{Front} = [Red    xx 9];
        ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们有一个属性，一个叫做％.Sides的Hash;每个键对应于其中一个Enum边。该值是Colors的9元素数组。数组上的每个元素对应于立方体上的一个位置。默认情况下，顶部的白色和正面的红色将在此处显示颜色和单元格位置，并带有数字和颜色。 （白色，红色是前面）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">         W0 W1 W2
         W3 W4 W5
         W6 W7 W8
G2 G5 G8 R2 R5 R8 B2 B5 B8 O2 O5 O8
G1 G4 G7 R1 R4 R7 B1 B4 B7 O1 O4 O7
G0 G3 G6 R0 R3 R6 B0 B3 B6 B0 B3 B6
         Y0 Y1 Y2
         Y3 Y4 Y5
         Y6 Y7 Y8</code></pre>
</div>
</div>
<div class="paragraph">
<p>我添加的第一种方法是做每个脸部顺时针转动。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method F {
    self!rotate-clockwise(Front);
    self!fixup-sides([
        Pair.new(Up,    [6,7,8]),
        Pair.new(Right, [2,1,0]),
        Pair.new(Down,  [2,1,0]),
        Pair.new(Left,  [6,7,8]),
    ]);
    self;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个公共方法调用两个私有方法（用！表示）;一个顺时针方向旋转一个侧面，第二个取对的列表，其中键是一个侧面，并且该值是一个位置列表。如果您想象顺时针旋转立方体的顶部，您可以看到位置正在从一个换成另一个。</p>
</div>
<div class="paragraph">
<p>请注意，我们从方法中返回自己;这允许我们按照原始设计中的方式调用方法调用。</p>
</div>
<div class="paragraph">
<p>单面的顺时针旋转显示正在传递的原始面，并使用阵列切片来改变原始面的顺序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># 0 1 2    6 3 0
# 3 4 5 -&gt; 7 4 1
# 6 7 8    8 5 2
method !rotate-clockwise(Side \side) {
    %!Sides{side}[0,1,2,3,5,6,7,8] = %!Sides{side}[6,3,0,7,1,8,5,2];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要为移动添加其余的符号，我们添加一些简单的包装方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method F2 { self.F.F; }
method Fʼ { self.F.F.F; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>F2只需要移动两次; F’作弊：3个权利左转。</p>
</div>
<div class="paragraph">
<p>在这一点上，我必须确保我的回合正在做他们应该做的事情，所以我添加了一个gist方法（当一个对象用say输出时被调用）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Cube::Three.new.U2.D2.F2.B2.R2.L2;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">      W Y W
      Y W Y
      W Y W
G B G R O R B G B O R O
B G B O R O G B G R O R
G B G R O R B G B O R O
      Y W Y
      W Y W
      Y W Y</code></pre>
</div>
</div>
<div class="paragraph">
<p>gist 的源代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method gist {
    my $result;
    $result = %!Sides{Up}.rotor(3).join(&#34;\n&#34;).indent(6);
    $result ~= &#34;\n&#34;;

    for 2,1,0 -&gt; $row {
        for (Left, Front, Right, Back) -&gt; $side {
            my @slice = (0,3,6) &gt;&gt;+&gt;&gt; $row;
            $result ~= ~%!Sides{$side}[@slice].join(&#39; &#39;) ~ &#39; &#39;;
        }
        $result ~= &#34;\n&#34;;
    }
    $result ~= %!Sides{Down}.rotor(3).join(&#34;\n&#34;).indent(6);
    $result;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有几件事要注意：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用.rotor（3）将9单元阵列分解为3个3单元列表。</p>
</li>
<li>
<p>.indent（6）预先在Up和Down两边加上空格。</p>
</li>
<li>
<p>（0,3,6）&gt;&gt; + &gt;&gt; $ row，这会增加列表中的每个值</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个要点非常适合逐步检查，但为了调试，我们需要一些更紧凑的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method dump {
    gather for (Up, Front, Right, Back, Left, Down) -&gt; $side {
        take %!Sides{$side}.join(&#39;&#39;);
    }.join(&#39;|&#39;);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将按照特定的顺序在边上迭代，然后使用gather take语法收集每一边的字符串表示形式，然后使用|将它们连接在一起。现在我们可以编写像：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Test; use Cube::Three;
my $a = Cube::Three.new();
is $a.R.U2.Rʼ.Uʼ.R.Uʼ.Rʼ.Lʼ.U2.L.U.Lʼ.U.L.dump,
    &#39;WWBWWWWWB|RRRRRRRRW|BBRBBBBBO|OOWOOOOOO|GGGGGGGGG|YYYYYYYYY&#39;,
    &#39;corners rotation&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这实际上是算法最后一步中使用的方法。通过这个调试输出，我可以拍摄一个原始的立方体，自己动手，然后将生成的立方体状态快速转录成字符串进行测试。</p>
</div>
<div class="paragraph">
<p>虽然计算机不一定需要旋转立方体，但如果我们可以旋转立方体，则会更容易遵循该算法，因此我们为六个可能的旋转中的每一个添加一个，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method rotate-F-U {
     self!rotate-clockwise(Right);
     self!rotate-counter-clockwise(Left);

     # In addition to moving the side data, have to
     # re-orient the indices to match the new side.
     my $temp = %!Sides{Up};
     %!Sides{Up}    = %!Sides{Front};
     self!rotate-counter-clockwise(Up);
     %!Sides{Front} = %!Sides{Down};
     self!rotate-clockwise(Front);
     %!Sides{Down}  = %!Sides{Back};
     self!rotate-clockwise(Down);
     %!Sides{Back}  = $temp;
     self!rotate-counter-clockwise(Back);
     self;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们将立方体从正面转到向上时，我们将左侧和右侧旋转到位。由于细胞的方向随着我们改变面部而改变，因为我们从面部到面部复制细胞，我们也可能需要旋转它们以确保它们最终以正确的方向朝向。和以前一样，我们返回自我以允许方法链接。</p>
</div>
<div class="paragraph">
<p>在我们开始测试时，我们需要确保我们可以知道何时立方体已解决;我们不关心立方体的方向，所以我们验证中心颜色与脸上的所有其他颜色相匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method solved {
    for (Up, Down, Left, Right, Back, Front) -&gt; $side {
        return False unless
            %!Sides{$side}.all eq %!Sides{$side}[4];
    }
    return True;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于每一侧，我们使用一侧的所有颜色的交界处与中心细胞进行比较（总是位置4）。我们很早就失败了，只有通过所有方面才能成功。</p>
</div>
<div class="paragraph">
<p>接下来，我添加了一种方法来搅乱魔方，所以我们可以考虑实施一种解决方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method scramble {
    my @random = &lt;U D F R B L&gt;.roll(100).squish[^10];
    for @random -&gt; $method {
        my $actual = $method ~ (&#34;&#34;, &#34;2&#34;, &#34;ʼ&#34;).pick(1);
        self.&#34;$actual&#34;();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这需要六个基本方法名称，挑选一堆随机值，然后挤压它们（确保连续没有模糊），然后选取前10个值。然后，我们可能会添加一个2或&#39;。最后，我们使用间接方法语法按名称调用各个方法。</p>
</div>
<div class="paragraph">
<p>最后，我准备好开始解决问题了！这就是事情变得复杂的地方。初学者方法的第一步经常被描述为直观的。这意味着它很容易解释…​…​但不容易编码。所以，扰流警报，截至本文发布时，解决的第一步就完成了。对于第一步的完整算法，请查看链接的github网站。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method solve {
    self.solve-top-cross;
}

method solve-top-cross {
    sub completed {
        %!Sides{Up}[1,3,5,7].all eq &#39;W&#39; &amp;&amp;
        %!Sides{Front}[5] eq &#39;R&#39; &amp;&amp;
        %!Sides{Right}[5] eq &#39;B&#39; &amp;&amp;
        %!Sides{Back}[5]  eq &#39;O&#39; &amp;&amp;
        %!Sides{Left}[5]  eq &#39;G&#39;;
    }
    ...
    MAIN:
    while !completed() {
        # Move white-edged pieces in second row up to top

        # Move incorrectly placed pieces in the top row to the middle

        # Move pieces from the bottom to the top
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意非常具体的检查，看看我们是否完成;我们使用一个词汇子来弥补复杂性 - 虽然我们在这里有一个相当内部的检查，但是我们可以看到，我们可能想要将这个抽象描述为可以说“这个边缘部分是正确的”。首先，我们将坚持单个单元格。</p>
</div>
<div class="paragraph">
<p>目前解决十字架的内容长达100多行，所以我不会经历所有的步骤。这是“简单”部分</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @middle-edges =
    [Front, Right],
    [Right, Back],
    [Back,  Left],
    [Left,  Front],
;

for @middle-edges -&gt; $edge {
    my $side7 = $edge[0];
    my $side1 = $edge[1];
    my $color7 = %!Sides{$side7}[7];
    my $color1 = %!Sides{$side1}[1];
    if $color7 eq &#39;W&#39; {
        # find number of times we need to rotate the top:
        my $turns = (
            @ordered-sides.first($side1, :k) -
            @ordered-sides.first(%expected-sides{~$color1}, :k)
        ) % 4;
        self.U for 1..$turns;
        self.&#34;$side1&#34;();
        self.Uʼ for 1..$turns;
        next MAIN;
    } elsif $color1 eq &#39;W&#39; {
        my $turns = (
            @ordered-sides.first($side7, :k) -
            @ordered-sides.first(%expected-sides{~$color7}, :k)
        ) % 4;
        self.Uʼ for 1..$turns;
        self.&#34;$side1&#34;();
        self.U for 1..$turns;
        next MAIN;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在真正的立方体上进行这一部分时，您可以旋转立方体而不考虑侧面部件，然后将十字架放在适当位置。为了让算法更“友好”一点，我们让这些中心保持在这个位置;我们将上侧旋转到位，然后将单个侧面旋转到顶部位置，然后将上侧旋转回原始位置。</p>
</div>
<div class="paragraph">
<p>这里有一些有趣的代码是.first（…​，：k）语法，它说找到匹配的第一个元素，然后返回匹配的位置。然后，我们可以在有序列表中查找事物，以便计算双方的相对位置。</p>
</div>
<div class="paragraph">
<p>请注意，解决方法只调用公共方法来转动立方体;虽然我们使用原始自省来获取立方体状态，但我们只使用“合法”的方式来解决问题。</p>
</div>
<div class="paragraph">
<p>有了这个方法的完整版本，我们现在用这个程序来解决白十字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use Cube::Three;
my $cube = Cube::Three.new();
$cube.scramble;
say $cube;
say &#39;&#39;;
$cube.solve;
say $cube;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它在给定这组移动的情况下产生这个输出（F’B2B2LR’U’RF’D2B2）。首先是争夺战，然后是解决白十字的版本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">    W G G
      Y W W
      Y Y Y
O O B R R R G B O Y Y B
R G O B R R G B G W O B
Y B B R O W G G G W W O
      W W O
      Y Y O
      B R R

      Y W W
      W W W
      G W R
O G W O R Y B B G R O G
Y G G R R B R B Y R O G
O O R Y O W O O R W Y B
      G G B
      B Y Y
      Y B B</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个例子打印出用来进行争夺的动作，显示乱数立方体，“解决”这个难题（在撰写本文时，它只是白色的十字），然后打印出立方体的新状态。</p>
</div>
<div class="paragraph">
<p>请注意，随着我们的进一步发展，这些步骤变得不那么“直观”，并且根据我的估计，编码更容易。例如，最后一步需要检查四个部分的方向，必要时旋转立方体，然后执行14步移动。 （在上面的测试中显示）。</p>
</div>
<div class="paragraph">
<p>希望我对Cubing和Raku的喜爱让你期待你的下一个项目！</p>
</div>
<div class="paragraph">
<p>对于未来的读者，我将在模块解决完成后的评论中注明。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十五天_圣诞奖金_并发http服务器实施和scripter的方法">23. <a href="https://rakuadvent.wordpress.com/2017/12/25/bonus-xmas-concurrent-http-server-implementation-and-the-scripters-approach/">第二十五天-圣诞奖金 - 并发HTTP服务器实施和scripter的方法</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>首先，我想强调 <a href="http://www.jnthn.net/">Jonathan Worthington</a> 在 <a href="http://rakudo.org/">Rakudo Raku</a> 和 <a href="https://docs.raku.org/type/IO::Socket::Async">IO::Socket::Async</a> 中的工作。谢谢 Jon！</p>
</div>
<div class="paragraph">
<p>我喜欢制作脚本;编写组织良好的动作序列，<strong>获得结果</strong>并对它们进行<strong>处理</strong>。</p>
</div>
<div class="paragraph">
<p>当我从 Raku 开始时，我发现了一个壮观的生态系统，我可以<strong>按照自己喜欢的方式</strong>实践我的想法：<strong>脚本方式</strong>。其中一个想法是实现一个小型的 HTTP 服务器来玩玩。查看与 <strong>Raku</strong>，HTTP 和套接字相关的其他项目和模块，我发现背后的作者是具有<strong>面向对象</strong>编程经验的程序员。</p>
</div>
<div class="sect2">
<h3 id="_raku_范式">23.1. Raku 范式</h3>
<div class="paragraph">
<p>Raku 支持三种最流行的编程范式:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>面向对象</p>
</li>
<li>
<p>函数式</p>
</li>
<li>
<p>过程式</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我认为，当你设计一个<strong>将会增长</strong>的应用程序或服务时，<strong>面向对象</strong>的范式是很好的，它会做许多<strong>不同的事情</strong>并且会有<strong>很多变化</strong>。但我不喜欢那些变化太大，会有很多变化的东西;这就是为什么我喜欢使用原生过程式方法的脚本，因为它能够<strong>快速提升简单性和有效性</strong>。我喜欢小（一步一步）但能快速完成伟大东西的事物。</p>
</div>
<div class="paragraph">
<p><strong>函数式</strong>范式在我看来非常棒;你可以使用一个函数，并像 var 一样使用它，以及其他令人惊讶的事情。</p>
</div>
</div>
<div class="sect2">
<h3 id="_raku_supplies_就像一个_v12_引擎">23.2. Raku Supplies 就像一个 V12 引擎</h3>
<div class="paragraph">
<p>在我开始将 <a href="http://rakuintro.com/">rakuintro.com</a> 翻译成<a href="http://es.rakuintro.com/">西班牙语</a>后不久，我开始使用 Raku。看看 <strong>Raku</strong> 的文档，我发现了 <strong>Raku</strong> 巨大的<strong>并发</strong>潜力。 Raku在<a href="https://docs.raku.org/language/concurrency">并发方面</a>比我想象的更加强大。</p>
</div>
<div class="paragraph">
<p>我使用 <strong>Raku</strong> 的 HTTP 服务器的思想始于 <a href="https://docs.raku.org/type/Supply">Raku Supplies</a>（具有多个订阅者的异步数据流），具体来说就是 <a href="https://docs.raku.org/type/IO::Socket::Async">IO::Socket::Async</a>类。所有的套接字管理，数据传输和并发性实际上都是<strong>自动</strong>且易于理解的。制作并玩一玩小并发但强大的服务是极好的。</p>
</div>
<div class="paragraph">
<p>基于 <a href="https://docs.raku.org/type/IO::Socket::Async">IO::Socket::Async</a> 文档的示例，我开始在 <a href="https://github.com/ramiroencinas/mini-http-cgi-server">mini-http-cgi-server</a> 项目中实现一个支持 pseudoCGI 的小型 HTTP 服务器，并且按照我的预期工作。当我得到我想要的东西时，我很满意，我离开了这个项目一段时间。我不喜欢事情发展太多。</p>
</div>
<div class="paragraph">
<p>但之后，为马德里 <a href="http://madrid.pm.org/workshop">Perl Workshop 2017</a> 做了一次演讲（感谢<a href="http://madrid.pm.org/">马德里 Perl Mongers</a> 和 <a href="http://barcelona.pm/">巴塞罗那 Perl Mongers</a> 团队为这次活动提供的支持），我有足够的动力去做<strong>更实际的</strong>事情，让网络<strong>前端</strong>编码人员可以完成他们的工作并且与 <strong>Raku正在等待的后端</strong>进行交流。一方面是典型的<strong>公共 html 静态结构</strong>，另一方面是一个包含多个 web 服务的 <strong>Raku</strong> 模块，用于等待来自前端人员的 web 请求。</p>
</div>
<div class="paragraph">
<p>然后 <a href="https://github.com/ramiroencinas/wap6">Wap6</a> 诞生了（Web App Raku）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_wap6_的结构">23.3. Wap6 的结构</h3>
<div class="paragraph">
<p>我喜欢 Wap6 实现的 Web 应用程序的结构：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>public</p>
</li>
<li>
<p>webservices</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>公共</strong>文件夹包含友好的前端东西，比如静态 html，javascript，css 等，也就是<strong>前端</strong>开发者空间。 <strong>webservices</strong> 文件夹包含<strong>后端</strong>的东西：一个 <strong>Raku</strong> 模块，包括每个 webservice 的一个函数。</p>
</div>
<div class="paragraph">
<p>相同的文件夹级别包含解决方案入口点，一个 <strong>Raku</strong> 脚本，其中包括初始化服务器参数，其中包含路由和 webservices 之间的映射：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %webservices =
  &#39;/ws1&#39; =&gt; ( &amp;ws1, &#39;html&#39; ),
  &#39;/ws2&#39; =&gt; ( &amp;ws2, &#39;json&#39; )
;</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你所看到的，不仅路由被映射到相应的 webservices，而且还指定 webservice 的返回内容类型(content-type )（如 HMTL 或 JSON）。也就是说，在 Web 浏览器中键入 <a href="http://domain/ws1">http://domain/ws1</a>，ws1 函数会返回具有相应内容类型的响应数据，我们将在稍后看到。</p>
</div>
<div class="paragraph">
<p>所有到 webservices 的路由都在 <strong>％webservices</strong> 散列中，并通过其他有用的命名参数传递给主函数 <strong>wap</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">wap(:$server-ip, :$server-port, :$default-html, :%webservices);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_wap6_的核心">23.4. Wap6 的核心</h3>
<div class="paragraph">
<p><strong>wap</strong> 函数位于 Wap6 使用的核心 lib 模块的外面，并包含并发和优雅的 V12 引擎：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
  whenever IO::Socket::Async.listen($server-ip,$server-port) -&gt; $conn {
    whenever $conn.Supply(:bin) -&gt; $buf {
      my $response = response(:$buf, :$current-dir, :$default-html, :%webservices);
      $conn.write: $response.encode(&#39;UTF-8&#39;);
      $conn.close;
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个三分（react – whenever – IO::Socket::Async）响应式，并发和异步的上下文。当传输从Web客户端（<strong>$conn</strong>）到达时，它将被放置在 bin 类型的新 Supply <strong>$buf</strong> (<strong>$conn.Suply(:bin)</strong>)中，<strong>$buf</strong> 和 <strong>％webservices</strong> 哈希等其他内容被发送到运行 HTTP 逻辑的响应函数。最后，响应函数的返回被写回到 Web 客户端。</p>
</div>
<div class="paragraph">
<p>响应函数（也位于核心库 lib 中）包含 <strong>HTTP 解析器</strong>的东西：它将传入数据（HTTP 实体）分割为头和主体，它执行验证，它需要基本的 HTTP 头信息，如方法（<strong>GET</strong> 或 <strong>POST</strong>）和 <strong>URI</strong>（统一资源标识符），它确定所请求的资源是 webservice（来自 webservices 文件夹）还是静态文件（来自公共文件夹），从资源中获取数据（来自静态文件或 webservice）并返回到 <strong>wap</strong> 函数以将响应写入 Web 客户端，如我们以前所见。</p>
</div>
</div>
<div class="sect2">
<h3 id="_webservices">23.5. Webservices</h3>
<div class="paragraph">
<p>响应函数验证 <strong>$buf</strong> 并从请求头中提取 HTTP 方法，可以是 <strong>GET</strong> 或 <strong>POST</strong>（我认为将来它不会支持更多的 HTTP 方法）。使用 <strong>GET</strong> 方法时，它将 URL 参数（如果有的话）放入 <strong>$get-params</strong>。 <strong>POST</strong> 方法的情况下，它将主体请求放入 <strong>$body</strong>。</p>
</div>
<div class="paragraph">
<p>然后是时候检查 Web 客户端是否请求了 webservice。 <strong>$get-params</strong> 包含了 <strong>URI</strong> 并用 <a href="https://github.com/raku-community-modules/uri">URI 模块</a>提取，最终结果放在 <strong>$path</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given $path {
  when %webservices{&#34;$_&#34;}:exists {
    my ( &amp;ws, $direct-type ) = %webservices{&#34;$_&#34;};
    my $type = content-type(:$direct-type);
    return response-headers(200, $type) ~ &amp;ws(:$get-params, :$body);
  }
  ..
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <strong>％webservices</strong> 哈希中存在 <strong>$path</strong>，则客户端需要一个 webservice。然后它从 <strong>％webservices</strong> 散列（是的，我也喜欢函数式范式:-)）和对应的内容类型中提取相应的 webservice 可调用函数 <strong>＆ws</strong>。然后它使用 <strong>$get-params</strong> 和请求 <strong>$body</strong> 参数调用 webservice 函数 <strong>＆ws</strong>。最后它返回连接的 HTTP 响应实体：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>具有状态 HTTP 200 OK 和给定内容类型（来自内容类型函数）的响应头。</p>
</li>
<li>
<p>webservice 输出。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可调用 webservice <strong>＆ws</strong> 可以是 <strong>ws1</strong>，位于 webservices 文件夹的 Raku 模块中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub ws1 ( :$get-params, :$body ) is export {
  if $get-params { return &#39;From ws1: &#39; ~ $get-params; }
  if $body { return &#39;From ws1: &#39; ~ $body; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个演示上下文中，webservice 简单地返回输入，即 <strong>$get-params</strong>（当 GET）或 <strong>$body</strong>（POST时）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_当客户端请求静态文件时">23.6. 当客户端请求静态文件时</h3>
<div class="paragraph">
<p>放弃所有其他可能性后，如果客户端请求公用文件夹中托管的静态文件（如html，js，css等），则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given $path {
..
  default {
    my $filepath = &#34;$current-dir/public/$path&#34;;
    my $type = content-type(:$filepath);
    return response-headers(200, $type) ~ slurp &#34;$current-dir/public/$path&#34;;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它返回包含匹配内容类型和请求文件内容的响应头。</p>
</div>
<div class="paragraph">
<p>这就是所有的了！以脚本过程式方式使用并发 Web服务：<strong>Wap6</strong>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结语">23.7. 结语</h3>
<div class="paragraph">
<p>我很满意 <strong>Wap6</strong> 的结果。我并不假装它增长很多，但我总是想继续添加<strong>更多功能</strong>：SSL支持（完成！），会话管理（进行中），Cookie，文件上传等。</p>
</div>
<div class="paragraph">
<p>Raku 为表执行并发网络操作提供了非常强大的方法：<a href="https://docs.raku.org/type/IO::Socket::Async">IO::Socket::Async</a>，一个杰作。另外，使用 <strong>Raku</strong>，您可以根据需要混合使用面向对象，过程式和函数式范式。借助这些功能，您可以设计一个并发异步服务并快速实现。</p>
</div>
<div class="paragraph">
<p>如果您希望在 <strong>Raku</strong> 生态系统中使用 HTTP 服务和并发性更严肃的方法，请看看 <a href="http://cro.services/">Cro</a>，它代表了一个很好的机会，可以将 <strong>Raku</strong> 作为 HTTP 服务空间中的强大实体。Jonathan Worthington 在同样的 Advent Calendar 的第九天写的就是<a href="https://rakuadvent.wordpress.com/2017/12/09/http-and-web-sockets-with-cro">关于 Cro</a>。</p>
</div>
<div class="paragraph">
<p>同时，我将继续使用 <strong>Wap6</strong>，以脚本的方式，贡献 <strong>Raku</strong> 生态系统，并从世界上最好的编程人员那里学习，我的意思是：<strong>Perl</strong> 和 <strong>Raku</strong> 程序员，当然:-)</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第一天_移植_vigilance将raku与标准工具集成在一起">24. 第一天 - 移植 Vigilance，将Raku与标准工具集成在一起</h2>
<div class="sectionbody">
<div class="paragraph">
<p>大家好，今天我们将采用基础设施脚本并将其从Perl 5移植到Raku.本文基于James Clark的一对帖子，你可以在这里找到：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://blog.lazycat.com.au/2014/05/integrating-integrity-part-1.html">第1部分</a></p>
</li>
<li>
<p><a href="http://blog.lazycat.com.au/2014/05/integrating-integrity-part-2.html">第2部分</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此脚本用于创建和验证MD5总和。 这些是128位值，可用于验证数据完整性。 虽然MD5已经被证明在防范恶意行为者方面不安全，但它对于检测磁盘损坏仍然很有用。</p>
</div>
<div class="paragraph">
<p>Raku生态系统正在发展，其中包含多种工具，这些工具可以从Perl 5 CPAN移植，也可以替代。 我将介绍原始脚本和移植的几个方面，并说明我为什么要进行一些特定的更改。 希望这会鼓励你出去移植你自己的小脚本。</p>
</div>
<div class="sect2">
<h3 id="_shebang_和导入">24.1. Shebang 和导入</h3>
<div class="paragraph">
<p>Perl 5版本使用一些基础设施和一些实用程序来处理Unicode并使命令行输出更好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">#!/usr/bin/perl -CSDA

use strict;
use warnings;
use utf8;
use Encode qw/encode_utf8 decode_utf8/;
use Getopt::Long;
use Digest::MD5;
use Term::ANSIColor;
use Term::ProgressBar;
use File::Find;
use File::Basename;
use Data::Dumper;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku默认启用了警告和限制，并且内置了Unicode支持，因此我们可以将其保留。 Data::Dumper也已经实现，它具有非常有用的IO功能。 将所有这些加在一起我们可以得到一个非常精益的标头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku
use v6;

use Digest::MD5;
use Terminal::ANSIColor;
use Terminal::Spinners;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_命令行选项">24.2. 命令行选项</h3>
<div class="paragraph">
<p>Perl 5有许多用于处理命令行参数的很棒的模块，在我们使用 Getopt::Long 的原始脚本中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># Define our command-line arguments.
my %opts = ( &#39;blocksize&#39; =&gt; 16384 );
GetOptions(\%opts, &#34;verify=s&#34;, &#34;create=s&#34;, &#34;update=s&#34;, &#34;files&#34;, &#34;blocksize=s&#34;, &#34;help!&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在Raku中，我们可以直接在MAIN方法中定义命令行选项。 我们使用多个调度来根据传递的参数来控制脚本的执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi MAIN (Str :$create, *@files where { so @files }) { ... }
multi MAIN (Str :$update, *@files) { ... }
multi MAIN (Str :$verify, *@files) { ... }
multi MAIN (*@files where { so @files }) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也意味着我们不必定义帮助选项/sub，因为我们可以文档化我们的MAIN子例程，因此：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| Verify the MD5 sums in a file that conforms to md5sum output:
#|
multi MAIN (Str :$verify, *@files) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能已经注意到Raku版本没有定义blocksize选项，我将回过头来看看。</p>
</div>
</div>
<div class="sect2">
<h3 id="_io_读写文件">24.3. IO: 读写文件</h3>
<div class="paragraph">
<p>我们将校验和存储在一个文件中，其中每一行的格式都与GNU coreutils中的md5sum程序的输出相同：32个十六进制数字，两个空格和文件名。</p>
</div>
<div class="paragraph">
<p>一些基本的IO，我们使用正则表达式来解析每一行。 使用有意义的空格有助于保持每个正则表达式相当简洁：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub load_md5sum_file
{
	my ($filename) = @_;
	my @plan;

	open(my $fh, &#39;&lt;:utf8&#39;, $filename) or die &#34;Couldn&#39;t open &#39;$filename&#39; : $!\n&#34;;
	my $linenum = 0;
	while (my $line = &lt;$fh&gt;) {
		chomp $line;
		$linenum++;
		if ($line =~ /^(?\p{ASCII_Hex_Digit}{32})  (?.*)$/) {
			# Checksum and filename compatible with md5sum output.
			push @plan, create_plan_for_filename($+{filename}, $+{md5});

		} elsif ($line =~ /^(?\p{ASCII_Hex_Digit}{32})  (?.*)$/) {
			# Checksum and filename compatible with md5sum&#39;s manpage but not valid for the actual program.
			# We&#39;ll use it, but complain.
			print STDERR colored(&#34;Warning: &#34;, &#39;bold red&#39;), colored(&#34;md5sum entry &#39;&#34;, &#39;red&#39;), $line, colored(&#34;&#39; on line $linenum of file $filename is using only one space, not two - this doesn&#39;t match the output of the actual md5sum program!.&#34;, &#39;red&#39;), &#34;\n&#34;;
			push @plan, create_plan_for_filename($+{filename}, $+{md5});

		} elsif ($line =~ /^\s*$/) {
			# Blank line, ignore.

		} else {
			# No idea. Best not to keep quiet, it could be a malformed checksum line and we don&#39;t want to just quietly skip the file if so.
			print STDERR colored(&#34;Warning: &#34;, &#39;bold red&#39;), colored(&#34;Unrecognised md5sum entry &#39;&#34;, &#39;red&#39;), $line, colored(&#34;&#39; on line $linenum of file $filename.&#34;, &#39;red&#39;), &#34;\n&#34;;
			push @plan, { error =&gt; &#34;Unrecognised md5sum entry&#34; };
		}
	}
	close($fh) or die &#34;Couldn&#39;t close &#39;$filename&#39; : $!\n&#34;;

	return @plan;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku允许我们验证我们是否通过签名传递了实际存在的文件。 此外，我们用 grammar 替换正则表达式，如果需要，我们可以在脚本的不同位置使用该 grammar：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MD5SUM {
	token TOP        { &lt;md5&gt; &lt;spacer&gt; &lt;filehandle&gt; }
	token md5        { &lt;xdigit&gt; ** 32 }
	token spacer     { \s+ }
	token filehandle { .* }
}

sub load-md5sum-file (Str $filehandle where { $filehandle.IO.f }) {
	my MD5Plan @plans;

	PARSE: for $filehandle.IO.lines(:close) -&gt; $line {
		next PARSE if !$line; # We don&#39;t get worked up over blank lines.

		my $match = MD5SUM.parse($line);

		if (!$match) {
			say $*ERR: colored(&#34;Couldn&#39;t parse $line&#34;, $ERROR_COLOUR);
			next PARSE;
		}

		if (!$match&lt;filehandle&gt;.IO.f) {
			say $*ERR: colored(&#34;{ $match&lt;filehandle&gt; } isn&#39;t an existing file.&#34;, $ERROR_COLOUR);
			next PARSE;
		}

		if ($match&lt;spacer&gt;.chars == 2) {
			@plans.push(MD5Plan.new($match&lt;filehandle&gt;.Str, $match&lt;md5&gt;.Str));
		}
		else {
			say $*ERR: colored(&#34;&#39;$line&#39; does not match the output of md5sum: wrong number of spaces.&#34;, $WARNING_COLOUR);
			@plans.push(MD5Plan.new($match&lt;filehandle&gt;.Str, $match&lt;md5&gt;.Str));
		}
	}

	 return @plans;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>写出数据非常相似：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">sub save_md5sum_file
{
	my ($filename, @plan) = @_;

	my $fh;
	unless (open($fh, &#39;&gt;:utf8&#39;, $filename)) {
		...
	}
	foreach my $plan_entry (@plan) {
		next unless $plan_entry-&gt;{correct_md5} &amp;&amp; $plan_entry-&gt;{filename};
		print $fh &#34;$plan_entry-&gt;{correct_md5}  $plan_entry-&gt;{filename}\n&#34;;
	}
	close($fh) or die &#34;Couldn&#39;t close &#39;$filename&#39; : $!\n&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>值得注意的是，Raku默认以Unicode格式写入文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub save-md5sum-file (Str $filehandle, @plans) {
	my $io = $filehandle.IO.open: :w;

	WRITE: for @plans -&gt; $plan {
		next WRITE unless $plan.computed-md5 &amp;&amp; $plan.filehandle;

		$io.say(&#34;{ $plan.computed-md5 }  { $plan.filehandle }&#34;);
	}

	$io.close;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_获得md5校验和">24.4. 获得MD5校验和</h3>
<div class="paragraph">
<p>Perl 5版本的Digest::MD5使用了相当多的XS来提高性能。 XS中包含了以块的形式添加数据以进行整体解析的方法。 这允许我们使用ProgressBar向用户展示用户等待时的进度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">sub run_md5_file
{
	my ($plan_entry, $progress_fn) = @_;

	# We use the OO interface to Digest::MD5 so we can feed it data a chunk at a time.
	my $md5 = Digest::MD5-&gt;new();
	my $current_bytes_read = 0;
	my $buffer;
	$plan_entry-&gt;{start_time} = time();
	$plan_entry-&gt;{elapsed_time} = 0;
	$plan_entry-&gt;{elapsed_bytes} = 0;

	# 3 argument form of open() allows us to specify &#39;raw&#39; directly instead of using binmode and is a bit more modern.
	open(my $fh, &#39;&lt;:raw&#39;, $plan_entry-&gt;{filename}) or die &#34;Couldn&#39;t open file $plan_entry-&gt;{filename}, $!\n&#34;;

	# Read the file in chunks and feed into md5.
	while ($current_bytes_read = read($fh, $buffer, $opts{blocksize})) {
		$md5-&gt;add($buffer);
		$plan_entry-&gt;{elapsed_bytes} += $current_bytes_read;
		$plan_entry-&gt;{elapsed_time} = time() - $plan_entry-&gt;{start_time};
		&amp;$progress_fn($plan_entry-&gt;{elapsed_bytes});
	}
	# The loop will exit as soon as read() returns 0 or undef. 0 is normal EOF, undef indicates an error.
	die &#34;Error while reading $plan_entry-&gt;{filename}, $!\n&#34; if ( ! defined $current_bytes_read);

	close($fh) or die &#34;Couldn&#39;t close file $plan_entry-&gt;{filename}, $!\n&#34;;

	# We made it out of the file alive. Store the md5 we computed. Note that this resets the Digest::MD5 object.
	$plan_entry-&gt;{computed_md5} = $md5-&gt;hexdigest();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku版本使用纯Perl并且缺少添加功能，因此我使用微调器而不是进度条。 我们还需要专门设置我们的编码，以避免在将二进制数据读取为Unicode时出现的错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub calc-md5-sum (MD5Plan $plan) {
    my $md5 = Digest::MD5.new;

    print &#34;Calculating MD5 sum for { $plan.filehandle }       &#34;; # We need some space for the spinner to take up.
	                                                             # I like &#39;bounce&#39;, so I need 6 spaces for the spinner
	                                                             # + an extra one to separate it from the filehandle.

	my Buf $buffer = $plan.filehandle.IO.slurp(:close, :bin);

	my $decoded = $buffer.decode(&#39;iso-8859-1&#39;);

	my $spinner = Spinner.new(type =&gt; &#39;bounce&#39;);

	my $promise = Promise.start({
		$md5.md5_hex($decoded)
	});

	until $promise.status {
		$spinner.next;
	}

	say &#39;&#39;; # Add a new line after the spinner.

	$plan.computed-md5 = $promise.result;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_结束之前的思考">24.5. 结束之前的思考</h3>
<div class="paragraph">
<p>我没有在我的系统上使用Raku版本因为Digest::MD5的低性能，在我的系统上我用md5sum调用替换它。 其他可能性是使用Inline::Perl5和Perl 5版本的Digest::MD5，或使用惊人的Raku原生调用接口来运行C实现。 我希望这篇文章能激发您将一些自己的Perl 5脚本移植到Raku，或者至少为您提供一些命令行交互的技巧。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二天_like_6_perls_in_a_pod_document_everything">25. 第二天 – Like 6 Perls in a Pod: document everything</h2>
<div class="sectionbody">
<div class="paragraph">
<p>圣诞节即将到来，圣诞老人很沮丧。 他的收件箱被来自全国各地的男孩和女孩的来信塞爆了。</p>
</div>
<div class="paragraph">
<p>但，</p>
</div>
<div class="paragraph">
<p>这些信是写给圣诞老人的吗？ 是否通过签名正确识别了孩子，以便将礼物送给对的人而不是给其他可能不值得的人？ 他们是针对圣诞老人的，而不是那些冒名顶替者，复活节兔子，或者更糟糕的是，三个所谓的 - 我不知道为什么 - 来自东方的智者？ 最糟糕的是，他个人是否必须通过他的王室和神圣的自我来检查所有这些东西？</p>
</div>
<div class="paragraph">
<p>没有。</p>
</div>
<div class="paragraph">
<p>Raku 以下面的方式来救援：</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/syntax/Creating%20grammars">grammar</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit grammar Santa-Letter;

token TOP           { &lt;dear&gt; \v+ &lt;paragraph&gt; [\v+ &lt;paragraph&gt;]* \v+ &lt;signature&gt;\v*}
token paragraph     { &lt;superword&gt;[ \h+ &lt;superword&gt;]+ }
token superword     { &lt;word&gt; | &lt;enhanced-word&gt;       }
token word          { \w+                            }
token enhanced-word { &lt;word&gt; [\,|\.|\:]              }
token dear          { Dear \h+ [S|s]anta [\,|\:]?    }
token signature     { \h+ \w+ \h* \w*                }</code></pre>
</div>
</div>
<div class="paragraph">
<p>该单位向圣诞老人宣布一封致敬的信，其后是一个或多个段落，最后是一个签名，其前面应有一个水平的空格，如 <code>\h</code> 所示。</p>
</div>
<div class="paragraph">
<p>像这样的信件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Dear Santa:

This year I have been a really good boy, I have been in all Squashathons.

So I want a plush Camelia studded with diamonds.

 JJ</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个简单的脚本将使用该 grammar 并在单封信中获取签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Santa-Letter;

sub MAIN ( Str $file = &#34;letter.txt&#34; ) {
    my $letter =$file.IO.slurp;
    my $parsed = Santa-Letter.parse($letter);
    say $parsed&lt;signature&gt;.trim;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这很好，很不错，但圣诞老人需要将这些数据与信件和索引一起提供给北极的CRM，同时他不得不与贸易战给他们造成严重破坏的供应商打交道…​所以他叫上他最亲密的IT精灵，来跟他一起做事。</p>
</div>
<div class="paragraph">
<p>演讲结束后，IT精灵站在那里，他的耳朵在颤抖。</p>
</div>
<div class="paragraph">
<p>“什么？”，圣诞老人咆哮道。 当然是以神圣的方式。</p>
</div>
<div class="paragraph">
<p>耳朵的尖变红了，并伴随着颤抖的辐射热量，使小冰柱融化并落到地上。</p>
</div>
<div class="paragraph">
<p>“你可以阅读消息来源，对吧？”</p>
</div>
<div class="paragraph">
<p>鲁道夫被冰柱融化的噪音惊醒，因为那是他的超级能量之一，介入。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_大多数人都可以阅读源代码但每个人都可以阅读文档">26. 大多数人都可以阅读源代码，但每个人都可以阅读文档。</h2>
<div class="sectionbody">
<div class="paragraph">
<p>鲁道夫说。</p>
</div>
<div class="paragraph">
<p>“而且每个人都应该写下这些文件”，他劝告道，他的头部前面有红色的鼻子。</p>
</div>
<div class="paragraph">
<p>圣诞老人嘟嚷着，但最终检查了他的 Santa-Letter grammar 的主分支并开始着手研究它。 当然，使用 Pod 6</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pod_6_stands_for_plain_old_documentation_for_raku">27. Pod 6 stands for “Plain Old documentation for Raku”</h2>
<div class="sectionbody">
<div class="paragraph">
<p>它（显然）不是首字母缩略词。 Pod6 是一个帮助 Raku 编码人员编写文档的 DSL。 它是一种标记语言，它使用 <code>=</code> 来启动命令和段落级标记。 我们会做到这一点，但目前，Santa 意识到最好的事情之一是它如何与 Raku 本身集成。 因此，他对检查程序进行了第二次迭代：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| This reads a letter file
sub MAIN ( Str $file = &#34;letter.txt&#34; ) {
    my $letter =$file.IO.slurp;
    my $parsed = Santa-Letter.parse($letter);
    say $parsed&lt;signature&gt;.trim;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在注释中有一个有趣的标志，<code>|</code>。 该标志将其与注释背后的代码联系起来。 在这种情况下，它是MAIN子例程。</p>
</div>
<div class="paragraph">
<p>圣诞老人将该程序发布到了生产环境。 IT精灵试图运行该程序，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">./get-signed.p6 --help</code></pre>
</div>
</div>
<div class="paragraph">
<p>它得到了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">Usage:
  ./get-signed.p6 [] -- This reads a letter file</code></pre>
</div>
</div>
<div class="paragraph">
<p>“有文档比没有文档更好”，他想。 但这还不够。 他完全使用自由软件进入北极票务系统，并要求提供更多文档并将任务分配给圣诞老人。 圣诞老人大声抗议，但顺从了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#|{ This reads a letter file in text format.
With no arguments, it will read the C&lt;letter.txt&gt; file.
}
sub MAIN ( Str $file = &#34;letter.txt&#34; ) {
    my $letter =$file.IO.slurp;
    my $parsed = Santa-Letter.parse($letter);
    say $parsed&lt;signature&gt;.trim;
    say $=pod[0].perl;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当使用 <code>--help</code> 调用时，这会打印相同的消息。 这是文档。 运行时:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku --doc get-signed.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">sub MAIN(
	Str $file = &#34;letter.txt&#34;,
)
This reads a letter file in text format. With no arguments, it will read the C file.</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以Raku理解注释和附加到它的代码，并自动打印两者。 记录例程就像这样简单。</p>
</div>
<div class="paragraph">
<p>此外，当在实际文件上运行时，最后一句被踢了，它打印出来：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Pod::Block::Declarator.new(WHEREFORE =&gt; sub MAIN (Str $file = &#34;letter.txt&#34;) { #`(Sub|81308800) ... }, config =&gt; {}, contents =&gt; [])</code></pre>
</div>
</div>
<div class="paragraph">
<p>与其他语言中用于注释的其他DSL不同，例如Perl 5中的Markdown或Pod本身，Pod 6不仅是用于注释的DSL，它还是Raku本身的一部分，因此，它由Raku解析器解释，其内部结构可用于 <code>$=pod</code> 变量中的内省。 在这种情况下，注释是一个 <code>Pod::Block::Declarator</code>，该数据结构包含`WHEREFORE`键，其中包含声明的函数和注释。 但是，`contents`和`config`为空。 他们不应该这样做。</p>
</div>
<div class="paragraph">
<p>更重要的是，注释中使用的一点点实际格式不起作用。 更不用说实际模块没有真正文档化。 现在是圣诞老人不高兴了。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_给模块添加文档">28. 给模块添加文档</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在编写实际代码之前，编写文档可能是您应该做的第一件事。 文档适用于模块客户端，但首先，它是作者的指南，模块应该做什么以及应该如何做的路线图。 如上所述，使用Pod 6可以很容易地记录单个方法或例程; 但是，模块的大图片视图也很方便。 这里是`Santa-Letter`的Pod:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">=begin pod

=head1 NAME

Santa-Letter - A grammar for letters to Santa for the L&lt;Raku Advent Calendar|https://rakuadvent.wordpress.com&gt;

=head1 SYNOPSIS

Parses letters formatted nicely and written by all good kids in the world.

=end pod</code></pre>
</div>
</div>
<div class="paragraph">
<p>方便地放在文件的末尾，当用`raku -doc Santa-Letter.pm6`调用时，或简单地`raku --doc Santa-Letter`如果它
已安装，甚至`p6doc Santa-Letter`如果是`raku/doc`的
在场，会写出类似的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">NAME

Santa-Letter - A grammar for letters to Santa for the Raku Advent
Calendar

SYNOPSIS

Parses letters formatted nicely and written by all good kids in the
world.</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是你会注意到这种类型的输出已经消除了一段标记。 `L`创建链接，但显然只有在输出格式支持时才这样做。 那么让我们试试其中一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku --doc=HTML Santa-Letter.pm6</code></pre>
</div>
</div>
<div class="paragraph">
<p>将输出大量代码，其中包括以下行：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Santa-Letter - A grammar for letters to Santa for the <a href="https://rakuadvent.wordpress.com/">Raku Advent Calendar</a></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>清楚地显示链接的输出。</p>
</div>
<div class="paragraph">
<p>事实上，此命令将使用 <code>Pod::To::HTML</code> 模块将 Pod 数据结构转换为 HTML。 使用任何其他东西将调用相应的模块，并且生态系统上有许多可用的<a href="https://modules.raku.org/search/?q=pod%3A%3Ato">模块</a>。 例如，<code>Pod::To::Pager</code> 将使用系统的分页使东西更美观。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku --doc=Pager Santa-Letter.pm6</code></pre>
</div>
</div>
<div class="paragraph">
<p>会输出这个</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/pager.png">img</a></p>
</div>
<div class="paragraph">
<p>此外，该文档遵循所有模块中使用的约定。 <code>NAME</code> 应描述名称和简短的 oneliner，告诉模块的内容，而 <code>SYNOPSIS</code> 包含更长的描述。 虽然这很好，但真正的文档应包含示例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">=begin code

use Santa-Letter;

say Santa-Letter.parse(&#34;Dear Santa\nAll I want for Christmas\nIs you\n Mariah&#34;);

=end code</code></pre>
</div>
</div>
<div class="paragraph">
<p>示例包含在代码块中，从Pod6的角度来看，它们是 `Pod::Block::Code`对象。 实际上，这是一件好事。 让我们将这一小段代码添加到我们的 grammar 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">our $pod = $=pod[0];</code></pre>
</div>
</div>
<div class="paragraph">
<p>Grammar 是类，它们具有类作用域的变量。 我们无法导出 <code>$=pod</code> 变量以避免与其他人发生冲突，但我们可以导出它，然后在我们的程序中使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $Santa-Letter::pod.perl;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，甚至更好， 安装 <code>Data::Dump</code> 并写下这样的东西:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Dump( $Santa-Letter::pod, :indent(4), :3max-recursion );</code></pre>
</div>
</div>
<div class="paragraph">
<p>它使用我们声明的 <code>pod</code> 类变量, 并且它是这样打印的:</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/structure.png">img</a></p>
</div>
<div class="paragraph">
<p>这个树可以称为POM（Pod对象模型），除了与每个块一起使用的已知的 <code>name</code> 和 <code>config</code> 元数据外，还包括同一级别的Pod6块数组。 每个人都有通用属性和特定属性，例如标题中的级别。 无论如何，有趣的是我们作为示例使用的代码本身可以作为 <code>Pod::Block::Code</code> 对象的内容。</p>
</div>
<div class="paragraph">
<p>圣诞老人想，“哼哼”。 我们可以做得更好。 我们真的可以检查包含的代码是否有效吗？ 我们可以！ 我们来扩展一下 <code>SYNOPSIS</code> 部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">=head1 SYNOPSIS

Parses letters formatted nicely and written by all good kids in the world.

=begin code

use Santa-Letter;

say Santa-Letter.parse(&#34;Dear Santa\nAll I want for Christmas\nIs you\n Mariah&#34;);

=end code

You can also access particular elements in the letter, as long as they are included on the grammar

    my $letter=&#34;Dear Santa,\nI have not been that good.\nJust a paper clip will do\n Donald&#34;
    say Santa-Letter.parse($letter)&lt;signature&gt;

Also

=for code :notest :reason(&#34;Variable defined above&#34;)
say &#34;The letter signed by &#34;, Santa-Letter.parse($letter),
    &#34; has &#34;, Santa-Letter.parse($letter).elems, &#34; paragraphs&#34;;

=end pod</code></pre>
</div>
</div>
<div class="paragraph">
<p>代码可以在Pod中以不同方式表示。 第一个是已知的; 第二个使用缩进，即Markdown，来表示同一件事情。 我们也可以使用 <code>=for</code> 作为段落块，在这种情况下使用代码类型声明，并将继续直到下一个空白行。 这是一种不需要 <code>=end</code> 指令的缩写方式。 但是还有更多的东西：配置变量 <code>:notest :reason(&#34;Variable defined above&#34;)</code>。 这些配置变量是任意的，我们可以添加任意多个。 他们将转到块的 <code>config</code> 属性，我们可以使用它们。 这正是我们将在此脚本中处理代码示例的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $Santa-Letter::pod.contents -&gt; $block {
    next if $block !~~ Pod::Block::Code;
    if $block.config&lt;notest&gt; {
        say &#34;→ Block\n\t&#34;~ $block.contents
            ~ &#34;\n\t❈ Not tested since \&#39;&#34; ~ $block.config&lt;reason&gt; ~ &#34;\&#39;&#34;;
    } else {
        my $code = $block.contents.join(&#34;&#34;);
        say &#34;→ Block\n\t&#34;~ $block.contents;
        try {
            EVAL $code;
        }
        if ( $! ) {
            say &#34;\n\t✘ Produces error \&#34;$!\&#34;&#34;, &#34;\n&#34; xx 2;
        } else {
            say &#34;✔ is OK\n&#34;;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们在上面的结构中看到的那样，<code>contents`属性将包含一个第一级Pod块的数组，在我们的例子中包括我们想要求值的所有三个块（或者可能不包括）。 跳过非代码块（但也可以检查拼写）。 我们在这里做了两件有趣的事情：我们通过 `$block.config</code> 检查配置中的 <code>notest</code> 标志，如果是这种情况我们打印一些注释，但是如果它应该被测试，那么它是`EVAL`ed（我们需要使用`MONKEY-SEE-NO-EVAL` 指令。</p>
</div>
<div class="paragraph">
<p>圣诞老人在文档上运行它，瞧瞧！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">→ Block
	my $letter=&#34;Dear Santa,\nI have not been that good.\nJust a paper clip will do\n Donald&#34;
say Santa-Letter.parse($letter)

	✘ Produces error &#34;Two terms in a row across lines (missing semicolon or comma?)&#34;(

)</code></pre>
</div>
</div>
<div class="paragraph">
<p>他立刻感到高兴和谦卑。 一个简单的分号破坏了示例的质量。 它始终是分号。 他把分号放回到示例中，模块文档以快速的颜色通过了测试。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_回到生产">29. 回到生产</h2>
<div class="sectionbody">
<div class="paragraph">
<p>提供了这个<a href="https://github.com/JJ/my-raku-examples/blob/master/grammars/Santa-Letter.pm6">文档模块</a>，IT精灵非常高兴，他的耳朵停止颤抖和发红。 他也可以给每个 token 编写文档，但足够了，至少他有一些例子可以让应用程序运行。 鲁道夫睡得很熟，现在他必须在信件接收微服务和客户关系宏服务之间建立桥梁。 他可能会使用 <a href="https://cro.services/">Cro</a>，但这是另一天的主题。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第三天_raku_跳转到那儿">30. 第三天 – Raku – 跳转到那儿</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://github.com/nige123/jmp.nigelhamilton.com">jmp</a>是一个Raku驱动的命令行程序，我每天都使用它来浏览成堆的Perl并快速跳转到我的$EDITOR。 我尝试在编码时保持<a href="https://rakuadvent.wordpress.com/2015/12/20/perl-6-christmas-have-an-appropriate-amount-of-fun/">流状态</a>，并且能够快速搜索文件然后直接跳转到编辑器中。</p>
</div>
<div class="paragraph">
<p><strong>jmp</strong> 是一个简单的基于终端的前端到您最喜欢的代码搜索工具（例如，rgrep，ag，ack，git grep等）。 它会显示一个搜索结果列表，您可以在跳转到编辑文件之前快速浏览（例如，vim，nano，<a href="https://commaide.com/">comma</a>等）。</p>
</div>
<div class="paragraph">
<p>它的工作原理如下：</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/11/jmp2-final.gif?w=600&amp;zoom=2">img</a></p>
</div>
<div class="paragraph">
<p>最近我重构了 <strong>jmp</strong>，以便在 <a href="https://github.com/ab5tract/Terminal-Print">Terminal::Print</a> 模块的帮助下改进用户界面。 Terminal::Print 提供了一个方便的二维网格，用于在终端屏幕上绘图。 还有一个用于异步处理用户输入的模块。</p>
</div>
<div class="paragraph">
<p>这是 <strong>jmp</strong> 代码，只要用户按下某个键，它就会响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $in-supply = decoded-input-supply;
my $timer     = Supply.interval(1).map: { Tick };
my $supplies  = Supply.merge($in-supply, $timer);

react {
    whenever $supplies -&gt; $_ {
        when Tick {}
        when &#39;CursorUp&#39;                 { self.pager.cursor-up;   }
        when &#39;CursorDown&#39;               { self.pager.cursor-down; }
        when &#39;CursorRight&#39; | &#39;PageDown&#39; { self.pager.next;        }
        when &#39;CursorLeft&#39;  | &#39;PageUp&#39;   { self.pager.previous;    }
        when &#39;x&#39; | &#39;X&#39;                  { self.pager.exit-page;   }
        when &#39;e&#39; | &#39;E&#39; {
             self.pager.edit-selected($!editor);
        }
        when $_ ~~ Str and $_.ord == 13 {
             # the user pressed ENTER
             self.pager.edit-selected($!editor);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码设置用户输入事件的异步 supply，并且只要事件触发（例如，用户按下PageUp），它就会做出反应。 但是如果用户一次按下很多键会发生什么？ 如何以有序的方式更新终端屏幕？</p>
</div>
<div class="paragraph">
<p>由于 Jonathan Worthington的 <a href="https://github.com/jnthn/oo-monitors">OO::Monitors</a> 模块和 <strong>monitor</strong> 关键字，解决方案在 <a href="https://github.com/ab5tract/Terminal-Print/blob/master/lib/Terminal/Print/Grid.pm6">Terminal::Print::Grid</a> 中找到。 这确保了一次只有一个线程可以在 grid 对象的方法中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use OO::Monitors;
unit monitor Terminal::Print::Grid;</code></pre>
</div>
</div>
<div class="paragraph">
<p>制作自己的 Raku 驱动的命令行工具是学习该语言的好方法。 如果您需要终端接口，请查看 <a href="https://github.com/ab5tract/Terminal-Print">Terminal::Print</a>。 为了加速命令行工具，将代码放在模块中是一个很好的技巧，因此Raku可以预编译它以加快启动时间（例如，<a href="https://github.com/nige123/jmp.nigelhamilton.com/blob/master/lib/JMP/CLI.pm">CLI.pm</a>）。</p>
</div>
<div class="paragraph">
<p>要安装jmp的第2版，首先安装<a href="https://raku.org/downloads/">Raku</a>，然后使用<a href="https://github.com/ugexe/zef">zef</a> Raku模块管理器来安装它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">shell&gt; zef install jmp   # or zef upgrade jmp
shell&gt; jmp config        # set up jmp to use your tools
shell&gt; jmp find sub MAIN # find files containing &#34;sub MAIN&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>随着我们越来越接近圣诞节，请留意更多的命令行工具会被打开。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第四天_献给新年的_raku_pod_新功能">31. 第四天 - 献给新年的 Raku Pod 新功能</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_介绍_3">31.1. 介绍</h3>
<div class="paragraph">
<p>Rakudo NQP 文件包含解析 Raku 输入文件并将其转换为正在运行的 Raku 程序的代码。 本文将重点介绍最近使用 Rakudo NQP 文件时的经验所学到的一些细节。 这项工作涉及实现一些尚未实现的（NYI）Raku POD 功能，我希望尽快合并这些更改。</p>
</div>
</div>
<div class="sect2">
<h3 id="_准备">31.2. 准备</h3>
<div class="paragraph">
<p>使用的 NQP 文件保存在 <a href="https://github.com/rakudo/rakudo/tree/master/src/Raku">https://github.com/rakudo/rakudo/src/Raku</a> 的git存储库中。 有关我的开发设置和工作流的更多背景信息，请参阅 <a href="https://rakuadvent.wordpress.com/2017/12/08/">https://rakuadvent.wordpress.com/2017/12/08/</a> 上的 2017 年 Raku Advent 条目。</p>
</div>
</div>
<div class="sect2">
<h3 id="_背景_2">31.3. 背景</h3>
<div class="paragraph">
<p>在我实现 NYI POD 功能的过程中，我已经给我添加到 Rakudo 仓库中的文档添加了注释: <a href="https://github.com/rakudo/rakudo/blob/master/docs/rakudo-nqp-and-pod-notes.md">rakudo/docs/rakudo-nqp-and-pod-notes.md</a>。我更新它，因为我发现了可能没有记录的新内容或者可能不容易找到其文档。该文件还包含一份完整的清单，通过我的计算，NYI POD 功能。以下是我已经工作了几个月的 NYI POD 功能列表，我希望在今年或新年初完成（以及每个功能的 roast 测试）:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>NYI: %config :numbered 对于段落或分隔的POD块，使用&#39;#&#39;别名</p>
</li>
<li>
<p>NYI: POD 数据块</p>
</li>
<li>
<p>NYI: 以defn块术语格式化代码</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>缺少的项目描述在由 Damian Conway 博士撰写的精美制作的<a href="https://design.raku.org/S26.html">概要S26</a>中，Larry Wall 是多产的得力男人 - 世界知名的 Perl 专家和著名的 Perl 作者。（请注意，现在很少有人在积极研究 POD，我的 NYI 功能列表可能不完整. S26 写得非常密实，如果不高度集中就不容易理解。我花了不少时间试图实现一个我认为已被描述的功能但我误读了文档！）</p>
</div>
<div class="paragraph">
<p>受许多因素的影响, 这项工作比我预期的时间更长，因为我将简要讨论，希望它可以帮助未来的开发人员。</p>
</div>
</div>
<div class="sect2">
<h3 id="_rakudo_nqp_grammar_和_actions_学到的东西">31.4. Rakudo NQP grammar 和 actions: 学到的东西</h3>
<div class="sect3">
<h4 id="_match_对象">31.4.1. Match 对象</h4>
<div class="paragraph">
<p>在 token 上完成一个 grammar 匹配会产生一个匹配对象。 如果 token 具有与该 token 同名的 action 操作方法，则使用匹配对象作为隐式或显式参数调用该 action 方法。 按照惯例，&#39;$/&#39; 用作显式参数，但可以使用另一个名称（不要这样做！）。 我不建议依赖隐式参数。 如果需要，可以添加其他参数。</p>
</div>
<div class="paragraph">
<p>请注意，随着解析的继续，匹配数据将保留在匹配对象中，因为它在其他 token 和方法中使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_断言">31.4.2. 断言</h4>
<div class="paragraph">
<p>断言在 POD 处理中发现的动态 grammar 中很重要。 在主匹配期间，通常必须选择几种匹配路径。 调试错误使用给我带来很多麻烦的一个例子是在定义分隔文本块的 token 内。</p>
</div>
<div class="paragraph">
<p>触发问题的测试用例是文件’b.t&#39;:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">=begin pod
text
=end pod

my $o = $=pod[0];
say $o;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我对它运行raku时，我得到了</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ ./raku b.t
Preceding context expects a term, but found infix = instead.
Did you make a mistake in Pod syntax?
at /usr/local/people/tbrowde/mydata/tbrowde-home-bzr/raku/raku-repo-forks/rakudo/b.t:1
------&gt; =begin ⏏pod</code></pre>
</div>
</div>
<div class="paragraph">
<p>不是很有帮助！ 然后我尝试了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ ./raku b.t --ll-exception b.t
Preceding context expects a term, but found infix = instead.
Did you make a mistake in Pod syntax?
   at SETTING::src/core/Exception.pm6:57  (./CORE.setting.moarvm:throw)
 from src/Raku/World.nqp:4955  (blib/Raku/World.moarvm:throw)
 from gen/moar/Raku-Grammar.nqp:301  (blib/Raku/Grammar.moarvm:typed_panic)
 from gen/moar/Raku-Grammar.nqp:3609  (blib/Raku/Grammar.moarvm:)
 ...more files and line numbers...</code></pre>
</div>
</div>
<div class="paragraph">
<p>更没用了！ 我尝试手动调查列出的文件，并且无法很好地解密代码以获得线索。</p>
</div>
<div class="paragraph">
<p>然后我尝试了另一个似乎有效的类似测试用例，文件’b2.t&#39;：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">=begin table
text
=end table

my $o = $=pod[0];
say $o;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我对它运行raku时，我得到了</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ ./raku b2.t
Pod::Block::Table
  text</code></pre>
</div>
</div>
<div class="paragraph">
<p>成功了！</p>
</div>
<div class="paragraph">
<p>但是这个失败的测试案例导致我几周尝试各种调试技术，直到最后，再次查看 Grammar.nqp 中的 <strong>delimited</strong> token 并在心里计算每个子匹配组正在做什么。 然后我仔细查看了包含<strong>断言</strong>的这个组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[
    # defn-line is all text to the newline
    &lt;?{ ~$&lt;type&gt; eq &#39;defn&#39; }&gt; # &lt;== assertion: this is a &#39;defn&#39; type
    \s* &lt;defn-line&gt;
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <strong>delimited</strong> 块 token 定义中，该组是顺序的而不是备选分支的一部分，必须匹配或全部 token 失败。不幸的是，失败的结果是 LTA , 对于这种情况是例外（这在 NQP 中并不常见，并且在其中工作的危险之一），并且我在寻找原因的过程中犯了太长时间的错误。欺骗我的一件事就是认为在一个没有得到满足的小组中的断言就像是&#39;?&#39;量词意味着忽略失败的匹配。在我仔细研究之后，我认为绝对不是这样！该组是否匹配，因此如果不匹配是可接受的，则量词必须在那里。</p>
</div>
<div class="paragraph">
<p>当我将 <strong>delimited</strong> token 的代码与 <strong>delimited_table</strong> 块 token 的起作用代码（之前我曾做过很多次）进行比较时，我看到 <strong>delimited_table</strong> 块中的同一匹配组具有&#39;?&#39;量词。在我给 <strong>delimited</strong> 块 token 中的组添加&#39;?&#39;后, 坏的测试用例再次起作用！</p>
</div>
</div>
<div class="sect3">
<h4 id="_调试">31.4.3. 调试</h4>
<div class="paragraph">
<p>对我来说最有用的 grammar 和 actions 调试技术是经典的：print 语句用于显示执行期间变量的值。该方法取决于哪种文件类型以及希望显示的值。以下是一些例子：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1、显示匹配对象的内容：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method do-foo($/) {
    say(&#34;DEBUG: dumping method &#39;do-foo&#39; match:&#34;);
    say($/.dump);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>2、显示 grammar 匹配期间的结果</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token blah {
    \h* $&lt;tok&gt; = [ foo | bar ] # &lt;== note &#39;=&#39; instead of &#39;:=&#39;
    { say(&#34;DEBUG: \$&lt;tok&gt; value: &#39;{$&lt;tok&gt;}&#39;&#34;); }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，say 语句位于由花括号定义的块内。另请注意，即使在 NQP 源文件中，grammar 中使用的匹配对象的赋值运算符（&#39;=&#39;）也不是绑定运算符（&#39;:=&#39;）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_动态变量">31.4.4. 动态变量</h4>
<div class="paragraph">
<p>grammar 和 action 大量使用动态变量（带有 <code>*</code> twigil 的变量，例如 <strong>$*IN-DEFN-BLOCK</strong>）。当需要在解析树中深入更改变量时，它们显示了它们的多功能性，并且该值在该解析的剩余部分（调用者）和子解析操作期间保持不变。</p>
</div>
</div>
<div class="sect3">
<h4 id="_make_made_和_ast">31.4.5. make, made 和 ast</h4>
<div class="paragraph">
<p>尽管在所有已发表的 Raku 书籍中都有解释，但 grammar 和 action 中使用的术语 “make”，“made” 和 “ast”一直让我很困惑。感谢 Raku 作者 <strong>Moritz Lenz</strong> 对 <strong>IRC#raku-dev</strong> 的问题的进一步解释和回答，他们更清楚了。</p>
</div>
<div class="paragraph">
<p>基本上，在 action 方法中，使用 <code>make</code> 会将当前值分配给匹配对象的 <code>.ast</code> 属性（或其别名 <code>.made</code>）和方法的名字。因此，给出以下方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method do-foo($/) {
    my $val = 6;
    make $val;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或可选地：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method do-foo($/) {
    $/.ast := 6;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们以后可以用这些惯用法中的一个来获得这个值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say(&#34;do-foo.ast = {$&lt;do-foo&gt;.ast}&#34;);  # output: 6
say(&#34;do-foo.ast = {$&lt;do-foo&gt;.made}&#34;); # output: 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>选择属性名称 <code>.ast</code> 是误导性的，因为它通常是指抽象语法树（AST），但在这种情况下，它与 AST 无关（尽管它可能具有 QAST 节点或任何其他类型的 NQP 对象值）。</p>
</div>
<div class="paragraph">
<p>请注意，分配给 <code>.ast</code> 属性的任何值都可能在 grammar 或 action 的稍后阶段被覆盖或删除。</p>
</div>
</div>
<div class="sect3">
<h4 id="_推迟生成qast节点">31.4.6. 推迟生成QAST节点</h4>
<div class="paragraph">
<p>有时在现有 grammar 中过早生成QAST节点阻止了正确的POD功能实现。一个例子是POD块的%config部分，它具有稍后解析所需的一些值。我正在做的部分工作需要重新编写%config匹配代码，因此在父对象（通常是POD类）的所有部分都已根据需要进行计算或构建之前，不会生成QAST节点。</p>
</div>
</div>
<div class="sect3">
<h4 id="_隔离pod_only代码">31.4.7. 隔离POD-only代码</h4>
<div class="paragraph">
<p>当前的 grammar 和 grammar action 代码是复杂的，并且有些谜题，因为插入了块并且超过15年没有再次触及。因此，很难避免合并冲突与大而必要的变化。核心开发人员提出的一个建议是帮助将 POD 代码与其他代码分开，这就是创建一个与其他现有方言类似的单独POD方言（子语言）。我曾经认为这将是一个有用的改变，但现在，在理解了更多的代码后，创建一个单独的POD方言似乎并不是特别有利。但是，将所有 POD-only 代码移动到封闭类或 grammar 块的末尾将有助于在个人合并重叠代码时最小化版本控制意外和冲突。</p>
</div>
<div class="paragraph">
<p>因此，几个星期前我抓住机会（1）询问了几个关键开发人员，如 @lizmat 和 @jnthn，如果他们对该计划没有问题，（2）创建并测试这样的更改作为拉取请求（PR），（3）合并相当大的PR。不幸的是，这一重大变化令一些开发人员感到意外，并在 IRC#raku-dev 上引发了一些惊讶的评论和投诉！幸运的是，发布经理 @AlexDaniel 运用了他惯用的外交和 git 代码讽刺风度，因为他让人群平静下来，并演示了改变实际上只是一个简单（但很大）的代码转换。所以我即将推出的PR不应该导致合并问题，因为我所知道的其他人都不会在同一个区域工作。</p>
</div>
<div class="paragraph">
<p>您可以通过在每个文件中搜索 POD-ONLY 来查看 Grammar.nqp 和 Actions.nqp 中 POD-only 代码的起点，您会发现：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#================================================================
# POD-ONLY CODE HANDLERS
#================================================================
# move ALL Pod-only [grammar|action] objects here</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_3">31.5. 总结</h3>
<div class="paragraph">
<p>我逐渐了解了如何改进 Rakudo Raku grammar 和实现一些 NYI POD 功能的 actions，我希望尽快交付它们。在工作期间，我从困难的方式学到了许多课程，并希望我对 POD 解析的黑暗角落有所了解。</p>
</div>
<div class="paragraph">
<p>从任何主要编码项目中拿走的最后一课：为合并提交制作，测试和提交小的（即有限的）更改！我在 POD 特征的有时弯曲的解析路径中被包裹起来，我做了太多的改变，并且不能轻易地撤消它们。我希望我不要重蹈覆辙。</p>
</div>
<div class="paragraph">
<p>我希望你和你的 Rakuish 圣诞快乐和新年快乐，并且用 Charles Dickens 的 Tiny Tim（圣诞颂歌）不朽的话来说，“上帝保佑我们，每一个人！”
== 第五天 - 变量</p>
</div>
<div class="paragraph">
<p>这么简单的事，不是吗？ 变量是一个保存着值的名字。</p>
</div>
<div class="paragraph">
<p>有时候，它持有的值可能会被另一个值所取代 - 因此就是名字。 （根据外科医生的说法，没有经常变化的变量应该看医生，并要求被诊断为常数。）</p>
</div>
<div class="paragraph">
<p>虽然它们很容易掌握，而且基本上每种语言都有它们，但我今天的目标是让你相信变量实际上非常棘手。 好的方式！ 我的目的是让你被这篇博文绊倒，茫然，喃喃自语“我以为我知道变量，但我真的不知道…​…​”。</p>
</div>
<div class="paragraph">
<p>接近最后，<a href="http://github.com/masak/007/">实验语言007</a>也将会出现，我考虑变量这么多完全是这种语言的过错。</p>
</div>
</div>
<div class="sect2">
<h3 id="_左还是右">31.6. 左还是右？</h3>
<div class="paragraph">
<p>变量奇怪的第一种方式是它们以两种完全不同的方式使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = &#34;Christmas&#34;;

say(&#34;Merry &#34; ~ $x);       # reading
$x = &#34;Easter&#34;;            # writing</code></pre>
</div>
</div>
<div class="paragraph">
<p>有时我们使用变量来读取值，有时我们使用它们来写一个值。但在这两种情况下，语法看起来完全一样！一些较旧的语言（例如Forth）实际上对这两种用法有不同的语法，我喜欢它们。但是这样的惯例似乎并没有幸存到现代。</p>
</div>
<div class="paragraph">
<p>相反，我们通过语法位置来区分这两种用法。如果你在赋值的左侧，那么你就被写了。否则，你正在被读取。</p>
</div>
<div class="paragraph">
<p>在文献中，这两种用途分别称为 <strong>lvalues</strong> 和 <strong>rvalues</strong>。分别为“左”和“右”。</p>
</div>
<div class="paragraph">
<p>Rvalues 非常正常，与我们对变量的一般考虑方式相对应;他们只是计算它们包含的值。然而，Lvalues 很奇怪。它们更像是盒子，你可以把东西放入（或内存位置？引用？），或者如果不是盒子本身，那么分离的能力放入其中。如果 lvalues 有一个类型，它看起来像 <code>(T) → void</code>，接受 <code>T</code> 但不返回任何东西的东西。</p>
</div>
</div>
<div class="sect2">
<h3 id="_参数">31.7. 参数</h3>
<div class="paragraph">
<p>变量对现代编程至关重要。 还有一个原则表明它们完全没有必要。</p>
</div>
<div class="paragraph">
<p>那就对了！ Tennent 的通信原则！ （我知道你在想什么。不，我说的不是那个 <a href="https://en.wikipedia.org/wiki/Tenth_Doctor">Tennant</a>。</p>
</div>
<div class="paragraph">
<p>这个原则主要指向一种在程序中重写所有变量声明的方法，因此它们是参数声明。 一个例子应该足以展示一般原则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Before
my $veggie = &#34;potato&#34;;
say &#34;$veggie, and that&#39;s all I have to say about that!&#34;;

# After
(-&gt; $veggie {
    say &#34;$veggie, and that&#39;s all I have to say about that!&#34;;
})(&#34;potato&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>看看变量声明如何变成参数声明，相应的赋值转变为参数？有经验的（或者我应该说是饱受争吵蹂躏的）JavaScript开发人员将这种结构视为 <a href="https://stackoverflow.com/questions/8228281/what-is-the-function-construct-in-javascript">IIFE</a>。</p>
</div>
<div class="paragraph">
<p>由于我们总能进行这种转换，因此我们并不需要变量。只有参数。我主要是告诉你这个，所以你可以有点特别感谢你不必用参数编写你的代码。</p>
</div>
<div class="paragraph">
<p>关于Tennent的通信原则的最后注释：它的原始用法在<a href="https://en.wikipedia.org/wiki/S-algol#Semantic_principles">维基百科</a>上有简要描述。它基本上被遗忘了，直到Java即将获得闭包并且它的名称被调用并且原则<a href="https://softwareengineering.stackexchange.com/questions/116395/what-is-the-good-explanation-of-tennents-correspondence-principle">被过度使用了一些</a>，也许。</p>
</div>
</div>
<div class="sect2">
<h3 id="_动态范围">31.8. 动态范围</h3>
<div class="paragraph">
<p>在Raku中，只要变量范围偏离词法范围，变量就会产生额外的“twigil”（sigil之后的可选符号）。这些替代范围中最重要的可能只是动态范围。</p>
</div>
<div class="paragraph">
<p>同样，我们最好用一个例子来说明差异：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $lexical = &#34;mainline&#34;;
my $*dynamic = &#34;mainline&#34;;

sub foo() {
    my $lexical = &#34;foo&#34;;
    my $*dynamic = &#34;foo&#34;;
    bar();
}

sub bar() {
    say $lexical;       # &#34;mainline&#34;
    say $*dynamic;      # &#34;foo&#34;
}

foo();</code></pre>
</div>
</div>
<div class="paragraph">
<p>忘记处女座和Saggitarius以及其他占星术的迹象。对于你更深层次的个性而言，值得做的唯一区别就是你是在做词法查找还是动态查找。毕竟，只有两种人。</p>
</div>
<div class="paragraph">
<p>无论我们喜不喜欢，查找都是一个过程。我们给了一个名字，然后我们去找相应的值。我知道，这令人沮丧。但无论如何，让我们这样做，看看它在哪里。</p>
</div>
<div class="paragraph">
<p>对于 <code>$lexical</code>，通过查看程序文本本身来进行查找。该变量是否定义在我们所在的最小范围内，那个 <code>bar</code> sub？ （事实并非如此。）然后我们向外走，直到周围的范围 - 这最终成为整个计划的范围。它是在那里定义的吗？是!真幸运的是我们从查找中获得胜利，其值为 <code>“mainline”</code>。</p>
</div>
<div class="paragraph">
<p><code>$*dynamic</code> - 请注意名字中的星号？我告诉过你有占星术！ - 我们也从最里面的范围，<code>bar</code> sub开始，并在那里寻找定义。 （我们找不到。）但现在发生了一些不同的事情。我们不会向外跟随块结构，而是向上跟随调用链。谁调用给我们？ <code>foo</code>。这就是我们的目标。那里有定义吗？是!所以我们已经完成并且成功了。</p>
</div>
<div class="paragraph">
<p>从历史的角度来看，动态查找是“明显的”，大多数语言最初都有它。词汇查找只是逐渐证明了它的价值，现在已成为流行病。 Perl 5实际上跨越了这段历史，而我的变量是词法，但较旧的我们/包变量是动态的。这就是你在历史发生时从身边得到的东西。</p>
</div>
<div class="paragraph">
<p>在Raku中，我们也通过禁止术语“父范围”来履行自己的职责。在一个词法和动态查找的世界里，它太混乱了。相反，我们更喜欢术语 <code>OUTER</code>（用于词法查找）和`CALLER`（用于动态查找）。</p>
</div>
<div class="paragraph">
<p>如果可能的话，Raku中的一些结构（例如`return`和`next`）会尝试词法，但如果找不到任何词汇周围的东西来“附加”，则会回归到动态。这种类型的行为似乎没有真正的学术术语，所以Raku的概要称它为“lexotic”。</p>
</div>
</div>
<div class="sect2">
<h3 id="_宏里面的变量">31.9. 宏里面的变量</h3>
<div class="paragraph">
<p>还在我这儿？礼包。 我们来谈谈宏。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use experimental :macros;

macro moo {
    my $counter = 0;
    quasi {
        say ++$counter;
    }
}

for ^10 {
    moo;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个简单的宏，只是将代码中的 <code>++$counter</code> 注入到 <code>for</code> 循环中。该程序将在各行上打印从1到10的所有数字。</p>
</div>
<div class="paragraph">
<p>很好，但…​…​怎么样？请注意，宏扩展代码引用 <code>$counter</code>，但词法查找（如上所述）将找不到在周围词法范围内声明的变量。但是，这个程序仍然有效，或者更确切地说，是有效的。</p>
</div>
<div class="paragraph">
<p>那么使程序运作的基本原则是什么呢？事实证明，通过一个非常幸运的偶然事件，在宏体内定义的变量可以被“无法统一”并被左值替换。注入的代码说 <code>$counter` 实际上看起来更像是 `☐</code>，其中 <code>☐</code> 代表那个（代表不可代理的）左值。</p>
</div>
<div class="paragraph">
<p>我知道这是一件小事，但是当我最终把它放在一起时我很高兴。事实上，我很高兴我把它写成<a href="https://github.com/masak/007/issues/410">github iuuse</a>，只是为了确保细节都能解决。请继续关注此项的实现，从而保持卫生。</p>
</div>
<div class="paragraph">
<p>（对于那些在家中保持分数的人来说，卫生宏是<a href="http://news.perlfoundation.org/2011/09/hague-grant-application-implem.html">本拨款申请</a>中的里程碑D3。）</p>
</div>
<div class="paragraph">
<p>需要明确的是 - 这更像是一种实现意图。 Raku（和007）尚未实现完全卫生。但是，拥有明确的前进道路令人振奋。</p>
</div>
<div class="paragraph">
<p>无论如何，这是变数。他们很可爱，有点奇怪，但最后我们很高兴他们在那里。快乐的历险。☺</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第六天_懒惰精灵与勤劳精灵">32. 第六天 - 懒惰精灵与勤劳精灵</h2>
<div class="sectionbody">
<div class="paragraph">
<p>对圣诞老人来说，圣诞节总是一年中最忙碌的时刻。 幸运的是，圣诞老人有很多帮手。 他们总是做一些小工作和家务，只是为了创造最好的假日季节体验！</p>
</div>
<div class="paragraph">
<p><a href="https://modules.raku.org/dist/Object::Delayed">Object::Delayed</a> 模块为圣诞老人的快乐精灵添加了两个非常有趣的精灵！ 他们的名字是 <code>slack</code> 和 <code>catchup</code>!</p>
</div>
<div class="sect2">
<h3 id="_lazy_slack">32.1. Lazy slack</h3>
<div class="paragraph">
<p>那个懒散的(<code>slack</code>)精灵确实非常懒惰。 懒散(<code>slack</code>)精灵不会做任何事情，直到你真的需要他去做。 虽然人们可以认为这是精灵中非常糟糕的性格特征，但它也是一种非常生态的特征。 人们可以认为这个懒散的(<code>slack</code>)精灵是他们所有人中最环保的精灵！ 你有多少次要求精灵为你做点事情，然后却没用过那个精灵辛苦工作的结果？ 即使它只是到处移动的被回收的电子，但仍然需要能量来移动它们！ 特别是, 如果那些电子被用来告诉其他精灵做一些遥远的事情，就像在外部数据库中一样！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Object::Delayed;
my $dbh = slack { DBIish.connect(...) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是你需要的 <code>$dbh</code> 变量，它只在实际需要时才与数据库建立连接。 当然，如果你想对该数据库进行查询，那么也可以使其懒惰！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Object::Delayed;
my $dbh = slack { DBIish.connect(...) }
my $sth = slack { $dbh.prepare(...) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于语句句柄也是懒惰的，因此在实际需要之前它实际上不会进行查询准备。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Object::Delayed;
my $dbh = slack { DBIish.connect(...) }
my $sth = slack { $dbh.prepare(...) }
# lotsa program
if $needed {
    $sth.execute;  # opens database handle + prepares query
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，如果 <code>$needed</code> 为 true，调用 <code>.execute</code> 函数将使 <code>$sth</code> 成为一个真正的 statemement 句柄，因为它使 <code>$dbh</code> 成为真正的数据库句柄。 那不是很好吗？ 因为如果你不需要它，所有进行查询准备的精灵都可以做其他的事情，而建立数据库连接的精灵也可以做其他事情。 更不用说数据库中的精灵们根本不知道你最初计划建立一个数据库连接！</p>
</div>
<div class="paragraph">
<p>当然，如果您确实需要数据库连接，那么告诉数据库的精灵们您已经完成了这一点总是一个好主意。 在 Raku 中，这不会自动发生，因为圣诞老人不会跟踪每个精灵的行为。 圣诞老人喜欢委派责任！ 当您离开需要数据库句柄的代码部分时，通常会告诉数据库精灵您已完成的工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">LEAVE .disconnect with $dbh;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>LEAVE</code> 精灵的特殊之处在于，当你离开被称为 <code>LEAVE</code> 精灵的街区时，它将完成被告知要做的事情。 在这种情况下，如果 <code>$dbh</code> 被定义，则在 <code>$<em></em></code><em> 上调用 <code>.disconnect</code> 方法：<code>with</code> 精灵不仅测试是否定义了给定值，还设置 <code>$</code></em>。</p>
</div>
<div class="paragraph">
<p>但是，但是，不会检查 <code>$dbh</code> 是否实际定义了与数据库的连接？ 不，这个懒散的精灵足够聪明，如果你问的是某个东西是 <code>.defined</code>，还是真或假，它实际上不会开始为你做这项工作。 这与 <code>catchup</code> 精灵有什么不同！</p>
</div>
</div>
<div class="sect2">
<h3 id="_尽力追赶">32.2. 尽力追赶</h3>
<div class="paragraph">
<p>如果懒惰精灵是圣诞老人雇佣的最环保的精灵，那么 <code>catchup</code> 肯定是最红的精灵。 因为你总是试图赶上 <code>catchup</code> 精灵。 但是追赶精灵似乎只是非常勤奋。</p>
</div>
<div class="paragraph">
<p>当你告诉 <code>catchup</code> 精灵做某事时，<code>catchup</code> 精灵会立即找到另一个精灵去做实际的工作并告诉你它完成了。 最有可能的不是。 当你真正想要使用你要求 <code>catchup</code> 精灵做的结果时，有两种可能性：如果另一个精灵完成并且结果可用，你将立即从`catchup` 精灵那里得到它。 如果其他精灵尚未完成，它将让你等到另一个精灵完成：它会迫使你赶上！ 那看起来怎么样？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Object::Delayed;
my $foo = catchup { sleep 5; &#34;Merry&#34; }      # sleep is just
my $bar = catchup { sleep 9; &#34;Christmas&#34; }  # another word
my $baz = catchup { sleep 8; &#34;everyone&#34; }   # for baking
say “$foo $bar, $baz!”;
say “Took { now - INIT now } seconds”;
# Merry Christmas, everybody!
# Took 9.008 seconds</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，<code>catchup</code> 精灵有另外3个精灵正在制作那些带有甜味硬壳釉的精美烘焙刻字，每个字母花费大约一秒钟。 如果只有一个精灵这样做，它至少需要5 + 9 + 8 = 22秒。 感谢 <code>catchup</code> 精灵，只用了9秒多一点！ 快了两倍多！</p>
</div>
<div class="paragraph">
<p>当然，如果所有其他精灵都在忙着做其他事情，那实际上可能需要一点时间而不是超过9秒。 或者甚至超过22秒，如果其他精灵正在处理更重要的事情，而不是用正确的玻璃烘焙字母。 所以你的精灵里程可能会有所不同。 你不想过度劳累你的精灵，也不要太久。 几秒钟应该没问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_use_the_right_elf">32.3. Use the right elf</h3>
<div class="paragraph">
<p>如果你想尽可能的绿色，请使用 <code>slack</code> 精灵。 如果你想要它，并且你现在想要它（嗯，尽快），那么如果你能够合理地确定有足够的其他精灵来完成实际的工作，那么使用 <code>catchup</code> 精灵是一个选择！</p>
</div>
<div class="paragraph">
<p>参与此博客文章的所有精灵们都欢呼！ 你真的非常确定没有任何快速，慢速或任何其他精灵以任何方式受到伤害。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第七天_细胞自动机">33. 第七天 – 细胞自动机</h2>
<div class="sectionbody">
<div class="paragraph">
<p>今天的降临日历帖子涉及Cellular Automata。</p>
</div>
<div class="paragraph">
<p>什么是细胞自动机？我很高兴你问！它们是由几个部分组成的系统：由细胞组成的一种场或“世界”，每个细胞可以在任何点处的一组状态，描述每个细胞可见的细胞的“邻域” ，以及一套规则，用于管理一个单元将其状态改变为什么状态以及其邻域中所有单元的状态。</p>
</div>
<div class="paragraph">
<p>当然，这是一个非常抽象的描述，所以让我举一些个别部分的例子，希望能让你了解你在细胞自动机中看到的内容：</p>
</div>
<div class="paragraph">
<p>在典型的世界中，你可能会发现细胞像串珠一样排列，或者像国际象棋或中国跳棋板上的字段。您还可以组成更多奇特的配置：任何二维场都可以映射到任何表面，例如<a href="https://en.wikipedia.org/wiki/Stanford_bunny">斯坦福兔子</a></p>
</div>
<div class="paragraph">
<p>你可以在野外找到的状态集是“从0到n的数字”，“这里有细菌”，“黑白颜色”（或更多）。由于您基本上可以将任何信息表示为“数字”，并且允许任意数量的状态，因此还可以存在表示“此时此单元格中有多少粒子在上升，下降，向左或向右移动的状态？ “作为整数或甚至浮点数。</p>
</div>
<div class="paragraph">
<p>邻域可以被认为是细胞“连接在一起”的模式。典型的社区将是“前面的一个，后面的一个”的“串珠”字段，以及“北，东，南，西”或“北，东北，东，东南，南，西南，西，西北“对于棋盘场 - 这两个分别是冯诺依曼附近和摩尔附近。</p>
</div>
<div class="paragraph">
<p>管理每个单元的邻域中的状态的一组规则将导致哪个状态转到其他状态可被视为特定元胞自动机的核心。</p>
</div>
<div class="paragraph">
<p>在今天的降临日历中，我们将探索您可能称之为最简单的自动机。我们将字段串起来像字符串上的珠子，我们将尝试一个或两个和一些不同的状态集。</p>
</div>
<div class="paragraph">
<p>为了让家里的人感兴趣，我将为您提供链接，让您在浏览器中运行示例代码，或在家中使用您的本地raku编译器！</p>
</div>
<div class="sect2">
<h3 id="_为学习而做">33.1. 为学习而做</h3>
<div class="paragraph">
<p>让我们开始，然后：</p>
</div>
<div class="paragraph">
<p>首先，我们需要什么？世界上必须有存储空间，需要一些代码来获得一个符合条件的邻居，以及一些代码来计算一个单元的下一个状态，给定它自己的状态和邻居的状态。最重要的是，我们想看看发生了什么，所以我们也有一些代码。</p>
</div>
<div class="paragraph">
<p>在确定每个单元可以具有哪些状态之后，我们将知道什么存储适合于我们的世界。使用8位整数数组将允许我们从任何不超过255个单独状态的状态集中进行选择。不过，让我们现在共计3个州。我们可以随心所欲地初始化世界，但是将每个字段设置为随机有效状态是一个很好的起点。另一个是将一个状态的单个单元放在中间，并使每个其他单元具有不同的状态。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant number-of-states = 3;
constant field-width = 60;

my int8 @field;

sub init-field {
    @field = (^number-of-states).roll(field-width);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>显示字段非常简单，具体取决于我们使用的输出。 这是一段可以在任何控制台中运行的代码，下面是一个6pad的链接，它在pad的HTML部分输出很少的彩色方块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub output-a-row {

    for @field {
        # Using the unicode characters &#34;Light shade&#34;, &#34;Medium shade&#34;, and &#34;Dark shade&#34;
        # and printing each field twice so they look square rather than slim and tall.
        print [&#34;\x2591&#34;, &#34;\x2592&#34;, &#34;\x2593&#34;][$_] x 2
    }

    say &#34;&#34;;
}

init-field;
output-a-row;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在<a href="https://raku.github.io/6pad/#baa305eff795ed1f7a1957b83a9d4b26">浏览器</a>中运行此代码。 你将不得不等待几秒钟来获得当前相当大的raku编译器在javascript中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_走在前面">33.2. 走在前面</h3>
<div class="paragraph">
<p>从单个行到单元格的自动机的模拟运行需要一次完成一大堆部分。</p>
</div>
<div class="paragraph">
<p>根据他们的定义，细胞自动机将同时推进其所有细胞。 我们当然不会去云端获得拥有与我们领域中的单元一样多的cpu内核的机器。 我们将通过一个简单的循环遍历所有字段来解决“根据它们的相邻单元格在上一步中计算每个单元格的下一步”。</p>
</div>
<div class="paragraph">
<p>对此的直接方法是在每个步骤之后有一个额外的字段来放置计算结果并将结果复制到“真实”字段数组中。 让我们尝试一下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub simulate-step {
    my int8 @output;

    for ^field-width -&gt; $x {
        # do some calculations here
    }

    @field = @output;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们看看我们需要什么来进行计算：新状态将取决于邻域和单元本身。 我们可能会选择最明显的社区：一个小区，它是该领域的前身和继承者。 但等等，第一个和最后一个细胞会发生什么？ 让我们假装他们有一个额外的邻居，它总是处于0状态。这样</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub simulate-step {
    my int8 @output;

    for ^field-width -&gt; $x {
        my $left   = $x - 1 &lt; 0 ?? 0 !! @field[$x - 1];
        my $middle = @field[$x];
        my $right  = $x + 1 &gt;= field-width ?? 0 !! @field[$x + 1];

        # do some calculation with $left, $middle, and $right
        # then push the result into @output
    }

    @field = @output;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以，我们终于到了我们需要决定我们的细胞自动机实际上应该首先做什么的地方。 但是，当我们甚至没有赋予“0,1和2”状态的含义时，我们应该如何弄清楚它应该做什么？</p>
</div>
<div class="paragraph">
<p>答案很简单！ 从字面上理解这一切。</p>
</div>
</div>
<div class="sect2">
<h3 id="_制作东西">33.3. 制作东西</h3>
<div class="paragraph">
<p>我的意思是，我们目前并不关心细胞自动机的作用，只要看起来不错。 那么为什么不预先通过滚动一些想象中的骰子来预先决定应该发生什么呢？</p>
</div>
<div class="paragraph">
<p>为此目的，它有助于知道有多少可能的“配置”甚至是单元及其邻居所在的。幸运的是，这很简单。 您可以将三个单元格想象为由三位数组成的数字，并且每个数字都允许为0,1或2。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">000  001  002
010  011  012
020  021  022
100  101  102
110  111  112
120  121  122
200  201  202
210  211  212
220  221  222</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我没有陷入困境，那就是左，中，右单元组成的所有可能性。 就像四位二进制数可以是2⁴数之一一样，这个三位三进制数可以是  3³。 这意味着我们只需要在0到2之间选择  3³ 个数字，上面表格中每个数字一个。</p>
</div>
<div class="paragraph">
<p>这样做真的很愉快！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my int8 @lookup-table = (^number-of-states).roll(3³);</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且给定 <code>$left</code>，<code>$middle</code> 和 <code>$right</code> 变量，我们可以将第一个与9相乘，第二个与3相乘，并将三者相加以获得查询表中的索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub simulate-step {
    my int8 @output;

    for ^field-width -&gt; $x {
        my $left   = $x - 1 &lt; 0 ?? 0 !! @field[$x - 1];
        my $middle = @field[$x];
        my $right  = $x + 1 &gt;= field-width ?? 0 !! @field[$x + 1];

        my $index = $left * 9 + $middle * 3 + $right;

        @output.push(@lookup-table[$index]);
    }

    @field = @output;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行这个已经让我们看起来很闪亮。 我们需要做的就是连接潜艇：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant number-of-states = 3;
constant field-width = 60;

my int8 @field;

sub init-field {
    @field = (^number-of-states).roll(field-width);
}
init-field;

sub output-a-row {

    for @field {
        # Using the unicode characters &#34;Light shade&#34;, &#34;Medium shade&#34;, and &#34;Dark shade&#34;
        # and printing each field twice so they look square rather than slim and tall.
        print [&#34;\x2591&#34;, &#34;\x2592&#34;, &#34;\x2593&#34;][$_] x 2
    }

    say &#34;&#34;;
}

my int8 @lookup-table = (^number-of-states).roll(3³);

sub simulate-step {
    my int8 @output;

    for ^field-width -&gt; $x {
        my $left   = $x - 1 &lt; 0 ?? 0 !! @field[$x - 1];
        my $middle = @field[$x];
        my $right  = $x + 1 &gt;= field-width ?? 0 !! @field[$x + 1];

        my $index = $left * 9 + $middle * 3 + $right;

        @output.push(@lookup-table[$index]);
    }

    @field = @output;
}

for ^100 {
    simulate-step;
    output-a-row;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果在某些时候看起来非常有趣！ 当然，我们需要通过随机查找表获得幸运。 如果你有很多无趣的东西，我喜欢这里的一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my int8 @lookup-table = &lt;0 0 2 0 0 0 1 2 0 0 1 1 2 1 1 2 1 1 1 0 1 2 2 0 2 1 1&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里是<a href="https://raku.github.io/6pad/#cb1856d301959e3d3dca95925eab2bee">6pad</a>的链接，您可以在浏览器中试用它。</p>
</div>
<div class="paragraph">
<p>第三，这是我的机器的截图，以防您在移动设备上阅读或其他无法运行raku的内容。</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/fish-tmp_112.png">img</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_改变">33.4. 改变</h3>
<div class="paragraph">
<p>现在我们的模拟器完成了它应该做的事情，让我们通过一些调整获得一些乐趣。</p>
</div>
<div class="paragraph">
<p>首先，让我们看看增加不同状态数量需要做些什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant number-of-states = 4;

# the size of the lookup table should be based on the number of states
my int8 @lookup-table = (^number-of-states).roll(number-of-states³);

sub output-a-row {

    for @field {
        # add unicode character &#34;Full block&#34; for the fourth state
        print [&#34;\x2591&#34;, &#34;\x2592&#34;, &#34;\x2593&#34;, &#34;\x2588&#34;][$_] x 2
    }

    say &#34;&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且计算也需要基于状态数进行计算：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $index = $left * number-of-states * number-of-states
            + $middle * number-of-states
            + $right;</code></pre>
</div>
</div>
<div class="paragraph">
<p>那已经是它了！ 到目前为止，甚至都不是很难。</p>
</div>
</div>
<div class="sect2">
<h3 id="_改变邻居">33.5. 改变邻居</h3>
<div class="paragraph">
<p>现在这个更有趣了。 更改邻域将需要我们的计算循环来为索引计算获取更多变量，并且查找表也将再次更改其大小。</p>
</div>
<div class="paragraph">
<p>让我们回到3个状态而不是4个状态，用一个只有一个单元格的单元替换邻域：我们将采用单元格的前任及其后继者，但忽略单元格本身。 然后我们添加了前任的前任和后继者的继任者：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># three states, but four neighbors
constant number-of-states = 3;
constant number-of-neighbors = 4;

# ...

# exponentiate number-of-states with number-of-neighbors, like
# you would to get a number-of-neighbors number in base number-of-states.
my int8 @lookup-table = (^number-of-states).roll(number-of-states ** number-of-neighbors);

sub simulate-step {
   my int8 @output;

   for ^field-width -&gt; $x {
       my $leftleft   = $x &lt;= 1 ?? 0 !! @field[$x - 2];
       my $left       = $x == 0 ?? 0 !! @field[$x - 1];

       my $right      = $x == field-width - 1 ?? 0 !! @field[$x + 1];
       my $rightright = $x &gt;= field-width - 2 ?? 0 !! @field[$x + 2];

       # many multiplications later ...
       my $index = $leftleft * number-of-states * number-of-states * number-of-states
                   + $left   * number-of-states * number-of-states
                   + $right  * number-of-states
                   + $rightright;

       @output.push(@lookup-table[$index]);
   }

   @field = @output;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/fish-tmp_113.png">img</a></p>
</div>
<div class="paragraph">
<p>这是试用它的 <a href="https://raku.github.io/6pad/#98c06c9c9aafaf36c9c4fbf320d9c9cc">6pad</a></p>
</div>
<div class="paragraph">
<p>可悲的是，它似乎只是让输出变得更加混乱。</p>
</div>
</div>
<div class="sect2">
<h3 id="_优化机会">33.6. 优化机会？</h3>
<div class="paragraph">
<p>目前，代码是高性能和可读性之间的折衷。 它也可能看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (0, |@field, 0).rotor(3 =&gt; -2) -&gt; ($left, $middle, $right) {
    my $index = :3[$right, $middle, $left];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然我的直觉告诉我，这会明显变慢。</p>
</div>
<div class="paragraph">
<p>但是我们可以使代码更快一点，甚至不会牺牲太多的可读性！</p>
</div>
<div class="paragraph">
<p>有一件事我们的计算循环太多了：数组访问！ 连续三次访问每个单元格：一旦它变为 <code>$right</code>，再次变为 <code>$middle</code>，另一次变为 <code>$left</code>。</p>
</div>
<div class="paragraph">
<p>那么我们怎样才能做得更好呢？ 我想到的第一件事是让变量 <code>$left</code>，<code>$middle</code> 和 <code>$right</code> 在迭代之间保持不变并通过以下方式移动单元格值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $left   = 0;
my $middle = @field[0];
my $right  = @field[1];

for ^field-width -&gt; $x {
    my $index = $left * number-of-states * number-of-states
            + $middle * number-of-states
            + $right;

    @output.push: @lookup-table[$index];
    $left = $middle;
    $middle = $right;
    $right = $x + 1 &gt;= field-width ?? 0 !! @field[$x + 1];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>很酷，我们甚至已经摆脱了 <code>$x</code> vs field-width的检查！ 但是还有另一件事情一遍又一遍地发生，我们可以做一点点简单。 我们可以让 <code>$left</code>，<code>$middle</code> 和 <code>$right</code> 变量已经保存了添加所需的确切值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $left   = 0;
my $middle = @field[0] * 3;
my $right  = @field[1];

for ^field-width -&gt; $x {
    my $index = $left + $middle + $right;

    @output.push: @lookup-table[$index];
    $left = $middle * 3;
    $middle = $right * 3;
    $right = $x + 1 &gt;= field-width ?? 0 !! @field[$x + 1];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我认为看起来很整洁！</p>
</div>
</div>
<div class="sect2">
<h3 id="_其他变化">33.7. 其他变化？</h3>
<div class="paragraph">
<p>我遇到的一种细胞自动机是每个细胞都有机会在每一步上进行计算的细胞自动机，否则只需保持其状态一步。 让我们看看它是如何实现的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant probability = 0.75e0;

my $left   = 0;
my $middle = @field[0] * 3;
my $right  = @field[1];

for ^field-width -&gt; $x {
    if rand &lt; probability {
        my $index = $left + $middle + $right;

        @output.push: @lookup-table[$index];
    }
    else {
        @output.push: $middle;
    }
    $left = $middle * 3;
    $middle = $right * 3;
    $right = $x + 1 &gt;= field-width ?? 0 !! @field[$x + 1];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>较低的概率很容易被发现，因为它们会使得到的图像看起来垂直拉伸。 较高的概率可以导致完全规则的模式保持大部分完整，但在某些时候可以在一两个点被分解。</p>
</div>
<div class="paragraph">
<p>这是给你的截图！</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/fish-tmp_114.png">img</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_这有用吗">33.8. 这有用吗？</h3>
<div class="paragraph">
<p>细胞自动机通常是非常通用的，甚至非常简单的自动机也可以处理通用计算，如“<a href="http://mathworld.wolfram.com/Rule110.html">规则110</a>”。还有更复杂的自动机，如<a href="https://en.wikipedia.org/wiki/Von_Neumann_universal_constructor">Von Neumann的能够自我复制的机器</a>和WireWorld，它已被用来构建<a href="https://www.quinapalus.com/wires11.html">一台可以计算素数并在七段显示器上显示它们的小机器</a>。</p>
</div>
<div class="paragraph">
<p>非常令人惊讶的是，有一台<a href="http://conwaylife.com/wiki/Turing_machine">图灵机</a>带有一个由非常受欢迎的生命游戏构建的文字磁带，并且可能更令人惊讶的是，它可以计算并显示<a href="http://conwaylife.com/wiki/OTCA_metapixel">生命游戏的生命游戏配置</a>。</p>
</div>
<div class="paragraph">
<p>总而言之，我发现细胞自动机是一个引人入胜的话题。在这篇文章中几乎没有提到二维细胞自动机，但除了本节已经提到的那些之外，还有许多有趣的自动机。</p>
</div>
<div class="paragraph">
<p>实施方面，您很可能不会使用CPU代码来模拟细胞自动机。至少，你不会使用遍历每个单独单元的循环 - 请参阅奇妙的<a href="http://conwaylife.com/wiki/Hashlife">HashLife算法</a>，该算法将世界切换为经常出现的越来越大的块，并立即执行许多全世界的步骤。否则，您很可能会在GPU上模拟CA，当每个单元的代码运行相同时，它会提供极高的并行度。</p>
</div>
<div class="paragraph">
<p>感谢您通过这个非常长的帖子陪伴我！</p>
</div>
<div class="paragraph">
<p>我希望我甚至可以唤醒对细胞自动机的奇妙和广阔世界的空洞兴趣！</p>
</div>
<div class="paragraph">
<p>每个人都有一个可爱的十二月！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第八天_让你的_raku_grammar_紧凑一点">34. 第八天 — 让你的 Raku grammar 紧凑一点</h2>
<div class="sectionbody">
<div class="paragraph">
<p>欢迎来到今年的 Raku Advent Calendar 的第8天！</p>
</div>
<div class="paragraph">
<p>Grammars 是使 Raku 成为一种优秀编程语言的众多因素之一。 我甚至不会尝试预测轮询的结果，以便在 grammars，Unicode 支持，并发功能，超运算符或集合语法之间进行选择，或者选择 Whatever star。 谷歌发现了自己在互联网上发布的最好的 Raku 功能列表。</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/screen-shot-2018-12-01-at-13-15-01.png">img</a></p>
</div>
<div class="paragraph">
<p>无论如何，今天我们将讨论 Raku grammars，我将分享一些技巧，用于使 grammars 更紧凑。</p>
</div>
<div class="sect2">
<h3 id="_1_拆分_actions">34.1. 1.拆分 actions</h3>
<div class="paragraph">
<p>假设您正在编写 grammar 来解析 Perl 的变量声明。 您希望它与以下语句匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s; my @a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它们都声明了一个变量，因此我们可以制定一个通用规则来解析这两种情况。 下面是完整的程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
    rule TOP {
        &lt;variable-declaration&gt;* %% &#39;;&#39;
    }

    rule variable-declaration {
        | &lt;scalar-declaration&gt;
        | &lt;array-declaration&gt;
    }

    rule scalar-declaration {
        &#39;my&#39; &#39;$&#39; &lt;variable-name&gt;
    }

    rule array-declaration {
        &#39;my&#39; &#39;@&#39; &lt;variable-name&gt;
    }

    token variable-name {
        \w+
    }
}

class A {
    has %!var;

    method TOP($/) {
        dd %!var;
    }

    method variable-declaration($/) {
        if $&lt;scalar-declaration&gt; {
            %!var{$&lt;scalar-declaration&gt;&lt;variable-name&gt;} = 0;
        }
        elsif $&lt;array-declaration&gt; {
            %!var{$&lt;array-declaration&gt;&lt;variable-name&gt;} = [];
        }
    }
}

G.parse(&#39;my $s; my @a;&#39;, :actions(A.new));</code></pre>
</div>
</div>
<div class="paragraph">
<p>我不解释这个程序的每一点; 如果您有兴趣，可以在最近的 <a href="http://perl.nl/amsterdam">Amsterdam.pm</a> 会议上观看<a href="https://www.youtube.com/watch?v=YWTmd4Hdfa4">80分钟的视频</a>。</p>
</div>
<div class="paragraph">
<p>现在感兴趣的对象是规则 <code>variable-declaration</code> 及其相应的 action。</p>
</div>
<div class="paragraph">
<p>该规则包含两个选项：是否声明了标量或数组。 该 action 还在选项之间进行选择，并使用 <code>if-else</code> 块执行该 action 操作。 Raku 允许你省略布尔条件周围的括号，但是，整个结构仍然很大。 例如，想想如果添加哈希声明，则需要添加另一个 <code>elsif</code> 分支。</p>
</div>
<div class="paragraph">
<p>为每个子分支分别采取 action 操作会更清楚：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method scalar-declaration($/) {
    %!var{$&lt;variable-name&gt;} = 0;
}

method array-declaration($/) {
    %!var{$&lt;variable-name&gt;} = [];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，每个方法的主体包含单行代码，你可以立即看到它正在做什么。 更不用说它变得不那么容易出错了。</p>
</div>
<div class="paragraph">
<p>在我们继续讨论下一个技巧之前，你可能需要实现另一个优化：<code>my</code> 关键字出现在任一声明中，因此请使用非捕获括号并将公用字符串从它们之中移出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule variable-declaration {
    &#39;my&#39; [
        | &lt;scalar-declaration&gt;
        | &lt;array-declaration&gt;
    ]
}

rule scalar-declaration {
    &#39;$&#39; &lt;variable-name&gt;
}

rule array-declaration {
    &#39;@&#39; &lt;variable-name&gt;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用_multi_方法">34.2. 使用 multi 方法</h3>
<div class="paragraph">
<p>让我们改进 grammar 以允许使用目标语言进行赋值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s; my @a; $s = 3; $a[1] = 4;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，赋值是以 Perl 5 样式完成的，数组元素为 sigil。 有了这个，可以使用以美元开头的单个规则来完成赋值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
    rule TOP {
        [
            | &lt;variable-declaration&gt;
            | &lt;assignment&gt;
        ]
        * %% &#39;;&#39;
    }

    # . . .

    rule assignment {
        &#39;$&#39; &lt;variable-name&gt; &lt;index&gt;? &#39;=&#39; &lt;value&gt;
    }

    rule index {
        &#39;[&#39; &lt;value&gt; &#39;]&#39;
    }

    token value {
        \d+
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，<code>assignment</code> action 操作必须推断出它目前正在处理的赋值类型。</p>
</div>
<div class="paragraph">
<p>同样，您可以使用我们的老朋友，action 操作中的 <code>if-else</code> 块。 根据索引的存在，您可以确定这是一个简单的标量还是数组的元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method assignment($/) {
    if $&lt;index&gt; {
        %!var{$&lt;variable-name&gt;}[$&lt;index&gt;&lt;value&gt;] = +$&lt;value&gt;;
    }
    else {
        %!var{$&lt;variable-name&gt;} = +$&lt;value&gt;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码也可以轻松简化，但这次使用 multi 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method assignment($/ where !$&lt;index&gt;) {
    %!var{$&lt;variable-name&gt;} = +$&lt;value&gt;;
}

multi method assignment($/ where $&lt;index&gt;) {
    %!var{$&lt;variable-name&gt;}[$&lt;index&gt;&lt;value&gt;] = +$&lt;value&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>where</code> 子句允许 Raku 决定哪个候选方法在给定情况下更适合。</p>
</div>
<div class="paragraph">
<p>另请注意在第二个 multi 方法中如何使用 <code>&lt;value&gt;</code> 键两次。 <code>&lt;value&gt;</code> 的每个条目指的是目标代码的不同部分：一个用于索引值，另一个用于右侧值。</p>
</div>
</div>
<div class="sect2">
<h3 id="_3_让_perl_完成这项工作">34.3. 3. 让 Perl 完成这项工作</h3>
<div class="paragraph">
<p>有时，Perl 可以为我们完成工作，特别是如果你想实现 Perl 熟悉的东西。 例如，让我们在赋值中允许不同类型的数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a; my $b; $a = 3; $b = -3.14;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 grammar 中引入浮点数比较容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token value {
    | &#39;-&#39;? \d+
    | &#39;-&#39;? \d+ &#39;.&#39; \d+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您想添加其他类型的数字，请参阅 <a href="https://www.perl.com/article/perl-6-grammers-part-1/">perl.com</a> 上的文章。 现在，我们可以用上面两个选项限制 grammar，因为这足以阐明这个技巧。</p>
</div>
<div class="paragraph">
<p>如果您使用更改运行代码，您可能会对获得所需结果感到惊讶。 两个变量都接收值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Hash %!var = {:a(3), :b(-3.14)}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下，都触发了相同的 action 操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method assignment($/ where !$&lt;index&gt;) {
    %!var{$&lt;variable-name&gt;} = +$&lt;value&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在赋值的右侧，我们看到 <code>+$&lt;value&gt;</code>，这是从 Match 对象转换为数字的类型。 grammar 将 <code>3</code> 或 <code>-3.14</code> 放在 <code>$&lt;value&gt;</code> 中，两者都作为字符串。 <code>+</code> 这个一元运算符尝试将字符串转换为数字。 两个字符串都是有效数字，因此 Raku 不会抱怨。</p>
</div>
<div class="paragraph">
<p>自己编写代码将字符串转换为数字会更加困难，因为需要考虑数值的所有不同形式。 要了解 Raku 知道的其他格式，请查看 <a href="https://github.com/rakudo/rakudo/blob/master/src/Raku/Grammar.nqp">Raku grammar</a> 中 <code>numish</code> 标记的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token numish {
    [
    | &#39;NaN&#39; &gt;&gt;
    | &lt;integer&gt;
    | &lt;dec_number&gt;
    | &lt;rad_number&gt;
    | &lt;rat_number&gt;
    | &lt;complex_number&gt;
    | &#39;Inf&#39; &gt;&gt;
    | $&lt;uinf&gt;=&#39;∞&#39;
    | &lt;unum=:No+:Nl&gt;
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您在自己的 grammar 中允许任何上述类型，Perl 将能够为您转换它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="_4_使用_multi_rules_和_multi_tokens">34.4. 4. 使用 multi-rules 和 multi-tokens</h3>
<div class="paragraph">
<p>它不仅是方法，也可以是 multi-things。 grammar 的规则和标记也是方法，您也可以创建它们的多个变体。</p>
</div>
<div class="paragraph">
<p>让我们更新我们的 grammar，以允许在赋值的右侧使用数学表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a; $a = 6 + 5 * (4 - 3);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的新问题是解析表达式并处理运算符优先级和括号。 您可以通过以下方式描述任何表达式：</p>
</div>
<div class="paragraph">
<p>1、表达式是由 <code>+</code> 或 <code>-</code> 分隔的项的序列。
2、上一个规则中的任何项都是由 <code>*</code> 或 <code>/</code> 分隔的项的序列。
3、括号内的任何内容都是另一个表达式，因此请转到规则1。</p>
</div>
<div class="paragraph">
<p>话虽如此，您最终会得到以下 grammar 变更：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
    # . . .

    rule assignment {
        &#39;$&#39; &lt;variable-name&gt; &lt;index&gt;? &#39;=&#39; &lt;expression&gt;
    }

    multi token op(1) {
        &#39;+&#39; | &#39;-&#39;
    }

    multi token op(2) {
        &#39;*&#39; | &#39;/&#39;
    }

    rule expression {
        &lt;expr(1)&gt;
    }

    multi rule expr($n) {
        &lt;expr($n + 1)&gt;+ %% &lt;op($n)&gt;
    }

    multi rule expr(3) {
        | &lt;value&gt;
        | &#39;(&#39; &lt;expression&gt; &#39;)&#39;
    }

    # . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，rules 和 tokes 都是 multi 方法，它采用反映表达式深度的单个整数值。 操作符也是如此：在第一级，你期望 <code>+</code> 和 <code>-</code> ，在第二级 -  <code>*</code> 和 <code>/</code>。</p>
</div>
<div class="paragraph">
<p>不要忘记 Raku 中的 multi 方法（以及 multi-subs）可以基于常量进行调度，这就是为什么你可以, 例如, 使用你在 <code>multi token op(2)</code> 中看到的签名。</p>
</div>
<div class="paragraph">
<p><code>expr($n)</code> 规则通过 <code>expr($n + 1)</code> 递归定义。 <code>$n</code> 达到3时递归停止，Raku 选择最后一个候选 <code>multi rule expr(3)</code>。</p>
</div>
<div class="paragraph">
<p>让我懒惰，并使用以前的建议让 Perl 计算表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method assignment($/ where !$&lt;index&gt;) {
    use MONKEY-SEE-NO-EVAL;
    %!var{$&lt;variable-name&gt;} = EVAL($&lt;expression&gt;);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一般来说，我建议只在神奇的圣诞节期间使用 <code>EVAL</code>。 在今年余下的时间里，请自己计算表达式并使用抽象语法树和 <code>make</code> 和 <code>made</code> 方法对儿保存部分结果。 例如，请参阅此处的<a href="https://github.com/ash/lingua/blob/master/LinguaActions.pm">示例</a>。</p>
</div>
<div class="paragraph">
<p>我还建议一些额外的阅读，以便更好地了解如何使用 <code>multi</code> 和 <code>proto</code> 关键字：</p>
</div>
<div class="paragraph">
<p>1、<a href="https://raku.online/2017/12/21/the-proto-keyword/">Raku 中的 proto 关键字</a>
2、<a href="https://raku.online/2018/02/21/63-more-on-the-proto-keyword-in-perl-6/">有关 Raku 中 proto 关键字的更多信息</a></p>
</div>
<div class="paragraph">
<p>此时此刻，令人惊叹的 Raku grammar 之旅就要结束了。 你可以在 <a href="https://github.com/ash/advent-2018-day8">GitHub</a> 上找到今天帖子的完整例子。 祝你读完其余的 Perl Advent Calendars，祝你愉快！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第九天_raku_中的常量">35. 第九天 - Raku 中的常量</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我自豪地告诉人们在<a href="https://act.yapc.eu/lpw2018">伦敦 Perl 工作室</a>前一天我写了我的第一个 Raku 程序（也就是一个能工作的程序）。 所以，JJ 说：“为什么不为 Raku 写一个 Advent 日历帖？”</p>
</div>
<div class="paragraph">
<p>我名下只有区区一个程序，我该写些什么呢？ 嗯…​…​我在 Perl 5 中创作了 <a href="https://metacpan.org/pod/Astro::Constants">Astro::Constants</a>，那么将它迁移到 Raku 有多难？</p>
</div>
<div class="paragraph">
<p>话匣子打开就关不上了，我给你讲一个 Perl 5 模块作者在 Raku 的领地中徘徊的故事。</p>
</div>
<div class="paragraph">
<p>如果在<a href="https://rakuadvent.wordpress.com/2018/12/04/day-5-variables/">第5天</a>你被“诊断”为常数，那么你正好需要今天的帖子。</p>
</div>
<div class="paragraph">
<p>我们习惯使用变量来计算东西和持有东西。 随着我们获得更多“东西”，总量会发生变化。 <a href="https://docs.raku.org/language/variables#The_constant_prefix">常量</a>是那些永远不会改变的值。 像一天中的秒数或光速。 当然，我们在计算中使用它们就像使用变量一样，但是你不想通过赋值意外地改变常量</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$SPEED_LIGHT = 30;</code></pre>
</div>
</div>
<div class="paragraph">
<p>甚至意外地当你打算测试它是否等于某个值时，就像这样</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if ( $SECONDS_IN_A_DAY = $seconds_waited) {</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你真正想的是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if ( $SECONDS_IN_A_DAY == $seconds_waited) {</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这些情况下，你希望编译器说“对不起，戴夫。 恐怕我不能这样做。“ Perl 编译器关闭了。 如果你尝试运行第一行，你会得到</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Cannot modify an immutable Num (299792458)
  in block  at im_sorry_dave.p6 line 12</code></pre>
</div>
</div>
<div class="paragraph">
<p>单击此处获取<a href="https://docs.raku.org/language/terms#Constants">完整解释</a></p>
</div>
<div class="sect2">
<h3 id="_如何制作一个常数">35.1. 如何制作一个常数</h3>
<div class="paragraph">
<p>要使变量保持不变，请使用 <code>constant</code> 关键字声明它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant $tau = pi * 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>嘿！ sigil 是可选的，所以我可以使用我最喜欢的样式进行常量声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my constant SPEED_LIGHT is export = 2.99792458e8;</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有这些乐趣不仅仅适用于<a href="https://docs.raku.org/type/Scalar">标量</a>。 <a href="https://docs.raku.org/type/List">列表</a>和<a href="https://docs.raku.org/type/Hash">散列</a>也可以声明为常量！</p>
</div>
<div class="paragraph">
<p>为什么要使 List 保持不变？ 一年中的月份是列表吧, 它阻止这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my constant @months = ;
...
@months[9] = &#39;Hacktober&#39;;   # changing a name
push @months, &#39;Hogmannay&#39;;  # we&#39;d all like more time after Christmas</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你尝试其中任何一个，你得到</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Cannot modify and immutable Str (D)       # error for the assignment
# or
Cannot call &#39;push&#39; on an immutable &#39;List&#39; # error for the push</code></pre>
</div>
</div>
<div class="paragraph">
<p>顺便说一句，<code>tau</code>，<code>pi</code>，<code>e</code> 和 <code>i</code> 都是 Raku 中的内置常量，以及它们的 Unicode 等价物，<code>τ</code>，<code>π</code> 和 <code>𝑒</code>。 似乎你可以使用<a href="https://docs.raku.org/language/variables#Sigilless_variables">无 sigil 变量</a>获得相同的行为但是今天暂且不表。</p>
</div>
</div>
<div class="sect2">
<h3 id="_从模块导出常量">35.2. 从模块导出常量</h3>
<div class="paragraph">
<p>如果你要在代码中反复使用相同的常量，那么将它们放在一个模块（一个单独的文件）中并将其加载到程序中是有意义的。 现在我不得不在这里加一些土鳖编程，但这对我有用，我会尽力解释它的能力。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6;
unit class Astro::Constants:ver&lt;0.0.1&gt;:auth;

my constant SPEED_LIGHT is export = 2.99792458e8;
...</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>第1行</strong> - 轻松入手。<code>use v6;</code> 告诉编译器这是一个 Raku 程序。等等！我不需要它。这只是编写程序的一个习惯。我可以摆脱它。</p>
</div>
<div class="paragraph">
<p><strong>第2行</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.raku.org/language/module-packages#The_unit_keyword">unit</a> 表示此文件只提供一个模块 - 不知道这意味着什么</p>
</li>
<li>
<p><a href="https://docs.raku.org/syntax/class">class</a> 创建文件的词法范围 - 但我可能已经使用了<a href="https://docs.raku.org/language/module-packages">模块</a>，而不是用于不属于类的代码。嗯，我想我必须更深入地考虑我的代码设计。但它仍然奏效！</p>
</li>
<li>
<p><code>Astro::Constants</code>  - 模块名称</p>
</li>
<li>
<p><code>ver&lt;0.0.1&gt;</code>  - 版本字符串，现在在包声明中。</p>
</li>
<li>
<p><code>auth</code>  - 嗯，这是作者。为包名添加更高的维度有点怪，但它确实允许您指定要使用的模块的版本。在 PAUSE 中没有名称空间露营的问题。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>第N行</strong> <code>my</code> 词汇范围; <code>constant</code> 使其成为只读; <code>SPEED_LIGHT</code> 是常量的名称; <code>is export</code> 允许常量<a href="https://docs.raku.org/language/modules#Exporting_and_selective_importing">在模块外部使用</a>，即在代码中使用; <code>2.99792458e8</code> 只是 Perl 表达 <code>2.99×10⁸</code> 的方式。</p>
</div>
<div class="paragraph">
<p>…​为了完整起见，加上版本方法和一些<a href="https://rakuadvent.wordpress.com/2015/12/10/day-10-perl-6-pod/">文档</a>来完成模块怎么样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method ver { v0.0.1 }

=begin pod

=head1 DESCRIPTION

A set of constants used in Physics, Chemistry and Math

=end pod</code></pre>
</div>
</div>
<div class="paragraph">
<p>将常量放入模块的一个副作用是它们<a href="https://docs.raku.org/language/traps#Constants_are_computed_at_compile_time">在编译时计算</a>。它应该使您的代码运行得更快，但编译后的模块仍然存在。 这对于常量非常有用，但如果您的模块包含您可能想要更改的内容，则需要重新编译它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_在程序中使用模块">35.3. 在程序中使用模块</h3>
<div class="paragraph">
<p>一旦你有了一个模块，你如何在程序中使用它？</p>
</div>
<div class="paragraph">
<p>在这个例子中，我创建了一个目录 <code>mylib/Astro</code>，并将该模块放在一个名为 <code>mylib/Astro/Constants.pm6</code> 的文件中。 这是我的程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6;
use lib ;
use Astro::Constants;

say &#34;speed of light =\t&#34;, SPEED_LIGHT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它<strong>起作用了</strong>！ 解释一下前3行：<code>use v6</code> 说使用 Raku; <code>use lib</code> 表示把路径添加到库搜索路径; <code>use Astro::Constants</code> 表示在库路径中搜索文件 <code>Astro/Constants.pm6</code> 并加载它。</p>
</div>
<div class="sect3">
<h4 id="_我必须做这一切吗_不">35.3.1. 我必须做这一切吗？ …​…​不。</h4>
<div class="paragraph">
<p>为什么要重新发明轮子？ 前面提到的JJ有<a href="https://github.com/JJ/p6-math-constants">以前的常量形式</a>，但你需要一个包管理器来完成它的安装工作。 在 Fedora 28 中，使用 <code>dnf install rakudo-zef</code> 来安装包管理器 <strong>zef</strong>。 然后，您可以搜索任何处理常量的模块。运行</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">zef search Constants</code></pre>
</div>
</div>
<div class="paragraph">
<p>将为您提供至少15个在生态系统中注册的软件包，并非所有软件包都是你正在寻找的软件包。您可以立即开始使用 <code>zef install Math::Constants</code> 并使用JJ的模块，或者您可以使用搜索来查看我是否已经找到时间上传我的尝试（当时可能名为 <strong>*Physics::Constants</strong>），即将于2019年发布。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_最后对代码维护进行了一些注释">35.4. 最后，对代码维护进行了一些注释</h3>
<div class="paragraph">
<p>对我来说，代码维护是科学编程中最重要的考虑因素。想想那位走进美学院门口的新科学专业的学生，​​并在第1天交给你维护的代码。在第20天保证，他们被要求做出改变。为了他们的缘故，我喜欢为了清晰而不是简洁而写作，因为科学中存在如此多的重载符号。因此，我对将符号投入计算时很谨慎。也许我什么都不担心，但找到答案的唯一方法就是去做，看看是否有害。</p>
</div>
<div class="paragraph">
<p>我现在发生的一种可能性是能够指定你所指的常数。这个组成的例子看起来有点像 Python。可能值得偷窃。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">import GRAVITATIONAL as G;
...
$F_between_two_bodies = G * $mass1 * $mass2 / $distance**2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我将在圣诞节阅读 <a href="https://www.packtpub.com/application-development/perl-6-deep-dive">Raku Deep Dive</a>，我会告诉你我明年的表现。</p>
</div>
<div class="paragraph">
<p>快乐地搞科学！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十天_跳转_开启你的工作流">36. 第十天 - 跳转, 开启你的工作流</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这是另一个版本的 <a href="https://github.com/nige123/jmp.nigelhamilton.com">jmp</a> 供你在圣诞节前解开。</p>
</div>
<div class="paragraph">
<p><strong>jmp</strong> 是一个命令行工具，用于搜索成堆的代码，然后快速跳转到 <code>$EDITOR</code>。这有助于<a href="https://rakuadvent.wordpress.com/2015/12/20/perl-6-christmas-have-an-appropriate-amount-of-fun/">保持流动</a>。</p>
</div>
<div class="paragraph">
<p>然而，计算机编程具有许多潜在的<a href="https://rakuadvent.wordpress.com/2016/12/19/fixing-flow/">流阻塞器</a>。要在编码时保持流状态，通常需要在其他情况下快速<strong>跳转</strong>(jmp)到一行代码：修复错误，运行测试，检查日志文件，检查git状态等. <strong>jmp</strong> 也可以帮助加速这些任务吗？</p>
</div>
<div class="paragraph">
<p>幸运的是，重构 <strong>jmp</strong> 以容纳这些额外的使用场景相对容易。最新版本的 <strong>jmp</strong> 现在的工作原理如下：</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/demo.gif?w=600&amp;zoom=2">img</a></p>
</div>
<div class="paragraph">
<p>在命令前加上 <strong>jmp</strong> 将导致命令再次执行，并且其输出会被吞噬并被分页。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| find matching lines
method find-files-in-command-output ($command) {

    # execute the command
    my $shell-cmd = shell $command, :out, :err;

    # join STDOUT and STDERR
    my $result = join(&#34;\n&#34;, $shell-cmd.out.slurp,
                            $shell-cmd.err.slurp);

    # don&#39;t actually look for filenames just yet
    # do that lazily on demand by the user
    return $result.lines.map({
               JMP::File::HitLater.new(context =&gt; $_)
           });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>jmp</strong> 为每一行创建结果提示，并对结果进行分页。然后，如果需要，您可以快速浏览输出并将 <strong>jmp</strong> 导入文本编辑器（请参阅 <strong>jmp config</strong> 以将其更改为您最喜欢的编辑器）。</p>
</div>
<div class="paragraph">
<p>速度对命令行工具很重要。<strong>jmp</strong> 只在用户选择编辑特定行时查找文件名, 而不是提前扫描每一行的文件名。这是懒惰地解析查找文件的行的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">submethod find-file-path {

    given self.context {

        # matches Perl 5 error output (e.g., at SomePerl.pl line 12)
        when /at \s (\S+) \s line \s (\d+)/ {
            proceed unless self.found-file-path($/[0], $/[1]);
        }

        # matches Raku error output (e.g., at SomeRaku.p6:12)
        when /at \s (&lt;-[\s:]&gt;+) &#39;:&#39; (\d+)/ {
            proceed unless self.found-file-path($/[0], $/[1]);
        }

        # matches Raku error output (e.g., SomeRaku.p6 (Some::Raku):12)
        when /at \s (&lt;-[\s:]&gt;+) &#39;(&#39; \S+ &#39;)&#39; &#39;:&#39; (\d+)/ {
            proceed unless self.found-file-path($/[0], $/[1]);
        }

        # more file finding patterns HERE - PR&#39;s welcome?

        # go through each token
        default {
            for self.context.words -&gt; $token {
                # keep trying to set the file path
                proceed if self.found-file-path($token);
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>when</strong> 块匹配不同类型的错误格式（例如，Perl 5 和 Raku）以提取文件名和行号。 <strong>proceed</strong> 语句对于移动到下一个 <strong>when</strong> 块非常有用。</p>
</div>
<div class="paragraph">
<p>这意味着你可以跳转(<strong>jmp</strong>)到工作流程中出现错误的任何位置：例如命令行的输出，测试输出，日志文件等。</p>
</div>
<div class="paragraph">
<p>要升级到 <strong>jmp</strong> 的第3版：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">shell&gt; zef upgrade jmp</code></pre>
</div>
</div>
<div class="paragraph">
<p>要首次安装 <strong>jmp</strong>，请<a href="https://raku.org/downloads/">安装 Raku</a>，然后使用 <a href="https://github.com/ugexe/zef">zef</a> Raku 模块管理器来安装它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">shell&gt; zef install jmp   # install the jmp command line tool
shell&gt; jmp config        # set up jmp to use your tools
shell&gt; jmp to sub MAIN   # find files containing &#34;sub MAIN&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>圣诞节前还有更多工具可以打开。在第17天再次与你联系，获取有助于您的非编码工作流的工具。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十一天_使用_raku_测试你的时刻表">37. 第十一天 - 使用 Raku 测试你的时刻表</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这几乎是在北极附近的精灵小学冬季学期结束之时。对于精灵而言，敏锐的人物头脑非常重要，而小精灵的数学老师 Hopper 女士希望确保他们在任期的倒数第二天保持他们的算术技能。（学期的最后一天保留用于观看电影和玩耍 -  很嗨皮）。</p>
</div>
<div class="paragraph">
<p>小精灵刚刚学会了他们的时间表（乘法表），最多12个，但他们并不像他们所想的那样擅长，其中一些人在圣诞节前将在玩具工作坊帮忙，那时候他们可能需要快速告诉大精灵有多少特定类型的玩具。</p>
</div>
<div class="paragraph">
<p>幸运的是，Elf Hopper 是一个非常聪明的精灵，拥有出色的数学和编码能力 - 自己。所以她起了一个快速的控制台应用程序来运行小精灵的学校颁发的 Perlix 6.0 boxen。</p>
</div>
<div class="paragraph">
<p>该程序允许小精灵通过运行它们在2至12次表中测试自己，或者如果它们提供单个数字参数，他们可以尝试任何他们喜欢的乘法表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use v6;

my $fixednum;
my %score;
my @exits = &lt;exit quit&gt;;

$fixednum = @*ARGS[0] || 0;
put &#34;Type the answer, or quit or exit to end the test.&#34;;


loop {
    my $coefficient = (2..12).pick;
    my $number = $fixednum || (2..12).pick;

    my $answer = prompt ( &#34;$coefficient × $number = &#34; );
    my $rightanswer = $coefficient × $number;

    last if $answer.lc ~~ any @exits;

    if $answer == $rightanswer {
        put &#34;Correct!&#34;;
        %score&lt;correct&gt;++;
    } else {
        put &#34;Sorry, that wasn&#39;t right! The answer is $rightanswer&#34;;
    }
    %score&lt;total&gt;++;
}

if %score&lt;total&gt;:exists {
    my $pc = 100 * %score&lt;correct&gt; / %score&lt;total&gt;;
    put &#34;You scored %score&lt;correct&gt; out of %score&lt;total&gt;, i.e. &#34;, sprintf &#34;%2.2f%%.&#34;, $pc;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Elf Hopper 向其它小精灵解释代码如下。</p>
</div>
<div class="paragraph">
<p>“可爱的小精灵们！这是关于程序如何工作的一些背景知识。</p>
</div>
<div class="paragraph">
<p>我在顶部附近添加了 <code>use v6;</code>，以便代码也可以在 Perl 5下 运行，它将自动使用 Raku 仿真器。</p>
</div>
<div class="paragraph">
<p>您将看到程序在特殊的 <code>@*ARGS</code> 数组的命令行上运行时选择一个可选参数。这是 Perl 5 的 <code>@ARGV</code> 数组的 Raku 等价物。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，数组，数组元素和数组切片总是使用 <code>@</code> sigil，与 Perl 5 不同，其中各个数组元素使用 <code>$</code> sigil。同样，哈希和哈希元素现在总是带有 <code>%</code> sigil，无论是整个哈希，它的切片还是单个元素都在使用。</p>
</div>
<div class="paragraph">
<p>那里还有另一个符号，星号 &#39;twigil&#39;，<code>*</code>。这表明 <code>@*ARGS</code> 是一个动态特殊变量。</p>
</div>
<div class="paragraph">
<p><code>prompt</code> 和 <code>loop</code> 关键字是 Raku 中的新功能，两者都是令人钦佩的名字！</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>prompt</code> 只返回用户输入的值，在本例中为变量。</p>
</li>
<li>
<p><code>loop</code> 是 Raku 的新块控制关键字之一。像这样的简单循环块只是创建了一个无限循环，可以由程序员以显式的方式结束，例如在满足条件时使用 <code>last</code> 关键字;或者例如由用户手动终止程序。</p>
</li>
<li>
<p>或者，循环可以采用三个参数，并且表现得像传统的C风格 <code>for</code> 循环。 （在 Raku 中，小精灵，<code>for</code> 只用于迭代列表或其他容器。）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在循环内部，小精灵，你可以看到范围对象。一切都是 Raku 中的一个对象，所以我可以在范围上调用 <code>pick</code> 方法来返回一个随机数。（好吧，无论如何，这是一个非加密安全的伪随机数！）</p>
</div>
<div class="paragraph">
<p><code>any</code> 关键字将 <code>@exits</code> 数组转换为 Raku 中许多新的有用数据结构之一：一个 <a href="https://rakuadvent.wordpress.com/2009/12/13/">Junction</a>。这使得使用 smartmatch 运算符 <code>~~</code> 直截了当地找到一个数组元素。<code>last</code> 关键字退出循环，如 Perl 5 中所示。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Junction">Junction</a> 是一种新类型的容器或列表，允许进行许多最有用的比较，例如 <code>any</code>，<code>all</code>，<code>one</code> 或 <code>none</code>，我们在 Perl 5 中使用 <code>grep</code> 或 <code>List::Util</code> 等模块进行比较，但它使它们成为可能键入更容易，并允许它们同时执行！这样做的一个副作用是 junction 是无序的：但它们主要是为了产生单个真值或假值，所以通常都可以。如果你想快速想要根据一些特定值的简短列表检查一个值，那么 junction 就很棒。但是如果需要的话，它们还能够让你匹配更大的值集。</p>
</div>
<div class="paragraph">
<p>在最后一个代码段落的顶部，您将看到 <code>:exists</code> 应用于 <code>%score&lt;total&gt;</code> 哈希键。<code>:exists</code> 是一个 Raku 副词！副词通常会修改方法的工作方式。<code>:exists</code> 是下标副词。它是一个副词，因为它改变了读取哈希键时发生的事情：不是返回值，而是查明值是否存在。这通常是使用 Perl 5 类中关注的那些熟悉的已定义方法的更好的替代方法。</p>
</div>
<div class="paragraph">
<p>当然，<code>exists</code> 测试就是为了确保在用户第一次退出程序时不会出现错误。</p>
</div>
<div class="paragraph">
<p>为什么我使用锯齿形符号来引用哈希键？好吧，花括号 <code>{}</code> 是散列键的标准下标运算符，如 Perl 5. 但是，大多数情况下你可能想要使用尖括号/锯齿形符号，因为它们提供单字键的自动引用。用于在 Perl 5 中执行此操作的简单`{}` 括号，但在 Raku 中不再执行此操作。需要引起括号内的字符串。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，放置了用于向终端输出文本的标准命令。这将输出以下列表项，然后是换行符。<code>say</code> 和 <code>print</code> 仍然可用; <code>say</code> 和 <code>put</code> 这两个都打印到标准输出并添加换行符; <code>print</code> 不会追加换行符。</p>
</div>
<div class="paragraph">
<p>如果你使用这个程序以及知道它是如何工作的，小精灵，你将有选择和知识，是否，何时以及如何在你自己的头脑中执行乘法，以及什么时候最好让 Raku -有动力的电脑做它。您的圣诞节作业是让您自己熟悉<a href="https://docs.raku.org/">https://docs.raku.org</a> 上的 Raku 文档。“</p>
</div>
<div class="paragraph">
<p>小精灵开始使用乘法测试程序，试图超越对方以获得最高的完美分数。他们发现它如此令人上瘾，以至于比赛甚至会加时到在学校的最后一天，当时他们应该正在观看’精灵&#39;！</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十二天_构建灵活的_grammar">38. 第十二天 - 构建灵活的 grammar</h2>
<div class="sectionbody">
<div class="paragraph">
<p>圣诞老人夫人写了一个基础的 Grammar，以配合 GDPR 无知精灵从世界各地收集的有关今年 naughty 或 nice 的人的简单列表。</p>
</div>
<div class="paragraph">
<p>每个记录都是一个名称，后跟一个标签，后跟一个地址，然后是一个标签，然后是 naughty 或 nice 的评估，然后用换行符结束。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Batman 1 Batman Street, Gotham Nice
Joker 5 Joker Street, Arkham Naughty
Riddler 12 Riddler Street, Arkham Naughty
Robin 2 Robin Street, Gotham Nice</code></pre>
</div>
</div>
<div class="paragraph">
<p>她希望将 naughty 的人排除在一个列表中，将 nice 的人过滤到另一个列表中，因为 Krampus 将在今年处理所有 naughty 的人。</p>
</div>
<div class="paragraph">
<p>S.夫人用这样的 grammar 开头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar naughty-nice-list {
    token TOP { &lt;details&gt;+ } # Find one or more records made up of name, address, assessment (defined below)

    token details { &lt;name&gt; &lt;address&gt; &lt;assessment&gt; }  # Find the elements from below, in this order

    token name { .*? \t } # Find any characters up to the earliest tab

    token address { .*? \t } # Find any characters up to the earliest tab

    token assessment { Naughty|Nice \n } # Find either &#39;Naughty&#39; or &#39;Nice&#39; followed by a newline
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并在列表上调用它，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">naughty-nice-list.parsefile(&#34;./list.txt&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，当然，她必须做一些事情将细节放入单独的列表中。</p>
</div>
<div class="paragraph">
<p>为此，她创建了一个 action 动作类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class santa-list-actions {
    has %!filtered-lists; # Create a private hash for this class

    method show { return %!filtered-lists } # Create a method to return our hash to the user

    # This method is automatically called when the token with the same name makes a match
    method details ($/) {
        # Create an array of just the name and address matches converted to strings
        my @details.push($&lt;name&gt;.Str, $&lt;address&gt;.Str);
        # Push the @details array into an array accessed with the &#39;Naughty&#39; or &#39;Nice&#39; key
        # Note the curly braces to interpolate { $ } instead of .
        # Otherwise we would get literally what we typed for the hash key.
        %!filtered-lists{ $&lt;assessment&gt;.Str }.push(@details);
    };
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>她这样使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $actions = santa-list-actions.new;
naughty-nice-list.parsefile(&#34;./list.txt&#34;, actions=&gt;$actions); # As Mrs S. called the object &#39;actions&#39;, the same as the keyword, she could write :$actions instead of actions=&gt;$actions
my %hash-naughty-nice = $actions.show;</code></pre>
</div>
</div>
<div class="paragraph">
<p>圣诞老人非常开心，她现在有一个哈希表，其中包含 &#39;Naughty&#39; 和 &#39;Nice&#39; 的键，每个键都包含一系列每个人的详细信息。</p>
</div>
<div class="paragraph">
<p>但是钓鱼洞里总是有一只北极熊爪子，尽管有圣诞老人的保证，来自世界各地的精灵们并不只是 “Naughty” 或 “Nice”。他们用自己的语言说出来！</p>
</div>
<div class="paragraph">
<p>圣诞老人特别问过，但圣诞老人坚持不懈。只有 &#39;Naughty&#39; 或 &#39;Nice&#39;。但有些列表看起来像这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Batman 1 Bat Street, Gotham Nice
Joker 5 Joker Street, Arkham Naughty
Riddler 12 Riddler Street, Arkham Naughty
Robin 2 Robin Street, Gotham Nice
El Gato Negro 1 Gato Street, South Texas Bueno
Victor Mancho 3 Mancho Street, New York City Malo</code></pre>
</div>
</div>
<div class="paragraph">
<p>圣诞老人简单地认为只是对新词进行硬编码，但她知道这不是懒惰的时候。世界各地都有精灵，她需要能够进化的东西。</p>
</div>
<div class="paragraph">
<p>所以，为了现在调用她的脚本，她创建了两个数组并将它们传递给 grammar：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @nice = [&#39;Nice&#39;, &#39;Bueno&#39;];
my @naughty = [&#39;Naughty&#39;, &#39;Malo&#39;];
naughty-nice-list.parsefile(&#34;./list.txt&#34;, args=&gt;(@nice, @naughty), actions=&gt;$actions);</code></pre>
</div>
</div>
<div class="paragraph">
<p>她改变了这样的 grammar 来使用新的数组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar naughty-nice-list {
    token TOP (@*nice-words, @*naughty-words) { &lt;details&gt;+ } # Create dynamic arrays with the passed in arrays, available throughout the grammar
    token details { &lt;name&gt; &lt;address&gt; &lt;assessment&gt; }
    token name { .*? \t }
    token address { .*? \t }
    token assessment { @*naughty-words|@*nice-words \n } # Find either a word from the naughty-words array or from the nice-words array followed by a newline
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是S.太太意识到她现在最终会在她的 action 动作类中的哈希表中创建许多不同的键。 键将是 &#39;Nice&#39;，&#39;Naughty&#39;，&#39;Bueno&#39; 或 &#39;Malo&#39;，因为这些将是 <code>$</code> 可能拥有的匹配单词（未来有更多可能出现）。</p>
</div>
<div class="paragraph">
<p>因此，她进行了另一项更改，为评估令牌命名语法中的潜在匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token assessment { $&lt;Naughty&gt;=@*naughty-words|$&lt;Nice&gt;=@*nice-words \n } # Mrs S. has now added names to the potential matches</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 action 动作类中，必须进行更改以适应这种情况。使用 <code>make</code> 和 <code>made</code>，圣诞老人将存储相应匹配的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class santa-list-actions {
    has %!filtered-lists;

    method show { return %!filtered-lists };

    method details ($/) {
        my @details.push($&lt;name&gt;.Str, $&lt;address&gt;.Str);
        %filtered-lists{ $&lt;assessment&gt;.made }.push(@details); # This will now use the value from &#39;assessment.made&#39; as the key, rather than the match in &#39;assessment.Str&#39;
    };

    method assessment ($/) {
        if $&lt;Naughty&gt; { # If the named pattern &#39;Naughty&#39; matched...
            make &#34;Naughty&#34; # ... set assessment.made to &#34;Naughty&#34;
        } elsif $&lt;Nice&gt;; { # Or if the named pattern &#39;Nice&#39; matched...
            make &#34;Nice&#34; # ... set assessment.made to &#34;Nice&#34;
        };
     };
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦圣诞老人将数据捕获到她自己的哈希中，她就可以轻松地检查出今年已经被马洛的 Victor Mancho 将其列入正确的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %hash-naughty-nice&lt;Naughty&gt;[2][0]; # Produces the output &#39;Victor Mancho&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以现在，圣诞老人可以将 “Naughty” 或 “Nice” 的任何新翻译添加到相关数组，而不会触及 grammar。</p>
</div>
<div class="paragraph">
<p>圣诞老人发现自己对 Raku grammar 的灵活性非常满意。圣诞老人对这个问题的研究起初不那么重要…​…​但是她知道她在确保每个人都能得到一个礼物或者在这个圣诞节的窗户上扔蛋的方法上做得很好。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十三天_使用_cro_和_debian_从头构建_web_服务">39. 第十三天 - 使用 Cro 和 Debian 从头构建 Web 服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我和圣诞老人​​谈过，他说他不知道如何在 <strong>Debian</strong> 上安装 <strong>Cro</strong>，所以我对自己说：我要帮助他。</p>
</div>
<div class="paragraph">
<p>如果您对 <strong>Apache</strong> 等 Web 服务器有一些经验，并且您已经听说过 <strong>Raku</strong> 强大的并发/响应方面，那么您肯定有兴趣了解 <a href="https://cro.services/">Cro 服务</a>。这篇文章的受众是<strong>具有 Debian 基本经验的人</strong>，或者在 <strong>Raku</strong> 新手…​就像圣诞老人一样。</p>
</div>
<div class="paragraph">
<p><strong>Cro</strong> 是一个 <strong>Raku 模块</strong>，它提供了轻松构建反应式和并发服务所需的一切，例如：Web 服务器。</p>
</div>
<div class="paragraph">
<p>在这篇文章中，我们将看到如何在 <strong>Debian</strong> 中安装 <strong>Cro</strong>，这是最受欢迎的 Linux 发行版之一。然后，我将解释 <strong>Cro</strong> 的演示示例。</p>
</div>
<div class="paragraph">
<p>我们将使用 <strong>Debian 9,64 位</strong>（Stretch），我们将在安装后启动它。</p>
</div>
<div class="sect2">
<h3 id="_安装_rakudo_raku_编译器">39.1. 安装 Rakudo Raku 编译器</h3>
<div class="paragraph">
<p><a href="https://rakudo.org/">Rakudo</a> 是 <strong>Cro</strong> 模块运行的当前 <strong>Raku</strong> 编译器。安装 <strong>Rakudo</strong> 的常规方法是安装 <a href="https://rakudo.org/files">Rakudo Star</a>，但我更喜欢快速的方式：<a href="https://github.com/nxadm/rakudo-pkg">rakudo-pkg</a> …​…​怎么样？只需从此 <a href="https://github.com/nxadm/rakudo-pkg#direct-downloads">repo</a> 下载并安装相应的 <strong>Debian 软件包</strong>。在我们的例子中，是来自 <strong>Debian 9, 64位</strong>的 <strong>.deb</strong> 文件。</p>
</div>
<div class="paragraph">
<p>使用 <strong>Debian</strong> 中的 root 用户，我们可以在 root home 中为 <strong>Rakudo</strong> 创建一个包文件夹，进入这个目录，下载 <strong>Debian 9, 64 位</strong>的当前 <strong>Rakudo</strong> 包，并安装它。就我而言：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">mkdir ~/rakudo-packages &amp;&amp; cd $_
wget https://github.com/nxadm/rakudo-pkg/releases/download/v2018.10-02/rakudo-pkg-Debian9_2018.10-02_amd64.deb
dpkg -i rakudo-pkg-Debian9_2018.10-02_amd64.deb</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Rakudo</strong> 运行时编译器和相关工具现在安装在 <strong>/opt/rakudo-pkg</strong> 文件夹中。在 <strong>export PATH</strong> 行之前，让所有用户在 <strong>/etc/profile</strong> 文件中插入以下行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">PATH=$PATH:/opt/rakudo-pkg/bin</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">source /etc/profile</code></pre>
</div>
</div>
<div class="paragraph">
<p>为所有用户重新加载 <strong>Debian</strong> 配置文件。</p>
</div>
<div class="paragraph">
<p>输入 <strong>raku -v</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku -v
This is Rakudo version 2018.10 built on MoarVM version 2018.10
implementing Raku.c.</code></pre>
</div>
</div>
<div class="paragraph">
<p>欢迎来到 <strong>Rakudo Raku!</strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_安装_cro_服务">39.2. 安装 Cro 服务</h3>
<div class="paragraph">
<p><strong>Cro</strong> 是 Raku 模块，<strong>Zef</strong> 是已经安装的当前 <strong>Raku</strong> 模块管理器。我们来安装 <strong>Cro</strong> 吧！</p>
</div>
<div class="paragraph">
<p>首先，我们将安装一些 <strong>Cro 包依赖项</strong>，例如 <strong>git</strong> 来连接和下载来自 Cro 相关存储库的文件，<strong>libssl-dev</strong> 以提供对安全套接字层的支持，<strong>build-essential</strong> 用于构建在安装期间 <strong>Cro</strong> 所使用的一些依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">apt-get install git libssl-dev build-essential</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您位于仅允许 Web 流量（端口80和443）的防火墙下，它将阻止 <strong>git</strong> 协议使用的端口，并且 <strong>Cro</strong> 安装将失败。要避免这种情况，请键入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">git config --global url.&#34;https://&#34;.insteadOf git://</code></pre>
</div>
</div>
<div class="paragraph">
<p>这告诉 <strong>git</strong> 使用 <strong>https</strong> 而不是 <strong>git</strong> 协议来连接 git 远程仓库。</p>
</div>
<div class="paragraph">
<p>现在我们准备用 <strong>Zef</strong>（及其所有依赖项）安装 <strong>Cro</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">zef install cro</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在测试阶段安装失败，请尝试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">zef install --/test cro</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <strong>Cro</strong> 安装正确完成，<strong>Cro</strong> 就准备好了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_cro_实战">39.3. Cro 实战</h3>
<div class="paragraph">
<p>让我们继续演示脚本。创建一个工作区文件夹，输入它并将下面的代码粘贴到名为 <strong>server.p6</strong> 的新文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::HTTP::Router;
use Cro::HTTP::Server;

my $application = route {
  get -&gt; &#39;greet&#39;, $name {
  content &#39;text/plain&#39;, &#34;Hello, $name!&#34;;
  }
}

my Cro::Service $hello = Cro::HTTP::Server.new(:host&lt;0.0.0.0&gt;, :port&lt;10000&gt;, :$application);

$hello.start;

react whenever signal(SIGINT) { $hello.stop; exit; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个脚本有 <strong>4个部分</strong>：</p>
</div>
<div class="paragraph">
<p>“use”使<strong>路由</strong>和<strong>服务</strong>类可用于下面。</p>
</div>
<div class="paragraph">
<p><strong>$application</strong> 是包含我们的 Web 应用程序的路由逻辑的对象，接收数据并将数据从客户端分发到我们的服务器。在这种情况下，<strong>get  →&#39;greet&#39;，$name</strong> 映射来自客户端 Web 浏览器的传入 URL <strong>/greet/Ramiro</strong>，在对象 <strong>$name</strong> 中推送 Ramiro。然后将代码转换为花括号 {}，返回响应 HTTP 请求头 <strong>content &#39;text/plain&#39;</strong> 和 HTTP 请求体 <strong>Hello, Ramiro!</strong> 到客户端 Web 浏览器。在一个严肃的应用程序中，在这部分中将会调用应用程序本身，并且它将等待响应，如示例所示。</p>
</div>
<div class="paragraph">
<p><strong>$hello</strong> 是一个服务对象，它使传入的数据通过新的侦听套接字传递给我们的 <strong>$application</strong>。它有3个参数，<strong>:host&lt;0.0.0.0&gt;</strong> 是服务启动的 localhost, <strong>:port&lt;10000&gt;</strong> 是用于监听传入数据的端口，<strong>$application</strong> 是我们的Web 应用程序。 下面的行 <strong>$hello.start</strong> 开始侦听。</p>
</div>
<div class="paragraph">
<p><strong>react whenever</strong> 等待按下 CTRL-C 时停止 Web 服务。</p>
</div>
<div class="paragraph">
<p>现在是从 shell 运行 Web 服务的时刻：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku server.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在您需要知道服务器主机的当前 IP 地址，尝试使用 <strong>ip addr</strong>。我的 Ip 地址是: <strong>192.168.1.48</strong>。</p>
</div>
<div class="paragraph">
<p>然后，从同一网络中的其他主机，打开 Web 浏览器并键入（在我这儿）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">http://192.168.1.48:10000/greet/Ramiro</code></pre>
</div>
</div>
<div class="paragraph">
<p>答案应该是 <strong>Hello, Ramiro!</strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_4">39.4. 总结</h3>
<div class="paragraph">
<p>从 <strong>Debian</strong> 的新安装开始，我们已经了解了如何安装 <strong>Cro</strong> 并运行演示脚本。现在，您已准备好继续使用 Cro 文档，并发现 <strong>Raku</strong> 可提供的最有前途的并发/异步服务平台。</p>
</div>
<div class="paragraph">
<p>我希望在阅读这篇文章并查看 <a href="https://cro.services/docs">Cro 文档</a>后，圣诞老人可以将他的网站迁移到 Cro Services。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十四天_使用_raku_设计小航天器">40. 第十四天 - 使用 Raku 设计(小)航天器</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_寻找共同点">40.1. 寻找共同点</h3>
<div class="paragraph">
<p>大家好！</p>
</div>
<div class="paragraph">
<p>那些日子我花了一些时间在基础部件上工作，揭示了可能的惊喜，Raku 的 <a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">LDAP（轻量级目录访问协议）</a>实现。</p>
</div>
<div class="paragraph">
<p>然而，现在谈论这个还为时尚早，所以我现在将有一些神秘的封面覆盖这个话题，因为我们有另一个 - 宇宙飞船！</p>
</div>
<div class="paragraph">
<p>航天器和LDAP之间的共同点是：LDAP规范使用一种称为符号的符号 <code>ASN.1</code>，它允许使用特定的文本语法定义抽象类型，并在 `ASN.1`编译器的帮助下，为特定的编程语言创建类型定义，以及什么是更多：此类型值的编码器和解码器，可以将您的值序列化为某些数据，例如，可以通过网络发送并在另一台计算机上很好地解析。</p>
</div>
<div class="paragraph">
<p>通过这种方式，您可以轻松地在应用程序中获得跨平台类型。编码器和解码器可以自动生成，不仅针对某些指定的编码格式，而且针对整个范围的二进制（例如 <code>BER</code>，<code>PER`和其他）和文本（例如`SOAP</code>）编码格式。</p>
</div>
<div class="paragraph">
<p>因此，为了完成工作，我必须至少实现 `ASN.1`Raku中的一些子集- 不是完整的规范，这很大，只关注LDAP规范中使用的功能。</p>
</div>
<div class="paragraph">
<p>“这听起来很有趣，但我们的宇宙飞船在哪里！？”，你可能会问。事实证明，这种 <code>Rocket</code> 类型是您在 <a href="http://asn1-playground.oss.com/">ASN.1 Playground</a> 网站上看到的第一件事，它让您可以免费访问 `ASN.1`编译器，它可以作为参考！</p>
</div>
</div>
<div class="sect2">
<h3 id="_asn_1_和限制">40.2. <code>ASN.1</code> 和限制</h3>
<div class="paragraph">
<p>这是花哨的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">World-Schema DEFINITIONS AUTOMATIC TAGS ::=
BEGIN
  Rocket ::= SEQUENCE
  {
     name      UTF8String (SIZE(1..16)),
     message   UTF8String DEFAULT &#34;Hello World&#34; ,
     fuel      ENUMERATED {solid, liquid, gas},
     speed     CHOICE
     {
        mph    INTEGER,
        kmph   INTEGER
     }  OPTIONAL,
     payload   SEQUENCE OF UTF8String
  }
END</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们快速浏览一下这个定义：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Rocket</code> 是一个 <code>SEQUENCE</code>  - 一组某类型的有序值，可以看作是异构列表/数组或类。</p>
</li>
<li>
<p>场 <code>name</code> 和 <code>message</code> 有 <code>UTF8String</code> 型，这是肯定的，一种字符串表示的 <code>ASN.1</code>。字段name已应用长度限制，<code>(SIZE(1..16))</code> 和 <code>message</code> 具有指定的默认值 <code>DEFAULT &#34;Hello World&#34;</code>。</p>
</li>
<li>
<p>字段 <code>fuel`有 `ENUMERATED</code> 类型：它只是一个可供选择的标签枚举。</p>
</li>
<li>
<p>字段 <code>speed</code> 是一个 <code>CHOICE</code>，它是一种特殊类型，它描述了一个字段，该值可以是指定类型之一。不同的是 <code>ENUMERATED</code>，价值不仅仅是标签。<code>OPTIONAL</code> 如你所知，关键字意味着如果不存在，该字段可能会被省略。</p>
</li>
<li>
<p>字段 <code>payload</code> 是一个 <code>SEQUENCE</code>，但指定了类型。这意味着我们可以根据需要在这里拥有尽可能多的 <code>UTF8String</code> 值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这里我们将应用两个重要的限制：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们将使用 <code>Basic Encoding Rules（BER）</code> - 将 `ASN.1`类型编码指定为特定字节序列的规则。如上所述，有不同的格式，但我们将使用这一种。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Basic Encoding Rules</code> 标准是基于一个所谓的“TLV编码”的事情-的类型的值被编码为字节序列表示：“ Ť AG”，“ 大号 ength”和“ V传递类型的某些值的ALUE”。让我们更仔细地看一下…​…​以相反的顺序！</p>
</div>
<div class="paragraph">
<p>“值”是包含值的字节表示的部分。每种类型都有自己的编码模式（例如，<code>INTEGER</code> 编码方式不同 <code>UTF8String</code>）。</p>
</div>
<div class="paragraph">
<p>“长度”是表示“值”部分中的字节数的数字。这允许我们很好地处理增量解析（通常也是！）。它也可以具有“未知”值，这允许我们以未知的长度流式传输数据，但我们将把它放在一边。</p>
</div>
<div class="paragraph">
<p>“标签”简单地说是一个字节或一些字节，我们可以用它来确定我们手头有什么类型。其确切值由标记规则的数量（“标记模式”）确定，并且存在好的或更差的不同模式。</p>
</div>
<div class="paragraph">
<p>并且，如果您已经等待某些段落的第二个限制，那么它是：</p>
</div>
<div class="paragraph">
<p>我们将 <code>IMPLICIT</code> 在这里使用 BER 的类型标记模式。正如您所猜测的那样，<code>EXPLICIT</code> 标记模式也同时存在 <code>AUTOMATIC</code>（在上面的 Rocket 示例中使用）。</p>
</div>
<div class="paragraph">
<p>考虑到这一点，我们需要将 <code>ASN.1</code> 上面的类型更改为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">World-Schema DEFINITIONS IMPLICIT TAGS ::=
BEGIN
  Rocket ::= SEQUENCE
  {
     name      UTF8String (SIZE(1..16)),
     message   UTF8String DEFAULT &#34;Hello World&#34; ,
     fuel      ENUMERATED {solid, liquid, gas},
     speed     CHOICE
     {
        mph   [0] INTEGER,
        kmph  [1] INTEGER
     }  OPTIONAL,
     payload   SEQUENCE OF UTF8String
  }
END</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>IMPLICIT TAGS</code> 用于代替字段中的 <code>AUTOMATIC TAGS</code> 和 <code>[$n]</code> 字符串 <code>speed</code>。</p>
</div>
<div class="paragraph">
<p>如果你看一下这个模式，事实证明，这是，其实，暧昧，因为 <code>mph</code> 和 <code>kmph</code> 都有 <code>INTEGER</code> 型。因此，如果我们 <code>INTEGER</code> 从字节流中读取了一个，它是 <code>mph</code> 值还是 <code>kmph</code> 值？如果我们谈论宇宙飞船，它会产生巨大的变化！</p>
</div>
<div class="paragraph">
<p>为了避免这种混淆，使用了特殊的标签，这里我们指定了我们想要的标签，因为与 <code>AUTOMATIC</code> 模式不同，<code>IMPLICIT</code> 它不适用于我们。</p>
</div>
</div>
<div class="sect2">
<h3 id="_逐步建设问题答案">40.3. 逐步建设。问题答案。</h3>
<div class="paragraph">
<p>那么，我们可以用 Raku 中的所有功能做什么呢？虽然编译器可能很有趣，但是可以通过可扩展的方式编译成 Raku，并且包含了奇特的功能？必须有一些更简单的东西。</p>
</div>
<div class="paragraph">
<p>比方说，我们有一个适用于航天器的脚本。当然，我们需要一个类型来表示一个，特别是一个类，让我们称之为 <code>Rocket</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class  Rocket {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，我们想知道一些有关它的数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Rocket {
    has $.name;
    has $.message is default(&#34;Hello World&#34;);
    has $.fuel;
    has $.speed;
    has @.payload;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们必须使我们的 <code>Rocket</code> 定义更明确，那么我们指定一些类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Fuel &lt;Solid Liquid Gas&gt;;

class Rocket {
    has Str $.name;
    has Str $.message is default(&#34;Hello World&#34;);
    has Fuel $.fuel;
    has $.speed;
    has Str @.payload;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在它开始提醒我们一些事情…​…​</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Str</code> 类似 <code>UTF8String</code>，只是我们不能离开它这样，因为 <code>ASN.1`我们不仅有 `UTF8String</code>，而且 <code>BIT STRING</code>，<code>OCTET STRING</code> 和其他字符串类型。</p>
</li>
<li>
<p><code>Fuel</code> 枚举类似于 <code>ENUMERATED</code> 类型。</p>
</li>
<li>
<p><code>@.payload</code> 中的 <code>@</code> 符号告诉我们，这将是一个序列，而且 <code>Str</code> 指定其元素的类型。</p>
</li>
<li>
<p>但是虽然有一些类似的观点，但从我们 `ASN.1`的观点来看，我们没有足够的数据。让我们一步一步解决这些问题！</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>我们怎么知道这完全Rocket是 `ASN.1`序列类型？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>通过应用角色：<code>class Rocket does ASNSequence</code>。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>我们怎么知道确切的字段顺序？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>通过实现此角色的存根方法：<code>method ASN-order { &lt;$!name $!message $!fuel $!speed @!payload&gt; }</code></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>我们怎么知道这 <code>$.speed</code> 是可选的？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>我们只是应用它的特征！<a href="https://docs.raku.org/language/traits">Traits</a> 允许我们在代码部分上执行自定义代码，特别是 <code>Attributes</code>。例如，虚构的API可以是这样的：<code>has $.speed is optional</code>。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>我们怎么知道 $.speed 是多少？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>由于 <code>CHOICE</code> 类型是“特殊的”，但仍然是一流的（例如，你可以使它递归），我们需要在这里发挥作用：<code>ASNChoice</code> 来救援。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="literalblock">
<div class="content">
<pre>我们怎么知道 `ASN.1`我们的 Str 类型是什么类型的字符串？</pre>
</div>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>我们来写吧 <code>has Str $.name is UTF8String;</code>。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>我们如何指定字段的默认值？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>虽然 Raku 已经具有内置 <code>is default</code> 特性，但对我们来说不好的是我们无法“很好地”检测到它。因此，我们必须引入另一个自定义特征，以满足我们的目的并应用内置特征：<code>has Str $.message is default-value(&#34;Hello World&#34;);</code></p>
</div>
<div class="paragraph">
<p>让我们在一个包中回答所有这些问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role ASNSequence { #`[ Elves Special Magic Truly Happens Here ] }

role ASNChoice { #`[ And even here ]  }

class SpeedChoice does ASNChoice {
    method ASN-choice() {
        # Description of: names, tags, types specificed by this CHOICE
        { mph =&gt; (0 =&gt; Int), kmph =&gt; (1 =&gt; Int) }
    }
}

class Rocket does ASNSequence {
    has Str $.name is UTF8String;
    has Str $.message is default-value(&#34;Hello World&#34;) is UTF8String;
    has Fuel $.fuel;
    has SpeedChoice $.speed is optional;
    has Str @.payload is UTF8String;

    method ASN-order { &lt;$!name $!message $!fuel $!speed @!payload&gt; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>值可能类似于：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $rocket = Rocket.new(
    name =&gt; &#39;Falcon&#39;,
    fuel =&gt; Solid,
    speed =&gt; SpeedChoice.new((mph =&gt; 18000)),
    payload =&gt; [ &#34;Car&#34;, &#34;GPS&#34; ]);</code></pre>
</div>
</div>
<div class="paragraph">
<p>答案越多，问题就越多</p>
</div>
<div class="paragraph">
<p>对于这个微小的例子（另一方面，它已经 `ASN.1`展示了许多特性），实际上，我们需要在我们的应用程序中使用这个类的实例，并可能根据需要对其进行编码和解码。</p>
</div>
<div class="paragraph">
<p>那么精灵们对我们的数据秘密做了什么？让我们在下一篇文章中找到答案！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十五天_使用_raku_构建小型航天器">41. 第十五天 - 使用 Raku 构建(小型)航天器</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_炫耀长耳朵">41.1. 炫耀长耳朵</h3>
<div class="paragraph">
<p>在<a href="https://rakuadvent.wordpress.com/2018/12/14/designing-a-space-ship-with-perl-6/">上一篇文章</a>中，我们遇到了某种特殊精灵的魔力：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Fuel &lt;Solid Liquid Gas&gt;;

class SpeedChoice does ASNChoice {
    method ASN-choice { { mph =&gt; (1 =&gt; Int), kmph =&gt; (0 =&gt; Int) } }
}

class Rocket does ASNSequence {
    has Str $.name is UTF8String;
    has Str $.message is default-value(&#34;Hello World&#34;) is UTF8String;
    has Fuel $.fuel;
    has SpeedChoice $.speed is optional;
    has Str @.payload is UTF8String;

    method ASN-order { &lt;$!name $!message $!fuel $!speed @!payload&gt; }
}

my $rocket = Rocket.new(
    name =&gt; &#39;Falcon&#39;,
    fuel =&gt; Solid,
    speed =&gt; SpeedChoice.new((mph =&gt; 18000)),
    payload =&gt; [ &#34;Car&#34;, &#34;GPS&#34; ]);

my $rocket-bytes = ASN::Serializer.serialize($rocket, :mode(Implicit));

#`[ Result:
      Blob.new(
          0x30, 0x1B, # Outermost SEQUENCE
          0x0C, 0x06, 0x46, 0x61, 0x6C, 0x63, 0x6F, 0x6E, # NAME, MESSAGE is missing
          0x0A, 0x01, 0x00, # ENUMERATED
          0x81, 0x02, 0x46, 0x50, # CHOICE
          0x30, 0x0A, # SEQUENCE OF UTF8String
              0x0C, 0x03, 0x43, 0x61, 0x72,  # UTF8String
              0x0C, 0x03, 0x47, 0x50, 0x53); # UTF8String
]

say ASN::Parser.new(:type(Rocket)).parse($rocket-bytes) eqv $rocket; # Certainly true!</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类型类型类型">41.2. 类型，类型，类型</h3>
<div class="paragraph">
<p>有些事情是不言而喻的（或者对于我来说，用了无数个小时来看精灵如何玩魔法）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># 1
role ASNSequence {
    # every descendant has to fulfill this important vow!
    method ASN-order {...}
}

# 2
role ASNChoice {
    has $.choice-value;

    # if you have to choose, choose wisely!
    method ASN-choice() {...}
    method ASN-value() { $!choice-value }

    method new($choice-value) { $?CLASS.bless(:$choice-value) }
}

# 3
role ASN::StringWrapper {
    has Str $.value;

    # Don&#39;t do this at home. :]
    method new(Str $value) { self.bless(:$value) }
}

# UTF8String wrapper
role ASN::Types::UTF8String does ASN::StringWrapper {}

# Yes, it is _this_ short
multi trait_mod:(Attribute $attr, :$UTF8String) is export { $attr does ASN::Types::UTF8String }</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>第一个是一个简单的角色，它允许我们强制执行 <code>ASN-order</code> 方法</p>
</li>
<li>
<p>第二个是持有 CHOICE 实际值的角色，并强制执行用户必须描述可能选项的方法</p>
</li>
<li>
<p>第三个描述了一个特性，如 <code>is UTF8String</code>，它为属性添加一个角色，这将在以后帮助我们，并提供角色本身以及一些包装代码</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>与第三部分表达的方式相同，可以表达 <code>OPTIONAL</code>，<code>DEFAULT</code> “traits”和其他字符串类型。</p>
</div>
</div>
<div class="sect2">
<h3 id="_进步进化序列化">41.3. 进步，进化，序列化！</h3>
<div class="paragraph">
<p>通过一系列规则可以做什么来序列化事物？鉴于 <code>Basic Encoding Rules</code> 对不同类型的值有不同的处理方式（如果你思考一下就不会觉得太奇怪！）以及一个类型可以嵌套在另一个类型中的事实，更不用说是递归的了？我觉得它可能不太难实现。 Raku 的 multi-dispatch 正派上用场！</p>
</div>
<div class="paragraph">
<p>一般来说，事情如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class ASN::Serializer {
    ...

    # like this:
    multi method serialize(ASNSequence $sequence, Int $index = 48, :$debug, :$mode = Implicit) { ... }

    # or this:
    multi method serialize(Int $int is copy where $int.HOW ~~ Metamodel::ClassHOW, Int $index = 2, :$debug, :$mode) { ... }
    multi method serialize($enum-value where $enum-value.HOW ~~ Metamodel::EnumHOW, Int $index = 10, :$debug, :$mode) { ... }

    # or even this:
    multi method serialize(Positional $sequence, Int $index is copy = 16, :$debug, :$mode) { ... }

    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>描述该领域所有内容的规则是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于复杂类型，必须引入一个 <strong>has</strong>，如 <code>ASNStructure</code>，迭代其内容，逐个序列化内部，并正确加入它。在一天结束时，对于每个这样的 <code>Serializer</code> 程序都具有已知的属性类型或者可以基于特征应用的角色（方便！）推断它，可以具有属性的值（或者如果属性是可选的并且可以省略则可以跳过该属性） ，可以包装/解包基于 <code>Str</code> 的类型 - 所有这些都允许一个序列化类型</p>
</li>
<li>
<p>对于简单类型，可以根据给定的规则对其进行序列化</p>
</li>
<li>
<p>对于一些方便的“特殊情况”，例如像 <code>@.foo</code> 那样的属性，需要推断发生了什么（在这种情况下，它将是 <code>SEQUENCEOF</code> 类型）并正确地序列化它</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>除了带有值的第一个参数外，还有三个参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>$index</code> 整数派上用场，特别是对于 BER 特定的索引</p>
</li>
<li>
<p><code>$debug</code> flag 启用调试输出（当调试一些二进制协议时，这非常有用！）</p>
</li>
<li>
<p>将来可能会使用 <code>$mode</code> 值来支持 <code>IMPLICIT</code> 以外的标记模式。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_如果有时间进行编码总会有时间进行解码">41.4. 如果有时间进行编码，总会有时间进行解码</h3>
<div class="paragraph">
<p>什么是解析器？如果序列化程序是“向后解析器”，那么解析器就是…​…​是的，它是一个向后的序列化器！但是这是什么意思？通常，序列化器接收一些 A 并产生一些给定形式的 B。并且解析器获取给定形式的一些 B 并产生一些 A。</p>
</div>
<div class="paragraph">
<p>假设有人知道正在解析的确切类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $parser = ASN::Parser.new(type =&gt; Rocket);
say $parser.parse($rocket-ber); # Yes, here goes our rocket!</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要解析此 <code>Buf</code> 内容，则必须指定其类型，就像下面这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method parse(Blob $input, ...) {
    ...
    self.parse($input, $!type, ...);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个方法不知道它所解析的类型，但它调用了它的朋友：<code>parse($input, SomeCoolType, …​)</code> 超出了传递的内容和它可以得到的类型。如果知道了类型，多重分派将很乐意为我们提供必要的解析实现。对于简单的类型。对于复杂的类型。对于“特殊”类型。有了 Raku，任何一天都会发生便利的奇迹！</p>
</div>
<div class="paragraph">
<p>让我们再看一眼：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Details and basic indentation are omitted for clarity

...

multi method parse(Buf $input is rw, ASNSequence $type, :$debug, :$mode) {
    # `$type` here is, really, not a value, but a Type Object. As `ASN-order` is defined on
    # type, there are no problems with gathering necessary info:
    my @params = do gather {
        for $type.ASN-order.kv -&gt; $i, $field {
            # Here be dragons! Or, rather, MOP is used here!
        }
    }
    # A-a-and a ready object of a type our parser has no clue about is returned.
    # Yes, it is kind of neat. :)
    $type.bless(|Map.new(@params));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上，更简单的类型更简单，就像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method parse(Buf $input is rw, $enum-type where $enum-type.HOW ~~ Metamodel::EnumHOW, :$debug, :$mode) {
    say &#34;Parsing `$input[0]` out of $input.perl()&#34; if $debug;
    $enum-type($input[0]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，必须保持规则，以表明错误，并做各种“无聊”的事情，而不是“必要”的事情。虽然 Raku 允许我们在这个区域使用一些不错的技巧，但在圣诞节前看它并不是太感兴趣。</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_oclock_supply_oclock">41.5. What o’clock? Supply o’clock!</h3>
<div class="paragraph">
<p>如果你已经厌倦了所有这些与 <code>ASN.1</code> 相关的东西，我有一个好消息：它已经快结束了。 \O/</p>
</div>
<div class="paragraph">
<p>虽然所有这些“类型是我的一等公民而我很酷”技巧很有趣，但还有一个技巧可以展示，虽然是相关的，但却有点完全不同。</p>
</div>
<div class="paragraph">
<p><code>ASN.1</code> 解析器应该是增量的。更重要的是，它必须是非常明确的，因为人们可以使用未知长度的值。可以做些什么来快速使我们的解析器增量？我们快点做吧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class ASN::Parser::Async {
    has Supplier::Preserving $!out = Supplier::Preserving.new;
    has Supply $!values = $!out.Supply;
    has Buf $!buffer = Buf.new;
    has ASN::Parser $!parser = ASN::Parser.new(type =&gt; $!type);
    has $.type;

    method values(--&gt; Supply) {
        $!values;
    }

    method process(Buf $chunk) {
        $!buffer.append: $chunk;
        loop {
            # Minimal message length
            last if $!buffer.elems &lt; 2;
            # Message is incomplete, good luck another time
            last unless $!parser.is-complete($!buffer);
            # Cut off tag, we know what it is already in this specific case
            $!parser.get-tag($!buffer);
            my $length = $!parser.get-length($!buffer);
            # Tag and length are already cut down here, take only value
            my $item-octets = $!buffer.subbuf(0, $length);
            $!out.emit: $!parser.parse($item-octets, :!to-chop); # `!to-chop`, because &#34;prefix&#34; is already cut
            $!buffer .= subbuf($length);
        }
    }

    method close() {
        $!out.done;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它可以像这样使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $parser = ASN::Parser::Async.new(type =&gt; Rocket);

$parser.values.tap({ say &#34;I get a nice thing!&#34;; });

react {
    whenever $socket.data-arrived -&gt; $chunk {
        $parser.process($chunk);
        LAST { $parser.close; }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是所有必须添加的，以使这种 <code>Parser</code> 增量为这个最小的情况。</p>
</div>
<div class="paragraph">
<p>当然，正如你可以猜到的那样，我正在写的东西有点过于具体，不仅仅是我的想象力，不仅是精灵，而是一群完整的冒险者（他们也可以处理一些二进制的东西！）。该实现已在 <a href="https://github.com/Altai-man/ASN-BER">ASN::BER 仓库</a>中提供。虽然它可能是一个非常早期的 alpha 版本，有许多东西甚至还没有计划好，并且有很长的篇幅可以用来改善这个模块的整体状态，它已经对我有用了解我的工作前面提到的半秘密。仓库肯定会打开建议，错误报告（甚至可能是 hug 报告），因为还有大量工作要做，但这是另一个故事了。</p>
</div>
<div class="paragraph">
<p>祝您度过愉快的一天，并确保在圣诞假期休息好！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十六天_检查你的列表俩次">42. 第十六天 - 检查你的列表俩次</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_从命令行了解_raku">42.1. 从命令行了解 Raku</h3>
<div class="paragraph">
<p>这是 Sniffles the Elf 的大好机会！在丝带矿山经过多年的苦差事后，他们终于被提升到了清单管理部门。作为一名闪亮的新助理尼斯名单审核员，Sniffles 正在走向重要时刻。</p>
</div>
<div class="paragraph">
<p>在 Sniffles 到达的第一天，他们的新老板格伦布尔先生正等着他。“好人清单管理很麻烦，当有人在服务器上洒了牛奶和饼干时，我们的数据被意外删除了。我们一直在忙着检查列表，我们忘了检查备份！现在我们必须从头开始重建一切！裁员后，我们有点人手不足，所以由你来挽救这一天。“</p>
</div>
<div class="paragraph">
<p>Sniffles，特别勤劳，津津乐道于这个问题。经过一些研究，他们意识到他们需要的所有数据都可用，他们只需要收集它。</p>
</div>
<div class="paragraph">
<p>他们的朋友在丝带矿山中，一位名叫 Hermie 的自称口述历史学家一直在谈论 Raku 有多么伟大。Sniffles 决定尝试一下。</p>
</div>
</div>
<div class="sect2">
<h3 id="_就像拔牙">42.2. 就像拔牙?</h3>
<div class="paragraph">
<p>Sniffles 首先用一种新语言抛出标准的第一个脚本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.d;

say &#34;Nice List restored!!!&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该脚本运行并尽职尽责地打印出消息。距离圣诞节还有几天了，是时候认真对待 <a href="https://docs.raku.org/">Raku文档</a>了。</p>
</div>
<div class="paragraph">
<p>稍微浏览一下 Sniffles 的 <a href="https://docs.raku.org/language/create-cli">Raku 命令行界面实用程序</a> 页面。他们喜欢它描述的 <code>MAIN</code> 这个特殊子程序的外观。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;Started initializing nice lister.&#39;;
sub MAIN() { say &#34;Nice List restored!!!&#34; }
say &#39;Finished initializing nice lister.&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Started initializing nice lister.
Finished initializing nice lister.
Nice List restored!!!</pre>
</div>
</div>
<div class="paragraph">
<p>好吧，至少那是他们的启动代码。Sniffles 抛弃了初始化消息，它们只是噪音。但他们确信这个 <code>MAIN</code> 函数必须有更多的技巧才能让 Hermie 如此兴奋。</p>
</div>
<div class="paragraph">
<p>回到文档…​检查了<a href="https://learnxinyminutes.com/docs/raku/">Y分钟学会X语言的 Raku 页面</a>。<code>MAIN</code> 接近尾声的额外部分是金矿！Sniffles 对这个念头打了个寒颤。</p>
</div>
<div class="paragraph">
<p>“好的，所以如果我们提供 <code>MAIN子</code> 程序签名，Raku 会为我们处理命令行解析。更好的是，它会自动生成帮助内容，“他们对自己嘟囔道。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN (
    :$list-of-all-kids,
    :$naughty-list
) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ nice-list
Usage:
  nicelist [--list-of-all-kids=&lt;Any&gt;] [--naughty-list=&lt;Any&gt;]</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行脚本得到：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Stub code executed
  in sub MAIN at foo line 1
  in block &lt;unit&gt; at foo line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>真棒。</p>
</div>
<div class="paragraph">
<p>但是开关名称有点长。由于 TheNorthPole.io 是一个专门的商店，Sniffles 认为他们可能不得不输入一堆。呸。如果您可以添加一些解释性文字，更短的名称将没有问题。Raku 支持使用 POD6 标记进行文字编程，因此可以轻松添加注释。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| Rebuild the Nice List
sub MAIN (
    :$all,    #= path to file containing the list of all children
    :$naughty #= path to file containing the Naughty List
) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Usage:
  nicelist [--all=&lt;Any&gt;] [--naughty=&lt;Any&gt;] -- Rebuild the Nice List

    --all=&lt;Any&gt;        path to file containing the list of all children
    --naughty=&lt;Any&gt;    path to file containing the Naughty List</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sniffles 印象深刻，但他们知道参数验证是编写 CLI 的另一部分，可能会变得乏味。“Raku 最近为我做了什么？”他们想知道。</p>
</div>
</div>
<div class="sect2">
<h3 id="_一种强大的沉默的类型">42.3. 一种强大的，沉默的类型</h3>
<div class="paragraph">
<p>Raku 有一个渐进式<a href="https://docs.raku.org/language/typesystem">类型系统</a>，包括编译和运行时类型检查。渐进类型允许 Sniffles 到目前为止忽略类型检查。他们添加了一些类型，看看发生了什么。</p>
</div>
<div class="paragraph">
<p>Sniffles 使用<a href="https://docs.raku.org/type/Signature#Constraining_argument_definiteness">类型 smiley</a>定义了 Str 的子集，该类型使用 <a href="https://docs.raku.org/type/Whatever">whatevercode</a> 来验证给定路径上是否存在文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset FilePath of Str:D where *.IO.f;

#| Rebuild the Nice List
sub MAIN (
    FilePath :$all,    #= path to file containing the list of all children
    FilePath :$naughty #= path to file containing the Naughty List
) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>他们运行这个脚本:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$nice-list  --naughty=naughty.kids --all=notAFile.bleh
Usage:
  nice-list [--all=&lt;FilePath&gt;] [--naughty=&lt;FilePath&gt;] -- Rebuild the Nice List</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>--all=&lt;FilePath&gt;        path to file containing the list of all children
--naughty=&lt;FilePath&gt;    path to file containing the Naughty List</pre>
</div>
</div>
<div class="paragraph">
<p>Sniffles 在没有争论和其他一些无效方式的情况下再次运行脚本。每次捕获无效输入并自动显示使用消息。 “非常好，”Sniffles 想道，“事实上，错误报告仍然很糟糕。如果你抛出一个参数就好像传入一个丢失的文件一样，你会得到相同的结果。”</p>
</div>
</div>
<div class="sect2">
<h3 id="_精灵类型不匹配_弥补改进的错误处理">42.4. 精灵类型不匹配 - 弥补改进的错误处理</h3>
<div class="paragraph">
<p>&#34;Ugh! How do I get around <strong>this</strong> problem?&#34; Sniffles shuffled around the docs some more.  <a href="https://docs.raku.org/syntax/multi">Multiple Dispatch</a> and <a href="https://docs.raku.org/type/Signature#index-entry-slurpy_argument">slurpy parameters</a>.  They added another subset and a couple of new definitions of MAIN:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset FileNotFound of Str:D where !*.IO.f();

multi sub MAIN (
    FilePath :$all,    #= path to file containing the list of all children
    FilePath :$naughty #= path to file containing the Naughty List
) { ... }

multi sub MAIN (
    FileNotFound :$all,
    *%otherStuff
) {
    die &#34;List of all children file does not exist&#34;;
}

multi sub MAIN (
    FileNotFound :$naughty,
    *%otherStuff
) {
    die &#34;Naughty List file does not exist&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>他们得到了:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Usage:
  nice-list [--all=&lt;FilePath&gt;] [--naughty=&lt;FilePath&gt;] -- Rebuild the Nice List
  nice-list [--all=&lt;FileNotFound&gt;] [--naughty=&lt;FilePath&gt;]
  nice-list [--all=&lt;FilePath&gt;] [--naughty=&lt;FileNotFound&gt;]</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>--all=&lt;FilePath&gt;        path to file containing the list of all children
--naughty=&lt;FilePath&gt;    path to file containing the Naughty List</pre>
</div>
</div>
<div class="paragraph">
<p>哪个工作完美…​除了现在他们在使用中有错误生成条目！双翘。Sniffles返回到CLI界面上的文章。将正确的特征添加到MAIN潜艇将使它们从自动生成的使用中消失：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN (
    FileNotFound :$all,
    *%otherStuff
) is hidden-from-USAGE {
    die &#34;List of all children file does not exist&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一团糟不见了！</p>
</div>
</div>
<div class="sect2">
<h3 id="_我们不会去直到我们得到一些">42.5. 我们不会去，直到我们得到一些！</h3>
<div class="paragraph">
<p>Grumble 先生走了过来，他停下来看着 Sniffles 的屏幕。“那里有趣的工作，Sniffles。我们需要那个脚本，我们昨天需要它。哦，我们需要它能够审核现有的 Nice List 并重建一个。我们也需要这个。看到你。“在Sniffles眨眼之前他消失了。</p>
</div>
<div class="paragraph">
<p>Sniffles 认为，做一个爬行的功能比被迫吃无花果布丁更好。他们添加了这些命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| Rebuild the Nice List
multi sub MAIN (
    &#39;build&#39;,
    FilePath :$all,    #= path to file containing the list of all children
    FilePath :$naughty #= path to file containing the Naughty List
) { ... }

#| Compare all the lists for correctness
multi sub MAIN (
    &#39;audit&#39;,
    FilePath :$all,     #= path to file containing the list of all children
    FilePath :$naughty, #= path to file containing the Naughty List
    FilePath :$nice,    #= path to file containing the Nice List
) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>“好极了，”他们想，“但你必须像这样运行脚本 <code>nicelist --all=foo --naughty=bar build</code>。可怕。”</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %*SUB-MAIN-OPTS =
    :named-anywhere,    # allow named variables at any location
;</code></pre>
</div>
</div>
<div class="paragraph">
<p>“它被修复了！” Sniffles 在座位上跳起来了。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Usage:
  nicelist build [--all=&lt;FilePath&gt;] [--naughty=&lt;FilePath&gt;] -- Rebuild the Nice List
  nicelist audit [--all=&lt;FilePath&gt;] [--naughty=&lt;FilePath&gt;] [--nice=&lt;FilePath&gt;] -- Compare all the lists for correctness</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>--all=&lt;FilePath&gt;        path to file containing the list of all children
--naughty=&lt;FilePath&gt;    path to file containing the Naughty List
--nice=&lt;FilePath&gt;       path to file containing the Nice List</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_跑步者走上了这条路">42.6. 跑步者走上了这条路。</h3>
<div class="paragraph">
<p>好的，现在 Sniffles 拥有一个完美的框架来构建一个优秀的实用程序脚本。是时候实际写出实际的东西了。Sniffles 知道他们真的打算雪橇这个项目。</p>
</div>
<div class="paragraph">
<p>很快，Snuffles发现Raku的功能集帮助他们制作了一个功能强大，正确的脚本。他们创建了一个 Child <a href="https://docs.raku.org/language/classtut">类</a>，在其上<a href="https://docs.raku.org/language/mop#index-entry-syntax_WHICH-WHICH">定义了身份操作</a>，编写了一个用于加载列表数据的简洁 CSV 解析器和一个报告函数。内置的 <a href="https://docs.raku.org/type/Set">Set 数据类型</a>提供了操作符，可以轻松查找不合适的条目，甚至更容易重建 Nice List。</p>
</div>
<div class="paragraph">
<p>一旦<a href="https://gist.github.com/daotoad/47bcbc6f1dc066fff982a72481c6bcd2">完成</a>，他们就恢复了 Nice List，并向 Grumbles 先生及其他团队发送了一封部门电子邮件，宣布他们取得了成功。当格罗布尔斯先生看到脚本有多好，它的用法和错误检查，仅此一次，他辜负了他们的期望。</p>
</div>
<div class="paragraph">
<p>为了表彰他们的辛勤工作和机智，Sniffles 被要求在圣诞老人最新工作室的开幕处剪彩。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第17天_通往幸福的编译之路">43. <a href="https://rakuadvent.wordpress.com/2018/12/17/day-17-compiling-our-way-to-happiness/">第17天 - 通往幸福的编译之路</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果我们选择接受它，我们的任务就是解决`SEND + MORE = MONEY`代码中的问题。不，请等一下，让我这样说吧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">    S E N D
+   M O R E
-----------
  M O N E Y</code></pre>
</div>
</div>
<div class="paragraph">
<p>它意味着相同，但是这样放置它更具<a href="https://en.wikipedia.org/wiki/Carry_(arithmetic">视觉冲击力</a>)，特别是因为我们很多人在学校这样做了。</p>
</div>
<div class="paragraph">
<p>基本规则很简单。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每个字母代表0到9之间的数字。</p>
</li>
<li>
<p>字母代表*不同的*数字; 两个字母可能不共享相同的数字。</p>
</li>
<li>
<p>前导数字（在我们的拼图中，<code>S</code> 和 <code>M</code>）不能为零。如果为零他们就不会是前导数字！</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>鉴于这些限制因素，上述难题有一个独特的解决方案。</p>
</div>
<div class="paragraph">
<p>我鼓励你找到解决方案。写一点代码，坚持一下！在这篇文章中，我们会这样做，但后来（关键）*不满足*于此，并最终陷入嵌套玩偶的情况，其中代码编写代码直到出现真正整洁的东西。结论将拼出最终目标-坚持不住了，我被实时地通过多个委员会获悉，正确的说法是“ *一个*终极愿景” -为了 Raku。</p>
</div>
<div class="paragraph">
<p>我们开工吧。</p>
</div>
<div class="sect2">
<h3 id="_marcus_junius_brute_forcethe_younger">43.1. Marcus Junius Brute Force（The Younger）</h3>
<div class="paragraph">
<p>我们当天的第一语言及其相应的解决方案是 Raku 本身。这里没有技巧; 我们只是像愤怒的公牛一样向问题域冲去，尝试一切。事实上，我们确保不要在这个问题上耍小聪明，只是尝试尽可能直接地表达解决方案。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 0..9 -&gt; int $d {
    for 0..9 -&gt; int $e {
        next if $e == $d;

        my int $y = ($d + $e) % 10;
        my int $_c1 = ($d + $e) div 10;

        for 0..9 -&gt; int $n {
            next if $n == $d;
            next if $n == $e;
            next if $n == $y;

            for 0..9 -&gt; int $r {
                next if $r == $d;
                next if $r == $e;
                next if $r == $y;
                next if $r == $n;

                next unless ($_c1 + $n + $r) % 10 == $e;
                my int $_c2 = ($_c1 + $n + $r) div 10;

                for 0..9 -&gt; int $o {
                    next if $o == $d;
                    next if $o == $e;
                    next if $o == $y;
                    next if $o == $n;
                    next if $o == $r;

                    next unless ($_c2 + $e + $o) % 10 == $n;
                    my int $_c3 = ($_c2 + $e + $o) div 10;

                    for 1..9 -&gt; int $s {
                        next if $s == $d;
                        next if $s == $e;
                        next if $s == $y;
                        next if $s == $n;
                        next if $s == $r;
                        next if $s == $o;

                        for 1..9 -&gt; int $m {
                            next if $m == $d;
                            next if $m == $e;
                            next if $m == $y;
                            next if $m == $n;
                            next if $m == $r;
                            next if $m == $o;
                            next if $m == $s;

                            next unless ($_c3 + $s + $m) % 10 == $o;
                            my int $_c4 = ($_c3 + $s + $m) div 10;

                            next unless $_c4 % 10 == $m;

                            say &#34;$s$e$n$d + $m$o$r$e == $m$o$n$e$y&#34;;
                        }
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你又看到了，它不*漂亮*，但它起作用了。这是你母亲警告你的那种缩进程度。不过，如果你问我，我更讨厌缩进。对于我们需要扫描其搜索空间的每个变量，我们都有一个。（只有有`Y`我们才能走捷径。）</p>
</div>
<div class="paragraph">
<p>虽然这是今天猛烈冲击的迂回而已，但MJD曾<a href="https://blog.plover.com/prog/haskell/monad-search.html">在博客上发表过关于此事的博客</a>，然后我<a href="http://strangelyconsistent.org/blog/send-more-money-in-raku">也在</a><a href="https://blog.plover.com/prog/haskell/monad-search.html">博客上写了这篇文章</a>。从某种意义上说，这些博客文章非常关注“删除缩进”。今天的帖子是我三年后的想法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_我让路径遍历少了以及所有其他路径">43.2. 我让路径遍历少了（以及所有其他路径）</h3>
<div class="paragraph">
<p>我们的第二语言仍然主要是 Raku，但有一个简洁的假象扩展名`amb`，但是拼写为（令人回味）<code>←</code>。它摆脱了所有显式`for`循环和缩进层级。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $d &lt;- 0..9;
my $e &lt;- 0..9;
guard $e != any($d);
my $y = ($d + $e) % 10;
my $_c1 = ($d + $e) div 10;

my $n &lt;- 0..9;
guard $n != any($d, $e, $y);
my $r &lt;- 0..9;
guard $r != any($d, $e, $y, $n);
guard ($_c1 + $n + $r) % 10 == $e;
my $_c2 = ($_c1 + $n + $r) div 10;

my $o &lt;- 0..9;
guard $o != any($d, $e, $y, $n, $r);
guard ($_c2 + $e + $o) % 10 == $n;
my $_c3 = ($_c2 + $e + $o) div 10;

my $s &lt;- 1..9;
guard $s != any($d, $e, $y, $n, $r, $o);
my $m &lt;- 1..9;
guard $m != any($d, $e, $y, $n, $r, $o, $s);
guard ($_c3 + $s + $m) % 10 == $o;
my $_c4 = ($_c3 + $s + $m) div 10;

guard $_c4 % 10 == $m;

say &#34;$s$e$n$d + $m$o$r$e == $m$o$n$e$y&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种解决方案更短，更紧凑，并且感觉不那么“聒噪”，并且只是通过摆脱`for`循环来加重。（我怀疑这与人们有时提到的那些命令性的声明谱有关。我们对循环不是那么感兴趣，只看到它完成了。）</p>
</div>
<div class="paragraph">
<p>我知道它不会完全弥补Raku没有`amb`运算符并且 `guard`在核心中（甚至在模块空间中）实现的事实，但是这里有一个简短的脚本将上述程序转换为今天的第一个版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $indent = 0;
constant SPACE = chr(0x20);
sub indent { SPACE x 4 * $indent }

for lines() {
    when /^ my \h+ (&#39;$&#39; \w) \h* &#39;&lt;-&#39; \h* (\d+ \h* &#39;..&#39; \h* \d+) &#39;;&#39; $/ {
        say indent, &#34;for $1 -&gt; int $0 \{&#34;;
        $indent++;
    }

    when /^ guard \h+ (&#39;$&#39; \w) \h* &#39;!=&#39; \h* &#39;any(&#39; (&#39;$&#39; \w)+ % [\h* &#39;,&#39; \h*] &#39;)&#39; \h* &#39;;&#39; $/ {
        say indent, &#34;next if $0 == $_;&#34;
            for $1;
        say &#34;&#34;;
    }

    when /^ guard \h+ ([&lt;!before &#39;==&#39;&gt; .]+ &#39;==&#39; &lt;-[;]&gt;+) &#39;;&#39; $/ {
        say indent, &#34;next unless $0;&#34;;
    }

    when /^ my \h+ (&#39;$&#39; \w+) \h* &#39;=&#39; \h* (&lt;-[;]&gt;+) &#39;;&#39; $/ {
        say indent, &#34;my int $0 = $1;&#34;;
    }

    when /^ \h* $/ {
        say &#34;&#34;;
    }

    when /^ say \h+ (&lt;-[;]&gt;+) &#39;;&#39; $/ {
        say indent, $_;
    }

    default {
        die &#34;Couldn&#39;t match $_&#34;;
    }
}

while $indent-- {
    say indent, &#34;\}&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但我们也不会就此满意。哦，不。</p>
</div>
</div>
<div class="sect2">
<h3 id="_在方程式中思考">43.3. 在方程式中思考</h3>
<div class="paragraph">
<p>第三种语言将我们进一步引入声明，摆脱了所有仅仅表明变量应该是不同项的 `guard ` 从句。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">ALL_DISTINCT

$d in 0..9
$e in 0..9
$n in 0..9
$r in 0..9
$o in 0..9
$s in 1..9
$m in 1..9

$y = ($d + $e) % 10
$_c1 = ($d + $e) div 10

($_c1 + $n + $r) % 10 == $e
$_c2 = ($_c1 + $n + $r) div 10

($_c2 + $e + $o) % 10 == $n
$_c3 = ($_c2 + $e + $o) div 10

($_c3 + $s + $m) % 10 == $o
$_c4 = ($_c3 + $s + $m) div 10

$_c4 % 10 == $m</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们现在完全处于<a href="https://en.wikipedia.org/wiki/Constraint_programming">约束编程</a>领域，如果不提这一点，是不诚实的。我们已经抛弃了Raku的必要方面，我们只关注描述我们正在解决的问题的约束。</p>
</div>
<div class="paragraph">
<p>上述程序最重要的方面是我们赋值时。即使这主要是一种优化，在我们知道我们可以直接计算变量的值而不是搜索变量的情况下。</p>
</div>
<div class="paragraph">
<p>即使在这种情况下，我们也可以转换回以前的解决方案。不过，我现在会省略这样一个翻译。</p>
</div>
<div class="paragraph">
<p>我将在结论中回到这种语言，因为它在很多方面证明了，这是最有趣的一种。</p>
</div>
</div>
<div class="sect2">
<h3 id="_第四语言">43.4. 第四语言</h3>
<div class="paragraph">
<p>到目前为止，我们还有哪些必要的复杂性可以剥离？具体而言，这些方程式来自前一解决方案中指定的位置？我们怎样才能更简洁地表达它们？</p>
</div>
<div class="paragraph">
<p>我想你会喜欢这个。第四种语言只是表达了这样的搜索：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">    S E N D
+   M O R E
-----------
  M O N E Y</code></pre>
</div>
</div>
<div class="paragraph">
<p>等一下，为什么又来？是的，你没有看错。这个问题最具声明性的解决方案只是问题规范本身的ASCII布局！当问题域和答案域如此相遇时，难道你不喜欢它吗？</p>
</div>
<div class="paragraph">
<p>从这个布局上，我们可以再次转换回约束编程解决方案，从手动算法中编写方程式，以便我们在学校学习。</p>
</div>
<div class="paragraph">
<p>因此，我们不仅不需要编写那些加重`for`循环的东西; 如果我们足够顽强，我们可以从问题到解决方案一直生成代码。我们只需找到合适的语言就可以了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论_5">43.5. 结论</h3>
<div class="paragraph">
<p>我对007的探索使我思考了上述事情：翻译程序。Raku 已经很好地公开了编译过程的一部分：解析。我们可以在用户空间和Raku工具链中使用 grammars。</p>
</div>
<div class="paragraph">
<p>我开始相信我们需要对编译管道的所有方面都这样做。在这里，让我把它作为口号或声明：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>当我们带来操作文本/数据的所有功能也可以向内转到编译过程本身时，Raku将充分发挥其潜力。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>我在不同语言之间编写（或想象）的那些翻译器，他们在压力下工作，但他们也很脆弱，有点浪费。问题在很大程度上是我们一直下降到文本。我们应该在AST级别执行此操作，其中所有结构都可用。</p>
</div>
<div class="paragraph">
<p>这种思想转变所带来的收益不容小觑。这是我们在Raku中找到Lispy启蒙的地方。</p>
</div>
<div class="paragraph">
<p>例如，带方程的第三种语言不必盲目地翻译成代码。它可以被*优化*，方程式篡改成更窄和更精确的方程式。从<a href="https://en.wikipedia.org/wiki/Verbal_arithmetic#Solving_cryptarithms">维基百科</a>可以看出，有可能做到如此优秀，以至于一旦程序运行就没有剩下的搜索。</p>
</div>
<div class="paragraph">
<p>我的梦想：能够进行上述转换，而不是在文本文件之间，而是在Raku中的*俚语*之间。并且能够进行优化步骤。一切都没有离开语言的舒适。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十八天_一棵_avg_格式的圣诞树">44. 第十八天 - 一棵 AVG 格式的圣诞树</h2>
<div class="sectionbody">
<div class="paragraph">
<p>圣诞树是一种传统的象征，可以追溯到欧洲四百多年前，所以对于一篇关于创造圣诞树图像的出现文章来说，这可能更好。</p>
</div>
<div class="paragraph">
<p>树的典型，简化的表示是几个尺寸逐渐减小的三角形，彼此叠加并且具有小的重叠，因此使用计算机程序很容易创建。</p>
</div>
<div class="paragraph">
<p>在这里，我将使用可缩放矢量图形（SVG）绘制图像，如上所述，它似乎非常适合任务。</p>
</div>
<div class="sect2">
<h3 id="_关于svg并创建它">44.1. 关于SVG并创建它</h3>
<div class="paragraph">
<p>SVG是一种XML文档格式，它将图像描述为点之间的一组矢量，它具有线条和形状的基元，并提供所描述对象的样式。</p>
</div>
<div class="paragraph">
<p>也许最简单的SVG文档是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34;
     xmlns:svg=&#34;http://www.w3.org/2000/svg&#34;
     xmlns:xlink=&#34;http://www.w3.org/1999/xlink&#34;
     width=&#34;100&#34;
     height=&#34;100&#34;&gt;
	&lt;g&gt;
		&lt;rect x=&#34;5&#34; y=&#34;5&#34; width=&#34;90&#34; height=&#34;90&#34; stroke=&#34;black&#34; fill=&#34;green&#34; /&gt;
	&lt;/g&gt;
&lt;/svg&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这描述了侧面90的绿色填充正方形（单元基本上是抽象的并且相对于显示器的尺寸，因为图像的可缩放特性意味着它们可能不等同于例如像素。）</p>
</div>
<div class="paragraph">
<p>现在我们可以在程序中使用一些变量插值打印出XML，但是对于比上面的例子更复杂的事情，这可能会非常繁琐且容易出错。幸运的是Raku有一个方便的<a href="https://github.com/moritz/svg">SVG</a>模块，它负责从描述它的数据结构中实际创建格式良好的XML文档。因此，我们的示例矩形可以使用以下内容创建：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use SVG;

say SVG.serialize(
    svg =&gt; [
        width =&gt; 100, height =&gt; 100,
        :g[:rect[:x&lt;5&gt;, :y&lt;5&gt;, :width&lt;90&gt;, :height&lt;90&gt;, :stroke&lt;black&gt;, :file&lt;green&gt;]],
    ],
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>本质上，参数`serialize`是一组嵌套的<a href="https://docs.raku.org/type/Pair">Pairs</a>：其中value是标量类型，键和值用于形成XML属性，其中值是List of Pairs，这将创建一个以键命名的XML元素，列表中的每个对都被解释为如上所述，从而允许以简单的声明方式构建复杂文档。</p>
</div>
<div class="paragraph">
<p>所以我们可以通过构造适当的数据结构来生成我们的示例圣诞树，但是因为我们的图像中可能至少有四个对象（三个三角形和一个用于树干的矩形）及其相关属性，这可能会非常不合适如果我们想改变某些东西，很难改变。</p>
</div>
<div class="paragraph">
<p>所以…</p>
</div>
</div>
<div class="sect2">
<h3 id="_我们抽象吧">44.2. 我们抽象吧！</h3>
<div class="paragraph">
<p>为了使我们的SVG生成更加灵活并为未来的代码重用开辟了机会，创建一组代表我们可能想要使用的SVG原语的类并抽象出将要生成的数据结构可能是有意义的。序列化为XML。</p>
</div>
<div class="paragraph">
<p>所以让我们从可以生成原始矩形示例的东西开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">use SVG;

class SVG::Drawing {
    role Element {
        method serialize() {
            ...
        }
    }

    has Element @.elements;

    has Int $.width;
    has Int $.height;

    class Group does Element {
        has Element @.elements;
        method serialize( --&gt; Pair ) {
            g =&gt; @!elements.map( -&gt; $e { $e.serialize }).list;
        }
    }

    class Rectangle does Element {
        has Int $.x;
        has Int $.y;
        has Int $.width;
        has Int $.height;
        has Str $.stroke;
        has Str $.fill;

        method serialize( --&gt; Pair) {
            rect =&gt; [x =&gt;  $!x, y =&gt; $!y, width =&gt; $!width, height =&gt; $!height, stroke =&gt; $!stroke, fill =&gt; $!fill ];
        }
    }

    method serialize( --&gt; Str ) {
        SVG.serialize(svg =&gt; @!elements.map(-&gt; $e { $e.serialize }).list);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要运行此示例，则应将其保存为`SVG/Drawing.pm`当前目录。</p>
</div>
<div class="paragraph">
<p>这给出了一个类来描述我们的图像作为一个整体，并协调数据结构的创建，这些数据结构将被序列化为我们的SVG文档，并且每个类都用于我们在原始示例中使用的`g`（Group）和`rect`（Rectangle）基元所以我们可以这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">use SVG::Drawing;

my SVG::Drawing $drawing = SVG::Drawing.new(elements =&gt; [
    SVG::Drawing::Group.new(elements =&gt; [
        SVG::Drawing::Rectangle.new(x =&gt; 5, y =&gt; 5, width =&gt; 100, height =&gt; 100, stroke =&gt; &#34;black&#34;, fill =&gt; &#34;green&#34; )
    ]);
]);

say $drawing.serialize;</code></pre>
</div>
</div>
<div class="paragraph">
<p>生成与第一个类似的文档。</p>
</div>
<div class="paragraph">
<p>您可能已经注意到了`Element`stubbed方法的作用`serialize`：这是为了描述基本类所需的接口，以便收集基本类对象的类可以取决于`serialize`它们何时到来时序列化这些收集的对象。生成XML文档。从一开始就添加它可以更容易，更可靠地添加类来描述绘图的新基元。</p>
</div>
</div>
<div class="sect2">
<h3 id="_让我们延伸">44.3. 让我们延伸！</h3>
<div class="paragraph">
<p>因此，除非我们有兴趣用相互叠加的不同大小的正方形制作圣诞树的相当现代主义的表示，否则我们需要一种创建我们需要的三角形的方法。幸运的是，SVG提供了许多从一组坐标点创建任意闭合形状的方法，但我们将使用最简单的方法，<code>polygon`它有一个属性`points</code>，它是以逗号分隔的顶点坐标的空格分隔列表。形状，最后一个连接到第一个以关闭形状。</p>
</div>
<div class="paragraph">
<p>我们将使用一个新的Polygon类来描述`polygon`原语：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use SVG;

class SVG::Drawing {
    role Element {
        method serialize() {
            ...
        }
    }

    has Element @.elements;

    has Int $.width;
    has Int $.height;

    class Group does Element {
        has Element @.elements;
        method serialize( --&gt; Pair ) {
            g =&gt; @!elements.map( -&gt; $e { $e.serialize }).list;
        }
    }

    class Rectangle does Element {
        has Int $.x;
        has Int $.y;
        has Int $.width;
        has Int $.height;
        has Str $.stroke;
        has Str $.fill;

        method serialize( --&gt; Pair) {
            rect =&gt; [x =&gt;  $!x, y =&gt; $!y, width =&gt; $!width, height =&gt; $!height, stroke =&gt; $!stroke, fill =&gt; $!fill ];
        }
    }

    class Point {
        has Int $.x;
        has Int $.y;

        method Str( --&gt; Str ) {
            ($!x, $!y).join: &#39;,&#39;;
        }
    }

    class Polygon does Element {
        has Str $.stroke;
        has Str $.fill;

        has Point @.points;

        method serialize( --&gt; Pair ) {
            polygon =&gt; [ points =&gt; @!points.join(&#39; &#39;), fill =&gt; $!fill, stroke =&gt; $!stroke ];
        }

    }

    method serialize( --&gt; Str ) {
        SVG.serialize(svg =&gt; @!elements.map(-&gt; $e { $e.serialize }).list);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了我们新的Polygon类之外，还有一个Point类描述了多边形顶点的坐标：<code>Str`提供的方法是为了简化`serialize`Polygon类方法的实现，因为</code>@.points`属性的元素将被字符串化为他们加入了`serialize`。</p>
</div>
<div class="paragraph">
<p>所以现在我们可以生成类似外观的图像，但是以不同的方式构造，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use SVG::Drawing;

my SVG::Drawing $drawing = SVG::Drawing.new(elements =&gt; [
    SVG::Drawing::Group.new(elements =&gt; [
        SVG::Drawing::Polygon.new(stroke =&gt; &#34;black&#34;, fill =&gt; &#34;green&#34;, points =&gt; [
            SVG::Drawing::Point.new(x =&gt; 5, y =&gt; 5),
            SVG::Drawing::Point.new(x =&gt; 105, y =&gt; 5),
            SVG::Drawing::Point.new(x =&gt; 105, y =&gt; 105),
            SVG::Drawing::Point.new(x =&gt; 5, y =&gt; 105)
        ])
    ]);
]);

say $drawing.serialize;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将生成一个XML文档，如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34;
     xmlns:svg=&#34;http://www.w3.org/2000/svg&#34;
     xmlns:xlink=&#34;http://www.w3.org/1999/xlink&#34;&gt;
	&lt;g&gt;
		&lt;polygon points=&#34;5,5 105,5 105,105 5,105&#34; fill=&#34;green&#34; stroke=&#34;black&#34; /&gt;
	&lt;/g&gt;
&lt;/svg&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以现在我们几乎拥有了绘制Chritmas树所需的一切，但在这一点上，值得退一步，展示对未来自我（或者其他可能需要处理代码的人）的爱。</p>
</div>
</div>
<div class="sect2">
<h3 id="_一个重构点">44.4. 一个重构点</h3>
<div class="paragraph">
<p>当我们创建新的Polygon类时，我们复制了`S.stroke`和`$.fill`属性，并安排它们以类似于Rectangle类的方式进行序列化。如果我们赶时间这可能是有意义的，这些是他们可能被使用的唯一地方，但是当我们阅读SVG文档时，很明显它们可以应用于许多SVG原语，因此重构是有意义的。现在，在我们添加任何可能需要它们的类之前。</p>
</div>
<div class="paragraph">
<p>最明显的方法是创建一个包含属性的新角色，并提供一个方法，该方法返回表示序列化中属性的对列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use SVG;

class SVG::Drawing {
    role Element {
        method serialize() {
            ...
        }
    }

    role Styled {
        has Str $.stroke;
        has Str $.fill;

        method styles() {
            ( stroke =&gt; $!stroke, fill =&gt; $!fill ).grep( { .value.defined } );
        }

    }

    has Element @.elements;

    has Int $.width;
    has Int $.height;

    class Group does Element {
        has Element @.elements;
        method serialize( --&gt; Pair ) {
            g =&gt; @!elements.map( -&gt; $e { $e.serialize }).list;
        }
    }

    class Rectangle does Element does Styled {
        has Int $.x;
        has Int $.y;
        has Int $.width;
        has Int $.height;

        method serialize( --&gt; Pair) {
            rect =&gt; [x =&gt;  $!x, y =&gt; $!y, width =&gt; $!width, height =&gt; $!height, |self.styles ];
        }
    }

    class Point {
        has Int $.x;
        has Int $.y;

        method Str( --&gt; Str ) {
            ($!x, $!y).join: &#39;,&#39;;
        }
    }

    class Polygon does Element does Styled {

        has Point @.points;

        method serialize( --&gt; Pair ) {
            polygon =&gt; [ points =&gt; @!points.join(&#39; &#39;), |self.styles ];
        }

    }

    method serialize( --&gt; Str ) {
        SVG.serialize(svg =&gt; @!elements.map(-&gt; $e { $e.serialize }).list);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以现在我们有一个双重好处，我们可以添加一个新的样式类而不必复制属性，而且我们可以添加我们可能想要的新样式属性，而无需更改消耗类。</p>
</div>
<div class="paragraph">
<p>通过一些额外的工作，我们可能失去了从the中的角色调用方法的需要`serialize`，比如说，使用属性上的特征，这将允许我们选择要序列化的属性，但我将把它当作一个随着圣诞节的到来，我们仍然没有树。</p>
</div>
</div>
<div class="sect2">
<h3 id="_一个进一步的抽象">44.5. 一个进一步的抽象</h3>
<div class="paragraph">
<p>现在我们处于一个很好的位置来创建我们的圣诞树，因为我们需要的三角形只是一个多边形的三面形状，但我们想要不止一个并且顶点的计算将是相当重复，加上，因为我为了简单而任意选择使用等边三角形，其他两个角的坐标可以从顶点和边长度的坐标计算，所以如果我们有一个三角类它可以自我计算，我们只需关注自己的大小和位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use SVG;

class SVG::Drawing {
    role Element {
        method serialize() {
            ...
        }
    }

    role Styled {
        has Str $.stroke;
        has Str $.fill;

        method styles() {
            ( stroke =&gt; $!stroke, fill =&gt; $!fill ).grep( { .value.defined } );
        }

    }

    has Element @.elements;

    has Int $.width;
    has Int $.height;

    class Group does Element {
        has Element @.elements;
        method serialize( --&gt; Pair ) {
            g =&gt; @!elements.map( -&gt; $e { $e.serialize }).list;
        }
    }

    class Rectangle does Element does Styled {
        has Int $.x;
        has Int $.y;
        has Int $.width;
        has Int $.height;

        method serialize( --&gt; Pair) {
            rect =&gt; [x =&gt;  $!x, y =&gt; $!y, width =&gt; $!width, height =&gt; $!height, |self.styles ];
        }
    }

    class Point {
        has Numeric $.x;
        has Numeric $.y;

        method Str( --&gt; Str ) {
            ($!x, $!y).join: &#39;,&#39;;
        }
    }

    class Polygon does Element does Styled {

        has Point @.points;

        method serialize( --&gt; Pair ) {
            polygon =&gt; [ points =&gt; @.points.join(&#39; &#39;), |self.styles ];
        }

    }

    class Triangle is Polygon {
        has Point $.apex is required;
        has Int   $.side is required;

        method points() {
            ($!apex, |self.base-points);
        }

        method base-points() {
            my $y = $!apex.y + self.get-height;

            (Point.new(:$y, x =&gt; $!apex.x - ( $!side / 2 )), Point.new(:$y, x =&gt; $!apex.x + ( $!side / 2 )));
        }

        method get-height(--&gt; Num ) {
            sqrt($!side**2 - ($!side/2)**2)
        }

    }

    method dimensions() {
        ( height =&gt; $!height, width =&gt; $!width ).grep( { .value.defined } );

    }

    method serialize( --&gt; Str ) {
        SVG.serialize(svg =&gt;  [ |self.dimensions, |@!elements.map(-&gt; $e { $e.serialize })]);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这需要在其他地方进行一些小的改动。在`Int`作为三角形的顶点的计算结果可能不是整数（或我们会风了一个靠不住的三角形，如果我们roumded他们）还点的属性是放宽到数字`serialize`多边形的方法是改变使用访问器方法`points`而不是直接使用属性，因此可以在我们的Triangle类中过度使用以计算三角形基线的附加点。</p>
</div>
<div class="paragraph">
<p>计算本身只使用一些初级几何来确定基线到顶点的高度，使用毕达哥拉斯定理得到两个基线点的y坐标，x坐标是两侧边长的一半。顶点x坐标。</p>
</div>
<div class="paragraph">
<p>此外，当我测试这个时，我注意到我之前没有实现高度和宽度属性的序列化，我们已经离开它，因为矩形没有超出默认绘图区域，但是三角形做了，因此没有显示。</p>
</div>
<div class="paragraph">
<p>无论如何，现在我们可以用最少的代码绘制一个三角形：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use SVG::Drawing;

my SVG::Drawing $drawing = SVG::Drawing.new(
    elements =&gt; [
        SVG::Drawing::Group.new(elements =&gt; [
            SVG::Drawing::Triangle.new(stroke =&gt; &#34;black&#34;, fill =&gt; &#34;green&#34;,
                apex =&gt; SVG::Drawing::Point.new(x =&gt; 100, y =&gt; 50),
                side =&gt; 50,
            )
        ])
    ],
    height  =&gt; 300,
    width   =&gt; 200
);

say $drawing.serialize;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将在足够大的空间中提供一个漂亮的绿色等边三角形来绘制我们的树。</p>
</div>
</div>
<div class="sect2">
<h3 id="_最后是我们的树">44.6. 最后是我们的树</h3>
<div class="paragraph">
<p>现在我们有了创建简单树的组成部分的方法，因此我们可以将它们与一个相对简单的脚本放在一起：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use SVG::Drawing;

my SVG::Drawing $drawing = SVG::Drawing.new(
    elements =&gt; [
        SVG::Drawing::Group.new(elements =&gt; [
            SVG::Drawing::Triangle.new(stroke =&gt; &#34;green&#34;, fill =&gt; &#34;green&#34;,
                apex =&gt; SVG::Drawing::Point.new(x =&gt; 100, y =&gt; 50),
                side =&gt; 50,
            ),
            SVG::Drawing::Triangle.new(stroke =&gt; &#34;green&#34;, fill =&gt; &#34;green&#34;,
                apex =&gt; SVG::Drawing::Point.new(x =&gt; 100, y =&gt; 75),
                side =&gt; 75,
            ),
            SVG::Drawing::Triangle.new(stroke =&gt; &#34;green&#34;, fill =&gt; &#34;green&#34;,
                apex =&gt; SVG::Drawing::Point.new(x =&gt; 100, y =&gt; 100),
                side =&gt; 100,
            ),
            SVG::Drawing::Rectangle.new(stroke  =&gt; &#34;brown&#34;,
                                        fill    =&gt; &#34;brown&#34;,
                                        x       =&gt;  90,
                                        y       =&gt; 185,
                                        width   =&gt; 20,
                                        height  =&gt; 40),
        ])
    ],
    height  =&gt; 300,
    width   =&gt; 200
);

say $drawing.serialize;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我通过反复试验选择了形状的大小和位置，它可能更科学地完成。</p>
</div>
<div class="paragraph">
<p>无论如何，这会产生这样的XML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34;
     xmlns:svg=&#34;http://www.w3.org/2000/svg&#34;
     xmlns:xlink=&#34;http://www.w3.org/1999/xlink&#34;
     height=&#34;300&#34;
     width=&#34;200&#34;&gt;
	&lt;g&gt;
		&lt;polygon points=&#34;100,50 75,93.30127018922192 125,93.30127018922192&#34; stroke=&#34;green&#34; fill=&#34;green&#34; /&gt;
		&lt;polygon points=&#34;100,75 62.5,139.9519052838329 137.5,139.9519052838329&#34; stroke=&#34;green&#34; fill=&#34;green&#34; /&gt;
		&lt;polygon points=&#34;100,100 50,186.60254037844385 150,186.60254037844385&#34; stroke=&#34;green&#34; fill=&#34;green&#34; /&gt;
		&lt;rect x=&#34;90&#34; y=&#34;185&#34; width=&#34;20&#34; height=&#34;40&#34; stroke=&#34;brown&#34; fill=&#34;brown&#34; /&gt;
	&lt;/g&gt;
&lt;/svg&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个合理的程式化圣诞树，用户代码最少。</p>
</div>
<div class="paragraph">
<p>由于我们设计模块的方式，我们已经把自己放在一个好的地方进一步扩展它，比如说，一个Circle类可以用来轻松地为我们的树添加彩色小玩意。</p>
</div>
<div class="paragraph">
<p>SVG是一个非常丰富的规范，具有大量基元，可满足大多数绘图需求，我们只实现了绘制树所需的最小值，但这可以扩展为支持您想要的任何类型的绘图。</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2018/12/tree.png?w=788">树</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十九天_交互式桌面应用">45. 第十九天 - 交互式桌面应用</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我是地下城与龙等角色扮演游戏的忠实粉丝。这些游戏中的大多数都有屏幕来帮助你隐藏你在运行游戏时所做的事情，并为你提供游戏中使用的一些图表，以减少书中的内容。</p>
</div>
<div class="paragraph">
<p>我的游戏收藏很广泛而且我宁愿使用我的笔记本电脑不仅隐藏在后面并跟踪信息，而且我还可以自动化骰子和图表使用。虽然我可以用文本编辑器和命令行魔法拼凑一些东西，但我宁愿拥有一些时髦的桌面应用程序，我可以向人们展示。</p>
</div>
<div class="paragraph">
<p>输入<a href="https://github.com/raku/gtk-simple">GTK::Simple</a>是Linux Gnome桌面使用的gtk3 UI库的包装器，但也可以在Windows和Mac上使用。该库通过Native Call 的强大功能为你提供了一个简单易用的界面，让你可以创建简单的桌面应用程序。</p>
</div>
<div class="sect2">
<h3 id="_骰子滚动">45.1. 骰子滚动</h3>
<div class="paragraph">
<p>由于历史原因，角色扮演游戏大多数倾向于选择使用基于柏拉图固体的骰子。骰子的标准组合是4,6,8,10,12,20，并且通过组合2个10面骰子100的骰子。骰子可以多次滚动，用于写入的标准符号是“ x<strong>d</strong>y ”，其中 “<strong>x</strong>“ 是掷骰子的数量，”<strong>y</strong>“ 是掷骰子的大小。单个骰子在开始时跳过1，例如“roll a d6”意味着掷出六面骰子。</p>
</div>
<div class="paragraph">
<p>有趣的是，在 Raku 中制作 “<strong>d</strong>” 运算符非常简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix: ( UInt $count, UInt $size ) { (1..$size).roll($count) }
sub prefix: ( UInt $size ) { 1 d $size }</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，你需要将数字与空格分开，并且 “<strong>d</strong>” 运算符或编译器会混淆。</p>
</div>
<div class="paragraph">
<p>我想要的是一个骰子滚轮应用程序，它提供了选择滚动标准骰子组的选项。现在我不会看到一些游戏使用的不同骰子，或者修改滚动，很多游戏都使用这些骰子。我想看看每个掷骰子，因为这可能很重要，具体取决于系统。如果可能的话，我也想要总数。</p>
</div>
</div>
<div class="sect2">
<h3 id="_简单的_gtksimple">45.2. 简单的 GTK::Simple</h3>
<div class="paragraph">
<p>GTK::Simple 的基本用法很简单。创建一个应用程序，添加内容，放入一些事件处理程序，然后离开。</p>
</div>
<div class="paragraph">
<p>首先，我们创建我们的应用程序，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">#!/usr/bin/env raku

# Get the GTK::Simple libraries
use GTK::Simple;
use GTK::Simple::App;

# Create the main app
my $app = GTK::Simple::App.new( title =&gt; &#34;Dice Roller&#34; );

# Start the app running
$app.run;</code></pre>
</div>
</div>
<div class="paragraph">
<p>但…。这不是很有趣：</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/empty.png?w=788">空</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_网格布局">45.3. 网格布局</h3>
<div class="paragraph">
<p>要在应用程序中布局小部件，我们有各种选项，但建议使用的是网格。网格布局从左上角的0,0开始并根据需要延伸的小部件。</p>
</div>
<div class="paragraph">
<p>正是在这一点上，我尝试构建一个应用程序，我打了一个墙。网格选项很好，我在下面的最后一个例子中使用它但是当我尝试的时候它没有按照我的预期工作。我仍然可以得到一个简单的网格，所以显示它的工作，但似乎需要更多的学习。无论如何这里是一个基本网格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku
# Get the GTK::Simple libraries
use GTK::Simple;
use GTK::Simple::App;

# Create the main app
my $app = GTK::Simple::App.new( title =&gt; &#34;Grid&#34; );

$app.set-content(
    GTK::Simple::Grid.new(
        # Grid key is [x,y,height,width]
        [0,0,1,1] =&gt; GTK::Simple::Button.new( label =&gt; &#34;a&#34; ),
        # A Button is a simple push button with a label
        [0,1,1,1] =&gt; GTK::Simple::Button.new( label =&gt; &#34;b&#34; ),
        [0,2,1,1] =&gt; GTK::Simple::Button.new( label =&gt; &#34;c&#34; ),
        [1,0,1,3] =&gt; GTK::Simple::Button.new( label =&gt; &#34;d&#34; ),
    )
);

$app.border-width = 10;
# Start the app
$app.run;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个产生：</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/grid-1.png?w=788">格</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_交互">45.4. 交互</h3>
<div class="paragraph">
<p>这很整洁，但按钮还没有做任何事情。为此，我们需要事件处理程序。GUI应用程序需要事件驱动才能对用户操作做出反应，幸运的是 Raku 具有处理 Supplies 形式的事件的功能。每个按钮都有一个名为 clicked 的 supply，它可以附加一个 tap 处理程序。</p>
</div>
<div class="paragraph">
<p>事件处理程序可以执行各种操作，包括操作其他UI对象。例如 ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

# Get the GTK::Simple libraries
use GTK::Simple;
use GTK::Simple::App;

# Create the main app
my $app = GTK::Simple::App.new( title =&gt; &#34;Grid&#34; );

$app.set-content(
    GTK::Simple::Grid.new(
        # As we want to refer to our buttons later we assign them
        # to variables
        [0,0,1,1] =&gt; my $b1 = GTK::Simple::Button.new( label =&gt; &#34;Push Me&#34; ),
        [1,1,1,1] =&gt; my $b2 = GTK::Simple::Button.new( label =&gt; &#34;---&#34; ),
        [2,2,1,1] =&gt; my $b3 = GTK::Simple::Button.new( label =&gt; &#34;---&#34; ),
        [3,3,1,1] =&gt; my $b4 = GTK::Simple::Button.new( label =&gt; &#34;---&#34; ),
    )
);

# The sensitive flag controls whether you can click on the button
$b2.sensitive = False;
$b3.sensitive = False;
$b4.sensitive = False;

# In the
$b1.clicked.tap( {
    # $_ is the clicked button. Turn it off
    .sensitive = False;
    # Change the label on the next button
    $b2.label = &#34;Now Me!&#34;;
    # Make it clickable
    $b2.sensitive = True
} );

# Leaving on one line to cut down on space
$b2.clicked.tap( { .sensitive = False; $b3.label = &#34;Me Next&#34;; $b3.sensitive = True } );
$b3.clicked.tap( { .sensitive = False; $b4.label = &#34;Me! Me!&#34;; $b4.sensitive = True } );
# App.exit closes the app.
$b4.clicked.tap( { $app.exit } );

$app.border-width = 10;
# Start the app
$app.run;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这使得：</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/buttons.png?w=788">纽扣</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_把它们放在一起">45.5. 把它们放在一起</h3>
<div class="paragraph">
<p>有了这个和另一个小部件，Label 给了我们一些文本，我们可以把骰子滚动应用程序放在一起：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

# Get the GTK::Simple libraries
use GTK::Simple;
use GTK::Simple::App;

# Define our `d` operator
sub infix: ( UInt $count, UInt $size ) { (1..$size).roll($count) }

# Create the main app
my $app = GTK::Simple::App.new( title =&gt; &#34;Dice Roller&#34; );

# Output Box : Define here so the buttons can access it.
my $output = GTK::Simple::Label.new( text =&gt; &#39;Roll : &#39;);

# Ouput box updater.
sub roll( $label, $count, $size ) {
    my @roll = $count d $size;
    $label.text = &#34;Roll : {@roll.join(&#34; + &#34;)} = {@roll.sum}&#34;;
}

# Create a grid and put the output box at the bottom filling the width
my @grid = ( [0,6,7,1] =&gt; $output );

# Track our depth in tthe grid
my $y = 0;

# Loop through counts
for (1..6) -&gt; $count {

    # Track our postion along the grid
    my $x = 0;

    # Loop through standard dice sizes
    for (4,6,8,10,12,20,100) -&gt; $size {

	# Standard labelling
	my $label = $count &gt; 1 ?? &#34;{$count}d{$size}&#34; !! &#34;d{$size}&#34;;

	# Create our button
	my $button = GTK::Simple::Button.new(label =&gt; $label);

	# Buttons get a supply which emit when they are clicked
	# Assign our roll function with the current count and size to it
	# Note we do it in a block so it&#39;s not called right now but when
	# the button is clicked
	$button.clicked.tap(
	    { roll( $output, $count, $size ) }
	);

	# Put the button in the valid place in the grid taking up one space
	@grid.push( [$x,$y,1,1] =&gt; $button );

	$x++;
    }
    $y++
}

# Create a grid object and assign it to the app.
$app.set-content(
    GTK::Simple::Grid.new( |@grid )
);

$app.border-width = 10;

# Start the app running
$app.run;</code></pre>
</div>
</div>
<div class="paragraph">
<p>看起来像（这里滚动3d6）：</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/dice-roller.png?w=788">骰子辊</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_最后的想法">45.6. 最后的想法</h3>
<div class="paragraph">
<p>考虑到我今天早上没有触及 GTK::Simple，我对我的最终结果非常满意。我认为我可以构建许多其他游戏工具。此外，我可能会参与模块本身的工作，尝试将更多的GTK功能添加到其中，并添加一些文档。</p>
</div>
<div class="paragraph">
<p>尽管如此，使用 GTK::Simple 还是很容易使桌面应用程序在Raku中遇到特殊的问题，而且代码并不多。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十天_raku_中的命题组合">46. 第二十天 - Raku 中的命题组合</h2>
<div class="sectionbody">
<div class="paragraph">
<p>来临是一个激动人心的时刻，是一个期待的时刻。不仅对我们人类而言 - 正是精灵变得最具创造力的时候。今天，我想在圣诞节压力下休闲一些时间来报道礼品包装领域正在开展的一些开创性工作。即使你没有预料到任何消息，这份报告仍然可以帮助你改进你的技术，因为 - 我不必提醒你 - 圣诞节快到了。</p>
</div>
<div class="paragraph">
<p>你知道哪个小孩子最喜欢吗？大礼物。因此，Northpole的现有扩大研究实验室的任务是寻找实用的方法来扩大礼物。现在，“大”可能意味着多种事物。我承认，第6单元弯曲的意思了一点，但他们的工作是迄今为止最有趣的：他们增加了<strong>音量</strong>的礼物，通过增加的礼品盒的尺寸。</p>
</div>
<div class="paragraph">
<p>“你如何包装6维礼物？”是管理层提出的有效问题。就好像天才击中了UX精灵的回应：«只需将它包裹起来，从每个三维视角看起来都像是一个正常的礼物»（他们实际上从<a href="https://gaussoids.de/">高斯</a>中学到了一个技巧，但谁也不想被视为天才偶尔？）。管理层感到满意，资金安全，数学精灵喜欢UX精灵提出的复杂性降低 - 只是制造技术还没有到那里生产那些高维盒子。因此他们决定在Raku中进行编程，因为在等待技术赶上100年语言时，最好使用什么？</p>
</div>
<div class="paragraph">
<p>“让我们开始工作，”他们说，并且他们得到了工作。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_你如何以数学方式包装礼物">47. 你如何以数学方式包装礼物？</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我在实验室逗留期间真正带回家的是，只有很多社会可接受或物理上可能的方式来包装礼物。首先，你需要一个礼物，然后一个盒子。你必须把礼品包装在盒子周围。这些步骤非常自然，精灵认为这是理所当然的。对于他们来说，“礼物”是礼品包装盒内的礼物。“包装”的挑战，以及将包装工与艺术大师分开的关键点，就是<strong>丝带</strong>和<strong>蝴蝶结</strong>发挥作用。你认为这应该够容易吗？好吧，再想一想！</p>
</div>
<div class="sect2">
<h3 id="_一个立方体卡罗尔">47.1. 一个立方体卡罗尔</h3>
<div class="paragraph">
<p>此设置中的礼物由<a href="https://en.wikipedia.org/wiki/Hypercube">n维立方体</a>建模，或简称为“n立方体”。n-cube是一个非常好的东西，因为它的所有面都是较小尺寸的立方体。计算机科学家喜欢它，因为它的顶点实际上只是长度为n 的`0`s和`1`s的串。在这里，我们关心n立方体的二维面或“正方形”。通常的三维立方体有六个正方形，正如你从骰子中所知道的那样。</p>
</div>
<div class="paragraph">
<p>精灵采取的方法将这些方块视为变量并分配给它们</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>没有</strong>如果的礼品盒，这部分上有唯一的礼品包装，因为我们同意需要，</p>
</li>
<li>
<p><strong>色带</strong>，如果有两端礼品丝带运行，或</p>
</li>
<li>
<p><strong>弓</strong>如果在立方体的这一侧弓或循环。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>是时候看一些代码了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#|« A square on the n-cube with wrapping.
In the n-cube there are 3*(n choose 2)*2**(n-2) WrapSquare variables,
one for every square and every kind of value that can be assigned to it.
»
class WrapSquare is Cube::Face does Propositional::Variable {
    has $.kind is required;

    method WHICH {
        ValueObjAt.new: &#34;WrapSquare|$!kind|{callsame}&#34;
    }

    # ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此片段告诉您这`WrapSquare`是多维数据集的一个面，其中`Cube::Face`该类实现了我们期望从多维数据集表面执行的大部分功能。它也是一种变量，并且具有一个`$.kind`属性，该属性将保存字符串`□<code>，</code>■<code>或者</code>!<a href="https://s0.wp.com/wp-content/mu-plugins/wpcom-smileys/twemoji/2/svg/1f380.svg">🎀</a>`，取决于为该正方形分配了哪个值（<strong>没有</strong>，<strong>功能区</strong>或<strong>弓形</strong>）。</p>
</div>
<div class="paragraph">
<p>有一些整洁的运算符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi prefix: (Str $s) {
    WrapSquare.new: :kind&lt;□&gt;,
        Cube::Face.from-word($s)
}

multi prefix: (Str $s) {
    WrapSquare.new: :kind&lt;■&gt;,
        Cube::Face.from-word($s)
}

multi prefix: (Str $s) {
    WrapSquare.new: :kind&lt;🎀&gt;,
        Cube::Face.from-word($s)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这让你 <code>WrapSquare</code> 通过写作来制作 ■&lt;0**010&gt;。该字符串 0**010 指定6维立方体中的正方形：让其中的 <code>*</code>  符号为通配符，它们在 <code>0</code> 和 <code>1</code> 之间变化。然后你得到四个二进制字符串 <code>000010</code>，<code>001010</code>，<code>010010</code> 和 <code>011010</code>。回想一下，长度为n（这里n = 6）的二进制字符串是n-cube的顶点，这四个碰巧绑定了它的二维面。这些 <code>WrapSquare</code> 文字将在以后全部出现。</p>
</div>
<div class="paragraph">
<p>经过所有这些解释后 <code>WrapSquare</code>，我几乎可以听到你心中想要满足的痒：“为什么会这样 <code>WrapSquare</code> <code>Variable</code> <code>Propositional</code>？”</p>
</div>
</div>
<div class="sect2">
<h3 id="_sat_a_clause的令人满意的故事">47.2. SAT-a-Clause的令人满意的故事</h3>
<div class="paragraph">
<p>回想一下UX精灵的建议是：«只需将其包裹起来，从每个三维视角看起来都像一个正常的礼物»。虽然这听起来非常简单，但它会产生一个非常复杂的问题。</p>
</div>
<div class="paragraph">
<p>“有多少种方式来包装n维礼物？”可能是精灵们问自己的第一个问题。UX精灵要我们做的是选择一个合适的三维包装，其中精灵已经是专家，对于n立方体表面上的每个三维立方体，<strong>但是</strong>所有这些三维包装都适合在高维立方体。n立方体有½n⋅（n-1）⋅2ⁿ-2平方但是通过选择3d包裹，你可以选择½n⋅（n-1）⋅（n-2）⋅2ⁿ-2平方，这是（n -2）你有变量的选择次数。原因是3立方体在n立方体中彼此共享正方形，就像在3维中一样，骰子的侧面具有共同的立方体边缘。</p>
</div>
<div class="paragraph">
<p>UX精灵创建的问题是为n-cube上的3-cube选择3d包装，只要它们具有公共方形，它们就彼此兼容。但这真的有多糟糕？在尺寸4中，您有24个正方形，因此3²= 282,429,536,481种选择包装的方式。如果您是随机进行的，那么您找到UX认可包装的机会甚至不是0.0000007％。正如我们将要看到的那样，正好有1848个正确的包装。</p>
</div>
<div class="paragraph">
<p>“我们怎么可能探索这样一个巨大的空间？” - 精灵们感到震惊。直到他们发现SAT求解器。`SAT`指的是<a href="https://en.wikipedia.org/wiki/Propositional_calculus">命题</a> <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">满足性问题</a>，决定使用布尔变量和运算的公式是否具有使公式成立的赋值，“满足”它的任务。</p>
</div>
<div class="paragraph">
<p>事实证明，礼品包装可以变成这种可满足性问题的一个例子。为简单起见，精灵决定为n-cube的每个方块分配三个布尔变量。他们主张这个广场是否装饰有□，■或🎀。这些变量中的一个必须是真的。然后，他们编码要求，每个3立方体必须包含一个适当的3d包装，并且所选择的包装在n立方体中兼容为命题公式。他们把这个公式的成分称为*giftoid公理* - 包装高维礼品的规则。</p>
</div>
<div class="paragraph">
<p>有些求解器比找到一个令人满意的任务更进一步（或确定找不到一个任务的不可能性）：他们可以返回这些任务的确切数量，甚至可以列出所有这些任务。正是精灵需要的东西，幸运的是，Raku可以使用命题演算和SAT求解器。</p>
</div>
<div class="paragraph">
<p>SAT求解器的输入是<a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form">Conjunctive Normal Form中</a>的布尔公式。该`Propositional`模块有一个特别好的实现，虽然我可能有偏见：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method NNF {
    self.rewrite(
        (  ^:p ⇔ ^:q ) =&gt; { ($:p ⇒  $:q) ∧ ($:q ⇒ $:p) },
        (  ^:p ⇒ ^:q ) =&gt; { ¬$:p ∨  $:q },
        (¬(^:p ∨ ^:q)) =&gt; { ¬$:p ∧ ¬$:q },
        (¬(^:p ∧ ^:q)) =&gt; { ¬$:p ∨ ¬$:q },
        (¬¬^:p)        =&gt; {  $:p        },
    )
    andthen .squish
}

method CNF {
    self.NNF.rewrite(
        (^:p ∨ (^:q ∧ ^:r)) =&gt; { ($:p ∨ $:q) ∧ ($:p ∨ $:r) },
        ((^:q ∧ ^:r) ∨ ^:p) =&gt; { ($:p ∨ $:q) ∧ ($:p ∨ $:r) },
    )
    andthen .squish
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该`CNF`方法首先将公式转换为中间形式，称为<a href="https://en.wikipedia.org/wiki/Negation_normal_form">否定范式</a>，然后将其转换为CNF。这两种方法都使用模块的中心齿轮之一，该`rewrite`方法。顾名思义，它重写了一个基于规则的公式，这些规则作为成对给出，例如`(^:p ⇔ ^:q ) ⇒ { ($:p ⇒ $:q) ∧ ($:q ⇒ $:p) }`。关键是一个公式对象，这里只是`⇔<code>两个变量的等价，</code><sup>:p`并且`</sup>:q`在整个公式内是模式匹配的。“限量印记”，在变量前面表明上的两侧发现子式`⇔<code>操作应当<strong>帽</strong>捕获的原始内部<a href="https://docs.raku.org/language/variables#index-entry-%24%3A">命名参数</a> `p`和`q`它们被传递到对fatarrow右侧的代码块，以确定</code>⇔<code>表达式的替换是什么。在这种情况下，等价被两个含义所取代 - 这个重写规则实现了定义</code>⇔<code>。上面的下一条规则实现了</code>⇒`。的定义。实际上，如果你想要一个NNF，必须消除这两个符号。</p>
</div>
<div class="paragraph">
<p>重写引擎执行所有列出的重写，直到找不到更多匹配项。现在，逻辑学家会告诉你，如果你这样做，你会将任何命题公式变成CNF。这应该足够内部。让我们公理化礼物吧！</p>
</div>
</div>
<div class="sect2">
<h3 id="_比你想知道的3d礼品包装更多">47.3. 比你想知道的3D礼品包装更多</h3>
<div class="paragraph">
<p>看到所有的高级成分落到实处，每个人都兴奋不已，我不得不停下来问：«基本情况怎么样？你如何包装3D礼物？»。问这个精灵和他们的眼睛开始发光。这是他们的第二天性，甚至是研究精灵。这些是每个精灵在学校学到的规则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>只是包装：</strong>没有丝带或蝴蝶结的礼物是好的，但永远不要忘记礼品包装，</p>
</li>
<li>
<p><strong>胶合弓：</strong>它可以有一个单面粘在一边，没有色带，</p>
</li>
<li>
<p><strong>色带：</strong>如果你使用色带，你必须把它包在盒子周围的“腰带”上，</p>
</li>
<li>
<p><strong>蝴蝶结腰带：</strong>你可以将蝴蝶结融入蝴蝶结腰带，</p>
</li>
<li>
<p><strong>一个弓：</strong>你可能只使用一个弓或没有，</p>
</li>
<li>
<p><strong>消歧：</strong>如果所有方面都有缎带，就必须有弓。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最后一个公理与其他公理不同。它不是小学包装表的一部分，后来被致力于高维包装的精灵们发现。（也许有一天会进入课程？）在谈论色带时，“立方体的方块”公式是一种简化，因为有两种方法可以将色带垂直或水平地包裹在立方体的给定方格中。在只有一条皮带的情况下，带状皮带公制用于定义色带的方向。类似地，实际上有三种方法可以围绕立方体包裹色带，这样所有方法都会导致每个边都被色带触摸，即每种方式都可以从三个方向中挑选出两个带。因此，立方体的这种“包裹”是模糊的，必须禁止。</p>
</div>
<div class="paragraph">
<p>该`Propositional`包可以采取不将任何对象`Propositional::Variable`作为式中的变量的作用。如上所示，通常的逻辑连接符被重载，因此您可以在Raku程序中编写公式，就像在纸上一样。仅要求变量角色是一个重要的设计决策，并具有一些巧妙的含义。例如，重写捕获`^:p`我们之前看到的，也是`Propositional::Variable`在智能匹配时特别表现的对象。</p>
</div>
<div class="paragraph">
<p>在精灵的情况下，`Variable`是`WrapSquare`类和允许任意对象作为变量的另一个优点显示自己：任意变量可以有任意方法或操作符作用于它们。精灵用它来完成另一个*复杂性的减少*。他们只需要对3立方体的<strong>一个角</strong>进行公理化，然后使用3立方体的<a href="https://en.wikipedia.org/wiki/Hyperoctahedral_group">对称组进行处理</a>。这个群体动作将公理化的角落移动到立方体的<strong>每个</strong>角落，因此连接该动作的轨道给出了3d礼品包装的完全公理化。现在我们同意这听起来很棒，让我们看看它是如何在Raku中完成的。（*注意：*公理化涉及<a href="https://en.wikipedia.org/wiki/Logical_connective">逻辑连接词</a>你可能想要熟悉并遵循上面人类可读的公理。）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">multi axioms ($n = 3) {
    my \φ = .CNF with [∧] gather {
        take □&lt;**0&gt; ∨ ■&lt;**0&gt; ∨ 🎀&lt;**0&gt;;
        take □&lt;**0&gt; ⇒ ¬(■&lt;**0&gt; ∨ 🎀&lt;**0&gt;);
        take ■&lt;**0&gt; ⇒ ¬(□&lt;**0&gt; ∨ 🎀&lt;**0&gt;);
        take 🎀&lt;**0&gt; ⇒ ¬(□&lt;**0&gt; ∨ ■&lt;**0&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们选择二维面`<strong>0`作为公理化的特定角落。有三个关联布尔变量，即`□&lt;</strong>0&gt;`，<code>■&lt;<strong>0&gt;`和</strong></code><strong>!<a href="https://s0.wp.com/wp-content/mu-plugins/wpcom-smileys/twemoji/2/svg/1f380.svg">🎀</a>&lt;</strong>0&gt;`（方便，他们也可以被称为是在Raku的代码，这要归功于我们的`WrapSquare`构造函数运算符）。要具有明确定义的包装，必须至少设置这三个变量中的一个。</p>
</div>
<div class="paragraph">
<p>公理说必须设置三个变量*中的至少*一个。下一个公理规则如果碰巧是活跃的（意味着广场上只有礼品包装），那么（）它也不能（）是真的，或者（）也被设置。任何令人满意的任务，即SAT求解器将为我们找到的最终公式将实现这个公理，因为我们采取了一个大的AND超过块。</p>
</div>
<div class="paragraph">
<p>您被邀请将其他公式追溯到包装表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">        take ■&lt;**0&gt; ⇒ (■&lt;**1&gt; ∨ 🎀&lt;**1&gt;);
        take (■&lt;**0&gt; ∧ ■&lt;**1&gt;) ⇒ (■&lt;*0*&gt; ∨ 🎀&lt;*0*&gt; ∨ ■&lt;0**&gt; ∨ 🎀&lt;0**&gt;);
        take (🎀&lt;**0&gt; ∧ ■&lt;**1&gt;) ⇒ (■&lt;*0*&gt; ∨ ■&lt;0**&gt;);
        take (🎀&lt;**0&gt; ∧ (■&lt;*0*&gt; ∨ ■&lt;0**&gt;)) ⇒ ■&lt;**1&gt;;
        take 🎀&lt;**0&gt; ⇒ ¬(🎀&lt;**1&gt; ∨ 🎀&lt;*0*&gt; ∨ 🎀&lt;*1*&gt; ∨ 🎀&lt;0**&gt; ∨ 🎀&lt;1**&gt;);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们对3立方体的一个角进行了公理化，我们采用了超八面体组。这可以通过所谓的二元性的组合来实现，该二元性是`&amp;postfix:&lt;°&gt;`操作者实现的`Cube::Face`，并且`&amp;infix:&lt;⤩&gt;`操作者存在的立方体的轴的排列。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    my \ψ = φ.rewrite(:1ce,
        (^:s(WrapSquare)) =&gt; { $:s° }
    );
    return [∧] gather for (1,2,3).permutations -&gt; \π {
        take (φ ∧ ψ).rewrite(:1ce,
            (^:s(WrapSquare)) =&gt; { $:s ⤩ π }
        );</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个`rewrite`方法再次闪耀在这里。捕获变量可以使用smartmatcher进行约束，例如类型`WrapSquare`。它们只匹配并捕获匹配约束的内容。因此，上述重写规则仅对公式中的变量起作用，并且它们只执行它`:1ce`- 因为否则重写引擎会一遍又一遍地重写相同的变量，因为它们在每次迭代中都会重新匹配。</p>
</div>
<div class="paragraph">
<p>你注意到了什么吗？看起来精灵们忘记了消歧公理。但是 - 它没有被遗忘。它已经是对称的，不必参与上面的对称化过程。如果确实如此，就会不必要地重复。它来了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">        LAST take ¬(■&lt;**0&gt; ∧ ■&lt;**1&gt; ∧ ■&lt;*0*&gt; ∧ ■&lt;*1*&gt; ∧ ■&lt;0**&gt; ∧ ■&lt;1**&gt;);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，三维礼品包装公理是完整的。精灵们兴高采烈地跳舞。</p>
</div>
</div>
</div>
</div>
<h1 id="_把它包起来_2" class="sect0">把它包起来</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>让我们总结一下。为了包装更高维度的礼物，我们将三维礼物包裹起来并将包装拼凑在一起。为了使三维包裹物公理化，在其一个角落周围进行公理化并转动立方体并重复该过程就足够了，因此立方体的每个角落都是一个公理化的角落。这给出了描述所有正确包装的布尔公式。</p>
</div>
<div class="paragraph">
<p>但是，嘿，我们还没完成！giftoids和SAT求解器在哪里？为了使n-giftoids公理化，上面构造的3立方公理化必须在n立方体的每个3面复制。另一个`Cube::Face`操作员出现在这里，再次出现在`rewrite`。它将一个正方形嵌入到n立方体的三个面中，正如我们所需要的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi axioms ($n where * &gt; 3) {
    my \Φ = axioms;
    [∧] gather for Faces($n, 3) -&gt; \Δ {
        take Φ.rewrite(:1ce,
            (^:s(WrapSquare)) =&gt; { $:s ↗ Δ }
        )
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用SAT工具`Propositional`，我们现在可以获得3-4G和5-Giftoids的实数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say count-sat Giftoid::axioms(3), :now
#= OUTPUT: 28
say count-sat(Giftoid::axioms(3), :now)
#= OUTPUT: 1848
say  count-sat(Giftoid::axioms(3), :now)
#= OUTPUT: 58213276</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了感受SAT求解者所做的惊人工作，考虑到它`28`在729种可能性中找到了3-giftoids 的数量，`1848`在282429536481种可能性中找到了4-giftoids的数量，以及可能`58213276`总共为147808829414345923316083210206383297601可能性的5-giftoids。</p>
</div>
<div class="paragraph">
<p>当你自己尝试上面的代码示例时，你应该知道的是SAT求解器，特别是计数器，是非常需要内存的。5-giftoid计数需要5:14处理器分钟，笔记本电脑上有4 GiB RAM，不是没有交换，但它可以在笔记本电脑上完成！大多数求解器允许限制时间和内存使用，但Raku模块中尚未实现求解器配置。</p>
</div>
<div class="paragraph">
<p>绝对可行的是获得一个3-giftoids列表，其中3-cube的所有六个方块的赋值按特定顺序列出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">.put for all-sat(Giftoid::axioms).map({ Giftoid.new: n =&gt; 3, deco =&gt; $_ })
#=« OUTPUT:
■■■🎀■■
□□■🎀■■
■■■■🎀■
■■■■■🎀
■■🎀■■■
■🎀■■■■
□□■■🎀■
□□🎀■■■
□□■■■🎀
□□■■■■
■■□□■🎀
■■□□🎀■
...
»</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者确定固定维度的giftoids中的平均弓箭数，尽管你不会对这些弓箭走得太远：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub mean-bows ($n) {
    my ($sum, $count);
    all-sat(Giftoid::axioms($n)).map({
        $sum += +.keys.grep(*.kind eq &lt;🎀&gt;);
        $count++;
    });
    $sum / $count;
}

say mean-bows(3);
#= OUTPUT: 0.857143
say mean-bows(4);
#= OUTPUT: 2.766234</code></pre>
</div>
</div>
<div class="paragraph">
<p>预算精灵谨慎地提出一个问题：«如果你任意增加giftoids的维度，这是否意味着保持有限？毕竟，弓是最昂贵的…​…​»</p>
</div>
<div class="paragraph">
<p>我会让你在假期里思考这个问题。快乐的包装。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十一天_一个红色的圣诞老人">48. 第二十一天 - 一个红色的圣诞老人</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这一年即将结束，我们有很多值得庆祝的事情！与家人和朋友相比，庆祝今年年底更好的方式是什么？为了帮助实现这一目标，在我家，我们决定开办秘密圣诞老人游戏！所以，我的目标是写一个秘密圣诞老人计划！这就是我可以使用这个名为<a href="https://github.com/FCO/Red">Red的</a>精彩项目的地方。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/FCO/Red">Red</a>是一个仍在开发中的<strong>raku</strong>的*ORM* （对象关系模型），尚未作为模块发布。但它正在增长，而且接近发布。</p>
</div>
<div class="paragraph">
<p>因此，让我们创建我们的第一张桌子：一张桌子，用于存储参与我们的秘密圣诞老人的人。代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Red;

model Person {
   has UInt     $.id        is serial;
   has Str      $.name      is column;
   has Str      $.email     is column{ :nullable };
}

my $*RED-DB = database &#34;SQLite&#34;;

Person.^create-table;

Person.^create: :name&lt;Fernando&gt;,    :email&lt;fco@aco.com&gt;;
Person.^create: :name&lt;Aline&gt;,       :email&lt;aja@aco.com&gt;;
Person.^create: :name&lt;Fernanda&gt;;
Person.^create: :name&lt;Sophia&gt;;

.say for Person.^all.grep(*.email.defined).map: *.name;</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://github.com/FCO/Red">Red</a>将<strong>关系数据库</strong>映射  到<strong>OOP</strong>。每个表都映射到一个  <a href="https://github.com/FCO/Red"><strong>Red</strong></a>类（<strong>模型</strong>），每个表的  <strong>对象*代表*一行</strong>。</p>
</div>
<div class="paragraph">
<p>我们创建*模型的方式*是使用<strong>模型</strong>特殊单词。一个*模型*仅仅是延伸的正常类<strong>红::型号</strong> ，具有<strong>MetamodelX ::红::型号</strong>的对象作为它的  <strong>元类</strong>。 <a href="https://github.com/FCO/Red"><strong>Red</strong></a>不会向您的模型添加任何未明确创建的方法。因此，要与*数据库*进行交互，您应该使用*元类*。</p>
</div>
<div class="paragraph">
<p>但是让我们继续吧。</p>
</div>
<div class="paragraph">
<p>代码创建一个名为  <strong>Person*的新*模型</strong>。此*模型*表示的*表*的名称将与模型名称相同：“Person”。如有必要，您可以使用特征更改表的名称 （例如  <strong>:)</strong>。<code>is table&lt;…​&gt;</code> <code>model Person is table&lt;another_name&gt; {…​}</code></p>
</div>
<div class="paragraph">
<p>该*模型*有3个*属性*：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>$ .name</strong>有一个  <code>is column</code> <strong>特征</strong> ;</p>
</li>
<li>
<p><strong>$ .email</strong>有  <code>is column{ :nullable }</code>;</p>
</li>
<li>
<p>和<strong>$ .id</strong>有一个  <code>is serial</code>。这意味着同样的`is column{ :id, :auto-increment }`。</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><a href="https://github.com/FCO/Red"><strong>Red</strong></a>默认 使用*非空*列，因此如果要创建可以为空的列，则应使用 <code>is column{ :nullable }</code>。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>因此*Person*上的所有属性都是*列*。在`is serial`（我指的是  <code>:id</code> 一部分）意味着它是表的主键。</p>
</div>
<div class="paragraph">
<p>之后，它为结果设置*动态变量*（<code>$*RED-DB</code>）<code>database &#34;SQLite&#34;</code>。该<strong>数据库</strong> *子*收到*司机*的名字和它期望的参数。</p>
</div>
<div class="paragraph">
<p>在这种情况下，它使用*SQLite*  驱动程序，如果您不传递任何参数，它将使用它作为  <strong>内存</strong> <strong>数据库</strong>。如果要使用名为*secret-santa.db*  的文件作为数据库文件，则可以执行此操作`database &#34;SQLite&#34;, :database&lt;secret-santa.db&gt;`。或者，如果您想使用本地*Postgres*，只需使用   <code>database &#34;Pg&#34;</code>。 <a href="https://github.com/FCO/Red"><strong>Red</strong></a>  使用变量  <code>$*RED-DB</code> 来知道要使用的数据库。</p>
</div>
<div class="paragraph">
<p>好的，现在让我们创建*表*！正如我之前所说，<a href="https://github.com/FCO/Red"><strong>红</strong></a>没有添加任何*方法*你没有明确要求。因此，要创建*表，<strong>使用*元类</strong> &#39; <strong>方法</strong>。`Person.^create-table`是你如何创建*表*。</p>
</div>
<div class="paragraph">
<p>这将运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">CREATE TABLE person(
    id integer NOT NULL primary key AUTOINCREMENT,
    name varchar(255) NOT NULL,
    email varchar(255) NULL
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们应该插入一些数据。我们用另一个*meta方法*（<code>.^create</code>）来做到这一点。该  <code>.^create</code> <strong>元方法*预期相同*参数</strong> <code>.new</code>  的期望。每个*命名参数*都将设置一个具有相同名称的  <strong>属性</strong>。 <code>.^create`将创建一个新的*Person*对象，将其保存在  <strong>数据库中</strong>（with `.^save: :insert</code>），然后返回它。</p>
</div>
<div class="paragraph">
<p>它运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">INSERT INTO person(
    email,
    name
) VALUES(
    &#39;fco@aco.com&#39;,
    &#39;Fernando&#39;
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个*模型*都有一个*ResultSeq*。这是代表每一个序列*行*的*表*。我们可以 用（或）得到它的*ResultSeq*。<strong>ResultSeq*有一些方法可以帮助您从*表中*获取信息，例如：  将过滤*行</strong>（就像在普通*Seq中一样*），但它不会在内存中执行此操作，它会返回带有该过滤器集的新  <strong>ResultSeq</strong>。检索其*迭代器时*，它使用*ResultSeq*上设置的所有内容运行<strong>SQL</strong>查询  。<code>.<sup>all<code>.</code></sup><code>rs</code>.grep</code></p>
</div>
<div class="paragraph">
<p>在我们的示例中，`Person.^all.grep(*.email.defined).map: *.name`将运行如下查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">SELECT
    person.name
FROM
    person
WHERE
    email IS NOT NULL</code></pre>
</div>
</div>
<div class="paragraph">
<p>它会打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Fernando
Aline</code></pre>
</div>
</div>
<div class="paragraph">
<p>好的，我们有一个代码可以保存谁进入我们的秘密圣诞老人游戏。但每个人都想要不同的礼物。我们怎么知道每个人的意愿？</p>
</div>
<div class="paragraph">
<p>让我们修改代码，使其为参与秘密圣诞老人的每个人保存心愿单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Red;

model Person { ... }

model Wishlist {
    has UInt    $!id        is serial;
    has UInt    $!wisher-id is referencing{ Person.id };
    has Person  $.wisher    is relationship{ .wisher-id };
    has Str:D   $.name      is column is required;
    has Str     $.link      is column;
}

model Person is rw {
   has UInt     $.id        is serial;
   has Str      $.name      is column;
   has Str      $.email     is column;
   has Wishlist @.wishes    is relationship{ .wisher-id }
}

my $*RED-DB = database &#34;SQLite&#34;;

Wishlist.^create-table;
Person.^create-table;

my \fernando = Person.^create: :name&lt;Fernando&gt;, :email&lt;fco@aco.com&gt;;
fernando.wishes.create: :name&lt;Comma&gt;,          :link&lt;https://commaide.com&gt;;
fernando.wishes.create: :name(&#34;raku books&#34;),  :link&lt;https://rakubook.com&gt;;
fernando.wishes.create: :name(&#34;mac book pro&#34;), :link&lt;https://www.apple.com/shop/buy-mac/macbook-pro/15-inch-space-gray-2.6ghz-6-core-512gb#&gt;;

my \aline = Person.^create: :name&lt;Aline&gt;, :email&lt;aja@aco.com&gt;;
aline.wishes.create: :name(&#34;a new closet&#34;), :link&lt;https://i.pinimg.com/474x/02/05/93/020593b34c205792a6a7fd7191333fc6--wardrobe-behind-bed-false-wall-wardrobe.jpg&gt;;

my \fernanda = Person.^create: :name&lt;Fernanda&gt;, :email&lt;faco@aco.com&gt;;
fernanda.wishes.create: :name(&#34;mimikyu plush&#34;), :link&lt;https://www.pokemoncenter.com/mimikyu-poké-plush-%28standard-size%29---10-701-02831&gt;;
fernanda.wishes.create: :name(&#34;camelia plush&#34;), :link&lt;https://farm9.static.flickr.com/8432/28947786492_80056225f3_b.jpg&gt;;

my \sophia = Person.^create: :name&lt;Sophia&gt;, :email&lt;saco@aco.com&gt;;
sophia.wishes.create: :name(&#34;baby alive&#34;), :link&lt;https://www.target.com/p/baby-alive-face-paint-fairy-brunette/-/A-51304817&gt;;

say &#34;\n{ .name }\n{ .wishes.map({&#34; { .name } =&gt; { .link }&#34; }).join(&#34;\n&#34;).indent: 3 }&#34; for Person.^all</code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Fernando
    Comma =&gt; https://commaide.com
    raku books =&gt; https://rakubook.com
    mac book pro =&gt; https://www.apple.com/shop/buy-mac/macbook-pro/15-inch-space-gray-2.6ghz-6-core-512gb#

Aline
    a new closet =&gt; https://i.pinimg.com/474x/02/05/93/020593b34c205792a6a7fd7191333fc6--wardrobe-behind-bed-false-wall-wardrobe.jpg

Fernanda
    mimikyu plush =&gt; https://www.pokemoncenter.com/mimikyu-poké-plush-%28standard-size%29---10-701-02831
    camelia plush =&gt; https://farm9.static.flickr.com/8432/28947786492_80056225f3_b.jpg

Sophia
    baby alive =&gt; https://www.target.com/p/baby-alive-face-paint-fairy-brunette/-/A-51304817</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们有一个新的  <strong>模型</strong> <strong>愿望清单</strong>  ，它引用了一个名为*withlist*的表  。它  <code>$!id</code> 作为  <strong>ID</strong>，  <code>$!name</code> 并  <code>$!link</code> 为列，也有一些新的东西！ <code>has UInt $!wisher-id is referencing{ Person.id };</code> 是一样  <code>has UInt $!wisher-id is column{ :references{ Person.id } };</code> ，这意味着它是一个*列*，这是一个  <strong>外键</strong>  引用  <strong>ID</strong> <strong>的人*的*列</strong>。它也有  <code>has Person $.wisher is relationship{ .wisher-id };</code> 它<strong>不是</strong>一个*列*，这是一个“虚拟”。在  <strong>$</strong>  <strong>印记</strong>  意味着有  <strong>只有1</strong>好心人˚F <strong>或</strong>愿望。并  <code>is relationship</code> 期待一个  <strong>Callable</strong> 这将获得一个  <strong>模型</strong>。如果它是  <strong>标量</strong>  ，它将接收当前  <strong>模型</strong>  作为唯一参数。所以，在这种情况下，它将是  <strong>愿望清单</strong>。该relationsip的回报  <strong>可赎回</strong>  必须是*列*引用其他一些*列*。</p>
</div>
<div class="paragraph">
<p>让我们看看这个表是如何创建的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">CREATE TABLE wishlist(
   id integer NOT NULL primary key,
   name varchar(255) NOT NULL,
   link varchar(255) NULL,
   wisher_id integer NULL references person(id)
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，没有   创建*wisher*列。</p>
</div>
<div class="paragraph">
<p>该  <strong>人</strong> <strong>模式</strong>  也发生了变化！现在它有一个  <code>@.wishes</code> <strong>关系</strong>（<code>has Wishlist @.wishes is relationship{ .wisher-id }</code>）。它使用  <strong>@</strong>  <strong>sigil，</strong>  因此每个  <strong>人</strong> 都可以拥有多个愿望。 传递的  <strong>Callable*将接收*Positional</strong> <strong>属性*的类型   （ 在此情况下为*Wishlist</strong>），并且必须返回引用其他列的列。</p>
</div>
<div class="paragraph">
<p>创建的表与以前相同。</p>
</div>
<div class="paragraph">
<p>我们之前创建了一个新的  <strong>Person</strong>  ：  <code>my \fernando = Person.^create: :name&lt;Fernando&gt;, :email&lt;<a href="mailto:fco@aco.com">fco@aco.com</a>&gt;;</code> 现在我们可以使用*关系*（<strong>愿望</strong>）来创建一个新的愿望（）。这为Fernando运行以下SQL创建了一个新的愿望：<code>fernando.wishes.create: :name&lt;Comma&gt;, :link<a href="https://commaide.com" class="bare">https://commaide.com</a></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">INSERT INTO wishlist(
   name,
   link,
   wisher_id
) VALUES(
   &#39;Comma&#39;,
   &#39;https://commaide.com&#39;,
   1
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>你看过了吗？ <code>wisher_id</code> 是  <strong>1</strong> …​ 1是费尔南多的身份。一旦你创建了Fernando的<strong>.wishes（）</strong>的愿望  ，它已经知道它属于Fernando。</p>
</div>
<div class="paragraph">
<p>然后我们为我们创造的每个人定义愿望。</p>
</div>
<div class="paragraph">
<p>然后我们遍历 数据库中的每个  <strong>Person</strong>（<code>Person.^all</code>）并打印其名称并循环该人的意愿并打印其名称和链接。</p>
</div>
<div class="paragraph">
<p>哦，我们可以拯救谁参与…​…​得到他们想要的东西…​…​但是平局？我应该送谁礼物？为此，我们再次更改程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use lib &lt;lib&gt;;
use Red;

model Person { ... }

model Wishlist {
    has UInt    $!id        is id;
    has UInt    $!wisher-id is referencing{ Person.id };
    has Person  $.wisher    is relationship{ .wisher-id };
    has Str:D   $.name      is column is required;
    has Str     $.link      is column;
}

model Person is rw {
   has UInt     $.id        is id;
   has Str      $.name      is column;
   has Str      $.email     is column;
   has UInt     $!pair-id   is referencing{ ::?CLASS.^alias.id };
   has ::?CLASS $.pair      is relationship{ .pair-id };
   has Wishlist @.wishes    is relationship{ .wisher-id }

   method draw(::?CLASS:U:) {
      my @people = self.^all.pick: *;
      for flat @people.rotor: 2 =&gt; -1 -&gt; $p1, $p2 {
         $p1.pair = $p2;
         $p1.^save;
      }
      given @people.tail {
         .pair = @people.head;
         .^save
      }
   }
}

my $*RED-DB = database &#34;SQLite&#34;;

Wishlist.^create-table;
Person.^create-table;

my \fernando = Person.^create: :name&lt;Fernando&gt;, :email&lt;fco@aco.com&gt;;
fernando.wishes.create: :name&lt;Comma&gt;,            :link&lt;https://commaide.com&gt;;
fernando.wishes.create: :name(&#34;raku books&#34;),    :link&lt;https://rakubook.com&gt;;
fernando.wishes.create: :name(&#34;mac book pro&#34;),   :link&lt;https://www.apple.com/shop/buy-mac/macbook-pro/15-inch-space-gray-2.6ghz-6-core-512gb#&gt;;

my \aline = Person.^create: :name&lt;Aline&gt;, :email&lt;aja@aco.com&gt;;
aline.wishes.create: :name(&#34;a new closet&#34;), :link&lt;https://i.pinimg.com/474x/02/05/93/020593b34c205792a6a7fd7191333fc6--wardrobe-behind-bed-false-wall-wardrobe.jpg&gt;;

my \fernanda = Person.^create: :name&lt;Fernanda&gt;, :email&lt;faco@aco.com&gt;;
fernanda.wishes.create: :name(&#34;mimikyu plush&#34;), :link&lt;https://www.pokemoncenter.com/mimikyu-poké-plush-%28standard-size%29---10-701-02831&gt;;
fernanda.wishes.create: :name(&#34;camelia plush&#34;), :link&lt;https://farm9.static.flickr.com/8432/28947786492_80056225f3_b.jpg&gt;;

my \sophia = Person.^create: :name&lt;Sophia&gt;,   :email&lt;saco@aco.com&gt;;
sophia.wishes.create: :name(&#34;baby alive&#34;),      :link&lt;https://www.target.com/p/baby-alive-face-paint-fairy-brunette/-/A-51304817&gt;;

Person.draw;

say &#34;{ .name } -&gt; { .pair.name }\n\tWishlist: { .pair.wishes.map(*.name).join: &#34;, &#34; }&#34; for Person.^all</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在<strong>Person</strong>  有两个新*属性*  （<strong>$！pair-id</strong>和<strong>$ .pair</strong>）和一个新方法（<strong>draw</strong>）。 <strong>$！pair-id</strong>  是一个 引用 同一个*表*  （<strong>Person</strong>）上  的字段<strong>id</strong>的*外键*，因此我们必须使用  <strong>别名</strong>  （）。另一个是使用该*外键*的*关系*  （<strong>$ .pair</strong>）。<code>.^alias</code></p>
</div>
<div class="paragraph">
<p>新方法（<strong>平局</strong>）是神奇发生的地方。它使用方法  <strong>.pick：\</strong>*  在普通的  <strong>Positional</strong>  上将洗牌。它在这里做同样的事情，查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT
   person.email , person.id , person.name , person.pair_id as &#34;pair-id&#34;
FROM
   person
ORDER BY
   random()</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦我们有了洗牌列表，我们就会使用  <strong>.rotor</strong>  来获取两个项目并返回一个，所以我们保存每个人给予下一个人的那一对，并且列表中的最后一个人将给第一个人。</p>
</div>
<div class="paragraph">
<p>这是我们最终代码的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Fernando -&gt; Sophia
	Wishlist: baby alive
Aline -&gt; Fernanda
	Wishlist: mimikyu plush, camelia plush
Fernanda -&gt; Fernando
	Wishlist: COMMA, raku books, mac book pro
Sophia -&gt; Aline
	Wishlist: a new closet</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为奖励，让我们看一下Red将要跟随的曲目。这是当前的工作代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Red;

model Person {
   has UInt     $.id        is id;
   has Str      $.name      is column;
   has Str      $.email     is column{ :nullable };
}

my $*RED-DB = database &#34;SQLite&#34;;

Person.^create-table;

Person.^create: :name&lt;Fernando&gt;,    :email&lt;fco@aco.com&gt;;
Person.^create: :name&lt;Aline&gt;,       :email&lt;aja@aco.com&gt;;
Person.^create: :name&lt;Fernanda&gt;;
Person.^create: :name&lt;Sophia&gt;;

.say for Person.^all.map: { &#34;{ .name }{ &#34; =&gt; { .email }&#34; if .email }&#34; };</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是它运行的SQL：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT
   CASE
      WHEN (email == &#39;&#39; OR email IS NULL) THEN name
   ELSE name || &#39; =&gt; &#39; || email
   END
    as &#34;data&#34;
FROM
   person</code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Fernando =&gt; fco@aco.com
Aline =&gt; aja@aco.com
Fernanda
Sophia</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十二天_测试_cro_http_api">49. 第二十二天 - 测试 Cro HTTP API</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_测试cro_http_api">49.1. 测试Cro HTTP API</h3>
<div class="paragraph">
<p>今年我花了大量的工作时间用于构建一些 Raku 应用程序。经过为 Raku 编译器和运行时开发贡献代码十年之后，最终使用它来提供解决实际问题的生产解决方案感觉很棒。我还不确定在我创建的<a href="http://www.commaide.com/">IDE中</a>编写代码，使用我设计的<a href="https://cro.services/">HTTP库</a>，由我实现大部分的<a href="https://rakudo.org/">编译器编译</a>，并在我扮演架构师的<a href="https://moarvm.org/">VM</a>上运行，是否会使我成为世界上最差的“尚未发明”的案例，或者只是真正的全栈。</p>
</div>
<div class="paragraph">
<p>无论我在做什么，我都非常重视自动化测试。每一次通过测试我都知道有东西能工作了  - 当我改进有问题的软件时，我不会破坏这些测试。即使使用自动化测试，也会发生错误，但是添加测试来弥补错误至少意味着我将来会犯下*不同的*错误，这可能有点可以原谅。</p>
</div>
<div class="paragraph">
<p>我目前正在处理的系统中的大多数代码和复杂性都在其域对象中。这些是通过使用Cro实现的HTTP API实现的 - 与系统的其他部分一样，此 HTTP API 具有自动化测试。他们使用我的一个旧模块`Test::Mock`- 以及今年发布的新模块，<code>Cro::HTTP::Test</code>。在今天的 Advent 文章中，我将讨论我如何一起使用它们，结果我觉得非常讨人喜欢。</p>
</div>
<div class="sect3">
<h4 id="_一个示例问题">49.1.1. 一个示例问题</h4>
<div class="paragraph">
<p>这是 advent 日历，所以当然我需要一个足够节日化的例子问题。对我而言，中欧圣诞时间的亮点之一是圣诞市场，有许多都坐落在美丽的历史城市广场上。除了香肠和热葡萄酒之外，我们还需要在广场上吗？当然，这是一棵高大帅气的圣诞树！但如何找到最好的树？好吧，我们通过建立一个系统来提供互联网帮助，他们可以提交他们认为可能适合的圣诞树的建议。什么可能出错？</p>
</div>
<div class="paragraph">
<p>可以 PUT 到路由 <code>/trees/{latitude}/{longitude}</code> 以在该位置提交候选圣诞树。预期的有效负载是带有树的高度( <code>height</code>) 的 JSON blob，以及 10-200 个文本字符的描述(<code>description</code>)，解释为什么这棵圣诞树太棒了。如果同一位置已经提交了圣诞树，则应返回 <code>409 Conflict</code> 响应。如果圣诞树被接受，那么将生成一个简单的 <code>200 OK</code> 响应，并带有一个 JSON 格式的主体描述该圣诞树。</p>
</div>
<div class="paragraph">
<p>同一 URI 的 GET 将返回相关树的描述，而 GET <code>/trees</code> 将返回已提交的树，最高的圣诞树排第一个。</p>
</div>
</div>
<div class="sect3">
<h4 id="_可测性">49.1.2. 可测性</h4>
<div class="paragraph">
<p>回到高中，科学课肯定是我最喜欢的。我们不时地做实验。当然，每个实验都需要编写 - 包括之前的计划，结果和对它们的分析。规划中最重要的部分之一是关于如何确保“公平测试”：我们如何试图控制我们还未尝试测试的所有事情，以便我们可以信任我们的观察并从中得出结论？</p>
</div>
<div class="paragraph">
<p>软件测试涉及大致相同的思考过程：我们如何运用我们感兴趣的组件，同时控制它们运行的上下文？有时，我们很幸运，我们正在测试纯粹的逻辑：它不依赖于我们提供给它的东西以外的任何东西。事实上，我们可以在这方面*创造自己的运气*，发现我们系统中可以是纯函数或不可变对象的部分。从我正在研究的当前系统中获取示例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们有一个由一堆规范文件构建的对象模型。
构建它的过程非常复杂，包括一系列健全性
检查，一些图形算法等等。但结果是
一堆*不可变的对象*。一旦建成，它们永远不会改变。
测试很简单：丢出一堆测试输入，并检查它是否
构建了预期的对象。</p>
</li>
<li>
<p>我们有一个计算器的小语言。
语言中表达式使用的数据作为参数传递给计算器，
然后我们可以检查结果是否符合预期。因此，计算器
是一个*纯函数*。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，为可测试性做的第一件事就是找到可以像这样的系统部分并以这种方式构建它们。唉，并非所有事情都如此简单。HTTP API 通常是可变状态的网关，数据库操作等。此外，良好的 HTTP API 会将域级别的错误条件映射到适当的 HTTP 状态代码。我们希望能够在我们的测试中创建这样的情况，以便覆盖它们。这是一个类似 `Test::Mock`工具入场的地方, 但要使用它，我们需要以一种对测试友好的方式考虑我们的Cro服务。</p>
</div>
</div>
<div class="sect3">
<h4 id="_打桩服务">49.1.3. 打桩服务</h4>
<div class="paragraph">
<p>对于那些刚接触Cro的人，让我们来看看我们可以编写的最低限度，以便启动和运行HTTP服务，提供有关树的一些假数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">use Cro::HTTP::Router;
use Cro::HTTP::Server;

my $application = route {
    get -&gt; &#39;trees&#39; {
        content &#39;application/json&#39;, [
            {
                longitude =&gt; 50.4311548,
                latitude =&gt; 14.586079,
                height =&gt; 4.2,
                description =&gt; &#39;Nice color, very bushy&#39;
            },
            {
                longitude =&gt; 50.5466504,
                latitude =&gt; 14.8438714,
                height =&gt; 7.8,
                description =&gt; &#39;Really tall and wide&#39;
            },
        ]
    }
}

my $server = Cro::HTTP::Server.new(:port(10000), :$application);
$server.start;
react whenever signal(SIGINT) {
    $server.stop;
    exit;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这不是一个能够测试我们路由的好方法。更好的方法是将路由放入 <code>lib/BestTree.pm6</code> 模块中的子例程中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module BestTree;
use Cro::HTTP::Router;

sub routes() is export {
    route {
        get -&gt; &#39;trees&#39; {
            content &#39;application/json&#39;, [
                {
                    longitude =&gt; 50.4311548,
                    latitude =&gt; 14.586079,
                    height =&gt; 4.2,
                    description =&gt; &#39;Nice color, very bushy&#39;
                },
                {
                    longitude =&gt; 50.5466504,
                    latitude =&gt; 14.8438714,
                    height =&gt; 7.8,
                    description =&gt; &#39;Really tall and wide&#39;
                },
            ]
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并从脚本中使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use BestTree;
use Cro::HTTP::Server;

my $application = routes();
my $server = Cro::HTTP::Server.new(:port(10000), :$application);
$server.start;
react whenever signal(SIGINT) {
    $server.stop;
    exit;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，如果我们有一些东西可以用来测试`route`块做正确的事情，我们可以使用(<code>use</code>)这个模块，继续我们的测试。</p>
</div>
</div>
<div class="sect3">
<h4 id="_存储模型等">49.1.4. 存储、模型等</h4>
<div class="paragraph">
<p>然而，还有另一个问题。我们的圣诞树服务将在一些数据库中存储树信息，并执行各种规则。这个逻辑应该去哪里？</p>
</div>
<div class="paragraph">
<p>我们有许多方法来安排这段代码，但最关键的是，这种逻辑并不属于我们的Cro路由处理程序。他们的工作是在域对象和HTTP世界之间进行映射，例如将域异常转换为适当的HTTP错误响应。那个映射是我们想要测试的。</p>
</div>
<div class="paragraph">
<p>所以，在我们继续之前，让我们来定义一些这些东西的外观。我们将有一个`BestTree::Tree`代表树的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class BestTree::Tree {
    has Rat $.latitude;
    has Rat $.longitude;
    has Rat $.height;
    has Str $.description;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将使用一个`BestTree::Store`对象。我们实际上不会将此作为此帖的一部分来实现; 这将是我们在测试中假装的东西。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class BestTree::Store {
    method all-trees() { ... }
    method suggest-tree(BestTree::Tree $tree --&gt; Nil) { ... }
    method find-tree(Rat $latitude, Rat $longitude --&gt; BestTree::Tree) { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是我们如何安排事情以便我们可以控制路由使用的存储，以进行测试？一个简单的方法是使它成为我们`routes`子程序的参数，这意味着它将在`route`块中可用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">sub routes(BestTree::Store $store) is export {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个功能因素。有些人可能更喜欢使用某种容器来使用某种基于OO的依赖注入。这也适用于Cro：只需要一个返回`route`块的方法。（如果使用Cro构建非常小的东西，请查看<a href="https://cro.services/docs/structuring-services">有关结构化服务</a>的<a href="https://cro.services/docs/structuring-services">文档，</a>以获得有关此方面的一些进一步建议。）</p>
</div>
</div>
<div class="sect3">
<h4 id="_获取树的清单">49.1.5. 获取树的清单</h4>
<div class="paragraph">
<p>现在我们准备开始编写测试了！让我们存根测试文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use BestTree;
use BestTree::Store;
use Cro::HTTP::Test;
use Test::Mock;
use Test;

# Tests will go here

done-testing;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用`BestTree`，它包含我们想要测试的路由，以及：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Cro::HTTP::Test</code>，我们将用它来轻松编写我们的路由测试</p>
</li>
<li>
<p><code>Test::Mock</code>，我们将用它来伪造存储</p>
</li>
<li>
<p><code>Test</code>，我们并不严格需要，但有权访问`subtest`将
让我们产生更有条理的测试输出</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>接下来，我们将在测试中使用几个树对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fake-tree-a = BestTree::Tree.new:
        latitude =&gt; 50.4311548,
        longitude =&gt; 14.586079,
        height =&gt; 4.2,
        description =&gt; &#39;Nice color, very bushy&#39;;
my $fake-tree-b = BestTree::Tree.new:
        latitude =&gt; 50.5466504,
        longitude =&gt; 14.8438714,
        height =&gt; 7.8,
        description =&gt; &#39;Really tall and wide&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是第一次测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subtest &#39;Get all trees&#39; =&gt; {
    my $fake-store = mocked BestTree::Store, returning =&gt; {
        all-trees =&gt; [$fake-tree-a, $fake-tree-b]
    };
    test-service routes($fake-store), {
        test get(&#39;/trees&#39;),
                status =&gt; 200,
                json =&gt; [
                    {
                        latitude =&gt; 50.4311548,
                        longitude =&gt; 14.586079,
                        height =&gt; 4.2,
                        description =&gt; &#39;Nice color, very bushy&#39;
                    },
                    {
                        latitude =&gt; 50.5466504,
                        longitude =&gt; 14.8438714,
                        height =&gt; 7.8,
                        description =&gt; &#39;Really tall and wide&#39;
                    }
                ];
        check-mock $fake-store,
                *.called(&#39;all-trees&#39;, times =&gt; 1, with =&gt; \());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，我们伪造一个 <code>BestTree::Store</code>，无论何时`all-trees`被调用，都将返回我们指定的伪数据。然后我们使用`test-service`，传递`route`用假存储创建的块。随后的块内的所有 <code>test</code> 调用都将针对该`route`块执行。</p>
</div>
<div class="paragraph">
<p>请注意，在这里我们不必担心运行HTTP服务来托管我们要测试的路由。实际上，由于Cro的管道架构，我们很容易就可以使用Cro HTTP客户端，连接其TCP消息输出以将它想要的数据发送到 Raku `Channel`中，然后将这些数据推送到服务管道的TCP消息的输入管道中，反之亦然。这意味着我们一路测试到发送和接收的字节，但实际上不必命中本地网络堆栈。（旁白：您也可以使用`Cro::HTTP::Test`URI，这意味着如果您真的想要启动测试服务器，或者甚至想针对在不同进程中运行的其他服务编写测试，您可以这样做。）</p>
</div>
<div class="paragraph">
<p>该`test`程序规定了测试案例。它的第一个参数描述了我们希望执行的请求 - 在这种情况下，是一个到 <code>/trees</code> 的`get` 。然后，命名参数指定响应的外观。该`status`检查将确保我们取回了预期的HTTP状态代码。该`json`检查实际上是一个里面有俩个：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它检查 HTTP 的 content-type 是否为 JSON</p>
</li>
<li>
<p>它检查反序列化为提供的JSON的正文（如果你不想
测试它的每一个，在那里传递一个块，应该计算为`True`）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果这就是我们所做的，并且我们运行了测试，我们会发现它们神秘地通过了，即使我们还没有编辑我们的`route`块的`get`处理程序来实际使用存储！为什么？因为事实证明我很懒，并且使用我之前的小服务器示例中的数据作为我的测试数据。不用担心：为了使测试更强大，我们可以添加一个对 <code>check-mock</code> 的调用，然后断言我们的假存储确实调用了一次 <code>all-trees</code> 方法，并且没有传递参数。</p>
</div>
<div class="paragraph">
<p>这让我们通过正确实现处理程序来使测试通过：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;trees&#39; {
    content &#39;application/json&#39;, [
        $store.all-trees.map: -&gt; $tree {
            {
                latitude =&gt; $tree.latitude,
                longitude =&gt; $tree.longitude,
                height =&gt; $tree.height,
                description =&gt; $tree.description
            }
        }
    ]
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_得到一棵树">49.1.6. 得到一棵树</h4>
<div class="paragraph">
<p>下一次测试的时间：获得一棵树。这里有两种情况需要考虑：一个是树是在哪里找到的，以及树是在哪里找不到的。这是对树是在哪里找到的情况的测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subtest &#39;Get a tree that exists&#39; =&gt; {
    my $fake-store = mocked BestTree::Store, returning =&gt; {
        find-tree =&gt; $fake-tree-b
    };
    test-service routes($fake-store), {
        test get(&#39;/trees/50.5466504/14.8438714&#39;),
                status =&gt; 200,
                json =&gt; {
                    latitude =&gt; 50.5466504,
                    longitude =&gt; 14.8438714,
                    height =&gt; 7.8,
                    description =&gt; &#39;Really tall and wide&#39;
                };
        check-mock $fake-store,
                *.called(&#39;find-tree&#39;, times =&gt; 1, with =&gt; \(50.5466504, 14.8438714));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在运行它失败了。事实上，`status`代码检查首先失败，因为我们还没有实现路由，因此得到404，而不是预期的200. 所以，这是一个让它通过的实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">        get -&gt; &#39;trees&#39;, Rat() $latitude, Rat() $longitude {
            given $store.find-tree($latitude, $longitude) -&gt; $tree {
                content &#39;application/json&#39;, {
                    latitude =&gt; $tree.latitude,
                    longitude =&gt; $tree.longitude,
                    height =&gt; $tree.height,
                    description =&gt; $tree.description
                }
            }
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>从其他路由来看，这部分看起来有些熟悉，不是吗？所以，有了两次通过测试，让我们继续重构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;trees&#39; {
    content &#39;application/json&#39;,
            [$store.all-trees.map(&amp;tree-for-json)];
}

get -&gt; &#39;trees&#39;, Rat() $latitude, Rat() $longitude {
    given $store.find-tree($latitude, $longitude) -&gt; $tree {
        content &#39;application/json&#39;, tree-for-json($tree);
    }
}

sub tree-for-json(BestTree::Tree $tree --&gt; Hash) {
    return {
        latitude =&gt; $tree.latitude,
        longitude =&gt; $tree.longitude,
        height =&gt; $tree.height,
        description =&gt; $tree.description
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>测试通过，我们知道我们的重构很好。但是等一下，如果那里没有树怎么办？在这种情况下，存储将返回`Nil`。我们想把它映射到404.这是另一个测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subtest &#39;Get a tree that does not exist&#39; =&gt; {
    my $fake-store = mocked BestTree::Store, returning =&gt; {
        find-tree =&gt; Nil
    };
    test-service routes($fake-store), {
        test get(&#39;/trees/50.5466504/14.8438714&#39;),
                status =&gt; 404;
        check-mock $fake-store,
                *.called(&#39;find-tree&#39;, times =&gt; 1, with =&gt; \(50.5466504, 14.8438714));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上，由于我们在路由块中没有考虑这种情况，因此失败了, 返回 500 错误码。令人高兴的是，这个很容易处理：把 <code>given`变成 `with</code>，它检查我们得到了一个已定义的对象，然后添加一个`else`并生成404 Not Found响应。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;trees&#39;, Rat() $latitude, Rat() $longitude {
    with $store.find-tree($latitude, $longitude) -&gt; $tree {
        content &#39;application/json&#39;, tree-for-json($tree);
    }
    else {
        not-found;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_提交一棵树">49.1.7. 提交一棵树</h4>
<div class="paragraph">
<p>最后但并非最不重要的是，让我们测试建议新树的路由。这是成功的情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subtest &#39;Suggest a tree successfully&#39; =&gt; {
    my $fake-store = mocked BestTree::Store;
    test-service routes($fake-store), {
        my %body = description =&gt; &#39;Awesome tree&#39;, height =&gt; 4.25;
        test put(&#39;/trees/50.5466504/14.8438714&#39;, json =&gt; %body),
                status =&gt; 200,
                json =&gt; {
                    latitude =&gt; 50.5466504,
                    longitude =&gt; 14.8438714,
                    height =&gt; 4.25,
                    description =&gt; &#39;Awesome tree&#39;
                };
        check-mock $fake-store,
                *.called(&#39;suggest-tree&#39;, times =&gt; 1, with =&gt; :(
                    BestTree::Tree $tree where {
                        .latitude == 50.5466504 &amp;&amp;
                        .longitude == 14.8438714 &amp;&amp;
                        .height == 4.25 &amp;&amp;
                        .description eq &#39;Awesome tree&#39;
                    }
                ));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>大部分都很熟悉，除了这次`check-mock` 调用看起来有点不同。<code>Test::Mock`让我们用两种不同的方式测试参数： `Capture</code>（我们到目前为止）或者 <code>Signature</code>。这个`Capture`案例非常适用于所有简单情况，我们只处理无聊的值。但是，一旦我们进入引用类型，或者如果我们实际上并不关心确切的值并且只是想断言我们关心的事情，签名就会让我们灵活地做到这一点。这里，我们使用一个`where`子句来检查路由处理程序构造的树对象是否包含预期的数据。</p>
</div>
<div class="paragraph">
<p>这是执行此操作的路由处理程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put -&gt; &#39;trees&#39;, Rat() $latitude, Rat() $longitude {
    request-body -&gt; (Rat(Real) :$height!, Str :$description!) {
        my $tree = BestTree::Tree.new: :$latitude, :$longitude,
                :$height, :$description;
        $store.suggest-tree($tree);
        content &#39;application/json&#39;, tree-for-json($tree);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意Cro如何让我们使用Raku签名来构建请求体。在一行中，我们说过：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>请求正文必须具有高度和描述</p>
</li>
<li>
<p>我们希望高度是一个`Real`数字</p>
</li>
<li>
<p>我们希望描述是一个字符串</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果其中任何一个失败，Cro将自动为我们产生400不良请求。事实上，我们可以编写测试来覆盖它 - 以及一个新的测试，以确保冲突将导致409。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subtest &#39;Problems suggesting a tree&#39; =&gt; {
    my $fake-store = mocked BestTree::Store, computing =&gt; {
        suggest-tree =&gt; {
            die X::BestTree::Store::AlreadySuggested.new;
        }
    }
    test-service routes($fake-store), {
        # Missing or bad data.
        test put(&#39;/trees/50.5466504/14.8438714&#39;, json =&gt; {}),
                status =&gt; 400;
        my %bad-body = description =&gt; &#39;ok&#39;;
        test put(&#39;/trees/50.5466504/14.8438714&#39;, json =&gt; %bad-body),
                status =&gt; 400;
        %bad-body&lt;height&gt; = &#39;grinch&#39;;
        test put(&#39;/trees/50.5466504/14.8438714&#39;, json =&gt; %bad-body),
                status =&gt; 400;

        # Conflict.
        my %body = description =&gt; &#39;Awesome tree&#39;, height =&gt; 4.25;
        test put(&#39;/trees/50.5466504/14.8438714&#39;, json =&gt; %body),
                status =&gt; 409;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的主要新事物是我们使用`computing`而不是带有 <code>mocked</code> 的`returning`。在这种情况下，我们传递一个块，它将被执行。（然而，该块不会获取方法参数。如果我们想要获取这些参数，则有第三个选项，<code>overriding</code>, 其中我们可以获取参数并编写一个假的方法体。）</p>
</div>
<div class="paragraph">
<p>以及如何处理？通过使我们的路由处理程序捕获并映射类型化的异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put -&gt; &#39;trees&#39;, Rat() $latitude, Rat() $longitude {
    request-body -&gt; (Rat(Real) :$height!, Str :$description!) {
        my $tree = BestTree::Tree.new: :$latitude, :$longitude,
                :$height, :$description;
        $store.suggest-tree($tree);
        content &#39;application/json&#39;, tree-for-json($tree);
        CATCH {
            when X::BestTree::Store::AlreadySuggested {
                conflict;
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_结束思考">49.1.8. 结束思考</h4>
<div class="paragraph">
<p>有了`Cro::HTTP::Test`，现在有一种很好的方法可以在Raku中编写HTTP测试。结合可测试的设计，也许是一个类似的模块`Test::Mock`，我们也可以将我们的Cro路由处理程序与其他所有东西隔离开来，从而简化测试。</p>
</div>
<div class="paragraph">
<p>我们的路由处理程序中的逻辑相对简单; 通常是小样本问题。然而，即使在这里，我发现旅程中有价值，而不仅仅是在目的地。为HTTP API编写测试的行为让我置身于任何将调用API的人的心中，这可能是一个有用的观点。经验还告诉我们，测试“太简单到失败”最终会导致错误：我可能会认为我犯得太聪明了。纪律有很长的路要走。在哪个方面，我现在会受到纪律处分，不时地从键盘上休息一下，然后去享受圣诞市场。-Ofun！</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十三天_blin很快就到圣诞节了">50. 第二十三天 - Blin，很快就到圣诞节了！</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rakuadvent.wordpress.com/2016/12/23/">两年前</a>我已经在出现一篇 advent 文章里提到过 Bisectable，但自那时以来发生了很多变化，所以我觉得是时候简要介绍一下 <code>bisectable</code> 机器人和它的朋友们了。</p>
</div>
<div class="paragraph">
<p>首先，让我们来定义正在解决的问题。有时会<a href="https://github.com/rakudo/rakudo/issues?q=is%3Aopen+is%3Aissue+label%3Aregression">发生</a>提交引入意外更改行为（错误）。通常我们称之为回归，在某些情况下，找出错误并修复它的最简单方法是首先找到引入回归的提交。</p>
</div>
<div class="paragraph">
<p>Rakudo 2015.12 和 2018.12 之间有<a href="https://github.com/Rakudo/Rakudo/compare/2015.12…​2018.12">9000个</a>提交，尽管它不*超过9000*，但仍然很多。</p>
</div>
<div class="paragraph">
<p>幸运的是，我们不需要测试所有修改。假设行为不是一直来回变化，我们可以使用<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">二分法查找</a>。</p>
</div>
<div class="sect2">
<h3 id="_git_bisect_和二分法查找">50.1. <code>git bisect</code> 和二分法查找</h3>
<div class="paragraph">
<p>基本上，给定任何提交范围，我们在范围的“中间”取一个提交提交并测试它。如果它是“坏”或者它显示“新”（现在是不正确的）行为，那么我们就可以抛弃我们范围的后半部分（因为我们知道更改必须在该提交之前发生或完全在该提交之后）。同样，如果它是“好”（或“旧”），我们会扔掉另一半。因此，我们只需检查`log n`个修改（≈13），而不是测试所有 9000 次提交。</p>
</div>
<div class="paragraph">
<p>Git 附带了<a href="https://git-scm.com/docs/git-bisect"><code>git bisect</code></a>为您实现二分法查找逻辑的命令。你所要做的就是给它一些起点，然后对于每次提交它跳转过去，告诉它是好还是坏。如果你做了足够多次，它会告诉你哪个提交有问题。</p>
</div>
<div class="paragraph">
<p>这一切都很好，但有两个问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_问题跳过">50.2. 问题❶：跳过</h3>
<div class="paragraph">
<p>让我们想象一下`2 + 2`用来返回的情况`4`（正确！），但现在返回`42`（…​…​也正确，但不完全对）。</p>
</div>
<div class="paragraph">
<p>所以你启动了 bisection 过程，git 在修改之间跳转，你测试它们。如果它是`4`那么`good`（或`old`），如果它是`42`那么它是`bad`（或`new`）。但后来你偶然发现了这种行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">&gt; 2 + 2

Merry Christmas!</code></pre>
</div>
</div>
<div class="paragraph">
<p>… 怎么办？显然，那个具体修改有点特殊。我们无法判断我们的错误是否存在，我们根本无法知道。是的，它不会打印`4`，但我们正在寻找一个非常具体的错误，因此它也不会被归类为“新”行为。当然，我们可以抛硬币并随机标记为`old`或者`new`，并希望圣诞节奇迹…​…​但是有50％的概率（如果我们只看到其中一个）将二分法查找转移到错误的方向。</p>
</div>
<div class="paragraph">
<p>对于这些情况，git 提供了一个特殊<a href="https://git-scm.com/docs/git-bisect#_bisect_skip">`skip`命令</a>。</p>
</div>
<div class="paragraph">
<p>如果你是手动测试，那么处理这些修改就有点简单（只要你记得你应该跳过(<code>skip</code>)他们）。但是，由于问题❷，很多人都倾向于使用`git bisect run`脚本自动化过程。也可以使用脚本跳过修改（使用退出代码`125`），但是如何确定应该跳过哪些修改并不是那么明显。</p>
</div>
</div>
<div class="sect2">
<h3 id="_问题构建时间">50.3. 问题❷：构建时间</h3>
<div class="paragraph">
<p>让我们用乐观的数字13来估计我们要测试的修改量。请记住，它不包括我们必须跳过的提交，以及可能需要测试的其他额外构建。</p>
</div>
<div class="paragraph">
<p>构建rakudo所需的时间因硬件而异，但我们乐观地说，在特定的提交中构建rakudo需要2分钟时间并对其进行测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">13 × 2 = 26 (minutes)</code></pre>
</div>
</div>
<div class="paragraph">
<p>那不是很方便，对吧？如果在此过程中出现问题…​…​你重新开始，<a href="https://www.youtube.com/watch?v=mPzjbXgaVOk&amp;feature=youtu.be&amp;t=16">然后等待</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_bisectable">50.4. Bisectable</h3>
<div class="paragraph">
<p>在2016年，在看到那些必须手动运行 <code>git bisect</code> 的人（实际上，大部分是<a href="https://colabti.org/irclogger/irclogger_log/raku?date=2016-05-17#l1353">我自己</a>）的痛苦之后，<a href="https://colabti.org/irclogger/irclogger_log/raku?date=2016-05-17#l1335">我想知道</a>：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>有没有人想过为每一次提交构建rakudo，以便你可以快速运行git bisect？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>该想法的成本效益分析受到了迅速质疑：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>AlexDaniel：你认为未来二分法将会很普遍吗？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>我提供了非常详细的理由：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>perlpilot：是的</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>三天后，机器人加入了频道。<a href="https://colabti.org/irclogger/irclogger_log/raku?date=2016-05-20#l345">这些反应</a>非常有趣：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>哇
哦
OooOOOoooh
Cooooool</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>当时我们很少知道结果会怎样。即使我不知道它会变得多么有用。<a href="https://colabti.org/irclogger/irclogger_log/raku?date=2018-11-13#l678">快进2年</a>：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>关于提交的大小：我尽量保持它们尽可能小，并且尽可能地包含它们，以便
在这种意义上更容易二分，bisectable6 也改变了我编码的方式
还有：bisectable6 让我更少担心我提交的更改
因为它通常限制很多地点寻找以修复问题，他们可以在几分钟而不是几小时内修复
或至少很快显示原因（所以短时间修复可能意味着 revert）
\ o /</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>但它并不总是完美的。引入机器人大约一小时后，它被用于其目的：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>bisect：<code>try { NaN.Rat == NaN; exit 0 }; exit 1</code>
moritz：（2016-05-02）<a href="https://github.com/rakudo/rakudo/commit/949a7c7" class="bare">https://github.com/rakudo/rakudo/commit/949a7c7</a></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>但是，由于一个<a href="https://github.com/raku/whateverable/commit/68ba961854b17298225dd9b886b2af874e567556">off-by-one</a>，它返回了错误的提交。实际提交是<a href="https://github.com/rakudo/rakudo/commit/e2f1fa7">e2f1fa7</a>，而<a href="https://github.com/rakudo/rakudo/commit/949a7c7">949a7c7</a>是其父级。</p>
</div>
<div class="paragraph">
<p>老实说，那时机器人非常糟糕。例如，它完全依赖于退出代码，所以你不能只是把 `2 + 2`抛给它并期望它检查输出。最终，实施了不同的模式，现在机器人首先检查起点上的行为（例如2015.12和HEAD），并确定执行二分法的最佳策略。例如，如果信号不同（例如SEGV），则它基于信号一分为二。如果信号相同，但退出代码不同，则使用退出代码。如果无法使用其他所有内容，则使用输出进行一分为二。</p>
</div>
<div class="paragraph">
<p>请记住，如果`raku`无法构建二进制文件，则可以检查二分法。这意味着在大多数情况下，您不需要添加自己的逻辑来跳过。它不仅将二分法时间从几十分钟缩短到几秒钟，而且还提供更可靠/正确的结果。</p>
</div>
</div>
<div class="sect2">
<h3 id="_存储">50.5. 存储</h3>
<div class="paragraph">
<p>一段时间之后，提交范围扩展到`2014.01`…​…​ <code>HEAD</code>，意味着所有提交都是从第一个有关Moar的Rakudo发布开始的。目前它有超过17000个构建。它可能听起来很多，但每个rakudo安装只需≈28MB，这不是*太多*。拥有几TB存储空间可以让您在未来几年内继续使用。</p>
</div>
<div class="paragraph">
<p>话虽如此，我的服务器上没有那么奢侈。它有一个120 GB SSD的RAID，因此整个事情不仅要适应这么小的空间，而且还应该为系统的其余部分留出足够的空间。</p>
</div>
<div class="paragraph">
<p>有很多实验（<a href="https://github.com/raku/whateverable/issues/23">一</a>，<a href="https://github.com/raku/whateverable/issues/117">二</a>）涉及找出节省空间的最佳策略，但*长话短说*，我们可以低至每个版本大约半兆字节！当然，它总是在压缩比和解压缩速度之间进行权衡，但使用现代压缩算法（<a href="https://github.com/facebook/zstd">zstd</a>，<a href="https://github.com/ckolivas/lrzip">lrzip</a>）一切都相对容易。</p>
</div>
</div>
<div class="sect2">
<h3 id="_更多机器人更好">50.6. 更多机器人，更好</h3>
<div class="paragraph">
<p>在Bisectable发布后不久，人们看到了其他工具的机会。想要在特定提交上运行一些代码吗？当然，这有<a href="https://github.com/raku/whateverable/wiki/Committable">一个机器人</a>。想下载预构建的rakudo存档而不是浪费你自己的cpu时间吗？是的，<a href="https://github.com/raku/whateverable/wiki/Shareable">还有另一个机器人</a>。想要绘制一些关于rakudo的信息吗？<a href="https://github.com/raku/whateverable/wiki/Statisfiable">当然有一个机器人！</a></p>
</div>
<div class="paragraph">
<p>机器人一直持续增加直到我们有了共计<a href="https://github.com/raku/whateverable/wiki"><strong>17个机器人！</strong></a>有些人认为这些机器人应该停止这样的倍增，也许人们是正确的。但我想重点是，现在很容易在Whateverable上为开发人员创建更多工具，这当然很棒。</p>
</div>
</div>
<div class="sect2">
<h3 id="_好的现在怎么样">50.7. 好的，现在怎么样？</h3>
<div class="paragraph">
<p>因此，bisectable可以在很短的时间内将数千个提交一分为二。它占用的存储空间非常小，并且用户不需要完全理解二分过程。既然二分是免费且容易的，我们可以做更多吗？</p>
</div>
</div>
<div class="sect2">
<h3 id="_是的blin">50.8. 是的，Blin！</h3>
<div class="paragraph">
<p>你可能听说过<a href="https://raku.party/post/Perl-6-Release-Quality-Assurance-Full-Ecosystem-Toaster">Toaster</a>。Toaster是一种尝试在两个或多个修订版中安装生态系统中的每个模块的工具。例如，假设最后一个版本是2018.12，发布经理即将从主HEAD中删除rakudo版本。然后，您可以在 <code>2018.12`和`master</code> 上运行 toaster，它会显示哪些模块用于干净安装，但不再做。</p>
</div>
<div class="paragraph">
<p>这给了我们Rakudo可能出错的信息，但并没有告诉我究竟是什么。鉴于此帖主要是关于Bisectable，你可能会猜到这是怎么回事。</p>
</div>
</div>
<div class="sect2">
<h3 id="_blin_项目_重新发明了_toasting">50.9. Blin 项目- 重新发明了 Toasting</h3>
<div class="paragraph">
<p>Blin是Rakudo版本的质量保证工具。它用于在rakudo中查找回归，但与Toaster不同，它不仅告诉哪些模块不再可安装，还将rakudo一分为二，以找出导致问题的提交。当然，它是围绕Whateverable构建的，因此额外的功能不会花费太多（甚至不需要很多代码）。作为奖励，它生成了<a href="https://gist.github.com/AlexDaniel/d7b789eefb34db31ee14f16dadd9a3ad">很好的图形</a>来可视化问题如何从模块依赖性传播（虽然这不是很常见）。</p>
</div>
<div class="paragraph">
<p>Blin的一个重要特性是它只尝试安装每个模块一次。因此，如果模块B依赖于模块A，A将被测试并安装一次，然后重新用于B的测试。因为这个过程是并行化的，您可能想知道它是如何实现的。<a href="https://github.com/raku/Blin/blob/b535dc0d727a61047199dd6ee67d07d626941965/bin/blin.p6#L285">基本上</a>，它使用被低估的`react/whenever`功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># slightly simplified
react {
    for @modules -&gt; $module {
        whenever Promise.allof($module.depends.keys».done) {
            start { process-module $module, … }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于每个模块（我们现在有超过1200个），它会创建自己的`whenever`块，在满足其依赖关系时触发。在我看来，这是Blin中主要逻辑的全部实现，其他一切只是粘合剂以获得Whateverable和Zef协同工作以实现我们所需要的，+一些输出生成。</p>
</div>
<div class="paragraph">
<p>在某种程度上，Blin对我们为Rakudo做质量保证的方式没有太大的改变。Toaster已经能够给我们一些基本的信息（尽管速度较慢），以便我们可以开始调查，而在过去，我知道将奇怪的东西（例如带有依赖关系的完整模块）推入二分法。只是现在它变得更容易了，当<a href="https://en.wikipedia.org/wiki/AI_takeover"><strong>The Day</strong></a>到来时，我不会因机器人滥用而受到惩罚。</p>
</div>
</div>
<div class="sect2">
<h3 id="_未来">50.10. 未来</h3>
<div class="paragraph">
<p><a href="https://github.com/raku/whateverable/issues">Whateverable</a>和<a href="https://github.com/raku/Blin/issues">Blin</a>一起有243个未解决的问题。这两个项目都非常有用，而且非常有用，但正如我们所说，它们不是很棒。大多数问题相对容易和有趣，但它们需要时间。如果您有任何帮助，或者您想维护这些项目，请随时这样做。如果你想基于Whateverable构建自己的工具（我们可能需要很多！），请参阅这个<a href="https://gist.github.com/AlexDaniel/88b38af5db9adcf0b711ac3df31dd431">hello world gist</a>。</p>
</div>
<div class="paragraph">
<p>🎅🎄， 🥞</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十四天_使用_raku_进行主题建模">51. 第二十四天 - 使用 Raku 进行主题建模</h2>
<div class="sectionbody">
<div class="paragraph">
<p>嗨，大家好。</p>
</div>
<div class="paragraph">
<p>今天，让我介绍<a href="https://github.com/titsuki/p6-Algorithm-LDA">Algorithm::LDA</a>。
该模块是用于主题建模的Latent Dirichlet Allocation（即LDA）实现。</p>
</div>
<div class="sect2">
<h3 id="_介绍_4">51.1. 介绍</h3>
<div class="paragraph">
<p>什么是LDA？LDA是一种流行的无监督机器学习方法。
它模拟文档生成过程，并将每个文档表示为主题的混合。</p>
</div>
<div class="paragraph">
<p>那么，“混合主题”是什么意思呢？图1显示了一篇文章，其中一些单词以三种颜色突出显示：黄色，粉红色和蓝色。关于遗传学的词语用黄色标出; 关于进化生物学的文字用粉红色标出; 有关数据分析的文字标有蓝色。想象一下，本文中的所有单词都是彩色的，然后我们可以将这篇文章表示为主题（即颜色）的混合。</p>
</div>
<div class="paragraph">
<p>图1 :( 此图片来自“概率主题模型”。（David Blei 2012））
<a href="https://camo.githubusercontent.com/464a19ca7cf15ea83e712cd8145afacc46c55cae/68747470733a2f2f7065726c36616476656e742e66696c65732e776f726470726573732e636f6d2f323031382f31322f73637265656e73686f742d66726f6d2d323031382d31322d31302d30302d31342d33312e706e673f773d363830">![图。1</a>](<a href="https://camo.githubusercontent.com/464a19ca7cf15ea83e712cd8145afacc46c55cae/68747470733a2f2f7065726c36616476656e742e66696c65732e776f726470726573732e636f6d2f323031382f31322f73637265656e73686f742d66726f6d2d323031382d31322d31302d30302d31342d33312e706e673f773d363830" class="bare">https://camo.githubusercontent.com/464a19ca7cf15ea83e712cd8145afacc46c55cae/68747470733a2f2f7065726c36616476656e742e66696c65732e776f726470726573732e636f6d2f323031382f31322f73637265656e73686f742d66726f6d2d323031382d31322d31302d30302d31342d33312e706e673f773d363830</a>)</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">好的，那么我将在下一节中演示如何使用Algorithm </dt>
<dd>
<p>LDA。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_建模报价">51.2. 建模报价</h3>
<div class="paragraph">
<p>在本文中，我们将探索<a href="https://www.wikiquote.org/">Wikiquote</a>。Wikiquote是一个提供源代码报价的云源平台。
通过使用Wikiquote API，我们获得用于LDA估计的报价。之后，我们执行LDA并绘制结果。
最后，我们使用生成的模型创建信息检索应用程序。</p>
</div>
<div class="sect3">
<h4 id="_初步">51.2.1. 初步</h4>
<div class="sect4">
<h5 id="_wikiquote_api">Wikiquote API</h5>
<div class="paragraph">
<p>Wikiquote具有<a href="https://en.wikiquote.org/w/api.php?action=help&amp;modules=query">动作API</a>，提供获取Wikiquote资源的方法。
例如，您可以按如下方式获取主页面的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ curl &#34;https://en.wikiquote.org/w/api.php?action=query&amp;prop=revisions&amp;titles=Main%20Page&amp;rvprop=content&amp;format=json&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述命令的结果是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">{&#34;batchcomplete&#34;:&#34;&#34;,&#34;warnings&#34;:{&#34;main&#34;:{&#34;*&#34;:&#34;Subscribe to the mediawiki-api-announce mailing list at &lt;https://lists.wikimedia.org/mailman/listinfo/mediawiki-api-announce&gt; for notice of API deprecations and breaking changes. Use [[Special:ApiFeatureUsage]] to see usage of deprecated features by your application.&#34;},&#34;revisions&#34;:{&#34;*&#34;:&#34;Because \&#34;rvslots\&#34; was not specified, a legacy format has been used for the output. This format is deprecated, and in the future the new format will always be used.&#34;}},&#34;query&#34;:{&#34;pages&#34;:{&#34;1&#34;:{&#34;pageid&#34;:1,&#34;ns&#34;:0,&#34;title&#34;:&#34;Main Page&#34;,&#34;revisions&#34;:[{&#34;contentformat&#34;:&#34;text/x-wiki&#34;,&#34;contentmodel&#34;:&#34;wikitext&#34;,&#34;*&#34;:&#34;\n
{{Main page header}}
\n
{{Main Page Quote of the day}}
\n&lt;/div&gt;\n\n \n{{Main Page Selected pages}}\n{{Main categories}}\n\n\n \n{{New pages}}\n{{Main Page Community}}\n\n\n\n==Wikiquote&#39;s sister projects==\n{{otherwiki}}\n\n==Wikiquote languages==\n{{Wikiquotelang}}\n\n__NOTOC__ __NOEDITSECTION__\n{{noexternallanglinks:ang|simple}}\n[[Category:Main page]]&#34;}]}}}}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_www">WWW</h5>
<div class="paragraph">
<p><a href="https://github.com/zoffixznet/raku-WWW">WWW</a>通过Zoffix Znet是它提供了易于使用的API，包括获取和解析JSON非常简单的库。
例如，正如README所说，您可以轻松地按`jget(URL)&lt;HASHKEY&gt;`样式获取内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say jget(&#39;https://httpbin.org/get?foo=42&amp;bar=x&#39;)&lt;args&gt;&lt;foo&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要安装WWW：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">zef install WWW</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_chartgnuplot">Chart::Gnuplot</h5>
<div class="paragraph">
<p><a href="https://github.com/titsuki/p6-Chart-Gnuplot">Chart::Gnuplot</a> by titsuki是<a href="http://www.gnuplot.info/">gnuplot</a>的绑定。</p>
</div>
<div class="paragraph">
<p>要安装 Chart::Gnuplot：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ zef install Chart::Gnuplot</code></pre>
</div>
</div>
<div class="paragraph">
<p>在本文中，我们使用此模块; 但是，如果你不熟悉gnuplot，有很多选择：<a href="https://github.com/moritz/svg-plot">SVG::Plot</a>，<a href="https://github.com/azawawi/raku-graphics-plplot">Graphics::PLplot</a>，<a href="https://0racle.info/articles/matplotlib_in_p6_intro">通过Inline::Python调用matplotlib函数</a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_来自nltk的stopwords">来自NLTK的Stopwords</h5>
<div class="paragraph">
<p>NLTK是一个用于自然语言处理的工具包。
不仅是 API，它还提供语料库。
您可以通过“70”获得英语的停用词。关键词语料库“：<a href="http://www.nltk.org/nltk_data/">http</a>：//www.nltk.org/nltk_data/</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_练习1获取报价并创建已清理的文档">51.2.2. 练习1：获取报价并创建已清理的文档</h4>
<div class="paragraph">
<p>一开始，我们必须从Wikiquote获取引用并创建干净的文档。</p>
</div>
<div class="paragraph">
<p>本部分的主要目标是根据以下格式创建文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">&lt;docid&gt; &lt;personid&gt; &lt;word&gt; &lt;word&gt; &lt;word&gt; ...
&lt;docid&gt; &lt;personid&gt; &lt;word&gt; &lt;word&gt; &lt;word&gt; ...
&lt;docid&gt; &lt;personid&gt; &lt;word&gt; &lt;word&gt; &lt;word&gt; ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>整个源代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.c;
use WWW;
use URI::Escape;

sub get-members-from-category(Str $category --&gt; List) {
    my $member-url = &#34;https://en.wikiquote.org/w/api.php?action=query&amp;list=categorymembers&amp;cmtitle={$category}&amp;cmlimit=100&amp;format=json&#34;;
    @(jget($member-url)&lt;query&gt;&lt;categorymembers&gt;.map(*&lt;title&gt;));
}

sub get-pages(Str @members, Int $batch = 50 --&gt; List) {
    my Int $start = 0;
    my @pages;
    while $start &lt; @members {
        my $list = @members[$start..^List($start + $batch, +@members).min].map({ uri_escape($_) }).join(&#39;%7C&#39;);
        my $url = &#34;https://en.wikiquote.org/w/api.php?action=query&amp;prop=revisions&amp;rvprop=content&amp;format=json&amp;formatversion=2&amp;titles={$list}&#34;;
        @pages.push($_) for jget($url)&lt;query&gt;&lt;pages&gt;.map({ %(body =&gt; .&lt;revisions&gt;[0]&lt;content&gt;, title =&gt; .&lt;title&gt;) });
        $start += $batch;
    }
    @pages;
}

sub create-documents-from-pages(@pages, @members --&gt; List) {
    my @documents;
    for @pages -&gt; $page {
        my @quotations = $page&lt;body&gt;.split(&#34;\n&#34;)\
        .map(*.subst(/\[\[$&lt;text&gt;=(&lt;-[\[\]|]&gt;+?)\|$&lt;link&gt;=(&lt;-[\[\]|]&gt;+?)\]\]/, { $&lt;text&gt; }, :g))\
        .map(*.subst(/\[\[$&lt;text&gt;=(&lt;-[\[\]|]&gt;+?)\]\]/, { $&lt;text&gt; }, :g))\
        .map(*.subst(&#34;[&#34;, &#34;[&#34;, :g))\
        .map(*.subst(&#34;]&#34;, &#34;]&#34;, :g))\
        .map(*.subst(&#34;&amp;amp;&#34;, &#34;&amp;&#34;, :g))\
        .map(*.subst(&#34;&amp;nbsp;&#34;, &#34;&#34;, :g))\
        .map(*.subst(/:i [ \&lt;\/?\s?br\&gt; | \&lt;br\s?\/?\&gt; ]/, &#34; &#34;, :g))\
        .grep(/^\*&lt;-[*]&gt;/)\
        .map(*.subst(/^\*\s+/, &#34;&#34;));

        # Note: The order of array wikiquote API returned is agnostic.
        my Int $index = @members.pairs.grep({ .value eq $page&lt;title&gt; }).map(*.key).head;
        @documents.push(%(body =&gt; $_, personid =&gt; $index)) for @quotations;
    }
    @documents.sort({ $^a&lt;personid&gt; &lt;=&gt; $^b&lt;personid&gt; }).pairs.map({ %(docid =&gt; .key, personid =&gt; .value&lt;personid&gt;, body =&gt; .value&lt;body&gt;) }).list
}

my Str @members = get-members-from-category(&#34;Category:1954_births&#34;);
my @pages = get-pages(@members);
my @documents = create-documents-from-pages(@pages, @members);

my $docfh = open &#34;documents.txt&#34;, :w;
$docfh.say((.&lt;docid&gt;, .&lt;personid&gt;, .&lt;body&gt;).join(&#34; &#34;)) for @documents;
$docfh.close;

my $memfh = open &#34;members.txt&#34;, :w;
$memfh.say($_) for @members;
$memfh.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，我们获得“Category：1954births”页面中列出的成员。我选择了Raku设计师诞生的那一年：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Str @members = get-members-from-category(&#34;Category:1954_births&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中，`get-members-from-category`通过维基语录API获取成员：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub get-members-from-category(Str $category --&gt; List) {
    my $member-url = &#34;https://en.wikiquote.org/w/api.php?action=query&amp;list=categorymembers&amp;cmtitle={$category}&amp;cmlimit=100&amp;format=json&#34;;
    @(jget($member-url)&lt;query&gt;&lt;categorymembers&gt;.map(*&lt;title&gt;));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，调用`get-pages`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @pages = get-pages(@members);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>get-pages</code> 获取给定标题（即成员）页面的子例程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub get-pages(Str @members, Int $batch = 50 --&gt; List) {
    my Int $start = 0;
    my @pages;
    while $start &lt; @members {
        my $list = @members[$start..^List($start + $batch, +@members).min].map({ uri_escape($_) }).join(&#39;%7C&#39;);
        my $url = &#34;https://en.wikiquote.org/w/api.php?action=query&amp;prop=revisions&amp;rvprop=content&amp;format=json&amp;formatversion=2&amp;titles={$list}&#34;;
        @pages.push($_) for jget($url)&lt;query&gt;&lt;pages&gt;.map({ %(body =&gt; .&lt;revisions&gt;[0]&lt;content&gt;, title =&gt; .&lt;title&gt;) });
        $start += $batch;
    }
    @pages;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中`@members[$start..^List($start + $batch, +@members).min]<code>是一段长度</code>$batch`，并且切片的元素由百分比编码`uri_escase`和联合`%7C`（即，编码的管道符号百分比）。
在这种情况下，结果之一`$list`是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Mumia%20Abu-Jamal%7CRene%20Balcer%7CIain%20Banks%7CGerard%20Batten%7CChristie%20Brinkley%7CJames%20Cameron%20%28director%29%7CEugene%20Chadbourne%7CJackie%20Chan%7CChang%20Yu-hern%7CLee%20Child%7CHugo%20Ch%C3%A1vez%7CDon%20Coscarelli%7CElvis%20Costello%7CDaayiee%20Abdullah%7CThomas%20H.%20Davenport%7CGerardine%20DeSanctis%7CAl%20Di%20Meola%7CKevin%20Dockery%20%28author%29%7CJohn%20Doe%20%28musician%29%7CF.%20J.%20Duarte%7CIain%20Duncan%20Smith%7CHerm%20Edwards%7CAbdel%20Fattah%20el-Sisi%7CRob%20Enderle%7CRecep%20Tayyip%20Erdo%C4%9Fan%7CAlejandro%20Pe%C3%B1a%20Esclusa%7CHarvey%20Fierstein%7CCarly%20Fiorina%7CGary%20L.%20Francione%7CAshrita%20Furman%7CMary%20Gaitskill%7CGeorge%20Galloway%7C%C5%BDeljko%20Glasnovi%C4%87%7CGary%20Hamel%7CFran%C3%A7ois%20Hollande%7CKazuo%20Ishiguro%7CJean-Claude%20Juncker%7CAnish%20Kapoor%7CGuy%20Kawasaki%7CRobert%20Francis%20Kennedy%2C%20Jr.%7CLawrence%20M.%20Krauss%7CAnatoly%20Kudryavitsky%7CAnne%20Lamott%7CJoep%20Lange%7CAng%20Lee%7CLi%20Bin%7CRay%20Liotta%7CPeter%20Lipton%7CJames%20D.%20Macdonald%7CKen%20MacLeod</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>get-pages`子例程使用哈希上下文相关器</code>%()`来创建哈希序列：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@pages.push($_) for jget($url)&lt;query&gt;&lt;pages&gt;.map({ %(body =&gt; .&lt;revisions&gt;[0]&lt;content&gt;, title =&gt; .&lt;title&gt;) });</code></pre>
</div>
</div>
<div class="paragraph">
<p>在那之后，我们调用 <code>create-documents-from-pages</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @documents = create-documents-from-pages(@pages, @members);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>create-documents-from-pages</code> 从每个页面创建文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub create-documents-from-pages(@pages, @members --&gt; List) {
    my @documents;
    for @pages -&gt; $page {
        my @quotations = $page&lt;body&gt;.split(&#34;\n&#34;)\
        .map(*.subst(/\[\[$&lt;text&gt;=(&lt;-[\[\]|]&gt;+?)\|$&lt;link&gt;=(&lt;-[\[\]|]&gt;+?)\]\]/, { $&lt;text&gt; }, :g))\
        .map(*.subst(/\[\[$&lt;text&gt;=(&lt;-[\[\]|]&gt;+?)\]\]/, { $&lt;text&gt; }, :g))\
        .map(*.subst(&#34;[&#34;, &#34;[&#34;, :g))\
        .map(*.subst(&#34;]&#34;, &#34;]&#34;, :g))\
        .map(*.subst(&#34;&amp;amp;&#34;, &#34;&amp;&#34;, :g))\
        .map(*.subst(&#34;&amp;nbsp;&#34;, &#34;&#34;, :g))\
        .map(*.subst(/:i [ \&lt;\/?\s?br\&gt; | \&lt;br\s?\/?\&gt; ]/, &#34; &#34;, :g))\
        .grep(/^\*&lt;-[*]&gt;/)\
        .map(*.subst(/^\*\s+/, &#34;&#34;));

        # Note: The order of array wikiquote API returned is agnostic.
        my Int $index = @members.pairs.grep({ .value eq $page&lt;title&gt; }).map(*.key).head;
        @documents.push(%(body =&gt; $_, personid =&gt; $index)) for @quotations;
    }
    @documents.sort({ $^a&lt;personid&gt; &lt;=&gt; $^b&lt;personid&gt; }).pairs.map({ %(docid =&gt; .key, personid =&gt; .value&lt;personid&gt;, body =&gt; .value&lt;body&gt;) }).list
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中`.map(<strong>.subst(/\<a href="https://docs.raku.org/language/regexes#Named_captures">\[$&lt;text&gt;=(←[\[]|</a>&gt;?)\|$&lt;link&gt;=(&lt;-[\[\]|]&gt;?)\]\]/, { $&lt;text&gt; }, :g))<code>和</code>.map(</strong>.subst(/\[\[$&lt;text&gt;=(←[\[\]|]&gt;+?)\]\]/, { $&lt;text&gt; }, :g))<code>是隐藏命令，提取文本以显示和删除文本，以便从锚文本进行内部链接。例如，</code><a id="Perl"></a><code>被缩减为`Perl</code>。有关更多语法信息，请参阅：[https]：<a href="https://docs.raku.org/language/regexes#Named_captures">//docs.raku.org/language/regexes#Named_captures</a>或<a href="https://docs.raku.org/routine/subst" class="bare">https://docs.raku.org/routine/subst</a></p>
</div>
<div class="paragraph">
<p>经过一些清理操作（.eg，<code>.map(*.subst(&#34;[&#34;, &#34;[&#34;, :g))</code>）后，我们提取引号线。</p>
</div>
<div class="paragraph">
<p>`.grep(/^*←[*]&gt;/)`查找以单星号开头的行，因为大多数引号都出现在这种行中。</p>
</div>
<div class="paragraph">
<p>接下来，`.map(<strong>.subst(/^\</strong>\s+/, &#34;&#34;))`删除每个星号，因为星号本身不是每个报价的组成部分。</p>
</div>
<div class="paragraph">
<p>最后，我们保存文档和成员（即标题）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $docfh = open &#34;documents.txt&#34;, :w;
$docfh.say((.&lt;docid&gt;, .&lt;personid&gt;, .&lt;body&gt;).join(&#34; &#34;)) for @documents;
$docfh.close;

my $memfh = open &#34;members.txt&#34;, :w;
$memfh.say($_) for @members;
$memfh.close;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_练习2执行lda并可视化结果">51.2.3. 练习2：执行LDA并可视化结果</h4>
<div class="paragraph">
<p>在上一节中，我们保存了已清理的文档。
在本节中，我们使用文档进行LDA估计并将结果可视化。
本部分的目标是绘制文档主题分布并编写主题词表。</p>
</div>
<div class="paragraph">
<p>整个源代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.c;
use Algorithm::LDA;
use Algorithm::LDA::Formatter;
use Algorithm::LDA::LDAModel;
use Chart::Gnuplot;
use Chart::Gnuplot::Subset;

sub create-model(@documents --&gt; Algorithm::LDA::LDAModel) {
    my $stopwords = &#34;stopwords/english&#34;.IO.lines.Set;
    my &amp;tokenizer = -&gt; $line { $line.words.map(*.lc).grep(-&gt; $w { ($stopwords !(cont) $w) and $w !~~ /^[ &lt;:S&gt; | &lt;:P&gt; ]+$/ }) };
    my ($documents, $vocabs) = Algorithm::LDA::Formatter.from-plain(@documents.map({ my ($, $, *@body) = .words; @body.join(&#34; &#34;) }), &amp;tokenizer);
    my Algorithm::LDA $lda .= new(:$documents, :$vocabs);
    my Algorithm::LDA::LDAModel $model = $lda.fit(:num-topics(10), :num-iterations(500), :seed(2018));
    $model
}

sub plot-topic-distribution($model, @members, @documents, $search-regex = rx/Larry/) {
    my $target-personid = @members.pairs.grep({ .value ~~ $search-regex }).map(*.key).head;
    my $docid = @documents.map({ my ($docid, $personid, *@body) = .words; %(docid =&gt; $docid, personid =&gt; $personid, body =&gt; @body.join(&#34; &#34;)) })\
    .grep({ .&lt;personid&gt; == $target-personid and .&lt;body&gt; ~~ /:i &lt;&lt; perl &gt;&gt;/}).map(*&lt;docid&gt;).head;

    note(&#34;@documents[$docid] is selected&#34;);
    my ($row-size, $col-size) = $model.document-topic-matrix.shape;
    my @doc-topic = gather for ($docid X ^$col-size) -&gt; ($i, $j) { take $model.document-topic-matrix[$i;$j]; }
    my Chart::Gnuplot $gnu .= new(:terminal(&#34;png&#34;), :filename(&#34;topics.png&#34;));
    $gnu.command(&#34;set boxwidth 0.5 relative&#34;);
    my AnyTicsTic @tics = @doc-topic.pairs.map({ %(:label(.key), :pos(.key)) });
    $gnu.legend(:off);
    $gnu.xlabel(:label(&#34;Topic&#34;));
    $gnu.ylabel(:label(&#34;P(z|theta,d)&#34;));
    $gnu.xtics(:tics(@tics));
    $gnu.plot(:vertices(@doc-topic.pairs.map({ @(.key, .value.exp) })), :style(&#34;boxes&#34;), :fill(&#34;solid&#34;));
    $gnu.dispose;
}

sub write-nbest($model) {
  my $topics := $model.nbest-words-per-topic(10);
  for ^(10/5) -&gt; $part-i {
    say &#34;|&#34; ~ (^5).map(-&gt; $t { &#34;topic { $part-i * 5 + $t }&#34; }).join(&#34;|&#34;) ~ &#34;|&#34;;
    say &#34;|&#34; ~ (^5).map({ &#34;----&#34; }).join(&#34;|&#34;) ~ &#34;|&#34;;
    for ^10 -&gt; $rank {
        say &#34;|&#34; ~ gather for ($part-i * 5)..^($part-i * 5 + 5) -&gt; $topic {
            take @($topics)[$topic;$rank].key;
        }.join(&#34;|&#34;) ~ &#34;|&#34;;
    }
    &#34;&#34;.say;
  }
}

sub save-model($model) {
  my @document-topic-matrix := $model.document-topic-matrix;
  my ($document-size, $topic-size) = @document-topic-matrix.shape;
  my $doctopicfh = open &#34;document-topic.txt&#34;, :w;

  $doctopicfh.say: ($document-size, $topic-size).join(&#34; &#34;);
  for ^$document-size -&gt; $doc-i {
    $doctopicfh.say: gather for ^$topic-size -&gt; $topic { take @document-topic-matrix[$doc-i;$topic] }.join(&#34; &#34;);
  }
  $doctopicfh.close;

  my @topic-word-matrix := $model.topic-word-matrix;
  my ($, $word-size) = @topic-word-matrix.shape;
  my $topicwordfh = open &#34;topic-word.txt&#34;, :w;

  $topicwordfh.say: ($topic-size, $word-size).join(&#34; &#34;);
  for ^$topic-size -&gt; $topic-i {
    $topicwordfh.say: gather for ^$word-size -&gt; $word { take @topic-word-matrix[$topic-i;$word] }.join(&#34; &#34;);
  }
  $topicwordfh.close;

  my @vocabulary := $model.vocabulary;
  my $vocabfh = open &#34;vocabulary.txt&#34;, :w;

  $vocabfh.say($_) for @vocabulary;
  $vocabfh.close;
}

my @documents = &#34;documents.txt&#34;.IO.lines;
my $model = create-model(@documents);
my @members = &#34;members.txt&#34;.IO.lines;
plot-topic-distribution($model, @members, @documents);
write-nbest($model);
save-model($model);</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，我们加载已清理的文档并调用`create-model`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @documents = &#34;documents.txt&#34;.IO.lines;
my $model = create-model(@documents);</code></pre>
</div>
</div>
<div class="paragraph">
<p>`create-model`通过加载给定文档来创建LDA模型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub create-model(@documents --&gt; Algorithm::LDA::LDAModel) {
    my $stopwords = &#34;stopwords/english&#34;.IO.lines.Set;
    my &amp;tokenizer = -&gt; $line { $line.words.map(*.lc).grep(-&gt; $w { ($stopwords !(cont) $w) and $w !~~ /^[ &lt;:S&gt; | &lt;:P&gt; ]+$/ }) };
    my ($documents, $vocabs) = Algorithm::LDA::Formatter.from-plain(@documents.map({ my ($, $, *@body) = .words; @body.join(&#34; &#34;) }), &amp;tokenizer);
    my Algorithm::LDA $lda .= new(:$documents, :$vocabs);
    my Algorithm::LDA::LDAModel $model = $lda.fit(:num-topics(10), :num-iterations(500), :seed(2018));
    $model
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$stopwords`来自NLTK的一组英语停用词在哪里（我提到了初步部分），并且</code>&amp;tokenizer`是一个自定义标记器`Algorithm::LDA::Formatter.from-plain`。标记器转换给定句子如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1. 通过空格拆分句子并生成令牌列表。</p>
</li>
<li>
<p>1. 用小写字符替换标记的每个字符。</p>
</li>
<li>
<p>1. 删除停用词列表中存在的令牌或分类为符号或标点符号的单长令牌。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Algorithm::LDA::Formatter.from-plain</code> 创建数字原生文档（即，文档中的每个单词被映射到其对应的词汇表id，并且该id由C int32表示）和来自文本列表的词汇表。</p>
</div>
<div class="paragraph">
<p>在`Algorithm::LDA`使用上述数值文档创建实例后，我们可以通过启动LDA估计`Algorithm::LDA.fit`。在此示例中，我们将主题数设置为10，将迭代次数设置为100，将srand的种子设置为2018。</p>
</div>
<div class="paragraph">
<p>接下来，我们绘制文档主题分布。在此绘图之前，我们加载已保存的成员</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @members = &#34;members.txt&#34;.IO.lines;
plot-topic-distribution($model, @members, @documents);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>plot-topic-distribution</code> 使用Chart </dt>
<dd>
<p>Gnuplot绘制主题分布：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub plot-topic-distribution($model, @members, @documents, $search-regex = rx/Larry/) {
    my $target-personid = @members.pairs.grep({ .value ~~ $search-regex }).map(*.key).head;
    my $docid = @documents.map({ my ($docid, $personid, *@body) = .words; %(docid =&gt; $docid, personid =&gt; $personid, body =&gt; @body.join(&#34; &#34;)) })\
    .grep({ .&lt;personid&gt; == $target-personid and .&lt;body&gt; ~~ /:i &lt;&lt; perl &gt;&gt;/}).map(*&lt;docid&gt;).head;

    note(&#34;@documents[$docid] is selected&#34;);
    my ($row-size, $col-size) = $model.document-topic-matrix.shape;
    my @doc-topic = gather for ($docid X ^$col-size) -&gt; ($i, $j) { take $model.document-topic-matrix[$i;$j]; }
    my Chart::Gnuplot $gnu .= new(:terminal(&#34;png&#34;), :filename(&#34;topics.png&#34;));
    $gnu.command(&#34;set boxwidth 0.5 relative&#34;);
    my AnyTicsTic @tics = @doc-topic.pairs.map({ %(:label(.key), :pos(.key)) });
    $gnu.legend(:off);
    $gnu.xlabel(:label(&#34;Topic&#34;));
    $gnu.ylabel(:label(&#34;P(z|theta,d)&#34;));
    $gnu.xtics(:tics(@tics));
    $gnu.plot(:vertices(@doc-topic.pairs.map({ @(.key, .value.exp) })), :style(&#34;boxes&#34;), :fill(&#34;solid&#34;));
    $gnu.dispose;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，我们绘制了Larry Wall的引文的主题分布（“虽然Perl口号是不仅仅有一种方法可以做到这一点，但我还是犹豫了10种方法来做某事。”）：</p>
</div>
<div class="paragraph">
<p>!<a href="https://camo.githubusercontent.com/787f04318d3c341aa81deaa2c2793054d48403ee/68747470733a2f2f7065726c36616476656e742e66696c65732e776f726470726573732e636f6d2f323031382f31322f746f706963732d312e706e673f773d363430">img</a></p>
</div>
<div class="paragraph">
<p>在绘图之后，我们称之为`write-nbest`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">write-nbest($model);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在LDA中，XXX表示的主题表示为单词列表。`write-nbest`写一个降价风格的主题词分配表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub write-nbest($model) {
  my $topics := $model.nbest-words-per-topic(10);
  for ^(10/5) -&gt; $part-i {
    say &#34;|&#34; ~ (^5).map(-&gt; $t { &#34;topic { $part-i * 5 + $t }&#34; }).join(&#34;|&#34;) ~ &#34;|&#34;;
    say &#34;|&#34; ~ (^5).map({ &#34;----&#34; }).join(&#34;|&#34;) ~ &#34;|&#34;;
    for ^10 -&gt; $rank {
        say &#34;|&#34; ~ gather for ($part-i * 5)..^($part-i * 5 + 5) -&gt; $topic {
            take @($topics)[$topic;$rank].key;
        }.join(&#34;|&#34;) ~ &#34;|&#34;;
    }
    &#34;&#34;.say;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果是：</p>
</div>
<div class="paragraph">
<p>| topic 0  | topic 1   | topic 2  | topic 3  | topic 4   |
| -------- | --------- | -------- | -------- | --------- |
| would    | scotland  | black    | could    | one       |
| itâ€™s   | country   | mr.      | first    | work      |
| believe  | one       | lot      | law      | new       |
| one      | political | play     | college  | human     |
| took     | world     | official | basic    | process   |
| much     | need      | new      | speak    | business  |
| donâ€™t  | must      | reacher  | language | becomes   |
| ever     | national  | five     | every    | good      |
| far      | many      | car      | matter   | world     |
| fighting | us        | road     | right    | knowledge |</p>
</div>
<div class="paragraph">
<p>| topic 5 | topic 6   | topic 7 | topic 8   | topic 9 |
| ------- | --------- | ------- | --------- | ------- |
| apple   | united    | people  | like      | */      |
| likely  | war       | would   | one       | die     |
| company | states    | i’m     | something | und     |
| jobs    | years     | know    | think     | quantum |
| even    | would     | think   | way       | play    |
| steve   | american  | want    | things    | noble   |
| life    | president | get     | perl      | home    |
| like    | human     | going   | long      | dog     |
| end     | must      | say     | always    | student |
| small   | us        | go      | really    | ist     |</p>
</div>
<div class="paragraph">
<p>正如你所看到的那样，引用“虽然Perl Slogan不仅仅是一种方法，我还有10种方法可以做某事。”包含“one”，“way”和“perl”。这就是为什么这个引用主要由主题8组成的原因。</p>
</div>
<div class="paragraph">
<p>对于下一节，我们按`save-model`子程序保存模型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub save-model($model) {
  my @document-topic-matrix := $model.document-topic-matrix;
  my ($document-size, $topic-size) = @document-topic-matrix.shape;
  my $doctopicfh = open &#34;document-topic.txt&#34;, :w;

  $doctopicfh.say: ($document-size, $topic-size).join(&#34; &#34;);
  for ^$document-size -&gt; $doc-i {
    $doctopicfh.say: gather for ^$topic-size -&gt; $topic { take @document-topic-matrix[$doc-i;$topic] }.join(&#34; &#34;);
  }
  $doctopicfh.close;

  my @topic-word-matrix := $model.topic-word-matrix;
  my ($, $word-size) = @topic-word-matrix.shape;
  my $topicwordfh = open &#34;topic-word.txt&#34;, :w;

  $topicwordfh.say: ($topic-size, $word-size).join(&#34; &#34;);
  for ^$topic-size -&gt; $topic-i {
    $topicwordfh.say: gather for ^$word-size -&gt; $word { take @topic-word-matrix[$topic-i;$word] }.join(&#34; &#34;);
  }
  $topicwordfh.close;

  my @vocabulary := $model.vocabulary;
  my $vocabfh = open &#34;vocabulary.txt&#34;, :w;

  $vocabfh.say($_) for @vocabulary;
  $vocabfh.close;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_练习3创建报价搜索引擎">51.2.4. 练习3：创建报价搜索引擎</h4>
<div class="paragraph">
<p>在本节中，我们创建一个报价搜索引擎，它使用上一节中创建的模型。
更具体地说，我们创建了基于LDA的文档模型（Xing Wei和W. Bruce Croft 2006），并创建了一个可以搜索报价的CLI工具。（注意，“token”和“word”这两个词在本节中是可互换的）</p>
</div>
<div class="paragraph">
<p>整个源代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.c;

sub MAIN(Str :$query!) {
    my \doc-topic-iter = &#34;document-topic.txt&#34;.IO.lines.iterator;
    my \topic-word-iter = &#34;topic-word.txt&#34;.IO.lines.iterator;
    my ($document-size, $topic-size) = doc-topic-iter.pull-one.words;
    my ($, $word-size) = topic-word-iter.pull-one.words;

    my Num @document-topic[$document-size;$topic-size];
    my Num @topic-word[$topic-size;$word-size];

    for ^$document-size -&gt; $doc-i {
        my \maybe-line := doc-topic-iter.pull-one;
        die &#34;Error: Something went wrong&#34; if maybe-line =:= IterationEnd;
        my Num @line = @(maybe-line).words&gt;&gt;.Num;
        for ^@line {
            @document-topic[$doc-i;$_] = @line[$_];
        }
    }

    for ^$topic-size -&gt; $topic-i {
        my \maybe-line := topic-word-iter.pull-one;
        die &#34;Error: Something went wrong&#34; if maybe-line =:= IterationEnd;
        my Num @line = @(maybe-line).words&gt;&gt;.Num;
        for ^@line {
            @topic-word[$topic-i;$_] = @line[$_];
        }
    }

    my %vocabulary = &#34;vocabulary.txt&#34;.IO.lines.pairs&gt;&gt;.antipair.hash;
    my @members = &#34;members.txt&#34;.IO.lines;
    my @documents = &#34;documents.txt&#34;.IO.lines;
    my @docbodies = @documents.map({ my ($, $, *@body) = .words; @body.join(&#34; &#34;) });
    my %doc-to-person = @documents.map({ my ($docid, $personid, $) = .words; %($docid =&gt; $personid) }).hash;
    my @query = $query.words.map(*.lc);

    my @sorted-list = gather for ^$document-size -&gt; $doc-i {
        my Num $log-prob = gather for @query -&gt; $token {
            my Num $log-ml-prob = Pml(@docbodies, $doc-i, $token);
            my Num $log-lda-prob = Plda($token, $topic-size, $doc-i, %vocabulary, @document-topic, @topic-word);
            take log-sum(log(0.2) + $log-ml-prob, log(0.8) + $log-lda-prob);
        }.sum;
        take %(doc-i =&gt; $doc-i, log-prob =&gt; $log-prob);
    }.sort({ $^b&lt;log-prob&gt; &lt;=&gt; $^a&lt;log-prob&gt; });

    for ^10 {
        my $docid = @sorted-list[$_]&lt;doc-i&gt;;
        sprintf(&#34;\&#34;%s\&#34; by %s %f&#34;, @docbodies[$docid], @members[%doc-to-person{$docid}], @sorted-list[$_]&lt;log-prob&gt;).say;
    }

}

sub Pml(@docbodies, $doc-i, $token --&gt; Num) {
    my Int $num-tokens = @docbodies[$doc-i].words.grep({ /:i^ $token $/ }).elems;
    my Int $total-tokens = @docbodies[$doc-i].words.elems;
    return -100e0 if $total-tokens == 0 or $num-tokens == 0;
    log($num-tokens) - log($total-tokens);
}

sub Plda($token, $topic-size, $doc-i, %vocabulary is raw, @document-topic is raw, @topic-word is raw --&gt; Num) {
    gather for ^$topic-size -&gt; $topic {
        if %vocabulary{$token}:exists {
            take @document-topic[$doc-i;$topic] + @topic-word[$topic;%vocabulary{$token}];
        } else {
            take -100e0;
        }
    }.reduce(&amp;log-sum);
}

sub log-sum(Num $log-a, Num $log-b --&gt; Num) {
    if $log-a &lt; $log-b {
        return $log-b + log(1 + exp($log-a - $log-b))
    } else {
        return $log-a + log(1 + exp($log-b - $log-a))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在beggining，我们加载保存的模型和准备`@document-topic`，<code>@topic-word</code>，<code>%vocabulary</code>，<code>@documents</code>，<code>@docbodies</code>，<code>%doc-to-person`和</code>@members`</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> my \doc-topic-iter = &#34;document-topic.txt&#34;.IO.lines.iterator;
    my \topic-word-iter = &#34;topic-word.txt&#34;.IO.lines.iterator;
    my ($document-size, $topic-size) = doc-topic-iter.pull-one.words;
    my ($, $word-size) = topic-word-iter.pull-one.words;

    my Num @document-topic[$document-size;$topic-size];
    my Num @topic-word[$topic-size;$word-size];

    for ^$document-size -&gt; $doc-i {
        my \maybe-line = doc-topic-iter.pull-one;
        die &#34;Error: Something went wrong&#34; if maybe-line =:= IterationEnd;
        my Num @line = @(maybe-line).words&gt;&gt;.Num;
        for ^@line {
            @document-topic[$doc-i;$_] = @line[$_];
        }
    }

    for ^$topic-size -&gt; $topic-i {
        my \maybe-line = topic-word-iter.pull-one;
        die &#34;Error: Something went wrong&#34; if maybe-line =:= IterationEnd;
        my Num @line = @(maybe-line).words&gt;&gt;.Num;
        for ^@line {
            @topic-word[$topic-i;$_] = @line[$_];
        }
    }

    my %vocabulary = &#34;vocabulary.txt&#34;.IO.lines.pairs&gt;&gt;.antipair.hash;
    my @members = &#34;members.txt&#34;.IO.lines;
    my @documents = &#34;documents.txt&#34;.IO.lines;
    my @docbodies = @documents.map({ my ($, $, *@body) = .words; @body.join(&#34; &#34;) });
    my %doc-to-person = @documents.map({ my ($docid, $personid, $) = .words; %($docid =&gt; $personid) }).hash;</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，我们`@query`使用选项设置`:$query`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @query = $query.words.map(*.lc);</code></pre>
</div>
</div>
<div class="paragraph">
<p>之后，我们计算`P(query|document)`基于Eq 的概率。前面提到的9篇文章（注意我们使用对数来避免不流动并将参数mu设置为零）并对它们进行排序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    my @sorted-list = gather for ^$document-size -&gt; $doc-i {
        my Num $log-prob = gather for @query -&gt; $token {
            my Num $log-ml-prob = Pml(@docbodies, $doc-i, $token);
            my Num $log-lda-prob = Plda($token, $topic-size, $doc-i, %vocabulary, @document-topic, @topic-word);
            take log-sum(log(0.2) + $log-ml-prob, log(0.8) + $log-lda-prob);
        }.sum;
        take %(doc-i =&gt; $doc-i, log-prob =&gt; $log-prob);
    }.sort({ $^b&lt;log-prob&gt; &lt;=&gt; $^a&lt;log-prob&gt; });</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Plda`为每个主题添加给定文档概率（即lnP（主题| theta，文档））和单词给定主题概率（即lnP（word | phi，topic））的对数主题，并将它们加起来</code>.reduce(&amp;log-sum);`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub Plda($token, $topic-size, $doc-i, %vocabulary is raw, @document-topic is raw, @topic-word is raw --&gt; Num) {
    gather for ^$topic-size -&gt; $topic {
        if %vocabulary{$token}:exists {
            take @document-topic[$doc-i;$topic] + @topic-word[$topic;%vocabulary{$token}];
        } else {
            take -100e0;
        }
    }.reduce(&amp;log-sum);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而且 <code>Pml</code>（ml表示最大似然）计数`$token`并将其标准化为文档中的总标记（注意，此计算也在日志空间中进行）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub Pml(@docbodies, $doc-i, $token --&gt; Num) {
    my Int $num-tokens = @docbodies[$doc-i].words.grep({ /:i^ $token $/ }).elems;
    my Int $total-tokens = @docbodies[$doc-i].words.elems;
    return -100e0 if $total-tokens == 0 or $num-tokens == 0;
    log($num-tokens) - log($total-tokens);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>好的，那就让我们执行吧！</p>
</div>
<div class="paragraph">
<p>查询“perl”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ raku search-quotation.p6 --query=&#34;perl&#34;
&#34;Perl will always provide the null.&#34; by Larry Wall -3.301156
&#34;Perl programming is an *empirical* science!&#34; by Larry Wall -3.345189
&#34;The whole intent of Perl 5&#39;s module system was to encourage the growth of Perl culture rather than the Perl core.&#34; by Larry Wall -3.490238
&#34;I dunno, I dream in Perl sometimes...&#34; by Larry Wall -3.491790
&#34;At many levels, Perl is a &#39;diagonal&#39; language.&#34; by Larry Wall -3.575779
&#34;Almost nothing in Perl serves a single purpose.&#34; by Larry Wall -3.589218
&#34;Perl has a long tradition of working around compilers.&#34; by Larry Wall -3.674111
&#34;As for whether Raku will replace Perl 5, yeah, probably, in about 40 years or so.&#34; by Larry Wall -3.684454
&#34;Well, I think Perl should run faster than C.&#34; by Larry Wall -3.771155
&#34;It&#39;s certainly easy to calculate the average attendance for Perl conferences.&#34; by Larry Wall -3.864075</code></pre>
</div>
</div>
<div class="paragraph">
<p>查询“apple”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku search-quotation.p6 --query=&#34;apple&#34;
&#34;Steve Jobs is the&#34;With phones moving to technologies such as Apple Pay, an unwillingness to assure security could create a Target-like exposure that wipes Apple out of the market.&#34; by Rob Enderle -3.841538
&#34;*:From Joint Apple / HP press release dated 1 January 2004 available [http://www.apple.com/pr/library/2004/jan/08hp.html here].&#34; by Carly Fiorina -3.904489
&#34;Samsung did to Apple what Apple did to Microsoft, skewering its devoted users and reputation, only better. ... There is a way for Apple to fight back, but the company no longer has that skill, and apparently doesn&#39;t know where to get it, either.&#34; by Rob Enderle -3.940359
&#34;[W]hen it came to the iWatch, also a name that Apple didn&#39;t own, Apple walked away from it and instead launched the Apple Watch. Certainly, no risk of litigation, but the product&#39;s sales are a fraction of what they otherwise might have been with the proper name and branding.&#34; by Rob Enderle -4.152145
&#34;[W]hen Apple wanted the name &#34;iPhone&#34; and it was owned by Cisco, Steve Jobs just took it, and his legal team executed so he could keep it. It turned out that doing this was surprisingly inexpensive. And, as the Apple Watch showcased, the Apple Phone likely would not have sold anywhere near as well as the iPhone.&#34; by Rob Enderle -4.187223
&#34;The cause of [Apple v. Qualcomm] appears to be an effort by Apple to pressure Qualcomm into providing a unique discount, largely because Apple has run into an innovation wall, is under increased competition from firms like Samsung, and has moved to a massive cost reduction strategy. (I&#39;ve never known this to end well, as it causes suppliers to create unreliable components and outright fail.)&#34; by Rob Enderle -4.318575
&#34;Apple tends to aggressively work to not discover problems with products that are shipped and certainly not talk about them.&#34; by Rob Enderle -4.380863
&#34;Apple no longer owns the tablet market, and will likely lose dominance this year or next. ... this level of sustained dominance doesn&#39;t appear to recur with the same vendor even if it launched the category.&#34; by Rob Enderle -4.397954
&#34;Apple is becoming more and more like a typical tech firm â€” that is, long on technology and short on magic. ... Apple is drifting closer and closer to where it was back in the 1990s. It offers advancements that largely follow those made by others years earlier, product proliferation, a preference for more over simple elegance, and waning excitement.&#34; by Rob Enderle -4.448473
&#34;[T]he litigation between Qualcomm and Apple/Intel ... is weird. What makes it weird is that Intel appears to think that by helping Apple drive down Qualcomm prices, it will gain an advantage, but since its only value is as a lower cost, lower performing, alternative to Qualcomm&#39;s modems, the result would be more aggressively priced better alternatives to Intel&#39;s offerings from Qualcomm/Broadcom, wiping Intel out of the market. On paper, this is a lose/lose for Intel and even for Apple. The lower prices would flow to Apple competitors as well, lowering the price of competing phones. So, Apple would not get a lasting benefit either.&#34; by Rob Enderle -4.469852 Ronald McDonald of Apple, he is the face.&#34; by Rob Enderle -3.822949
&#34;With phones moving to technologies such as Apple Pay, an unwillingness to assure security could create a Target-like exposure that wipes Apple out of the market.&#34; by Rob Enderle -3.849055
&#34;*:From Joint Apple / HP press release dated 1 January 2004 available [http://www.apple.com/pr/library/2004/jan/08hp.html here].&#34; by Carly Fiorina -3.895163
&#34;Samsung did to Apple what Apple did to Microsoft, skewering its devoted users and reputation, only better. ... There is a way for Apple to fight back, but the company no longer has that skill, and apparently doesn&#39;t know where to get it, either.&#34; by Rob Enderle -4.052616
&#34;*** The previous line contains the naughty word &#39;$&amp;&#39;.\n if /(ibm|apple|awk)/; # :-)&#34; by Larry Wall -4.088445
&#34;The cause of [Apple v. Qualcomm] appears to be an effort by Apple to pressure Qualcomm into providing a unique discount, largely because Apple has run into an innovation wall, is under increased competition from firms like Samsung, and has moved to a massive cost reduction strategy. (I&#39;ve never known this to end well, as it causes suppliers to create unreliable components and outright fail.)&#34; by Rob Enderle -4.169533
&#34;[T]he litigation between Qualcomm and Apple/Intel ... is weird. What makes it weird is that Intel appears to think that by helping Apple drive down Qualcomm prices, it will gain an advantage, but since its only value is as a lower cost, lower performing, alternative to Qualcomm&#39;s modems, the result would be more aggressively priced better alternatives to Intel&#39;s offerings from Qualcomm/Broadcom, wiping Intel out of the market. On paper, this is a lose/lose for Intel and even for Apple. The lower prices would flow to Apple competitors as well, lowering the price of competing phones. So, Apple would not get a lasting benefit either.&#34; by Rob Enderle -4.197869
&#34;Apple tends to aggressively work to not discover problems with products that are shipped and certainly not talk about them.&#34; by Rob Enderle -4.204618
&#34;Today&#39;s tech companies aren&#39;t built to last, as Apple&#39;s recent earnings report shows all too well.&#34; by Rob Enderle -4.209901
&#34;[W]hen it came to the iWatch, also a name that Apple didn&#39;t own, Apple walked away from it and instead launched the Apple Watch. Certainly, no risk of litigation, but the product&#39;s sales are a fraction of what they otherwise might have been with the proper name and branding.&#34; by Rob Enderle -4.238582</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_结论_6">51.3. 结论</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">在本文中，我们探索了Wikiquote，并使用Algoritm </dt>
<dd>
<p>LDA创建了一个LDA模型。
之后我们构建了一个信息检索应用程序。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>感谢您阅读我的文章！下次见！</p>
</div>
</div>
<div class="sect2">
<h3 id="_引文_2">51.4. 引文</h3>
<div class="ulist">
<ul>
<li>
<p>Blei，David M.“Probabilistic topic models。”ACM 55.4（2012）的通讯：77-84。</p>
</li>
<li>
<p>Wei，Xing和W. Bruce Croft。“基于LDA的文档模型，用于临时检索。”第29届年度国际ACM SIGIR研究与开发信息检索会议论文集。ACM，2006。
== 第二十五天 - 以数之名</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个学期学期我参加了我的第一个校对课程，题为“数学证明研讨会简介”。在学习了其他数学课程（微积分，矩阵代数等）之后，我觉得我没有那么多的数学基础，到目前为止，我所做的只是纯粹的计算数学，到处撒上了一些证明。回想起来，我发现课程非常有趣，并且学习不同的定理及其证明，主要来自数论，给了我一个新的数学视角。</p>
</div>
<div class="paragraph">
<p>你可能会问，“这与 Raku 有什么关系？”。正如我所提到的，课堂上讨论的大多数证明或家庭作业都与数论有关。如果 Raku 和数论有一个共同点就是它们的可访问性。类似于数论的内容如何具体和熟悉，Raku 对初学者来说非常平易近人。事实上，鼓励初学者写出所谓的“婴儿 Perl”。</p>
</div>
<div class="paragraph">
<p>似乎他们分享的另一件事是他们的浩瀚。例如，在 Raku 中可以找到许多运算符，而在数论中，可以找到从偶数到可爱数字的过多不同类型的数字。在大多数情况下，这些数字很容易理解，如果有一个数字的定义，那么很容易检查该类别中是否包含给定的整数。例如，素数正式定义如下：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>如果整数p&gt; 1的唯一正数除数为1且p为p，则称p为素数，或简称为素数。否则，称整数p为合数。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>通过使用这个定义，我们可以非常简单地弄清楚某个数字是否是素数。例如，在前十个正整数中，2,3,5和7是素数。对于小数字来说这是微不足道的，但是用更大的数字手工完成它会很快变得单调乏味。这就是 Raku 的用武之地。Raku 提供了许多构造/函数，即使它们不能简化工作，它们也可以简化它。例如，考虑到素数的定义，我们可以轻松实现在 Raku 中测试素数的算法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub isPrime( $number ) {
    return $number &gt; 1 if $number ≤ 3;

    loop (my $i = 2; $i² ≤ $number; $i++) {
        return False if $number %% $i;
    }

    return True;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住，这不是关于编写高性能代码。如果代码以这种方式拒绝，那么它将是优秀的，但它不是目标。我的目的是展示初学者在 Raku 中表达数学结构的容易程度。值得一提的是，Raku 已经包含了`is-prime`测试素数的子程序（或方法）。然而，尽管对于素数这是正确的，但对于你可能遇到的另一种类型的数字可能并非如此，例如阶乘，因子或甚至加泰罗尼亚数字。在这种情况下，Raku 会很有帮助。</p>
</div>
<div class="paragraph">
<p>在了解了不同类型的数字后，我开始寻找一些奇特的数字，看看如何使用 Raku 实现它们。在这个过程中，我发现这个<a href="http://www.daviddarling.info/encyclopedia/N/numbers_types.html">有用的网站</a>列出了一堆数字，它们的定义和一些例子。从所有这些中，我选择了四种类型的数字，这些数字并非愚蠢地难以实现（我仍然在编写 Perl 宝宝!😅），同时足以说明一些 Raku 构造。另一方面，我避免了那些可能过于简单的事情。</p>
</div>
<div class="paragraph">
<p>让我们开始于…​</p>
</div>
</div>
<div class="sect2">
<h3 id="_友善的数字">51.5. 友善的数字</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Amicable 数字是一对数字，也称为<strong>友好数字</strong>，每个<strong>数字</strong>的等分部分添加给另一个数字。</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub aliquot-parts( $number ) {
   (^$number).grep: $number %% *;
}

sub infix:&lt;amic&gt;( $m, $n ) {
    $m == aliquot-parts($n).sum &amp;&amp;
    $n == aliquot-parts($m).sum;
}

say 12 amic 28;   # False, 12 and 28 aren&#39;t amicables.
say 220 amic 284; # True, 220 and 284 are though.</code></pre>
</div>
</div>
<div class="paragraph">
<p>数字的等分部分是排除数字本身的因素。为了找到数字的等分部分，我创建了一个子程序`aliquot-parts`，用于`1..^$number`创建从1到`$numbers`（不包括）的数字列表。随后对该列表进行了追踪，以找出列表中均匀分割的那些数字`$number`。在这个片段中，它是通过使用中缀运算符实现的`%%<code>，`True`如果第一个操作数可被第二个操作数整除，则返回该操作符。否则，它返回`False</code>。第二个操作数代表前面提到的列表中的任何数字，所以我使用过`*<code>，在这种情况下，它被称为*任何星形，*并在表达式上创建一个闭包</code>$number %% *<code>。因此，子程序中的整个表达式相当于</code>(^$number).grep: { $number %% $_ };`。最后，子程序返回`$number`排除`$number`自身的因子列表。</p>
</div>
<div class="paragraph">
<p>为了确定两个数字是否友好，我们可以只使用一个子程序。但是，Raku允许创建新的运算符，这些运算符*只是具有有趣名称的子程序*，我就是这么做的。我创建了中缀运算符（意思是两个操作数之间）<code>amic</code> ，<code>True`如果两个数字是友好的，则返回。否则，`False</code>。如你所见，创建新运算符的语法很简单：关键字`sub`，后跟运算符的类型（前缀，中缀，后缀等），引用构造内的运算符名称，预期参数和代码块。</p>
</div>
</div>
<div class="sect2">
<h3 id="_factorion">51.6. Factorion</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>因子是一个自然数，等于给定基数中其数字的阶乘的总和。</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset Whole of Int where * ≥ 0;

sub postfix:&lt;!&gt;( Whole $N --&gt; Whole ) {
    [*] 1..$N;
}

sub is-factorion( Whole $number --&gt; Bool ) {
    $number == $number.comb.map({ Int($_)! }).sum
}

say is-factorion(25);  # False
say is-factorion(145); # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>回想一下，通常用数字<strong>N</strong>表示的阶乘`N!<code>是产品`1 x 2 x …​ x N</code>。例如，<code>3! = 1 x 2 x 3 = 6</code>。在代码片段中，我创建了postfix运算符`!<code>以返回整数操作数的阶乘。因此`say 3!;</code>，在代码片段和打印中工作得很好`6`。计算阶乘是如何直接的：范围`1..$N`创建一个从1到`$N`（包括）的数字列表然后我使用`[…​]<code>，这被称为*减少*元运算符，运算符</code>*<code>减少创建的列表`1 x 2 x …​ $N</code>，有效地给了我阶乘的`$N`。Raku中有许多运算符，元运算符`[…​]`可以与其中许多运算符一起使用。</p>
</div>
<div class="paragraph">
<p>至于因子，我想知道一个数字是否是一个因子，所以我创建了一个采用整数并返回一个布尔值的子程序。Raku逐渐输入，因此它允许显式输入变量，指定子的返回类型等。我决定键入子程序的参数和子程序的返回类型。</p>
</div>
<div class="paragraph">
<p>关于友好数字的部分，我对子程序的论点非常自由。但是，在这里，我决定遵循阶乘的定义，只允许整数，因此定义和使用该`Whole`类型。在Raku中，运算符`subset`使用基类型声明一个新类型。但是，如果我没有使用该`where`条款，那么我最终只会使用另一个名称，这个`Int`类型将是多余的。所以我使用该`where`子句来约束对所需输入的任何赋值的类型。在这种情况下，赋值给类型的变量`Whole`。</p>
</div>
<div class="paragraph">
<p>使用`is-factorion`sub，我使用该方法`comb`分解`$number`成数字，然后用`map`它们找到各自的阶乘并总结它们。子返回`True`if `$number`等于其数字的阶乘的总和。`False`否则返回。</p>
</div>
</div>
<div class="sect2">
<h3 id="_循环数">51.7. 循环数</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>循环数是具有<strong>N个</strong>数字的数字，当乘以时`1, 2, 3, …​, N`，以不同的顺序产生相同的数字。</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub is-cyclic( Int $n --&gt; Bool ) {
    for 1..$n.chars -&gt; $d {
        return False if $n.comb.Bag != ($n * $d).comb.Bag;
    }
    return True;
}

say is-cyclic(142857); # True
say is-cyclic(95678);  # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我创建了`is-cyclic`一个采用整数并返回布尔值的子程序。我使用`for`循环遍历数字位数（第1个，第2个等）并使用它们乘以每次迭代中的数字。然后我使用之前看到的`comb`方法，然后使用该`Bag`方法。在Raku中，a <code>Bag`是不同元素的不可变集合，没有特定顺序，其中每个元素按集合中的副本数加权。这是我需要的那种结构，因为只有数字的数字及其数量很重要，而不是它们的顺序，并且`Bag`完全实现了这一点。`False`如果行李不具有相同的数字或具有相同的数字但是加权不同，则子程序返回。除此以外，`True</code> 返回，表示数字的循环。</p>
</div>
</div>
<div class="sect2">
<h3 id="_快乐的数字">51.8. 快乐的数字</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>幸福数字由以下过程定义：从任何正整数开始，将数字替换为其在十进制数字中的数字的平方和，并重复该过程，直到该数字等于1（它将保留的位置），或者它在一个不包括1的循环中无休止地循环。</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub is-happy( $n is copy ) {
    my $seen-numbers = :{};
    while $n &gt; 1 {
        return False if $n ∈ $seen-numbers;
        $seen-numbers{$n} = True;
        $n = $n.comb.map(*²).sum
    }
    return True;
}

say is-happy(7);     # True
say is-happy(2018);  # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>在完成定义中描述的过程之后，一个快乐的数字结束等于1.另一方面，一个非快乐的数字跟随一个到达循环的序列，该序列`4, 16, 37, 58, 89, 145, 42, 20, 4,…<code>不包括1.有了这个事实，我创建了散列</code>$seen-numbers`到跟踪这些数字。如while循环所示，该过程一次又一次地重复，同时`$n`大于1或直到看到数字。这里突出的线是包含符号∈的线。在集合论中，如果元素p是集合A的成员（或元素），则它由p∈A表示，这正是在此处测试的内容。如果数字`$n`是散列的元素，则子返回`False`。否则，它返回`True`，表示数字的幸福。</p>
</div>
</div>
<div class="sect2">
<h3 id="_摘要">51.9. 摘要</h3>
<div class="paragraph">
<p>在这篇文章中，我略微进行了逐步打字，如何定义一个新的运算符，使用`subset`关键字`set`和`bag`数据结构进行子类化。正如你可能已经意识到的那样，Raku 提供了许多可以促进许多不同任务的构造。在这种情况下，我希望以更加程序化的方式表达数字的定义。你可能会完全不同，但你可以放心，Raku 可以让你的工作更轻松，更有乐趣。</p>
</div>
<div class="paragraph">
<p>嗯…​…​这就是所有人！圣诞节快乐，新年快乐！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_raku_中的异步和并发入门">52. Raku 中的异步和并发入门</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/01/introducing-async-concurrency-in-raku/cover-dmitrii-vaccinium-Q47eNv_UvfM-unsplash_huc21c1d46fd3ec96fb42a3a0ab1e6a4ce_1773515_280x280_fill_q75_box_smart1.jpg" alt="Introducing Async &amp; Concurrency in Raku"/>
</div>
</div>
<div class="paragraph">
<p>从今天之后的23天里, 在我们进入这个降临日历之前, 我想确保介绍一下我将要涉及的基本概念。我把它称为 &#34;Raku Async &amp; Concurrency Advent Calendar&#34;, 但这些术语是什么意思呢, 它们又是如何应用于 Raku 的呢？</p>
</div>
<div class="paragraph">
<p>这个 Advent Calendar 的前提是你对 Raku 有基本的了解。如果你不了解 Raku, 但你熟悉另一种语言, 我相信你可能会跟得上。然而, 这是针对中高级开发者的, 所以我推荐你先从这些资源中学习 Raku。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://shop.oreilly.com/product/0636920062776.do">Perl 6 入门</a>(Raku 是以前称为 Perl 6 的语言)</p>
</li>
<li>
<p><a href="https://learnxinyminutes.com/docs/perl6/">用 Y 分钟学习 Raku</a></p>
</li>
<li>
<p><a href="https://raku.guide/">Raku 指南</a></p>
</li>
<li>
<p><a href="https://docs.raku.org/language.html">Raku 文档</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_异步编程">52.1. 异步编程</h3>
<div class="paragraph">
<p>Async 是异步编程的简称, 因为异步(asynchronous)的输入很麻烦。异步编程是一种编程风格, 对函数的调用与其返回是脱节的。通常, 我们会写一个这样的函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub double($x) { $x * 2 }
my $val = double(21);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们想把这段代码变成异步的, 我们可以尝试这样做:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub double($x) { sub () { $x * 2 } }
my $promise = double($x);
# more code
# ...
# more code
my $val = $promise.();</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个愚蠢的人为的例子, 但重点是我们实际上要到后来才会收到值。这种编程风格主要是在你知道你需要完成一些工作, 但不需要立即得到结果的时候有用。当你可能需要在此期间做其他工作时, 这种方式尤其有用。</p>
</div>
<div class="sect3">
<h4 id="_什么时候才有意义">52.1.1. 什么时候才有意义？</h4>
<div class="paragraph">
<p>举几个例子说明异步可能会有帮助的情况。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>所有基于套接字的客户端/服务器应用程序都必须是异步的。对于 TCP 来说, 在服务器上, 你建立一个监听套接字, 然后当客户端连接时, 你会收到一个连接的套接字, 你可以在这个套接字上使用读写操作交换数据。而 TCP 客户端则是请求一个连接, 然后等待服务器接受连接。在等待的过程中, 客户端可以继续进行工作。</p>
</li>
<li>
<p>一个实时处理日志数据的程序通常有几个处理步骤, 每一行都要经过。它等待数据的到达。它解析每一行数据, 从中获取有趣的信息。它对数据进行过滤, 以决定它是否对当前任务有用。它对数据进行计算。这些操作中的每一项都可以在异步编程链中执行, 其中每一步只要有一定量的数据准备好了, 就会执行这些操作。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>异步只是一种编程风格, 它适合于你, 软件开发者, 决定它适合的地方。有些问题比其他问题更具有内在的异步性, 但你也可以同步地构建它们。当它适合你的时候就使用异步(async)。</p>
</div>
</div>
<div class="sect3">
<h4 id="_工具有哪些">52.1.2. 工具有哪些？</h4>
<div class="paragraph">
<p>在 Raku 中, 异步编程主要是通过高级的、&#34;可组合&#34;的接口来进行的, 比如 <a href="https://docs.raku.org/type/Promise">Promise</a>, <a href="https://docs.raku.org/type/Supply">Supply</a> 和 <a href="https://docs.raku.org/type/Channel">Channel</a>。这些都是高级的, 因为它们提供了一个针对某人的接口, 而不需要严格证明这些工具如何使用的安全性。你仍然要小心, 这是肯定的, 但陷阱减少了很多, 从它们的接口上看应该更明显。它们是可组合的, 因为它们的设计是为了让你把使用这些接口的不同库, 以可预测的方式一起使用。</p>
</div>
<div class="paragraph">
<p>另一方面, 像 <a href="https://docs.raku.org/type/Lock">Lock</a> 和 <a href="https://docs.raku.org/type/Semaphore">Semaphore</a> 这样的低级工具, 当使用这些工具的不同库组合在一起时, 会导致不可预测的行为。这些在 Raku 中也是可用的, 因为有时你需要用它们来构建, 但它们不是 Raku 的异步编程的万金油。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是什么样子的呢">52.1.3. 它是什么样子的呢？</h4>
<div class="paragraph">
<p>那么 Raku 中的异步编程是什么样的呢？这里有一个基本的计数程序, 但我们不使用循环, 而是每秒钟输出一个数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    whenever Supply.interval(1) -&gt; $n {
        say $n;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这在功能上等同于运行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 1...* -&gt; $n {
    say $n;
    sleep 1;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见, 语法非常简单, 希望容易上手。你甚至可以认为它算是同步的, 而不会遇到太多麻烦。Raku 中的异步编程的一个目标是让那些不完全理解它的人至少能理解发生了什么。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_并发编程">52.2. 并发编程</h3>
<div class="paragraph">
<p>我在大学里上过一门关于并发编程的课。恐怕我没有很好地掌握这个主题就通过了这门课。然而, 我认为部分原因是因为它是一个很难真正理解的概念, 通过掀开引擎盖, 看看所有的运动部件。不过, 也有一部分原因是因为这门课用数学术语来教授并发性, 而我发现实用术语更容易理解。</p>
</div>
<div class="paragraph">
<p>并发编程仅仅是同时运行程序的各个部分的行为。程序中可以同时运行的部分称为线程。你可以把线程视为程序可以在其中运行其代码的通道。例如, 每个线程可能使用不同的起始数据运行同一个程序代码。或者, 一个程序可以有一个线程用于更新图形界面, 一个线程用于与网络上的其他程序对话, 一个线程用于对接收到的数据进行本地处理。</p>
</div>
<div class="sect3">
<h4 id="_裸机线程">52.2.1. 裸机线程</h4>
<div class="paragraph">
<p>分道运行可以通过多种方式实现, 包括:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在单 CPU/单核计算机上, CPU 会将需要同时进行的代码交错执行。代码实际上并不是同时运行, 而是每个程序的每个线程都有时间在 CPU 上运行一些指令, 然后进行上下文切换, 运行另一个线程。</p>
</li>
<li>
<p>在多 CP​​U/多核计算机上, 这既意味着在每个 CPU 核心上交错运行代码, 也意味着在每个核心上同时在不同的硬件上运行各种程序和线程。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>无论如何, 你都会遇到一个问题, 即任何给定线程中的代码可能只完成了任务的一小部分, 因此你需要确保线程之间安全地交互。这就是所谓的&#34;线程安全代码&#34;。</p>
</div>
</div>
<div class="sect3">
<h4 id="_线程安全">52.2.2. 线程安全</h4>
<div class="paragraph">
<p>构建线程安全代码有几种基本的编程风格。我在这里从最喜欢到最不喜欢的风格来介绍它们:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>任何无状态的代码或者只有自身内部状态变化的代码本质上都是线程安全的。只有当代码需要访问其他代码可能使用的数据时, 它才会变得不安全。</p>
</li>
<li>
<p>通常情况下, 可以将代码写成内部是无状态的, 但在完成执行时执行状态更改。只要某些内容以安全的方式同步状态更新, 这种数据转换就是线程安全的。执行转换的代码本身不必对安全性做出任何特殊规定。</p>
</li>
<li>
<p>对于必须在执行线程之间共享某些可变状态的情况, 每次读取和写入数据时都必须格外小心, 以确保这些更改不会破坏状态。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Raku 提供了专门的工具来处理这些情况。每当编写并发程序时, 都应该尽可能地瞄准前两种编码风格。这些是最容易理解和维护的。然而, 第三种选择有时是最好的</p>
</div>
</div>
<div class="sect3">
<h4 id="_raku_之道">52.2.3. Raku 之道</h4>
<div class="paragraph">
<p>在 Raku 中, 我们不倾向于直接使用线程。取而代之的是, 我们调度代码块异步运行。代码的实际运行方式取决于所使用的调度程序。Rakudo 上的默认调度程序会将代码块调度到主线程之外的单独线程上运行。<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>
</div>
<div class="paragraph">
<p>调度要运行的块的主要方法是使用 <code>start</code> 块, 类似于下面的示例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">start {
    # Subtask 1
}
start {
    # Subtask 2
}
# Main task</code></pre>
</div>
</div>
<div class="paragraph">
<p>我个人将根据这种方式或通过其他方式安排的工作称为&#34;任务&#34;(task)或&#34;子任务&#34;(subtask), 这取决于上下文。不过这不是 Raku 主义, 所以要注意其他人的术语可能会有所不同。</p>
</div>
<div class="paragraph">
<p>总之, 主要的一点是, 并发是指同时运行你的代码的两个不同部分。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_并行编程">52.3. 并行编程</h3>
<div class="paragraph">
<p>我们在本日历中经常使用的第三个术语是并行编程。并行编程与并发性非常相似, 但主要面向并行处理数据。例如, 如果你有大量的整数, 你想通过一个函数来运行, 你可以为对这些整数中的每一个整数都并发地执行该操作。这是并行编程。</p>
</div>
<div class="paragraph">
<p>它是与异步(async)或并发是一个独立的术语, 原因有二。其一, 并行程序不一定是并发或异步的, 其二, 有一些与并行编程相关的特殊优化, 它们不一定是通用并发或异步的一部分。</p>
</div>
<div class="paragraph">
<p>例如, 这是 Raku 中的一个小型并行程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @doubles = (1...10_000_000).hyper.map(* * 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>当这个程序运行时, Raku 会安排任务在多个线程中运行, 对范围内的所有值进行迭代, 并将所有1000万个值全部分批翻倍。把工作分为几批, 然后选择如何调度, 这就是并行编程本身的特殊主题。这个程序可能是并发的, 但它不是异步的。我们也可以异步地进行并行编程, 但在这个例子中我们并没有。</p>
</div>
</div>
<div class="sect2">
<h3 id="_编程编程">52.4. 编程编程</h3>
<div class="paragraph">
<p>所以, 当我们把这些术语放在一起的时候, 我们会发现一个程序可能具有所描述的三种属性中的任何一种。它可能是并发的, 异步的和并行的。它可能不具备这些特性。它可能只是其中的一个或两个, 任意组合。这些都是不同的编程风格。</p>
</div>
<div class="paragraph">
<p>Raku 提供的工具旨在使你的代码在异步、并发和并行地编写时更容易阅读。它还旨在鼓励你以一种固有的线程安全的方式编写你的代码, 允许你在多个线程中同时操作时安全地转换状态。</p>
</div>
<div class="paragraph">
<p>我希望在接下来的23天里, 我将更好地让你决定何时拥抱Raku的每一个特性, 以及如何以一种让你的代码更快, 同时又易于人类解析和理解的方式进行。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/archive/2019/12/01/introducing-async-concurrency-in-raku.html" class="bare">https://zostay.com/archive/2019/12/01/introducing-async-concurrency-in-raku.html</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_promise">53. Promise</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 中, <a href="https://zostay.com/archive/2019/12/02/promises.html">Promise</a> 代表了异步任务之间通信的最简单的高级语言功能。它们很像人与人之间的承诺。例如, 我可能会答应我的儿子, 我会帮助他完成学业。当我帮助他的时候, 我就会遵守这个承诺。或者, 如果由于某种原因, 我未能帮助他, 我就会违背这个承诺。Raku 中 的 Promise 也是如此。当一个值到达的时候, 返回一个值的承诺(Promise)就会被遵守。如果发生了错误, 阻止了值的到达, 那么返回值的承诺(Promise)就会被打破。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/02/promises/cover-korie-cull-f3gcUmrR4eQ-unsplash_hu4feb791eb4e6207b9aa233eb6f7c17b5_2502682_280x280_fill_q75_box_smart1.jpg" alt="Promise"/>
</div>
</div>
<div class="paragraph">
<p>所以, 让我们来看看 Raku 中的基本承诺:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = start {
    my $nth = 0;
    my $nth-prime;
    for 1..* -&gt; $number {
        $nth++ if $number.is-prime;
        if $nth == 10_000 {
            $nth-prime = $number;
            last;
        }
    }
    $nth-prime;
}
await $promise.then({ say .result });</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码使用 <a href="https://docs.raku.org/language/control#index-entry-control_flow_start-start">start</a> 块开始查找第 10000 个素数。这个块返回一个  <a href="https://docs.raku.org/type/Promise">Promise</a> 对象。这个对象以三种状态之一存在(你可以用 <code>.status</code> 方法检查）。初始状态为 <strong>Planned</strong> 状态, 然后它进入两种最终状态中的一种。如果无法得到一个结果(通常是因为发生了异常), 则进入 <strong>Broken</strong> 状态, 而当结果可用时, 则进入 <strong>Kept</strong> 状态。一旦处于 <strong>Kept</strong> 状态, <code>.result</code> 方法将立即返回被保存的 <code>Promise</code> 的值。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>.then</code> 方法将 Promise 链在一起。这是通过添加另一个块来实现的, 该块在第一个块保留后立即开始。新的块将被赋予前一个 Promise 对象作为参数, 该方法返回一个新的 Promise, 该 Promise 将包含下一个块的结果。</p>
</div>
<div class="paragraph">
<p>上面代码中的 <code>start</code> 块将计算安排在默认线程池中的下一个未使用的线程上运行, 并返回一个 Promise 对象。<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup> 我们使用 <code>.then()</code> 来输出计算的 <code>.result</code>, 只要它可用。</p>
</div>
<div class="paragraph">
<p>最后, 我们有一个 <a href="https://docs.raku.org/type/Promise#sub_await">await</a> 语句, 该语句使主线程暂停, 直到值变得可用。如果没有这条语句, 我们的程序会在计算完成之前结束。</p>
</div>
<div class="paragraph">
<p><code>await</code> 语句还允许一个被破坏的 Promise 传递异常。考虑一下这段代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = start { die &#39;bad stuff&#39; }
sleep 1;
say &#39;something&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码会休眠 1 秒钟, 并打印 &#34;something&#34; 到标准输出。然而, 异常永远不会被接收到。这是因为尽管异常会导致 Promise 被破坏, 但我们根本没有看到 Promise 的结果。我们可以在 Promise 上添加一个 <code>await</code>, 准备好接收该值, 任何抛出的导致 Promise 被破坏的异常都会被接收。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = start { die &#39;bad stuff&#39; }
sleep 1;
say &#39;something&#39;;
await $promise;
CATCH {
    default {
        say &#34;ERROR: $_.message()&#34;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码和之前做的事情完全一样, 但是在 &#34;something&#34; 后面也会输出 &#34;ERROR: bad stuff&#34;。一定要确保在 <code>start</code> 块内部或者在另一个以这种方式接收 Promise 的块中处理你的异常, 否则你可能最终会遇到奇怪的意外问题。</p>
</div>
<div class="paragraph">
<p>这些都是 Raku Promise 的基本要素。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/02/promises/" class="bare">https://zostay.com/posts/2019/12/02/promises/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_supply_块">54. Supply 块</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/03/supply-blocks/cover-alexander-schimmeck-vKyp17kj31w-unsplash_huafe518bf6a9b466ef820c1441343f08e_5154826_280x280_fill_q75_box_smart1.jpg" alt="Supply Blocks"/>
</div>
</div>
<div class="paragraph">
<p>当你的 Raku 应用程序中流过需要在线程间安全地访问的数据流时, 你需要 <a href="https://docs.raku.org/type/Supply">Supply</a>。今天, 我们将讨论一种特殊的使用供应的方式, 即 <a href="https://docs.raku.org/syntax/supply%20emit">supply</a> 块。如果你熟悉序列, 也就是 <a href="https://docs.raku.org/type/Seq">Seq</a> 对象, <code>supply</code> 块的工作方式与之非常相似, 但是允许你在数据到来时拉动它, 并在这期间轻松地做其他事情。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi a(1) { 1 }
multi a(2) { 2 }
multi a($n where $n &gt; 2) { a($n - a($n-1)) + a($n - a($n-2)) }

my $hofstadter-generator = supply {
    for (1 ... *).map(-&gt; $n { a($n) }) -&gt; $v {
        emit $v;
    }
}

react {
    whenever $hofstadter-generator -&gt; $v {
        note $v;
    }
    whenever Supply.interval(1) {
        say &#34;Waiting...&#34;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以我们这里有三段代码:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>函数 <code>a()</code> 生成 Hofstadter Q 序列<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>的值(以一种特别低效的方式)。</p>
</li>
<li>
<p>有一个使用 <code>supply</code> 块生成的 Supply 对象, 它使用我们定义的函数输出 Hofstadter Q 序列的值, 从头开始, 一直到程序退出。</p>
</li>
<li>
<p>然后是一个 <a href="https://docs.raku.org/language/concurrency#index-entry-react">react</a> 块, 只要有值就输出, 在值之间每隔一秒输出一条等待消息。关于 <code>react</code> 块, 我将在改天再详细介绍。现在, 只需要知道 <code>react</code> 块允许我们通过将结果拉回到单个线程中来同步异步工作。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>至于我们的中心主题, <code>supply</code> 块, 它返回一个可以被&#34;分接&#34;(tapped)的 <code>Supply</code> 对象。通过调用 <code>.tap</code> 或 <code>.act</code> 方法, 或者在 <code>whenever</code> 块中作为 <code>react</code> 或另一个 <code>supply</code> 块的一部分使用。</p>
</div>
<div class="paragraph">
<p>在 <code>supply</code> 块的情况下, 我们得到的这种 <code>Supply</code> 对象被称为&#34;按需供应&#34;(on demand Supply)。这意味着每当 <code>Supply</code> 被分接(tap)时, 与该块相关的代码都会被运行。每当遇到 <code>emit</code> 时, 传递给 <code>.tap</code> 或 <code>whenever</code> 语句的块都会被运行, 并给出作为参数发出的值(在上面的示例代码中命名为 <code>$v</code>)。执行一直持续到给 supply 的块退出或到达 <code>done</code> 语句, 这将导致 <code>supply</code> 块退出(这个操作与 <code>last</code> for 循环非常相似)。</p>
</div>
<div class="paragraph">
<p>例如, 如果我们希望我们的序列在迭代 100 次后自动结束, 我们可以这样重写我们的 <code>supply</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $stopping-hofstadter-generator = supply {
        for (1 ... *).map(-&gt; $n { a($n) }) -&gt; $v {
            emit $v;
            done if $v &gt; 100;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在使用 <code>supply</code> 块时, 要记住一个非常重要的因素, 即 <code>emit</code> 命令会在每个分接(<code>tap</code>)完成工作之前进行阻塞。<sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup>这意味着该 <code>supply</code> 块&#34;支付&#34;其分接的计算时间。这种延迟提供了一种反压形式, 防止生成的 <code>Supply</code> 运行速度超过分接(tap)的处理速度。因此,如果你想让你的事件流以光速运行, 并且不在乎工具处理是否能跟上, 你需要确保分接(tap)立即启动(<code>start</code>)新的任务来运行, 以避免阻塞, 或者你想要一个不同于普通 <code>Supply</code> 的机制来处理工作负载。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/03/supply-blocks/" class="bare">https://zostay.com/posts/2019/12/03/supply-blocks/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_channel">55. Channel</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 中, <a href="https://docs.raku.org/type/Channel">Channel</a> 是一个异步的数据队列。你可以将数据送入队列的一端, 并在另一端安全地接收数据, 即使是在多个线程参与的情况下。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/04/channels/cover-tania-miron-EKX3Lx-t5CM-unsplash_hu42ee8b5b2f8086eb01445008d13dff6b_2041273_280x280_fill_q75_box_smart1.jpg" alt="Channel"/>
</div>
</div>
<div class="paragraph">
<p>让我们考虑一下<a href="https://en.wikipedia.org/wiki/Dining_philosophers_problem">哲学家用餐问题</a>的一个变体:我们有五个哲学家在桌子上喝汤。他们不互相交谈, 因为他们太忙于思考哲学问题。然而, 只有 2 个汤勺。每当一位哲学家想喝一口汤时, 她都需要获得一把汤勺。幸运的是, 每位哲学家都愿意分享汤勺, 并在每次舀完后将勺子放在桌子的中央。</p>
</div>
<div class="paragraph">
<p>我们可以这样来模拟这个问题:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $table = Channel.new;
my @philosophers = (^5).map: -&gt; $p {
    start {
        my $sips-left = 100;
        while $sips-left &gt; 0 {
            my $spoon = $table.receive;
            say &#34;Philosopher $p takes a sip with the $spoon.&#34;;
            $sips-left--;
            sleep rand;
            $table.send($spoon);
            sleep rand;
        }
    }
}
$table.send: &#39;wooden spoon&#39;;
$table.send: &#39;bamboo spoon&#39;;
await Promise.allof(@philosophers);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, 我们有五个任务运行在五个线程中, 每个任务都在争夺两个汤勺资源中的一个。他们每人将各喝 100 口汤。运行这个程序会得到 500 行类似于这样的输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">...
Philosopher 0 takes a sip with the wooden spoon.
Philosopher 2 takes a sip with the bamboo spoon.
Philosopher 3 takes a sip with the wooden spoon.
Philosopher 1 takes a sip with the bamboo spoon.
Philosopher 4 takes a sip with the bamboo spoon.
Philosopher 2 takes a sip with the bamboo spoon.
Philosopher 0 takes a sip with the wooden spoon.
Philosopher 1 takes a sip with the wooden spoon.
Philosopher 0 takes a sip with the wooden spoon.
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>代码本身非常简单。我们启动了(<code>start</code>)五个线程, 每个线程代表一个哲学家。每个哲学家都调用 <code>.receive</code> 接收下一个可用的勺子。该方法将一直阻塞, 直到有汤勺可用为止。哲学家喝一口汤, 然后使用 <code>.send</code> 将勺子放回到桌子上供其他人使用。最终, 哲学家喝完了 100 口, 并且由 <code>start</code> 返回的 Promise 会被保留下来。</p>
</div>
<div class="paragraph">
<p>主线程通过使用 <code>.send</code> 将两个汤勺放在桌子上来启动这个过程。然后, 它使用 <code>await</code> 来保持程序运行, 直到所有的哲学家完成任务。</p>
</div>
<div class="paragraph">
<p>就 CPU 而言, 通道的开销非常低。发送者将不会等待接收者。接收者可以使用 <code>.receive</code> 来阻塞, 直到队列中有可用的内容, 也可以使用 <code>.poll</code> 来检查条目而不阻塞。成本转移到内存中。通道必须在内部存储所有已发送的项, 直到它们被接收, 并且队列将继续增长, 直到程序用完内存。</p>
</div>
<div class="paragraph">
<p>因此, 当你有资源或消息要分发, 但不在任务之间共享时, 通道是很有用的。或者当你只需要进行点对点的通信时。作业队列、资源池和点对点任务通信是通道非常适合解决的那种问题的好例子。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/04/channels/" class="bare">https://zostay.com/posts/2019/12/04/channels/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_线程">56. 线程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>警告！ 我们现在正在深入了解 Raku 的内部深度。线程是一种低级的 API, 几乎所有的应用程序都应避免使用线程(Thread)。然而, 如果你的特定应用程序需要直接访问线程(<a href="https://docs.raku.org/type/Thread">Thread</a>), 那么它就是为你准备的。<sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup></p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/05/threads/cover-boris-dunand-FLzsXmNpNY8-unsplash_hubbf65d3913ba2b5d11e1378d1ae20adb_3385815_280x280_fill_q75_box_smart1.jpg" alt="Threads"/>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中, <code>Thread</code> 类的使用是直截了当的, 并且看起来与你熟悉其他语言中的线程工具的预期非常相似:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t = Thread.start:
    name =&gt; &#39;Background task&#39;,
    :app_lifetime,
    sub {
        if rand &gt; 0.5 { say &#39;weeble&#39; }
        else { say &#39;wobble&#39; }
    },
    ;

say &#34;Starting $t.id(): $t.name()&#34;;
say &#34;Main App Thread is $*THREAD.id(): $*THREAD.name()&#34;;

$t.finish; # wait for the thread to stop</code></pre>
</div>
</div>
<div class="paragraph">
<p>给 <code>Thread.start</code> 方法一些代码来运行, 然后你就离开了。<code>name</code> 和 <code>app_lifetime</code> 选项是可选的。如果 <code>app_lifetime</code> 为 <code>False</code>（这是默认值）, 当主应用程序线程终止时, 该线程将被终止。如果设置为 <code>True</code>, 只要这个线程在运行, 应用程序就会继续运行。正常情况下, 只有应用程序的主线程才有这个权限。</p>
</div>
<div class="paragraph">
<p>所有代码, 都在一个线程内运行。你的代码可以使用名为 <code>$*THREAD</code> 的动态变量访问它正在运行的线程。这对于调试时拉出 <code>.id</code>, 帮助了解一个任务此时正在哪个线程中运行是很有帮助的。</p>
</div>
<div class="paragraph">
<p>当你想暂停当前线程以等待另一个线程完成时, 你可以使用 <code>.finish</code> 方法（或者你可以使用 <code>.join</code>, 它是 <code>.finish</code> 的同义词）。</p>
</div>
<div class="paragraph">
<p>另一种运行线程的方法是使用 <code>.new</code> 和 <code>.run</code> 的组合。这与 <code>.start</code> 类似, 但代码必须作为命名参数传递给 <code>.new</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t2 = Thread.new:
    name =&gt; &#39;Another task&#39;,
    code =&gt; sub {
        loop {
            say &#39;stuff&#39;;
            sleep 1;
        }
    },
    ;

# The thread does not start until we...
$t2.run;

# And then we&#39;d better wait for it or we&#39;ll exit immediately
$t2.finish;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在大多数情况下, 我都会在降临日历中提到线程, 以此来描述代码在其中运行的“通道”。然而, 我会不时地使用 <code>$*THREAD.id</code> 来帮助说明代码确实在不同的线程中运行。否则, 我一般会直接忽略 Thread 对象。</p>
</div>
<div class="paragraph">
<p>几乎所有的 Raku 程序都应该坚持使用 <code>start</code> 块或 <code>Promise.start</code> 来启动在另一个线程上运行的任务。只有在真正需要的时候, 你才应该直接利用 <code>Thread</code>, 对于大多数 Raku 开发人员来说, 可能永远不会使用或接近 Thread。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/05/threads/" class="bare">https://zostay.com/posts/2019/12/05/threads/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_raku_调度器">57. Raku 调度器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 中, 大量的面向并发的编码都依赖于 <a href="https://docs.raku.org/type/Scheduler">Scheduler</a> 的使用。许多异步操作依赖于虚拟机在运行时创建的默认调度程序。你可以通过名为 <a href="https://docs.raku.org/language/variables#index-entry-$*SCHEDULER">$*SCHEDULER</a> 的动态变量来访问它。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/06/raku-schedulers/cover-curtis-macnewton-vVIwtmqsIuk-unsplash_hu802150c44c239c3f53b4fc234a8323d6_2735965_280x280_fill_q75_box_smart1.jpg" alt="Schedulers"/>
</div>
</div>
<div class="paragraph">
<p>调度程序(Scheduler)的最重要功能是 <code>.cue</code> 方法。使用代码引用调用该方法将安排工作(work)的执行。调度程序的类型将决定其具体含义。</p>
</div>
<div class="paragraph">
<p>也就是说，这是一个低级接口，你可能不应该在大多数代码中调用 <code>.cue</code>。最好的做法是依靠高级工具, 比如 <code>start</code>，并构造一个 Promise 供你监视工作(work)。</p>
</div>
<div class="paragraph">
<p>每个调度程序都提供了三种方法：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>.uncaught_handler</code> 是一个访问器，它返回一个例程，或者可以将其设置为例程，只要调度程序抛出异常, 而任务代码本身不对其进行处理，就会调用该例程。如果未提供处理程序，而提示任务抛出了异常，则应用程序将在这个异常上退出。如果你使用高级并发工具, 如 <code>start</code> 块，则将永远不会使用 <code>.uncaught_handler</code>，因为它们各自提供了自己的异常处理。</p>
</li>
<li>
<p><code>.cue</code> 方法用于将任务添加到调度中。调度程序将在资源允许的情况下执行该任务（取决于调度程序的操作方式）。</p>
</li>
<li>
<p><code>.loads</code> 方法返回一个整数，该整数表示调度程序当前的负载。这是对当前作业队列大小的指示。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>所以，你可以建立一个非常简单的调度程序，就像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class MyScheduler does Scheduler {
    method cue(&amp;code, Instant :$at, :$in, :$every, :$times = 1; :&amp;catch) {
        sleep $at - now if $at &amp;&amp; $at &gt; now;
        sleep $in if $in;

        for ^$times {
            code();
            CATCH {
                default {
                    if &amp;catch {
                        catch($_);
                    }
                    elsif self.uncaught_handler {
                        self.uncaught_handler.($_);
                    }
                    else {
                        .throw;
                    }
                }
            }
            sleep $every if $every;
        }

        class { method cancel() { } }
    }

    # We don&#39;t really queue jobs, so always return 0 for the load
    method loads(--&gt; 0) { }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这和 <code>CurrentThreadScheduler</code> 的功能有些类似。</p>
</div>
<div class="paragraph">
<p>Rakudo 内置了两个调度程序：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.raku.org/type/ThreadPoolScheduler">ThreadPoolScheduler</a> 就是通常默认的 <code>$*SCHEDULER</code>。当它被构造时，你可以设置它允许同时使用的线程数量。然后，它管理一个线程池，并将在这些线程上调度提示任务。随着任务的完成, 释放线程，下一个任务将被调度运行。任务可以和这个调度程序同时运行。当 <code>.cue</code> 返回时，任务可能尚未开始。返回对象的 <code>.cancel</code> 方法可用来请求取消某个任务的工作(work)。</p>
</li>
<li>
<p><a href="https://docs.raku.org/type/CurrentThreadScheduler">CurrentThreadScheduler</a> 是一个备用的调度程序。它基本上只是立即执行任务，并在任务完成后返回。返回的取消对象有一个 <code>.cancel</code> 方法，但是它是一个空操作，因为在调度程序返回时, 工作总是已经完成。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>许多异步方法，比如 <a href="https://docs.raku.org/type/Promise">Promise</a> 上的 <a href="https://docs.raku.org/type/Promise#method_start"><code>.start</code></a> 方法，会接收一个名为 <code>:scheduler</code> 的参数，你可以在其中传递一个自定义的调度程序。一般来说，你可以坚持使用默认的调度程序。对调度程序最常见的调整可能是改变线程池中的线程数，或者在某些情况下切换到使用当前的线程调度程序。你有可能不需要做这两件事。而且，而如果你需要一些奇特的东西，那么定义自己的调度程序也是合理的。需要考虑的事情。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/06/raku-schedulers/" class="bare">https://zostay.com/posts/2019/12/06/raku-schedulers/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_react_块">58. React 块</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 中的 <a href="https://docs.raku.org/language/concurrency#index-entry-react">react</a> 块是重新同步异步编码活动的主要手段。使用它,你可以轻松地将 <a href="https://docs.raku.org/type/Promise">promises</a>、<a href="https://docs.raku.org/type/Supply">supplies</a>和 <a href="https://docs.raku.org/type/Channel">channels</a> 组合在一起, 使你的程序或子系统成为一个连贯的整体。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/07/react-blocks/cover-alexander-schimmeck-X-RFSg_4EL4-unsplash_hu33a2585040fa0e46f598379fa8d3b2df_2559998_280x280_fill_q75_box_smart1.jpg" alt="react"/>
</div>
</div>
<div class="paragraph">
<p><code>react</code> 块本身可以运行任何你想要的代码, 再加上一个或多个 <code>whenever</code> 块。块中的代码会运行一次, 当 <code>done</code> 子例程被调用时, 或者当所有与 <code>whenever</code> 块相关联的对象完成时（即所有的承诺都被保留或破坏, 所有的供应已退出或关闭, 所有的通道已失败或关闭）, 块将退出。</p>
</div>
<div class="paragraph">
<p>除了语法之外, 关于 <code>react</code> 块, 需要注意的关键一点是, 块内的所有代码总是会像单线程一样运行(即, 可能会使用多线程, 但绝不会让这个块内的任何代码并发运行)。</p>
</div>
<div class="paragraph">
<p>我们来看一个 <code>react</code> 块的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $commands = Channel.new;
my $input = Supplier.new;
my $output = Supplier.new;
my $quit = Promise.new;
react {
    print &#39;&gt; &#39;;

    start loop { $input.emit: $*IN.getc }

    whenever $input.Supply.lines.map({ .trim }) {
        when /^add \s+ (\d+) \s+ (\d+)$/ { $commands.send: (&#39;add&#39;, +$0, +$1) }
        when /^sub \s+ (\d+) \s+ (\d+)$/ { $commands.send: (&#39;sub&#39;, +$0, +$1) }
        when &#39;quit&#39; | &#39;exit&#39; { $quit.keep }
        default { $output.emit: &#39;syntax error&#39; }
    }

    whenever $commands -&gt; @command {
        multi doit(&#39;add&#39;, Int $a, Int $b) { $a + $b }
        multi doit(&#39;sub&#39;, Int $a, Int $b) { $a - $b }

        $output.emit: doit(|@command);
    }

    whenever $output.Supply { .say; print &#39;&gt; &#39; }

    whenever $quit {
        say &#39;Quitting.&#39;;
        done;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序提供了一个小型的交互式 shell, 可以执行加法和减法运算。运行时, 你可以按以下方式使用它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; add 4 5
9
&gt; sub 10 7
3
&gt; exit
Quitting.</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见, 这段代码使用了几个 <code>Supply</code> 对象, 一个 <code>Channel</code> 和一个 <code>Promise</code> 来操作的。他们中的每一个都以预期的方式与 <code>whenever</code> 工作。<code>run</code> 块内的所有代码都像在单线程中运行一样（尽管并没有特别保证只使用单线程, 只是没有代码会并发运行）。</p>
</div>
<div class="paragraph">
<p>然而, 在这种情况下, 从单任务中运行而不并发确实存在一个问题。即使你使用 <code>.Supply</code> 方法来异步获取数据, <code>$*IN</code> 文件句柄也只执行阻塞读取。因此, 我们必须在后台线程中运行的任务中拉取输入, 这就是为什么我们在读取字符输入的循环之前放了一个 <code>start</code>。如果没有这个并发任务, 我们就必须多敲几次 Return 键, 以便其他 <code>whenever</code> 子句也有机会运行。</p>
</div>
<div class="paragraph">
<p>也就是说, 我们可以把其它的 <code>whenever</code> 块的工作移到单独的并发任务中, 然后把每个任务都拉到这个 <code>react</code> 块中, 这样就能很好地工作了。<code>react</code> 块的目标是用一种简单明了的语法来同步异步工作。我认为它的工作做得很好。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/07/react-blocks/" class="bare">https://zostay.com/posts/2019/12/07/react-blocks/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lock_类">59. Lock 类</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 中编写并发代码时, 我们要避免任务之间共享数据。这是因为不共享数据的代码是自动安全的, 并且不必担心与其他代码的相互依赖性。所以, 在可能的情况下, 你应该通过 <code>Supply</code>、<code>Promise</code> 和 <code>Channel</code> 对象来完成你的工作, 然后通过中央线程将它们同步在一起。这样, 所有状态变化都是安全的。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/08/the-lock-class/cover-maxim-zhgulev-5tmItJfHkIc-unsplash_hu604da152536f26176df092a26a53d8d0_371005_280x280_fill_q75_box_smart1.jpg" alt="Lock Class"/>
</div>
</div>
<div class="paragraph">
<p>不过, 这并不总是实用的。有时候, 在不同线程上运行的任务之间共享可以变化的数据确实更有效率。然而, 这样的共享本质上是不安全的。</p>
</div>
<div class="paragraph">
<p>例如, 这里有一个在 Raku 中非常简单的多线程应用程序, 它不是线程安全的, 会导致错误的结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 0;
my @p = (
    start for ^100 { $x++; sleep rand/10; },
    start for ^100 { $x++; sleep rand/10; },
);
await Promise.allof(@p);
say $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可能期望 <code>$x</code> 的值是 200, 但它不太可能是 200。它几乎可以肯定会更低。这是因为简单的 <code>$x++</code> 操作需要:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>读取 <code>$x</code> 的值。</p>
</li>
<li>
<p>在 <code>$x</code> 读取的值上加一。</p>
</li>
<li>
<p>将计算出的值存储回 <code>int $x</code>。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果碰巧第一个任务执行了步骤1和2, 然后第二个任务在第一个任务完成步骤3之前执行了步骤1到3, 那么至少有一个增量操作会丢失。在每个任务的 100 次迭代过程中, 我预计会有5到10次写入丢失, 并且每次运行都有可能给出稍微不同的答案。这就是在并发性方面不安全的含义。</p>
</div>
<div class="paragraph">
<p>对于这个特殊的程序, 上面的三个步骤构成了一个关键部分。关键部分是一段必须依次执行的代码, 如果它要完全正常工作的话。在 Raku 代码本身中, 关键部分只是每个循环中的 <code>$x++</code> 语句。</p>
</div>
<div class="paragraph">
<p>确保代码中的关键部分以线程安全的方式处理的一种机制是使用互斥锁。Raku 提供 <a href="https://docs.raku.org/type/Lock">Lock</a> 类, 可以用于这个目的。</p>
</div>
<div class="paragraph">
<p>当你创建一个 Lock 对象时, 你可以 <code>.lock</code> 或 <code>.unlock</code> 代码中的锁。如果任何其他代码在没有调用 <code>.unlock</code> 的情况下, 在同一个对象上调用了 <code>.lock</code>, 那么调用 <code>.lock</code> 方法将阻止你的代码继续运行。一旦持有锁的线程调用 <code>.unlock</code>, 另一个等待锁释放的线程将被允许继续运行。</p>
</div>
<div class="paragraph">
<p>在上面的示例中, 我们可以将其修改如下, 使之成为线程安全的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 0;
my $lock = Lock.new;
my @p = (
    start for ^100 { $lock.lock; $x++; $lock.unlock; sleep rand/10; },
    start for ^100 { $lock.protect: { $x++ }; sleep rand/10; }
);
await Promise.allof(@p);
say $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我没有提到 <code>.protect</code>, 但它的作用和调用 <code>.lock</code>, 运行给定的块, 然后运行 <code>.unlock</code> 相同。不过这样做的好处是, 如果块里面出现了问题, 它可以彻底的让 <code>.unlock</code> 调用发生。在上面我们使用 <code>.lock</code> 和 <code>.unlock</code> 的第一个循环中, 有可能因为抛出异常而导致锁被永久锁定。使用 <code>.protect</code> 可以自动避免这种风险, 所以它是使用 <code>Lock</code> 的首选方式。</p>
</div>
<div class="paragraph">
<p>在结束之前, 我想提一下锁的几个负面因素。首先, 锁的性能不是很好。它们易于实现且易于使用, 但是互斥会带来较高的性能成本。你可能希望确保少量使用锁, 并且仅将其用于保护关键部分。</p>
</div>
<div class="paragraph">
<p>另一个主要缺点是, 当使用锁时, 你可以获得线程安全, 但可能会增加死锁的风险。我已经提到了一个死锁风险:一个任务导致错误, 使一个锁无法被解锁。这个锁现在是死锁, 没有任务可以接管它。当涉及到多个锁时, 死锁的风险可能会更加微妙, 并且非常难以发现。与供应(Supply)或承诺(Promise)不同, 锁(Lock)是不能安全地组合的。这意味着两个使用锁来保护自身安全的库在一起使用时, 如果不小心, 可能会出现死锁。</p>
</div>
<div class="paragraph">
<p>尽管有这些缺点, 锁对于使代码线程安全是很有用的东西。在这个降临日历的后面, 我们将使用锁来演示如何创建线程安全的数据结构。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/08/the-lock-class/" class="bare">https://zostay.com/posts/2019/12/08/the-lock-class/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_atomic_integer">60. Atomic Integer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>什么比锁更快？比较和交换(CAS)。现代 CPU 有多个核心。因此, 所有的现代 CPU 都必须拥有执行绝对原子操作的工具, 以便让这些多核一起工作。这些操作的其中之一就是比较与交换(compare-and-swap) 或 <code>cas</code> 操作。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/09/atomic-integers/cover-heather-gill-Ub2JHFkIXWc-unsplash_hu361675a22350da2201213fc332ace117_4173099_280x280_fill_q75_box_smart1.jpg" alt="Atomic Integers"/>
</div>
</div>
<div class="paragraph">
<p>抽象地讲, cas 操作需要三个参数, 一个要修改的变量、一个给定的值和一个新的值。只有当变量所持有的当前值等于给定值时, 变量才会被设置为被修改后的新值。而这是以单次操作的方式进行的, 保证不受任何其他并发操作的干扰。在这一过程中, 系统会设置一个标志来标记操作的成功或失败。如果该变量的值与预期值不同, 则该变量保持不变, 操作失败。为了完成一个原子变化, 你重复运行一个计算, 并以 <code>cas</code> 操作结束, 直到操作成功为止。这听起来可能不是很有效率, 但事实证明, 在大多数情况下, 它比锁更快。</p>
</div>
<div class="paragraph">
<p>Raku 通过 <a href="https://docs.raku.org/type/atomicint">atomicint</a> 类型上的 <a href="https://docs.raku.org/type/atomicint#sub_cas">cas</a> 函数以及一些帮助你执行这些原子变化的操作符, 提供了对这种操作的直接访问。</p>
</div>
<div class="paragraph">
<p>为了演示 <code>atomicint</code> 的一个可能的用法, 让我们首先考虑一下 ATM 问题。有两个人有一个银行账户。假设在一天开始的时候, 这个账户里有 1000 美元。其中一个人在市中心的 ATM 机上取款 100 元, 另一个人在机场的 ATM 机上存款 250 元。在一天结束时, 我们显然希望新的余额是 1150 美元。但是, 如果这两笔交易同时发生, 那就不能保证了, 除非我们采取一些谨慎的措施来保证这一点。</p>
</div>
<div class="paragraph">
<p>让我们先用天真的方法写出我们的代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int $balance = 1000;
start { $balance = $balance - 100 } # one
start { $balance = $balance + 250 } # two
say $balance;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不幸的是, 现在可能会出现余额与 1150 美元不同的情况。这是因为如果这两个任务实际上同时运行, 它们执行的操作可能会像这样交错进行。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>块一读取 1000 美元的余额。</p>
</li>
<li>
<p>块二读取 1000 美元的余额。</p>
</li>
<li>
<p>块一从 1000 中减去 100, 得到 900。</p>
</li>
<li>
<p>块二从 1000 中加上 250, 得到 1250。</p>
</li>
<li>
<p>块一将余额设置为 900。</p>
</li>
<li>
<p>块二将余额设置为 1250。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>读和写操作必须按顺序执行, 这样代码才能正常工作。我们可以使用 <a href="https://docs.raku.org/type/Lock">lock</a> 或 <a href="https://docs.raku.org/type/Semaphore">semaphore</a> 或其他传统的构造来形成一个围绕着修改变量的关键部分, 但这些操作通常都很慢。</p>
</div>
<div class="paragraph">
<p>相反, 我们可以使用 <code>cas</code> 操作来依次执行操作。所以, 如果我们使用 <code>atomicint</code> 重写上面的代码, 我们最终会得到这样的结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my atomicint $balance = 1000;
start { $balance ⚛️= ⚛️$balance - 100 } # one
start { $balance ⚛️= ⚛️$balance + 250 } # two
say $balance;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的结果将始终是预期的 1150。让我们假设这两个任务和之前一样同时运行, 但最后的分配是一个比较和交换操作, 而不是一个常规的集。其结果会是这样的。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>块一读取 1000 美元的余额。</p>
</li>
<li>
<p>块二读取 1000 美元的余额。</p>
</li>
<li>
<p>块一从 1000 中减去 100, 得到 900。</p>
</li>
<li>
<p>块二在 1000 的基础上加 250, 得到 1250。</p>
</li>
<li>
<p>块一执行比较和交换 <code>$balance</code> 从 1000到900, 成功了。</p>
</li>
<li>
<p>块二执行比较和交换 <code>$balance</code> 从1000到1250, 失败了。</p>
</li>
<li>
<p>块二读取的 <code>$balance</code> 为900。</p>
</li>
<li>
<p>块二在 900 的基础上加上 250, 得到 1150。</p>
</li>
<li>
<p>块二执行比较和交换 <code>$balance</code> 从900到1150, 成功了。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>出现额外的步骤 7-9 是因为在 <code>cas</code> 操作中, 解决失败需要重复操作直到成功。除非对单个变量的写入争夺程度是极端的, 否则这不应该导致任何任务无限期地失败。</p>
</div>
<div class="paragraph">
<p>如果你不喜欢代码中的表情符号, 那也没关系。有一个 Texas 函数用于执行原子表情符操作符提供的每一个操作。<code>atomicint</code> 提供了以下操作:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>atomic-assign 或 ⚛️=</p>
</li>
<li>
<p>atomic-fetch 或 ⚛️ 前缀, 用于执行原子读取值</p>
</li>
<li>
<p>atomic-fetch-inc 或 ⚛️++ 后缀</p>
</li>
<li>
<p>atomic-fetch-dec 或 ⚛️– 后缀</p>
</li>
<li>
<p>atomic-fetch-add 或 ⚛️+=</p>
</li>
<li>
<p>atomic-fetch-sub 或 ⚛️-=</p>
</li>
<li>
<p>atomic-inc-fetch 或 ++⚛️ 前缀</p>
</li>
<li>
<p>atomic-dec-fetch 或 –⚛️ 前缀</p>
</li>
<li>
<p>cas</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们快速考虑一下 <code>cas</code> 函数本身, 它是实现其他运算符的基础。这个操作允许你实现任何涉及 <code>atomicint</code> 比较和交换的操作。它有两种基本形式, 为了演示它们是如何工作的, 我们可以使用这两种形式重新实现上面的 ATM 问题。</p>
</div>
<div class="paragraph">
<p>首先, 考虑一下这个使用 <code>cas</code> 函数的程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my atomicinc $balance = 1000;
sub update-balance($change-by) {
    my $new-balance;
    loop {
        my $old-balance = $balance;
        $new-balance = $balance + $change-by;
        if cas($balance, $old-balance, $new-balance) == $old-balence {
            last;
        }
    }
    return $new-balance;
}
start update-balance(-100); # one
start update-balance(250);  # two
say $balance;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这在功能上是相同的, 虽然比上面的操作更啰嗦。这基本上是让你直接访问 <code>cas</code> 操作本身, 并让你控制重试的次数和执行的具体操作。这个功能的工作原理是这样的, 不过整个操作是原子式的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub cas(atomicint $target is rw, int $expected-value, int $new-value --&gt; int) {
    my int $seen = $target;
    if $seen == $expected-value {
        $target = $new-value;
    }
    return $seen;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着它将在每个情况下都返回它所看到的值, 但当它看到的值与你所预期的值一致时, 它将改变存储在目标中的值。</p>
</div>
<div class="paragraph">
<p>这个方法还有第二个版本, 它可以帮助简化你的代码, 为你执行循环。如果要再写一次 ATM 问题, 我们也可以这样写。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my atomicint $balance = 1000;
sub update-balance($change-by) {
    cas $balance, -&gt; $seen-value { $seen-value + $change-by }
}
start update-balance(-100); # one
start update-balance(250);  # two
say $balance;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这大大缩短了实现这个操作所需的代码。它通过在循环中反复执行给定的操作, 直到 <code>cas</code> 操作成功。在这种情况下, <code>cas</code> 函数是这样定义的, 但同样是在适当的地方使用原子操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub cas(atomicint $target is rw, &amp;operation) {
    loop {
        my int $seen = $target;
        my $new-value = operation($seen);
        if $seen == $target { # still equal?
            $target = $new-value;
        }
        return $new-value;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, <code>cas</code> 子程序的另一种选择是接受一个函数, 返回被设置的新值, 而接受两个整数的 <code>cas</code> 则返回被看到的值。也就是说, 这种第二种且紧凑的形式将返回值像赋值操作一样处理, 但另一种形式的工作方式不允许这样处理。</p>
</div>
<div class="paragraph">
<p>我真的很想和大家分享如何在 Raku 中的任何标量值上使用 <code>cas</code>, 但这篇文章已经很长了。我将在这个降临节稍后介绍。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/09/atomic-integers/" class="bare">https://zostay.com/posts/2019/12/09/atomic-integers/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_分而治之模式">61. 分而治之模式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>现在我们来考虑一下如何解决并发性的一个大问题。如果你有一个需要处理大量数据的算法问题, 你想最大限度地提高可用 CPU 核心的负载, 以尽快处理这些数据。为了演示我们如何在 Raku 中实现这一点, 我们将考虑康威的《生命游戏》, 在一个有效的无限棋盘上进行。<sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup></p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/10/the-divide-and-conquer-pattern/cover-seth-cottle-eeoXwem688U-unsplash_hu578561e015dcc2299a521a0877cc4e7f_3472343_280x280_fill_q75_box_smart1.jpg" alt="The Divide and Conquer Pattern"/>
</div>
</div>
<div class="paragraph">
<p>让我们从定义康威的《生命游戏》开始, 以防你之前没有接触过它。生命游戏是英国数学家约翰-康威发明的一种模拟游戏。它是在一个简单的网格上进行的, 每个方格被称为一个细胞。在一个给定的回合中, 每个细胞可能要么是活的, 要么是死的。每个细胞有 8 个邻居, 分别是上、下、左、右和 4 条对角线上的细胞。为了确定一个细胞在下一个回合的状态, 你使用当前细胞的状态和它的邻居从当前回合使用这些规则执行以下检查。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>任何有少于两个邻居的活细胞都会死亡。</p>
</li>
<li>
<p>任何有两个或三个邻居的活细胞继续生存。</p>
</li>
<li>
<p>任何有三个以上邻居的活细胞都会死亡。</p>
</li>
<li>
<p>任何有三个邻居的死细胞复活。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果你想了解更多的细节, 你应该看看维基百科上关于<a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">康威的《生命的游戏》</a>的文章。</p>
</div>
<div class="paragraph">
<p>我已经在一个漂亮的长程序中实现了康威的《生命游戏》, 并有图形（或文本）输出和所有的内容。然而, 它大约有 400 行代码, 所以我不打算在这里包含所有的代码。你可以在我的 <a href="https://github.com/zostay/raku-Game-Life">github</a> 上查看这个项目的持续发展。</p>
</div>
<div class="paragraph">
<p>模拟器有一个名为 <code>Game::Life::Player</code> 的角色, 它定义了对玩家对象的要求。这个对象负责执行游戏规则。具体来说, <code>.next-turn-for</code> 方法被赋予了一个当前棋盘的不可变的副本, 一组边界, 和一个可改变的下一个棋盘的副本来写入。它负责根据刚才提到的规则将当前棋盘变成下一回合的棋盘。</p>
</div>
<div class="paragraph">
<p>下面是 <code>Game::Life::Player::Basic</code> 实现中的一个副本, 这基本上是最简单的方法了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Game::Life::Player {
    ...
    method next-turn-for-cell(
        Int:D $x,
        Int:D $y,
        Board:D $current,
        Board:D $next,
    ) {
        # Is the cell currently live?
        my $live      = $current.cell($x, $y);

        # How many live neighbors does it currently have?
        my $neighbors = [+] $current.neighbors($x, $y);

        # If alive and has too many or too few neighbors, die.
        if $live &amp;&amp; !(2 &lt;= $neighbors &lt;= 3) {
            return $next.kill($x, $y);
        }

        # if dead and has the right number of neighbors, come to life.
        elsif !$live &amp;&amp; $neighbors == 3 {
            return $next.raise($x, $y);
        }

        else {
            return Nil;
        }
    }
}

class Game::Life::Player::Basic does Game::Life::Player {
    ...
    method next-turn-for(
        Int:D $l,
        Int:D $t,
        Int:D $r,
        Int:D $b,
        Board:D $current,
        Board:D $next,
    ) {
        for $l..$r -&gt; $x {
            for $t..$b -&gt; $y {
                self.next-turn-for-cell($x, $y, $current, $next);
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>实现方法是简单地迭代边界内的每个细胞, 并在其上运行 <code>.next-turn-for-cell</code>。这个方法是在 <code>.role</code> 中实现的, 只是实现了适用于单个细胞的规则。很简单。<sup class="footnote">[<a id="_footnoteref_7" class="footnote" href="#_footnotedef_7" title="View footnote.">7</a>]</sup></p>
</div>
<div class="paragraph">
<p>即使是对于相对较小的游戏场, 单块迭代也会花费很长的时间。为了改善这种情况, 我们可以将工作划分成合理大小的块, 并在一个单独的任务中处理每个块。在多线程的情况下, 我们应该可以将做工作所需的时间缩短到 N 的倍数, 其中 N 是可用于计算的核心数。在现实中, 你得到的时间会比这少一些, 但我们应该绝对能够通过这种方式提高速度。</p>
</div>
<div class="paragraph">
<p>我们可能怎么做呢？这里有一个可能的解决方案, 确保我们永远不会处理大于 20 乘 20 的块, 使得连续进行大约 400 次计算。获得最大的效率需要一些调整, 所以一个给定的系统可能会用不同的数字做得更好, 但你懂的。</p>
</div>
<div class="paragraph">
<p>这里有一个 <code>parallel-next-turn-for</code> 的实现, 是 <code>Game::Life::Player::DivideAndConquer</code> 玩家类的一部分。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Game::Life::Player::DivideAndConquer is Game::Life::Player::Basic {
    ...
    method parallel-next-turn-for(
        Int:D $l,
        Int:D $t,
        Int:D $r,
        Int:D $b,
        Board:D $current,
        Board:D $next,
    ) {
        my @jobs = gather {
            if $r - $l &gt; 20 {
                my $m = ceiling($l + ($r - $l)/2);
                #dd $l, $m, $r;

                take start self.parallel-next-turn-for($l, $t, $m - 1, $b, $current, $next);
                take start self.parallel-next-turn-for($m, $t, $r, $b, $current, $next);
            }

            elsif $b - $t &gt; 20 {
                my $m = ceiling($t + ($b - $t)/2);
                #dd $t, $m, $b;

                take start self.parallel-next-turn-for($l, $t, $r, $m - 1, $current, $next);
                take start self.parallel-next-turn-for($l, $m, $r, $b, $current, $next);
            }

            else {
                take start self.next-turn-for($l, $t, $r, $b, $current, $next);
            }
        }

        await Promise.allof(@jobs);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这与之前的输入相同, 但如果列数太多, 无法处理, 我们就按列数将工作减半。如果列是合理的, 但行数太多, 我们就把工作按行数减半。如果大小刚刚好, 我们就使用我们从 <code>Game::Life::Player::Basic</code> 继承的 <code>next-turn-for</code>。</p>
</div>
<div class="paragraph">
<p>无论我们是分成两个任务, 还是只做某一部分细胞的工作, 我们都会使用 <code>start</code> 块来调度工作, 然后等待结果。这样方式的细分意味着我们创建了一个任务的层次结构, 可以再细分, 再细分。然后, Raku 调度器会在线程可用时调度任务运行。</p>
</div>
<div class="paragraph">
<p>在我的 2015 年的 Macbook Pro 上, 游戏在顺序运行时, 使用 100% 的 CPU, 在 35 秒左右的时间内跑完 200 个回合的 Gosper 滑翔机枪。同样的程序在并行运行时, 使用接近 300% 的 CPU 运行约 20-25 秒。如果不是我的渲染任务偶尔也要用 CPU 重绘图形窗口, 可能会更高。但那又有什么乐趣呢？</p>
</div>
<div class="paragraph">
<p>所以, 这就是当你有多个核心可用时可以采用的并发模式, 而且算法适合被拆分成几个部分。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/10/the-divide-and-conquer-pattern/" class="bare">https://zostay.com/posts/2019/12/10/the-divide-and-conquer-pattern/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_并行的_map_reduce_模式">62. 并行的 Map-Reduce 模式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在函数式编程中, Map-reduce 是一种常见的解决问题的方法。你有一个列表项,你要对这些项进行迭代处理,然后你把这个集合进行汇总。我们之所以称之为map-reduce,是因为迭代步骤是将值映射成新的值,而汇总步骤是减少值的数量。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/11/parallel-map-reduce-pattern/cover-sebastien-le-derout-xc4C8j4Bnqc-unsplash_hu098ba572eac2d273a9acf7b37e313970_2405230_280x280_fill_q75_box_smart1.jpg" alt="map-reduce"/>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中,map-reduce 是一种常见的编程模式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fibonacci = (1, 1, * + * ... *);
my $double-sum = $fibonacci[^100].grep(*.is-prime).map(* * 2).reduce(* + *);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就用序列运算符创建了一个 <a href="https://docs.raku.org/type/Seq">Seq</a>。这就是经典的斐波那契序列。然后我们取 Fibonacci 的前 100 个元素,过滤掉任何非质数,将质数加倍,然后将数值相加。</p>
</div>
<div class="paragraph">
<p>这是一个奇怪的操作,但展示了你会用 map-reduce 模式执行的任务。我们取一个数据序列(本例中是斐波那契序列的前 100 个元素), 我们对数据进行过滤,只保留质数,将其值加倍,然后将其相加,得到最终的和。</p>
</div>
<div class="paragraph">
<p>在这种情况下,答案并不难计算,而且可能是瞬时的,但如果我们需要对前 4000 个数字进行这种操作呢？在今天的典型系统中,这很可能需要几秒钟的时间。由于 <code>.grep</code> 和 <code>.map</code> 必须对每个值进行迭代过滤和转换,所以我们没有特别的理由必须对每个值依次进行这些操作。<sup class="footnote">[<a id="_footnoteref_8" class="footnote" href="#_footnotedef_8" title="View footnote.">8</a>]</sup></p>
</div>
<div class="paragraph">
<p>Raku 提供的工具可以让你以不同的方式并行化这个任务,只需做一点小小的改变。考虑一下这个变化。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fibonacci = (1, 1, * + * ... *);
my $double-sum = $fibonacci[^100].race.grep(*.is-prime).map(* * 2).reduce(* + *);</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过在开头插入 <code>.race</code>,我们告诉 Raku 以并行方式执行操作。它将把任务分成几个部分,在不同的任务中运行这些部分,这些任务将被调度到不同的线程上。在我的系统中,该操作的运行速度比第一个快2到3倍。</p>
</div>
<div class="paragraph">
<p>Raku 提供了几种不同的策略来并行化 map-reduce 任务。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.raku.org/type/Iterable#method_race">.race</a> 方法将操作打散, 以并发处理的批次来执行工作。但它并不能保证原始项的顺序得到保留。这些项只是在线程完成后返回。</p>
</li>
<li>
<p><a href="https://docs.raku.org/type/Iterable#method_hyper">.hyper</a> 方法与 <code>.race</code> 方法非常相似,但它能保证原始列表中的项的顺序得到保留。这意味着,如果列表中较早的部分耗时较长,那么对列表后面部分的处理将被耽搁。它的效率不高,但如果你需要保留顺序,<code>.hyper</code> 会保证保留顺序。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些操作中的每一个都会接收一个 <code>:batch</code> 和 <code>:degree</code> 参数,以备你想自定义工作的分解和执行方式。Raku 试图选择合理的默认值,但是当你需要获得更好的性能时,为你的特定设置调整这些参数可能会带来一些改进。</p>
</div>
<div class="paragraph">
<p><code>:degree</code> 选项选择要启动多少个 worker。对于 CPU 绑定的工作,一般来说,最好选择一个与可用的 CPU 核数相等的数字。没有理由选择更高的数值,因为在这种情况下,你永远不会同时运行超过那么多的工作。但是,如果工作涉及到在磁盘或网络上的等待,你的代码很可能会暂停几毫秒或更长时间等待 IO。在这些情况下,明智的做法是将 <code>:degree</code> 增加到数倍于 CPU 的数量,以考虑到等待时间。</p>
</div>
<div class="paragraph">
<p><code>:batch</code> 选项决定如何分解工作。当要做的工作速度很快时,一个大数字是有用的。这将使你的吞吐量保持在较高的水平。当工作时间较长或你想尽快得到每个结果时,一个小的数字,甚至是1,都是合理的。</p>
</div>
<div class="paragraph">
<p>所以,考虑到这一点,我们可以这样进一步调整上面的工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fibonacci = (1, 1, * + * ... *);
my $double-sum = $fibonacci[^4000].race(:batch(1000), :4degree).grep(*.is-prime).map(* * 2).reduce(* + *);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,调优在我的 4 核笔记本上并没有太大的区别,但是当你的系统上有超过 4 个核心的时候,调优很可能会有一些帮助。</p>
</div>
<div class="paragraph">
<p>所以,任何时候,当你有一个任务需要对项进行迭代和操作的时候,如果你有足够的 CPU 时间来加快它们的速度,可以考虑在你的代码中使用 <code>.hyper</code> 或 <code>.race</code>。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/11/parallel-map-reduce-pattern/" class="bare">https://zostay.com/posts/2019/12/11/parallel-map-reduce-pattern/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_保留你的线程或不保留">63. 保留你的线程或不保留</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 中, 有不同的方法来暂停你的代码。最简单也是最明显的方法是使用 <a href="https://docs.raku.org/type/Date#sub_sleep">sleep</a>:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/12/keep-your-thread-or-dont/cover-artem-beliaikin-49mCO5ZRQDk-unsplash_hu727ba057d1e2b0b7df933b7d62380299_4093734_280x280_fill_q75_box_smart1.jpg" alt="Thread"/>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $before = now;
sleep 1;
my $after = now - $before;
say $after;</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设你的系统目前没有被拖累, <code>$after</code> 的输出应该是一个非常接近 1 的数字。不是很刺激:你这一秒钟什么都没做。呜呜。呜呜。</p>
</div>
<div class="paragraph">
<p>然而, 在实际代码中, 你有时确实需要暂停一下。比如说, 你可能正试图发送一封邮件, 结果失败了。在发送邮件时, 如果它能快速到达是很好的, 但最终还是要达。因此, 在排队发送邮件的时候, 你要观察是否有错误。当它们发生时, 你要在放弃之前继续尝试很长时间。然而, 你不希望不断地尝试。你需要在重试之间暂停一下。</p>
</div>
<div class="paragraph">
<p>如果我在内存中构建一个天真的实现（而不是一个更合理的磁盘队列）, 我可以这样做。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">start {
    my $retries = 10;
    my $success;
    for ^10 -&gt; $retry {
        $success = sendmail();

        last if $success;

        sleep 60 * 2 ** $retry;
    }

    die &#34;Never could send that email.&#34; unless $success;

    $success;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这段代码中, 你有一个 <code>sendmail</code> 函数, 你认为它可以正确地发送一封邮件。你将尝试发送 10 次。你检查是否成功, 然后你使用一个指数级延长的时间间隔休眠, 在接下来的 18 个小时里, 你会把重试的时间分散开来。在这之后, 你会放弃。为了避免在长达 18 小时内阻断正常工作的进程, 你在 <code>start</code> 块中运行了整个过程。每当发送邮件时, 返回的 <a href="https://docs.raku.org/type/Promise">Promise</a> 都会被保留, 如果邮件失败, 则会被破坏(broken)。</p>
</div>
<div class="paragraph">
<p>不过, 有一个问题。这段代码将一个线程阻塞长达 18 小时。而线程是一种非常有限的资源。默认的线程池里最多有 64 个线程。这可不是什么好事。这意味着我们的进程仍然可以工作, 但这个线程被锁住了, 做了一大堆的事情。线程是昂贵的资源, 这样一来, 线程的使用成本会很高。如果你每 15 分钟要发一次以上的邮件, 你就会用完线程。</p>
</div>
<div class="paragraph">
<p>如何解决这个问题呢？你可以重新配置 Raku, 使用资源池中的线程更多的调度器, 但线程的目标是做事情。你为什么要浪费一个线程什么都不做, 除非你真的没有工作让他们做。</p>
</div>
<div class="paragraph">
<p>你可以用一种方式来解决这个问题, 释放你的线程继续工作, 并暂停任务。<code>await</code> 语句是让你的代码告诉 Raku, &#34;如果你需要的话, 你可以把我的线程收回来。&#34; 所以我们把上面的代码改成这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">start {
    my $retries = 10;
    my $success;
    for ^10 -&gt; $retry {
        $success = sendmail();

        last if $success;

        await Promise.in(60 * 2 ** $retry);
    }

    die &#34;Never could send that email.&#34; unless $success;

    $success;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在代码会在规定的时间内进入休眠状态, 但线程被释放出来供 Raku 重用, 这意味着你的应用程序不会在下一次需要同时给 65 个人发垃圾邮件的时候, 在邮件服务器瘫痪的情况下等待 18 个小时。</p>
</div>
<div class="paragraph">
<p>这在一般情况下都是正确的, 而不仅仅是为了暂停休眠。任何时候, 只要你使用了 <code>await</code>（只要你的 Raku 的版本支持规格 6.d 或更高的版本）, 你的 Raku 将能够重用该线程, 如果被等待的东西还没有准备好。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/12/keep-your-thread-or-dont/" class="bare">https://zostay.com/posts/2019/12/12/keep-your-thread-or-dont/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_监控模式">64. 监控模式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>今天我想讨论一下使用锁来使对象线程安全。也就是说, 通过采用一个简单的模式来锁定对对象的访问, 可以有效地保证每次只有一个线程可以访问对象的任何部分。因此, 这就保证了对象的状态永远不会被破坏, 即使是在多个线程试图并发访问对象的的时候。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/13/the-monitor-pattern/cover-akshay-chauhan-vQObm74PB_c-unsplash_hua5cbd351e325c4223f7a0bc7ff5ed716_1567586_280x280_fill_q75_box_smart1.jpg" alt="The Monitor Pattern"/>
</div>
</div>
<div class="sect2">
<h3 id="_面向对象设计">64.1. 面向对象设计</h3>
<div class="paragraph">
<p>在讨论共享的、可变对象的并发性之前, 我们先来考虑一下是什么才是设计良好的一般对象。在面向对象设计中, 一个新手的错误是把对象看作是信息的容器。当这样设计时, 对象会根据它们所包含的数据进行映射, 并且通过一系列的 getter 和 setter 来暴露这些数据是很有诱惑力的。然而, 一个设计良好的对象将包含状态作为封装功能的一种手段, 而这些功能需要该状态来操作。它通过允许其他对象通过方法向它发送消息来执行那些可能更新内部状态的操作来实现这一点。</p>
</div>
<div class="paragraph">
<p>举个拗口的例子, 如果我们要构建一个只有 <code>push</code> 操作的链表, 我们可以构建一个这样的简单列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class LinkedListRaw {
    has $.data;
    has $.next is rw;
}

my $list = LinkedListRaw.new(data =&gt; 1);
$list.next = LinkedListRaw.new(data =&gt; 2);
$list.next.next = LinedListRaw.new(data =&gt; 3);</code></pre>
</div>
</div>
<div class="paragraph">
<p>而一个更好的设计应该是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class LinkedList {
    has $.data;
    has $!next;

    method !tail() {
        my $here = self;
        loop { return $here without $here.next; $here = $here.next }
    }

    method push($data) {
        self!tail.next = LinkedList.new(:$data);
    }
}

my $list = LinkedList.new(data =&gt; 1);
$list.push: 2;
$list.push: 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 我之所以花点时间提到良好的面向对象设计实践, 是因为我们现在要考虑的监控器模式依赖于设计良好的对象才有效。(我之所以提到这一点, 也是因为不良的面向对象设计实践甚至在原本优秀的工程师中也很普遍)。</p>
</div>
</div>
<div class="sect2">
<h3 id="_监控monitors">64.2. 监控(Monitors)</h3>
<div class="paragraph">
<p>当你有一个无状态的系统, 或者是一个系统的状态是基于转换不可变对象的系统时, 并发是最容易的。例如, 如果你只需要将计算结果从一个线程传递到另一个线程, 那么每个阶段都很容易地保留当前值的副本, 转换该值, 并将新的副本传递给下一个阶段。</p>
</div>
<div class="paragraph">
<p>然而, 有状态对象可能会带来挑战, 因为当另一个线程开始对对象进行新的操作时, 对对象状态的改变可能只在一个线程中被部分应用。如果我们不保护我们的对象一次执行多个状态变化, 或者在状态变化只完成一部分时, 不保护我们的对象被读取, 那么我们的代码就不会是线程安全的。你不应该从多个线程同时使用这样的对象。(大多数内置的 Raku 对象就是这样的对象！)</p>
</div>
<div class="paragraph">
<p>如果你处于复制对象状态不切实际的情况下, 你需要在线程之间共享状态, 一个非常简单的解决方案是使用监控模式(monitor pattern)。下面是我们在使用监控模式之前的一个线程安全版本的只推链表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class LinkedListSafe {
    has $.data;
    has $!next;
    has Lock $!lock .= new;

    method !tail() {
        my $here = self;
        loop { return $here without $here.next; $here = $here.next }
    }

    method push($data) {
        $!lock.protect: {
            self!tail.next = LinkiedListSafe.new(:$data);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>就是这样。这就是整个监控模式, 只是使用一个 Lock 来保护每个公共方法的所有c代码, 这些方法从对象的可变状态中读取或写入。虽然这很简单, 但采用这种模式也有几个缺点。</p>
</div>
<div class="paragraph">
<p>如果对状态变化的争夺很大, 这通常是一个低性能的解决方案。例如, 如果很多线程会频繁地对这个链表进行多次 <code>push</code>, 那么性能就不会很好。</p>
</div>
<div class="paragraph">
<p>在每个部分的周围添加 <code>$!lock.protect.protect: { …​ }</code>, 做起来很繁琐, 而且在开发过程中容易忘记。</p>
</div>
<div class="paragraph">
<p>为了改善第一种情况, 请确保你的监控器只包含与封装对象状态相关的代码。创建非监控器的次要对象, 这些对象不是任何计算和动作的监控器, 也不是任何其他无状态工作的监控器。</p>
</div>
<div class="paragraph">
<p>对于第二种情况, 我推荐使用 Jonathan Worthington 的一个模块。他写了一个工具来自动实现监控器模式。如果你安装了 <a href="https://github.com/jnthn/oo-monitors">OO::Monitors</a>, 你可以把上面的链表改写成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use OO::Monitors;

monitor LinkedListMonitor {
    has $.data;
    has $!next;

    method !tail() {
        my $here = self;
        loop { return $here without $here.next; $here = $here.next }
    }

    method push($data) {
        self!tail.next = LinkiedListSafe.new(:$data);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>monitor</code> 是一个实现监控模式的类(<code>class</code>)。每个方法都会自动为你加锁保护。</p>
</div>
<div class="paragraph">
<p>如果你需要使一个有状态的对象线程安全, 并且你希望有一个简单的机制来实现, 那么这是一个合理的模式。不过如果性能是首要考虑的问题, 那么监控对象可能不适合你。最后, 要知道, 这种模式完全依赖于深思熟虑的 <strong>OO</strong> 设计来工作。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/13/the-monitor-pattern/">https://zostay.com/posts/2019/12/13/the-monitor-pattern/</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_比较并交换标量">65. 比较并交换标量</h2>
<div class="sectionbody">
<div class="paragraph">
<p>之前, 我讨论了比较和交换操作, 作为对 <a href="https://docs.raku.org/type/atomicint">atomicint</a> 变量进行的操作。这只是冰山一角。虽然大多数原子表情符号 ⚛️ 运算符只适用于 <code>atomicints</code>, 但 <code>cas</code> 函数、<code>atomic-fetch</code>(或前缀 ⚛️ 运算符)和 <code>atomic-assign</code>(或 ⚛️= 运算符)都可以用于任何一种 <a href="https://docs.raku.org/type/Scalar">Scalar</a> 变量。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/14/compare-and-swap-your-scalars/cover-ryan-hafey-i5n6WHtvQ4c-unsplash_hu99555bcdeb04e0e215e55c02c705a2b4_2576715_280x280_fill_q75_box_smart1.jpg" alt="Compare-and-swap Your Scalars"/>
</div>
</div>
<div class="paragraph">
<p>首先, 我们需要确定我们知道什么是 Scalar。在 Raku 中, 每个变量名都与一个容器相关联。如果你想知道它是如何工作的, 我推荐你阅读关于<a href="https://docs.raku.org/language/containers">容器</a>的语言文档。对于我们的目的来说, 只要说几乎所有以 <code>$</code> 魔符开头的常规变量都被一个  Scalar 所包含就足够了。如果你做了一些特殊的事情来初始化这样的变量, 那么它可能没有 Scalar 容器。</p>
</div>
<div class="paragraph">
<p>这里有一个快速的例子, 应该足够说明我们的目的了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Any typical $ sigil variable represents a Scalar container
my $value = 42;

# Each index of an array is normally a Scalar container
my @array;
@array[0] = 10;

# Binding directly to Int, so this is NOT a Scalar.
my $constant := 100; # NOT Scalar

# Binding direclty on an array index is also NOT a Scalar.
@array[1] := 20; # NOT Scalar

# Proxy containers are NOT Scalar containers
my $special := Proxy.new(
    FETCH =&gt; method () { 10 }
    STORE =&gt; method ($v) { 10 }
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你试图在非 Scalar 容器上使用 <a href="https://docs.raku.org/type/Scalar#sub_cas">cas</a>, Raku 会抛出一个类似于&#34;Proxy 容器不知道如何进行原子比较和交换&#34;的异常, 所以在大多数情况下, 出错的位置应该很明显。</p>
</div>
<div class="paragraph">
<p>够了。如何使用它呢？让我们试着举个例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $atomic-string = &#39;&#39;;
start {
    loop {
        cas $atomic-string, -&gt; $v {
            if $v.ends-with(&#39;A&#39;) { &#34;$vB&#34; }
            else { $v }
        }
        sleep rand;
    }
}
start {
    loop {
        cas $atomic-string, -&gt; $v {
            if $v eq &#39;&#39; || $v.ends-with(&#39;B&#39;) { &#34;$vA&#34; }
            else { $v }
        }
        sleep rand;
    }
}
start {
    loop {
        given ⚛️$atomic-string {
            if .ends-with(&#39;B&#39;) &amp;&amp; .chars %% 10 { .say }
        }
        sleep rand;
    }
}

sleep 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是个没什么用的程序, 但它展示了你可以做的事情。我们只有一个常规变量, 存储一个空字符串来开始。然后我们有三个任务同时运行。第一个任务使用 <code>cas</code> 操作查看字符串是否以 &#34;A&#34; 结尾, 如果是, 则添加一个 &#34;B&#34;。第二个任务使用 <code>cas</code> 操作查看字符串是否为空或以 &#34;B&#34; 结尾, 如果是, 则添加 &#34;A&#34;。第三种操作只有在字符串以 &#34;B&#34; 结尾并且长度是 10 的倍数时才会输出。它运行 10 秒后退出。这是一个效率很低的程序, 在我的笔记本上运行一次, 输出的结果是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">ABABABABAB
ABABABABAB
ABABABABAB
ABABABABABABABABABAB
ABABABABABABABABABABABABABABAB</code></pre>
</div>
</div>
<div class="paragraph">
<p>本质上, 每个 Scalar 内部都可以访问一个 atomicint, 它是用来在改变时锁定标量的。这些可以比使用 Lock 对象更有效率。当对某些数据的访问竞争很激烈时, <code>cas</code> 很可能会输, 因为每个试图处理数据的线程都会忙于等待。然而, 当对该项的争夺较低, 而且你不需要高效地阻塞和恢复线程时, <code>cas</code> 操作可以更高效。这可能需要对每种方法进行一些 AB 测试, 以确定哪种方法对你的特定情况最有效。</p>
</div>
<div class="paragraph">
<p>这个月晚些时候, 我计划更详细地演示一下如何使用这种 <code>cas</code> 操作来实现无锁的数据结构。所以我们很快就会再次回到这个话题。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/14/compare-and-swap-your-scalars/" class="bare">https://zostay.com/posts/2019/12/14/compare-and-swap-your-scalars/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_拆解异步问题">66. 拆解异步问题</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在编写异步代码时, 我经常面临的一个挑战就是想办法把问题合理的分解。我应该把代码分解到什么程度？我到底要走多少步？我如何处理分支或分叉的任务？我如何处理我所创建的相互依赖关系？我在这篇文章中希望给出一些我所学到的准则和一些工具来回答这些问题。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/15/breaking-down-async-problems/cover-kazuky-akayashi-uZS1IHEqfxU-unsplash_hu3077ccc5ff33dca4029a7fecb4c6b155_4432907_280x280_fill_q75_box_smart1.jpg" alt="Breaking Down Async Problems"/>
</div>
</div>
<div class="paragraph">
<p>这篇降临日历的文章将集中在异步问题上。在日历的后面, 我再来考虑同样的问题, 重点是并发问题。</p>
</div>
<div class="sect2">
<h3 id="_异步问题的特殊性">66.1. 异步问题的特殊性</h3>
<div class="paragraph">
<p>这个问题与更多传统的编程问题相比, 性质不同, 但实际实质并无不同。就像你在编写软件时, 需要用函数、方法和子程序将软件分解成几块一样, 你在处理异步问题时也大体如此。</p>
</div>
<div class="paragraph">
<p>那么, 是什么特殊的&#34;特征&#34;让这些异步问题与众不同。那么, 是什么让异步程序成为异步的呢？就是调用和结果之间的分离。你发起工作, 只要有两个因素为真, 你处理结果的代码就会工作。</p>
</div>
<div class="paragraph">
<p>你准备好了处理工作, 并且结果是可用的。因此, 异步问题的特殊性在于, 你要以这样的方式来工作, 以确保这两个条件尽可能多地为真, 从而使你的代码在结果准备好处理的那一刻, 就可以处理处理结果的工作。</p>
</div>
<div class="paragraph">
<p>这是你在看分解异步问题时唯一需要特别考虑的地方。否则, 你的编程问题都是典型的编程问题。说到这里, 现在让我们考虑一下 Raku 中各种类型的异步编码方法的一些实际考虑。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_react_块">66.2. 使用 react 块</h3>
<div class="paragraph">
<p>我的第一条实用建议是, 每当你需要将你的工作聚集在一起时, 总是使用 <a href="https://docs.raku.org/language/concurrency#index-entry-react">react</a> 块。<code>react</code> 块是协调多个异步进程一起工作的完美场所。</p>
</div>
<div class="paragraph">
<p>举个例子, 我使用 Raku 程序来静态地渲染这个网站。我为此开发的工具有一个名为 <code>build-loop</code> 的模式, 它监视文件的变化, 并在这些变化发生时重建网站。在生产中, 它监控一个套接字, 每当同步工具检测到主 <code>git repo</code> 有变化时, 它就会被 ping。在开发中, 它使用 <a href="https://docs.raku.org/type/IO::Notification">IO::Notification</a> 来监视磁盘上的变化, 并且还运行一个微型 Web 服务器, 这样我就可以以模拟部署系统的方式来服务这些文件。</p>
</div>
<div class="paragraph">
<p>它有一个主 <code>react</code> 块, 看起来是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    my $needs-rebuild = True;
    with $notify-port {
        whenever IO::Socket::Async.listen(&#39;127.0.0.1&#39;, $notify-port) -&gt; $conn {
            # manage a connection to set $needs-rebuild on ping
        }
    }

    with $server-port {
        whenever IO::Socket::Async.listen(&#39;127.0.0.1&#39;, $server-port) -&gt; $conn {
            # micro-web server for developer mode here
        }
    }

    whenever Supply.interval($interval, :$delay) {
        if $needs-rebuild {
            $needs-trigger--;
            build-site();
        }

        once {
            # configure IO::Notification to set $needs-rebuild on change
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我省略了很多细节, 但这应该能让你有个感觉。我能够协调不同的手段, 通过这些手段, 我可以发现导致网站重建的变化。我有一个工具, 可以把重建的次数控制在只有 <code>$interval</code> 秒的频率, 这样就一组变化就不会无休止地重新触发构建。我可以同时运行一个小型的 Web 服务器, 在开发者模式下为内容提供服务。而且我是在同一个事件循环中使用单线程来完成这一切的。</p>
</div>
<div class="paragraph">
<p>好的地方在于, 对于一个 <code>react</code> 内的每一个 <code>whenever</code>, 我们可以共享变量和状态, 而不必担心线程安全问题。这些块可能在同一个线程上运行, 也可能不在同一个线程上运行, 但无论如何, Raku 保证它们不会并发运行。</p>
</div>
<div class="paragraph">
<p>因此, react 块非常适合将各种任务协调在一起。几乎我写的每一个异步程序都会在某个地方有一个这样的主循环。如果任务具有很强的独立性, 我可以为每组任务设置一个事件循环, 而 <code>react</code> 块则在 <a href="https://docs.raku.org/language/control#index-entry-control_flow_start-start">start</a> 中运行。例如, 我可以用事件循环来处理图形更新, 用另一个事件循环来运行网络后端。</p>
</div>
<div class="sect3">
<h4 id="_首选管道">66.2.1. 首选管道</h4>
<div class="paragraph">
<p>每当你分解问题时, 你往往会选择创建一个 <a href="https://docs.raku.org/type/Supplier">Supplier</a> 对象, 并将数据输入其中, 或者是管道化。如果你可以管道化, 那么你就应该管道化。最简单的管道的例子是 <a href="https://docs.raku.org/type/Supply">Supply</a> 上的 <a href="https://docs.raku.org/type/Supply#method_map">.map</a> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $original = Supply.interval(1);
my Supply $plus-one = $original.map(* + 1);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样做大大简化了你的处理过程。它清楚地展示了一个任务对前一个任务的依赖性。它很容易阅读和遵循。它将为你省去许多麻烦。</p>
</div>
<div class="paragraph">
<p>关于其他类似的内置映射函数, 请参阅 Supply 的文档。我最喜欢的一个是 <a href="https://docs.raku.org/type/Supply#method_lines">.lines</a>, 它可以把一个发出字符串的 Supply 变成一个由换行符分解的字符串列表。</p>
</div>
<div class="paragraph">
<p><a href="https://cro.services/">Cro</a> 服务平台将这种平台的概念正式化为转换。几乎整个系统都是一个从请求到响应的管道, 其中每一步都将输入转化为接近最终输出的一步。这是一种非常强大的处理异步处理(async processing)的手段。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_让任何事情都成为供应">66.3. 让任何事情都成为供应</h3>
<div class="paragraph">
<p>如果你正在构建一个列表, 你可以使用 <a href="https://docs.raku.org/language/concurrency#index-entry-supply_%28on-demand%29">supply</a> 块来制作这个列表。这对于非琐碎的流程或者需要经常重复使用 <code>Supply</code> 的时候, 效果最好。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $primes = supply {
    for 1...* -&gt; $n {
        emit $n if $n.is-prime;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在像上面的 <code>supply</code> 块这样的琐碎处理中, 在只需要分接(tap)一次的情况下, 更简单的方法可能是通过在序列上调用 <a href="https://docs.raku.org/routine/Supply#class_Any">.Supply</a> 将 <a href="https://docs.raku.org/type/Seq">Seq</a> 变成 <code>Supply</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $primes = (1...*).grep(*.is-prime).Supply;</code></pre>
</div>
</div>
<div class="paragraph">
<p>后一个例子在功能上等同于第一个例子, 在我看来, 更容易阅读和理解。然而, 当你需要生成一个可重用的 <code>Supply</code> 或基于非琐碎逻辑的 <code>Supply</code> 时, 请准备好 <code>supply</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_supplier_进行拆分和连接">66.4. 使用 Supplier 进行拆分和连接</h3>
<div class="paragraph">
<p>当你有一组对象进来需要不同的处理时, 你可以在这里插入一个 <code>if</code> 语句来处理每一种情况, 或者你也可以将这些项重新发射到不同的流中进行处理。如果处理的情况不复杂, 可以考虑为每种类型的处理使用一个单独的 <code>Supplier</code> 对象。然后, 如果有必要的话, 再使用一个 <code>Supplier</code> 将这些流重新连接起来。</p>
</div>
<div class="paragraph">
<p>这类似于决定是否对一个有多种解决方案的问题使用单独的子程序。不使用单独的子程序(<code>sub</code>), 可以使用单独的 <code>whenever</code> 来代替。</p>
</div>
<div class="paragraph">
<p>考虑一下这个问题, 我们有一个合并的日志, 我们想把错误对象和访问对象区别对待。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    my Supplier $emitter .= new;
    my Supplier $error .= new;
    my Supplier $access .= new;

    whenever $emitter.Supply { .say }
    whenever $error.Supply -&gt; %e {
        $emitted.emit: &#34;%e&lt;timestamp&gt; Error %e&lt;code&gt;: %e&lt;message&gt;&#34;;
    }
    whenever $access.Supply -&gt; %a {
        $emitted.emit: &#34;%a&lt;timestamp&gt; Access: %a&lt;url&gt;&#34;;
    }
    whenever $log.Supply.lines -&gt; $line {
        given $line.&amp;from-json {
            when so .&lt;type&gt; eq &#39;error&#39; { $error.emit: $_ }
            when so .&lt;type&gt; eq &#39;access&#39; { $access.emit: $_ }
            default { die &#34;invalid log type&#34; }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>拆分和连接可以更好的原因是, 它可以更容易阅读和理解, 因为每个 <code>whenever</code> 都集中在一个任务上。在一个分支涉及较长的进程, 而另一个分支涉及较短的进程的情况下, 它还可以让你考虑如何最好地分别优化每个任务。</p>
</div>
</div>
<div class="sect2">
<h3 id="_按需供应与现场供应">66.5. 按需供应与现场供应</h3>
<div class="paragraph">
<p>你应该知道各种供应(supply)之间的区别。它们之间的区别有些微妙, 可以在一定程度上互换使用。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用 <code>Supplier</code> 类创建一个实时供应(live supply)。有一个单一的事件流, 这些事件是由关联的 <code>Supply</code> 对象上的当前分接器(tap)接收的。如果没有分接器(tap), 则不处理这些事件。如果有 N 个分接器(tap), <code>Supplier</code> 对象的 <a href="https://docs.raku.org/type/Supplier#method_emit">.emit</a> 方法会阻塞, 直到每个分接器(tap)处理完该事件。</p>
</li>
<li>
<p>使用 <code>supply</code> 块或通过调用列表上的 <code>.Supply</code> 方法来创建按需供应(on-demand supply)。<code>Supply</code> 的每个分接器(tap)实际上是一个独立的进程, 从头到尾接收由该供应对象生成的所有项。生成供应中每个项的代码都会被运行, 再次在 <code>supply</code> 块中<a href="https://docs.raku.org/language/control#supply/emit">发射</a>, 直到单次分接(tap)完成。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>从本质上说, 实时供应(live supply)使用的是扇出式(fan-out)架构, 而按需供应(on-demand supply)在行为上其实只是 <code>Seq</code> 的一个变种。我认为按需供应只是一个适配器(adapter), 使返回序列的函数与 <code>whenever</code> 块一起工作。</p>
</div>
</div>
<div class="sect2">
<h3 id="_避免_supplierpreserving">66.6. 避免 Supplier::Preserving</h3>
<div class="paragraph">
<p>还有就是 <a href="https://docs.raku.org/type/Supplier::Preserving">Supplier::Preserving</a>。有人认为这是两种类型之间的中间地带。然而, 这个对象的语义与现场供应(live supply)的语义完全相同, 但有一个例外:当没有分接器(tap)时, 这个对象会缓冲发出的事件, 并立即将这些对象转储到第一个出现的分接器(tap)中。</p>
</div>
<div class="paragraph">
<p>因此, 它主要是在开始发射前很难初始化分接器(tap)的情况下的一种便利。比如说:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Supplier::Preserving $msg .= new;
$msg.emit($_) for ^10;
$msg.Supply.tap: { .say };</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使在向 <code>$msg</code> 发射后发生了分接(tap), 程序也会打印出从1到10的数字。</p>
</div>
<div class="paragraph">
<p>问题是 <code>Supplier::Preserving</code> 有相关的风险, 比如第一次分接(tap)时, 内存膨胀或在旧数据上长时间的迭代。相反, 你应该更倾向于使用 <code>Supplier</code>, 并在发射之前确保所有的分接(tap)都到位。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Supplier $msg .new new;
$msg.Supply.tap: { .say }
$msg.emit($_) for ^10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者只是能够在开始的时候错过一些。有些情况下, 你可能真的想用 <a href="https://docs.raku.org/type/Channel">Channel</a> 来代替。</p>
</div>
<div class="paragraph">
<p>有些情况下, <code>Supplier::Preserving</code> 是很方便的, 所以根据需要利用它。我只是发现当我偷懒的时候, 它是适当的引导的一个简单的拐杖, 但在大多数情况下, 随着时间的推移, 它让我很烦。</p>
</div>
</div>
<div class="sect2">
<h3 id="_拆分长期运行的_whenever_块">66.7. 拆分长期运行的 whenever 块</h3>
<div class="paragraph">
<p>对于你的任务来说, 什么是合理的, 可能会有所不同, 但请记住, 在 <code>react</code> 块内运行的代码, 一个 <code>whenever</code> 块会阻塞所有其他块的运行。<code>react</code> 块实际上只是在老式事件循环的薄薄一层外衣, 在这里任何子任务都会饿死其他任务的处理时间。</p>
</div>
<div class="paragraph">
<p>例如, 考虑一下我在上面提到的 <code>build-loop</code> 工具的 <code>react</code> 块。当 <code>build-site()</code> 例程运行时, 我的 Web 服务器无法刷新。这样可以吗？</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>这是一个开发过程, 所以我可以容忍 Web 服务器运行过程中的一些奇怪现象。</p>
</li>
<li>
<p>我是唯一的开发者。</p>
</li>
<li>
<p>这意味着我的网站要等到网站建设完成后才能刷新。</p>
</li>
<li>
<p>我更愿意等待, 只看到新鲜的内容。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>听起来, 这对我来说是个胜利。</p>
</div>
<div class="paragraph">
<p>在生产中, 我是不会容忍的。在网络内容方面, 如果要花费超过几毫秒的时间来构建, 那么现在的旧内容几乎总是比最新鲜的内容要好。在这种情况下, 我会设置一个单独的 Web 服务器线程。在这种特殊情况下, 根本没有应用服务器, 只有静态内容, 所以没有必要。</p>
</div>
<div class="paragraph">
<p>这就是你在设计 <code>whenever</code> 块时必须要做的那种权衡。如果一个 <code>whenever</code> 块运行时间过长, 其他块就会被推迟。如果这是件坏事, 那就把那个 <code>whenever</code> 块分成一系列较小的 <code>whenever</code> 块, 把它们链在一起。在一些运行时间较长的过程中, 每当你完成一个 <code>whenever</code> 块的时候, 都是一个潜在的饥饿任务轮到它的机会。</p>
</div>
<div class="paragraph">
<p>如果这样的任务仍然是个问题, 你可能需要通过 <code>start</code> 块把它移到另一个线程中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_批量短任务">66.8. 批量短任务</h3>
<div class="paragraph">
<p>另外, 琐碎的任务会涉及到一定的开销, 让 <code>react</code> 块之间进行切换。如果一个任务速度超级快, 你可能会考虑使用 <code>Supply</code> 上的 <a href="https://docs.raku.org/type/Supply#method_batch"><code>.batch</code></a> 方法, 让你在元素组上循环, 以避免频繁切换任务。<a href="https://docs.raku.org/type/Supply#method_batch">.batch</a> 方法之所以方便, 是因为它可以让你把一个问题在时间延迟和元素数量上进行分解。这将让你的程序有更多的时间去做真正的工作, 而不是花更少的时间去做决定下一步安排哪个任务的繁忙工作。</p>
</div>
</div>
<div class="sect2">
<h3 id="_避免休眠">66.9. 避免休眠</h3>
<div class="paragraph">
<p>如果你在一个 <code>react</code> 块中, 你不希望调用 <a href="https://docs.raku.org/type/Date#sub_sleep">sleep</a>, 除非你的目的是阻止当前线程的所有执行。否则, 你最好使用 <a href="https://docs.raku.org/routine/await">await</a> 来暂停你的任务。如果你这样做, 你的 <code>react</code> 块可以继续处理事件, 直到 <code>await</code> 完成。如果你需要在若干秒内添加一个 <code>await</code>, 你可以这样做。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">await Promise.in(10); # sleep 10 seconds</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_谨防死锁">66.10. 谨防死锁</h3>
<div class="paragraph">
<p>尽管 Raku 的接口是可以组合的, 但如果你使用不当, 仍然有可能导致死锁。<code>react</code> 块内的任何东西都保证以顺序的方式运行。这意味着, 如果你期望两个 <code>whenever</code> 块能够同时运行, 那么当代码突然停止时, 你会很失望。我之所以提到这一点, 是因为我时不时会遇到这个问题。即使我知道 <code>react</code> 块执行的是单线程一次的规则, 但我还是会时不时地想象多个 <code>whenever</code> 块可以同时运行。</p>
</div>
<div class="paragraph">
<p>如果你真的需要这样, 这很容易解决。只要在 <code>whenever</code> 块里面放一个 <code>start</code> 块, 就可以让两段代码同时运行。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论_7">66.11. 结论</h3>
<div class="paragraph">
<p>暂时到此为止。几天后, 我们将再来讨论这个话题, 但不是异步, 而是考虑分工并发处理的准则。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/15/breaking-down-async-problems/" class="bare">https://zostay.com/posts/2019/12/15/breaking-down-async-problems/</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_信号量">67. 信号量</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/16/semaphores/_hub7f3ac8d1cb0b33d101673df85949210_1816497_248defd7f26318921ad630d203317a47.jpg" alt="semaphore"/>
</div>
</div>
<div class="paragraph">
<p>信号量(semaphore)是一个使用标志发送消息的系统。哦, 等等, 这就是计算机之外的信号量(semaphore)。在计算机中, 信号量(semaphore)就像一种锁, 被获取 N 次后就会被锁住。这对于你有 N 个项的资源, 当你知道有资源可用的时候, 想要快速分配, 然后立即阻止, 直到资源被释放出来的情况下, 是很有用的。Raku 为此提供了一个内置的 <a href="https://docs.raku.org/type/Semaphore">Semaphore</a> 类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class ConnectionPool {
    has @.connections;
    has Semaphore $!lock;

    submethod BUILD(:@!connections) {
        $!lock .= new(@!connections.elems);
    }

    method use-connection() {
        $!lock.acquire;
        pop @!connections;
    }

    method return-connection($connection) {
        push @!connections, $connection;
        $!lock.release;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, 我们有一个连接池, 在这里我们可以快速、安全地从连接堆栈中拉取条目。但是, 一旦最后一个连接被拉出, <code>.use-connection</code> 方法就会阻塞, 直到使用 <code>.return-connection</code> 返回一个连接。</p>
</div>
<div class="paragraph">
<p>还有一个额外的 <a href="https://docs.raku.org/type/Semaphore#method_try_acquire">.try_acquire</a> 方法可以用来代替 <a href="https://docs.raku.org/type/Semaphore#method_acquire">.acquire</a>, 它返回一个决定成败的 <a href="https://docs.raku.org/type/Bool">Bool</a>。例如, 我们可能会有一个用于按键的缓冲区, 如果缓冲区填满了, 我们希望它失败, 而不是继续存储按键事件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class KeyBuffer {
    has UInt $.size;
    has UInt $!read-cursor = 0;
    has UInt $!write-cursor = 0;
    has byte @!key-buffer;
    has Semaphore $!buffer-space;
    has Semaphore $!lock .= new(1);

    submethod BUILD(UInt :$!size) {
        @!key-buffer = 0 xx $!size;
        $!buffer-free .= new($!size);
    }

    method !increment-cursor($cursor is rw) {
        $cursor++;
        $cursor %= $!size;
    }

    method store(byte $key) {
        $!buffer-space.try_acquire or die &#34;buffer is full!&#34;

        $!lock.acquire;
        LEAVE $!lock.free;

        @!key-buffer[ $!write-cursor ] = $key;
        self!increment-cursor($!write-cursor);
    }

    method getc(--&gt; byte) {
        my $result = 0;

        $!lock.acquire;
        LEAVE $!lock.release;

        if $!read-cursor != $!write-cursor {
            $result = @!key-buffer[ $!read-cursor ];
            self!increment-cursor($!read-cursor);

            $!buffer-space.release;
        }

        $result;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个数据结构使用了两个信号量。其中一个名为 <code>$!lock</code>, 和 <a href="https://docs.raku.org/type/Lock">Lock</a> 的工作方式一样, 用来保护关键部分, 并确保它们是原子的。另一个叫 <code>$!buffer-space</code>, 用于确保当缓冲区填满时, 写操作失败。</p>
</div>
<div class="paragraph">
<p>如你所见, 我们使用 <code>.try_acquire</code> 方法从 <code>Semaphore</code> 中获取资源。如果该方法返回 <code>False</code>, 我们会抛出一个异常, 让调用者知道操作失败。如果该方法返回 <code>True</code>, 那么我们就获得了向缓冲区添加另一个条目的权限。当我们从缓冲区中读取时, 我们仍然使用 <a href="https://docs.raku.org/type/Semaphore#method_release">.release</a> 来再次标记可用的空间。</p>
</div>
<div class="paragraph">
<p>我之所以用 <code>Semaphore</code> 来做互斥锁, 是因为它可以用这种方式, 这就是我们要讨论的问题。然而让, Lock 或者 <a href="https://docs.raku.org/type/Lock::Async">Lock:::Async</a> 的 <code>protect</code> 方法在这里可能是更好的选择, 因为你不需要小心翼翼地确保 <code>.release</code> 被调用, 因为 <code>.protect</code> 块为你处理了这个问题。也就是说, <a href="https://docs.raku.org/language/phasers#LEAVE">LEAVE</a> phaser 是确保 <code>.release</code> 被调用的好方法, 因为无论块如何退出, LEAVE phaser 都会被调用（也就是说, 即使是在异常情况下也会运行）。</p>
</div>
<div class="paragraph">
<p>需要注意的是, 如果在上面的 <code>.getc</code> 方法中, 在 <code>$!read-cursor</code> 被增量后, 但在 <code>$!buffer-space.release</code> 被调用之前, 如果发生了异常, 你可能会让缓冲区处于一个糟糕的状态, 它不再有那么多的空间。因此, 一个可能值得做的改进是确保 <code>if</code> 块中的异常被捕获并处理, 如果这种异常是可能的。</p>
</div>
<div class="paragraph">
<p>一般要记住的是, 每当处理并发性的时候, 看似微不足道的边缘情况很容易变得很重要。有时会以不可预见的方式变得很重要。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/16/semaphores/" class="bare">https://zostay.com/posts/2019/12/16/semaphores/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_比较_react_与_tap">68. 比较 react 与 tap</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 中, 我们有几种基本的方式来获取从 <a href="https://docs.raku.org/type/Supply">Supply</a> 发出的事件, 这就引出了一个问题, 那就是每一种方式之间有什么区别？我想通过创建一个带有几个间隔的 <a href="https://docs.raku.org/language/concurrency#index-entry-react">react</a> 块来回答这个问题, 然后用 <a href="https://docs.raku.org/type/Supply#method_tap">tap</a> 来模拟同样的基本功能。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/17/comparing-react-with-tap/cover-fikri-rasyid-LJnRzbDFdI4-unsplash_hu242dc4845fc5428385ea04be07c767ec_2222285_280x280_fill_q75_box_smart1.jpg" alt="react"/>
</div>
</div>
<div class="paragraph">
<p>让我们从我们的基础 <code>react</code> 块开始:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub seconds { state $base = now; now - $base }
react {
    say &#34;REACT 1: {seconds}&#34;;

    whenever Supply.interval(1) {
        say &#34;INTERVAL 1-$_: {seconds}&#34;;
        done if $_ &gt; 3;
    }

    say &#34;REACT 2: {seconds}&#34;;

    whenever Supply.interval(0.5) {
        say &#34;INTERVAL 2-$_: {seconds}&#34;;
    }

    say &#34;REACT 3: {seconds}&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>seconds</code> 例程只是一个辅助工具, 为我们提供从块开始到工作的时间(以秒为单位)。这个代码块的输出通常会类似于这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">REACT 1: 0.0011569
REACT 2: 0.0068571
REACT 3: 0.008015
INTERVAL 1-0: 0.0092906
INTERVAL 2-0: 0.0101116
INTERVAL 2-1: 0.5103139
INTERVAL 1-1: 1.007995
INTERVAL 2-2: 1.022309
INTERVAL 2-3: 1.5124228
INTERVAL 1-2: 2.0137509
INTERVAL 2-4: 2.014717
INTERVAL 2-5: 2.517795
INTERVAL 1-3: 3.016291
INTERVAL 2-6: 3.0182612
INTERVAL 2-7: 3.521018
INTERVAL 1-4: 4.0182113</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么它是什么意思呢？嗯, 首先要注意的是, <code>react</code> 块本身的所有代码都会先运行。也就是说, 它运行所有的命令, 包括每个 <code>whenever</code> 块来注册每个 <code>Supply</code> 的事件 tap, 但还不运行代码。一旦 <code>react</code> 块完成运行, 它就会进行阻塞, 直到所有的 <code>whenever</code> 块都运行完毕或者是遇到 <code>done</code> 语句。这时, 所有的供应都会被解开(untapped), 继续执行。</p>
</div>
<div class="paragraph">
<p>顺便说一下, 如果你想在一个 <code>react</code> 块完成后让一个块运行(或者说一个供应块), 你可以使用特殊的 <a href="https://docs.raku.org/language/phasers#CLOSE">CLOSE</a> phaser。<a href="https://docs.raku.org/language/phasers#LEAVE">LEAVE</a> phaser 会在 <code>react</code> 块中的代码完成 设置 <code>react</code> 后立即退出。</p>
</div>
<div class="paragraph">
<p>除此以外, 必须注意的是, 与 <code>react</code> 块相关的一切都只会按顺序运行。Raku 并没有承诺在一个线程中运行, 但它承诺一个 <code>react</code> 块里面的两部分代码不会并发运行。这包括第一次运行通过执行 <code>react</code> 块本身, 以及执行 <code>react</code> 向供应发射值的 <code>whenever</code> 块。</p>
</div>
<div class="paragraph">
<p>那么, 我们应该如何使用 <code>.tap</code> 来实现这种行为呢？我们可以这样做。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub seconds { state $base = now; now - $base }
REACT: {
    say &#34;REACT 1: {seconds}&#34;;

    my $ready = Promise.new;
    my $mutex = Lock.new;
    my $finished = my $done = Promise.new;

    my $interval1 = Supply.interval(1).tap: {
        await $ready;
        $mutex.protect: {
            say &#34;INTERVAL 1-$_: {seconds}&#34;;
            $done.keep if $_ &gt; 3;
        }
    }

    $finished .= then: -&gt; $p {
        $interval1.close;
    }

    say &#34;REACT 2: {seconds}&#34;;

    my $interval2 = Supply.interval(0.5).tap: {
        await $ready;
        $mutex.protect: {
            say &#34;INTERVAL 2-$_: {seconds}&#34;;
        }
    }

    $finished .= then: -&gt; $p {
        $interval2.close;
    }

    say &#34;REACT 3: {seconds}&#34;;

    $ready.keep;
    await $finished;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这与 <code>react</code> 块的实际工作类似, 但多了几个手动步骤。首先, 我们必须准备几个承诺(Promise)。<code>$ready</code> <a href="https://docs.raku.org/type/Promise">Promise</a> 是保留在 &#34;react&#34; 块的结尾, 以释放 tap 进行工作。<code>$done</code> Promise 是我们保留主线程的地方, 直到执行完成。</p>
</div>
<div class="paragraph">
<p>我还没有实现如果所有的供给都完成了, 就自动保留 <code>$done</code> 的额外逻辑。这样做可以通过为每个 tap 创建另一个 Promise 来实现, 当 tap done 块被执行时, 这个Promise将被保留。可以为所有这些 <a href="https://docs.raku.org/type/Promise#method_allof">Promise.allof()</a> 承诺附加一个 <a href="https://docs.raku.org/type/Promise#method_then">.then</a> 块。我把解决这个问题作为一个练习留给读者。</p>
</div>
<div class="paragraph">
<p>另一个主要的新增功能是 <code>$mutex</code> <a href="https://docs.raku.org/type/Lock">lock</a> 对象。这可以防止各个 tap 块同时运行。</p>
</div>
<div class="paragraph">
<p>这应该就足够了。这可能不是最有效的解决方案, 但它确实展示了 <code>react</code> 块给你带来的额外帮助。你可能会注意到 tap 版本的速度稍微快了一点。这并不奇怪。这个 <code>tap</code> 版本不像 <code>react</code> 块那样精心组织。因此, 如果多花几毫秒的时间对你的代码很重要, 你可以考虑直接使用 tap 和其他工具来实现你的异步协调代码, 而不是使用 <code>react</code> 块。但是, 要注意的是, <code>react</code> 块很可能通过为你做那些繁琐的小细节, 为你的调试省去了一大堆麻烦。</p>
</div>
<div class="paragraph">
<p>还有最后一点, <a href="https://docs.raku.org/type/Supply#method_act">act</a> 方法的文档中说, 它的工作原理和 tap 一样, 但给定的代码一次只由一个线程执行。我真的不清楚这到底是什么意思, 因为这个基本保证也是 tap 所固有的。这是因为在所有的 tap 运行完毕之前, <code>Supply</code> 无法继续进行另一个发出的消息。在实践中, 分接(tap)也都是同步运行每个消息的。在我所有的工作中, 我还没有发现任何证据表明在一个给定的 <code>Supply</code> 上的 tap 会同时运行。无论如何, 如果有人能继续在 <a href="https://www.reddit.com/r/rakulang/comments/ebpf8j/zostay_advent_day_17_comparing_react_with_tap/">Reddit</a> 上发表这个帖子, 并解释一下 tap 和 act 之间的实际区别是什么, 我将不胜感激。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/17/comparing-react-with-tap/" class="bare">https://zostay.com/posts/2019/12/17/comparing-react-with-tap/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_supply_反压">69. Supply 反压</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 中, <a href="https://docs.raku.org/type/Supply">Supply</a> 是线程之间发送消息的主要工具之一。从 <code>Supply</code> 的结构方式来看, 很明显, 它为一个或多个任务提供了一种向多个接收方任务发送事件的手段。然而, 不那么明显的是, <code>Supply</code> 会给发送者带来一定的成本。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/18/supply-back-pressure/cover-toa-heftiba-a9pFSC8dTlo-unsplash_hu71d190ba122c284277c5e37c86e316cf_716097_280x280_fill_q75_box_smart1.jpg" alt="Supply Back Pressure"/>
</div>
</div>
<div class="paragraph">
<p>考虑一下这个程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $counter = Supplier.new;
start react whenever $counter.Supply {
    say &#34;A pre-whenever $_&#34;;
    sleep rand;
    say &#34;A post-whenever $_&#34;;
}
start react whenever $counter.Supply {
    say &#34;B pre-whenever $_&#34;;
    sleep rand;
    say &#34;B post-whenever $_&#34;;
}
start for 1...* {
    say &#34;pre-emit $_&#34;;
    $counter.emit($_);
    say &#34;post-emit $_&#34;;
}
sleep 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里我们有三个任务在运行, 每个任务都在一个独立的线程中。我们让主程序在10秒后退出。前两个线程接收来自 <code>$counter.Supply</code> 的消息。第三个线程向这个 <code>Supply</code> 提供一连串的整数。你可能会想, 最后的任务会在传递事件的过程中进行竞赛, 但如果是这样, 那你就错了。</p>
</div>
<div class="paragraph">
<p>考虑一下这个程序的输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">pre-emit 1
A pre-whenever 1
A post-whenever 1
B pre-whenever 1
B post-whenever 1
post-emit 1
pre-emit 2
A pre-whenever 2
A post-whenever 2
B pre-whenever 2
B post-whenever 2
post-emit 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意到一个模式了吗？即使前两个线程有一个随机等待, 第三个线程根本没有等待, 但第三个线程会被阻塞, 直到其他两个线程都完成。这种行为都是一样的, 无论 <code>Supply</code> 是如何被 tap 的, 这种行为都是一样的, 也就是说, 无论你是使用 whenever 块还是调用 <code>.tap</code>, 都没有关系。</p>
</div>
<div class="paragraph">
<p>因此, 如果你想让你的发射器尽可能快地爆破事件, 你需要确保尽快写完 tap, 或者考虑不同的解决方案, 比如使用一个 Channel, 它将任务内存中排队任务, 只要监听该 channel 的线程有时间处理它们, 它们就会得到处理。</p>
</div>
<div class="paragraph">
<p>只要在使用 <code>Supply</code> 的时候注意这个背压成本就可以了。发送者总是要付出代价的。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/18/supply-back-pressure/" class="bare">https://zostay.com/posts/2019/12/18/supply-back-pressure/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_无锁的线程安全结构">70. 无锁的线程安全结构</h2>
<div class="sectionbody">
<div class="paragraph">
<p>正如我之前在这个日历中多次说过的, 最好避免在运行的线程之间共享状态。然而, 这里又是另一种共享状态的方法, 当你需要这样做的时候。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/19/thread-safe-structures-without-locking/cover-raissa-de-paula-ZUgVjh7PFhk-unsplash_hu11d8d3af3484057d8b22e647ddbea047_3449561_280x280_fill_q75_box_smart1.jpg" alt="Thread Safe Structures Without Locking"/>
</div>
</div>
<div class="paragraph">
<p><a href="https://zostay.com/archive/2019/12/13/the-monitor-pattern.html">几天前</a>, 我们考虑将监视器作为创建线程安全对象的一种机制。让我们考虑一下下面的监视器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class BankBalanceMonitor {
    has UInt $.balance = 1000;
    has Lock $!lock .= new;

    method deposit(UInt:D $amount) {
        $!lock.protect: { $!balance += $amount };
    }

    method withdraw(UInt:D $amount) {
        $!lock.protect: { $!balance -= $amount };
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://zostay.com/archive/2019/12/14/compare-and-swap-your-scalars.html">后天</a>我们考虑了比较与交换(compare-and-swap)操作, 也就是 <code>cas</code>, 以及如何在 Raku 中与任何标量变量一起使用它。通过使用 <code>cas</code>, 我们实际上可以在完全不使用锁的情况下创建线程安全对象。</p>
</div>
<div class="paragraph">
<p>因此, 我们可以把上面的类重写成这样的无锁数据结构。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class BankBalanceLockFree {
    has UInt $.balance = 1000;

    method deposit(UInt:D $amount) {
        cas $!balance, -&gt; $current { $current + $amount };
    }

    method withdraw(UInt:D $amount) {
        cas $!balance, -&gt; $current { $current - $amount };
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>就是这样。同样的保护措施, 但现在我们用标量 <code>CAS</code> 操作代替了。这可以比锁定更有效率。但为什么呢？</p>
</div>
<div class="paragraph">
<p>因为每次遇到锁的时候, 开始和结束都会有成本。再加上每一个关键的部分都是一个瓶颈, 多线程系统必须暂时变成单线程。而 <code>CAS</code> 没有特别昂贵的操作, 但可能会导致关键部分多次重跑。</p>
</div>
<div class="paragraph">
<p>让我们考虑一下我们系统中两个变量的极端情况: 竞争和运行时间。竞争(contention)是一个通用术语, 描述了一次需要在关键部分工作的线程数量。这里的运行时间描述的是在关键部分内运行操作所需的时间。</p>
</div>
<div class="paragraph">
<p>如果一个操作有较低的竞争性和较短的运行时间, 那么 <code>CAS</code> 几乎可以肯定会有更好的性能。锁在开始和结束时有很高的开销, 而 <code>CAS</code> 几乎不会有开销。在低竞争性的情况下, 我们可能要时不时地重复一个操作, 但操作的速度很快, 所以没有关系。</p>
</div>
<div class="paragraph">
<p>如果一个操作的竞争性很高, 运行时间很短, <code>CAS</code> 还是很有可能胜出。你可能最终会有一两个线程不得不多次重复操作, 但随着线程数量的增多, 一个锁对单线程瓶颈的执行并不能很好的扩展。</p>
</div>
<div class="paragraph">
<p>如果一个操作的竞争性低, 运行时间长, 那么 <code>CAS</code> 可能是个败笔。如果关键部分真的需要几百毫秒甚至更长的时间, 那么重复的成本可能会更高。不过, 可能值得进行 A/B 测试, 看看哪种方法会赢。</p>
</div>
<div class="paragraph">
<p>如果一个操作具有高竞争性和长运行时间, 锁可能会赢。然而, 在这一点上, 你的操作是否真的可以跨多线程扩展就不太清楚了。在许多竞争线程上长时间锁定的瓶颈, 基本上会使你的应用沦为单线程。也许是时候考虑如何加快操作速度, 或者用不涉及共享状态的方式进行操作了。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/19/thread-safe-structures-without-locking/" class="bare">https://zostay.com/posts/2019/12/19/thread-safe-structures-without-locking/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_拆解并发问题">71. 拆解并发问题</h2>
<div class="sectionbody">
<div class="paragraph">
<p>今天这篇文章的目标是考虑什么时候要同时运行你的任务, 以及如何做到这一点。我不打算为此给出任何规则, 因为一次有效的规则可能在下一次就不管用了。相反, 我将专注于分享一些我从个人经验中学到的准则。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/20/breaking-down-concurrency-problems/cover-mick-haupt-QaCltys9eNw-unsplash_hu0f93f0f550d24bfe14ec296c6d9cfdb9_4033112_280x280_fill_q75_box_smart1.jpg" alt="Breaking Down Concurrency Problems"/>
</div>
</div>
<div class="sect2">
<h3 id="_牢记你的承诺">71.1. 牢记你的承诺</h3>
<div class="paragraph">
<p>每当你使用并发的时候, 你要紧紧抓住相关的 <a href="https://docs.raku.org/type/Promise">Promise</a> 对象。它们几乎都是重新合并(rejoin)你的任务, 使主线程等待你的并发任务完成等等的最佳方式。</p>
</div>
<div class="paragraph">
<p>我在代码中看到的一个常见模式是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $gui-task = start { ... }
my $console  = start { ... }
my $jobs     = start { ... }
await Promise.allof($gui-task, $console, $jobs);</code></pre>
</div>
</div>
<div class="paragraph">
<p>就像这样, 我有三个任务在三个不同的线程中运行, 主线程一直保持到三个任务完成。</p>
</div>
<div class="paragraph">
<p>这个 <code>await</code> 也是你要添加 <code>CATCH</code> 块的地方, 因为其他线程的异常会在这个时候重新合并(rejoin)到调用线程中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_主线程是特殊的">71.2. 主线程是特殊的</h3>
<div class="paragraph">
<p>当你编写并发程序时, 要注意主线程是特殊的。它不会被安排运行任务, 只要它在做某事或等待某事, 你的程序就会继续运行。只要主线程一退出, 你的其他任务就会立即被收割并退出。</p>
</div>
</div>
<div class="sect2">
<h3 id="_倾向于用单线程进行输入或输出">71.3. 倾向于用单线程进行输入或输出</h3>
<div class="paragraph">
<p>避免线程之间共享文件句柄或套接字。每次只有一个线程可以读取或写入一个句柄。确保你安全地做到这一点的最简单的方法是将该活动保持在一个线程中。在一个多线程程序中, 任何线程都可能输出到标准输出或标准错误, 我经常调用类似下面的模式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Supplier $out .= new;
my Supplier $err .= new;
start {
    react {
        whenever $out { .say }
        whenever $err { .note }
    }
}
start {
    for ^10_000 { $out.emit: $_ }
}
start {
    for ^10_000 { $out.emit: $_ }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你不采用这样的模式, 你的程序可能仍然可以工作, 但你的输出可能会出现一些奇怪的怪现象。</p>
</div>
</div>
<div class="sect2">
<h3 id="_raku_数据结构本质上并不安全">71.4. Raku 数据结构本质上并不安全</h3>
<div class="paragraph">
<p>与上一节中说的输入和输出类似, 请注意, 大多数 Raku 数据结构都不是线程安全的。如果你想跨线程使用一个数据结构, 你必须使用一些策略来使该访问线程安全。一些可行的策略是。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用一个线程来管理对该数据结构的访问, 就像上面对标准输出和标准错误所做的那样。</p>
</li>
<li>
<p>使用监视器模式(monitor pattern)来保护数据结构的安全。</p>
</li>
<li>
<p>适当地利用 <a href="https://docs.raku.org/routine/cas">cas</a>、<a href="https://docs.raku.org/type/Lock">Lock</a>、<a href="https://docs.raku.org/type/Lock::Async">Lock:::Async</a>、<a href="https://docs.raku.org/type/Semaphore">Semaphore</a>、Promise 或其他可用的锁机制之一来保护对对象的访问。</p>
</li>
<li>
<p>使用 <a href="https://docs.raku.org/type/Channel">Channel</a> 或 <a href="https://docs.raku.org/type/Supply">Supply</a> 管理对对象的修改。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>无论你做什么, 都不要认为对对象的访问是线程安全的, 除非线程安全是对象设计的明确部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="_在每个_gui_事件循环或窗口中使用任务">71.5. 在每个 GUI 事件循环或窗口中使用任务</h3>
<div class="paragraph">
<p>如果你的应用程序有一个 GUI, 你几乎肯定需要一个单独的线程来管理 GUI 的输入和输出。大多数 GUI 库已经有一个内置的事件循环, 你想把它作为一个任务在一个单独的循环中运行。你可能需要为整个 GUI 设置一个任务, 也可能需要为每个窗口设置一个单独的任务。</p>
</div>
</div>
<div class="sect2">
<h3 id="_批量小任务">71.6. 批量小任务</h3>
<div class="paragraph">
<p>你并不总是希望每个动作都有一个任务。有些动作实在是太琐碎了, 而执行时间又太短, 无法管理。什么是合理的任务规模, 其实取决于你和你的执行环境。只是要注意, 当涉及的处理是琐碎的时候, 分批运行你的任务往往是比以微小的片段运行更好的策略。</p>
</div>
<div class="paragraph">
<p>如果你使用 <code>hyper</code> 或 <code>race</code> <a href="https://docs.raku.org/language/statement-prefixes#index-entry-hyper_%28statement_prefix%29-hyper">关键字</a> 或 <a href="https://docs.raku.org/type/Iterable#method_hyper">方法</a> 来并行化工作, 那么批处理是内置的、自动的。你可能想尝试一下参数, 看看调整任务的批处理大小是否能提高速度。</p>
</div>
</div>
<div class="sect2">
<h3 id="_将较大的任务分解成较小的任务">71.7. 将较大的任务分解成较小的任务</h3>
<div class="paragraph">
<p>有些并发任务, 你只想在 CPU 时间可用时连续运行, 或者每当有事件出现时就触发。然而, 单次运行时间较长的任务有时可以从被分解成较小的任务中受益。可以同时运行的任务数量有限, 将它们分解可以帮助确保 CPU 保持忙碌。</p>
</div>
<div class="paragraph">
<p>将任务分解的一个简单方法是在自然位置插入 <code>await</code> 语句。从 Raku v6.d 开始, 你可以有效地将任务转化为协程(coroutine), 通过使用 <code>await</code> 暂停, 直到 socket 准备好了, 更多的数据进来了, 有信号从 Promise 或 Channel 等处到达, 等等。记住, 任何时候 Raku 遇到 <code>await</code>, 都是 Raku 在为当前任务所使用的线程上的另一个任务安排工作的机会。</p>
</div>
</div>
<div class="sect2">
<h3 id="_小心线程的限制">71.8. 小心线程的限制</h3>
<div class="paragraph">
<p>可用的线程数量是有限的。如果你的任务有可能运行大量的任务, 请花点时间考虑如何分解任务。限制任务之间的依赖数量将使你的程序能够有效地扩展, 而不会耗尽资源。</p>
</div>
<div class="paragraph">
<p>任何时候, 你的任务必须暂停输入或出于任何原因, 确保用 <code>await</code> 来做, 将确保最大数量的线程准备好工作。</p>
</div>
</div>
<div class="sect2">
<h3 id="_避免休眠_2">71.9. 避免休眠</h3>
<div class="paragraph">
<p>我认为 <a href="https://docs.raku.org/type/Date#sub_sleep">sleep</a> 是有害的。相反, 最好使用 <a href="https://docs.raku.org/type/Promise#method_in">await Promise.in(…​)</a>], 因为这让 Raku 能够将当前线程重用到另一个任务中。只有当你故意想在暂停期间锁定一个线程时才使用 <code>sleep</code>。我在这个临终日历中使用 sleep 主要是因为它比较熟悉。在实践中, 我一般只在主线程上使用它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论_8">71.10. 结论</h3>
<div class="paragraph">
<p>这些建议中的大部分内容与分解异步问题的建议重叠。我希望这能在编写并发程序时提供一些有用的指导。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/20/breaking-down-concurrency-problems/" class="bare">https://zostay.com/posts/2019/12/20/breaking-down-concurrency-problems/</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_并行循环执行">72. 并行循环执行</h2>
<div class="sectionbody">
<div class="paragraph">
<p>迭代很慢。如果在循环中要处理 N 件事, 则循环将需要 N 次迭代来处理。太慢了。不过有时候这是解决问题的唯一方法。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/21/parallel-loop-execution/cover-federico-beccari-ahi73ZN5P0Y-unsplash_huac7d2a5953ab5a36db86404f4aa1157d_2764178_280x280_fill_q75_box_smart1.jpg" alt="Parallel Loop Execution"/>
</div>
</div>
<div class="paragraph">
<p>例如, 让我们考虑这样的情况: 我们有一个 JSON 日志, 并且想要一个命令来读取每一行, 解析该日志的 JSON, 并对其进行汇总以显示时间戳和消息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use JSON::Fast;
my $log-file = &#39;myapp.log&#39;.IO;
for $log-file.lines -&gt; $line {
  my %data = from-json($line);
  say &#34;%data&lt;timestamp&gt; %data&lt;message&gt;&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你的系统上有多个核心(都 2019 年了谁还没有多核呢？), 其实你可以通过一些小小的更改来加快这个速度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use JSON::Fast;
my $log-file = &#39;myapp.log&#39;.IO;
race for $log-file.lines -&gt; $line {
  my %data = from-json($line);
  say &#34;%data&lt;timestamp&gt; %data&lt;message&gt;&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/statement-prefixes#index-entry-race_%28statement_prefix%29-race">race</a> 前缀添加到任何循环中都会导致项在可用核心上尽可能快地被迭代。在我的机器上, 对于一个只有这两个字段的 10000 行的短日志, 其结果是节省了大约 25% 的时间。然而, 这也带来了一个后果：原来的行的顺序不再保留。在某些情况下, 这可能并不重要, 但在另一些情况下却很重要。</p>
</div>
<div class="paragraph">
<p>现在, 我们可以使用另一个保留顺序的前缀, 叫做 <code>hyper</code>。然而, 在这种特殊情况下, 它是行不通的。为什么呢？因为 <code>hyper</code> 只能保证结果按顺序输出, 但这里我们是在代码运行时输出结果。这是每当使用这些关键字时要非常小心的地方。</p>
</div>
<div class="paragraph">
<p>但是, 这很容易解决。你只需要消除副作用, 让你的 <code>for</code> 循环发挥作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use JSON::Fast;
my $log-file = &#39;myapp.log&#39;.IO;
my $output-lines = hyper for $log-file.lines -&gt; $line {
  my %data = from-json($line);
  &#34;%data&lt;timestamp&gt; %data&lt;message&gt;&#34;;
}
.say for @$output-lines;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 我们从并行解析 JSON 行中获得了大部分的加速, 但是我们可以按照与原始文件相同的顺序输出。这样做的原因是, 带有 <code>hyper</code> 或 <code>race</code> 前缀的 <code>for</code> 循环的输出就像 <code>do</code> 一样：结果是一个我们可以迭代的序列。在这种情况下, 它是一个 <code>HyperSeq</code>, 它确保 Raku 正确处理多线程部分。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/21/parallel-loop-execution/" class="bare">https://zostay.com/posts/2019/12/21/parallel-loop-execution/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_asynchronous_socket">73. Asynchronous Socket</h2>
<div class="sectionbody">
<div class="paragraph">
<p>有什么比套接字通信更异步的？当两个程序需要相互交谈时, 往往是来自世界不同地区不同网络上的不同计算机, 你可以使用套接字进行连接。无论是 HTTP 服务器还是某些自定义协议, 你都可以使用 <a href="https://docs.raku.org/type/IO::Socket::Async">IO::Socket::Async</a> 来实现该通信的两边。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/22/asynchronous-socket/cover-elena-mozhvilo-FBaJVyV_NvU-unsplash_hu955699248d7ee02d3ae96cb021aa0bcc_5441407_280x280_fill_q75_box_smart1.jpg" alt="Asynchronous Socket"/>
</div>
</div>
<div class="paragraph">
<p>让我们考虑一个简单的计算器服务。它侦听 TCP 连接。当连接建立后, 它通过连接接收一行行的输入, 并将每一行解析为一个简单的数学计算, 比如 <code>2+2</code> 或 <code>6*7</code>。</p>
</div>
<div class="paragraph">
<p>我们可以把服务器写成这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
  whenever IO::Socket::Async.listen(&#39;127.0.0.1&#39;, 3456) -&gt; $conn {
    whenever $conn.Supply.lines -&gt; $line {
      if $line ~~ m:s/$&lt;a&gt; = [ \d+ ] $&lt;op&gt; = [ &#39;+&#39; | &#39;-&#39; | &#39;*&#39; | &#39;/&#39; ] $&lt;b&gt; = [ \d+ ]/ {
        my $a = +$&lt;a&gt;;
        my $b = +$&lt;b&gt;;

        my $r = do given &#34;$&lt;op&gt;&#34;.trim {
          when &#39;+&#39; { $a + $b }
          when &#39;-&#39; { $a + $b }
          when &#39;*&#39; { $a + $b }
          when &#39;/&#39; { $a + $b }
          default { &#34;Unknown Error&#34;; }
        }

        $conn.print(&#34;$r\n&#34;);
      }
      else {
        $conn.print(&#34;Syntax Error\n&#34;);
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 嵌套的 <code>whenever</code> 块可能看起来有些奇怪, 但这很好。你可以随时通过这种方式在 <code>react</code> 内添加更多 <code>whenever</code> 块。</p>
</div>
<div class="paragraph">
<p>外层的 <code>whenever</code> 侦听新的连接对象。它在这里唯一的工作就是将连接注册为服务器的另一个 <code>whenever</code> 块。要知道, 使用这种策略确实意味着你要异步处理所有的连接, 就像从一个线程来的一样。一个更具可扩展性的解决方案可能是为每个到达的连接使用一个 <code>start</code> 块(看起来像这样):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">start react whenever $conn.Supply.lines -&gt; $line { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>继续前进, 内部的 <code>whenever</code> 会在每个连接到达时监视它的输入行。每当客户端发送了一行输入, 它就会接收到一条消息。这段代码会解析这一行, 执行表达式(或发现错误), 并返回结果。</p>
</div>
<div class="paragraph">
<p>很简单。</p>
</div>
<div class="paragraph">
<p>我们调用 <code>listen</code> 在指定的地址和端口号上建立一个侦听的 TCP 套接字。这将返回一个 <a href="https://docs.raku.org/type/Supply">Supply</a>, 它将发出已连接的 IO::Socket::Async 对象。每当从关联的客户端发送时, 就可以使用连接对象上的 <code>Supply</code> 方法来获取文本（或通过 <code>:bin</code> 选项获取字节）。你可以使用 <code>write</code> 和 <code>print</code> 方法来发送字节和文本。</p>
</div>
<div class="paragraph">
<p>客户端也可以使用 <code>IO::Socket::Async</code> 来编写。下面是一个使用我们的表达式服务器来计算斐波那契序列的客户端:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my ($a, $b) = (0, 1);
say &#34;$a&#34;;
say &#34;$b&#34;;
await IO::Socket::Async.connect(&#39;127.0.0.1&#39;, 3456).then: -&gt; $connection {
  given $connection.result -&gt; $conn {
    $conn.print(&#34;$a + $b\n&#34;);

    react {
      whenever $conn.Supply.lines -&gt; $line {
        $a = $b;
        $b = +$line;
        say &#34;$b&#34;;
        $conn.print(&#34;$a + $b\n&#34;);
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>连接客户端时, 我们使用带有 IP 地址或服务器主机名的 <code>connect</code> 方法进行连接。该方法返回一个 <a href="https://docs.raku.org/type/Promise">Promise</a>, 一旦建立连接, 该 Promise 就会被保留。这个 Promise 的结果是一个连接的 <code>IO::Socket::Async</code> 对象, 它的使用方法和服务器完全一样, 其中 <code>Supply</code> 返回文本或字节, 而 <code>write</code> 和 <code>print</code> 用于发送文本或字节。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/archive/2019/12/22/asynchronous-socket.html" class="bare">https://zostay.com/archive/2019/12/22/asynchronous-socket.html</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_异步锁">74. 异步锁</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 实际上提供了两个不同的锁定类。<a href="https://docs.raku.org/type/Lock">Lock</a> 对象提供了一个非常标准的锁机制。当使用了 <code>.lock</code> 和 <code>.unlock</code> 或者调用了 <code>.protect</code> 时, 你会得到一段代码, 这段代码暂停直到锁释放, 在保持锁的同时运行, 然后释放锁, 这样其他可能在锁上等待的代码就可以运行。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/23/asynchronous-locking/cover-rich-smith-Y8gO2d7ByjY-unsplash_hu21d7ace117197dacae725fe40d0f6a55_1897495_280x280_fill_q75_box_smart1.jpg" alt="Asynchronous Locking"/>
</div>
</div>
<div class="paragraph">
<p>然而, <code>Lock</code> 类的工作方式会阻塞当前线程。正如我在前面的降临日历中所指出的那样, 线程的目的是做事情, 所以阻止线程运行就是阻止线程实现自己的目的。幸运的是, 有一个解决方案。</p>
</div>
<div class="paragraph">
<p>如果你想要锁定, 但又不想在等待锁释放的时候烧掉线程, 可以考虑使用 <a href="https://docs.raku.org/type/Lock::Async">Lock::Async</a> 代替 <code>Lock</code>。它的工作原理与 <code>Lock</code> 非常相似, 但 <code>.lock</code> 方法不会阻塞。相反, 它返回一个 Promise, 当锁被释放时, 这个 <a href="https://docs.raku.org/type/Promise">Promise</a> 将被保留。等待该 Promise 的代码将以一种允许 Raku 为另一个任务重用当前线程的方式暂停。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class SafeQueue {
    has @!queue;
    has Lock::Async $!lock .= new;

    method enqueue($value) {
        await $!lock.lock;
        push @!queue, $value;
        $!lock.unlock;
    }

    method dequeue(--&gt; Any) {
        $!lock.protect: { shift @!queue }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码演示了 <code>.lock</code> 和 <code>.unlock</code> 以及 <code>.protect</code> 的使用。你应该总是优先选择 <code>.protect</code>, 因为如果在获取锁后发生异常, 上面 <code>enqueue</code> 中的代码可能会让锁永远保持。从你的程序的角度来看, <code>.protect</code> 的行为介于 <code>Lock</code> 和 <code>Lock::Async</code> 之间, 但在内部会对 <code>.lock</code> 方法执行一个 <code>await</code>。这意味着代码所运行的线程将被释放出来, 以便被另一个正在等待调度的任务使用。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/23/asynchronous-locking/" class="bare">https://zostay.com/posts/2019/12/23/asynchronous-locking/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_异步进程间通信">75. 异步进程间通信</h2>
<div class="sectionbody">
<div class="paragraph">
<p>标题里有很多大词。简单来说, 就是在后台运行一个程序, 并在输入和输出可用时与之交互。Raku 中用于完成这项工作的工具叫做 <a href="https://docs.raku.org/type/Proc::Async">Proc::Async</a>。如果你曾经处理过试图与外部进程安全通信、写入输入和从输出和错误流中读取的痛苦, 并对此感到厌恶, 我想你会喜欢 Raku 内置的工具。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/24/asynchronous-inter-process-communication/cover-pavan-trikutam-71CjSSB83Wo-unsplash_hu84979ebdeaf52e08bd584cf870e0475b_4309353_280x280_fill_q75_box_smart1.jpg" alt="Asynchronous Inter-Process Communication"/>
</div>
</div>
<div class="paragraph">
<p>首先, 让我们来构思一个问题。让我们做一个外部程序, 它把字符串作为输入, 并将其反转, 并在标准输出上输出。同时, 它在标准错误上报告给定的字符串是否为回文。我们可以这样写这个程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $*IN.lines -&gt; $line {
    my $rline = $line.flip;
    say $rline;
    note ($rline eq $line);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了让大家明白, 对于这个样本输入。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">spam
slap
tacocat</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将得到这样的输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">maps
False
pals
False
tacocat
True</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>True</code> 和 <code>False</code> 这两行是标准错误, 其他行为标准输出。清楚了吗？很好。</p>
</div>
<div class="paragraph">
<p>接下来, 为了完成我们的构思问题, 我们需要与这个程序进行交互, 只需写出一条消息, 比如 <code>tacocat is a palindrome!</code>。因为每当我们看到一个回文的时候就会很兴奋。否则我们什么都不想输出。让我们使用 <code>Proc:::Async</code> 来与我们的另一个程序进行交互, 我们称之为 <code>palindromer</code>, 以示欢喜。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    my $palindromes = Supplier.new;
    my $p = Proc::Async.new: &#39;./palindromer&#39;, :w;
    my @rlines;
    my @palindrome-checks;

    # Echo our own input
    whenever $*IN.Supply.lines -&gt; $line {
        $p.say: $line;

        # Let palindromer know when we run out of input
        LAST { $p.close-stdin }
    }

    # Watch for the reverse lines on palindromer&#39;s standard output
    whenever $p.stdout.lines -&gt; $rline {
        if @palindrome-checks.shift -&gt; $is-palindrome {
            $palindromes.emit: $rline;
        }
        else {
            push @rlines, $rline
        }
    }

    # Watch for the True/False output from palindromer&#39;s standard error
    whenever $p.stderr.lines -&gt; $is-palindrome {
        if @rlines.shift -&gt; $rline {
            $palindromes.emit: $rline if $is-palindrome eq &#39;True&#39;;
        }
        else {
            push @palindrome-checks, $is-palindrome;
        }
    }

    # PALINDROMES ARE EXCITING!
    whenever $palindromes.Supply -&gt; $palindrome {
        say &#34;$palindrome is a palindrome!&#34;;
    }

    # Quit when palindromer quits
    whenever $p.start { done }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 如果我们把和之前一样的输入管道到我们的新程序中, 我们应该得到这样的输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">tacocat is a palindrome!</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的代码处理了标准输出和标准错误不同步的潜在问题, 通过使用队列来积累两边的额外值。我们将发现的 palindromes 送入到一个名为 <code>$palindromes</code> 的中央<a href="https://docs.raku.org/type/Supplier">供应</a>中, 这样我们就可以有一个地方来打印我们发现的 palindromes。</p>
</div>
<div class="paragraph">
<p>在使用 <code>Proc:::Async</code> 时要注意的几个关键点。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>始终要把 <a href="https://docs.raku.org/type/Proc::Async#method_start">.start</a> 调用放在标准输出和标准错误的 tap 之后。否则, 可能会出现漏行的问题(即在你侦听之前发出的行)。顺便说一下, 如果 Raku 检测到你这样做了, 它就会警告你。这个方法会返回一个 <a href="https://docs.raku.org/type/Promise">Promise</a>, 当程序结束时, 这个 Promise 会被保留。</p>
</li>
<li>
<p>确保你在完成输入时使用 <a href="https://docs.raku.org/type/Proc::Async#method_close-stdin">.close-stdin</a> 来确保其他程序知道你已经完成了。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>否则, 还有一些更有趣的功能, 比如 <a href="https://docs.raku.org/type/Proc::Async#method_ready">.ready</a> 等, 你可能想在网上<a href="https://docs.rakue.org/type/Proc::Async">阅读更多</a>关于 Raku 参考文档的内容。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/24/asynchronous-inter-process-communication/" class="bare">https://zostay.com/posts/2019/12/24/asynchronous-inter-process-communication/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第一天_为什么_raku_是_advent_code_的理想语言">76. 第一天 - 为什么 Raku 是 Advent Code 的理想语言？</h2>
<div class="sectionbody">
<div class="paragraph">
<p>现在已经到了12月，是我最喜欢的两个科技界传统的时候了：<a href="https://raku-advent.blog/">Raku Advent Calendar</a> 和 <a href="https://adventofcode.com/2020/about">Advent of Code</a>。这两个节日传统有一个相当多的共同点 - 它们都从12月1日一直持续到圣诞节，并且都涉及到在活动期间每天发布新的东西。具体来说，Raku Advent Calendar 会发布一篇关于 <a href="https://www.raku.org/">Raku 编程语言</a>的新博文，而 Advent of Code 则会发布一个新的编程挑战 - 可以用任何语言解决。</p>
</div>
<div class="paragraph">
<p>(在这篇文章中，我将把&#34;代码降临&#34;称为 &#34;AoC&#34; - 不要与美国政治家 <a href="https://en.wikipedia.org/wiki/Alexandria_Ocasio-Cortez">AOC</a> 混淆，据我所知，他并没有用 Raku 编程)。</p>
</div>
<div class="paragraph">
<p>对我来说，Raku 和 AoC 是科技降临季的巧克力和花生酱：每一个都是单独的好东西，但它们结合起来会更好。如果你的唯一目标是解决 AoC 挑战，那么 Raku 是一种很好的语言；另一方面，如果你的唯一目标是学习 Raku，那么解决 AoC 挑战是一种很好的方式。这篇文章将解释 Raku 和 AoC 是如何如此契合的，然后提供一些资源来帮助我们大家开始解决 AoC 挑战。</p>
</div>
<div class="sect2">
<h3 id="_什么是_raku你为什么要关心">76.1. 什么是 Raku？(你为什么要关心？)</h3>
<div class="paragraph">
<p>由于 Raku 是一种相对较新的编程语言，至少你们中的一些人可能对它不熟悉，也不知道为什么它值得学习。Raku 是<a href="https://www.reddit.com/r/rakulang/comments/ixo408/how_would_you_describe_raku_in_one_sentence/">众所周知的很难</a>用一句话来描述的，但这是我的尝试。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Raku 是一种简洁的，富有表现力的，积极的多范式语言，具有强推断类型，内置的并发性，丰富的元编程，以及一流的字符串处理和模式匹配。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>这在实践中意味着，我发现自己越来越多地接触到 Raku。当遇到几乎所有的问题时，我一直认为 Raku 是一种能让我以最清晰、最快速、最优雅的方式解决它的语言。(唯一的例外是，如果解决我的问题需要编译语言的原始速度或低资源使用。但即使在这种相对罕见的情况下，我可能会用 Rust 写代码中性能关键的部分，而用 Raku 写其他部分，以利用<a href="https://raku-advent.blog/2019/12/13/day-4-a-little-rr/">这两种语言的良好配合</a>。)</p>
</div>
<div class="paragraph">
<p>这并不是说 Raku 是一种试图对所有人都适用的语言。事实上，Raku 难得的、像激光一样关注个人的生产力，并且愿意牺牲一些标准的企业/大型团体功能来实现这个目标，正如我之前详细讨论过的那样（<a href="https://www.codesections.com/blog/raku-manifesto/">第一部分</a>，<a href="https://www.codesections.com/blog/raku-manifesto-2/">第二部分</a>，<a href="https://www.codesections.com/blog/raku-manifesto-3/">第三部分</a>）。但是，即使抛开这些大局观的想法，Raku 也是一种充满了有趣想法的语言。如果这些想法有我相信的一半那么好，那么 Raku 就是你在工具箱中想要的一门语言。</p>
</div>
</div>
<div class="sect2">
<h3 id="_为什么_raku_非常适合解决_aoc_挑战">76.2. 为什么 Raku 非常适合解决 AoC 挑战？</h3>
<div class="paragraph">
<p>我相信，Raku 很适合解决许多不同的问题，但它绝对是代码降临挑战的绝佳选择。为了解释原因，我将介绍一下我们希望从理想的 AoC 语言中得到什么。然后，我会介绍一个去年第一个 AoC 挑战的 Raku 解决方案，并将其与我们的理想进行比较。(Spoiler: they’re really similar!)</p>
</div>
<div class="paragraph">
<p>当思考理想的 AoC 语言时，我想到的 AoC 的第一个特点是，它是一系列小的，基本上自成一体的谜题，而不是一个大型项目。这说明理想的语言应该是简明扼要、低锅炉板的。当建立一个大型项目时，处理许多行的锅炉模板是很烦人的，但可以忍受，但如果在 AoC 的每一天都重复这样做，那就糟糕多了。而且，由于我们将分享我们的代码，保持简洁将有助于其他人看到我们的逻辑，而不会被内务细节所干扰。</p>
</div>
<div class="paragraph">
<p>我们可以说得更具体一些：AoC 挑战赛通常会提供文本输入，并寻找文本输出；它们通常也会提供几个测试用例，有助于制作一个可行的解决方案。因此，除了在一般情况下简明扼要之外，我们理想的语言还应该为脚本和测试提供低锅炉板的解决方案。</p>
</div>
<div class="paragraph">
<p>也许 AoC 最显著（当然也是最有趣的！）的特点是它的社区驱动和教育性：数以千计的程序员都在或多或少地解决相同的难题，然后将他们的解决方案发布到 <a href="https://www.reddit.com/r/adventofcode/">Advent of Code 子 reddit 上</a>。从阅读其他解决方案 - 包括不同语言的解决方案 - 中学到的东西和你自己解决难题一样多，甚至更多，这是非常常见的。这意味着我们理想中的语言应该是可读的、优雅的，即使对于没有太多语言经验的人来说也是如此。</p>
</div>
<div class="paragraph">
<p>当然，虽然能够写出让不熟悉语言的人也能欣赏的代码是件好事，但我们的大部分教学和学习将来自于将我们的解决方案与同一种语言的其他解决方案进行比较。毕竟，同一语言中的不同解决方案往往会显示出做出不同权衡的方法，并能帮助我们扩展编程工具集。或者至少在我们的语言中不同的解决方案是，嗯，不同的情况下会发生这种情况：如果我们的语言将每个人都推向一个单一的，明显的解决方案，那么这种学习的空间就会少很多。所以我们理想的语言应该提供不止一种解决任何特定挑战的方法。</p>
</div>
<div class="paragraph">
<p>我相信我还可以继续说下去，但似乎我们已经有了一个很好的清单。总而言之，我们正在寻找一种语言，这种语言要简洁、低模板，特别是对于脚本和测试来说，并且允许为每个挑战提供多种不同的可读性和优雅的解决方案。(请注意，这个列表是关于寻找最好的语言来学习和享受 AoC。如果你的目标是在 AoC 排行榜上名列前茅，那么 Raku 出色的字符串处理功能仍然会让它成为一个<a href="https://blog.vero.site/post/advent-leaderboard#get-comfortable-with-your-language-standard-library-and-editor">很好的选择</a>。但是，从现实的角度来看，如果这是你的目标，你应该选择任何你最熟悉的语言）。)</p>
</div>
<div class="paragraph">
<p>现在我们知道了在理想的语言中我们会想要什么，让我们来看看去年第一个挑战的 Raku 解决方案。</p>
</div>
</div>
<div class="sect2">
<h3 id="_aoc_2019_raku_第1天">76.3. AoC 2019 Raku 第1天</h3>
<div class="paragraph">
<p>你可以阅读<a href="https://adventofcode.com/2019/day/1">完整的问题描述</a>来了解所有的细节，但简短的版本是，这个挑战要求我们根据飞船的质量，对发射飞船所需的燃料进行一些不同的计算。具体来说，在第一部分中，我们被告知。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>要找出一个模块所需的燃料， 取其质量，除以3，四舍五入，再减去2。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>因为 Raku 有<a href="https://docs.raku.org/language/operators#index-entry-Integer_division_operator">整数除法运算符</a>，所以这几乎是小菜一碟。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub fuel($mass) { +$mass div 3 - 2 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二部分要求我们进行类似的计算，但这次要考虑到我们要添加的燃料所增加的额外质量。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>燃料本身也需要燃料 就像一个模块一样 取它的质量，除以3，四舍五入，再减去2。然而，该燃料也需要燃料，该燃料也需要燃料，以此类推。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>为了解决这部分问题，我们可以使用第一部分的燃料函数来计算我们需要多少燃料，然后将我们的初始结果加到我们需要的新质量的燃料量上。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi total-fuel($mass) { fuel($mass).&amp;{$_ + .&amp;total-fuel} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二部分还告诉我们。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>任何需要负燃料的质量都应该被视为需要零燃料。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>同样，Raku 提供了一个强大的功能，使这个问题变得简单：在这种情况下，强大的功能是 Raku 针对<a href="https://docs.raku.org/type/Signature#index-entry-where_clause">函数签名</a>中的运行时值进行模式匹配的能力。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi total-fuel($mass where fuel($mass) ≤ 0) { 0 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这三行字，我们基本上就解决了这个挑战。当然，我们希望不仅能够对单个数字进行计算，而且能够对我们的整个输入进行计算（在这个挑战中，输入的形式是一个文本文件，每行有不同的数字）。我们还希望我们的脚本是可执行的，并能公开一个带有用户友好描述和—​帮助文本的 CLI。这个 CLI 应该允许用户选择我们的脚本是解决挑战的第一部分还是第二部分。</p>
</div>
<div class="paragraph">
<p>幸运的是，Raku 让我们只需要三行额外的代码和一个 shebang 注释就可以添加所有这些细节。到目前为止，我们的完整解决方案如下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku
unit sub MAIN( #=  Solve the 2019 AoC day 01 puzzle
    Bool :$p2  #={ Solve p2 instead of p1 (the default)} );
sub fuel($mass) { +$mass div 3 - 2 }
multi total-fuel($mass) { fuel($mass).&amp;{$_ + .&amp;total-fuel} }
multi total-fuel($mass where fuel($mass) ≤ 0) { 0 }

say lines.map($p2 ?? &amp;total-fuel !! &amp;fuel).sum;</code></pre>
</div>
</div>
<div class="paragraph">
<p>(第2行和第3行中的注释产生了 - 帮助文档。)</p>
</div>
<div class="paragraph">
<p>这个挑战还提供了7个测试用例，我们也许应该把它们包括进去。当在一个较大的 Raku 项目中工作时，<a href="https://docs.raku.org/language/testing">标准的方法</a>是将我们的测试分成一个单独的文件。但我们要<a href="https://www.perl.com/pub/2007/12/06/soto-11.html/">使用脚本</a>，如果放弃单文件的简单性，那就太可惜了。所以，我们不使用单独的文件，而是使用我<a href="https://www.codesections.com/blog/raku-unit-testing-with-conditional-compilation/">之前在博客中介绍过</a>的一种技术，使用 Raku 的条件编译将我们的测试包含在一个文件中，而不需要在每次运行脚本时执行它们。</p>
</div>
<div class="paragraph">
<p>使用这种技术，我们得到的最终代码（包括测试）是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku
unit sub MAIN( #=  Solve the 2019 AoC day 01 puzzle
    Bool :$p2  #={ Solve p2 instead of p1 (the default)} );
sub fuel($mass) { +$mass div 3 - 2 }
multi total-fuel($mass) { fuel($mass).&amp;{$_ + .&amp;total-fuel} }
multi total-fuel($mass where fuel($mass) ≤ 0) { 0 }

say lines.map($p2 ?? &amp;total-fuel !! &amp;fuel).sum;

# Tests (run with `raku --doc -c $FILE`)
DOC CHECK { use Test;
    subtest &#39;Part 1&#39;, { fuel(12).&amp;is:            2;
                        fuel(14).&amp;is:            2;
                        fuel(1_969).&amp;is:         654;
                        fuel(100_756).&amp;is:       33_583; }
    subtest &#39;Part 2&#39;, { total-fuel(14).&amp;is:      2;
                        total-fuel(1_969).&amp;is:   966;
                        total-fuel(100_756).&amp;is: 50_346; }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_将_raku_与理想的_aoc_语言进行比较">76.4. 将 Raku 与理想的 AoC 语言进行比较。</h3>
<div class="paragraph">
<p>那么，Raku 在我们之前提出的指标上表现如何呢？好吧，就简洁和低模板而言，这段代码似乎做得还不错。的确，它远没有达到最大程度的简洁；它比我去年在 <a href="https://en.wikipedia.org/wiki/APL_(programming_language">Dyalog APL</a>#Dyalog_APL 中解决这个挑战时<a href="https://fosstodon.org/@codesections/103233204678110012">想出的方案</a>要长7倍左右。) 不过，程序的代码只有6行，7个测试用例的代码只有9行，我还是会给它打分，认为它是高度简洁的。作为对比，一个<a href="https://github.com/thorstel/Advent-of-Code-2019/blob/master/day01/src/main.rs">强势的 Rust 解法</a>在方案上用了27行代码，测试上用了17行代码。</p>
</div>
<div class="paragraph">
<p>而在支持脚本和测试的同时，又消除了锅炉模板，Raku 的代码就非常理想了。开头的 shebang 一行是锅炉模板，但对于用任何语言创建一个独立的脚本都是必不可少的。除了这一行，唯一可以说是模板的部分是使用测试行和单元子 MAIN 行。这些行给我们提供了一个经过测试的脚本和一个完整的文档化的 CLI - 这是 Rust 和上面链接的 APL 例子都没有提供的。考虑到我们得到的回报，我准备给这个解决方案打满分，因为它支持脚本和测试而不依赖模板。</p>
</div>
<div class="paragraph">
<p>判断 Raku 解决方案的可读性和优雅程度当然涉及到更多的主观性。而且，可以说，懂 Raku 的人最没有资格判断代码对于不懂 Raku 语言的程序员的可读性。也就是说，在我看来，这个解决方案的可读性足够强，一个非 Raku 程序员也可以遵循它—​同时仍然利用了足够多的 Raku 的聪明特性，使其变得优雅。一个非 Raku 程序员可能不知道 <code>div</code> 操作符，但可以从上下文和合理的假设中找出它，它必须做一些不同于/操作符的事情。<code>fuel($mass).&amp;{ $_ + total-fuel($_) }</code> 这一行也可能会让一个非 Raku 程序员慢下来—​特别是如果他们没有遇到 Perl 中的 $_ 主题变量的话。但是，我相信他们也能很快地从上下文中找出答案。而且，一旦他们明白了，我打赌他们会很欣赏重用（而不是重新计算）<code>fuel($mass)</code> 值的优雅，而不需要创建和命名一个临时值。</p>
</div>
<div class="paragraph">
<p>最后一个对非 Raku 程序员来说可能会很陌生的片段是 <code>$mass where fuel($mass) ≤ 0</code> 部分。但是，在我看来（诚然有失偏颇！），这个片段既清晰又立即优雅 - 它如此完美地抓住了&#34;只有当 $mass 小于或等于0时才调用这个函数&#34;的意图，这是大多数其他编程语言无法用函数签名表达的。我知道优雅是看人下菜碟，但这个片段和整个脚本都非常符合我的定义。</p>
</div>
<div class="paragraph">
<p>我们的最后一个标准 - Raku 是否提供了不止一种解决这个挑战的方法—​从单一的解决方案中本质上是无法判断的。但在 Raku 中，不管它指的是什么，总是有不止一种方法。一个相对较小的改变就是向乐库的类型系统靠拢。因为 Raku 有如此强大的类型推理能力，所以可以像写动态类型语言一样来写。但是 Raku 有一个强大的类型系统，允许你约束你的函数接受的类型。</p>
</div>
<div class="paragraph">
<p>例如，在当前的代码中，我们有函数 <code>sub fuel($mass) { +$mass div 3 - 2 }</code>。这个函数可以接受任何类型的增量 (随后用 <code>+</code> 操作符将其转换为数字类型)，但不保证其返回类型。这种灵活性是很好的 - 当我们从  stdin 传递输入时，它可以让我们用 Str 来调用 fuel，而当我们递归调用它时，则用 Int 来调用。如果我们想要更多的类型安全（在一个较长的程序中，我们很可能会这样做），我们可以像这样确定参数和返回类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub fuel(Int $mass --&gt; Int) { $mass div 3 - 2 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于这个函数只接受 Ints，所以我们不需要在函数体里面加上 <code>+</code>，但是我们需要在调用 <code>fuel</code> 之前对输入进行解析。我们可以用很多方法来实现；我可能会在我们的 <code>lines</code> 管道中添加一个 <code>.map(+*)</code> 方法调用。</p>
</div>
<div class="paragraph">
<p>另一种选择是使用<a href="https://docs.raku.org/type/Signature#Coercion_type">强制类型的约束</a>，在安全性和灵活性之间取得一些中间地带。这将导致 <code>sub fuel(Int() $mass -→ Int)</code> 的签名。<code>Int()</code> 部分约束函数接受一个可以被转换为 Int 的类型，并自动执行转换。使用这个签名，我们可以避免使用 <code>+$mass</code> 或 <code>.map(+*)</code>。</p>
</div>
<div class="paragraph">
<p>添加类型安全只是我们可以用不同的方式来解决这个问题的一种方法。我们也可以使用一个带有计算终点的<a href="https://docs.raku.org/language/operators#index-entry-sequence_operator">序列</a> (例如，$_, total-fuel($_) ...^ * ≤ 0) 来替代我们目前使用的 where 块。或者我们可以使用 reduce（无论是作为方法调用还是使用 <a href="https://docs.raku.org/language/operators#index-entry-">+</a>_(reduction_metaoperators[reduce 元操作符]））来代替单独的 <code>map</code> 和 <code>sum</code> 步骤。或者我们可以通过使用 <a href="https://docs.raku.org/syntax/gather%20take">gather 和 take</a> 来进一步远离 <code>map</code>。简而言之，即使是像这样简单的问题，我们也有大量的方法可以使用 Raku - 这还没有提到我们可以使用 Raku 强大的、内置的并发支持来并行化我们的解决方案的方法，如果出于某种原因，我们想要提升性能的话。无论你个人如何解决 AoC 挑战，我敢打赌，你可以通过看看人们在 Raku 中提出的各种其他解决方案来学习一些东西。</p>
</div>
<div class="paragraph">
<p>我知道，我们能从一个 AoC 挑战中得出多少结论是有限的 - 尤其是到12月，挑战的难度一般都会增加，这意味着第一天的挑战并不那么有代表性。我知道，并不是每个人都会认同我关于什么是适合 AoC 的语言的定义。尽管如此，我希望我们对 AoC 挑战赛的详细研究已经足以说服您，Raku 是一种很有前途的语言，可以用于 AoC。如果您至少已经了解一些 Raku 语言，我希望您会同意，通过 AoC 挑战赛来学习是一个很好的选择（既可以提高 Raku 语言的水平，也可以分享您的知识）。如果你还不了解 Raku，我希望你至少能把 AoC 作为一个学习的机会。</p>
</div>
<div class="paragraph">
<p>如果是这样，我有一些好消息。AoC 是学习 Raku 的绝佳途径。</p>
</div>
</div>
<div class="sect2">
<h3 id="_为什么_aoc_是学习_raku_的好方法">76.5. 为什么 AoC 是学习 Raku 的好方法？</h3>
<div class="paragraph">
<p>要想知道为什么 AoC 是学习 Raku 的好方法，我想从另一个问题开始：学习 Raku 有多难？</p>
</div>
<div class="paragraph">
<p>对于这个问题，有两种不同的观点。从一个角度来看，Raku 非常难学 - 几乎和 <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language">Scheme</a>）容易学的方式完全一样。著名的 Scheme 几乎没有语法；你可以很容易地坐下来，一次就能学会 Scheme 的全部语法。(当然，掌握这门语言需要的时间要长得多)。</p>
</div>
<div class="paragraph">
<p>Raku 几乎占据了相反的极端：它大量使用语法。我不认为有什么特别原则性的方法来衡量不同编程语言的&#34;大小&#34;，但<a href="https://learnxinyminutes.com/">《Y分钟内学会X》</a>系列指南可能会提供一个大致的近似值。对比<a href="https://learnxinyminutes.com/docs/CHICKEN/">《Learn X in Y minutes》（其中X=CHICKEN Scheme）</a>指南和<a href="https://learnxinyminutes.com/docs/raku/">《Learn X in Y minutes》（其中X=Raku）</a>指南，我看到 Raku 的指南大约有7倍的行数；我可以理解为什么有人会得出Y的值在这两个公式中很不一样的结论。</p>
</div>
<div class="paragraph">
<p>而且语法并不是 Raku 是一种大型语言的唯一方式。我之前形容 Raku 是&#34;积极的多范式&#34;；一个<a href="https://www.evanmiller.org/a-review-of-perl-6.html">有影响力的评论</a>称 Raku 是&#34;多范式，也许是全范式&#34;。不管你怎么说，很明显，你可以用很多不同的方式来写 Raku。你可以<a href="https://docs.raku.org/language/101-basics">用程序化的方式来写</a>，如果你愿意的话，可以用显式 <code>for</code> 循环来完成。它还对<a href="https://docs.raku.org/language/101-basics">函数式编程</a>提供了<a href="https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming/">一流的支持</a>（包括对<a href="https://wimvanderbauwhede.github.io/articles/function-types/">函数类型</a>、<a href="https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/">抽象数据类型</a>以及<a href="https://wimvanderbauwhede.github.io/articles/universal-interpreter-part-1/">其他高级函数式特性</a>的支持，而这些特性是多范式语言经常从其函数式工具箱中省略的）。您也可以编写纯<a href="https://docs.raku.org/language/objects">面向对象的 Raku</a>，事实上，该语言本身就是从 OO 的角度构建的。Raku 还从<a href="https://docs.raku.org/language/list#index-entry-Shaped_arrays">数组编程</a>、<a href="https://docs.raku.org/type/Signature#Type_constraints">约束编程</a>和<a href="https://docs.raku.org/routine/==%3E">数据流编程</a>中借鉴了许多思想，它支持并发编程、通用编程和极强的<a href="https://docs.raku.org/language/mop#index-entry-Introspection">自省</a>和<a href="https://docs.raku.org/language/mop">元编程</a>。</p>
</div>
<div class="paragraph">
<p>真正掌握 Raku 并不仅仅意味着了解它的所有广泛的语法，它甚至不意味着熟悉 Raku 支持的许多不同的范式。要想完全精通 Raku，需要有判断力来<a href="https://www.oreilly.com/radar/multi-paradigm-languages/">决定哪种范式最适合今天的问题</a>，并能自如地正确应用该范式。从这个角度来看，Raku 是一门极难学的语言 - 虽然这样做的回报让它值得。</p>
</div>
<div class="paragraph">
<p>但还有另一种观点说，Raku 其实很容易学。</p>
</div>
<div class="paragraph">
<p>诚然，如果你试图在没有上下文的情况下一次性学会所有 Raku 的语法是很难的。但你不应该这样做，就像一个英语人试图通过坐下来用德语词典来学习德语一样。学习一门语言的所有语法似乎是一件合理的事情，唯一的原因是有些编程语言是如此的微不足道，以至于一次全部学习的方法不会立即造成灾难性的后果。但这并不意味着这种方法就是一个好主意。</p>
</div>
<div class="paragraph">
<p>相反，学习 Raku 的方法是学习足够的知识，然后开始使用它，并在你走的时候学习更多的知识。从这个角度来看，Raku 的大量语法与语言的难易程度无关 - 你并不是想一次性学会它，所以你开始学习的那点语法是一半还是只有 20% 都无所谓。而 Raku 的多范式特性实际上使 Raku 更容易倾斜而不是更难：因为 Raku 支持这么多不同的范式，你可以从你最初最舒服的任何 Raku 子集开始，然后从那里扩展出来。</p>
</div>
<div class="paragraph">
<p>现在，您可能已经明白了为什么我们花了这么长的时间来讨论学习 Raku 是容易还是困难：如果您试图以学习 Scheme 的方式来学习 Raku，您将会陷入艰难的困境。但是，如果你采取更零碎的方法，学习 Raku 就容易多了。而这种零敲碎打的方法也完美地映射到了通过《代码降临》学习 Raku 上。</p>
</div>
<div class="paragraph">
<p>具体来说，要想用零敲碎打的方法取得成功，你需要在一系列小项目上下功夫，即使你只知道语言的一角，每个项目也是可以管理的。它们需要是风险相对较低的项目 - 因为你还不知道解决一个问题的所有不同方法，所以有时候你很有可能会实现一个次优的解决方案。而且，最重要的是，你需要在一个能让你看到其他方法的上下文中完成它们。从面向对象的 Raku 子集开始，并从你的舒适区之外逐渐添加技术，是学习 Raku 的好方法，但只有当你真正做到 &#34;逐渐添加技术&#34;的部分，它才会有效。如果你陷入了困境，你就学不到那么多东西，而看到其他人使用不同的技术来更优雅地解决同样的问题是避免那种困境的最好方法。</p>
</div>
<div class="paragraph">
<p>简而言之，如果你想在 Raku 中取得更好的成绩，最好的方法莫过于通过尽可能多的&#34;代码降临&#34;挑战，将你的解决方案与其他 AoC 解决方案（在 Raku 和其他语言中）进行比较和对比，并批判性地思考各种方法的优缺点。</p>
</div>
</div>
<div class="sect2">
<h3 id="_让我们一起努力吧">76.6. 让我们一起努力吧</h3>
<div class="paragraph">
<p>为了让我们更容易找到彼此的&#34; Raku 代码降临&#34;解决方案，我创建了一个可以容纳所有解决方案的 GitHub 仓库：<a href="https://github.com/codesections/advent-of-raku-2020">codeections/advent-of-raku-2020</a>。我将有意保持这个仓库的最小化 - 如果 Raku 不是那么善于避免模板，我会添加一个设置 AoC 解决方案的模板。但是，考虑到 Raku 所需要的模板很少，我计划将 Repo 简单地作为我们解决方案的主机和相关资源的链接。</p>
</div>
<div class="paragraph">
<p>如果您希望您的解决方案被包含在内，请提交一个 PR，添加一个 <code>$your-name</code> 文件夹，其中包含您的解决方案（细节在 README 中）。当然，将您的解决方案发布到 Advent of Raku repo 并不妨碍您将其发布到其他您想发布的地方，无论是您自己的网站、<a href="https://www.reddit.com/r/rakulang/">Raku 子 reddit</a> 还是主 <a href="https://www.reddit.com/r/adventofcode/">AoC 子 reddit</a>。</p>
</div>
<div class="paragraph">
<p>请随时将您的解决方案添加到回帖中，甚至 - 特别是！如果您不确定您的解决方案是否符合您的要求，也可以将其添加到回帖中。- 如果您不确定您是否有时间完成所有的 AoC 挑战，或者您是 Raku 的新手，不确定您是否会在第一天就坚持使用这门语言，请将您的解决方案添加到仓库中。毕竟，所有这一切的目的都是为了共同学习，我们可以通过将具有尽可能广泛的观点和背景的人聚集在一起来达到最好的目的。</p>
</div>
<div class="paragraph">
<p>我还注册了一个 Raku 社区的<a href="https://adventofcode.com/2020/leaderboard/private">私人排行榜</a>，你可以通过登录，按照这个链接，然后输入代码 407451-52d64a27 进入（如果有必要，我可以修改这个代码，更安全地分发，但我预计不会有任何问题）。尽管有&#34;排行榜&#34;这个名字，但我认为这并不是一个竞争性的排名，更多的是一种跟踪谁在参与的方式 - 就我个人而言，我并不打算急于完成挑战，也不打算在任何基于时间的指标上提高我的分数（事实上，考虑到我的时区和我通常的日程安排，我怀疑我是否会在大多数谜题发布几个小时后才开始）。</p>
</div>
<div class="paragraph">
<p>我很期待看到你的解决方案；我相信我们可以从彼此身上学到很多东西。我也期待着讨论我们所采取的不同方法，不管是在 GitHub 问题上，还是在 Raku 或 AoC 子 reddits上，或是在 <a href="https://raku.org/community/irc">#raku</a> IRC 频道上（我会尽量关注所有这些频道）。祝大家好运，愿我们都有一个 -Ofun Advent。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二天_perl_is_dead_long_live_perl_and_raku">77. 第二天 - Perl is dead. Long live Perl and Raku.</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://perl.org/">Perl</a>已死，是一个完全错误的备忘录。<a href="https://www.perl.org/about.html">Perl 并没有死</a>，只是对一些程序员来说，它已经死了。复杂的 regexes？Sigils？有不止一种方法（<a href="https://docs.raku.org/language/glossary#TMTOWTDI">TMTOWTDI</a>）？有时候，当程序员在野外遇到 Perl 时，他们的反应是恐惧。他们喊道：&#34;WTF！？&#34;。但恐惧不一定是 Perl 的杀手。如果你花时间去看透 Perl 的不完美，<a href="https://www.perl.org/learn.html">走过学习曲线</a>，就会有丰富的回报。Perl 是一种不完美的语言，但它的实用性和表现力，30多年来，它帮助程序员完成了工作。</p>
</div>
<div class="paragraph">
<p>当 <a href="https://en.wikipedia.org/wiki/Larry_Wall">Larry Wall</a> <a href="https://github.com/Raku/mu/blob/master/AUTHORS">在 Perl 社区的帮助下</a><a href="https://design.raku.org/">设计</a><a href="https://raku.org/">Raku</a> 时，他修正了 Perl 的大部分不完美，并将 Perl 的 DNA 加倍发扬光大。Perl 重视实用主义、表现力和鞭策，Raku 也是如此。当你可以用 <a href="https://docs.raku.org/language/variables#Twigils">twigils</a>($!, %!, @!等)获得双倍的乐趣时，为什么要停留在 sigils($@%)上呢？</p>
</div>
<div class="paragraph">
<p>然而，对于一些程序员来说，仅仅是看到 twigil 就会产生恐惧。就像 Perl 一样，Raku 的表达能力是一把双刃剑 - 有可能让其他程序员止步不前。Raku 程序员的 &#34;DWIM&#34;（do what I mean）可能会成为另一个程序员的 &#34;WAT！？&#34;</p>
</div>
<div class="sect2">
<h3 id="_流畅的无畏代码">77.1. 流畅的无畏代码</h3>
<div class="paragraph">
<p>我们为两个受众编写程序：人类和计算机。应该首先考虑的是人类。如果我不能在一周内理解自己的代码，我的同事们还有什么希望？幸运的是，我们可以帮助自己，也可以帮助对方，在 Raku 学习曲线上有一个平稳的旅程。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://camo.githubusercontent.com/adae2c7bc72f3b2b7480d1769cd89dddab1eb4302e4cafd7930760a584477dfb/68747470733a2f2f7065726c36616476656e742e66696c65732e776f726470726573732e636f6d2f323031352f31322f63616d656c69612d666c6f77696e672e676966" alt="68747470733a2f2f7065726c36616476656e742e66696c65732e776f726470726573732e636f6d2f323031352f31322f63616d656c69612d666c6f77696e672e676966"/></span></p>
</div>
<div class="paragraph">
<p>学习 Raku 永远不会枯燥无味，但你上一次在学习 Raku 时遇到坎坷是什么时候？这是你帮助自己和他人的机会。你可以在你的代码中留下一条感同身受的评论，贡献一些文档，写一篇博文，做一次演讲，在 StackOverflow 上提问和回答问题等等。</p>
</div>
<div class="paragraph">
<p>编程的乐趣就是在完成事情的同时，为自己和对方<a href="https://perl6advent.wordpress.com/2015/12/20/perl-6-christmas-have-an-appropriate-amount-of-fun/">找到流</a>。不需要 Raku 摇滚明星。</p>
</div>
</div>
<div class="sect2">
<h3 id="_在学习曲线上冲浪">77.2. 在学习曲线上冲浪</h3>
<div class="paragraph">
<p>也许你还没有开始学习 Raku？现在是将 Raku 添加到你的工具箱的最佳时机。以下是我发现的一些有用的学习资源，我希望你也能做到。</p>
</div>
<div class="paragraph">
<p>首先，有一个精辟简洁的 <a href="https://raku.guide/">Raku</a> 介绍，其中包括如何安装 Raku 的说明。Raku 解释器本身也非常有用。如果你的 Raku 程序包含错误，<a href="https://perl6advent.wordpress.com/2016/12/19/fixing-flow/">Raku 通常会建议修复它们的方法</a>。</p>
</div>
<div class="paragraph">
<p>对于来自其他语言的程序员，<a href="http://www.rosettacode.org/wiki/Category:Raku">RosettaCode</a> 展示了不同语言的编码解决方案。准备好被 Raku 运算符的表现力所惊喜吧。Raku 的表现力通常会导致<a href="http://www.rosettacode.org/wiki/Last_Friday_of_each_month#Raku">更少的代码行数</a>（LLOC）。</p>
</div>
<div class="paragraph">
<p>你的第一个 Raku 程序的一个想法是翻译一个你熟悉的不同语言的程序。这里有一些从其他语言翻译到 Raku 的有用指南。<a href="https://docs.raku.org/language/5to6-nutshell">Perl</a>、<a href="https://docs.raku.org/language/py-nutshell">Python</a>、<a href="https://docs.raku.org/language/rb-nutshell">Ruby</a>、<a href="https://docs.raku.org/language/haskell-to-p6">Haskell</a> 和 <a href="https://docs.raku.org/language/js-nutshell">Javascript</a>。</p>
</div>
<div class="paragraph">
<p>关于 Raku 的书籍清单越来越多，还有一个<a href="https://perl6book.com/">选择流程图</a>。这里是一个选择:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.learningraku.com/">Learning Raku</a></p>
</li>
<li>
<p><a href="https://www.apress.com/gp/book/9781484261088">Raku Fundamentals</a></p>
</li>
<li>
<p><a href="https://www.apress.com/gp/book/9781484262573">Raku Recipes</a></p>
</li>
<li>
<p><a href="https://www.apress.com/gp/book/9781484232279">Parsing with Perl 6 Regexes and Grammars</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>搜索与 Raku 相关的问题通常会指向 <a href="https://docs.raku.org/">docs.raku.org</a> 的官方文档或 <a href="https://stackoverflow.com/questions/tagged/raku">StackOverflow 上的 Raku 答案</a>。</p>
</div>
<div class="paragraph">
<p>当你想了解更多关于特定子主题的信息，或者深入了解 Raku 更深层次的设计理念时，请查看 <a href="https://www.jnthn.net/slides.html">Jonathan Worthington 的清晰演示和解释</a>。</p>
</div>
<div class="paragraph">
<p>最后，如果你在某些事情上被卡住了，或者只是想分享学习 Raku 的<a href="https://www.raku.org/fun/">乐趣</a>，<a href="https://www.raku.org/community/irc">freenode 上的 #raku IRC 频道</a>是友好和欢迎的。</p>
</div>
<div class="paragraph">
<p>Perl 和 Raku 都是任何程序员工具箱中的有用工具：不需要害怕，只要记得帮助代码流动就可以了。</p>
</div>
<div class="paragraph">
<p>Perl 和 Raku 万岁。</p>
</div>
<div class="paragraph">
<p>圣诞快乐!</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_使用_raku_进行文化编程">78. 使用 Raku 进行文化编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>不同的编程语言社区有不同的文化。有些更务实，有些更理想化。有的非常强调让代码对于任何加入现有项目的人来说都是彻底可读可懂的，有的则更喜欢写出清晰而深入的文档。</p>
</div>
<div class="paragraph">
<p>Raku，继承了 Perl 最好的部分之一，有一个写出很棒文档的社区。</p>
</div>
<div class="sect2">
<h3 id="_什么是文化编程">78.1. 什么是文化编程？</h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Literate_programming">文化编程</a>是对文档的另一种看法。在 Literate Programming 中，我们不以代码为核心元素，而是围绕它来编写文档，我们编写的文档包含了我们程序的基本部分。通过这种方式，我们将代码融入到我们的自然语言中，使设计的基本思想变得清晰。通过这种方式，我们也自然而然地开始明确思考我们的程序需要执行哪些操作来完成我们设定的任务。</p>
</div>
<div class="paragraph">
<p>文化编程不能和文档生成混为一谈，它不仅仅是拥有一个文档齐全的程序，文档华丽地围绕着代码，并嵌入到代码中，而是拥有一个关于程序的文档，而程序本身也被嵌入其中。正如 Lewis Carroll 在《爱丽丝梦游仙境》中让疯帽子说的那样。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>你可以说&#34;我看到了吃的东西&#34;和&#34;我看到什么我就吃什么&#34;是一回事！</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="_什么是_org_mode">78.2. 什么是 Org-mode？</h3>
<div class="paragraph">
<p>林肯：https://orgmode.org/[Org-mode] 是 Emacs Lisp 解释器（可以说是文本编辑器）中的一种文本编辑模式。当启用 Org 模式时，人们可以使用一种特殊的标记类型编辑文本，称为 Org。与 Markdown 类似，它支持基本的文本功能，如标题，基本的文本属性，如粗体或斜体文本，嵌入式超链接，嵌入式代码块等。</p>
</div>
<div class="paragraph">
<p>然而，由于 Emacs 平台的通用性，Org 模式已经扩展了一个被称为 &#34;Babel&#34; 的设施，它允许作者执行源代码块。各种语言都是开箱即用的，不幸的是，尽管 Raku 已经很老了，但仍然是一种相当年轻的语言，不在其中。为了解决这个问题，我写了一个名为 <a href="https://github.com/tmtvl/ob-raku">ob-raku</a> 的软件包，它扩展了 Babel 的功能，将 Raku 添加到支持的语言中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_ob_raku">78.3. 使用 Ob-Raku</h3>
<div class="paragraph">
<p>要在 Emacs 中使用 ob-raku，你需要下载这个软件包（简单的从 GitHub 上克隆或者下载其中一个发布的 tar 包），并将其添加到 Emacs 的加载路径中。这可以通过环境变量来完成。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">export EMACSLOADPATH=&#34;/path/to/ob-raku:$EMACSLOADPATH&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者你可以更改你配置文件中的路径 (可能是 ~/.emacs 或 ~/.emacs.d/init.el):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-lisp" data-lang="lisp">(add-to-list &#39;load-path &#34;/path/to/ob-raku&#34;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>添加路径后，您可以将 Raku 添加到 Babel 可以使用的语言列表中，就像这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-lisp" data-lang="lisp">(org-babel-do-load-languages
 &#39;org-babel-load-languages
 &#39;((c . t)
   (emacs-lisp . t)
   ; ...
   (raku . t)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>随着 Raku 加入到列表中，你可以像这样创建一个 Raku 代码块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-lisp" data-lang="lisp">#+BEGIN_SRC raku
&#34;!dlroW ,olleH&#34;.flip
#+END_SRC</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过将光标放在代码块中或代码块的末尾，使用菜单栏或输入 C-c C-c（这是 Emacs 的 Ctrl+c Ctrl+c 的符号）来运算代码块。运算的结果将被添加到代码块之后。</p>
</div>
</div>
<div class="sect2">
<h3 id="_连接代码块">78.4. 连接代码块</h3>
<div class="paragraph">
<p>不幸的是，由于缺乏对 ob-raku 的会话支持，这意味着在一个代码块中声明的函数不能在其他代码块中使用。尽管如此，运算一个代码块的结果可以作为另一个代码块的参数，将它们串联起来。因此，当编辑一个 <code>.org</code> 文件时，我们可以写以下内容。</p>
</div>
<div class="paragraph">
<p>让我们用 Raku 做一个列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-lisp" data-lang="lisp">#+NAME: nested-list
#+BEGIN_SRC raku
my @a = ((&#34;A&#34;, &#34;B&#34;), (&#34;C&#34;, &#34;D&#34;))
#+END_SRC</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们也可以包括其他语言的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-lisp" data-lang="lisp">#+NAME: elisp-list
#+BEGIN_SRC emacs-lisp :results vector
&#39;(1 2)
#+END_SRC</code></pre>
</div>
</div>
<div class="paragraph">
<p>而现在我们将使用我们刚才定义的列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-lisp" data-lang="lisp">#+NAME: crosser
#+HEADER: :var a=nested-list() b=elisp-list()
#+BEGIN_SRC raku
my @crossed = @a X @b
#+END_SRC</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你运算 crosser 块时，Babel 将运算嵌套列表和 elisp-list 块，这两个块都返回列表，并将它们分配给 @a 和 @b 变量。由此产生的交叉列表将在 crosser 块的下方返回。</p>
</div>
</div>
<div class="sect2">
<h3 id="_编辑说明">78.5. 编辑说明</h3>
<div class="paragraph">
<p>这篇文章是在2020年2月底起草的，在Daniel Sockwell写出关于用Pod6进行扫盲编程的优秀<a href="https://www.codesections.com/blog/weaving-raku/">文章</a>之前。这篇文章不会提到用 Pod6 来做 Literate Programming，而是谈谈我写的一个 Emacs 包，在 Emacs <a href="https://orgmode.org/">Org-mode</a> 中使用 Raku。</p>
</div>
<div class="paragraph">
<p>写这篇文章的时候，Emacs 中的 Raku REPL 交互还在进行中，多亏了 Matías Linares，它后来得到了巩固。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论和感谢">78.6. 结论和感谢</h3>
<div class="paragraph">
<p>虽然 ob-raku 的功能仍然有限，但任何已经使用它来编写文档的人现在都可以实现 Raku 代码，从而显示出用我们可爱的通用语言表达的可重复的数据，一旦会话支持落地，Org-mode 内置的纠缠设施应该会给社区带来真正的 Literate Programming。</p>
</div>
<div class="paragraph">
<p>如果没有 raku-mode 的努力，ob-raku 的创建是不可能的，所以我想感谢每一个参与该项目的人的辛勤工作。虽然我们的社区规模不大，但有一些充满激情的人在努力改进我们每天使用的工具，这让我们的工作更加愉快，从而帮助我们继续前进，使我们的小天堂变得最好。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第四天_使用_raku_grammars_解析_clojure_命名空间形式">79. 第四天 - 使用 Raku grammars 解析 Clojure 命名空间形式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>有一天，我开始想，是否有可能解析 <a href="https://clojure.org/reference/namespaces">Clojure 命名空间</a>形式，并生成现实世界中 Clojure 项目中使用的各种命名空间的依赖关系图。虽然这是最初的动机，但我最终还是掉进了 <a href="https://docs.raku.org/language/grammars">Raku grammar</a> 的兔子洞，并且在学习如何使用它们的过程中度过了一段愉快的时光。我很高兴你能和我一起重温那段旅程。</p>
</div>
<div class="sect2">
<h3 id="_背景介绍">79.1. 背景介绍</h3>
<div class="sect3">
<h4 id="_grammar_3">79.1.1. Grammar</h4>
<div class="paragraph">
<p>非正式地说，grammar 可以被认为是一套描述语言的规则。有了这些规则，人们就可以有意义地解析（理解或解构成语法成分）一段文字。事实证明，这在计算机中是一项常见的任务。我们需要经常将程序从一种语言翻译成另一种语言。这就是编译器的工作。在能够翻译之前，编译器需要知道根据语言的 grammar，原始程序是否甚至是有效的。</p>
</div>
<div class="paragraph">
<p>虽然我们已经在理论上解释了什么是 grammar，但 Raku grammar 帮助我们将抽象的 grammar 建模为一个编程结构（<code>grammar</code> 关键字及其相邻的助手），我们可以使用它来执行解析任务。理解这种区别是很重要的。</p>
</div>
<div class="paragraph">
<p>一级 <a href="https://docs.raku.org/language/grammars">grammar</a> 被认为是 Raku 的革命性功能之一。通常情况下，你会发现 grammar 是作为一个库或一个独立的工具，但 Raku 已经全盘接受了它，并拥有一个强大的 grammar 实现，使大多数解析任务变得轻而易举。</p>
</div>
</div>
<div class="sect3">
<h4 id="_clojure">79.1.2. Clojure</h4>
<div class="paragraph">
<p><a href="https://clojure.org/">Clojure</a> 是一种现代 lisp，恰好是我在 <code>$DAYJOB</code> 中使用的语言。在大多数 Clojure 文件的顶部，都有一个导入各种内部和外部命名空间的形式。这样我们就可以把我们的项目整齐地组织成许多独立的文件，而不必把它们都放到一个大文件中。我们很快就会设计一个能够解析这些命名空间形式的 grammar。</p>
</div>
</div>
<div class="sect3">
<h4 id="_grammartracer">79.1.3. Grammar::Tracer</h4>
<div class="paragraph">
<p><a href="https://github.com/jnthn/grammar-debugger">Grammar::Tracer</a> 有助于找出你的 grammar 不匹配的地方，对于调试来说是非常宝贵的。在运行这些代码示例之前，请确保你安装了 Grammar::Tracer。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_让我们开始做饭吧">79.2. 让我们开始做饭吧</h3>
<div class="sect3">
<h4 id="_一个微不足道的例子">79.2.1. 一个微不足道的例子</h4>
<div class="paragraph">
<p>Clojure 命名空间是一个 Lisp 形式，正如预期的那样，它以开括号开始，以闭括号结束。让我们为一个最简单的 Clojure 形式 - 空列表写一个 grammar。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">()</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar EmptyLispForm {
    token TOP { &lt;lparen&gt; &lt;rparen&gt; }

    token lparen { &#39;(&#39; }
    token rparen { &#39;)&#39; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是我们能写的最简单的 grammar 之一。解析总是从 TOP 标记开始，并从那里递归到各个组件标记。我们只有两个这样的标记 <code>lparen</code> 和 <code>rparen</code>，用来表示左圆括号和右圆括号。玩玩 <a href="https://gist.github.com/samebchase/e988e1ed9609daffaf1849c2527af51d">trivial.raku</a>，看看我们如何解析这个。</p>
</div>
</div>
<div class="sect3">
<h4 id="_热身_用_raku_grammar_来回答一个老生常谈的面试问题">79.2.2. 热身: 用 Raku grammar 来回答一个老生常谈的面试问题</h4>
<div class="paragraph">
<p>问题：写一个检查小括号是否平衡的程序。</p>
</div>
<div class="paragraph">
<p>比如说:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">() ;; balanced
(()) ;; balanced
(()(())) ;; balanced
(()(((()))) ;; unbalanced</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar BalancedParens {
    token TOP { &lt;balanced-paren&gt; }

    token balanced-paren { &lt;lparen&gt; &lt;balanced-paren&gt;* &lt;rparen&gt; }

    token lparen { &#39;(&#39; }
    token rparen { &#39;)&#39; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>很有可能我把这段话写得太啰嗦了，但还是只有六行相当易读的文字。</p>
</div>
<div class="paragraph">
<p>现在，在时间压力下，哪种可能性更大？编码堆栈并处理边缘情况，还是使用 grammar 与 Grammar::Tracer 的威力来快速破解一个声明式解决方案。</p>
</div>
<div class="paragraph">
<p>事实证明，我们刚刚解决了编写现实世界 grammar 中最棘手的一个方面，那就是处理嵌套结构。作为程序员，我们知道当我们看到嵌套结构时，我们知道我们将不得不以某种形式处理递归。</p>
</div>
<div class="paragraph">
<p>你可以在控制台上玩玩 <a href="https://gist.github.com/samebchase/fad8108cb6daeaf8043d92a40eb29276">balanced-parens.raku</a> 程序，观察一下 grammar 是如何解析的。</p>
</div>
<div class="paragraph">
<p>注意：事实证明，还有<a href="https://docs.raku.org/language/regexes#Tilde_for_nesting_structures">更好的</a>方法来解析嵌套结构，但现在这样就可以了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解析我们的第一个命名空间形式">79.2.3. 解析我们的第一个命名空间形式</h4>
<div class="paragraph">
<p>让我们试着解析一下这个简单的命名空间声明。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">;; 1   3
   |   |
;; (ns my-own.fancy.namespace)
    |                        |
;;  2                        4</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然这很简单，但在处理更复杂的命名空间形式时，它将是一个重要的构件。让我们把它分解成四个组件<a href="https://en.wikipedia.org/wiki/Lexical_analysis#Lexeme">词条</a>。我们可以看到 open 和 close parens，我们看到 ns，命名空间 my-own.fancy.namespace，最后是 close paren。就是这样! 让我们用一个 grammar 来处理这些单独的部分。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar SimpleNs {
    token TOP { &lt;simple-ns&gt; }

    #                  1        2            3         4
    #                  |        |            |         |
    token simple-ns { &lt;lparen&gt; &lt;ns-keyword&gt; &lt;ns-name&gt; &lt;rparen&gt; }

    token ns-keyword { &#39;ns&#39; }
    token ns-name { &lt;.ns-name-component&gt;+ % &#39;.&#39; }
    token ns-name-component { ( &lt;.alnum&gt; | &#39;-&#39; )+ }

    token lparen { &#39;(&#39; }
    token rparen { &#39;)&#39; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这边我们可以看到，我们已经将其翻译成了简单的 Raku grammar。你可以说定义 simple-ns 根本不需要，我们可以直接把它放在 top 中，但不管怎样。</p>
</div>
<div class="paragraph">
<p>我们需要在这里处理一下 <a href="https://en.wikipedia.org/wiki/Regular_expression">regexes</a> 的问题。在各种风味的 regexes 中，<code>+</code> 通常意味着一个或多个。<code>|</code> 的含义与你所期望的略有不同，但你可以查看 regex <a href="https://docs.raku.org/language/regexes">文档</a>来了解 <code>|</code> 和 <code>||</code> 之间的所有细节区别。通俗地说，我们是说一个命名空间组件，即两个点之间的东西，是由一个或多个字母字符或连字符组成的。现在，如果有一个规则说一个命名空间必须以字母字符开始，而不是以数字开始，那么 grammar 会变得更复杂一些，但这是一个教育学的例子，所以我们不会太迂腐。</p>
</div>
<div class="paragraph">
<p>我希望眼尖的读者能指出一些问题。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;.alnum&gt; 是在哪里定义的，为什么前面有一个点？</pre>
</div>
</div>
<div class="paragraph">
<p>alnum 是预定义的。它前面有一个 <code>.</code> 的原因是，我们对捕捉每个字母不感兴趣，因为它的层次太低。我们感兴趣的是捕获一个顶层的标记，比如 ns-name，而不是每个单独的字符。通过在不同的标记中添加和删除一个点来玩玩代码示例，看看 Grammar::Tracer 的输出有什么不同。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% 是什么意思？</pre>
</div>
</div>
<div class="paragraph">
<p>这是一个非常有用的方便方法，用来描述在一堆其他事物之间穿插的模式。例如，我们可以有一个像 foo.bar.baz 这样的命名空间，或者我们可以有一个 192.168.0.1 的 IPv4 地址，其中整数用点来分隔。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token ns-name { &lt;.ns-name-component&gt;+ % &#39;.&#39; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着 ns-name 是由至少一个 ns-name-component’s（用 <code>+</code> 表示）和 <code>.</code>（用 % 表示）分开。</p>
</div>
<div class="paragraph">
<p>好了，我想这应该可以了吧？让我们看看当我们运行这段代码的时候会发生什么吧</p>
</div>
<div class="paragraph">
<p>不，这并不奏效。正如 Grammar::Tracer 告诉我们的那样，我们没有考虑到 <code>ns</code> 后面的空间。在传统的编译器理论中，有一个标记化的过程，在这个过程中，一些轻量级的 regexes 被用来将程序分离成它的组件词素，并在解析器接管之前丢弃所有无关的空间。然而，在这里我们不会这样做，我们将在 grammar 本身中处理这个问题。现在，可以争论这是否是一个好的决定，但这是另一个讨论。让我们增加一些留白的空间，看看会发生什么。在构建完整的 Clojure NS 语法时，我让自己陷入了这样的境地：在我认为我们应该允许可选择的空白字符的地方，我自由地使用 <code>&lt;.ws&gt;*</code> 表示零或更多的空白字符，就像你在现实世界的程序中所期望的那样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token simple-ns { &lt;lparen&gt; &lt;ns-keyword&gt; &lt;.ws&gt; &lt;ns-name&gt; &lt;rparen&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这个小小的补充，我们现在就可以解析简单的命名空间形式了。你可以玩玩 <a href="https://gist.github.com/samebchase/0820b9ecfdb011a9b73aedfb4ba349d1">simple-ns.raku</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_让我们让生活变得更加困难吧">79.2.4. 让我们让生活变得更加困难吧</h4>
<div class="paragraph">
<p>好了，现在我们已经掌握了诀窍，那么我们来看一个更<a href="https://gist.github.com/samebchase/3debbe6190eb1c8f5325ae2640840db4">现实</a>一点的命名空间形式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns my-amazing.module.core
  (:require [another-library.json.module :as json]
            [yet-another.http.library :as http]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个现实的命名空间形式，我们将通过增加对 <code>:require</code> 形式的支持来解析，在这个形式下，其他库被导入并被赋予一个简短的昵称。</p>
</div>
<div class="paragraph">
<p>这能做到吗？当然可以。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar RealisticNs {
    token TOP { &lt;realistic-ns&gt; }

    token realistic-ns { &lt;lparen&gt;
                           &lt;ns-keyword&gt; &lt;.ws&gt; &lt;ns-name&gt; &lt;.ws&gt;
                           &lt;require-form&gt;
                         &lt;rparen&gt; }

    token ns-keyword { &#39;ns&#39; }

    token ns-name { &lt;.ns-name-component&gt;+ % &#39;.&#39; }
    token ns-name-component { ( &lt;.alnum&gt; | &#39;-&#39; )+ }

    token require-form { &lt;lparen&gt;
                           &lt;require-keyword&gt; &lt;ws&gt;? &lt;ns-imports&gt;
                         &lt;rparen&gt; }

    token require-keyword { &#39;:require&#39; }

    token ns-imports { &lt;ns-import&gt;+ % &lt;.ws&gt; }

    token ns-import { &lt;lsquare&gt;
                        &lt;ns-name&gt; &lt;.ws&gt; &#39;:as&#39; &lt;.ws&gt; &lt;ns-nickname&gt;
                      &lt;rsquare&gt; }

    token ns-nickname { &lt;.alnum&gt;+ }

    token lsquare { &#39;[&#39; }
    token rsquare { &#39;]&#39; }

    token lparen { &#39;(&#39; }
    token rparen { &#39;)&#39; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>目前还没有太可怕的东西。我们可以看看 grammar 是如何发展的。在顶层，在 realistic-ns 中，我们增加了一个额外的 token，叫做 <code>&lt;require-form&gt;</code>，我们稍后将细节具体化。我们可以通过这种方式来管理复杂性，这样我们就有能力根据需要放大和缩小细节。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用解析后的数据">79.2.5. 使用解析后的数据</h4>
<div class="paragraph">
<p>现在我们已经能够解析数据了，我们需要利用我们解析的数据。这就是 Actions 的作用。</p>
</div>
<div class="paragraph">
<p>当我们进行 RealisticNs.parse(…​) 时，会返回一个与 RealisticNs grammar 对应的 Match 对象。虽然我们可以通过查询该对象来获取我们所需要的数据片段，但使用 Action 来建立我们真正感兴趣的数据就不那么麻烦了。</p>
</div>
<div class="paragraph">
<p>给定，一个命名空间，我们要提取出来。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Namespace name
Imported namespaces
Imported namespace nicknames</pre>
</div>
</div>
<div class="paragraph">
<p>简单的原则是，对于我们感兴趣的 token，我们创建一个同名的 Action 方法。当 Match 对象正在建立时，当 token 被匹配时，token 的 Action 方法就会运行。Grammar 是自上而下解析的，但数据是由 Action 方法以自下而上的方式建立起来的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class RealisticNsActions {
    has $!ns-name;
    has $!imported-namespaces = SetHash.new;
    has $!ns-nicknames = SetHash.new;

    method TOP($/) {
        make {
            ns-name =&gt; $!ns-name,
            ns-imports =&gt; $!imported-namespaces,
            ns-nicknames =&gt; $!ns-nicknames
        }
    }

    method ns-name($/) {
        $!ns-name = $/.Str;
    }

    method imported-ns-name($/) {
        $!imported-namespaces{$/.Str}++;
    }

    method ns-nickname($/) {
        $!ns-nicknames{$/.Str}++;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们创建了一个 RealisticNsActions 类，并创建了一些方法，在这些方法中，我们想对与之相关的数据做一些事情。我们根本不需要触及语法定义（这让它保持了干净）。我们需要做的唯一额外的事情，就是在解析时，我们需要像这样传递 Actions 对象，它指示 Raku 在看到这些标记时运行这些标记 Action 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN() {
    my $s = RealisticNs.parse(slurp(&#34;realistic.clj&#34;), actions =&gt; RealisticNsActions.new);
    say $s.made;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在一个 Actions 类中，TOP 方法可以用来生成最终的 payload，我们可以通过调用 make 方法来访问。关于 make 和 made 的更多信息，官方的 Raku grammar 教程已经说得很清楚了。简而言之，使用 make 创建的任意有效载荷可以通过使用 made 来访问。</p>
</div>
<div class="paragraph">
<p>当我们运行这个程序时，我们看到的是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{ns-imports =&gt; SetHash(another-library.json.module
                       yet-another.http.library),
 ns-name =&gt; my-amazing.module.core,
 ns-nicknames =&gt; SetHash(http json)}</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如预期的那样，我们可以看到解析后的数据被创建在一个漂亮的 HashMap 中，但是如果知道 yet-another.http.library 在命名空间中的昵称是 http，那不是更好吗？这就是我们在刚写的 Actions 类中遇到的一个设计问题。我们在一个较低的层次上构建了有效载荷。</p>
</div>
<div class="paragraph">
<p>我们需要更多的结构来获得我们想要的 namespace → namespace-nickname 映射。快速浏览一下语法告诉我们，我们可以在 ns-import 级别找到它，因为它的子标记是 import-ns-name 和 ns-nickname，而这两个是我们想要的数据片段。</p>
</div>
<div class="paragraph">
<p>我们为 ns-import 写一个 Action 方法吧!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class RealisticNsActions {
    has $!ns-name;
    has $!imported-namespaces = SetHash.new;
    has %!ns-nicknames;

    method TOP($/) {
        make {
            ns-name =&gt; $!ns-name,
            ns-imports =&gt; $!imported-namespaces,
            ns-nicknames =&gt; %!ns-nicknames
        }
    }

    method ns-name($/) {
        $!ns-name = $/.Str;
    }

    method ns-import($match) {
        #say $match;

        my $imported-ns-name = $match&lt;imported-ns-name&gt;.Str;
        my $ns-nickname = $match&lt;ns-nickname&gt;.Str;

        $!imported-namespaces{$imported-ns-name}++;
        %!ns-nicknames{$imported-ns-name} = $ns-nickname;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就导致了输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{ns-imports =&gt; SetHash(another-library.json.module
                       yet-another.http.library),
 ns-name =&gt; my-amazing.module.core,
 ns-nicknames =&gt; {another-library.json.module =&gt; json,
                  yet-another.http.library =&gt; http}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们已经掌握了所有我们需要的信息。你可以玩玩 <a href="https://gist.github.com/samebchase/82df3d17341898e054828ea1f7728f87">realistic-ns-with-actions.raku</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_在_action_类中匹配对象">79.2.6. 在 Action 类中匹配对象</h4>
<div class="paragraph">
<p>成功解析的结果是一个 <a href="https://docs.raku.org/type/Match">Match</a> 对象。这包含了整个层级化的解析结构。</p>
</div>
<div class="paragraph">
<p>无论我们在 ns-import 方法中做了什么，我们都可以在更高的层次上做，但该层次的 Match 对象需要更多的查询。这是因为该方法会将其&#34;视图&#34;接收到完整的 Match 对象中，即 TOP 方法会有整个 Match 对象，而 ns-import 方法会有一个更受限制的视图，利用这个视图我们可以很容易地提取出 import-ns-name 和 ns-nickname。这可能不会马上有意义，但在与 Match 打交道一段时间后，你会发现在尽可能低的层次上提取出有用的信息是多么的有意义，这样可以更容易地进行查询。在最上层，为了提取出 ns-nickname，我们不得不查询 realistic-ns → require-form → ns-imports → ns-import → ns-nickname，这至少可以说是很麻烦的，而且因为有多个这样的情况，所以会有一个 ns-import 的数组。</p>
</div>
<div class="paragraph">
<p>为了直观的看到每个 Action 方法中发生了什么，可以适当的添加一个 <code>say $match</code> 或者 <code>say $/</code>，看看那个层次的结构是什么。</p>
</div>
</div>
<div class="sect3">
<h4 id="_开发风格">79.2.7. 开发风格</h4>
<div class="paragraph">
<p>Raku 目前还没有 Lisp 程序员习惯的全功能 REPL 环境。这只是一些需要解决的问题。</p>
</div>
<div class="paragraph">
<p>Raku REPL 可以用来快速测试简短的单行代码片段，主要是作为最简单的安全检查，但对于任何比这更复杂的东西，它都会变得笨重。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，我使用了一种 TDD 方法，我将一个真实世界的 Clojure 项目，并在所有的 Clojure 文件上运行（快速发展的）语法。每一个&#34;正确&#34;的变化，解析的文件数量就会增加，而每一个&#34;错误&#34;的变化，解析的文件数量就会减少。</p>
</div>
</div>
<div class="sect3">
<h4 id="_接下来的步骤">79.2.8. 接下来的步骤</h4>
<div class="paragraph">
<p>有了我们目前已经解决的问题，要解析现实世界中的 Clojure 命名空间声明也不是什么难事。例如，我们已经添加了对使用 :require 形式导入 Clojure 命名空间的支持。同样，我们也可以添加对 :import 形式的支持，我们使用该形式导入 Java 库。同样的迭代方法可以用来解析越来越复杂的代码。</p>
</div>
<div class="paragraph">
<p>最后的 <a href="https://gist.github.com/samebchase/f6fbb81a2273fe86dbc129488ed5f842">Clojure NS grammar</a>，我已经能够用它来解析数百个 Clojure 文件。使用这个 grammar 来生成依赖图是一个留待日后再谈的故事。你可能会注意到，我必须处理大量的 grammar 变化和可选的空白。我相信我们已经将实现的核心提取到了我们已经详细讨论过的易于理解的 grammar 中。</p>
</div>
</div>
<div class="sect3">
<h4 id="_注意事项还有几个大的">79.2.9. 注意事项（还有几个大的）</h4>
<div class="paragraph">
<p>有可能当一个语法被不恰当地指定时，程序就会挂掉。发生的情况类似于<a href="https://www.regular-expressions.info/catastrophic.html">病态的回溯</a>。这并不是只有 Raku grammar，或者一般的 grammar 才会出现这种情况。一个写得不好的 regex 也会有同样的效果，所以在把一个 regex/grammar 放到一个高危应用的热路径上之前，必须意识到这种偶然性。有一些高调的死后案例讨论了写得不好的 regex 是如何让网络应用瘫痪的。</p>
</div>
<div class="paragraph">
<p>在处理 regex 时，通常的建议是避免使用 .*（任何字符的任何数字），而在与之匹配的内容上要有更多的限制，这个建议对于 grammar 也是适用的。尽可能的限制性，在不可避免的时候放松某些东西。在最终的代码中，我能够解析上百个真实的 Clojure 命名空间声明，但在每隔一段时间演化 grammar 的过程中，我确实遇到了几次这种行为，通过按照所述调整 grammar 来补救。能够可靠地修复它，是很难的，但时间久了，你就能直观地做到这一点。</p>
</div>
<div class="paragraph">
<p>在生产系统中，另一个需要警惕的是，即使语法规范得很好，一个恶意用户会不会制作一个触发这种病态行为的输入？只要有足够的动机，任何事情都有可能发生，所以所有的赌注都是不存在的。</p>
</div>
<div class="paragraph">
<p>Grammar 比正则表达式更强大（https://en.wikipedia.org/wiki/Chomsky_hierarchy）。传统的警告，不要用 regexes 来<a href="https://stackoverflow.com/a/1732454">解析它不够强大的东西</a>，在这里并不适用，假设 grammar 写得很好，但一个写得很好的 grammar 就像一个无 bug 的程序一样难以捉摸。我指的不是语言原始设计中的 grammar，而是你为了解析某件事情而写的 grammar。如果不能正确处理角句，不能充分处理错误，你最终会得到一个脆弱的、令人沮丧的、难以调试的程序。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_结束语">79.3. 结束语</h3>
<div class="paragraph">
<p>现在我们已经到了尾声，我希望这又是一篇漂浮在互联网上的文章，它能帮助初出茅庐的 Rakoons(Rakoons 能飞吗?思考)了解 Raku grammar 如何成为一个强大的工具，来解决任何可能遇到的解析任务。</p>
</div>
</div>
<div class="sect2">
<h3 id="_参考文献">79.4. 参考文献</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.raku.org/language/grammars">Grammar 教程</a>在帮助我掌握 Raku grammar 方面是非常宝贵的。这篇文章也可以看作是同样风格的另类教程。</p>
</li>
<li>
<p><a href="https://jeffreykegler.github.io/personal/timeline_v3">Parsing: a timeline</a> 是一篇很长的文章，但完全值得一读。</p>
</li>
<li>
<p><a href="https://perl6advent.wordpress.com/2011/12/02/grammartracer-and-grammardebugger/">Grammar::Tracer</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_片尾字幕">79.5. 片尾字幕</h3>
<div class="ulist">
<ul>
<li>
<p>多年来所有的 Raku 设计者和贡献者。</p>
</li>
<li>
<p>Jonathan Worthington，感谢他创建了 Grammar::Tracer。</p>
</li>
<li>
<p>所有友好的 Rakoons (@JJ)，他们帮助审核了本文。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第六天_declarative_apis_easy_peasy_with_raku">80. 第六天 - Declarative APIs, easy peasy with Raku</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://raku.org/">Raku</a> 的 API 往往很容易阅读，例如，命名的参数减轻了对方法调用中参数顺序的记忆。</p>
</div>
<div class="paragraph">
<p>但有时一个库的作者会在此基础上制作出特别漂亮的声明式 API。其中一个例子是 <a href="https://cro.services/">Cro</a>，一个用于编写基于 HTTP 的服务的框架，它允许你写一些东西，如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $application = route {
    get -&gt; &#39;greet&#39;, $name {
        content &#39;text/plain&#39;, &#34;Hello, $name!&#34;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>来声明你的路由，也就是 Cro 为你调用的回调，当用户请求符合路由引入的模式的 URL 时，Cro 会为你调用哪些回调，在这个例子中，/greet/fido 等等。</p>
</div>
<div class="paragraph">
<p>今天，我们将探讨使这种声明式 API 工作的机制，也就是自然读取的 API 和尽可能少使用锅炉模板的 API。</p>
</div>
<div class="paragraph">
<p>我们将探讨如何为你编写的库启用类似的接口。</p>
</div>
<div class="sect2">
<h3 id="_声明式_api_基础">80.1. 声明式 API 基础</h3>
<div class="paragraph">
<p>上面的例子依赖于几个主要的想法。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>像 <code>route</code>、<code>get</code> 和 <code>content</code> 这样的裸词只是名称相同的函数，你可以简单地用它们的名称和空格来调用它们。语句的其他部分被解释为这些函数的参数。</p>
</li>
<li>
<p>在 <code>route { …​ }</code> 中，<code>{ …​ }</code> 是一个 Block，也就是像函数一样的一段代码。</p>
</li>
<li>
<p>同样，<code>→ &#39;greet&#39;, $name { …​ }</code> 是一个块，这个块有一个显式<a href="https://docs.raku.org/type/Signature">签名</a>(&#39;greet&#39;, $name) 部分。库代码可以反省这个签名，也就是找到参数的名称 ($name) 和常量字符串 &#39;greet&#39; 的值。</p>
</li>
<li>
<p>还有一种无形的机制，将 get 与外面的 <code>route { …​ }</code> 块绑定。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最后一点需要再解释一下。在 Cro 中，你可以有多个独立的 <code>route { }</code> 块，像这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $app1 = route {
    get -&gt; &#39;meet&#39; { content &#39;text/plain&#39;, &#39;Nice to see you&#39; }
}
my $app2 = route {
    get -&gt; &#39;greet&#39; { content &#39;text/plain&#39;, &#39;Oh hai&#39; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cro 如何知道 <code>meet</code> 回调属于 <code>$app1</code>，<code>greet</code> 属于 <code>$app2</code>？<code>route</code> 子程序需要调用传递给它的块来找出它声明的回调，所以它需要向块中注入某种上下文。做到这一点的方法是通过一个<a href="https://docs.raku.org/language/variables#index-entry-Dynamically_scoped_variables">动态作用域变量</a>。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，你可以通过在 <a href="https://docs.raku.org/language/glossary#index-entry-Sigil">sigil</a> 后面声明一个带 * 的变量来实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub outer(&amp;callback) {
    my @*DYNAMIC;
    callback();
    return @*DYNAMIC.list;
}
sub inner() {
    @*DYNAMIC.push(42);
}
say outer(&amp;inner);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 sub outer 声明了一个动态变量 @*DYNAMIC。在 outer 完成之前，所有被调用的都可以看到这个变量，包括 inner 的内部，它被绑定到参数 <code>&amp;callback</code> 上。因此，代码打印 <code>[42]</code>。</p>
</div>
<div class="paragraph">
<p>如果你看看 <a href="https://github.com/croservices/cro-http/blob/5e636321ef16a3abae2927eb3948b19eb4de3d02/lib/Cro/HTTP/Router.pm6#L606">Cro::HTTP 对 sub route 的定义</a>，你可以看到它使用的技巧基本相同，只是用一个空的 RouteSet 而不是一个空的数组来初始化动态变量。</p>
</div>
</div>
<div class="sect2">
<h3 id="_实用化">80.2. 实用化</h3>
<div class="paragraph">
<p>假设你正在写一个观察目录树的库，你可以配置它将飞翔同步到另一个当地，或者根据某些属性自动删除它们，或者当某些文件改变时调用你的代码。</p>
</div>
<div class="paragraph">
<p>你想提供一个额外的厉害的，像这样的声明式 API。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $syncer = directory &#39;Documents&#39;, {
    watch name =&gt; /.*/, -&gt; $file { say &#34;File $file changed&#34; }
    delete name =&gt; /\.swp/;
    delete name =&gt; /\.swo/;
    delete age_days =&gt; * &gt; 5;
    sync extension =&gt; &#39;txt&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要让这个例子编译，你只需要用适当的签名声明 directory, delete, sync 和 watch 这四个函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub delete(*%conditions) {}
sub sync(*%conditions) {}
sub watch(&amp;callback, *%conditions) {}

sub directory(Str $path, &amp;callback) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，你还需要在一个数据结构中捕获条件和回调，这样你的假设库就可以用它做一些事情。</p>
</div>
<div class="paragraph">
<p>这可以是一个用于存储动作类型的枚举，以及一个用于条件和可选回调的类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Sync::Action &lt;Delete Sync Watch&gt;;
class ConditionalRule {
    has Sync::Action $.action is required;
    has %.conditions;
    has &amp;.callback;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>加上一个存储目录和 ConditionalRule 对象列表的类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Sync::Spec {
    has Str $.path;
    has ConditionalRule @.rules;
    method add(ConditionalRule $r) { @.rules.append: $r }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，我们需要将开始的四个函数具体化。directory 创建一个 Sync::Spec 对象，然后调用它的回调。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub directory(Str $path, &amp;callback) {
    my $*SYNC = Sync::Spec.new(:$path);
    callback;
    return $*SYNC;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其他三个需要创建新的 ConditionalRule 对象，并将其添加到 $*SYNC 中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub delete(*%conditions) {
    $*SYNC.add: ConditionalRule.new:
        :action(Sync::Action::Delete),
        :%conditions,
}
sub sync(*%conditions) {
    $*SYNC.add: ConditionalRule.new:
        :action(Sync::Action::Sync),
        :%conditions,
}
sub watch(&amp;callback, *%conditions) {
    $*SYNC.add: ConditionalRule.new:
        :action(Sync::Action::Sync),
        :%conditions,
        :&amp;callback,
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个恼人的模板，但它允许漂亮界面的用户放弃所有的模板。</p>
</div>
<div class="paragraph">
<p>一旦你把所有这些拼凑在一起，directory 就会返回一个 Sync::Spec 对象，这个对象包含了所有必要的知识，为假设的 syncer 库提供燃料。</p>
</div>
<div class="paragraph">
<p>剩下的就是真正实现它了。这个任务远远超出了本文的范围 - 留给读者去做，如果你选择了这些的话。</p>
</div>
<div class="paragraph">
<p>但是，等等，我们还没有完全完成，因为当有人滥用我们整洁的小 API 时。如果你只是在目录块之外调用 delete，你就会得到 Dynamic variable $*SYNC not found 的错误信息，这并不值得我们向往的精彩。</p>
</div>
<div class="paragraph">
<p>幸运的是，我们可以很容易地改进这一点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub delete(*%conditions) {
    die &#39;delete outside a directory { } block&#39;
        unless defined $*SYNC;
    $*SYNC.add: ConditionalRule.new:
        :action(Sync::Action::Delete),
        :%conditions,
}</code></pre>
</div>
</div>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>并类推其他三个动作。同样是更多的模板，符合 Raku 代表用户折磨实现者的座右铭。</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr/>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. 我将在后面介绍调度器的细节。当我这样做的时候, 你会看到 Raku 使用的确切机制来决定一个任务是否被安排在一个单独的线程中立即运行, 在未来的某个时间在一个单独的线程上运行, 在当前线程停止忙碌时在当前线程上运行等等。不过, 我一般会假设 <code>start</code> 会把任务安排在下一个可用的线程上, 因为在 Raku 中一般都是安全的。
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. 请注意, 这是 MoarVM 下 Rakudo 中运行的默认调度程序的过程。实际发生的事情可能会根据 <a href="https://docs.raku.org/language/variables#index-entry-$*SCHEDULER">$*SCHEDULER</a> 变量中的当前值而有些不同。我将在以后的文章中进一步讨论这个问题
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. 关于以下整数序列的背景，见 <a href="https://oeis.org/A005185">https://oeis.org/A005185</a>
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. 这是所有 <code>Supply</code> 对象的特性，而不仅仅是 <code>supply</code> 块或按需供应生成的对象。︎
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. 需要说明的是, <code>Thread</code> 对象不一定代表一个特定的操作系统线程, 但它应该能让你尽可能地接近实现。
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. 我并不是说这是一种高效的模拟康威的《生命游戏》的方法, 但我只是在演示如何利用一个版本的模拟器, 并利用并发模式使其更高效。
</div>
<div class="footnote" id="_footnotedef_7">
<a href="#_footnoteref_7">7</a>. 这是严重的低效率, 因为大段的棋盘很可能是空白的。正如我已经提到的那样, 我在这里的目的不是为了实现一个高效的棋手, 而是展示我们如何利用并发来提高效率。
</div>
<div class="footnote" id="_footnotedef_8">
<a href="#_footnoteref_8">8</a>. Raku 已经为这个操作做了一些优化。例如,它不会为 <code>.grep</code> 和 <code>.map</code> 执行单独的循环。这些操作将以序列的方式链在一起,所以基本上只执行一次迭代。
</div>
</div>

</article>


    

  </main><section class="site__search">
    <label class="site__form">
        <p class="form__label">Search around the site</p> 
        <input class="site__search-bar form__input" type="text">
    </label>
    <div class="site__search-bar-results"></div>
</section>
  
  <footer class="site__footer">
    
    
    <p class="footer__sign">© 2020 ohmyraku</p></footer>





<script defer type="text/javascript" src="https://ohmyraku.github.io/js/script.14164ab553b19613ce98aadb54b1ed9a89ae5b056c72b99a4c672e37954f33d67bebe1452b0279025ba889964b51bdf8ec69683933cf427ae67c08ac2cdda7b1.js" integrity="sha512-FBZKtVOxlhPOmKrbVLHtmomuWwVscrmaTGcuN5VPM9Z76&#43;FFKwJ5AluoiZZLUb347GloOTPPQnrmfAisLN2nsQ=="></script>



</body>
</html>