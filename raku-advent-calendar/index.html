<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Raku Advent Calendar :: 山川异域, 风月同天</title>

<meta name="author" content="ohmyraku">
<meta name="application-name" content="山川异域, 风月同天">
<meta name="description" content="1. 第一天 – Raku 鬼精灵: 圣诞节实用指南 看看他们！同事、朋友和亲近的家人都在开心地笑着。他们都在享受着使用 Raku 的 6.c “圣诞”版编程的乐趣。给力的并发原语, 核心文法, 还有非常棒的对象模型。它让我印象深刻！
 但是等一下…​ 就一秒。我有个想法。一个可怕的想法。我想到了一个鬼主意! 我们可以在他们的&#34;圣诞&#34;上捣乱。需要的只有一点花招。哈哈哈哈哈哈！！
 欢迎来到 2017 年的 Raku 圣诞日历！每天，从今天直到圣诞节，我们都会有一篇很赞的关于 Raku 的博客推送到你面前。
 今天，我们会展示我们淘气的一面并且故意地做些淘气的事情。确实，这有点用，但是淘气点更快乐。我们开始吧！
 1.1. But True does False 你听过 but 操作符吗？一个好玩的东西：
 say True but False ?? &#39;Tis true&#39; !! &#39;Tis false&#39;; # OUTPUT: «Tis false␤» my $n = 42 but &#39;forty two&#39;; say $n; # OUTPUT: «forty two␤» say $n &#43; 7; # OUTPUT: «49␤»   它是一个中缀操作符，它首先拷贝它左边的对象，然后把它右边提供的 role 混进这个拷贝中：">
<meta name="robots" content="noodp"/>
<meta name="generator" content="Hugo 0.79.0" />
<meta name="referrer" content="no-referrer" />
<meta name="format-detection" content="telephone=no">

<link rel="canonical" href="https://ohmyraku.github.io/raku-advent-calendar/" />


<link rel="icon" href="https://ohmyraku.github.io/logo.png" />

<link rel="stylesheet" href="https://ohmyraku.github.io/scss/main.min.84f71d25d375c522a861bb4719728ce6839cf3635b15ca0c7a1b4d799c2dc3399a1d6cb46058a9d8fdbebe9156a8857279cfdeb70aa3862e629de234b5a41fa1.css" integrity="sha512-hPcdJdN1xSKoYbtHGXKM5oOc82NbFcoMehtNeZwtwzmaHWy0YFip2P2&#43;vpFWqIVyec/etwqjhi5ineI0taQfoQ==">
<script>

const theme = window.localStorage.getItem('theme'); 
if (theme && theme !== "1") {
    document.documentElement.classList.add('theme-' + theme);
}
</script>


</head>
<body>
  <main class="site__content">
    <div class="site__page">
  <nav class="site__breadcrumbs">
    <a class="site__breadcrumb" href="https://ohmyraku.github.io/">山川异域, 风月同天</a><a class="site__breadcrumb--active" href="https://ohmyraku.github.io/raku-advent-calendar/">Raku Advent Calendar</a>
</nav>

<h1 class="page__title">Raku Advent Calendar</h1>
  <div class="page__meta">
    <p>
    
    <span class="page__date">
    on <time datetime="2020-02-05T15:26:52&#43;08:00">2020-02-05</time>
    
    </span>
    </p>

    

    
    </div>
</div>


<div class="page__toc">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#_第一天_raku_鬼精灵_圣诞节实用指南">1. 第一天 – Raku 鬼精灵: 圣诞节实用指南</a>
      <ul>
        <li><a href="#_but_true_does_false">1.1. But True does False</a></li>
        <li><a href="#_wrapping_it_up">1.2. Wrapping It Up</a></li>
        <li><a href="#_看不见的斗篷">1.3. 看不见的斗篷</a></li>
        <li><a href="#_ho_ho_ho">1.4. Ho-Ho-Ho</a></li>
        <li><a href="#_结论">1.5. 结论</a></li>
      </ul>
    </li>
    <li><a href="#_第二天_raku_符号_变量和容器">2. 第二天-Raku: 符号, 变量和容器</a>
      <ul>
        <li><a href="#_把钱拿出来">2.1. 把钱拿出来</a></li>
        <li><a href="#_我们祝你有一个愉快的列表圣诞">2.2. 我们祝你有一个愉快的列表圣诞</a></li>
        <li><a href="#_thats_your_assignment">2.3. That’s Your Assignment</a></li>
        <li><a href="#_positionlly">2.4. Position@lly</a></li>
        <li><a href="#_the_one_and_only">2.5. The One and Only</a></li>
        <li><a href="#_decont">2.6. Decont</a></li>
        <li><a href="#_不要让它溜走">2.7. 不要让它溜走</a></li>
        <li><a href="#_i_want_less">2.8. I Want Less</a></li>
        <li><a href="#_defaulting_on_default_defaults">2.9. Defaulting on Default Defaults</a></li>
        <li><a href="#_自定义">2.10. 自定义</a></li>
        <li><a href="#_这就是全部伙计">2.11. 这就是全部，伙计</a></li>
        <li><a href="#_结论_2">2.12. 结论</a></li>
      </ul>
    </li>
    <li><a href="#_第三天_letterops_with_raku">3. 第三天 – LetterOps with Raku</a>
      <ul>
        <li><a href="#_规模">3.1. 规模</a></li>
        <li><a href="#_markdown_来拯救">3.2. Markdown 来拯救</a></li>
        <li><a href="#_使用_raku_处理_markdown">3.3. 使用 Raku 处理 Markdown</a></li>
        <li><a href="#_需要更多的结构">3.4. 需要更多的结构</a></li>
        <li><a href="#_这里的玩具是重要的">3.5. 这里的玩具是重要的</a></li>
        <li><a href="#_还没有">3.6. 还没有</a></li>
        <li><a href="#_包起来">3.7. 包起来</a></li>
      </ul>
    </li>
    <li><a href="#_第四天_使用_grammars_进行解析">4. 第四天-使用 Grammars 进行解析</a>
      <ul>
        <li><a href="#_理解_grammars">4.1. 理解 Grammars</a></li>
        <li><a href="#_递归下降分析法和优先级">4.2. 递归下降分析法和优先级</a></li>
        <li><a href="#_左递归和其他陷阱">4.3. 左递归和其他陷阱</a></li>
        <li><a href="#_始于简单">4.4. 始于简单</a></li>
        <li><a href="#_组装完整的_grammars">4.5. 组装完整的 Grammars</a></li>
        <li><a href="#_调试_grammars">4.6. 调试 Grammars</a></li>
        <li><a href="#_解析空白和注释">4.7. 解析空白和注释</a></li>
        <li><a href="#_保存状态">4.8. 保存状态</a></li>
        <li><a href="#_使用动态变量实现词法作用域">4.9. 使用动态变量实现词法作用域</a></li>
        <li><a href="#_总结">4.10. 总结</a></li>
        <li><a href="#_解构_json">4.11. 解构 JSON</a></li>
        <li><a href="#_在块儿中使用签名">4.12. 在块儿中使用签名</a></li>
        <li><a href="#_你甚至可以解构对象">4.13. 你甚至可以解构对象!</a></li>
        <li><a href="#_结论_3">4.14. 结论</a></li>
      </ul>
    </li>
    <li><a href="#_第六天_raku_书籍">5. 第六天-Raku 书籍</a></li>
    <li><a href="#_第七天_测试所有的东西">6. 第七天 – 测试所有的东西</a>
      <ul>
        <li><a href="#_it_depends">6.1. It depends…</a></li>
        <li><a href="#_懒惰和不耐烦">6.2. 懒惰和不耐烦</a></li>
        <li><a href="#_晾干">6.3. 晾干</a></li>
      </ul>
    </li>
    <li><a href="#_第八天_adventures_in_nqp_land_hacking_the_rakudo_compiler">7. 第八天 - Adventures in NQP Land: Hacking the Rakudo Compiler</a>
      <ul>
        <li><a href="#_背景">7.1. 背景</a></li>
        <li><a href="#_not_quite_perl_nqp">7.2. Not Quite Perl (NQP)</a></li>
        <li><a href="#_进入战壕">7.3. 进入战壕</a></li>
        <li><a href="#_工作区和工具">7.4. 工作区和工具</a></li>
        <li><a href="#_hacking">7.5. Hacking</a></li>
        <li><a href="#_测试">7.6. 测试</a></li>
        <li><a href="#_文档">7.7. 文档</a></li>
        <li><a href="#_nqp_经验教训">7.8. NQP 经验教训</a></li>
        <li><a href="#_成功">7.9. 成功！</a></li>
        <li><a href="#_总结_2">7.10. 总结</a></li>
        <li><a href="#_参考">7.11. 参考</a></li>
        <li><a href="#_附录">7.12. 附录</a></li>
        <li><a href="#_主要的_raku_pod_渲染器">7.13. 主要的 Raku POD 渲染器</a></li>
      </ul>
    </li>
    <li><a href="#_第九天_http_and_web_sockets_with_cro">8. 第九天 – HTTP and Web Sockets with Cro</a>
      <ul>
        <li><a href="#_响应式管道">8.1. 响应式管道</a></li>
        <li><a href="#_http_服务器简单的方法">8.2. HTTP 服务器，简单的方法</a></li>
        <li><a href="#_通向幸福的途径">8.3. 通向幸福的途径</a></li>
        <li><a href="#_中间件变得更容易">8.4. 中间件变得更容易</a></li>
        <li><a href="#_这只是一个供应链supply_chain">8.5. 这只是一个供应链(Supply chain)</a></li>
        <li><a href="#_哦和websockets">8.6. 哦，和WebSockets？</a></li>
        <li><a href="#_综上所述">8.7. 综上所述</a></li>
      </ul>
    </li>
    <li><a href="#_第十天_wrapping_rats">9. 第十天 – Wrapping Rats</a></li>
    <li><a href="#_第十一天_raku_中所有的星号">10. 第十一天-Raku 中所有的星号</a>
      <ul>
        <li><a href="#_1_乘法">10.1. 1. 乘法</a></li>
        <li><a href="#_2_幂">10.2. 2. 幂</a></li>
        <li><a href="#_3_零或多次重复">10.3. 3. 零或多次重复</a></li>
        <li><a href="#_4_min_到_max_次重复">10.4. 4. Min 到 Max 次重复</a></li>
        <li><a href="#_5_吞噬参数">10.5. 5. 吞噬参数</a></li>
        <li><a href="#_6_吨吨吨吨吨吨吨">10.6. 6. 吨吨吨吨吨吨吨</a></li>
        <li><a href="#_7_动态作用域">10.7. 7. 动态作用域</a></li>
        <li><a href="#_8_编译变量">10.8. 8. 编译变量</a></li>
        <li><a href="#_9_all_methods">10.9. 9. All methods</a></li>
        <li><a href="#_10_whatever">10.10. 10. Whatever</a></li>
        <li><a href="#_11_whatevercode">10.11. 11. WhateverCode</a></li>
        <li><a href="#_作业">10.12. 作业</a></li>
        <li><a href="#_附加题">10.13. 附加题</a></li>
      </ul>
    </li>
    <li><a href="#_第十二天_the_year_of_raku_books">11. 第十二天 – The Year of Raku Books</a></li>
    <li><a href="#_第十三天_使用_raku_挖掘维基百科">12. 第十三天 - 使用 Raku 挖掘维基百科</a>
      <ul>
        <li><a href="#_介绍">12.1. 介绍</a></li>
        <li><a href="#_grammar_和_actions_难学吗">12.2. Grammar 和 Actions 难学吗?</a></li>
        <li><a href="#_第一根火柴">12.3. 第一根火柴</a></li>
        <li><a href="#_第二根火柴">12.4. 第二根火柴</a></li>
        <li><a href="#_第三根火柴">12.5. 第三根火柴</a></li>
        <li><a href="#_面向对象">12.6. 面向对象</a></li>
        <li><a href="#_w_is_your_friend">12.7. &lt;|w&gt; is your friend</a></li>
      </ul>
    </li>
    <li><a href="#_第十五天_带有_promise_的简单网络爬虫">13. 第十五天-带有 Promise 的简单网络爬虫</a>
      <ul>
        <li><a href="#_结论是">13.1. 结论是</a></li>
      </ul>
    </li>
    <li><a href="#_第十六天_raku_性能改进">14. 第十六天-Raku 性能改进</a></li>
    <li><a href="#_第十七天_关于消息传递">15. 第十七天-关于消息传递</a>
      <ul>
        <li><a href="#_为什么要传递消息">15.1. 为什么要传递消息</a></li>
        <li><a href="#_传递什么信息">15.2. 传递什么信息</a></li>
        <li><a href="#_强制性的你好世界">15.3. 强制性的你好，世界</a></li>
        <li><a href="#_一些更有用的东西">15.4. 一些更有用的东西</a></li>
        <li><a href="#_保持主题">15.5. 保持主题</a></li>
        <li><a href="#_但是生命比amqp更重要">15.6. 但是，生命比AMQP更重要</a></li>
        <li><a href="#_把它包起来">15.7. 把它包起来</a></li>
      </ul>
    </li>
    <li><a href="#_第十八天_raku_支持的工作流">16. 第十八天-Raku 支持的工作流</a></li>
    <li><a href="#_第十九天_language_independent_validation_rules_livr_for_raku">17. 第十九天-Language Independent Validation Rules (LIVR) for Raku</a>
      <ul>
        <li><a href="#_livr_介绍">17.1. LIVR 介绍</a></li>
        <li><a href="#_livr和raku">17.2. LIVR和Raku</a></li>
        <li><a href="#_livr_链接">17.3. LIVR 链接</a></li>
      </ul>
    </li>
    <li><a href="#_第二十天_宏的进阶">18. 第二十天-宏的进阶</a></li>
    <li><a href="#_第二十一天_数独与junctions和集合">19. 第二十一天-数独与Junctions和集合</a>
      <ul>
        <li><a href="#_junctions量子逻辑测试">19.1. Junctions：量子逻辑测试</a></li>
        <li><a href="#_集合对象的集合">19.2. 集合：对象的集合</a></li>
        <li><a href="#_关于对象的说明">19.3. 关于对象的说明</a></li>
      </ul>
    </li>
    <li><a href="#_第二十二天_raku_d_的特性">20. 第二十二天-Raku.d 的特性</a>
      <ul>
        <li><a href="#_在创建时调整对象">20.1. 在创建时调整对象</a></li>
        <li><a href="#_并发性改进">20.2. 并发性改进</a></li>
        <li><a href="#_unicode_goodies">20.3. Unicode goodies</a></li>
        <li><a href="#_跳过值">20.4. 跳过值</a></li>
        <li><a href="#_of_bufs_and_blobs">20.5. Of Bufs and Blobs</a></li>
        <li><a href="#_测试测试测试">20.6. 测试，测试，测试！</a></li>
        <li><a href="#_这是怎么回事">20.7. 这是怎么回事</a></li>
        <li><a href="#_main_函数">20.8. MAIN 函数</a></li>
        <li><a href="#_嵌入_raku">20.9. 嵌入 Raku</a></li>
        <li><a href="#_礼品袋的底部">20.10. 礼品袋的底部</a></li>
        <li><a href="#_赶上雪橇的时间">20.11. 赶上雪橇的时间</a></li>
      </ul>
    </li>
    <li><a href="#_第二十三天_raku_高尔夫">21. 第二十三天-Raku 高尔夫</a>
      <ul>
        <li><a href="#_一些基本的例子">21.1. 一些基本的例子</a></li>
        <li><a href="#_numbers">21.2. Numbers</a></li>
        <li><a href="#_条件">21.3. 条件</a></li>
        <li><a href="#_打字很难让我们使用一些预定义的字符串">21.4. 打字很难，让我们使用一些预定义的字符串！</a></li>
        <li><a href="#_base_16_base_36_nah_base_0x10ffff">21.5. Base 16? Base 36? Nah, Base 0x10FFFF!</a></li>
        <li><a href="#_所有的好事都必须结束可怕的事情_更是如此">21.6. 所有的好事都必须结束;可怕的事情 - 更是如此</a></li>
      </ul>
    </li>
    <li><a href="#_第二十四天_解魔方">22. 第二十四天-解魔方</a>
      <ul>
        <li><a href="#_介绍_2">22.1. 介绍</a></li>
        <li><a href="#_符号">22.2. 符号</a></li>
        <li><a href="#_算法">22.3. 算法</a></li>
        <li><a href="#_设计一个模块">22.4. 设计一个模块</a></li>
        <li><a href="#_代码">22.5. 代码</a></li>
      </ul>
    </li>
    <li><a href="#_第二十五天_圣诞奖金_并发http服务器实施和scripter的方法">23. 第二十五天-圣诞奖金 - 并发HTTP服务器实施和scripter的方法</a>
      <ul>
        <li><a href="#_raku_范式">23.1. Raku 范式</a></li>
        <li><a href="#_raku_supplies_就像一个_v12_引擎">23.2. Raku Supplies 就像一个 V12 引擎</a></li>
        <li><a href="#_wap6_的结构">23.3. Wap6 的结构</a></li>
        <li><a href="#_wap6_的核心">23.4. Wap6 的核心</a></li>
        <li><a href="#_webservices">23.5. Webservices</a></li>
        <li><a href="#_当客户端请求静态文件时">23.6. 当客户端请求静态文件时</a></li>
        <li><a href="#_结语">23.7. 结语</a></li>
      </ul>
    </li>
    <li><a href="#_第一天_移植_vigilance将raku与标准工具集成在一起">24. 第一天 - 移植 Vigilance，将Raku与标准工具集成在一起</a>
      <ul>
        <li><a href="#_shebang_和导入">24.1. Shebang 和导入</a></li>
        <li><a href="#_命令行选项">24.2. 命令行选项</a></li>
        <li><a href="#_io_读写文件">24.3. IO: 读写文件</a></li>
        <li><a href="#_获得md5校验和">24.4. 获得MD5校验和</a></li>
        <li><a href="#_结束之前的思考">24.5. 结束之前的思考</a></li>
      </ul>
    </li>
    <li><a href="#_第二天_like_6_perls_in_a_pod_document_everything">25. 第二天 – Like 6 Perls in a Pod: document everything</a></li>
    <li><a href="#_大多数人都可以阅读源代码但每个人都可以阅读文档">26. 大多数人都可以阅读源代码，但每个人都可以阅读文档。</a></li>
    <li><a href="#_pod_6_stands_for_plain_old_documentation_for_raku">27. Pod 6 stands for “Plain Old documentation for Raku”</a></li>
    <li><a href="#_给模块添加文档">28. 给模块添加文档</a></li>
    <li><a href="#_回到生产">29. 回到生产</a></li>
    <li><a href="#_第三天_raku_跳转到那儿">30. 第三天 – Raku – 跳转到那儿</a></li>
    <li><a href="#_第四天_献给新年的_raku_pod_新功能">31. 第四天 - 献给新年的 Raku Pod 新功能</a>
      <ul>
        <li><a href="#_介绍_3">31.1. 介绍</a></li>
        <li><a href="#_准备">31.2. 准备</a></li>
        <li><a href="#_背景_2">31.3. 背景</a></li>
        <li><a href="#_rakudo_nqp_grammar_和_actions_学到的东西">31.4. Rakudo NQP grammar 和 actions: 学到的东西</a></li>
        <li><a href="#_总结_3">31.5. 总结</a></li>
        <li><a href="#_左还是右">31.6. 左还是右？</a></li>
        <li><a href="#_参数">31.7. 参数</a></li>
        <li><a href="#_动态范围">31.8. 动态范围</a></li>
        <li><a href="#_宏里面的变量">31.9. 宏里面的变量</a></li>
      </ul>
    </li>
    <li><a href="#_第六天_懒惰精灵与勤劳精灵">32. 第六天 - 懒惰精灵与勤劳精灵</a>
      <ul>
        <li><a href="#_lazy_slack">32.1. Lazy slack</a></li>
        <li><a href="#_尽力追赶">32.2. 尽力追赶</a></li>
        <li><a href="#_use_the_right_elf">32.3. Use the right elf</a></li>
      </ul>
    </li>
    <li><a href="#_第七天_细胞自动机">33. 第七天 – 细胞自动机</a>
      <ul>
        <li><a href="#_为学习而做">33.1. 为学习而做</a></li>
        <li><a href="#_走在前面">33.2. 走在前面</a></li>
        <li><a href="#_制作东西">33.3. 制作东西</a></li>
        <li><a href="#_改变">33.4. 改变</a></li>
        <li><a href="#_改变邻居">33.5. 改变邻居</a></li>
        <li><a href="#_优化机会">33.6. 优化机会？</a></li>
        <li><a href="#_其他变化">33.7. 其他变化？</a></li>
        <li><a href="#_这有用吗">33.8. 这有用吗？</a></li>
      </ul>
    </li>
    <li><a href="#_第八天_让你的_raku_grammar_紧凑一点">34. 第八天 — 让你的 Raku grammar 紧凑一点</a>
      <ul>
        <li><a href="#_1_拆分_actions">34.1. 1.拆分 actions</a></li>
        <li><a href="#_使用_multi_方法">34.2. 使用 multi 方法</a></li>
        <li><a href="#_3_让_perl_完成这项工作">34.3. 3. 让 Perl 完成这项工作</a></li>
        <li><a href="#_4_使用_multi_rules_和_multi_tokens">34.4. 4. 使用 multi-rules 和 multi-tokens</a></li>
      </ul>
    </li>
    <li><a href="#_第九天_raku_中的常量">35. 第九天 - Raku 中的常量</a>
      <ul>
        <li><a href="#_如何制作一个常数">35.1. 如何制作一个常数</a></li>
        <li><a href="#_从模块导出常量">35.2. 从模块导出常量</a></li>
        <li><a href="#_在程序中使用模块">35.3. 在程序中使用模块</a></li>
        <li><a href="#_最后对代码维护进行了一些注释">35.4. 最后，对代码维护进行了一些注释</a></li>
      </ul>
    </li>
    <li><a href="#_第十天_跳转_开启你的工作流">36. 第十天 - 跳转, 开启你的工作流</a></li>
    <li><a href="#_第十一天_使用_raku_测试你的时刻表">37. 第十一天 - 使用 Raku 测试你的时刻表</a></li>
    <li><a href="#_第十二天_构建灵活的_grammar">38. 第十二天 - 构建灵活的 grammar</a></li>
    <li><a href="#_第十三天_使用_cro_和_debian_从头构建_web_服务">39. 第十三天 - 使用 Cro 和 Debian 从头构建 Web 服务</a>
      <ul>
        <li><a href="#_安装_rakudo_raku_编译器">39.1. 安装 Rakudo Raku 编译器</a></li>
        <li><a href="#_安装_cro_服务">39.2. 安装 Cro 服务</a></li>
        <li><a href="#_cro_实战">39.3. Cro 实战</a></li>
        <li><a href="#_总结_4">39.4. 总结</a></li>
      </ul>
    </li>
    <li><a href="#_第十四天_使用_raku_设计小航天器">40. 第十四天 - 使用 Raku 设计(小)航天器</a>
      <ul>
        <li><a href="#_寻找共同点">40.1. 寻找共同点</a></li>
        <li><a href="#_asn_1_和限制">40.2. <code>ASN.1</code> 和限制</a></li>
        <li><a href="#_逐步建设问题答案">40.3. 逐步建设。问题答案。</a></li>
      </ul>
    </li>
    <li><a href="#_第十五天_使用_raku_构建小型航天器">41. 第十五天 - 使用 Raku 构建(小型)航天器</a>
      <ul>
        <li><a href="#_炫耀长耳朵">41.1. 炫耀长耳朵</a></li>
        <li><a href="#_类型类型类型">41.2. 类型，类型，类型</a></li>
        <li><a href="#_进步进化序列化">41.3. 进步，进化，序列化！</a></li>
        <li><a href="#_如果有时间进行编码总会有时间进行解码">41.4. 如果有时间进行编码，总会有时间进行解码</a></li>
        <li><a href="#_what_oclock_supply_oclock">41.5. What o’clock? Supply o’clock!</a></li>
      </ul>
    </li>
    <li><a href="#_第十六天_检查你的列表俩次">42. 第十六天 - 检查你的列表俩次</a>
      <ul>
        <li><a href="#_从命令行了解_raku">42.1. 从命令行了解 Raku</a></li>
        <li><a href="#_就像拔牙">42.2. 就像拔牙?</a></li>
        <li><a href="#_一种强大的沉默的类型">42.3. 一种强大的，沉默的类型</a></li>
        <li><a href="#_精灵类型不匹配_弥补改进的错误处理">42.4. 精灵类型不匹配 - 弥补改进的错误处理</a></li>
        <li><a href="#_我们不会去直到我们得到一些">42.5. 我们不会去，直到我们得到一些！</a></li>
        <li><a href="#_跑步者走上了这条路">42.6. 跑步者走上了这条路。</a></li>
      </ul>
    </li>
    <li><a href="#_第17天_通往幸福的编译之路">43. 第17天 - 通往幸福的编译之路</a>
      <ul>
        <li><a href="#_marcus_junius_brute_forcethe_younger">43.1. Marcus Junius Brute Force（The Younger）</a></li>
        <li><a href="#_我让路径遍历少了以及所有其他路径">43.2. 我让路径遍历少了（以及所有其他路径）</a></li>
        <li><a href="#_在方程式中思考">43.3. 在方程式中思考</a></li>
        <li><a href="#_第四语言">43.4. 第四语言</a></li>
        <li><a href="#_结论_5">43.5. 结论</a></li>
      </ul>
    </li>
    <li><a href="#_第十八天_一棵_avg_格式的圣诞树">44. 第十八天 - 一棵 AVG 格式的圣诞树</a>
      <ul>
        <li><a href="#_关于svg并创建它">44.1. 关于SVG并创建它</a></li>
        <li><a href="#_我们抽象吧">44.2. 我们抽象吧！</a></li>
        <li><a href="#_让我们延伸">44.3. 让我们延伸！</a></li>
        <li><a href="#_一个重构点">44.4. 一个重构点</a></li>
        <li><a href="#_一个进一步的抽象">44.5. 一个进一步的抽象</a></li>
        <li><a href="#_最后是我们的树">44.6. 最后是我们的树</a></li>
      </ul>
    </li>
    <li><a href="#_第十九天_交互式桌面应用">45. 第十九天 - 交互式桌面应用</a>
      <ul>
        <li><a href="#_骰子滚动">45.1. 骰子滚动</a></li>
        <li><a href="#_简单的_gtksimple">45.2. 简单的 GTK::Simple</a></li>
        <li><a href="#_网格布局">45.3. 网格布局</a></li>
        <li><a href="#_交互">45.4. 交互</a></li>
        <li><a href="#_把它们放在一起">45.5. 把它们放在一起</a></li>
        <li><a href="#_最后的想法">45.6. 最后的想法</a></li>
      </ul>
    </li>
    <li><a href="#_第二十天_raku_中的命题组合">46. 第二十天 - Raku 中的命题组合</a></li>
    <li><a href="#_你如何以数学方式包装礼物">47. 你如何以数学方式包装礼物？</a>
      <ul>
        <li><a href="#_一个立方体卡罗尔">47.1. 一个立方体卡罗尔</a></li>
        <li><a href="#_sat_a_clause的令人满意的故事">47.2. SAT-a-Clause的令人满意的故事</a></li>
        <li><a href="#_比你想知道的3d礼品包装更多">47.3. 比你想知道的3D礼品包装更多</a></li>
      </ul>
    </li>
    <li><a href="#_把它包起来_2">把它包起来</a>
      <ul>
        <li><a href="#_第二十一天_一个红色的圣诞老人">48. 第二十一天 - 一个红色的圣诞老人</a></li>
        <li><a href="#_第二十二天_测试_cro_http_api">49. 第二十二天 - 测试 Cro HTTP API</a></li>
        <li><a href="#_第二十三天_blin很快就到圣诞节了">50. 第二十三天 - Blin，很快就到圣诞节了！</a></li>
        <li><a href="#_第二十四天_使用_raku_进行主题建模">51. 第二十四天 - 使用 Raku 进行主题建模</a></li>
        <li><a href="#_第一天_来自_perl_的_raku">52. 第一天 - 来自 Perl 的 Raku</a></li>
        <li><a href="#_第二天_crohttp_crud_指南">53. 第二天 - Cro::HTTP CRUD 指南</a></li>
        <li><a href="#_第三天_栈帧规约">54. 第三天 - 栈帧规约</a></li>
        <li><a href="#_第四天_不被_tripscodes_绊倒">55. 第四天 - 不被 tripscodes 绊倒</a></li>
        <li><a href="#_第五天_模块化_raku_命令行应用">56. 第五天 - 模块化 Raku 命令行应用</a></li>
        <li><a href="#_第六天_在你的_raku仓库中添加一些github动作">57. 第六天 - 在你的 Raku(仓库)中添加一些(GitHub)动作</a></li>
        <li><a href="#_第七天_使用_raku_解析_firefox_的_user_js第一部分">58. 第七天 - 使用 Raku 解析 Firefox 的 user.js(第一部分)</a></li>
        <li><a href="#_第八天_使用_raku_解析_firefox_的_user_js第二部分">59. 第八天 - 使用 Raku 解析 Firefox 的 user.js(第二部分)</a></li>
        <li><a href="#_第九天_容器链">60. 第九天 - 容器链</a></li>
        <li><a href="#_第十天_急转弯">61. 第十天 - 急转弯</a></li>
        <li><a href="#_第十一天_使用_libarchive_打包">62. 第十一天 - 使用 libarchive 打包</a></li>
        <li><a href="#_第十二天_在_raku_中制作一个简单的机器人">63. 第十二天 - 在 Raku 中制作一个简单的机器人</a></li>
        <li><a href="#_第十三天_一点_rust_和_raku">64. 第十三天 - 一点 Rust 和 Raku</a></li>
        <li><a href="#_第十四天_超越类型之外之_rakudo_mop">65. 第十四天 超越类型之外之 Rakudo MOP</a></li>
        <li><a href="#_元对象协议">66. 元对象协议</a></li>
        <li><a href="#_spreading_the_joy">67. Spreading the Joy</a></li>
        <li><a href="#_第十五天_圣诞老人有太多蛋酒了">68. 第十五天 - 圣诞老人有太多蛋酒了</a></li>
        <li><a href="#_第十六天_raku_加持的工作面跳转">69. 第十六天 - Raku 加持的工作面跳转</a></li>
        <li><a href="#_第十七天_迷宫机">70. 第十七天 - 迷宫机</a></li>
        <li><a href="#_第十八天_我的并发_raku_程序在做什么">71. 第十八天 - 我的并发 raku 程序在做什么?</a></li>
        <li><a href="#_第十九天_raku_中的函数式编程">72. 第十九天 - Raku 中的函数式编程</a></li>
        <li><a href="#_第二十天_perl_到_raku_的代码转换">73. 第二十天 - perl 到 raku 的代码转换</a></li>
        <li><a href="#_第二十一天_搜索红色礼物">74. 第二十一天 - 搜索红色礼物</a></li>
        <li><a href="#_第二十二天_当然是课程">75. 第二十二天 - 当然是课程</a></li>
        <li><a href="#_第二十三天_a_raku_advent_helper">76. 第二十三天 – A Raku Advent Helper</a></li>
        <li><a href="#_第_24_天raku_之鬼灵精第二部稳住阵脚">77. 第 24 天：《Raku 之鬼灵精》第二部：稳住阵脚</a></li>
        <li><a href="#_第一天_为什么_raku_是_advent_code_的理想语言">78. 第一天 - 为什么 Raku 是 Advent Code 的理想语言？</a></li>
        <li><a href="#_第十二天_那种快乐的感觉">79. 第十二天 - 那种快乐的感觉</a></li>
        <li><a href="#_promise">80. Promise</a></li>
        <li><a href="#_supply_块">81. Supply 块</a></li>
        <li><a href="#_channel">82. Channel</a></li>
        <li><a href="#_线程">83. 线程</a></li>
        <li><a href="#_raku_调度器">84. Raku 调度器</a></li>
        <li><a href="#_react_块">85. React 块</a></li>
        <li><a href="#_lock_类">86. Lock 类</a></li>
        <li><a href="#_atomic_integer">87. Atomic Integer</a></li>
        <li><a href="#_分而治之模式">88. 分而治之模式</a></li>
        <li><a href="#_并行的_map_reduce_模式">89. 并行的 Map-Reduce 模式</a></li>
        <li><a href="#_保留你的线程或不保留">90. 保留你的线程或不保留</a></li>
        <li><a href="#_监控模式">91. 监控模式</a></li>
        <li><a href="#_比较并交换标量">92. 比较并交换标量</a></li>
        <li><a href="#_拆解异步问题">93. 拆解异步问题</a></li>
        <li><a href="#_信号量">94. 信号量</a></li>
        <li><a href="#_比较_react_与_tap">95. 比较 react 与 tap</a></li>
        <li><a href="#_supply_反压">96. Supply 反压</a></li>
        <li><a href="#_无锁的线程安全结构">97. 无锁的线程安全结构</a></li>
        <li><a href="#_拆解并发问题">98. 拆解并发问题</a></li>
        <li><a href="#_并行循环执行">99. 并行循环执行</a></li>
        <li><a href="#_asynchronous_socket">100. Asynchronous Socket</a></li>
        <li><a href="#_异步锁">101. 异步锁</a></li>
        <li><a href="#_异步进程间通信">102. 异步进程间通信</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div>

</div>

<article class="page__content" >
<div class="sect1">
<h2 id="_第一天_raku_鬼精灵_圣诞节实用指南">1. 第一天 – Raku 鬼精灵: 圣诞节实用指南</h2>
<div class="sectionbody">
<div class="paragraph">
<p>看看他们！同事、朋友和亲近的家人都在开心地笑着。他们都在享受着使用 Raku 的 6.c “圣诞”版编程的乐趣。给力的并发原语, 核心文法, 还有非常棒的对象模型。它让我印象深刻！</p>
</div>
<div class="paragraph">
<p>但是等一下…​ 就一秒。我有个想法。一个可怕的想法。我想到了一个鬼主意! 我们可以在他们的&#34;圣诞&#34;上捣乱。需要的只有一点花招。哈哈哈哈哈哈！！</p>
</div>
<div class="paragraph">
<p>欢迎来到 2017 年的 Raku 圣诞日历！每天，从今天直到圣诞节，我们都会有一篇很赞的关于 Raku 的博客推送到你面前。</p>
</div>
<div class="paragraph">
<p>今天，我们会展示我们淘气的一面并且故意地做些淘气的事情。确实，这有点用，但是淘气点更快乐。我们开始吧！</p>
</div>
<div class="sect2">
<h3 id="_but_true_does_false">1.1. But True does False</h3>
<div class="paragraph">
<p>你听过 <code>but</code> 操作符吗？一个好玩的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say True but False ?? &#39;Tis true&#39; !! &#39;Tis false&#39;;
# OUTPUT: «Tis false␤»

my  $n = 42 but &#39;forty two&#39;;
say $n;     # OUTPUT: «forty two␤»
say $n + 7; # OUTPUT: «49␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>它是一个中缀操作符，它首先拷贝它左边的对象，然后把它右边提供的 role 混进这个拷贝中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = 42 but role Evener {
    method is-even { self %% 2 }
}
say $n.is-even; # OUTPUT: «True␤»
say $n.^name;   # OUTPUT: «Int+{Evener}␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的前俩个例子中的那些不是 roles。<code>but</code> 操作符有种便捷的写法：如果 but 右边的东西不是 role，它就会给你创建一个！那个 role 只会有一个方法，以右侧对象的 <code>^name</code> 命名，并且那个方法只会简单地返回那个给定的对象。因此，这…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put True but &#39;some boolean&#39;; # OUTPUT: «some boolean␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>等价于：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put True but role {
    method ::(BEGIN &#39;some boolean&#39;.^name) {
        &#39;some boolean&#39;
    }
} # OUTPUT: «some boolean␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.^name</code> 在我们的字符串上返回 <code>Str</code>， 因为它是一个 <code>Str</code> 对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;some boolean&#39;.^name;  # OUTPUT: «Str␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以那个 role 提供了一个叫做 <code>Str</code> 的方法, 在非 <code>Str</code> 对象上调用该方法以获取字符串值的输出, 使我们的布尔值变成修改过的字符串化的表示。</p>
</div>
<div class="paragraph">
<p>举个例子，字符串 <code>0</code> 在 Rakudo Raku 中是 <code>True</code> 但是在 Perl 5 中是 <code>False</code>。使用 <code>but</code> 操作符, 我们能修改字符串的行为，让它表现的像 Perl 5 版本那样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Perl5Str {
    method Bool {
        nextsame unless self eq &#39;0&#39;;
        False
    }
}
sub perlify { $^v but Perl5Str };

say so perlify &#39;meows&#39;; # OUTPUT: «True␤»
say so perlify &#39;0&#39;;     # OUTPUT: «False␤»
say so perlify &#39;&#39;;      # OUTPUT: «False␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Perl5Str</code> 这个 role 提供了供 <code>so</code>  子例程调用的  <code>.Bool</code> 方法。在这个方法里面，我们使用 <code>nextsame</code> 子例程重新分派了原来的 <code>.Bool</code> 方法，除非那个字符串是 <code>0</code>, 那时我们仅仅返回 <code>False</code>。</p>
</div>
<div class="paragraph">
<p><code>but</code> 操作符有一个兄弟： <code>does</code> 中缀操作符。它们的行为相似，但是它不拷贝。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $o = class { method stuff { &#39;original&#39; } }.new;
say $o.stuff;  # OUTPUT: «original␤»

$o does role { method stuff { &#39;modded&#39; } };
say $o.stuff; # OUTPUT: «modded␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序中的某些东西是全局可访问的，而在有些实现（例如 Rakudo）中，某些常量被缓存了。这意味着我们可以在程序的不同部分变得很淘气，而那些圣诞节的庆祝者们甚至不知道发生了什么！</p>
</div>
<div class="paragraph">
<p>假如我们覆写了 <code>prompt</code> 子例程的读方法会怎么样？他们喜欢圣诞节？我们来给他们一些圣诞树：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$*IN does role { method get { &#34;🎄 {callsame} 🎄&#34; } }

my $name = prompt &#34;Enter your name: &#34;;
say &#34;You entered your name as: $name&#34;;

# OUTPUT
# Enter your name: (typed by user:) Zoffix Znet
# You entered your name as: 🎄 Zoffix Znet 🎄</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使我们把代码粘贴到模块中该覆盖也会起作用。 我们也可以把它提升一个档次，弄乱枚举和缓存的常量，虽然这个顽皮的举动可能将无法跨越模块边界和其他特定实现的缓存失效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">True does False;
say 42 ?? &#34;tis true&#34; !! &#34;tis false&#34;;
# OUTPUT: «tis true␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>到目前为止，这还没有达到想要的效果，但是让我们试着把我们的数字强制为 <code>Bool</code> 值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">True does False;
say 42.Bool ?? &#34;tis true&#34; !! &#34;tis false&#34;;
# OUTPUT: «tis false␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们做到了！ 而现在，对于最后的格林奇 - 值得接触，我们将混淆数字计算的数值结果。 Rakudo 缓存 <code>Int</code> 常量。 当用不同类型的数字计算时，Infix <code>+</code> 运算符也使用 <a href="https://github.com/raku/doc/issues/1690">internal-ish-ish</a> <code>.Bridge</code> 方法。 所以，让我们重写常量上的 <code>.Bridge</code> 来返回一些奇怪的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">BEGIN 42 does role { method Bridge { 12e0 } }
say 42 + 15;   # OUTPUT: «57␤»
say 42 + 15e0; # OUTPUT: «27␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是善意的邪恶，肯定会毁了圣诞节，但这只是开始…​</p>
</div>
</div>
<div class="sect2">
<h3 id="_wrapping_it_up">1.2. Wrapping It Up</h3>
<div class="paragraph">
<p>没有包装的礼物，会是什么样的圣诞节？ 哦，对于礼物，我们将有 Raku 的 <a href="https://docs.raku.org/type/Routine">Routine</a> 类型的 <a href="https://docs.raku.org/routine/wrap">.wrap</a> 方法包装他们，哦，太好了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use soft;
sub foo { say &#39;in foo&#39; }
&amp;foo.wrap: -&gt; | {
    say &#39;in the wrap&#39;;
    callsame;
    say &#39;back in the wrap&#39;;
}
foo;

# OUTPUT:
# in the wrap
# in foo
# back in the wrap</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用 <code>use soft</code> 编译指令来防止不必要的内联，否则这些内联会干扰我们的包装。然后，我们使用一个我们想要包装成一个名词的例程，通过它和 <code>＆</code> sigil 来使用它，并调用带有一个<a href="https://docs.raku.org/type/Callable"><code>Callable</code></a>的 <a href="https://docs.raku.org/routine/wrap"><code>.wrap</code></a> 方法。</p>
</div>
<div class="paragraph">
<p>给定的 <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a> 的签名必须与包装的例程（或其 <code>proto</code> 原型，如果它是一个 multi）兼容;否则我们将无法正确调度程序并使用参数调用包装器。在上面的例子中，我们只是使用匿名的 <a href="https://docs.raku.org/type/Capture"><code>Capture</code></a>（<code>|</code>）来接受所有可能的参数。</p>
</div>
<div class="paragraph">
<p>在 <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a> 里面，我们有两个 <a href="https://docs.raku.org/routine/say"><code>say</code></a> 调用，并使用 <a href="https://rakudo.party/post/Raku-But-Heres-My-Dispatch-So-Callwith-Maybe">callsame</a> 例程来调用下一个可用的调度候选者，这正好是我们原来的例程。这很方便，因为我们试图在包装器中按照它的名字来调用 <code>foo</code> ，我们将从头开始调度，导致无限的调度循环。</p>
</div>
<div class="paragraph">
<p>既然方法是 <a href="https://docs.raku.org/type/Routine">Routine</a>，我们也可以把它们包装起来。我们可以使用 <code>.^lookup</code> 元方法来获取 <a href="https://docs.raku.org/type/Method"><code>Method</code></a> 对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">IO::Handle.^lookup(&#39;print&#39;).wrap: my method (|c) {
    my &amp;wrapee = nextcallee;
    wrapee self, &#34;🎄 Ho-ho-ho! 🎄\n&#34;;
    wrapee self, |c
};

print &#34;Hello, World!\n&#34;;

# OUTPUT:
# 🎄 Ho-ho-ho! 🎄
# Hello, World!</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们从 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 类型中获取 <a href="https://docs.raku.org/routine/print">.print</a> 方法，然后包装它。我们希望在方法内部使用 <code>self</code>，所以我们使用独立的方法（<code>my method …</code>）来代替块或子例程。我们想使用 <code>self</code> 的原因是能够调用我们包装的方法来打印我们的 Christmassy 消息。因为我们的方法是分离的，<a href="https://rakudo.party/post/Raku-But-Heres-My-Dispatch-So-Callwith-Maybe">callwith</a> 和相关的例程将需要与其他参数一起自我馈送，以确保我们继续分派给正确的对象。</p>
</div>
<div class="paragraph">
<p>在 wrap 中，我们使用 <code>nextcallee</code> 例程来获得原始的方法。如果它是一个 <code>multi</code>，我们将得到 <code>proto</code>，而不是一个与原始参数最匹配的特定候选者，所以相比传统的例程，下一个 <a href="https://rakudo.party/post/Raku-But-Heres-My-Dispatch-So-Callwith-Maybe#haveyoutriedtocallthemwith…​">candidate ordering</a> 候选排序在 wrap 中略有不同。我们把 <code>nextcallee</code> 放到一个变量中，因为我们想多次调用它，调用它将例程从调度栈中移出。在第一个调用中，我们打印了我们的 Christmass 信息，而在第二个调用中，我们只是 slip 我们的原始参数的 <a href="https://docs.raku.org/type/Capture">Capture</a>（<code>|c</code>），完成了原来想要发生的调用。</p>
</div>
<div class="paragraph">
<p>感谢 <a href="https://docs.raku.org/routine/wrap">.wrap</a>，我们可以改变甚至完全重新定义子程序和方法的行为，当你的朋友尝试使用它们的时候肯定会很快乐。哈哈哈！</p>
</div>
</div>
<div class="sect2">
<h3 id="_看不见的斗篷">1.3. 看不见的斗篷</h3>
<div class="paragraph">
<p>我们到目前为止所玩的技巧是非常可怕的，但它们太明显，太…​明显。 由于 Raku 具有极好的 Unicode 支持，所以我认为我们应该搜索大量的 Unicode 字符来获得一些有趣的恶作剧。 特别是，我们正在寻找不是空白的隐形字符。 我们的目的只有一个就足够了，但是这四个在我的电脑上是相当隐蔽的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[⁠] U+2060 WORD JOINER [Cf]
[⁡] U+2061 FUNCTION APPLICATION [Cf]
[⁢] U+2062 INVISIBLE TIMES [Cf]
[⁣] U+2063 INVISIBLE SEPARATOR [Cf]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 支持可以由任何字符组成的自定义术语和操作符，除了空格之外。 例如，这是我的专利耸肩操作符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;¯\(°_o)/¯&gt; {
    ($^a, $^b).pick
}

say &#39;Coke&#39; ¯\(°_o)/¯ &#39;Pepsi&#39;;
# OUTPUT: «Pepsi␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个由非标识字符组成的术语（我们也可以在定义中使用真实的字符）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub term:«\c[family: woman woman boy boy]» {
    &#39;♫ We— are— ♪ faaaamillyyy ♬&#39;
}
say 👩‍👩‍👦‍👦;
# OUTPUT: «♫ We— are— ♪ faaaamillyyy ♬»</code></pre>
</div>
</div>
<div class="paragraph">
<p>用我们看不见的非空白字符，我们可以使无形的操作符和术语！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:«\c[INVISIBLE TIMES]» { $^a × $^b }
my \r = 42;

say &#34;Area of the circle is &#34; ~ π⁢r²;
# OUTPUT: «Area of the circle is 5541.76944093239␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们来创建一个 <code>Jolly</code> 模块，它将导出一些不可见的术语和操作符。 然后我们把它们撒在我们的 Christmassy朋友的代码中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module Jolly;

sub   term:«\c[INVISIBLE TIMES]» is export { 42 }
sub  infix:«\c[INVISIBLE TIMES]» is export {
    $^a × $^b
}
sub prefix:«\c[INVISIBLE SEPARATOR]» (|)
    is looser(&amp;[,]) is export
{
    say &#34;Ho-ho-ho!&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们对术语和中缀操作符使用了相同的字符。 这很好，因为 Raku 对操作符有相当严格的期望，反之亦然，所以它会知道我们什么时候使用该术语或何时使用中缀操作符。 下面是由此产生的 Grinch 代码，以及它产生的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">⁣say 42⁢⁢;

# OUTPUT:
# 1764
# Ho-ho-ho!</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将确保调试的乐趣！ 以下是该行代码中的字符列表，供您查看我们使用隐形好东西的位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for &#39;⁣say 42⁢⁢;&#39;.uninames;

# OUTPUT:
# INVISIBLE SEPARATOR
# LATIN SMALL LETTER S
# LATIN SMALL LETTER A
# LATIN SMALL LETTER Y
# SPACE
# DIGIT FOUR
# DIGIT TWO
# INVISIBLE TIMES
# INVISIBLE TIMES
# SEMICOLON</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ho_ho_ho">1.4. Ho-Ho-Ho</h3>
<div class="paragraph">
<p>圣诞节时的生产力下降到停滞状态。 人们心中都有节日和新年。 在所有代码中看到大量的 TODO 注释并不让我感到惊讶。 但是如果我们能够发现并投诉他们呢？ 只要有人感到懒惰，没有什么比 Grinch 更像编程了！</p>
</div>
<div class="paragraph">
<p>Raku 有俚语。 这是一个实验性的功能，目前还没有一个官方支持的接口，但是，对于我们的目的来说，它会做的很好。</p>
</div>
<div class="paragraph">
<p>使用俚语，可以在词法上改变 Raku 的文法，并引入语言特性和行为，就像 Raku 核心开发者一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">BEGIN $*LANG.refine_slang: &#39;MAIN&#39;,
    role SomeExtraGrammar {
        token term:sym&lt;meow&gt; {
            &#39;This is not a syntax error&#39;
        }
    },
    role SomeExtraActions {
        method EXPR (Mu $/) {
            say &#34;Parsed expression: &#34; ~ $/;
            nextsame
        }
    }

This is not a syntax error;
say &#39;hehe&#39;

# OUTPUT:
# Parsed expression: This is not a syntax error
# Parsed expression: &#39;hehe&#39;
# Parsed expression: say &#39;hehe&#39;
# hehe</code></pre>
</div>
</div>
<div class="paragraph">
<p>俚语功能的“实验性”部分主要在于不得不依靠 <a href="https://github.com/rakudo/rakudo/blob/master/src/Raku/Grammar.nqp">core Grammar</a> 和 <a href="https://github.com/rakudo/rakudo/blob/master/src/Raku/Actions.nqp">core Actions</a> 的结构;目前没有官方保证这些将保持不变，这使得俚语变得脆弱。</p>
</div>
<div class="paragraph">
<p>对于我们调皮的 Grinchy 技巧，我们将修改注释的行为，如果我们读取代码来追踪调用 <a href="https://github.com/rakudo/rakudo/blob/79390147ac6b874f7c01c5818520cc5b31bde042/src/Raku/Grammar.nqp#L700-L702">the comment token</a> 的代码，我们会发现它实际上是重新定义的 <a href="https://github.com/rakudo/rakudo/blob/79390147ac6b874f7c01c5818520cc5b31bde042/src/Raku/Grammar.nqp#L652-L666">ws</a> token 的一部分，正如您可能从每天都知道的 Raku 文法除其他外，负责语法规则中的空白匹配。</p>
</div>
<div class="paragraph">
<p>这个问题稍微复杂一些，因为 <code>ws</code> 是一个基石标记，与 <code>comp_unit</code>，<code>statementlist</code> 和 <code>statement</code> 一起，它不能在 mainline（例程和块之外的代码）中修改。原因是在使用这些令牌的股票版本解析主线之后，俚语被加载。<code>statement</code>  token 内的标记甚至可以在 mainline 中更改，因为 <code>statement</code>  标记会 reblesses 文法，但是 <code>ws</code> 不会获得如此的奢侈。</p>
</div>
<div class="paragraph">
<p>既然我们已经开始深入到底了…​…​足够的话了！我们来写代码吧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">BEGIN $*LANG.refine_slang: &#39;MAIN&#39;, role {
    token comment:sym&lt;todo&gt; {
        &#39;#&#39; \s* &#39;TODO&#39; &#39;:&#39;? \s+ &lt;( \N*
        { die &#34;Ho-ho-ho! I think you were&#34;
            ~ &#34; meant to finish &#34; ~ $/ }
    }
}

sub business-stuff {
    # TODO: business stuff
}

# OUTPUT:
# ===SORRY!===
# Ho-ho-ho! I think you were meant to finish business stuff</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用 <a href="https://docs.raku.org/language/phasers">BEGIN phaser</a> 在编译时进行俚语修改，因为我们试图影响如何进一步编译。</p>
</div>
<div class="paragraph">
<p>我们添加了一个新的 <code>proto</code> 标记： <code>comment:sym&lt;todo&gt;</code> 到核心 Raku 文法，匹配类似于常规注释匹配的内容，除了它还寻找我们的 Christmassy 朋友决定离开的 <code>TODO</code>。 <code>\N*</code> 原子捕获用户在 <code>TODO</code> 之后键入的字符串，匹配捕获标记指示编译器将存储在 <code>$/</code> 变量中的匹配对象内的捕获文本中的以前匹配的东西排除在外。</p>
</div>
<div class="paragraph">
<p>在 token 的末尾，我们简单地使用一个代码块来告诉用户完成他们的 TODO 的消息。 很狡猾！</p>
</div>
<div class="paragraph">
<p>由于我们宁愿用户不注意我们的诡计，让我们将俚语粘贴到目标代码将要加载的模块中。 我们只是稍微调整一下原来的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># File: ./Jolly.pm6
sub EXPORT {
    $*LANG.refine_slang: &#39;MAIN&#39;, role {
        token comment:sym&lt;todo&gt; {
            &#39;#&#39; \s* &#39;TODO&#39; &#39;:&#39;? \s+ &lt;( \N*
            { die &#34;Ho-ho-ho! I think you were&#34;
                ~ &#34; meant to finish &#34; ~ $/ }
        }
    }

    Map.new
}

# File: ./script.p6
use lib &lt;.&gt;;
use Jolly;

sub business-stuff {
    # TODO: business stuff
}

# OUTPUT:
# ===SORRY!===
# Ho-ho-ho! I think you were meant to finish business stuff</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们希望俚语在脚本的编译时运行，而不是在模块中，所以我们删除了 <code>BEGIN</code> phaser，而是将代码固定在 <a href="https://docs.raku.org/language/modules#index-entry-sub_EXPORT">sub EXPORT</a> 中，在脚本编译过程中使用该模块时运行。 <code>Map.new</code> 就是我喜欢在 <code>EXPORT</code>  sub 中写 <code>{}</code>，以表示我们不希望导出任何符号。 在我们的脚本中，我们现在只需要使用模块，俚语被激活。真棒！</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论">1.5. 结论</h3>
<div class="paragraph">
<p>今天，我们开始淘气的 Grinches 2017 年的 Raku 的降临日历和搞乱用户的程序。 我们使用 <code>but`和 `does</code> 操作符来改变对象。 包装的方法和子程序与我们的自定义例程，实现额外的功能。 做出隐形术语和操作符。 甚至突变语言本身来做我们的竞标。</p>
</div>
<div class="paragraph">
<p>在接下来的 23 天里，我们会看到更多的 Raku Advent 文章，所以一定要回头看看。 也许，到这一切的尽头，我们的 Grinchy 心将长大三个尺寸…​</p>
</div>
<div class="paragraph">
<p>-Ofun</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二天_raku_符号_变量和容器">2. 第二天-Raku: 符号, 变量和容器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>对容器的基本理解对于在 Raku 中进行愉快的编程是至关重要的。它们无处不在，不仅影响你获得的变量类型，还决定了 <a href="https://docs.raku.org/type/List"><code>List</code></a> 和 <a href="https://docs.raku.org/type/Map"><code>Map</code></a> 在迭代时的行为方式。</p>
</div>
<div class="paragraph">
<p>今天，我们将学习什么是容器，以及如何使用它们，但是首先，我希望你暂时忘记你对 Raku 的符号和变量的所有知识或怀疑，特别是如果你来自 Perl 5 的背景。 忘记一切。</p>
</div>
<div class="sect2">
<h3 id="_把钱拿出来">2.1. 把钱拿出来</h3>
<div class="paragraph">
<p>在 Raku 中，变量以 <code>$</code> 符号为前缀，用绑定运算符（<code>:=</code>）赋值。 像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $foo := 42;
say &#34;The value is $foo&#34;; # OUTPUT: «The value is 42␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你已经按照我的建议来忘记你所知道的一切，那么学习 <a href="https://docs.raku.org/type/List"><code>List</code></a> 和 <a href="https://docs.raku.org/type/Hash"><code>Hash</code></a> 类型也是一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $ordered-things := &lt;foo bar ber&gt;;
my $named-things   := %(:42foo, :bar&lt;ber&gt;);

say &#34;$named-things&lt;foo&gt; bottles of $ordered-things[2] on the wall&#34;;
# OUTPUT: «42 bottles of ber on the wall␤»

.say for $ordered-things;  # OUTPUT: «foo␤bar␤ber␤»
.say for $named-things;    # OUTPUT: «bar =&gt; ber␤foo =&gt; 42␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>了解这一点，你可以写出各种各样的程序，所以如果你开始觉得有太多的东西需要学习，记住你不需要一次学习所有东西。</p>
</div>
</div>
<div class="sect2">
<h3 id="_我们祝你有一个愉快的列表圣诞">2.2. 我们祝你有一个愉快的列表圣诞</h3>
<div class="paragraph">
<p>让我们试着用我们的变量做更多的事情。 想要更改列表中的值并不罕见。 到目前为止我们的表现如何呢？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list := (1, 2, 3);
$list[0] := 100;
# OUTPUT: «Cannot use bind operator with this left-hand side […] »</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管我们可以绑定到变量，但是如果我们试图绑定到某个值，我们会得到一个错误，无论这个值是来自 <a href="https://docs.raku.org/type/List"><code>List</code></a> 还是只是一个字面值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1 := 100;
# OUTPUT: «Cannot use bind operator with this left-hand side […] »</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是为什么列表是不可变的。 然而，这是一个实现愿望的季节，所以我们希望有一个可变的<a href="https://docs.raku.org/type/List"><code>List</code></a>！</p>
</div>
<div class="paragraph">
<p>我们需要掌握的是一个 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 对象，因为绑定操作符可以使用它。 顾名思义，一个 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 存储一个东西。 你不能通过 <a href="https://docs.raku.org/routine/new"><code>.new</code></a> 方法实例化一个 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a>，但是我们可以通过声明一些词法变量来得到它们。 不需要费心给他们的名字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list := (my $, my $, my $);
$list[0] := 100;
say $list; # OUTPUT: «(100 (Any) (Any))␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出中的 <code>(Any)</code> 是容器的默认值（稍后一点）。 上面，似乎我们设法在 <a href="https://docs.raku.org/type/List"><code>List</code></a> 创建后将一个值绑定到列表的元素上，我们不是吗？ 确实我们做了，但是…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list := (my $, my $, my $);
$list[0] := 100;
$list[0] := 200;
# OUTPUT: «Cannot use bind operator with this left-hand side […] »</code></pre>
</div>
</div>
<div class="paragraph">
<p>绑定操作用一个新的值（<code>100</code>）代替 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器，所以如果我们试图再次绑定，我们又回到了原来的方括号那个，试图绑定到一个值，而不是一个容器。</p>
</div>
<div class="paragraph">
<p>我们需要一个更好的工具。</p>
</div>
</div>
<div class="sect2">
<h3 id="_thats_your_assignment">2.3. That’s Your Assignment</h3>
<div class="paragraph">
<p>绑定运算符有一个表亲：赋值运算符（<code>=</code>）。 我们不用一个绑定操作符替换我们的 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器，而是使用赋值操作符来赋值或者“存储”我们在容器中的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list := (my $ = 1, my $ = 2, my $ = 3);
$list[0] = 100;
$list[0] = 200;
say $list;
# OUTPUT: «(200 2 3)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以从一开始就指定我们的原始值，并且可以随时用其他值替换它们。 我们甚至可以变得时髦，并在每个容器上放置不同的类型约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $list := (my Int $ = 1, my Str $ = &#39;2&#39;, my Rat $ = 3.0);
$list[0] = 100; # OK!
$list[1] = 42;  # Typecheck failure!

# OUTPUT: «Type check failed in assignment;
#    expected Str but got Int (42) […] »</code></pre>
</div>
</div>
<div class="paragraph">
<p>这有些放纵，但有一件事可以使用类型约束：<code>$list</code> 变量。 我们将其限制为 <a href="https://docs.raku.org/type/Positional"><code>Positional</code></a> 角色，以确保它只能保持 <a href="https://docs.raku.org/type/Positional"><code>Positional</code></a> 类型，就像 <a href="https://docs.raku.org/type/List"><code>List</code></a> 和 <a href="https://docs.raku.org/type/Array"><code>Array</code></a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Positional $list := (my $ = 1, my $ = &#39;2&#39;, my $ = 3.0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>不知你咋想的，但是这对我来说看起来非常冗长。 幸运的是，Raku 有语法来简化它！</p>
</div>
</div>
<div class="sect2">
<h3 id="_positionlly">2.4. Position@lly</h3>
<div class="paragraph">
<p>首先，让我们摆脱变量的显式类型约束。 在 Raku 中，您可以使用 <code>@</code> 而不是 <code>$</code> 作为符号来表示您希望变量受到角色 <a href="https://docs.raku.org/type/Positional"><code>Positional</code></a> 的类型约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @list := 42;
# OUTPUT: «Type check failed in binding;
#   expected Positional but got Int (42) […] »</code></pre>
</div>
</div>
<div class="paragraph">
<p>其次，我们将使用方括号来代替圆括号来存储我们的 <a href="https://docs.raku.org/type/List"><code>List</code></a>。 这告诉编译器创建一个 <a href="https://docs.raku.org/type/Array"><code>Array</code></a> 而不是一个 <a href="https://docs.raku.org/type/List"><code>List</code></a>。 <a href="https://docs.raku.org/type/Array"><code>Array</code></a>s 是可变的，它们将每个元素自动粘贴到 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器中，就像我们在前一节中手动操作一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @list := [1, &#39;2&#39;, 3.0];
@list[0] = 100;
@list[0] = 200;
say @list;
# OUTPUT: «[200 2 3]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的代码变得更短了，但我们可以折腾更多的字符。 就像赋值给`$<code>-sigiled 变量而不是绑定一样，你可以赋值给</code>@` -sigiled 变量来获得一个自由的 <a href="https://docs.raku.org/type/Array"><code>Array</code></a>。 如果我们切换到赋值，我们可以完全摆脱方括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @list = 1, &#39;2&#39;, 3.0;</code></pre>
</div>
</div>
<div class="paragraph">
<p>好，简洁。</p>
</div>
<div class="paragraph">
<p>类似的想法背后是 <code>％</code> - 和 <code>&amp;</code> 符号化的变量。 <code>％</code> sigil 意味着 <a href="https://docs.raku.org/type/Associative"><code>Associative</code></a> 角色的类型约束，并为赋值提供相同的快捷方式（给你一个 <a href="https://docs.raku.org/type/Hash"><code>Hash</code></a>），并为这些值创建 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器。 对于角色 <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a> 和赋值的 <code>＆</code>-sigiled变量类型 - 行为类似于 <code>$</code> sigils，给出一个可以修改其值的自由 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my  %hash = :42foo, :bar&lt;ber&gt;;
say %hash;  # OUTPUT: «{bar =&gt; ber, foo =&gt; 42}␤»

my &amp;reversay = sub { $^text.flip.say }
reversay &#39;6 lreP ♥ I&#39;; # OUTPUT: «I ♥ Raku␤»

# store a different Callable in the same variable
&amp;reversay = *.uc.say;  # a WhateverCode object
reversay &#39;I ♥ Raku&#39;; # OUTPUT: «I ♥ PERL 6␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_one_and_only">2.5. The One and Only</h3>
<div class="paragraph">
<p>之前我们知道赋值给 <code>$</code> -sigiled 变量会给你一个免费的 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器。 由于标量，顾名思义，只包含一个东西…​…​如果你把一个 <a href="https://docs.raku.org/type/List"><code>List</code></a> 放到 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 中会发生什么？ 毕竟，当你试图这样做的时候，宇宙仍然没有被扼杀：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my  $listish = (1, 2, 3);
say $listish; # OUTPUT: «(1 2 3)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样的行为可能使 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 看起来似乎是一个用词不当，但它确实把整个列表视为一个东西。 我们可以通过几种方式观察其差异。 我们来比较绑定到 <code>$</code> -sigiled 变量的 <a href="https://docs.raku.org/type/List"><code>List</code></a>（所以不包含 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a>）和赋值给 <code>$</code> -sigiled 变量（自动 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器）的 <a href="https://docs.raku.org/type/List"><code>List</code></a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Binding:
my  $list := (1, 2, 3);
say $list.perl;
say &#34;Item: $_&#34; for $list;

# OUTPUT:
# (1, 2, 3)
# Item: 1
# Item: 2
# Item: 3


# Assignment:
my $listish = (1, 2, 3);
say $listish.perl;
say &#34;Item: $_&#34; for $listish;

# OUTPUT:
# $(1, 2, 3)
# Item: 1 2 3</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/routine/perl"><code>.perl</code></a> 方法给了我们一个额外的见解，并在第二个 <a href="https://docs.raku.org/type/List"><code>List</code></a> 之前显示了一个 <code>$</code>，以表明它在 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 中是集装箱化的。 更重要的是，当我们用 <code>for</code> 循环迭代我们的 <a href="https://docs.raku.org/type/List"><code>List</code></a>s 时，第二个 <a href="https://docs.raku.org/type/List"><code>List</code></a> 结果只有一个迭代：整个 <a href="https://docs.raku.org/type/List"><code>List</code></a> 作为一个项目！ <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 没有辜负它的名字。</p>
</div>
<div class="paragraph">
<p>这种行为不仅仅是学术上的兴趣。 回想一下，<a href="https://docs.raku.org/type/Array"><code>Array</code></a>s（和<a href="https://docs.raku.org/type/Hash"><code>Hash</code></a>es）为它们的值创建<a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器。 这意味着如果我们嵌套东西，即使我们选择一个单独的列表或散列在里面存储着 <a href="https://docs.raku.org/type/Array"><code>Array</code></a>（或 <a href="https://docs.raku.org/type/Hash"><code>Hash</code></a>），并试图迭代它，它将只被视为一个单一的项目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @stuff = (1, 2, 3), %(:42foo, :70bar);
say &#34;List Item: $_&#34; for @stuff[0];
say &#34;Hash Item: $_&#34; for @stuff[1];

# OUTPUT:
# List Item: 1 2 3
# Hash Item: bar  70
# foo 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样的推理（即 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器中的列表和散列是单个项目）适用于当您试图压扁 <a href="https://docs.raku.org/type/Array"><code>Array</code></a> 的元素或将它们作为参数传递给 <a href="https://docs.raku.org/type/Signature#index-entry-parameter_%2A%40-parameter_%2A%2525_slurpy_argument_%28Signature%29-Slurpy_%28A.K.A._Variadic%29_Parameters">slurpy</a> 参数时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @stuff = (1, 2, 3), %(:42foo, :70bar);
say flat @stuff;
# OUTPUT: «((1 2 3) {bar =&gt; 70, foo =&gt; 42})␤»

-&gt; *@args { @args.say }(@stuff)
# OUTPUT: «[(1 2 3) {bar =&gt; 70, foo =&gt; 42}]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>正是这种行为可以将 Raku 初学者推上墙，特别是那些来自 Perl 5 自动展平语言的人。然而，现在我们知道为什么会出现这种行为，我们可以改变它！</p>
</div>
</div>
<div class="sect2">
<h3 id="_decont">2.6. Decont</h3>
<div class="paragraph">
<p>如果 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器是罪魁祸首，我们所要做的就是删除它。 我们需要将我们的列表和哈希值去容器化，或者简称为 “decont”。 在你的 Raku 之旅中，你可以找到几种方法来完成这个工作，但是为此设计的一个方法就是 decont methodop（<code>&lt;&gt;</code>）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @stuff = (1, 2, 3), %(:42foo, :70bar);
say &#34;Item: $_&#34; for @stuff[0]&lt;&gt;;
say &#34;Item: $_&#34; for @stuff[1]&lt;&gt;;

# OUTPUT:
# Item: 1
# Item: 2
# Item: 3
# Item: bar   70
# Item: foo   42</code></pre>
</div>
</div>
<div class="paragraph">
<p>它很容易记住：它看起来像一个被挤压的盒子（一个被踩踏的容器）。 在通过索引到 <a href="https://docs.raku.org/type/Array"><code>Array</code></a> 中检索我们的容器化项目之后，我们附加了 decont 并从 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器中移除了内容，导致我们的循环遍历它们中的每个项目。</p>
</div>
<div class="paragraph">
<p>如果您希望一次去除 <a href="https://docs.raku.org/type/Array"><code>Array</code></a> 中的每个元素，只需使用超运算符（<code>»</code>，或 <code>&gt;&gt;</code>，如果您更喜欢使用 ASCII）就可以使用 decont：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @stuff = (1, 2, 3), %(:42foo, :70bar);
say flat @stuff»&lt;&gt;;
# OUTPUT: «(1 2 3 bar =&gt; 70 foo =&gt; 42)␤»

-&gt; *@args { @args.say }(@stuff»&lt;&gt;)
# OUTPUT: «[1 2 3 bar =&gt; 70 foo =&gt; 42]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>随着容器被删除，我们的列表和散列就像我们想要的那样变平。 当然，我们可以避免使用 <a href="https://docs.raku.org/type/Array"><code>Array</code></a>，而将原始 <a href="https://docs.raku.org/type/List"><code>List</code></a> 绑定到变量上。 由于 <a href="https://docs.raku.org/type/List"><code>List</code></a> 没有把它们的元素放入容器，所以没有任何东西可以去除：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @stuff := (1, 2, 3), %(:42foo, :70bar);
say flat @stuff;
# OUTPUT: «(1 2 3 bar =&gt; 70 foo =&gt; 42)␤»

-&gt; *@args { @args.say }(@stuff)
# OUTPUT: «[1 2 3 bar =&gt; 70 foo =&gt; 42]␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_不要让它溜走">2.7. 不要让它溜走</h3>
<div class="paragraph">
<p>当我们在这里的时候，值得注意的是，当他们想要执行decont（我们不是在传递参数给 <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a> 的时候使用它）时，许多人使用 *slip*运算符（<code>|</code>）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @stuff = (1, 2, 3), (4, 5);
say &#34;Item: $_&#34; for |@stuff[0];

# OUTPUT:
# Item: 1
# Item: 2
# Item: 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然它可以完成工作，但可能会引入微妙的 bugs，这些 bug 可能很难追查到。 尝试在这里找到一个，在一个程序中迭代了一个无限的非负整数列表，并打印那些素数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $primes = ^∞ .grep: *.is-prime;
say &#34;$_ is a prime number&#34; for |$primes;</code></pre>
</div>
</div>
<div class="paragraph">
<p>放弃？ 这个程序会导致内存泄漏…​ 非常缓慢。 尽管我们遍历了无限的项目列表，但这不是问题，因为 <a href="https://docs.raku.org/routine/grep"><code>.grep</code></a> 方法返回的 <a href="https://docs.raku.org/type/Seq"><code>Seq</code></a> 对象不会保留已经迭代的项目，因此内存使用永远不会增长。</p>
</div>
<div class="paragraph">
<p>有问题的部分是我们的 <code>|</code>  slip 操作符。 它将我们的 <a href="https://docs.raku.org/type/Seq"><code>Seq</code></a> 转换成一个 <a href="https://docs.raku.org/type/Slip"><code>Slip</code></a> ，这是一个 <a href="https://docs.raku.org/type/List"><code>List</code></a> 类型，并且保存我们已经消耗的所有的值。 如果您希望在 <a href="http://hisham.hm/htop/"><code>htop</code></a> 中看到增长，那么这个程序的修改版本会更快地增长：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># CAREFUL! Don&#39;t consume all of your resources!
my $primes = ^∞ .map: *.self;
Nil for |$primes;</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们再试一次，但是这次使用 decont 方法 op：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $primes = ^∞ .map: *.self;
Nil for $primes&lt;&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>内存使用现在是稳定的，程序可以坐在那里迭代直到时间结束。 当然，因为我们知道这是 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器导致的容器化，我们希望在这里避免它，所以我们可以简单地将 <a href="https://docs.raku.org/type/Seq"><code>Seq</code></a> 绑定到变量上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $primes := ^∞ .map: *.self;
Nil for $primes;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_i_want_less">2.8. I Want Less</h3>
<div class="paragraph">
<p>如果你讨厌符号，Raku 会得到一些你可以微笑的东西：无符号的变量。 只要在声明中加一个反斜杠的前缀，表示你不想要讨厌的符号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my \Δ = 42;
say Δ²; # OUTPUT: «1764␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>你不会得到任何这样的变量的自由 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a>，因此，在声明期间，绑定或赋值给他们没有任何区别。 它们的行为类似于将值绑定到 <code>$</code> -sigiled 变量的行为，包括绑定 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a>s 并使变量可变：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my \Δ = my $ = 42;
Δ = 11;
say Δ²; # OUTPUT: «121␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个更常见的地方，你可能会看到这样的变量是作为例程的参数，在这里，这意味着你想把 <code>is raw</code> trait 应用到参数上。 这在 <a href="https://docs.raku.org/type/Signature#index-entry-%2B_%28Single_Argument_Rule_Slurpy%29"><code>+</code> positional slurpy</a> 参数的含义也是存在的（不需要反斜杠），如果它是 <code>is raw</code> 的，意味着你将不会得到不需要的 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 容器，因为它是一个 <a href="https://docs.raku.org/type/Array"><code>Array</code></a>，因为它具有 <code>@</code> sigil：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub sigiled ($x is raw, +@y) {
    $x = 100;
    say flat @y
}

sub sigil-less (\x, +y) {
    x = 200;
    say flat y
}

my $x = 42;
sigiled    $x, (1, 2), (3, 4); # OUTPUT: «((1 2) (3 4))␤»
say $x;                        # OUTPUT: «100␤»

sigil-less $x, (1, 2), (3, 4); # OUTPUT: «(1 2 3 4)␤»
say $x;                        # OUTPUT: «200␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defaulting_on_default_defaults">2.9. Defaulting on Default Defaults</h3>
<div class="paragraph">
<p>容器提供的一个很棒的功能是默认值。 你可能听说过在 Raku 中，`Nil`表示缺少一个值，而不是一个值。 容器默认值就是它的作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x is default(42);
say $x;   # OUTPUT: «42␤»

$x = 10;
say $x;   # OUTPUT: «10␤»

$x = Nil;
say $x;   # OUTPUT: «42␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个容器的默认值是使用 <a href="https://docs.raku.org/type/Variable#index-entry-trait_is_default_%28Variable%29-trait_is_default"><code>is default</code> trait</a> 给它的。 它的参数是在编译时计算的，每当容器缺少一个值时，就使用结果值。 由于 <code>Nil</code> 的工作是表明这一点，因此将 <code>Nil</code> 分配到容器中将导致容器包含其默认值，而不是 <code>Nil</code>。</p>
</div>
<div class="paragraph">
<p>可以给 <a href="https://docs.raku.org/type/Array"><code>Array</code></a> 和 <a href="https://docs.raku.org/type/Hash"><code>Hash</code></a> 容器赋予默认值，如果你希望你的容器在字面上包含 <code>Nil</code>，当没有值时，只需要指定 <code>Nil</code> 作为默认值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a is default&lt;meow&gt; = 1, 2, 3;
say @a[0, 2, 42]; # OUTPUT: «(1 3 meow)␤»

@a[0]:delete;
say @a[0];        # OUTPUT: «meow␤»

my %h is default(Nil) = :bar&lt;ber&gt;;
say %h&lt;bar foos&gt;; # OUTPUT: «(ber Nil)␤»

%h&lt;bar&gt;:delete;
say %h&lt;bar&gt;       # OUTPUT: «Nil␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>容器的默认值有一个默认的默认值：容器上的显式类型约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say my Int $y; # OUTPUT: «(Int)␤»
say my Mu  $z; # OUTPUT: «(Mu)␤»

say my Int $i where *.is-prime; # OUTPUT: «(&lt;anon&gt;)␤»
$i.new; # OUTPUT: (exception) «You cannot create […]»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有明确的类型约束，默认的默认值是一个 <a href="https://docs.raku.org/type/Any"><code>Any</code></a> 类型的对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say my $x;    # OUTPUT: «(Any)␤»
say $x = Nil; # OUTPUT: «(Any)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，您可能在可选参数的例程签名中使用的默认值不是容器默认值，将 <code>Nil</code> 分配给子例程参数或分配给参数不会使用签名中的默认值。</p>
</div>
</div>
<div class="sect2">
<h3 id="_自定义">2.10. 自定义</h3>
<div class="paragraph">
<p>如果容器的标准行为不适合您的需求，您可以使用 <a href="https://docs.raku.org/type/Proxy"><code>Proxy</code></a> 类型创建自己的容器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $collector := do {
    my @stuff;
    Proxy.new: :STORE{ @stuff.push: @_[1] },
               :FETCH{ @stuff.join: &#34;|&#34;   }
}

$collector = 42;
$collector = &#39;meows&#39;;
say $collector; # OUTPUT: «42|meows␤»

$collector = &#39;foos&#39;;
say $collector; # OUTPUT: «42|meows|foos␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>接口有点笨重，但它完成了工作。我们使用 <a href="https://docs.raku.org/routine/new"><code>.new</code></a> 方法创建 <a href="https://docs.raku.org/type/Proxy"><code>Proxy</code></a> 对象，该方法需要两个必需的命名参数：<code>STORE</code> 和 <code>FETCH</code>，每个都带一个 <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a>。</p>
</div>
<div class="paragraph">
<p>每当从容器中读取一个值时，<code>FETCH`<a href="https://docs.raku.org/type/Callable">`Callable</a></code> 被调用，这可能比直接看到的次数多出现一次：在上面的代码中，当容器通过调度和例程这两个调用渗透时，<code>FETCH`<a href="https://docs.raku.org/type/Callable">`Callable</a></code> 被调用10次。 <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a> 被调用一个单一的位置参数：<a href="https://docs.raku.org/type/Proxy"><code>Proxy</code></a> 对象本身。</p>
</div>
<div class="paragraph">
<p>无论何时将值存储到我们的容器中（例如，使用赋值运算符（<code>=</code>）），<code>STORE</code> <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a> 都会被调用。 <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a> 的第一个位置参数是 <a href="https://docs.raku.org/type/Proxy"><code>Proxy</code></a> 对象本身，第二个参数是存储的值。</p>
</div>
<div class="paragraph">
<p>我们希望 <code>STORE</code> 和 <code>FETCH</code>  <a href="https://docs.raku.org/type/Callable"><code>Callable</code></a> 共享 <code>@stuff</code> 变量，所以我们使用 <a href="https://docs.raku.org/syntax/do"><code>do</code> statement prefix</a> 和一个代码块来很好地包含它。</p>
</div>
<div class="paragraph">
<p>我们将我们的 <a href="https://docs.raku.org/type/Proxy"><code>Proxy</code></a> 绑定到一个变量，其余的只是正常的变量用法。输出显示我们的自定义容器提供的改变过的行为。</p>
</div>
<div class="paragraph">
<p>Proxies 也可以方便地作为返回值来提供具有可变属性的额外行为。例如，这里有一个属性，从外部看来只是一个正常的可变属性，但实际上强制它的值从 <a href="https://docs.raku.org/type/Any"><code>Any</code></a> 任何类型变为 <a href="https://docs.raku.org/type/Int"><code>Int</code></a> 类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Foo {
    has $!foo;
    method foo {
        Proxy.new: :STORE(-&gt; $, Int() $!foo { $!foo }),
                   :FETCH{ $!foo }
    }
}

my $o = Foo.new;
$o.foo = &#39; 42.1e0 &#39;;
say $o.foo; # OUTPUT: «42␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>很甜蜜！ 如果你想要一个更好的接口的 <a href="https://docs.raku.org/type/Proxy"><code>Proxy</code></a> 与一些更多的功能，请检查 <a href="http://modules.raku.org/dist/Proxee">Proxee</a> 模块。</p>
</div>
</div>
<div class="sect2">
<h3 id="_这就是全部伙计">2.11. 这就是全部，伙计</h3>
<div class="paragraph">
<p>那关于这一切。 在 Raku 中你将会看到的剩下的动物是 “twigils”：名称前带有两个符号的变量，但是就容器而言，它们的行为与我们所介绍的变量相同。 第二个符号只是表示附加信息，如变量是隐含的位置参数还是命名参数…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub test { say &#34;$^implied @:parameters[]&#34; }
test &#39;meow&#39;, :parameters&lt;says the cat&gt;;
# OUTPUT: «meow says the cat␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>…​或者该变量是私有属性还是公共属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">with class Foo {
    has $!foo = 42;
    has @.bar = 100;
    method what&#39;s-foo { $!foo }
}.new {
    say .bar;       # OUTPUT: «[100]␤»
    say .what&#39;s-foo # OUTPUT: «42␤»
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而，这是另一天的旅程。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论_2">2.12. 结论</h3>
<div class="paragraph">
<p>Raku 有一个丰富的变量和容器系统，与 Perl 5 有很大的不同。理解它的工作方式是非常重要的，因为它会影响列表和哈希行为的迭代和展开方式。</p>
</div>
<div class="paragraph">
<p>赋值给变量提供了有价值的快捷方式，例如提供<a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a>，<a href="https://docs.raku.org/type/Array"><code>Array</code></a>或<a href="https://docs.raku.org/type/Hash"><code>Hash</code></a> 容器，具体取决于符号。 如果您需要，绑定到变量允许您绕过这样的快捷方式。</p>
</div>
<div class="paragraph">
<p>在 Raku 中存在无符号变量，它们与具有绑定功能的 <code>$</code> -sigiled 变量具有相似的行为。 当用作参数时，这些变量的行为就像应用了 <code>is raw</code> trait一样。</p>
</div>
<div class="paragraph">
<p>最后，容器可以有默认值，可以创建自己的自定义容器，可以绑定到变量或从例程返回。</p>
</div>
<div class="paragraph">
<p>节日快乐！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第三天_letterops_with_raku">3. 第三天 – LetterOps with Raku</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_规模">3.1. 规模</h3>
<div class="paragraph">
<p>“规模！规模就是一切！“。</p>
</div>
<div class="paragraph">
<p>当圣诞老人的声音传到他们身上时，精灵散落在四面八方。</p>
</div>
<div class="paragraph">
<p>“这个 operation 是为三十四个孩子准备的？现在我们有无数的！大人也送信！“</p>
</div>
<div class="paragraph">
<p>小精灵 Buzzius 站了出来，喷出“但现在我们有电脑！”，又回到他精灵的追求。</p>
</div>
<div class="paragraph">
<p>“他们有什么好处？请告诉我，如果我仍然需要阅读每一封信，我该怎么办？“。</p>
</div>
<div class="paragraph">
<p>小精灵 Diodius 短暂地从藏身处抬起头，说：“告诉孩子们发一封文字信”。</p>
</div>
<div class="paragraph">
<p>圣诞老人停止了叫喊，并抓住了他有胡子的下巴。 “我可以做到这一点”。早期的儿童采用者就像这样发了一封信。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Dear Santa: I have been a good boy so I want you to bring me a collection of scythes and an ocean liner with a captain and a purser and a time travel machine and instructions to operate it and I know I haven&#39;t been so good at times but that is why I&#39;m asking the time machine so that I can make it good and well and also find out what happened on July 13th which I completely forgot.</code></pre>
</div>
</div>
<div class="paragraph">
<p>“我能做到吗？”。圣诞老人重复自己。他必须从单线混乱中提取一份礼物清单。例如，除以 <code>and</code>。</p>
</div>
<div class="paragraph">
<p>当然，使用 Raku 可以使用 <code>$þ</code> 作为变量，甚至可以<a href="https://en.wikipedia.org/wiki/Runic_(Unicode_block">使用</a>) <code>our $ᚣ= True</code> 作为标准，这是他最喜欢的语言。在一行中，您可以获得所有块，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[ &#34;Dear Santa: I have been a good boy so I want you to bring me a collection of scythes&#34;, &#34;an ocean liner with a captain&#34;, &#34;a purser&#34;, &#34;a time travel machine&#34;, &#34;instructions to operate it&#34;, &#34;I know I haven&#39;t been so good at times but that is why I&#39;m asking the time machine so that I can make it good&#34;, &#34;well&#34;, &#34;also find out what happened on July 13th which I completely forgot.\n&#34; ]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>/\s* «and» \s*/</code> regexp 使用了 `and`s 并且移除了空格，创建了一组句子。这些句子可能包含或不包含客户希望圣诞老人带来的东西。这让圣诞老人又一次咆哮起来。 “规模和结构！我们需要扩展，我们需要结构！“</p>
</div>
</div>
<div class="sect2">
<h3 id="_markdown_来拯救">3.2. Markdown 来拯救</h3>
<div class="paragraph">
<p>“马修斯投了出来。”每个人都知道 <a href="https://help.github.com/articles/basic-writing-and-formatting-syntax/">Markdown</a>。这是文字，为结构引入了几个标志。“</p>
</div>
<div class="paragraph">
<p>奥克斯正在努力晋升为第二级的精灵，他说。 “用Elvish-est的语言，榆树。你知道，这是精灵，但对于一封信“</p>
</div>
<div class="paragraph">
<p>“我可以做到这一点，”圣诞老人说。精灵喜欢他可以做的方法。所以他安装了所有东西，并做了这个小程序</p>
</div>
<div class="paragraph">
<p>圣诞老人安静了约 30 秒。然后再次听到了他的咆哮。</p>
</div>
<div class="paragraph">
<p>“永远，你听到我说话了吗？我从来不想再听到复活节兔子或其他邪恶生物的这种产卵。“</p>
</div>
<div class="paragraph">
<p>离屏幕最近的那些精灵观察到大量的红色，但不是很好的红色，没有任何类似于工作代码。所以他们给了鲁道夫一张便条（红红的鼻子驯鹿）一张便条，他用一只小鹿角忠实地扛着它。</p>
</div>
<div class="paragraph">
<p>“那么我们应该回到 Raku 吗？”</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_raku_处理_markdown">3.3. 使用 Raku 处理 Markdown</h3>
<div class="paragraph">
<p>圣诞老人发现了 <code>Text::Markdown</code>，他立即安装了该模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install Text::Markdown</code></pre>
</div>
</div>
<div class="paragraph">
<p>它有Text，它有Markdown，它承诺处理它，这是他所需要的。所以他向他的客户群通报说，如果你希望这个人在你的烟囱里拿着一个装有好东西的麻袋，那么今年就需要降价了。</p>
</div>
<div class="paragraph">
<p>早期的采用者再一次回答了这个问题</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku"># Dear Santa

I have been a good boy so I want you to bring me a collection of
scythes and an ocean liner with a captain and a purser and a time
travel machine and instructions to operate it and I know I haven&#39;t
been so good at times but that is why I&#39;m asking the time machine so
that I can make it good and well and also find out what happened on
July 13th which I completely forgot.</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么，这是降价，是不是？这是妥善处理和所有。 “正确处理一封信很重要”，圣诞老人大声说道，大声说道，只是让鲁道夫惊呆了，鲁道夫是唯一一个挂着的人。 “它给结构。让我们检查一下信件是否有这个“。</p>
</div>
<div class="paragraph">
<p>“哇！”圣诞老人说。然后，“哇”。只需几行代码即可阅读并理解文档的结构，另一行则检查是否至少有一个是标题。如果是这样，它会表示真。这是真的。</p>
</div>
<div class="paragraph">
<p>圣诞老人很高兴一小会儿。他抓住了鲁道夫脖子的后背，这让他感到惊讶。然后他停止了这样做。鲁道夫抬起头来，只是稍微支撑了他的后腿，感到不快。</p>
</div>
</div>
<div class="sect2">
<h3 id="_需要更多的结构">3.4. 需要更多的结构</h3>
<div class="paragraph">
<p>圣诞老人发现了这封信：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku"># Dude

=== Welll...

I have been a naughty person


=== Requests

Well...</code></pre>
</div>
</div>
<div class="paragraph">
<p>妥善处理和一切，他不能浪费他的时间与不好的人。规模。和资源。资源只能用于好人，而不是坏人。坏人不好，就是这样。所以回到编码，鲁道夫溜走寻找地衣糖或任何东西，他出示了这样的：</p>
</div>
<div class="paragraph">
<p>圣诞老人对第二个标题之后的段落提取技巧以及他能够很好地使用他所喜爱的Thorn信件这一事实感到自豪。他还喜欢函数式编程，在Lisp中咬牙切齿。所以他创建了这个最初是假的翻转开关，但是当它正在处理的元素是一个标题并且其级别是两个时，翻转开关。他也很高兴他可以用标记的文本顶部的分层结构来做这种事情。</p>
</div>
<div class="paragraph">
<p>此外，他可以检查该标题（行为）与下一行之间的任何段落中是否出现“好”字。而且任何一个都很酷。其中一个段落提到的很好就足够了。最后一行将首先返回一个布尔值数组，如果其中一个包含好的话，它最终将会声明为True。否则为假。适合从坏的方面挑选好的东西。</p>
</div>
<div class="paragraph">
<p>圣诞老人很开心。 -ier。但仍然。</p>
</div>
</div>
<div class="sect2">
<h3 id="_这里的玩具是重要的">3.5. 这里的玩具是重要的</h3>
<div class="paragraph">
<p>所以他真正想要的是玩具清单。在再次请求改变信件格式，他可以做的，因为他是圣诞老人，每个人都希望他的圣诞节免费的东西，他开始接收这种结构的信件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku"># Dear Santa

=== Behavior

I have been a good boy


=== Requests

And this is what I want

 - scythes
 - an ocean liner with a captain and a purser
 - a time travel machine and instructions to operate it</code></pre>
</div>
</div>
<div class="paragraph">
<p>他们在结构上的自发性缺乏。而且结构很好。你可以得到一个请求列表：</p>
</div>
<div class="paragraph">
<p>这实际上是链表列表处理表达式的一个不清晰的列表。在这之前的这句话有一个列表提及几乎一样坏。但让我们看看那里发生了什么。</p>
</div>
<div class="paragraph">
<p>首先在列表中，我们仅使用正则表达式和东西来获取请求标题后面的内容。我们本可能已经把它归结为对Str的转变，但是我们已经失去了结构。结构很重要，圣诞老人永远不会厌倦这一点。接下来，我们只提取那些实际上是列表的元素，将所有绒毛都取出来。</p>
</div>
<div class="paragraph">
<p>而事实恰恰是，结构太多这样的事情。该列表包含具有元素的元素。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">那或Text </dt>
<dd>
<p>Markdown可以做一个大改造。这篇文章的作者正在将他的特别愿望清单放在这里。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_还没有">3.6. 还没有</h3>
<div class="paragraph">
<p>但几乎。我们有这个名单，现在圣诞老人发现像时间旅行机器和星期一这样的事情。他不能在精灵工厂订购周一。他必须阅读每一件事情。但不用担心。这也可以照顾到：</p>
</div>
<div class="paragraph">
<p>简单来说，这个程序会遍历愿望清单中保存的项目清单，并检查产品性能。它是一种产品吗？它走了。你是在问上周五晚上，你完全错过了什么？它不，也不敢浪费圣诞老人的时间，男孩。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">这件事的要点在于使用全新的Wikidata </dt>
<dd>
<p>API模块的Wikidata查询。此模块只是将内容发送到Wikidata API并将其作为对象返回。相信与否，这就是SPARQL查询的作用：将项目名称插入到查询中，进行查询，并在返回的元素数量不为零时返回true。产品在你的指尖！在几行代码中！现在，他可以将所有东西链接在一起，并从包含此信件的信件中获取</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku"> - Morning sickness
 - Scythe
 - Mug</code></pre>
</div>
</div>
<div class="paragraph">
<p>只有你们可以从当地，市中心，妈妈和流行商店订购的其中两件，这是圣诞老人实际上偷偷购买所有东西的地方，因为他大量购买，并且他得到了很好的交易。</p>
</div>
<div class="paragraph">
<p>圣诞老人微微一笑，精灵，驯鹿和几只海雀在那里没有任何理由就爆发出大声的欢呼声。然后，他们往下看</p>
</div>
</div>
<div class="sect2">
<h3 id="_包起来">3.7. 包起来</h3>
<div class="paragraph">
<p>圣诞老人和 Raku 是一个很好的比赛，因为他们都是在圣诞节的时候来的。圣诞老人发现你可以自己做很多有用的事情，或者使用最近可用的优质模块之一。</p>
</div>
<div class="paragraph">
<p>不过，这位作者在给圣诞老人的信中将包括一些帮助，以继续介绍由他维护的这篇文章中使用的两个模块，这些模块需要更多有经验的编码人员进行测试，扩展或者重新编写。但他很高兴地看到，使用Raku可以直接完成处理给圣诞老人的信件等世俗和略微神圣的事情。你也应该这样做。</p>
</div>
<div class="paragraph">
<p>这篇文章的代码和样例可以从 <a href="https://github.com/JJ/santa-markdown">GitHub</a> 获得。也是这个文本。帮助和建议非常受欢迎。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第四天_使用_grammars_进行解析">4. 第四天-使用 Grammars 进行解析</h2>
<div class="sectionbody">
<div class="paragraph">
<p>下面是从 <a href="https://www.apress.com/us/book/9781484232279">Parsing with Raku Regexes and Grammars: A Recursive Descent into Parsing</a> 这本书里面提取出来的一章, 作者是 Moritz Lenz, 由 Apress Media 出版社出版。版权经过允许。</p>
</div>
<div class="paragraph">
<p>这本书马上就要出版了。至少该书的电子版这个月应该可以购买, 纸质版的可以在 <a href="https://smile.amazon.com/dp/1484232275/">亚马逊</a> 预定了。原本最迟会在 2018 年元月发出, 但是幸运的是, 圣诞节你就可以看到了。</p>
</div>
<div class="paragraph">
<p>下面你会看到第九章, 使用 Grammars 进行解析。前面的章节详细探讨了创建正则表达式块儿、正则表达式怎么和 Raku 代码进行交互、匹配对象、正则力学、常用正则技术，还有重用和组合正则。你可以通过阅读<a href="https://docs.raku.org/language/regexes">正则表达式官方文档</a>来获取更多关于正则的背景。</p>
</div>
<div class="paragraph">
<p>后面的章节涵盖了 action 类和对象, 怎么报告高质量的解析错误, Unicode 支持, 最后还有三个案例研究。</p>
</div>
<div class="paragraph">
<p>现在, 尽情享受吧！</p>
</div>
<div class="paragraph">
<p>Grammar 是众人皆知的用于解析的瑞士军刀。</p>
</div>
<div class="paragraph">
<p>在本章中，我们将更详细地探讨它们。 最重要的是，我们将讨论如何利用他们的威力。</p>
</div>
<div class="sect2">
<h3 id="_理解_grammars">4.1. 理解 Grammars</h3>
<div class="paragraph">
<p>Grammars 实现了自顶向下的解析方法。 入口点，通常是 <code>TOP</code> regex 正则表达式，它知道粗粒度的结构，并调用下降到繁复细节的更深一步的正则表达式。 也会涉及到递归。 例如，如果解析算术表达式，则操作符可以是一对括号内的任意表达式。</p>
</div>
<div class="paragraph">
<p>这是一个自顶向下的结构，或者更确切地说是一个<a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">递归下降分析方法</a>。 如果不涉及回溯，我们称之为*预测分析法*，因为在字符串中的每个位置，我们确切地知道我们在寻找什么 - 我们可以预测下一个 token 将会是什么（即使我们只能预测它可能是一组可选分支的其中之一）。</p>
</div>
<div class="paragraph">
<p>结果匹配树在结构上完全对应于 grammar 中正则表达式的调用结构。 让我们考虑解析一个只包含运算符 <code>*</code>，`+`和用于分组的括号的算术表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MathExpression {
    token TOP    { &lt;sum&gt; }
    rule sum     { &lt;product&gt;+ %  &#39;+&#39; }
    rule product { &lt;term&gt;+ % &#39;*&#39; }
    rule term    { &lt;number&gt; | &lt;group&gt; }
    rule group   { &#39;(&#39; &lt;sum&gt; &#39;)&#39; }
    token number { \d+ }
}

say MathExpression.parse(&#39;2 + 4 * 5 * (1 + 3)&#39;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>从 Grammar 本身，你已经可以看到递归的可能性：<code>sum</code> 调用 <code>product</code>，<code>product</code> 调用 <code>term</code>，<code>term</code> 调用 <code>group</code>，<code>group</code> 再次调用 <code>sum</code>。 这允许解析任意深度的嵌套表达式。</p>
</div>
<div class="paragraph">
<p>解析上面的例子产生下面的匹配对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">⌜2 + 4 * 5 * (1 + 3)⌟
 sum =&gt; ⌜2 + 4 * 5 * (1 + 3)⌟
  product =&gt; ⌜2 ⌟
   term =&gt; ⌜2 ⌟
    number =&gt; ⌜2⌟
  product =&gt; ⌜4 * 5 * (1 + 3)⌟
   term =&gt; ⌜4 ⌟
    number =&gt; ⌜4⌟
   term =&gt; ⌜5 ⌟
    number =&gt; ⌜5⌟
   term =&gt; ⌜(1 + 3)⌟
    group =&gt; ⌜(1 + 3)⌟
     sum =&gt; ⌜1 + 3⌟
      product =&gt; ⌜1 ⌟
       term =&gt; ⌜1 ⌟
        number =&gt; ⌜1⌟
      product =&gt; ⌜3⌟
       term =&gt; ⌜3⌟
        number =&gt; ⌜3⌟</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想知道某个特定的数字是如何解析的，你可以通过查找当前行上缩进较少的行来追踪路径。 例如，数字 <code>1</code> 由 token <code>number`解析，调用自 `term</code>，再调用自 <code>product</code>，以此类推。</p>
</div>
<div class="paragraph">
<p>我们可以通过从 token <code>number</code> 引发异常来验证这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    token number {
        (\d+)
        { die &#34;how did I get here?&#34; if $0 eq &#39;1&#39; }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这确实显示了回溯中的调用链，其中最直接的上下文是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">how did I get here?
  in regex number at bt.p6 line 9
  in regex term at bt.p6 line 5
  in regex product at bt.p6 line 4
  in regex sum at bt.p6 line 3
  in regex group at bt.p6 line 6
  in regex term at bt.p6 line 5
  in regex product at bt.p6 line 4
  in regex sum at bt.p6 line 3
  in regex TOP at bt.p6 line 2
  in block &lt;unit&gt; at bt.p6 line 13</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个语法只使用 tokens 和 rules，所以不涉及回溯，而 grammar 是一个预测分析法。 这是相当典型的。 没有回溯或在几个地方有回溯时, 许多 grammars 都工作正常。</p>
</div>
</div>
<div class="sect2">
<h3 id="_递归下降分析法和优先级">4.2. 递归下降分析法和优先级</h3>
<div class="paragraph">
<p><code>MathExpression</code> grammar 有两个结构相同的 rules：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule sum { &lt;product&gt;+ %  &#39;+&#39; }
rule product { &lt;term&gt;+ % &#39;*&#39; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是, 我们也可以写成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule  expression { &lt;operator&gt;+ % &lt;term&gt; }
token operator   {  &#39;*&#39; | &#39;+&#39; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者甚至使用前一章讨论的 <code>proto token</code> 构造来解析不同的操作符。我选择第一种更重复的方法的原因是它使匹配结构对应于运算符 <code>*</code> 和 <code>+</code> 的优先级。</p>
</div>
<div class="paragraph">
<p>当计算数学表达式 <code>1 + 2 * 5</code> 时，数学家和大多数编程语言首先计算 <code>2 * 5</code>，因为 <code>*</code> 运算符的优先级高于 <code>+</code>。然后将结果代入表达式，成为 <code>1 + 10</code>，最后得到 <code>11</code>。</p>
</div>
<div class="paragraph">
<p>当用 grammar 的第一个版本解析这样的表达式的时候，解析树的结构表示这个分组：它具有 - 作为最高级 - 单个 sum，操作数是 <code>1</code> 和 <code>2 * 5</code>。</p>
</div>
<div class="paragraph">
<p>这是有代价的：对于每个优先级我们需要一个单独的 rule 和名字，并且所产生的结果匹配对象的嵌套层级, 每个优先级至少有一级。而且，稍后增加更多的优先级并不是微不足道的，而且很难通用。如果您不愿意接受这些成本，则可以使用具有单个 token 的平级模型来解析所有运算符。如果您需要能反映优先级的结构，则可以编写代码将列表转换为树。这通常被称为<a href="https://en.wikipedia.org/wiki/Operator-precedence_parser">运算符优先级解析器</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_左递归和其他陷阱">4.3. 左递归和其他陷阱</h3>
<div class="paragraph">
<p>为了避免无限递归，你必须注意，每个可能的递归循环至少将游标位置推进了一个字符。在 <code>MathExpression</code> grammar 中，唯一可能的递归循环是 <code>sum</code>→<code>product</code>→<code>term</code>→<code>group</code>→<code>sum</code>，并且 <code>group</code> 只有在消耗了一个初始开口圆括号 <code>(</code> 时才匹配。</p>
</div>
<div class="paragraph">
<p>如果递归不消耗字符，则它被称为*左递归*，并且需要特殊的语言支持, 这个 Raku 并不支持。一个例子是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token a { &lt;a&gt;? &#39;a&#39; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>它本该与正则表达式 <code>a+</code> 匹配相同的输入，但是却无限循环而不前进。</p>
</div>
<div class="paragraph">
<p>避免左递归的一个常用技巧是有一个可以按照从通用（这里是 <code>sum</code>）到特定（<code>number</code>）顺序排序正则表达式的结构。当正则表达式偏离该顺序时（例如 <code>group `调用 `sum</code>），你只需要关心并检查消耗的字符。</p>
</div>
<div class="paragraph">
<p>无限循环的另一个潜在来源是在量词化能匹配空字符串的正则表达式时。在解析允许某些内容为空的语言时可能会发生这种情况。例如，在 UNIX shell 中，你可以在给变量赋值的时候把右侧置空：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">VAR1=value
VAR2=</code></pre>
</div>
</div>
<div class="paragraph">
<p>在为 UNIX shell 命令编写 grammar 时，编写一个可能匹配空字符串的 <code>token string { \w* }</code> 可能会很冒险。 在允许多于一个字符串字面值的情况下，<code>&lt;string&gt;+</code> 就会挂起，因为实际的正则表达式 <code>[\w*]+</code> 试图无限次地匹配一个零宽度的字符串。</p>
</div>
<div class="paragraph">
<p>一旦你意识到了这个问题，解决方案就变得非常简单：将 token 更改为不允许空字符串（<code>token string { \w+ }</code>），并显式地处理允许空字符串的情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    token assignment {
        &lt;variable&gt; &#39;=&#39; &lt;string&gt;?
    }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_始于简单">4.4. 始于简单</h3>
<div class="paragraph">
<p>即使 grammar 是自上而下工作的，但是开发的时候最好开自下而上。 一开始，grammar 的总体结构往往是不明显的，但是你通常知道*末端* token：那些能直接匹配文本而不需要调用其他 subrules 的 token。</p>
</div>
<div class="paragraph">
<p>在前面的解析数学表达式的例子中，你可能一开始不知道如何安排解析 sums 和 products 的 rules，但你很可能知道必须在某个时候解析数字，所以一开始你可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MathExpression {
    token number { \d+ }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这并不是很多，但也不是很复杂，这是程序员有时在遇到新问题领域时克服挑战的一种很好的方式。 当然，一旦你有了 token，就可以开始写一些测试了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MathExpression {
    token number { \d+ }
}

multi sub MAIN(Bool :$test!) {
    use Test;
    plan 2;
    ok MathExpression.parse(&#39;1234&#39;, :rule&lt;number&gt;),
        &#39;&lt;number&gt; parses 1234&#39;;
    nok MathExpression.parse(&#39;1+4&#39;, :rule&lt;number&gt;),
        &#39;&lt;number&gt; does not parse 1+4&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，您可以以自己的方式创建更复杂的表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MathExpression {
    token number { \d+ }
    rule product { &lt;number&gt;+ % &#39;*&#39; }
}

multi sub MAIN(Bool :$test!) {
    use Test;
    plan 5;
    ok MathExpression.parse(&#39;1234&#39;, :rule&lt;number&gt;),
        &#39;&lt;number&gt; parses 1234&#39;;
    nok MathExpression.parse(&#39;1+4&#39;, :rule&lt;number&gt;),
        &#39;&lt;number&gt; does not parse 1+4&#39;;

    ok MathExpression.parse(&#39;1234&#39;, :rule&lt;product&gt;),
        &#39;&lt;product&gt; can parse a simple number&#39;;
    ok MathExpression.parse(&#39;1*3*4&#39;, :rule&lt;product&gt;),
        &#39;&lt;product&gt; can parse three terms&#39;;
    ok MathExpression.parse(&#39;1 * 3&#39;, :rule&lt;product&gt;),
        &#39;&lt;product&gt; and whitespace&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在测试的早期包含空白是值得的。 上面的例子看起来是无害的，但最后那个测试实际上失败了。 没有 rule 匹配 <code>1</code> 和 <code>*</code> 之间的空格。 在 <code>&lt;number&gt;</code> 和 <code>+</code> 量词之间的正则表达式中添加一个空格使测试再次通过，因为空格插入了一个隐式的 <code>&lt;.ws&gt;</code> 调用。</p>
</div>
<div class="paragraph">
<p>如果你从最简单的开始，尽快抓住这些细节，就很容易理解。 如果不是从上到下写下整个 grammar，你就会花很多时间去调试为什么一些看起来很简单的东西会导致解析失败, 比如额外的空格。</p>
</div>
</div>
<div class="sect2">
<h3 id="_组装完整的_grammars">4.5. 组装完整的 Grammars</h3>
<div class="paragraph">
<p>一旦你为词法分析编写了基本的 tokens，你可以进行合并。 通常，tokens 不会在匹配的边界处解析空白，因此组合它们的 rules 会这样做。</p>
</div>
<div class="paragraph">
<p>在上一节的 <code>MathExpression</code> 示例中，<code>rule product</code> 直接地调用了 <code>number</code>, 即使我们现在知道最终版本使用了一个中间步骤，也就是 rule <code>term</code>，它也可以解析用圆括号围起来的表达式。 引入这个额外的步骤不会使我们为 <code>product</code> 编写的测试失效，因为它在早期版本中匹配的字符串仍然匹配。 从处理语言子集的 grammar 开始，引入更多层是自然发生的，稍后将扩展。</p>
</div>
</div>
<div class="sect2">
<h3 id="_调试_grammars">4.6. 调试 Grammars</h3>
<div class="paragraph">
<p>对于正则表达式或 Grammar，有两种失败模式：它们可以匹配，当它不应该匹配（误报）时，或者它应该匹配（错误否定）时可能匹配失败。通常，误报更容易理解，因为您可以检查生成的匹配对象，并查看哪些正则表达式匹配了字符串的哪一部分。</p>
</div>
<div class="paragraph">
<p>有一个方便的工具来调试误报：<code>Grammar::Tracer</code> 模块。如果将模块加载到包含 grammar 的文件中，则运行该 grammar 会生成诊断信息，以帮助您找出匹配出错的位置。</p>
</div>
<div class="paragraph">
<p>请注意，这只是开发人员的诊断工具; 如果你想给终端用户更好的错误信息，请阅读第 11 章的改进建议。</p>
</div>
<div class="paragraph">
<p>您需要安装 Raku 的 <code>Grammar::Debugger</code> 模块，其中还包含 <code>Grammar::Tracer</code>。如果您使用 <code>moritzlenz/raku-regex-alpine</code> 的 docker 镜像，这已经为您完成了。如果您通过其他方法安装了Raku，则需要在命令行上运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install Grammar::Debugger</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果尚未安装 <code>zef</code>，请按照 <a href="https://github.com/ugexe/zef#installation">zef GitHub页面</a> 上的安装说明进行操作。</p>
</div>
<div class="paragraph">
<p>让我们来看一下 TadeuszSośnierz 写的 Raku 模块 <a href="https://github.com/tadzik/raku-Config-INI">Config::INI</a>。 它包含以下 <a href="https://github.com/tadzik/raku-Config-INI/blob/master/lib/Config/INI.pm">grammar</a>（这儿稍微重新格式化了）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar INI {
    token TOP {
        ^ &lt;.eol&gt;* &lt;toplevel&gt;?  &lt;sections&gt;* &lt;.eol&gt;* $
            }
    token toplevel { &lt;keyval&gt;* }
    token sections { &lt;header&gt; &lt;keyval&gt;* }
    token header   { ^^ \h* &#39;[&#39; ~ &#39;]&#39; $&lt;text&gt;=&lt;-[ \] \n ]&gt;+
                     \h* &lt;.eol&gt;+ }
    token keyval   { ^^ \h* &lt;key&gt; \h* &#39;=&#39; \h* &lt;value&gt;? \h*
                     &lt;.eol&gt;+ }
    regex key      { &lt;![#\[]&gt; &lt;-[;=]&gt;+ }
    regex value    { [ &lt;![#;]&gt; \N ]+ }
    token eol      { [ &lt;[#;]&gt; \N* ]? \n }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设我们想知道为什么它不解析下面的一段输入文本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a = b
[foo]
c: d</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以, 在该 grammar 之前, 我们插入下面这一行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Grammar::Tracer;</code></pre>
</div>
</div>
<div class="paragraph">
<p>之后，添加一小段调用该 grammar 的 <code>.parse</code> 方法的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">INI.parse(q:to/EOF/);
a = b
[foo]
c: d
EOF</code></pre>
</div>
</div>
<div class="paragraph">
<p>这产生了一个可观的，但相当丰富的输出。</p>
</div>
<div class="paragraph">
<p>每个条目由一个正则表达式的名称组成，比如 <code>TOP</code> 或者 <code>eol</code>（&#34;end of line&#34; 的缩写），后面跟着它调用的正则表达式的缩进后的输出。 每个正则表达式后面都有一个包含星号（<code><strong></strong></code><strong>）和 <code>MATCH</code> 后跟正则表达式匹配到的字符串片段这样的行; 如果正则表达式失败，则 <code></code></strong> 号后面跟的是 <code>FAIL</code>。</p>
</div>
<div class="paragraph">
<p>让我们一块一块地查看输出，即使它成块地出现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">TOP
|  eol
|  * FAIL
|  toplevel
|  |  keyval
|  |  |  key
|  |  |  * MATCH &#34;a &#34;
|  |  |  value
|  |  |  * MATCH &#34;b&#34;
|  |  |  eol
|  |  |  * MATCH &#34;\n&#34;
|  |  |  eol
|  |  |  * FAIL
|  |  * MATCH &#34;a = b\n&#34;
|  |  keyval
|  |  |  key
|  |  |  * FAIL
|  |  * FAIL
|  * MATCH &#34;a = b\n&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这告诉我们，<code>TOP</code> 调用了 <code>eol</code>，它没有匹配。 由于 <code>eol</code> 的调用是用 <code>*</code> 量化的，所以这不会导致 <code>TOP</code> 的匹配失败。 <code>TOP</code> 然后调用了 <code>key</code>, 匹配到文本 &#34;a&#34;, 调用 <code>value</code>, 匹配到文本 &#34;b&#34;。 然后 <code>eol</code> 正则表达式继续匹配换行符，在第二次尝试时失败（因为在一行中没有两个换行符）。 这会导致初始的 <code>keyval</code> token 匹配成功。 第二次调用 <code>keyval</code> 匹配很快（在调用 <code>key</code> 中）。 然后，<code>toplevel</code> token 的匹配成功进行，消耗了字符串 &#34;a = b \ n&#34;。</p>
</div>
<div class="paragraph">
<p>到目前为止，这一切看起来都和预期的一样。 现在我们来看看第二部分的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">|  sections
|  |  header
|  |  |  eol
|  |  |  * MATCH &#34;\n&#34;
|  |  |  eol
|  |  |  * FAIL
|  |  * MATCH &#34;[foo]\n&#34;
|  |  keyval
|  |  |  key
|  |  |  * MATCH &#34;c: d\n&#34;
|  |  * FAIL
|  * MATCH &#34;[foo]\n&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TOP</code> 接下来调用 <code>sections</code>，其中 token <code>header</code> 成功匹配了字符串 <code>&#34;[foo] \ n&#34;</code>。 然后，<code>keyval</code> 调用 <code>key</code>，它匹配了 <code>&#34;c: d\n&#34;</code> 整行。 等等，这是不对的，是吗？ 我们可能期望 <code>key</code> 只匹配 <code>c</code>。 我当然不希望它匹配最后的换行符。 输入中缺少等号会导致 regex 引擎永远不会调用 regex <code>value</code>。 但是由于 <code>keyval</code> 再次用星号 <code>*</code> 量词进行量化，因此调用正则表达式 <code>sections</code> 的匹配成功地匹配了 header <code>&#34;[foo]\n&#34;</code>。</p>
</div>
<div class="paragraph">
<p><code>Grammar::Tracer</code> 输出的最后一部分如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">|  sections
|  |  header
|  |  * FAIL
|  * FAIL
|  eol
|  * FAIL
* FAIL</code></pre>
</div>
</div>
<div class="paragraph">
<p>从这里开始都是 <code>FAIL</code>。第二次调用 <code>sections</code> 再次尝试解析 header，但其下一个输入仍然是 <code>&#34;c: d\n&#34;</code>，所以失败了。正如 token <code>TOP</code> 中字符串末尾的锚点 <code>$</code> 一样，在 <code>parse</code> 方法中总体匹配失败。</p>
</div>
<div class="paragraph">
<p>所以我们已经知道正则表达式 <code>key</code> 匹配整行 <code>c: d\n</code>，但是因为没有等号（<code>=</code>）跟在后面，所以 token <code>keyval</code> 解析不了这一行。由于没有其他正则表达式（特别是没有 <code>header</code>）匹配它，这是匹配失败的地方。</p>
</div>
<div class="paragraph">
<p>从这个例子中你可以看到，<code>Grammar::Tracer</code> 使我们能够精确定位解析失败发生的位置，尽管我们必须仔细查看它的输出以找到它。在终端中运行时，会自动获取彩色输出，其中 <code>FAIL</code> 为红色，<code>MATCH</code> 为绿色背景，token 名称以粗体白色（而不是通常的灰色）输出。这样可以更容易地从底部扫描（失败的匹配通常会留下一条红色的 <code>FAIL</code>），直到尾部成功的匹配，然后在匹配和失败之间的边界附近查看。</p>
</div>
<div class="paragraph">
<p>由于调试带来了巨大的精神负担，而且 <code>Grammar::Tracer</code> 的输出趋向于快速增长，所以通常建议将失败的输入减少到最小的样本。在上述情况下，我们可以删除输入字符串的第一行，并保存十行 <code>Grammar::Tracer</code> 输出来查看。</p>
</div>
</div>
<div class="sect2">
<h3 id="_解析空白和注释">4.7. 解析空白和注释</h3>
<div class="paragraph">
<p>如前所述，解析无关紧要的空格的惯用方法是调用 <code>&lt;.ws&gt;</code>，通常隐式地使用 rule 中的空格。 默认的 <code>ws</code> 实现 <code>&lt;!ww&gt;\s*</code> 对许多语言都适用，但是它有其局限性。</p>
</div>
<div class="paragraph">
<p>在数量惊人的文件格式和计算机语言中，也有 <code>&lt;.ws&gt;</code> 占用的空白是有意义的。 这些包括 INI 文件（换行符通常表示一个新的键/值对），Python 和 YAML（缩进用于分组），CSV（换行符表示新记录）以及 Makefile（缩进要求是制表符）。</p>
</div>
<div class="paragraph">
<p>在这些情况下，最好的做法在你自己的 grammar 中重写 <code>ws</code> 来匹配只有不重要的空格。 让我们来看看第二个简约的 INI 解析器，它是从上一节中描述的独立开发的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar INIFile {
    token TOP { &lt;section&gt;* }
    token section {
        &lt;header&gt;
        &lt;keyvalue&gt;*
    }
    rule header {
        &#39;[&#39;  &lt;-[ \] \n ]&gt;+ &#39;]&#39; &lt;.eol&gt;
    }
    rule keyvalue {
        ^^
        $&lt;key&gt;=[\w+]
        &lt;[:=]&gt;
        $&lt;value&gt;=[&lt;-[\n;#]&gt;*]
        &lt;.eol&gt;
    }
    token ws { &lt;!ww&gt; \h* }
    token eol {
        \n [\h*\n]*
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它解析简单的 INI 配置文件就像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">[db]
driver: mysql
host: db01.example.com
port: 122
username: us123
password: s3kr1t</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意这个 grammar 如何使用两条路径来解析空格：自定义的 <code>ws</code> token 只匹配水平空白（空格和制表符），单独的 <code>eol</code> token 匹配(significant)换行符。 <code>eol</code> token 还吞噬了只包含空格的更多行。</p>
</div>
<div class="paragraph">
<p>如果语言支持注释，并且不希望它们出现在解析树中，则可以使用 <code>ws</code> token 或 <code>eol</code>（或其等价物）来解析它们。 哪一个取决于哪里允许注释。 在 INI 文件中，它们只允许出现在键值对之后，或者它们自己单独占一行，所以 <code>eol</code> 将是合适的地方。 相比之下，SQL 允许在每个允许空格的地方进行注释，所以在 <code>ws</code> 中解析它们是很自然的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># comment parsing for SQL:
token ws { &lt;!ww&gt; \s* [ &#39;--&#39; \N* \n ]* }

# comment parsing for INI files:
token eol { [ [ &lt;[#;]&gt; \N* ]? \n ]+ }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_保存状态">4.8. 保存状态</h3>
<div class="paragraph">
<p>一些更有趣的数据格式和语言要求解析器存储事物（至少暂时）以便能够正确地解析它们。 一个恰当的例子是C编程语言，另一个例子是受其语法启发的（例如C ++和Java）。 这样的语言允许表单类型variable = initial_value的变量声明，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">int x = 42;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是有效的语法，但只有当第一个单词是一个类型名称。 相反，这将是无效的，因为x不是一个类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">int x = 42;
x y = 23;</code></pre>
</div>
</div>
<div class="paragraph">
<p>从这些例子中可以清楚地看到，解析器必须有它所知道的所有类型的记录。 由于用户也可以在他们的代码文件中声明类型，解析器必须能够更新这个记录。</p>
</div>
<div class="paragraph">
<p>许多语言还要求在引用符号（变量，类型和函数）之前进行声明。 这也需要语法来跟踪已经声明的内容和没有的内容。 这个已经声明的记录（以及什么是一个类型，也可能不是其他元信息）被称为符号表。</p>
</div>
<div class="paragraph">
<p>我们不考虑解析完整的C语言，而是考虑一种极简主义语言，它只允许分配数字列表和变量给变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a = 1
b = 2
c = a, 5, b</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们不强加声明规则，写一个语法是很容易的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar VariableLists {
    token TOP        { &lt;statement&gt;* }
    rule  statement  { &lt;identifier&gt; &#39;=&#39; &lt;termlist&gt; \n }
    rule  termlist   { &lt;term&gt; * % &#39;,&#39; }
    token term       { &lt;identifier&gt; | &lt;number&gt; }
    token number     { \d+ }
    token identifier { &lt;:alpha&gt; \w* }
    token ws         { &lt;!ww&gt; \h* }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们要求变量只能在赋值之后才能使用，所以下面的输入将是无效的，因为在第二行中没有声明b的地方：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a = 1
c = a, 5, b
b = 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了维护一个符号表，我们需要三个新的元素：符号表的声明，一些代码，当赋值语句被解析时，将一个变量名添加到符号表中，最后检查一个变量是否已经被声明 我们在一个术语列表中遇到它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar VariableLists {
    token TOP {
        :my %*SYMBOLS;
        &lt;statement&gt;*
    }
    token ws { &lt;!ww&gt; \h* }
    rule statement {
        &lt;identifier&gt;
        { %*SYMBOLS{ $&lt;identifier&gt; } = True }
        &#39;=&#39; &lt;termlist&gt;
        \n
    }
    rule termlist { &lt;term&gt; * % &#39;,&#39; }
    token term { &lt;variable&gt; | &lt;number&gt; }
    token variable {
        &lt;identifier&gt;
        &lt;?{ %*SYMBOLS{ $&lt;identifier&gt; } }&gt;
    }
    token number { \d+ }
    token identifier { &lt;:alpha&gt; \w* }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在令牌TOP中，：my％* SYMBOLS声明一个变量。 正则表达式中的声明以冒号（:)开始，以分号（;）结尾。 在它们之间，它们看起来像Raku中的正常声明。％sigil表示该变量是一个散列 - 一个字符串键到值的映射。 *使它成为一个动态变量 - 一个变量，不仅限于当前范围，而且对于从当前范围调用的代码（或正则表达式，也是代码）也是可见的。 由于这是一个非常大的范围，所以在大写字母中选择一个变量是自定义的。</p>
</div>
<div class="paragraph">
<p>第二部分，在符号表中添加一个符号，发生在规则声明中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    rule statement {
        &lt;identifier&gt;
        { %*SYMBOLS{ $&lt;identifier&gt; } = True }
        &#39;=&#39; &lt;termlist&gt;
        \n
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>大括号内是常规的（非正则表达式）Raku代码，所以我们可以使用它来操作哈希％* SYMBOLS。 表达式$ &lt;identifier&gt;访问变量name2的捕获。 因此，如果此规则解析变量a，则此语句将设置％* SYMBOLS {&#39;a&#39;} = True。</p>
</div>
<div class="paragraph">
<p>代码块的位置是相关的。 把它放在调用termlist之前意味着当术语列表被解析时变量已经是已知的，所以它接受像a = 2，a这样的输入。 如果我们首先调用termlist，这种输入被拒绝。</p>
</div>
<div class="paragraph">
<p>说到拒绝，这部分发生在令牌变量。 term现在调用新的标记变量（以前它直接称为标识符），并且变量验证该符号是在之前声明的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    token term { &lt;variable&gt; | &lt;number&gt; }
    token variable {
        &lt;identifier&gt;
        &lt;?{ %*SYMBOLS{ $&lt;identifier&gt; } }&gt;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可能还记得在前面的例子中，&lt;？{…​}&gt;执行一段Raku代码，如果它返回一个假值，则解析失败。 如果$ &lt;identifier&gt;不在％SYMBOLS中，这正是发生的情况。 在这个时候，令牌的非回溯性是很重要的。 如果被解析的变量是abc，并且变量a在％* SYMBOLS中，则回溯将尝试&lt;identifier&gt;的较短匹配，直到它碰到a，然后成功3。</p>
</div>
<div class="paragraph">
<p>由于在标记TOP中声明了％* SYMBOLS，所以当您尝试从语法外调用除TOP之外的其他规则时，必须复制此声明。 没有像我的％* SYMBOLS ;,一个像这样的调用声明</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">VariableLists.parse(&#39;abc&#39;, rule =&gt; &#39;variable&#39;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>dies with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Dynamic variable %*SYMBOLS not found</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用动态变量实现词法作用域">4.9. 使用动态变量实现词法作用域</h3>
<div class="paragraph">
<p>许多编程语言都有一个词汇范围的概念。 范围是程序中符号可见的区域。 如果范围仅由文本的结构（而不是程序的运行时功能）决定，我们称之为范围词法。</p>
</div>
<div class="paragraph">
<p>范围通常可以嵌套。 在一个作用域中声明的变量在这个作用域中是可见的，在所有的内部嵌套作用域中（除非内部作用域声明了一个名称相同的变量，在这种情况下，内部声明隐藏了外部作用域）。</p>
</div>
<div class="paragraph">
<p>回到列表和作业的玩具语言，我们可以引入一对花括号来表示一个新的范围，所以这是有效的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a = 1
b = 2
{
    c = a, 5, b
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但下一个例子是无效的，因为它只在内部范围内声明b，所以它在外部范围内是不可见的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a = 1
{
    b = 2
}
c = a, 5, b</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了在语法中实现这些规则，我们可以利用一个重要的观察：语法中的动态范围对应于它分析的文本中的词法范围。 如果我们有一个正则表达式块来解析范围的分隔符以及范围内的事物，那么它的动态范围就局限于它所调用的所有正则表达式（直接或间接），这也是它的范围 匹配输入文本。</p>
</div>
<div class="paragraph">
<p>我们来看看如何实现动态范围：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar VariableLists {
    token TOP {
        :my %*SYMBOLS;
        &lt;statement&gt;*
    }
    token ws { &lt;!ww&gt; \h* }
    token statement {
        | &lt;declaration&gt;
        |  &lt;block&gt;
    }
    rule declaration {
        &lt;identifier&gt;
        { %*SYMBOLS{ $&lt;identifier&gt; } = True; }
        &#39;=&#39; &lt;termlist&gt;
        \n
    }
    rule block {
        :my %*SYMBOLS = CALLERS::&lt;%*SYMBOLS&gt;;
        &#39;{&#39; \n*
            &lt;statement&gt;*
        &#39;}&#39; \n*
    }
    rule termlist { &lt;term&gt; * % &#39;,&#39; }
    token term { &lt;variable&gt; | &lt;number&gt; }
    token variable {
        &lt;identifier&gt;
        &lt;?{ %*SYMBOLS{ $&lt;identifier&gt; } }&gt;
    }
    token number { \d+ }
    token identifier { &lt;:alpha&gt; \w* }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个语法的前一个版本有一些变化：规则语句已被重命名为声明，新的规则语句分析声明或块。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">所有有趣的位都发生在块规则中。 该行：my％* SYMBOLS = CALLERS </dt>
<dd>
<p>&lt;％* SYMBOLS&gt;; 声明一个新的动态变量％* SYMBOLS并用该变量的前一个值初始化它。 CALLERS :: &lt;％* SYMBOLS&gt;通过调用者和调用者的调用者等查找变量％* SYMBOLS，从而查找对应于外部作用域的值。 初始化创建散列的副本，以便对一个副本的更改不会影响其他副本。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>让我们来看看当这个语法解析下面的输入时会发生什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a = 1
b = 2
{
    c = a, 5, b
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前两行之后，％* SYMBOLS的值为{a ⇒ True，b ⇒ True}。 当规则块解析第三行的开放大括号时，它会创建％* SYMBOLS的副本。 第四行的c的声明将对c ⇒ True插入到％* SYMBOLS的副本中。 在规则块解析最后一行的结束大括号之后，它将成功退出，并且％* SYMBOLS的副本将超出范围。 这给我们留下了早期版本的％* SYMBOLS（只有键a和b），当TOP退出时，它们超出了范围。</p>
</div>
<div class="paragraph">
<p>通过显式符号表进行范围确定</p>
</div>
<div class="paragraph">
<p>使用动态变量来管理符号表通常工作得很好，但是有一些边缘情况下更明确的方法效果更好。 这样的边缘情况包括那些符号太多以至于复制变得非常昂贵的情况，或者必须检查多于最顶端的范围的情况，或者复制符号表是不切实际的。</p>
</div>
<div class="paragraph">
<p>因此，可以为符号表编写一个类（在最简单的情况下，它使用一个数组作为范围的堆栈），在进入和离开范围时，在声明一个变量时，以及为了检查一个变量是否为 在一个范围内已知：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class SymbolTable {
    has @!scopes = {}, ;
    method enter-scope() {
        @!scopes.push({})
    }
    method leave-scope() {
        @!scopes.pop();
    }
    method declare($variable) {
        @!scopes[*-1]{$variable} = True
    }
    method check-declared($variable) {
        for @!scopes.reverse -&gt; %scope {
            return True if %scope{$variable};
        }
        return False;
    }
}

grammar VariableLists {
    token TOP {
        :my $*ST = SymbolTable.new();
        &lt;statement&gt;*
    }
    token ws { &lt;!ww&gt; \h* }
    token statement {
        | &lt;declaration&gt;
        |  &lt;block&gt;
    }
    rule declaration {
        &lt;identifier&gt;
        { $*ST.declare( $&lt;identifier&gt; ) }
        &#39;=&#39; &lt;termlist&gt;
        \n
    }
    rule block {
        &#39;{&#39; \n*
            { $*ST.enter-scope() }
            &lt;statement&gt;*
            { $*ST.leave-scope() }
        &#39;}&#39; \n*
    }
    rule termlist { &lt;term&gt; * % &#39;,&#39; }
    token term { &lt;variable&gt; | &lt;number&gt; }
    token variable {
        &lt;identifier&gt;
        &lt;?{ $*ST.check-declared($&lt;identifier&gt;) }&gt;
    }
    token number { \d+ }
    token identifier { &lt;:alpha&gt; \w* }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>SymbolTable类具有私有数组属性@！作用域，它使用包含单个空散列的列表进行初始化。输入一个作用域意味着在这个数组的顶部推一个空的散列，当离开这个作用域的时候，它会通过pop方法调用再次被删除。变量声明将其名称添加到最顶端的散列@ @ scopes [* - 1]。</p>
</div>
<div class="paragraph">
<p>检查变量的存在不能只考虑最顶端的散列，因为变量被继承到内部作用域。在这里，我们以相反的顺序遍历所有的范围，从最内层到最外层的范围。遍历的顺序与简单的布尔检查无关，但是如果您需要查找与该变量相关的信息，则遵守此顺序以引用正确的顺序非常重要。</p>
</div>
<div class="paragraph">
<p>令牌TOP创建类SymbolTable的新对象，声明调用声明方法，令牌变量调用方法检查声明。规则块在解析语句列表之前调用进入范围，之后保留范围。这个工作，但只有当语句列表可以被成功解析;如果不是，规则块在管理调用离开范围之前失败。</p>
</div>
<div class="paragraph">
<p>对于这种情况，Raku有一个安全特性：如果在LEAVE语句前添加一个语句，那么在例程退出时，Raku可以在所有可能的情况下调用它（即使抛出异常）。由于LEAVE相位器只能在正则代码中使用，而不能在正则表达式中使用，所以我们需要将正则表达式包装在一个方法中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    method block {
        $*ST.enter-scope();
        LEAVE $*ST.leave-scope();
        self.block_wrapped();
    }
    rule block_wrapped {
        &#39;{&#39; \n*
            &lt;statement&gt;*
        &#39;}&#39; \n*
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们拥有与动态变量相同的鲁棒性，并且以更多的代码和更多的努力为代价，可以更灵活地向符号表添加额外的代码。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结">4.10. 总结</h3>
<div class="paragraph">
<p>Raku 的 Grammar 是编写递归下降解析器的一种声明方式。 如果没有回溯，他们就是可预测的; 在每一个时刻，我们都知道我们想要的 token 列表。</p>
</div>
<div class="paragraph">
<p>Grammar 的递归性带来了左递归的风险，即递归路径不消耗任何字符的情况，从而导致无限循环。</p>
</div>
<div class="paragraph">
<p>尽管 Grammar 是自上而下的，但是他们通常是从下到上写出来的：从词法分析开始，然后转向解析更大的结构。</p>
</div>
<div class="paragraph">
<p>复杂语言成功和精确的解析需要额外的状态。 我们已经看到了如何在 grammar 中使用动态变量来保存状态，它们的作用域如何对应于输入的词法作用域，以及如何将符号表写入并集成到 grammars 中。</p>
</div>
<div class="paragraph">
<p>1、就像一把瑞士军刀一样，但是功能更强大。
2、在这一点上，<code>identifier</code> 不会解析其周围的空白是至关重要的。 因此，token 不关心空白的原则和调用这些 token 的 rules 解析空白。
3、在这种情况下，这将是无害的，因为没有其他 rule 可以匹配变量的其余部分，导致解析错误。 但是在更复杂的情况下，这种无意的回溯会导致语法维护人员非常困惑的错误。</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.wordpress.com/2017/12/04/day-08-parsing-with-grammars-book-extract/">Day 4 – Parsing with Grammars</a>
== 第五天 - 使用 Raku 签名解构参数</p>
</div>
<div class="paragraph">
<p>在许多其他关键的 Raku 特性中，我认为 <a href="https://docs.raku.org/type/Signature">Signatures</a> 是众多&#34;杀手级&#34;特性之一。 它们的功能如此丰富而强大，我怀疑关于如何使用它们可以写一整本书。 我想探索一下我原来忽略但是非常珍惜的一些特定功能。</p>
</div>
<div class="paragraph">
<p>您可能已经看到了基本的子程序签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub myfunc($x, $y, $z) {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它给函数声明了 3 个标量参数, 并在函数体里面给了它们 <strong>$x</strong>, <strong>$y</strong>, <strong>$z</strong> 的名字。</p>
</div>
<div class="paragraph">
<p>太简单了。</p>
</div>
<div class="paragraph">
<p>你可以更有爱心, 给它们加上指定的类型:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub myfunc(Str $x, Int $y, Rat $z) {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用笑脸符号 <code>:D</code> 让参数值是有定义的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub myfunc(Str:D $x, Int:D $y, Rat:D $z) {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有很多其它花哨的说明符你可以使用，在这里我不深入了。</p>
</div>
<div class="paragraph">
<p>但是如果你的参数更复杂呢？ （不是 <a href="https://docs.raku.org/type/Complex">Complex</a> - 虽然它也起作用..）</p>
</div>
<div class="paragraph">
<p>For example, you might want to restrict a specific parameter to a Positional argument like an Array, or an Associative one like a Hash using the respective sigils, @ or %.
例如，你可能想要将特定的参数限制为像 Array 这样的 Positional 参数，或者使用相应的 @ 或 ％ 符号将这个参数限制为像 Hash 这样的关联参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub myfunc(%h) {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我可以使用一个散列来调用该函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">myfunc(%( a =&gt; 1, b =&gt; &#39;this&#39;, c =&gt; 2.2));</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我想验证那些特定的字段是否存在，我可以把代码放在函数的顶部来做到这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub myfunc(%h) {
    die &#34;a must be an Int&#34; unless %h&lt;a&gt; ~~ Int;
    die &#34;b must be a Str&#34;  unless %h&lt;b&gt; ~~ Str;
    die &#34;c must be a Rat&#34;  unless %h&lt;c&gt; ~~ Rat;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我还想简化引用那些字段的方式，我可以将它们赋值给其他变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub myfunc(%h) {
    die &#34;a must be an Int&#34; unless %h&lt;a&gt; ~~ Int;
    die &#34;b must be a Str&#34;  unless %h&lt;b&gt; ~~ Str;
    die &#34;c must be a Rat&#34;  unless %h&lt;c&gt; ~~ Rat;

    my $a = %h&lt;a&gt;;
    my $b = %h&lt;b&gt;;
    my $c = %h&lt;c&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有点无聊，对吗？</p>
</div>
<div class="paragraph">
<p>Perl 签名参数解构来拯救你了！ 我们可以在子例程签名自身中做所有的事情 - 只要放一个子签名(sub-signature)在后面即可。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub myfunc(%h (Int :$a, Str :$b, Rat :$c)) {...}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_解构_json">4.11. 解构 JSON</h3>
<div class="paragraph">
<p>相当不错，但如果你有<strong>更</strong>复杂的东西呢？</p>
</div>
<div class="paragraph">
<p>假如说一块儿有嵌套结构的 JSON，某些部分可能缺失了, 它们需要默认值, 等等。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use JSON::Fast;
my $item = from-json(q:to/END/);
    {
        &#34;book&#34; : {
            &#34;title&#34;  : &#34;A Christmas Carol&#34;,
            &#34;author&#34; : &#34;Charles Dickens&#34;
        },
        &#34;count&#34; : 12,
        &#34;tags&#34; : [ &#34;christmas&#34;, &#34;santa&#34;]
    }
    END</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>q:to/END/</code> 是一个 Raku <a href="https://docs.raku.org/language/quoting#index-entry-quote_heredocs_%3Ato-Heredocs%3A_%3Ato">heredoc</a>，它直接在文本中直到 END，然后我们可以使用 <a href="https://github.com/timo/json_fast">JSON::Fast</a> 的 <code>from-json()</code> 将其解析为 perl 中的数据结构。 你可以在函数签名中描述整个 JSON 结构，以便接收以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub myfunc(% (:%book (Str:D :$title, Str:D :$author), Int :$count,
              :@tags ($first-tag, *@other-tags)) )
{...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，在函数体中，我可以将这些部分引用为 <code>$title</code>，<code>$author</code>，<code>$count`和 `@tags</code>。 为了方便起见，我还将标签分成了 <code>$first-tag</code> 和 <code>@other-tags</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_在块儿中使用签名">4.12. 在块儿中使用签名</h3>
<div class="paragraph">
<p>当然，签名对于子程序来说是幻想的，但是你也可以在块儿(Block)中使用签名和解构。 假设你有一个上面的 JSON 条目的数组，并希望通过一个 <code>for</code> 循环遍历它们？ 只需在 <code>for</code> 的尖号块中使用解构签名即可：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @itemlist -&gt; % (:%book (Str:D :$title, Str:D :$author), Int :$count,
                    :@tags ($first-tag, *@other-tags))
{
    say &#34;$title, $author, $count, @tags[], $first-tag, @other-tags[]&#34;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意在这种情况下，我甚至不需要散列本身，所以我省略了散列的名称，仅使用 <code>％</code> 作为匿名散列（关联）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_你甚至可以解构对象">4.13. 你甚至可以解构对象!</h3>
<div class="paragraph">
<p>你有没有试过遍历一组对象，你所做的第一件事是调用一些访问器来获取一些属性？ 当然，你可以使用 <code>.attribute</code> 和 主题化的迭代器，但是使用子签名，你可以做更多。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Book {
    has $.title;
    has $.author;
    has $.count;
    has @.tags;
}

my @booklist =
    Book.new(title =&gt; &#39;A Christmas Carol&#39;,
             author =&gt; &#39;Charles Dickens&#39;,
             count =&gt; 12,
             tags =&gt; &lt;ghost christmas&gt;),

    Book.new(title =&gt; &#39;A Visit from St. Nicholas&#39;,
             author =&gt; &#39;Clement Clarke Moore&#39;,
             count =&gt; 4,
             tags =&gt; &lt;santa christmas&gt;);

for @booklist -&gt; Book $b (:$title,:$author, :$count, :@tags) {
    say &#34;$title, $author, $count, @tags[]&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您想检查类型或定义，或设置默认值，您都可以在签名中正确地执行。 如果您不喜欢对象属性的名称，则可以使用别名来重命名它们, 你开心就行。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论_3">4.14. 结论</h3>
<div class="paragraph">
<p>我发现解构参数在与数据库查询结果和 JSON 交互中非常有用。 您可以使用任何其他签名特性，包括指定类型，定义，可选性，默认值，使用别名重命名，使用子集约束或“where”从句，slurpies等。</p>
</div>
<div class="paragraph">
<p>节日快乐！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第六天_raku_书籍">5. 第六天-Raku 书籍</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rakuadvent.wordpress.com/2017/12/06/" class="bare">https://rakuadvent.wordpress.com/2017/12/06/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第七天_测试所有的东西">6. 第七天 – 测试所有的东西</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 与其大姐姐 Perl 5一样，具有很悠久的测试传统。当您安装任何 Perl 模块时，安装程​​序通常会运行该模块的测试套件。当然，作为新兴的 Raku 模块作者，您需要创建自己的测试套件。或者，也许你会在创建模块<strong>之前</strong>勇于创建测试套件。这实际上有几个好处，其中最主要的是你的第一个用户，甚至在它被写之前。</p>
</div>
<div class="paragraph">
<p>但在实际代码之前，我想提一下我经常使用的两个 shell 别名 -</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">alias 6=&#39;raku -Ilib&#39;
alias 6p=&#34;prove -e&#39;raku -Ilib&#39;&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些别名使我可以快速运行测试文件，而不必去安装我的代码。如果我在项目目录中，我可以运行</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ 6 t/01-core.t
ok 1 - call with number
ok 2 - call with text
ok 3 - call with formatted string
1..3</code></pre>
</div>
</div>
<div class="paragraph">
<p>它会告诉我我运行了哪些测试以及它们是否全部通过。就像它的大姐姐Perl 5一样，Raku使用’t /&#39;目录作为测试文件，并按照惯例使用后缀&#39;.t’来区分测试文件和软件包或脚本。它还有一个内置的单元测试模块，我们在上面使用。如果我们正在测试sprintf（）内部，它可能看起来像</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Test;

ok sprintf(1), &#39;call with number&#39;;
ok sprintf(&#34;text&#34;), &#39;call with text&#39;;
ok sprintf(&#34;%d&#34;,1), &#39;call with formatted string&#39;;

done-testing;</code></pre>
</div>
</div>
<div class="paragraph">
<p>ok和done-testing功能会自动导出给我们。我在这里使用规范的Raku风格，而不是太依赖括号。在这种情况下，我确实需要使用圆括号来确保sprintf（）不会“认为”“空调用”是它的参数。</p>
</div>
<div class="paragraph">
<p>OK只需要两个参数，你想要测试的真实性，以及一个可选的消息。如果第一个参数是任何评估为True的东西，则测试通过。否则…​…​你知道。该消息只是描述测试的文本。它纯粹是可选的，但当测试失败时它可以很方便，因为您可以在测试文件中搜索该字符串并快速找到问题。不过，如果你像作者一样，行号更有价值，所以当你看到的时候</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">not ok 1 - call with number
# Failed test &#39;call with number&#39;
# at test.t line 4
ok 2 - call with text
ok 3 - call with formatted string
1..3</code></pre>
</div>
</div>
<div class="paragraph">
<p>在您的测试中，您可以立即跳转到测试文件的第4行并开始编辑以找出问题所在。当你的测试文件变得越来越大时，这会变得更有用，例如我正在编写的Common Lisp版本（格式）的测试，每个测试文件超过200个测试并且不断增长。</p>
</div>
<div class="paragraph">
<p>最后，完成测试只是告诉测试模块我们已经完成了测试，没有更多的测试来了。当你刚刚开始时，这很方便，你不断尝试你的API，添加和更新测试。没有测试计数器来更新每次或任何其他机制来跟踪。</p>
</div>
<div class="paragraph">
<p>当然，这是可选的，但其他工具可能会在最后使用&#39;1..3’来证明您的测试实际上已经完成。 Jenkins的单元测试和其他系统也可能需要这个工具。</p>
</div>
<div class="sect2">
<h3 id="_it_depends">6.1. It depends…</h3>
<div class="paragraph">
<p>你对’是’的定义是什么。如果你只关心某件事情的真实性，好的测试是好的，但有时你需要深入一点。 Raku就像它的大姐姐一样可以帮助你。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">is 1 + 1, 2, &#39;prop. 54.43, Principia Mathematica&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不只是检查你的测试的真实性，它会检查它的价值。虽然你可以很容易地写这个</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">ok 1 + 1 == 2, &#39;prop. 54.43, Principia Mathematica&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用是使你的意图明确，你关注的是表达式1 + 1是否等于2;与同一语句的ok版本一样，目前还不清楚您是在测试&#39;1 + 1’部分还是&#39;==&#39;运算符。</p>
</div>
<div class="paragraph">
<p>这两个测试本身可能占据您测试需求的80％，处理基本列表和哈希时相对安全，如果您真的需要复杂的测试，那么它的大姐姐正在站在脚边，准备处理复杂的哈希阵列组合。</p>
</div>
</div>
<div class="sect2">
<h3 id="_懒惰和不耐烦">6.2. 懒惰和不耐烦</h3>
<div class="paragraph">
<p>有时你会有一个巨大的字符串，你只需要检查一下它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">ok &#39;Lake Char­gogg­a­gogg­man­chaugg­a­gogg­chau­bun­a­gung­a­maugg&#39; ~~ &#39;manchau&#39;, &#39;my side&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你当然可以在这里使用~~运算符。就像&#39;1 + 1 == 2’一样，但是你的意图可能并不明确。你可以使用类似的方法来明确你的意图。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">like &#39;Lake Char­gogg­a­gogg­man­chaugg­a­gogg­chau­bun­a­gung­a­maugg&#39;,
     /manchau/, &#39;my side&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>并没有~~悬在你的船边。</p>
</div>
</div>
<div class="sect2">
<h3 id="_晾干">6.3. 晾干</h3>
<div class="paragraph">
<p>在美丽的Lake Chargoggagoggmanchauggagoggchaubunagungamaugg度过一段时间后，你可能想把你的衣服拧干。测试文件往往会增长，特别是回归测试。你可能会发现自己写作</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">is sprintf( &#34;%s&#34;, &#39;1&#39; ), &#39;1&#39;, &#34;%s formats numbers&#34;;
is sprintf( &#34;%s&#34;, &#39;⅑&#39; ), &#39;⅑&#39;, &#34;%s formats fractions&#34;;
is sprintf( &#34;%s&#34;, &#39;Ⅷ&#39; ), &#39;Ⅷ&#39;, &#34;%s formats graphemes&#34;;
is sprintf( &#34;%s&#34;, &#39;三&#39; ), &#39;三&#39;, &#34;%s formats CJKV&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这很好，复制和粘贴（特别是从StackOverflow）是一个悠久的传统，没有错。不过考虑一下，当你使用“％d”而不是“％s”添加更多测试时会发生什么情况，并且由于所有这些字符串都是数字，因此您只需复制并粘贴该块，将“％s”更改为“％d”，然后继续。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">is sprintf( &#34;%s&#34;, &#39;1&#39; ), &#39;1&#39;, &#34;%s formats numbers&#39;;
# ...

is sprintf( &#34;%d, &#39;1&#39; ), &#39;1&#39;, &#34;%d formats numbers&#39;;
# ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以现在你已经有了两组测试，名称相同。而不是编辑所有新的“％d”测试，如果我们不必首先重复自己的话，这会不会很好？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subtest &#39;%s&#39;, {
    is sprintf( &#34;%s&#34;, &#39;1&#39; ), &#39;1&#39;, &#34;formats numbers&#34;;
    is sprintf( &#34;%s&#34;, &#39;⅑&#39; ), &#39;⅑&#39;, &#34;formats fractions&#34;;
    is sprintf( &#34;%s&#34;, &#39;Ⅷ&#39; ), &#39;Ⅷ&#39;, &#34;formats graphemes&#34;;
    is sprintf( &#34;%s&#34;, &#39;三&#39; ), &#39;三&#39;, &#34;formats CJKV&#34;;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在你只需要在两个地方而不是三个地方进行编辑。如果这激发了您对测试的兴趣，我鼓励您在我的个人网站上查看<a href="http://theperlfisher.blogspot.cz/2017/11/test-all-things.html">测试所有事情</a>以获得更高级的测试范例和更高级的 Raku 代码。另外不要忘记关注明天的 Raku Advent 发布！</p>
</div>
<div class="paragraph">
<p>谢谢你，快乐的黑客！</p>
</div>
<div class="paragraph">
<p>DrForr 又名 Jeff Goff，<a href="http://theperlfisher.blogspot.cz/">Perl Fisher</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第八天_adventures_in_nqp_land_hacking_the_rakudo_compiler">7. 第八天 - Adventures in NQP Land: Hacking the Rakudo Compiler</h2>
<div class="sectionbody">
<div class="paragraph">
<p>对旧圣诞节经典“圣诞节十二天”的道歉，我给你一个 Raku 版本的第一行：</p>
</div>
<div class="paragraph">
<p>在圣诞节的第一天，我真正的爱给了 pod 树上的 Perl 表格…​…​</p>
</div>
<div class="paragraph">
<p>但是我得到的表格不是很漂亮！</p>
</div>
<div class="sect2">
<h3 id="_背景">7.1. 背景</h3>
<div class="paragraph">
<p>我与 Raku 的第一次真正联系是在 2015 年春天，当时我决定检查它的状态，发现它已经准备好迎接黄金时段。在获得了该语言的一些经验之后，我开始在我可以提供帮助的地方贡献文档。我对文档的第一个贡献是清理其中没有很好呈现的表格。在我对本地主机上的 pod 表进行实验期间，我尝试了下表格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">=begin table
-r0c0  r0c1
=end table</code></pre>
</div>
</div>
<div class="paragraph">
<p>这导致 Raku 抛出一个丑陋的, LTA（非常搓）的异常消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">&#34;===SORRY!=== Cannot iterate object with P6opaque representation&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我解决了这个问题，但它让我感觉不爽，所以我开始调查 pod 和 tables 的内部。这导致我在 <a href="https://github.com/rakudo/rakudo/blob/master/src/Raku/Pod.nqp">github.com/rakudo/src/Raku/Pod.nqp</a> 中发现了问题的根源。</p>
</div>
<div class="paragraph">
<p>事实上，许多 pod 表格问题的真正问题最终都出现在该文件中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_not_quite_perl_nqp">7.2. Not Quite Perl (NQP)</h3>
<div class="paragraph">
<p>nqp 是用于构建 Rakudo Raku 编译器的中间语言。它的 git 仓库在<a href="https://github.com/raku/nqp">这里</a>。本文的其余部分是关于修改 rakudo 编译器中的 nqp 代码，其仓库地址在<a href="https://github.com/rakudo/rakudo">这里</a>。 Rakudo 在<a href="http://rakudo.org/">这里</a>也有一个网站。</p>
</div>
<div class="paragraph">
<p>在走得太远之前，我首先阅读有关 Rakudo 和 NQP 的可用信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Jonathan Worthington’s (JWs) 的幻灯片课程 <a href="http://edumentab.github.io/rakudo-and-nqp-internals-course/">Rakudo and NQP Internals</a></p>
</li>
<li>
<p><a href="https://github.com/raku/nqp/blob/master/docs/ops.markdown">NQP opcodes</a></p>
</li>
<li>
<p><a href="https://github.com/raku/nqp/blob/master/docs/built-ins.md">NQP built-in routines</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后我开始通过编写和运行一些这样的小型 nqp 文件来练习nqp编码（文件 “hello.nqp”）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nqp" data-lang="nqp">say(&#34;Hello, world!&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>当它被执行时，会给出预期的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ nqp hello.nqp
Hello, world!</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>say()</code> 是不需要 <code>nqp::</code> 前缀的少数 nqp opcodes 之一。</p>
</div>
</div>
<div class="sect2">
<h3 id="_进入战壕">7.3. 进入战壕</h3>
<div class="paragraph">
<p><code>rakudo/src/Raku/Pod.nqp</code> 文件中包含的 <code>Raku::Pod</code> 类的用途是将 pod grammar 匹配并将它们转换为 <code>rakudo/src/core/Pod.pm</code> 中的 Raku pod 类定义，供 Raku 领地上的渲染者进一步处理。对于表格，表示以 Raku 文档设计中描述的任何合法 pod 格式表示的内容概要 S26，Raku 测试套件规范和 Raku 文档必须转换为 Raku <strong>Pod::Block::Table</strong> 类如文件 <a href="https://github.com/rakudo/rakudo/blob/master/src/core/Pod.pm">rakudo/src/core/Pod.pm</a> 中所述，使用此格式的对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">configuration information
a header line with N cells
M content lines, each with N cells</code></pre>
</div>
</div>
<div class="paragraph">
<p>我希望 nqp 表格 pod 处理功能非常强大，能够自动修复某些格式问题（给作者一个警告），或者抛出一个异常（优雅）并提供问题的详细信息，以便作者修复 pod 输入。</p>
</div>
</div>
<div class="sect2">
<h3 id="_工作区和工具">7.4. 工作区和工具</h3>
<div class="paragraph">
<p>我需要两个克隆版本库：rakudo 和 roast。我还需要在 github 上复刻那些相同的git 仓库，所以我可以为我的更改创建 pull 请求（PR）。我在 CPAN 模块 <a href="https://metacpan.org/pod/distribution/App-GitGot/bin/got">App::GitGot</a> 中找到了非常方便的 Perl 5 工具。使用 <strong>got</strong> 允许我轻松设置所有四个仓库。 （请注意，got 得要求其目标 repo 不存在于所需的本地目录或用户的github 帐户中。）配置完成后，我去了一个合适的目录以包含两个 repos 并执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">got fork https://github.com/rakudo/rakudo.git
got fork https://github.com/raku/roast.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>这导致了一个子目录rakudo和 roast 包含克隆仓库和 rakudo 和 roast github 帐户上的新复刻。在 rakudo 目录中，可以看到用于轻松创建 PR 的默认设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ git remote -v
origin  git@github.com:tbrowder/rakudo.git (fetch)
origin  git@github.com:tbrowder/rakudo.git (push)
upstream    https://github.com/rakudo/rakudo.git (fetch)
upstream    https://github.com/rakudo/rakudo.git (push)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 roast 仓库中有类似的结果。</p>
</div>
<div class="paragraph">
<p>接下来，我将 roast 仓库作为 rakudo 的子目录（“rakudo/t/spec”）重命名，所以它作为本地 rakudo 的一个子集。</p>
</div>
<div class="paragraph">
<p>最后，我创建了几个 bash 脚本，以便于在本地 repo 目录中配置 rakudo 进行安装，设置环境并运行测试：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>rakudo-local-config.sh</p>
</li>
<li>
<p>run-table-tests.sh</p>
</li>
<li>
<p>set-rakudo-envvars.sh</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>（请参阅 <a href="https://github.com/tbrowder/nqp-tools">https://github.com/tbrowder/nqp-tools</a> 上提到的所有脚本。）</p>
</div>
<div class="paragraph">
<p>要完成本地工作环境，您需要安装一些本地模块，以便您必须更改路径并安装 zef 安装程序的本地副本。在 rakudo 目录中执行以下步骤（来自 <a href="https://rakuadvent.wordpress.com/mentions/zoffix/">@Zoffix</a> 的建议）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">git clone https://github.com/ugexe/zef
export PATH=`pwd`/install/bin:$PATH
cd zef; raku -Ilib bin/zef install .
cd ..
export PATH=`pwd`/install/share/raku/site/bin:$PATH
zef install Inline::Perl5</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后安装您需要的其他模块，例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">zef install Debugger::UI::CommandLine
zef install Grammar::Debugger</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hacking">7.5. Hacking</h3>
<div class="paragraph">
<p>现在开始黑客入侵。准备好构建时，执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">make
make install</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>make install</code> 步骤非常关键，否则，在我们设置的本地环境中，将不会找到新的 Raku 可执行文件。</p>
</div>
<div class="paragraph">
<p>调试于我来说很费力，每次重建需要大约三分钟。调试器（raku-debug-m）会非常有用，但我无法安装所需的 <code>Debbugger::UI::CommandLine</code> 模块，因此它可以被本地安装的 <code>raku-debug-m</code> 识别。我使用的主要方法是插入print 语句，并使用 raku 的 <code>--ll-exception</code> 选项。值得注意的是，这位作者是一位 Raku 新手，犯了很多错误，并且并不总是记得修复，因此有了这篇文章。 （注意我可能会使用调试工具，但在我开始的时候，我没有要求帮助，也没有提供上面提供的建议。）</p>
</div>
</div>
<div class="sect2">
<h3 id="_测试">7.6. 测试</h3>
<div class="paragraph">
<p>不言而喻，一个好的 PR 将包括对变化的测试。我总是创建一个与我的 rakudo 分支同名的 roast 分支。然后我提交了两个 PR，我指的是 rakudo PR 中的 toast PR，反之亦然。我注意到 toast PR，它需要伴生 rakudo PR 通过所有测试。</p>
</div>
<div class="paragraph">
<p>见参考文献5 了解更多有关专门测试脚本的详细信息，以进行欺骗和其他深奥测试事宜。</p>
</div>
</div>
<div class="sect2">
<h3 id="_文档">7.7. 文档</h3>
<div class="paragraph">
<p>我尝试将我的修复程序保留在最新的 <a href="https://docs.raku.org/language/tables">Raku pod 表格文档</a>中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_nqp_经验教训">7.8. NQP 经验教训</h3>
<div class="ulist">
<ul>
<li>
<p>LTA 错误消息是生活中的事实，例如，“无法调用此对象…​”，这可能是由很多事情造成的，包括拼写错误的标识符（提交 NQP 问题，早期报告可能不会很快修复）。</p>
</li>
<li>
<p>确保所有 nqp 操作码都有 <code>nqp::</code> 前缀（除了少数内置函数）</p>
</li>
<li>
<p>在 nqp 专用沙箱中练习新代码。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_成功">7.9. 成功！</h3>
<div class="paragraph">
<p>现在我已经接受并合并了两个主要的Raku POD（和 toast）PR，并且我正在研究一个更“容易”的，我将在本周完成。 这些 PR 是：</p>
</div>
<div class="paragraph">
<p>1.Rakudo PR＃1240
这个 <a href="https://github.com/rakudo/rakudo/pull/1240">Rakudo PR</a>  为 RT＃124403，＃128221，＃132341，＃13248和＃129862提供了修复程序。它伴随着 toast <a href="https://github.com/raku/roast/pull/353">PR＃353</a>。</p>
</div>
<div class="paragraph">
<p>这个 PR 允许上面的问题表格被正确渲染。它还添加了有问题的表的警告，添加了 Rakudo 环境变量RAKUDO_POD6_TABLE_DEBUG 以帮助用户调试表（请参阅文档，<a href="https://docs.raku.org/programs/00-running#Environment_Variables">用户调试</a>），并允许具有空列的短行正确呈现。</p>
</div>
<div class="paragraph">
<p>2.Rakudo PR＃1287
这个 <a href="https://github.com/rakudo/rakudo/pull/1287">Rakudo PR</a> 为 Rakudo repo 问题＃1282提供了一个解决方案。它伴随着 roast <a href="https://github.com/raku/roast/pull/361">PR＃361</a>。 （请注意，roast PR＃361 尚未合并。）</p>
</div>
<div class="paragraph">
<p>这个 PR 允许表格视觉列分隔符（&#39;|&#39;）和（&#39;+&#39;）作为单元格数据通过在 pod 源中转义它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_2">7.10. 总结</h3>
<div class="ulist">
<ul>
<li>
<p>Raku pod相对于Perl 5来说是一个很大的改进，但它还没有完全实现。</p>
</li>
<li>
<p>在 Rakudo Perl的内部工作是有益的（并且很有趣），但是准备让你的手变脏！</p>
</li>
<li>
<p>Raku 社区是一个很好的团队。</p>
</li>
<li>
<p>我喜欢 Rakudo Raku。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>圣诞快乐，Hacking 快乐！</p>
</div>
</div>
<div class="sect2">
<h3 id="_参考">7.11. 参考</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>JWs Raku debugger <a href="https://rakuadvent.wordpress.com/2012/12/05/a-perl-6-debugger/">Advent article</a></p>
</li>
<li>
<p>JWs Rakudo debugger module <a href="https://github.com/jnthn/rakudo-debugger">Debugger::UI::CommandLine</a></p>
</li>
<li>
<p>JWs grammar debugger module <a href="https://github.com/jnthn/grammar-debugger">Grammar::Debugger</a></p>
</li>
<li>
<p><a href="https://github.com/raku/roast/blob/master/README.md">Testing Rakudo</a></p>
</li>
<li>
<p><a href="https://github.com/raku/roast/blob/master/CONTRIBUTING.md">Contributing to roast</a></p>
</li>
<li>
<p><a href="https://help.github.com/categories/collaborating-with-issues-and-pull-requests/">Github guide to pull requests (PRs)</a></p>
</li>
<li>
<p><a href="https://docs.raku.org/">Raku documentation (<strong>docs</strong>)</a></p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_附录">7.12. 附录</h3>
<div class="paragraph">
<p>POD 工具</p>
</div>
<div class="ulist">
<ul>
<li>
<p>raku –doc=MODULE # where ‘MODULE’ is ‘HTML’, ‘Text’, 或其它合适的模块</p>
</li>
<li>
<p>p6doc</p>
</li>
<li>
<p>raku –ll-exception</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_主要的_raku_pod_渲染器">7.13. 主要的 Raku POD 渲染器</h3>
<div class="ulist">
<ul>
<li>
<p>Pod::To::Text (part of the rakudo core)</p>
</li>
<li>
<p><a href="https://github.com/raku/Pod-To-HTML">Pod::To::HTML</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第九天_http_and_web_sockets_with_cro">8. 第九天 – HTTP and Web Sockets with Cro</h2>
<div class="sectionbody">
<div class="paragraph">
<p>礼物不仅仅是圣诞节的时候才有。今年夏天，在瑞士 Perl 工作室 - 精美地坐落在阿尔卑斯山 - 我有幸透露了 <a href="http://cro.services/">Cro</a>。 Cro 是一组用于在 Raku 中构建服务的库，以及一些用于 stub，run 和跟踪服务的开发工具。 Cro 主要关注使用 HTTP（包括HTTP/2.0）和 Web 套接字构建服务，但可以提供对 ZeroMQ 的早期支持，并计划在未来推出一系列其他选项。</p>
</div>
<div class="sect2">
<h3 id="_响应式管道">8.1. 响应式管道</h3>
<div class="paragraph">
<p>Cro 遵循 Perl 的设计原则，使简单的事情变得简单，并且让困难的事情变得可能。就像 Git 一样，Cro 可以被认为是具有瓷器（使简单的事情变得简单）和管道（使困难的事情成为可能）。管道水平由组成管道的组件组成。这些组件具有不同的形状，例如源，传输和下沉。这是一个将 HTTP 请求转换为 HTTP 响应的转换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro;
use Cro::HTTP::Request;
use Cro::HTTP::Response;

class MuskoxApp does Cro::Transform {
    method consumes() { Cro::HTTP::Request }
    method produces() { Cro::HTTP::Response }
    method transformer(Supply $pipeline --&gt; Supply) {
        supply whenever $pipeline -&gt; $request {
            given Cro::HTTP::Response.new(:$request, :200status) {
                .append-header: &#34;Content-type&#34;, &#34;text/html&#34;;
                .set-body: &#34;Muskox Rocks!\n&#34;.encode(&#39;ascii&#39;);
                .emit;
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，让我们用一个 TCP 监听器，一个 HTTP 请求解析器和一个 HTTP 响应序列化器来编写它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::TCP;
use Cro::HTTP::RequestParser;
use Cro::HTTP::ResponseSerializer;

my $server = Cro.compose:
    Cro::TCP::Listener.new(:port(4242)),
    Cro::HTTP::RequestParser.new,
    MuskoxApp,
    Cro::HTTP::ResponseSerializer;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">这将返回一个Cro </dt>
<dd>
<p>Service，我们现在可以启动，并在Ctrl + C时停止：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$server.start;
react whenever signal(SIGINT) {
    $server.stop;
    exit;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行。然后 <code>curl</code> 它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ curl http://localhost:4242/
Muskox Rocks!</code></pre>
</div>
</div>
<div class="paragraph">
<p>不错。但是如果我们想要一个HTTPS服务器呢？如果我们有方便的关键和证书文件，这只是一个用TLS监听器替换TCP监听器的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::TLS;

my $server = Cro.compose:
    Cro::TLS::Listener.new(
        :port(4242),
        :certificate-file(&#39;certs-and-keys/server-crt.pem&#39;),
        :private-key-file(&#39;certs-and-keys/server-key.pem&#39;)
    ),
    Cro::HTTP::RequestParser.new,
    MuskoxApp,
    Cro::HTTP::ResponseSerializer;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行。然后 <code>curl -k</code> 它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ curl -k https://localhost:4242/
Muskox Rocks!</code></pre>
</div>
</div>
<div class="paragraph">
<p>和中间件？这只是构成管道的另一个组成部分。或者，从另一个角度来看，对于Cro，一切都是中间件。即使请求解析器或响应序列化器可以很容易地被替换，如果需要的话（这听起来像是一件奇怪的事情需要，但这实际上是实现FastCGI会涉及的）。</p>
</div>
<div class="paragraph">
<p>所以，这就是克罗的方式。它还需要大量的样板才能在此级别上工作。带上瓷器！</p>
</div>
</div>
<div class="sect2">
<h3 id="_http_服务器简单的方法">8.2. HTTP 服务器，简单的方法</h3>
<div class="paragraph">
<p>Cro::HTTP::Server 类摆脱了构建 HTTP 处理管道的样板。从前面的例子变成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro;
use Cro::HTTP::Server;

class MuskoxApp does Cro::Transform {
    method consumes() { Cro::HTTP::Request }
    method produces() { Cro::HTTP::Response }
    method transformer(Supply $pipeline --&gt; Supply) {
        supply whenever $pipeline -&gt; $request {
            given Cro::HTTP::Response.new(:$request, :200status) {
                .append-header: &#34;Content-type&#34;, &#34;text/html&#34;;
                .set-body: &#34;Muskox Rocks!\n&#34;.encode(&#39;ascii&#39;);
                .emit;
            }
        }
    }
}

my $server = Cro::HTTP::Server.new: :port(4242), :application(MuskoxApp);
$server.start;
react whenever signal(SIGINT) {
    $server.stop;
    exit;
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">这里没有魔法;它真的只是一个更方便的方式来组成一条管线。虽然这只是对HTTP / 1. *的节省，但HTTP / 2.0管道涉及更多的组件，而支持这两者的管道仍然更为复杂。相比之下，配置Cro </dt>
<dd>
<p>HTTP :: Server可以轻松地完成支持HTTP / 1.1和HTTP / 2.0的HTTPS：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %tls =
    :certificate-file(&#39;certs-and-keys/server-crt.pem&#39;),
    :private-key-file(&#39;certs-and-keys/server-key.pem&#39;);
my $server = Cro::HTTP::Server.new: :port(4242), :application(MuskoxApp),
    :%tls, :http&lt;1.1 2&gt;;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_通向幸福的途径">8.3. 通向幸福的途径</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Cro中的Web应用程序最终总是将HTTP请求转换为HTTP响应的转换。然而，想要以完全相同的方式处理所有请求的情况非常罕见。通常，不同的URL应该路由到不同的处理程序。输入Cro </dt>
<dd>
<p>HTTP :: Router：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::HTTP::Router;
use Cro::HTTP::Server;

my $application = route {
    get -&gt; {
        content &#39;text/html&#39;, &#39;Do you like dugongs?&#39;;
    }
}

my $server = Cro::HTTP::Server.new: :port(4242), :$application;
$server.start;
react whenever signal(SIGINT) {
    $server.stop;
    exit;
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">路由块返回的对象执行Cro </dt>
<dd>
<p>Transform角色，这意味着它可以很好地与Cro.compose（…​）配合使用。然而，使用路由器编写应用程序会更方便一些！让我们看看更仔细一点：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; {
    content &#39;text/html&#39;, &#39;Do you like dugongs?&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，get是说这个处理程序只处理HTTP GET请求。尖头块的空签名意味着不需要URL段，所以该路由仅适用于/。然后，而不是必须做一个响应对象实例，添加一个头，并编码一个字符串，内容函数完成这一切。</p>
</div>
<div class="paragraph">
<p>路由器是为了利用Raku签名而建立的，同时也可以让Raku程序员感觉自然。路由段通过声明参数来建立，而文字串段恰好匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;product&#39;, $id {
    content &#39;application/json&#39;, {
        id =&gt; $id,
        name =&gt; &#39;Arctic fox photo on canvas&#39;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用curl进行快速检查表明，它还负责为我们序列化JSON：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ curl http://localhost:4242/product/42
{&#34;name&#34;: &#34;Arctic fox photo on canvas&#34;,&#34;id&#34;: &#34;42&#34;}</code></pre>
</div>
</div>
<div class="paragraph">
<p>JSON正文序列化程序由内容类型激活。这是可能的，也很简单，可以实现并插入自己的身体序列器。</p>
</div>
<div class="paragraph">
<p>想要捕获多个网址段？ Slurpy参数也可以工作，这对于服务静态资产时可以很方便地与静态结合使用，也许深层次的多级目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;css&#39;, *@path {
    static &#39;assets/css&#39;, @path;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可选参数适用于可能提供或可能不提供的段。使用子集类型来限制允许的值也可以。 Int只接受URL段中的值以整数形式解析的请求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;product&#39;, Int $id {
    content &#39;application/json&#39;, {
        id =&gt; $id,
        name =&gt; &#39;Arctic fox photo on canvas&#39;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>命名参数用于接收查询字符串参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;search&#39;, :$query {
    content &#39;text/plain&#39;, &#34;You searched for $query&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将填充在这样的请求中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ curl http://localhost:4242/search?query=llama
You searched for llama</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些也可以是类型约束和/或需要的（命名参数在Raku中默认是可选的）。 Cro路由器试图帮助你做好HTTP，方法是给出一个404错误来匹配一个URL段，405（方法不允许），当段匹配但是使用了错误的方法时，400当方法和段很好时，但查询字符串有问题。通过使用is标头并且是cookie特征的命名参数也可以用于接受和/或限制标头和cookie。</p>
</div>
<div class="paragraph">
<p>路由器将所有路由编译成Raku语法，而不是一次一个地浏览路由。这意味着路线将使用NFA进行匹配，而不是一次一个地突破。此外，这意味着应用Raku最长的文字前缀规则，因此：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;product&#39;, &#39;index&#39; { ... }
get -&gt; &#39;product&#39;, $what { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使您按照相反的顺序编写了这些请求，它们总是会优先选择这两项中的第一项作为/ product / index的请求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;product&#39;, $what { ... }
get -&gt; &#39;product&#39;, &#39;index&#39; { ... }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_中间件变得更容易">8.4. 中间件变得更容易</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">有趣的是，HTTP中间件只是一个Cro </dt>
<dd>
<p>Transform，但如果Cro是所有产品的话，那么写起来会不太有趣。令人高兴的是，有一些更简单的选择。路径块可以包含块之前和之后的块，这些块将在块中的任何路由处理之前和之后运行。因此，可以将HSTS标头添加到所有响应中：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $application = route {
    after {
        header &#39;Strict-transport-security&#39;, &#39;max-age=31536000; includeSubDomains&#39;;
    }
    # Routes here...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者对没有授权标头的所有请求使用HTTP 403 Forbidden进行响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $application = route {
    before {
        unless .has-header(&#39;Authorization&#39;) {
            forbidden &#39;text/plain&#39;, &#39;Missing authorization&#39;;
        }
    }
    # Routes here...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其行为如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ curl http://localhost:4242/
Missing authorization
$ curl -H&#34;Authorization: Token 123&#34; http://localhost:4242/
&lt;strong&gt;Do you like dugongs?&lt;/strong&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_这只是一个供应链supply_chain">8.5. 这只是一个供应链(Supply chain)</h3>
<div class="paragraph">
<p>所有的Cro实际上只是构建一系列Raku Supply对象的一种方式。尽管中间件块之前和之后都很方便，但将中间件作为转换编写，无论何时使用语法，都可以访问Raku电源的全部功能。因此，如果您需要使用会话令牌进行请求并对会话数据库进行异步调用，并且只有发出请求才能进行进一步处理（或者重定向到登录页面），则可以这样做 - 阻止其他请求（包括同一连接上的请求）。</p>
</div>
<div class="paragraph">
<p>事实上，Cro完全是根据更高级别的Raku并发功能构建的。没有明确的线程，也没有明确的锁定。相反，所有并发都是以Raku Supply和Promise的形式表示的，并且由Raku运行时库决定，以便在多个线程上扩展应用程序。</p>
</div>
</div>
<div class="sect2">
<h3 id="_哦和websockets">8.6. 哦，和WebSockets？</h3>
<div class="paragraph">
<p>事实证明，Raku提供的地图非常适合网络套接字。事实上，很好，Cro在API方面的增加相对较少。以下是一个（过度）简单的聊天服务器后端的外观：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $chat = Supplier.new;
get -&gt; &#39;chat&#39; {
    # For each request for a web socket...
    web-socket -&gt; $incoming {
        # We start this bit of reactive logic...
        supply {
            # Whenever we get a message on the socket, we emit it into the
            # $chat Supplier
            whenever $incoming -&gt; $message {
                $chat.emit(await $message.body-text);
            }
            # Whatever is emitted on the $chat Supplier (shared between all)
            # web sockets), we send on this web socket.
            whenever $chat -&gt; $text {
                emit $text;
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">请注意，这样做需要使用Cro </dt>
<dd>
<p>HTTP :: Router :: WebSocket;导入提供网络套接字功能的模块。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_综上所述">8.7. 综上所述</h3>
<div class="paragraph">
<p>这只是对Cro所提供的内容的一瞥。没有空间讨论HTTP和Web套接字客户端，用于存根和运行项目的cro命令行工具，提供用于执行相同操作的Web UI的Cro Web工具，或者如果您将CRO_TRACE = 1粘贴到您的环境中，您可以获得大量有关请求和响应处理的多汁调试细节。</p>
</div>
<div class="paragraph">
<p>要了解更多信息，请查看Cro文档，其中包括关于构建单页应用程序的教程。如果你有更多的问题，最近在Freenode上创建了#cro IRC频道</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十天_wrapping_rats">9. 第十天 – Wrapping Rats</h2>
<div class="sectionbody">
<div class="paragraph">
<p>沿着烟囱向下是一件危险的事情。</p>
</div>
<div class="paragraph">
<p>烟囱可能很窄，很高，有时候建造得不够好。</p>
</div>
<div class="paragraph">
<p>今年，圣诞老人想要做好准备。因此，他正在将烟囱检查与交付礼物结合起来。</p>
</div>
<div class="paragraph">
<p>烟囱检查涉及确保每层砖都处于正确的高度; 即砂浆层的高度是一致的，并且砖的高度也是一致的。</p>
</div>
<div class="paragraph">
<p>例如，对于 2¼” 高的砖和厚度为 ⅜” 的砂浆，测量序列应该如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">                       🎅
                      ─██─
                       ||
 layer                                      total
       ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
  2¼   ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
       ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
   ⅜                                        ‾‾???
       ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░
  2¼   ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░
       ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░
   ⅜                                        ‾‾5⅝
       ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░
  2¼   ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░
       ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░
   ⅜                                        ‾‾3
       ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░
  2¼   ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░
       ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░
   ⅜   _____________________________________‾‾⅜</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个计划是让精灵们下降到烟囱的底部，手中拿着卷尺，然后回来，确保每个砖块的顶部恰好位于卷尺上的正确位置。</p>
</div>
<div class="paragraph">
<p>一个名叫猫王的特殊精灵已经自己写了一个程序来帮助完成计算这个高度序列的任务。</p>
</div>
<div class="paragraph">
<p>因为懒惰，猫王甚至不想添加上述任何分数，并希望程序完成所有工作。他也不想花费精力去找出每层高度的公式。幸运的是，他正在使用 Raku，它将 unicode 分数转换为有理数（类型为 <code>Rat</code>），并且还有一个序列运算符（<code>…​</code>），它根据前几项计算出算术序列。</p>
</div>
<div class="paragraph">
<p>所以，猫王在程序中的第一个片段看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @heights = 0, ⅜, 3, 5+⅝ ... *;

say @heights[^10].join(&#39;, &#39;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这给了他需要的前10个高度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">0, 0.375, 3, 5.625, 8.25, 10.875, 13.5, 16.125, 18.75, 21.375</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然这是正确的，但很难使用。卷尺只有几分之一英寸，而不是小数。猫王真正想要的输出是分数。</p>
</div>
<div class="paragraph">
<p>幸运的是，他知道使用 <code>join</code> 将 <code>Rat`s 转换为字符串，通过调用 `Rat</code> 类的 <code>Str</code> 方法完成将 <code>Rat</code> 转换为 <code>Str</code>。因此，通过修改 <code>Rat.Str</code> 的行为，他认为可以使输出更漂亮。</p>
</div>
<div class="paragraph">
<p>他决定这样做的方式是包装(<code>wrap</code>) <code>Str</code> 方法（又名使用装饰器模式），如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Rat.^find_method(&#39;Str&#39;).wrap:
  sub ($r) {
    my $whole = $r.Int || &#34;&#34;;
    my $frac = $r - $whole;
    return &#34;$whole&#34; unless $frac &gt; 0;
    return &#34;$whole&#34; ~ &lt;⅛ ¼ ⅜ ½ ⅝ ¾ ⅞&gt;[$frac * 8 - 1];
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>换句话说，当把 <code>Rat</code> 字符串化时，除非有小数部分，否则返回整个部分。然后将小数部分视为八分之一数，并将其用作数组中的索引以查找正确的 unicode 分数。</p>
</div>
<div class="paragraph">
<p>他将这一点与他的第一个程序结合起来，以获得这样的高度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">0, ⅜, 3, 5⅝, 8¼, 10⅞, 13½, 16⅛, 18¾, 21⅜</code></pre>
</div>
</div>
<div class="paragraph">
<p>“万岁!” 他想。 “正是我需要的。”</p>
</div>
<div class="paragraph">
<p>圣诞老人看了看这个程序，并说：“猫王，这很聪明，但还不够。虽然大多数砖块的尺寸是 ⅛ 的倍数，但砂浆水平可能并非如此。你也可以让你的程序处理这些情况吗？“</p>
</div>
<div class="paragraph">
<p>“当然”，猫王苦笑着说。然后他将这一行添加到他的包装函数中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">return &#34;$whole {$frac.numerator}⁄{$frac.denominator}&#34;
   unless $frac %% ⅛;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用“可被整除”操作符（<code>%%</code>），以确保分数可以平分为八分之一，并且如果不是只显式地打印分子和分母。然后，对于 ⅕” 厚的砂浆，序列为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @heights = 0, ⅕,
                 ⅕ + 2+¼ + ⅕,
                 ⅕ + 2+¼ + ⅕
                   + 2+¼ + ⅕ ... *;
say @heights[^10].join(&#39;, &#39;);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">0,  1⁄5, 2 13⁄20, 5 1⁄10, 7 11⁄20, 10, 12 9⁄20, 14 9⁄10, 17 7⁄20, 19 4⁄5</code></pre>
</div>
</div>
<div class="paragraph">
<p>“实际上”，圣诞老人说，“现在在我看来，也许这没有用 - 卷尺只有十六分之一英寸，所以最好四舍五入到十六分之一英寸。”</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2017/12/tape-measure.jpg?w=1570">img</a></p>
</div>
<div class="paragraph">
<p>猫王加了一个 <code>round</code> 调用来结束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Rat.^find_method(&#39;Str&#39;).wrap:
  sub ($r) {
        my $whole = $r.Int || &#39;&#39;;
        my $frac = $r - $whole;
        return &#34;$whole&#34; unless $frac &gt; 0;
        my $rounded = ($frac * 16).round/16;
        return &#34;$whole&#34; ~ &lt;⅛ ¼ ⅜ ½ ⅝ ¾ ⅞&gt;[$frac * 8 - 1] if $rounded %% ⅛;
        return &#34;$whole {$rounded.numerator}⁄{$rounded.denominator}&#34;;
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这给了他：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">0,  3⁄16, 2⅝, 5⅛, 7 9⁄16, 10, 12 7⁄16, 14⅞, 17¼, 19 13⁄16</code></pre>
</div>
</div>
<div class="paragraph">
<p>他向 Elvira 精灵展示了他的程序，他说：“真是巧合，我写了一个几乎完全一样的程序！除此之外，我也想知道砖层的底部在哪里。我无法使用序列运算符来完成此操作，因为它不是算术级数，但是我可以使用 lazy gather 和匿名有状态变量！就像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my \brick = 2 + ¼;
my \mortar = ⅜;
my @heights = lazy gather {
    take 0;
    loop { take $ += $_ for mortar, brick }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Elvira 的程序产生了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">0, ⅜, 2⅝, 3, 5¼, 5⅝, 7⅞, 8¼, 10½, 10⅞</code></pre>
</div>
</div>
<div class="paragraph">
<p>即砖层的顶部和底部：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">                     \ 🎅 /
                       ██
                       ||
 layer                                      total
       ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
  2¼   ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
       ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░
   ⅜                                        ‾‾8¼
       ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░‾‾7⅞
  2¼   ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░
       ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░
   ⅜                                        ‾‾5⅝
       ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░‾‾5¼
  2¼   ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░
       ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░
   ⅜                                        ‾‾3
       ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░‾‾2⅝
  2¼   ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░
       ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░
   ⅜   _____________________________________‾‾⅜
                                            ‾‾0</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了他们的程序在手，精灵检查了烟囱，圣诞老人在另一个节日期间没有受伤。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十一天_raku_中所有的星号">10. 第十一天-Raku 中所有的星号</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在今年的 Raku Advent Calendar 中, 雪花被今天的博客文章承包了。 我们将检阅使用了 <code><strong></strong></code><strong> 字符的结构。 在 Raku 中，根据上下文的不同，您可以叫它星星（或者，如果你愿意的话，可以叫它星号）或者 *whatever</strong>。</p>
</div>
<div class="paragraph">
<p>Raku 不是一个隐秘的编程语言， 在许多方面它的语法比 Perl 5 更加一致。另一方面，有些地方需要花时间来开启对语法的信心。</p>
</div>
<div class="paragraph">
<p>让我们看看 <code><strong></strong></code><strong> 的不同用法，从最简单的开始，旨在了解最烧脑的例如 <code></code></strong><code> ** *</code>。</p>
</div>
<div class="paragraph">
<p>前两种用法很简单，不需要太多的讨论：</p>
</div>
<div class="sect2">
<h3 id="_1_乘法">10.1. 1. 乘法</h3>
<div class="paragraph">
<p>单个星号用于乘法。严格来讲, 这是一个中缀操作符 <code>infix:&lt;*&gt;</code>, 它的返回值为 <code>Numeric</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say 20 * 18; # 360</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_幂">10.2. 2. 幂</h3>
<div class="paragraph">
<p>两个星号 <code><strong></strong></code><strong> 是幂操作符。再次, 这是一个中缀操作符 <code>infix:&lt;</code></strong><code>&gt;</code>, 它返回 <code>Numeric</code> 结果, 计算两个给定值点幂。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say pi ** e; # 22.4591577183611</code></pre>
</div>
</div>
<hr/>
<div class="paragraph">
<p>正则表达式中同样也使用了两个标记（<code><strong></strong></code><strong> 或 <code></code></strong><code>*</code>），它们表示不同的东西。 Raku 的一个特点是它可以很容易地在不同的语言之间切换。 正则表达式和 grammar 都是这样的内部语言的例子，其中同样的符号在 Raku 中可能意味着不同的含义。</p>
</div>
</div>
<div class="sect2">
<h3 id="_3_零或多次重复">10.3. 3. 零或多次重复</h3>
<div class="paragraph">
<p><code>*</code> 号量词这个语法条目和 Perl 5 中点行为类似: 允许原子的零次或多次重复。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my $weather = &#39;*****&#39;;
my $snow = $weather ~~ / (&#39;*&#39;*) /;
say &#39;Snow level is &#39; ~ $snow.chars; # Snow level is 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然, 我们还在这儿看到了同一个字符的另一种用法, <code>*</code> 字面量。</p>
</div>
</div>
<div class="sect2">
<h3 id="_4_min_到_max_次重复">10.4. 4. Min 到 Max 次重复</h3>
<div class="paragraph">
<p>两个 <code>**</code> 号是另一个量词的一部分，它指定了最小和最大重复次数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my $operator = &#39;..&#39;;
say &#34;&#39;$operator&#39; is a valid Raku operator&#34;
    if $operator ~~ /^ &#39;.&#39; ** 1..3 $/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，预计这个点会被重复一次，两次或三次; 不多也不少。</p>
</div>
<div class="paragraph">
<p>让我们超前一点儿，以 <code>Whatever</code> 符号的角色（剧场中的角色，而不是 Raku 的面向对象编程）使用星号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my $phrase = &#39;I love you......&#39;;
say &#39;You are so uncertain...&#39;
    if $phrase ~~ / &#39;.&#39; ** 4..* /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>范围的第二个端点是打开的，这个正则表达式接受所有其中包含四个点以上的短语。</p>
</div>
</div>
<div class="sect2">
<h3 id="_5_吞噬参数">10.5. 5. 吞噬参数</h3>
<div class="paragraph">
<p>在子例程签名的数组参数之前的星号意味着吞噬参数 - 将单独的标量参数吞噬进单个数组中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">list-gifts(&#39;chocolade&#39;, &#39;ipad&#39;, &#39;camelia&#39;, &#39;raku&#39;);

sub list-gifts(*@items) {
    say &#39;Look at my gifts this year:&#39;;
    .say for @items;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>哈希也允许吞噬参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">dump(alpha =&gt; &#39;a&#39;, beta =&gt; &#39;b&#39;); # Prints:
                                 # alpha = a
                                 # beta = b

sub dump(*%data) {
    for %data.kv {say &#34;$^a = $^b&#34;}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，与 Perl 5 不同的是，如果您省略函数签名中的星号，代码将无法编译，因为 Raku 就是说一不二：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Too few positionals passed; expected 1 argument but got 0</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_6_吨吨吨吨吨吨吨">10.6. 6. 吨吨吨吨吨吨吨</h3>
<div class="paragraph">
<p><code>**@</code> 也能工作，但是当你传递数组或列表的时候请注意其中的区别。</p>
</div>
<div class="paragraph">
<p>带一颗星星：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my @a = &lt; chocolade ipad &gt;;
my @b = &lt; camelia raku &gt;;

all-together(@a, @b);
all-together([&#39;chocolade&#39;, &#39;ipad&#39;], [&#39;camelia&#39;, &#39;raku&#39;]);
all-together(&lt; chocolade ipad &gt;, &lt; camelia raku &gt;);

sub all-together(*@items) {
    .say for @items;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>目前，无论参数列表传递的方式如何，每个礼物都被单独打印了出来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">chocolade
ipad
camelia
raku
chocolade
ipad
camelia
raku
chocolade
ipad
camelia
raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>带俩颗星星：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">keep-groupped(@a, @b);
keep-groupped([&#39;chocolade&#39;, &#39;ipad&#39;], [&#39;camelia&#39;, &#39;raku&#39;]);
keep-groupped(&lt; chocolade ipad &gt;, &lt; camelia raku &gt;);

sub keep-groupped(**@items) {
    .say for @items;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次，<code>@items</code> 数组只有两个元素，反映了参数的结构类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">[chocolade ipad]
[camelia raku]</code></pre>
</div>
</div>
<div class="paragraph">
<p>或</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">(chocolade ipad)
(camelia raku)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_7_动态作用域">10.7. 7. 动态作用域</h3>
<div class="paragraph">
<p><code>*</code> twigil，引入了动态作用域。 动态变量和全局变量很容易搞混淆，所以最好测试下面的代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">sub happy-new-year() {
    &#34;Happy new $*year year!&#34;
}

my $*year = 2018;
say happy-new-year(); # 输出 Happy new 2018 year!</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你省略了星号, 那么代码就运行不了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">Variable &#39;$year&#39; is not declared</code></pre>
</div>
</div>
<div class="paragraph">
<p>更正它的唯一方法是将 <code>$year</code> 的定义移到函数定义的上面。 使用动态变量 <code>$*year</code>，函数被调用的地方定义了结果。 <code>$*year</code> 变量在子例程的外部作用域中是不可见的，但是在动态作用域内是可见的。</p>
</div>
<div class="paragraph">
<p>对于动态变量，将新值赋给现有变量还是创建新变量并不重要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">sub happy-new-year() {
    &#34;Happy new $*year year!&#34;
}

my $*year = 2018;
say happy-new-year();

{
    $*year = 2019;        # New value
    say happy-new-year(); # 2019
}

{
    my $*year = 2020;     # New variable
    say happy-new-year(); # 2020
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_8_编译变量">10.8. 8. 编译变量</h3>
<div class="paragraph">
<p>Raku 提供了许多伪动态常量, 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say $*PERL;      # Raku (6.c)
say @*ARGS;      # Prints command-line arguments
say %*ENV&lt;HOME&gt;; # Prints home directory</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_9_all_methods">10.9. 9. All methods</h3>
<div class="paragraph">
<p><code>.*</code> postfix 伪操作符调用给定名称的所有方法，名称可以在给定的对象中找到，并返回一个结果列表。 在微不足道的情况下，你会得到一个学术上荒诞不羁的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">6.*perl.*say; # (6 Int.new)</code></pre>
</div>
</div>
<div class="paragraph">
<p>带星号的代码与不带星号代码有些不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">pi.perl.say; # 3.14159265358979e0 (notice the scientific
             # format, unlike pi.say)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.*</code> postfix 的真正威力来自于继承。 它有时有助于揭示真相：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">class Present {
    method giver() {
        &#39;parents&#39;
    }
}

class ChristmasPresent is Present {
    method giver() {
        &#39;Santa Claus&#39;
    }
}

my ChristmasPresent $present;

$present.giver.say;             # Santa Claus
$present.*giver.join(&#39;, &#39;).say; # Santa Claus, parents</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个星号就差别很大!</p>
</div>
<hr/>
<div class="paragraph">
<p>现在，到了 Raku 最神秘的部分。接下来的两个概念，<code>Whatever</code> 和 <code>WhateverCode</code> 类，很容易混淆在一起。 让我们试着做对吧。</p>
</div>
</div>
<div class="sect2">
<h3 id="_10_whatever">10.10. 10. Whatever</h3>
<div class="paragraph">
<p>单个星号 <code>*</code> 能表示任何东西(<code>Whatever</code>)。 <code>Whatever</code> 在 Raku 中是一个预定义好的类, 它在某些有用的场景下引入了一些规定好的行为。</p>
</div>
<div class="paragraph">
<p>例如，在范围和序列中，最后的 <code>*</code> 表示无穷大。 我们今天已经看到了一个例子。 这是另一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">.say for 1 .. *;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个单行程序具有非常高的能量转换效率，因为它产生了一个递增整数的无限列表。 如果你要继续，请按 <code>Ctrl + C</code>。</p>
</div>
<div class="paragraph">
<p>范围 <code>1 .. *</code> 与 <code>1 .. Inf</code> 相同。 您可以清楚地看到，如果您跳转到 Rakudo Raku 源文件并在 <a href="https://github.com/rakudo/rakudo/blob/master/src/core/Range.pm">src/core/Range.pm</a> 文件的 <code>Range</code> 类的实现中找到如下定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">multi method new(Whatever \min,Whatever \max,:$excludes-min,:$excludes-max){
    nqp::create(self)!SET-SELF(-Inf,Inf,$excludes-min,$excludes-max,1);
}
multi method new(Whatever \min, \max, :$excludes-min, :$excludes-max) {
    nqp::create(self)!SET-SELF(-Inf,max,$excludes-min,$excludes-max,1);
}
multi method new(\min, Whatever \max, :$excludes-min, :$excludes-max) {
    nqp::create(self)!SET-SELF(min,Inf,$excludes-min,$excludes-max,1);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这三个 multi 构造函数描述了三种情况：<code>* .. <strong></strong></code><strong>，<code></code></strong><code> .. $n</code> 和 <code>$n .. *</code>，它们被立即转换为 <code>-Inf .. Inf</code>，<code>-Inf .. $n</code> 和 <code>$n .. Inf</code>。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>作为一个圣诞故事，这里有一个小小的插曲，表明 <code>*</code> 不仅仅是一个 <code>Inf</code>。 有两个到 <a href="https://github.com/rakudo/rakudo/blob/master/src/core/Whatever.pm">src/core/Whatever.pm</a> 的提交：</p>
</div>
</blockquote>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>首先，2015年9月16日，&#34;<a href="https://github.com/rakudo/rakudo/commit/425845d723afb60d80dcca55b509ff1c1f9b303c#diff-ac169f9e5137f98d305f3cae4c0c4d07" class="bare">https://github.com/rakudo/rakudo/commit/425845d723afb60d80dcca55b509ff1c1f9b303c#diff-ac169f9e5137f98d305f3cae4c0c4d07</a>:&#34;</p>
</div>
</blockquote>
</div>
<div class="literalblock">
<div class="content">
<pre>  my class Whatever {
      multi method ACCEPTS(Whatever:D: $topic) { True }
      multi method perl(Whatever:D:) { &#39;*&#39; }
+     multi method Numeric(Whatever:D:) { Inf }
  }</pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>几周之后, 在2015年10月23日，&#34;<a href="https://github.com/rakudo/rakudo/commit/4e35e807c5f0c8ac134e1ed87b4b9343966d0d8d#diff-ac169f9e5137f98d305f3cae4c0c4d07">* no longer defaults to Inf</a>&#34;，这是为了保护其他 dwimmy 情况下的扩展性:</p>
</div>
</blockquote>
</div>
<div class="literalblock">
<div class="content">
<pre>  my class Whatever {
      multi method ACCEPTS(Whatever:D: $topic) { True }
      multi method perl(Whatever:D:) { &#39;*&#39; }
-     multi method Numeric(Whatever:D:) { Inf }
  }</pre>
</div>
</div>
<div class="paragraph">
<p>回到我们更实际的问题，让我们创建自己的使用 whatever 符号 <code>*</code> 的类，。 下面是一个简单的例子，它带有一个接收 <code>Int</code> 值或者 <code>Whatever</code> 的 multi-方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">class N {
    multi method display(Int $n) {
        say $n;
    }

    multi method display(Whatever) {
        say 2000 + 100.rand.Int;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第一种情况下，该方法只是打印该值。 第二种方法是打印一个在 2000 到 2100 之间的随机数。 因为第二种方法的唯一参数是 <code>Whatever</code>，所以签名中不需要变量。</p>
</div>
<div class="paragraph">
<p>下面是你如何使用这个类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my $n = N.new;
$n.display(2018);
$n.display(*);</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个调用回显它的参数，而第二个调用打印某些随机的东西。</p>
</div>
<div class="paragraph">
<p><code>Whatever</code> 符号可以作为一个裸的 <code>Whatever</code>。 假如，你创建一个 <code>echo</code> 函数，并将 <code>*</code> 传递给它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">sub echo($x) {
    say $x;
}

echo(2018); # 2018
echo(*);    # *</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一次，没有魔术发生，该程序打印一个星号。</p>
</div>
<div class="paragraph">
<p>现在我们正处在一个四两拨千斤的节骨眼上。</p>
</div>
</div>
<div class="sect2">
<h3 id="_11_whatevercode">10.11. 11. WhateverCode</h3>
<div class="paragraph">
<p>最后, 我们来谈谈 <code>WhateverCode</code>。</p>
</div>
<div class="paragraph">
<p>取一个数组然后打印出它的最后一个元素。如果你使用 Perl 5 的风格来做, 你会键入 <code>@a[-1]</code> 那样的东西。在 Raku 中, 那会产生错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Unsupported use of a negative -1 subscript
to index from the end; in Raku please
use a function such as *-1</code></pre>
</div>
</div>
<div class="paragraph">
<p>编译器建议使用一个函数, 例如 <code>*-1</code>。它是函数吗？是的, 更准确的说, 它是一个 <code>WhateverCode</code> 块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say (*-1).WHAT; # (WhateverCode)</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 打印数组的后半部分:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my @a = &lt; one two three four five six &gt;;
say @a[3..*]; # (four five six)</code></pre>
</div>
</div>
<div class="paragraph">
<p>数组的索引的范围是 <code>3 .. *</code>。 <code>Whatever</code> 作为 range 的右端意味着从数组中取出所有剩余的元素。 <code>3 .. *</code> 的类型是 <code>Range</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say (3..*).WHAT; # (Range)</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，减少一个元素。 我们已经看到，要指定最后一个元素，必须要使用诸如 <code>*-1</code> 的函数。 在 range 的右端可以做同样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say @a[3 .. *-2]; # (four five)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个时候，发生了所谓的 <code>Whatever-柯里化</code>，<code>Range</code> 变成了 <code>WhateverCode</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say (3 .. *-2).WHAT; # (WhateverCode)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>WhateverCode</code> 是一个内置的 Raku 类名称; 它可以很容易地用于方法分派。 让我们更新上一节中的代码，并添加一个方法变体，它需要一个 <code>WhateverCode</code> 参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">class N {
    multi method display(Int $n) {
        say $n;
    }

    multi method display(Whatever) {
        say 2000 + 100.rand.Int;
    }

    multi method display(WhateverCode $code) {
        say $code(2000 + 100.rand.Int);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，参数列表中的星号要么落入 <code>display(Whatever)</code>, 要么落入 <code>display(WhateverCode)</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">N.display(2018);     # display(Int $n)

N.display(*);        # display(Whatever)

N.display(* / 2);    # display(WhateverCode $code)
N.display(* - 1000); # display(WhateverCode $code)</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们再来看看 <code>display</code> 方法中的签名:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">multi method display(WhateverCode $code)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$code</code> 参数被用作方法内的函数引用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say $code(2000 + 100.rand.Int);</code></pre>
</div>
</div>
<div class="paragraph">
<p>该函数需要一个参数，但它会去哪里？ 或者换句话说，函数体是什么，在哪里？ 我们将该方法调用为 <code>N.display(* / 2)</code> 或 <code>N.display(* - 1000)</code>。 答案是 <code>* / 2</code> 和 <code>* - 1000</code> 都是函数！ 还记得编译器关于使用诸如 <code>*-1</code> 之类的函数的提示吗？</p>
</div>
<div class="paragraph">
<p>这里的星号成为第一个函数参数，因此 <code>* / 2</code> 相当于 <code>{$^a / 2}</code>，而 <code>*-1000</code> 相当于 <code>{$^a - 1000}</code>。</p>
</div>
<div class="paragraph">
<p>这是否意味着可以在 <code>$^a</code> 的旁边使用 <code>$^b</code>? 当然！ 使 <code>WhateverCode</code> 块接受两个参数。 你如何指出其中的第二个？ 毫不惊喜，再用一个星号！ 让我们将 <code>display</code> 方法的第四个变体添加到我们的类中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">multi method display(WhateverCode $code
                     where {$code.arity == 2}) {
    say $code(2000, 100.rand.Int);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，使用 <code>where</code> 块来缩小调度范围，只选择那些有两个参数的 <code>WhateverCode</code> 块。 完成此操作后，方法调用中将允许含有两个雪花：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">N.display( * + * );
N.display( * - * );</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些调用定义了用于计算结果的函数 <code>$code</code>。 所以，<code>N.display(* + *)</code> 背后的实际操作如下：<code>2000 + 100.rand.Int</code>。</p>
</div>
<div class="paragraph">
<p>需要更多的雪花吗？ 多添加点星星：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">N.display( * * * );
N.display( * ** * );</code></pre>
</div>
</div>
<div class="paragraph">
<p>类似地, 里面实际的计算是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">2000 * 100.rand.Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>和</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">2000 ** 100.rand.Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>恭喜！ 你现在可以像编译器那样毫不费力地解析 <code>* ** *</code> 结构了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_作业">10.12. 作业</h3>
<div class="paragraph">
<p>到目前为止，Raku 给了我们很多圣诞礼物。 让我们回过头来做一下练习并回答一下问题：下面代码中的每个星号在意味着什么？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my @n =
    ((0, 1, * + * ... *).grep: *.is-prime).map: * * * * *;
.say for @n[^5];</code></pre>
</div>
</div>
<div class="paragraph">
<p>D’哦。 我建议我们从转换代码开始来摆脱所有的星号，并使用不同的语法。</p>
</div>
<div class="paragraph">
<p>序列运算符 <code>…​</code> 之后的 <code>*</code> 意味着无限地生成序列，所以用 <code>Inf</code> 来代替它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">((0, 1, * + * ... Inf).grep: *.is-prime).map: * * * * *</code></pre>
</div>
</div>
<div class="paragraph">
<p>生成器函数中的两个星号 <code>* + *</code> 可以用一个带有两个显式参数的 lambda 函数来替换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">((0, 1, -&gt; $x, $y {$x + $y} ... Inf).grep:
    *.is-prime).map: * * * * *</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，简单的语法交替。 用带圆括号的方法调用替换 <code>.grep</code>。 它的参数 <code><strong>.is-prime</strong></code><strong> 变成一个代码块，并且星号被替换为默认变量 <code>$_</code>。 请注意，代码使用 <code></code></strong> 时不需要花括号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">(0, 1, -&gt; $x, $y {$x + $y} ... Inf).grep({
    $_.is-prime
}).map: * * * * *</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，与 <code>.map</code> 相同的技巧：但是这次这个方法有三个参数，因此，你可以编写 <code>{$^a * $^b * $^c}</code> 而不是 <code>* * * * *</code>，这里是新的 完整程序的变体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my @n = (0, 1, -&gt; $x, $y {$x + $y} ... Inf).grep({
        $_.is-prime
    }).map({
        $^a * $^b * $^c
    });
.say for @n[^5];</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在很明显，代码打印了三个斐波那契素数组积的前五个。</p>
</div>
</div>
<div class="sect2">
<h3 id="_附加题">10.13. 附加题</h3>
<div class="paragraph">
<p>在教科书中，最具挑战性的任务是用 <code>*</code> 标记的。 这里有几个由你自己来解决。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1. Raku 中的 <code>chdir(&#39;/&#39;)</code> 和 <code>＆*chdir(&#39;/&#39;)</code> 有什么区别？</p>
</li>
<li>
<p>2. 解释下面的 Raku 代码并修改它以展示其优点：<code>.say for 1 …​ **</code>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>❄❄❄</p>
</div>
<div class="paragraph">
<p>今天就这样了。 我希望你喜欢 Raku 的强大功能和表现力。今天，我们只谈到了一个 ASCII 字符。 想象一下，如果考虑到该语言在当今编程语言中提供了最好的 Unicode 支持，Raku 的 Universe 是多么的庞大。</p>
</div>
<div class="paragraph">
<p>今天享受 Raku，并传播这个词！ 请继续关注 Raku Advent Calendar; 更多的文章正在等待你的关注，明天就要来了。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十二天_the_year_of_raku_books">11. <a href="https://rakuadvent.wordpress.com/2017/12/12/day-12-the-year-of-perl-6-books/">第十二天 – The Year of Raku Books</a></h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_第十三天_使用_raku_挖掘维基百科">12. 第十三天 - 使用 Raku 挖掘维基百科</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_介绍">12.1. 介绍</h3>
<div class="paragraph">
<p>大家好!</p>
</div>
<div class="paragraph">
<p>今天，让我介绍一下如何用 Raku 挖掘维基百科的 Infobox。</p>
</div>
<div class="paragraph">
<p>维基百科信息框在自然语言处理中扮演着非常重要的角色，并且有许多应用程序可以利用维基百科信息框：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>构建知识库（例如 DBpedia[0]）</p>
</li>
<li>
<p>排名属性的重要性[1]</p>
</li>
<li>
<p>问答[2]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>其中，我将重点讨论信息框提取问题，并演示如何使用 Grammars 和 Actions 解析信息框的复杂结构。</p>
</div>
</div>
<div class="sect2">
<h3 id="_grammar_和_actions_难学吗">12.2. Grammar 和 Actions 难学吗?</h3>
<div class="paragraph">
<p>不，他们不是！</p>
</div>
<div class="paragraph">
<p>你只需要知道五件事情：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Grammar</p>
</li>
<li>
<p><strong>token</strong> 是最基础的一个。你通常使用它。</p>
</li>
<li>
<p><strong>rule</strong> 让空白符有意义。</p>
</li>
<li>
<p><strong>regex</strong> 让匹配引擎回溯。</p>
</li>
<li>
<p>Actions</p>
</li>
<li>
<p><strong>make</strong> 准备一个对象用于返回当 made calls on it。</p>
</li>
<li>
<p><strong>made</strong> 在它的调用者身上调用并返回准备好的对象。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>欲了解更多信息, 请查看: <a href="https://docs.raku.org/language/grammars">https://docs.raku.org/language/grammars</a></p>
</div>
<div class="sect3">
<h4 id="_什么是_infobox">12.2.1. 什么是 Infobox?</h4>
<div class="paragraph">
<p>你有没有听过 &#34;Infobox&#34; 这个词?</p>
</div>
<div class="paragraph">
<p>对于那些没听说过的人，我会简单地解释一下。</p>
</div>
<div class="paragraph">
<p>理解信息框的一个简单方法是使用一个真实的例子：</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2017/11/rakuinfobox.png">img</a></p>
</div>
<div class="paragraph">
<p>你可以看到，信息框会在页面的右上方显示页面主题的属性-值对儿。例如, 在这个例子中, 它说 Raku 的设计者 (ja: 設計者)是 Larry Wall(ja: ラリー・ウォール)。</p>
</div>
<div class="paragraph">
<p>欲了解更多信息, 请查看: <a href="https://en.wikipedia.org/wiki/Help:Infobox">https://en.wikipedia.org/wiki/Help:Infobox</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_第一个例子_raku">12.2.2. 第一个例子: Raku</h4>
<div class="paragraph">
<p>首先要说的是，我将使用日文维基百科而不是英文维基百科演示解析技术。</p>
</div>
<div class="paragraph">
<p>主要原因是解析日文维基百科是我的$ dayjob :)</p>
</div>
<div class="paragraph">
<p>第二个原因是我想要展示 Raku 如何轻松地处理 Unicode 字符串。</p>
</div>
<div class="paragraph">
<p>然后，让我们开始解析 <a href="https://ja.wikipedia.org/wiki/Perl_6">Raku 文章</a>中的信息框！</p>
</div>
<div class="paragraph">
<p>用 wiki 标记写的文章的代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">{{Comp-stub}}

{{Infobox プログラミング言語
|名前             = Raku
|ロゴ             = [[Image:Camelia.svg|250px]]
|パラダイム       = [[マルチパラダイムプログラミング言語|マルチパラダイム]]
|登場時期         = [[2015年]]12月25日
|設計者           = [[ラリー・ウォール]]
|最新リリース     = Rakudo Star 2016.04
|型付け           = [[動的型付け]], [[静的型付け]]
|処理系           = [[Rakudo]]
|影響を受けた言語 = [[Perl|Perl 5]], [[Smalltalk]], [[Haskell]], [[Ruby]]
|ライセンス       = [[Artistic License 2]]
|ウェブサイト     = [https://raku.org/ Raku.org]
}}
{{プログラミング言語}}

&#39;&#39;&#39;Raku&#39;&#39;&#39;（パールシックス）は、[[ラリー・ウォール]]により設計された[[オブジェクト指向]][[スクリプト言語]]である。

Rakuは、[[2000年]]に[[Perl]]の次期メジャーバージョンとして設計が始められ、[[2015年]]12月25日に公式のRaku正式安定版がリリースされた。しかし、言語仕様は現在のPerl (Perl 5)と互換性がなく、既存のPerl 5のソフトウェアをRaku用に「アップグレ
ード」するのは極めて困難である。したがって現在はPerl 5とRakuは別の言語であると考えられており、RakuはPerl 5の次期バージョンではないとされている。換言すれば、RakuはPerl 5から移行対象とはみなされていない。</code></pre>
</div>
</div>
<div class="paragraph">
<p>代码有三个有问题的部分：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>信息框块后面有多余的元素，例如模板 <code>{{プログラミング言語}}</code> 和以 <code>&#39;&#39;&#39;Raku&#39;&#39;&#39;</code> 开头的主句。</p>
</li>
<li>
<p>我们必须区分三种类型的 token: 锚点文本（例如: <code><a id="Rakudo"></a></code>）, 原始文本（例如： <code>Rakudo Star 2016.04</code>）, 网站链接
（例如： <code>[<a href="https://raku.org/" class="bare">https://raku.org/</a> Raku.org]</code>）。</p>
</li>
<li>
<p>信息框不从文章的顶部位置开始。在这个例子中, <code>{{Comb-stub}}</code> 在文章的顶部。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>好的，接下来我将演示如何按照 Grammar，Actions，Caller（即调用 Grammar 和 Actions 的代码部分）的顺序来解决上述问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="_grammar">12.2.3. Grammar</h4>
<div class="paragraph">
<p>解析信息框的 Grammar 代码如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Infobox::Grammar {
    token TOP { &lt;infobox&gt; .+ } # (#1)
    token infobox { &#39;{{Infobox&#39; &lt;.ws&gt; &lt;name&gt; \n &lt;propertylist&gt; &#39;}}&#39; }
    token name { &lt;-[\n]&gt;+ }
    token propertylist {
        [
            | &lt;property&gt; \n
            | \n
        ]+
    }
    token property {
        &#39;|&#39; &lt;key=.key-content&gt; &#39;=&#39; &lt;value=.value-content-list&gt;
    }

    token key-content { &lt;-[=\n]&gt;+ }
    token value-content-list {
        &lt;value-content&gt;+
    }
    token value-content { # (#6)
        [
            | &lt;anchortext&gt;
            | &lt;weblink&gt;
            | &lt;rawtext&gt;
            | &lt;delimiter&gt;
        ]+
    }
    token anchortext { &#39;[[&#39; &lt;-[\n]&gt;+? &#39;]]&#39;        } # (#2)
    token weblink    { &#39;[&#39; &lt;-[\n]&gt;+? &#39;]&#39;          } # (#3)
    token rawtext    { &lt;-[\|\[\]\n、\,\&lt;\&gt;\}\{]&gt;+ } # (#4)
    token delimiter  { [ &#39;、&#39; | &#39;,&#39; ]             } # (#5)
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>问题 1 的答案:</p>
</li>
<li>
<p>使用 <code>.+</code> 来匹配多余的部分。(#1)</p>
</li>
<li>
<p>问题 2 的答案:</p>
</li>
<li>
<p>准备 3 种类型的 tokens: 锚文本(#2), 网站链接(#2), 和原始文本(#4)。</p>
</li>
<li>
<p>tokens 可能被分隔符（例如: <code>,</code>）分割, 所以准备分割符 token。(#5)</p>
</li>
<li>
<p>将 token 值-内容表示为四个 token 的任意长度序列（即，锚点文本，网站链接，原始文本，分隔符）。(#6)</p>
</li>
<li>
<p>问题 3 的答案:</p>
</li>
<li>
<p>没有特别的事情要提及。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_actions">12.2.4. Actions</h4>
<div class="paragraph">
<p>Actions 的代码如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Infobox::Actions {
    method TOP($/) { make $&lt;infobox&gt;.made }
    method infobox($/) {
        make %( name =&gt; $&lt;name&gt;.made, propertylist =&gt; $&lt;propertylist&gt;.made )
    }
    method name($/) { make ~$/.trim }
    method propertylist($/) {
        make $&lt;property&gt;&gt;&gt;.made
    }
    method property($/) {
        make $&lt;key&gt;.made =&gt; $&lt;value&gt;.made
    }
    method key-content($/) { make $/.trim }
    method value-content-list($/) {
        make $&lt;value-content&gt;&gt;&gt;.made
    }
    method value-content($/) { # (#1)
        my $rawtext = $&lt;rawtext&gt;&gt;&gt;.made&gt;&gt;.trim.grep({ $_ ne &#34;&#34; });

        make %(
            anchortext =&gt; $&lt;anchortext&gt;&gt;&gt;.made,
            weblink =&gt; $&lt;weblink&gt;&gt;&gt;.made,
            rawtext =&gt; $rawtext.elems == 0 ?? $[] !! $rawtext.Array
        );
    }
    method anchortext($/) {
        make ~$/;
    }
    method weblink($/) {
        make ~$/;
    }
    method rawtext($/) {
        make ~$/;
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>问题 2 的解决方法:</p>
</li>
<li>
<p>使 token value-content 由三个键组成：anchortext，weblink 和 rawtext。</p>
</li>
<li>
<p>问题 1 和 3的解决方法:</p>
</li>
<li>
<p>没有特别的事情要提及。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_caller">12.2.5. Caller</h4>
<div class="paragraph">
<p>Caller 部分的代码如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @lines = $*IN.lines;
while @lines {
    my $chunk = @lines.join(&#34;\n&#34;); # (#1)
    my $result = Infobox::Grammar.parse($chunk, actions =&gt; Infobox::Actions).made; # (#2)
    if $result&lt;name&gt;:exists {
        $result&lt;name&gt;.say;
        for @($result&lt;propertylist&gt;) -&gt; (:$key, :value($content-list)) { # (#3)
            $key.say;
            for @($content-list) -&gt; $content {
                $content.say;
            }
        }
    }
    shift @lines;
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>问题 3 的解决方法:</p>
</li>
<li>
<p>逐行阅读文章并制作一个包含当前行和最后一行之间的行的块。 （＃1）</p>
</li>
<li>
<p>如果解析器确定：</p>
</li>
<li>
<p>该块不包含信息框，它返回一个未定义的值。接收未定义值的好方法之一是使用 <code>$</code> 符号。(#2)</p>
</li>
<li>
<p>该块包含信息框，它返回一个定义的值。使用 <code>@()</code> contextualizer 并迭代结果。(#3)</p>
</li>
<li>
<p>问题 1 和 2 的解决方法：</p>
</li>
<li>
<p>没有特别的事情要提及。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_运行解析器">12.2.6. 运行解析器</h4>
<div class="paragraph">
<p>你准备好了吗？
是时候运行第一个例子了！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku parser.p6 &lt; raku.txt
プログラミング言語
名前
{anchortext =&gt; [], rawtext =&gt; [Raku], weblink =&gt; []}
ロゴ
{anchortext =&gt; [[[Image:Camelia.svg|250px]]], rawtext =&gt; [], weblink =&gt; []}
パラダイム
{anchortext =&gt; [[[マルチパラダイムプログラミング言語|マルチパラダイム]]], rawtext =&gt; [], weblink =&gt; []}
登場時期
{anchortext =&gt; [[[2015年]]], rawtext =&gt; [12月25日], weblink =&gt; []}
設計者
{anchortext =&gt; [[[ラリー・ウォール]]], rawtext =&gt; [], weblink =&gt; []}
最新リリース
{anchortext =&gt; [], rawtext =&gt; [Rakudo Star 2016.04], weblink =&gt; []}
型付け
{anchortext =&gt; [[[動的型付け]] [[静的型付け]]], rawtext =&gt; [], weblink =&gt; []}
処理系
{anchortext =&gt; [[[Rakudo]]], rawtext =&gt; [], weblink =&gt; []}
影響を受けた言語
{anchortext =&gt; [[[Perl|Perl 5]] [[Smalltalk]] [[Haskell]] [[Ruby]]], rawtext =&gt; [], weblink =&gt; []}
ライセンス
{anchortext =&gt; [[[Artistic License 2]]], rawtext =&gt; [], weblink =&gt; []}
ウェブサイト
{anchortext =&gt; [], rawtext =&gt; [], weblink =&gt; [[https://raku.org/ Raku.org]]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们看到的例子可能对您来说太简单了。让我们挑战更难的！</p>
</div>
</div>
<div class="sect3">
<h4 id="_第二个例子_阿尔伯特爱因斯坦">12.2.7. 第二个例子: 阿尔伯特爱因斯坦</h4>
<div class="paragraph">
<p>作为第二个例子，我们来解析<a href="https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%AB%E3%83%99%E3%83%AB%E3%83%88%E3%83%BB%E3%82%A2%E3%82%A4%E3%83%B3%E3%82%B7%E3%83%A5%E3%82%BF%E3%82%A4%E3%83%B3">阿尔伯特爱因斯坦</a>的信息框。</p>
</div>
<div class="paragraph">
<p>用 wiki 标记写的文章的代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">{{Infobox Scientist
|name = アルベルト・アインシュタイン
|image = Einstein1921 by F Schmutzer 2.jpg
|caption = [[1921年]]、[[ウィーン]]での[[講義]]中
|birth_date = {{生年月日と年齢|1879|3|14|no}}
|birth_place = {{DEU1871}}&lt;br&gt;[[ヴュルテンベルク王国]][[ウルム]]
|death_date = {{死亡年月日と没年齢|1879|3|14|1955|4|18}}
|death_place = {{USA1912}}&lt;br /&gt;[[ニュージャージー州]][[プリンストン (ニュージャージー州)|プリンストン]]
|residence = {{DEU}}&lt;br /&gt;{{ITA}}&lt;br&gt;{{CHE}}&lt;br /&gt;{{AUT}}(現在の[[チェコ]])&lt;br /&gt;{{BEL}}&lt;br /&gt;{{USA}}
|nationality = {{DEU1871}}、ヴュルテンベルク王国（1879-96）&lt;br /&gt;[[無国籍]]（1896-1901）&lt;br /&gt;{{CHE}}（1901-55）&lt;br /&gt;{{AUT1867}}（1911-12）&lt;br /&gt;{{DEU1871}}、{{DEU1919}}（1914-33）&lt;br /&gt;{{USA1912}}（1940-55）
| spouse      = [[ミレヴァ・マリッチ]]&amp;nbsp;(1903-1919)&lt;br /&gt;{{nowrap|{{仮リンク|エルザ・アインシュタイン|en|Elsa Einstein|label=エルザ・レーベンタール}}&amp;nbsp;(1919-1936)}}
| children    = [[リーゼル・アインシュタイン|リーゼル]] (1902-1903?)&lt;br /&gt;[[ハンス・アルベルト・アインシュタイン|ハンス
・アルベルト]] (1904-1973)&lt;br /&gt;[[エドゥアルト・アインシュタイン|エドゥアルト]] (1910-1965)
|field = [[物理学]]&lt;br /&gt;[[哲学]]
|work_institution = {{Plainlist|
* [[スイス特許庁]] ([[ベルン]]) (1902-1909)
* {{仮リンク|ベルン大学|en|University of Bern}} (1908-1909)
* [[チューリッヒ大学]] (1909-1911)
* [[プラハ・カレル大学]] (1911-1912)
* [[チューリッヒ工科大学]] (1912-1914)
* [[プロイセン科学アカデミー]] (1914-1933)
* [[フンボルト大学ベルリン]] (1914-1917)
* {{仮リンク|カイザー・ヴィルヘルム協会|en|Kaiser Wilhelm Society|label=カイザー・ヴィルヘルム研究所}} (化学・物理学研究所長, 1917-1933)
* [[ドイツ物理学会]] (会長, 1916-1918)
* [[ライデン大学]] (客員, 1920-)
* [[プリンストン高等研究所]] (1933-1955)
* [[カリフォルニア工科大学]] (客員, 1931-33)
}}
|alma_mater = [[チューリッヒ工科大学]]&lt;br /&gt;[[チューリッヒ大学]]
|doctoral_advisor = {{仮リンク|アルフレート・クライナー|en|Alfred Kleiner}}
|academic_advisors = {{仮リンク|ハインリヒ・フリードリヒ・ウェーバー|en|Heinrich Friedrich Weber}}
|doctoral_students =
|known_for = {{Plainlist|
*[[一般相対性理論]]
*[[特殊相対性理論]]
*[[光電効果]]
*[[ブラウン運動]]
*link:E=mc&lt;sup&gt;2&lt;/sup&gt;[[E=mc2|質量とエネルギーの等価性]]
*[[アインシュタイン方程式]]
*[[ボース分布関数]]
*[[宇宙定数]]
*[[ボース＝アインシュタイン凝縮]]
*[[EPRパラドックス]]
*{{仮リンク|古典統一場論|en|Classical unified field theories}}
}}
| influenced  = {{Plainlist|
* {{仮リンク|エルンスト・G・シュトラウス|en|Ernst G. Straus}}
* [[ネイサン・ローゼン]]
* [[レオ・シラード]]
}}
|prizes = {{Plainlist|
*{{仮リンク|バーナード・メダル|en|Barnard Medal for Meritorious Service to Science}}(1920)
*link:1921[[ノーベル物理学賞]]
*link:1921[[マテウチ・メダル]]
*link:1925[[コプリ・メダル]]
*link:1926[[王立天文学会ゴールドメダル]]
*link:1929[[マックス・プランク・メダル]]
}}
|religion =
|signature = Albert Einstein signature 1934.svg
|footnotes =
}}
{{thumbnail:begin}}
{{thumbnail:ノーベル賞受賞者|1921年|ノーベル物理学賞|光電効果の法則の発見等}}
{{thumbnail:end}}
&#39;&#39;&#39;アルベルト・アインシュタイン&#39;&#39;&#39;&lt;ref group=&#34;†&#34;&gt;[[日本語]]における表記には、他に「アル{{Underline|バー}}ト・アインシュine|バー}}ト・アイン{{Underline|ス}}タイン」（[[英語]]の発音由来）がある。&lt;/ref&gt;（{{lang-de-short|Albert Einstein}}&lt;ref ɛrt ˈaɪnˌʃtaɪn}} &#39;&#39;&#39;ア&#39;&#39;&#39;ルベルト・&#39;&#39;&#39;ア&#39;&#39;&#39;インシュタイン、&#39;&#39;&#39;ア&#39;&#39;&#39;ルバート・&#39;&#39;&#39;ア&#39;&#39;&#39;インシュタイン&lt;/ref&gt;&lt;ref group=&#34;†&#34;taɪn}} &#39;&#39;&#39;ア&#39;&#39;&#39;ルバ（ー）ト・&#39;&#39;&#39;ア&#39;&#39;&#39;インスタイン、&#39;&#39;&#39;ア&#39;&#39;&#39;ルバ（ー）&#39;&#39;&#39;タ&#39;&#39;&#39;インスタイン&lt;/ref&gt;&lt;ref&gt;[http://dictionary.rein Einstein] (Dictionary.com)&lt;/ref&gt;&lt;ref&gt;[http://www.oxfordlearnersdictionaries.com/definition/english/albert-einstein?q=Albert+Einstein Albert Einstein] (Oxford Learner&#39;s Dictionaries)&lt;/ref&gt;、[[1879年]][[3月14日]] - [[1955年]][[4月18日]]）ツ]]生まれの[[理論物理学者]]である。</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你所看到的，这里有五个新问题：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>一些模板</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>包含换行符;并且</p>
</li>
<li>
<p>是嵌套的(例如. <code>{{nowrap|{{仮リンク|…​}}…​}}</code>)</p>
</li>
</ol>
</div>
</li>
<li>
<p>某些 attribute-value 对是空的。</p>
</li>
<li>
<p>attribute-value 对的一些 value-sides</p>
<div class="olist loweralpha">
<ol class="loweralpha">
<li>
<p>包含中断标签;并且</p>
</li>
<li>
<p>由不同类型的 token 组成（例如，anchortext 和 rawtext）。所以你需要添加位置信息来表示 tokens 之间的依赖关系。</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>我将按照 Grammar，Actions 的顺序展示如何解决上述问题。</p>
</div>
<div class="paragraph">
<p>Caller 的代码与前一个相同。</p>
</div>
</div>
<div class="sect3">
<h4 id="_grammar_2">12.2.8. Grammar</h4>
<div class="paragraph">
<p>Grammar 代码如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Infobox::Grammar {
    token TOP { &lt;infobox&gt; .+ }
    token infobox { &#39;{{Infobox&#39; &lt;.ws&gt; &lt;name&gt; \n &lt;propertylist&gt; &#39;}}&#39; }
    token name { &lt;-[\n]&gt;+ }
    token propertylist {
        [
            | &lt;property&gt; \n
            | \n
        ]+
    }
    token property {
        [
            | &#39;|&#39; &lt;key=.key-content&gt; &#39;=&#39; &lt;value=.value-content-list&gt;
            | &#39;|&#39; &lt;key=.key-content&gt; &#39;=&#39; # (#4)
        ]
    }

    token key-content { &lt;-[=\n]&gt;+ }
    token value-content-list {
        [
            | &lt;value-content&gt; &lt;br&gt; # (#6)
            | &lt;value-content&gt;
            | &lt;br&gt;
        ]+
    }
    token value-content-list-nl { # (#1)
        [
            | &lt;value-content&gt; &lt;br&gt; # (#7)
            | &lt;value-content&gt;
            | &lt;br&gt;
        ]+ % \n
    }
    token value-content {
        [
            | &lt;anchortext&gt;
            | &lt;weblink&gt;
            | &lt;rawtext&gt;
            | &lt;template&gt;
            | &lt;delimiter&gt;
            | &lt;sup&gt;
        ]+
    }
    token br { # (#5)
        [
            | &#39;&lt;br /&gt;&#39;
            | &#39;&lt;br/&gt;&#39;
            | &#39;&lt;br&gt;&#39;
        ]
    }
    token template {
        [
            | &#39;{{&#39; &lt;-[\n]&gt;+? &#39;}}&#39;
            | &#39;{{nowrap&#39; &#39;|&#39; &lt;value-content-list&gt; &#39;}}&#39; # (#3)
            | &#39;{{Plainlist&#39; &#39;|&#39; \n &lt;value-content-list-nl&gt; \n &#39;}}&#39; # (#2)
        ]
    }
    token anchortext { &#39;[[&#39; &lt;-[\n]&gt;+? &#39;]]&#39; }
    token weblink { &#39;[&#39; &lt;-[\n]&gt;+? &#39;]&#39; }
    token rawtext { &lt;-[\|\[\]\n、\,\&lt;\&gt;\}\{]&gt;+ }
    token delimiter { [ &#39;、&#39; | &#39;,&#39; | &#39;&amp;nbsp;&#39; ] }
    token sup { &#39;&lt;sup&gt;&#39; &lt;-[\n]&gt;+? &#39;&lt;/sup&gt;&#39;}
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>问题 1.1 的解决方法：</p>
</li>
<li>
<p>创建 token <strong>value-content-list-nl</strong>，它是 value-content-list token 的换行符分隔版本。使用<a href="https://docs.raku.org/language/regexes#Modified_quantifier:_%,_%%">修改量词</a> <code>％</code> 来表示这种序列是很有用的。 （＃1）</p>
</li>
<li>
<p>创建 token 模板。在这一个中，定义一个代表 <a href="https://en.wikipedia.org/wiki/Template:Plainlist">Plainlist 模板</a> 的序列。 （＃2）</p>
</li>
<li>
<p>问题 1.2 的解决方法：</p>
</li>
<li>
<p>使 token 模板能够调用 token value-content-list。此修改触发递归调用并捕获嵌套结构，因为 token value-content-list 包含 token 模板。 （＃3）</p>
</li>
<li>
<p>问题 2 的解决方法：</p>
</li>
<li>
<p>在 token <strong>property</strong> 中，定义一个 value-side 为空的序列（即以&#39;=&#39;结尾的序列）。 （＃4）</p>
</li>
<li>
<p>问题 3.1 的解决方法:</p>
</li>
<li>
<p>创建 token br（＃5）
 - 让 token br 遵循两个 token 中的 token value-content：</p>
</li>
<li>
<p>token value-content-list （＃6）</p>
</li>
<li>
<p>token-content-list-nl（＃7）</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_actions_2">12.2.9. Actions</h4>
<div class="paragraph">
<p>Action 代码如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Infobox::Actions {
    method TOP($/) { make $&lt;infobox&gt;.made }
    method infobox($/) {
        make %( name =&gt; $&lt;name&gt;.made, propertylist =&gt; $&lt;propertylist&gt;.made )
    }
    method name($/) { make $/.trim }
    method propertylist($/) {
        make $&lt;property&gt;&gt;&gt;.made
    }
    method property($/) {
        make $&lt;key&gt;.made =&gt; $&lt;value&gt;.made
    }
    method key-content($/) { make $/.trim }
    method value-content-list($/) {
        make $&lt;value-content&gt;&gt;&gt;.made
    }
    method value-content($/) {
        my $rawtext = $&lt;rawtext&gt;&gt;&gt;.made&gt;&gt;.trim.grep({ $_ ne &#34;&#34; });

        make %(
            anchortext =&gt; $&lt;anchortext&gt;&gt;&gt;.made,
            weblink =&gt; $&lt;weblink&gt;&gt;&gt;.made,
            rawtext =&gt; $rawtext.elems == 0 ?? $[] !! $rawtext.Array,
            template =&gt; $&lt;template&gt;&gt;&gt;.made;
        );
    }
    method template($/) {
        make %(body =&gt; ~$/, from =&gt; $/.from, to =&gt; $/.to); # (#1)
    }
    method anchortext($/) {
        make %(body =&gt; ~$/, from =&gt; $/.from, to =&gt; $/.to); # (#2)
    }
    method weblink($/) {
        make %(body =&gt; ~$/, from =&gt; $/.from, to =&gt; $/.to); # (#3)
    }
    method rawtext($/) {
        make %(body =&gt; ~$/, from =&gt; $/.from, to =&gt; $/.to); # (#4)
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>问题 3.2 的解决方法：</p>
</li>
<li>
<p>调用 make 时，分别使用 Match.from 和 Match.to 来获取匹配开始位置和匹配结束位置。 （＃1〜＃4）</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_运行解析器_2">12.2.10. 运行解析器</h4>
<div class="paragraph">
<p>该跑了！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ raku parser.p6 &lt; einstein.txt
Scientist
name
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; アルベルト・アインシュタイン, from =&gt; 27, to =&gt; 42}], template =&gt; [], weblink =&gt; []}
image
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; Einstein1921 by F Schmutzer 2.jpg, from =&gt; 51, to =&gt; 85}], template =&gt; [], weblink =&gt; []}
caption
{anchortext =&gt; [{body =&gt; [[1921年]], from =&gt; 97, to =&gt; 106} {body =&gt; [[ウィーン]], from =&gt; 107, to =&gt; 115} {body =&gt; [[講義]], from =&gt; 117, to =&gt; 123}], rawtext =&gt; [{body =&gt; , from =&gt; 96, to =&gt; 97} {body =&gt; での, from =&gt; 115, to =&gt; 117} {body =&gt; 中, from =&gt; 123, to =&gt; 124}], template =&gt; [], weblink =&gt; []}
birth_date
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 138, to =&gt; 139}], template =&gt; [{body =&gt; {{生年月日と年齢|1879|3|14|no}}, from =&gt; 139, to =&gt; 163}], weblink =&gt; []}
birth_place
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 178, to =&gt; 179}], template =&gt; [{body =&gt; {{DEU1871}}, from =&gt; 179, to =&gt; 190}], weblink =&gt; []}
{anchortext =&gt; [{body =&gt; [[ヴュルテンベルク王国]], from =&gt; 194, to =&gt; 208} {body =&gt; [[ウルム]], from =&gt; 208, to =&gt; 215}], rawtext =&gt; [], template =&gt; [], weblink =&gt; []}
death_date
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 229, to =&gt; 230}], template =&gt; [{body =&gt; {{死亡年月日と没年齢|1879|3|14|1955|4|18}}, from =&gt; 230, to =&gt; 263}], weblink =&gt; []}
death_place
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 278, to =&gt; 279}], template =&gt; [{body =&gt; {{USA1912}}, from =&gt; 279, to =&gt; 290}], weblink =&gt; []}
{anchortext =&gt; [{body =&gt; [[ニュージャージー州]], from =&gt; 296, to =&gt; 309} {body =&gt; [[プリンストン (ニュージャージー州)|プリンストン]], from =&gt; 309, to =&gt; 338}], rawtext =&gt; [], template =&gt; [], weblink =&gt; []}
residence
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 351, to =&gt; 352}], template =&gt; [{body =&gt; {{DEU}}, from =&gt; 352, to =&gt; 359}], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [], template =&gt; [{body =&gt; {{ITA}}, from =&gt; 365, to =&gt; 372}], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [], template =&gt; [{body =&gt; {{CHE}}, from =&gt; 376, to =&gt; 383}], weblink =&gt; []}
{anchortext =&gt; [{body =&gt; [[チェコ]], from =&gt; 400, to =&gt; 407}], rawtext =&gt; [{body =&gt; (現在の, from =&gt; 396, to =&gt; 400} {body =&gt; ), from =&gt; 407, to =&gt; 408}], template =&gt; [{body =&gt; {{AUT}}, from =&gt; 389, to =&gt; 396}], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [], template =&gt; [{body =&gt; {{BEL}}, from =&gt; 414, to =&gt; 421}], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [], template =&gt; [{body =&gt; {{USA}}, from =&gt; 427, to =&gt; 434}], weblink =&gt; []}
nationality
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 449, to =&gt; 450} {body =&gt; ヴュルテンベルク王国（1879-96）, from =&gt; 462, to =&gt; 481}], template =&gt; [{body =&gt; {{DEU1871}}, from =&gt; 450, to =&gt; 461}], weblink =&gt; []}
{anchortext =&gt; [{body =&gt; [[無国籍]], from =&gt; 487, to =&gt; 494}], rawtext =&gt; [{body =&gt; （1896-1901）, from =&gt; 494, to =&gt; 505}], template =&gt; [], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; （1901-55）, from =&gt; 518, to =&gt; 527}], template =&gt; [{body =&gt; {{CHE}}, from =&gt; 511, to =&gt; 518}], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; （1911-12）, from =&gt; 544, to =&gt; 553}], template =&gt; [{body =&gt; {{AUT1867}}, from =&gt; 533, to =&gt; 544}], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; （1914-33）, from =&gt; 582, to =&gt; 591}], template =&gt; [{body =&gt; {{DEU1871}}, from =&gt; 559, to =&gt; 570} {body =&gt; {{DEU1919}}, from =&gt; 571, to =&gt; 582}], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; （1940-55）, from =&gt; 608, to =&gt; 617}], template =&gt; [{body =&gt; {{USA1912}}, from =&gt; 597, to =&gt; 608}], weblink =&gt; []}
spouse
{anchortext =&gt; [{body =&gt; [[ミレヴァ・マリッチ]], from =&gt; 634, to =&gt; 647}], rawtext =&gt; [{body =&gt; , from =&gt; 633, to =&gt; 634} {body =&gt; (1903-1919), from =&gt; 653, to =&gt; 664}], template =&gt; [], weblink =&gt; []}
{anchortext =&gt; [], rawtext =&gt; [], template =&gt; [{body =&gt; {{nowrap|{{仮リンク|エルザ・アインシュタイン|en|Elsa Einstein|label=エルザ・レーベンタール}}&amp;nbsp;(1919-1936)}}, from =&gt; 670, to =&gt; 754}], weblink =&gt; []}
children
{anchortext =&gt; [{body =&gt; [[リーゼル・アインシュタイン|リーゼル]], from =&gt; 771, to =&gt; 793}], rawtext =&gt; [{body =&gt; , from =&gt; 770, to =&gt; 771} {body =&gt; (1902-1903?), from =&gt; 793, to =&gt; 806}], template =&gt; [], weblink =&gt; []}
{anchortext =&gt; [{body =&gt; [[ハンス・アルベルト・アインシュタイン|ハンス・アルベルト]], from =&gt; 812, to =&gt; 844}], rawtext =&gt; [{body =&gt; (1904-1973), from =&gt; 844, to =&gt; 856}], template =&gt; [], weblink =&gt; []}
{anchortext =&gt; [{body =&gt; [[エドゥアルト・アインシュタイン|エドゥアルト]], from =&gt; 862, to =&gt; 888}], rawtext =&gt; [{body =&gt; (1910-1965), from =&gt; 888, to =&gt; 900}], template =&gt; [], weblink =&gt; []}
field
{anchortext =&gt; [{body =&gt; [[物理学]], from =&gt; 910, to =&gt; 917}], rawtext =&gt; [{body =&gt; , from =&gt; 909, to =&gt; 910}], template =&gt; [], weblink =&gt; []}
{anchortext =&gt; [{body =&gt; [[哲学]], from =&gt; 923, to =&gt; 929}], rawtext =&gt; [], template =&gt; [], weblink =&gt; []}
work_institution
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 949, to =&gt; 950}], template =&gt; [{body =&gt; {{Plainlist|
* [[スイス特許庁]] ([[ベルン]]) (1902-1909)
* {{仮リンク|ベルン大学|en|University of Bern}} (1908-1909)
* [[チューリッヒ大学]] (1909-1911)
* [[プラハ・カレル大学]] (1911-1912)
* [[チューリッヒ工科大学]] (1912-1914)
* [[プロイセン科学アカデミー]] (1914-1933)
* [[フンボルト大学ベルリン]] (1914-1917)
* {{仮リンク|カイザー・ヴィルヘルム協会|en|Kaiser Wilhelm Society|label=カイザー・ヴィルヘルム研究所}} (化学・物理学研究所長, 1917-1933)
* [[ドイツ物理学会]] (会長, 1916-1918)
* [[ライデン大学]] (客員, 1920-)
* [[プリンストン高等研究所]] (1933-1955)
* [[カリフォルニア工科大学]] (客員, 1931-33)
}}, from =&gt; 950, to =&gt; 1409}], weblink =&gt; []}
alma_mater
{anchortext =&gt; [{body =&gt; [[チューリッヒ工科大学]], from =&gt; 1424, to =&gt; 1438}], rawtext =&gt; [{body =&gt; , from =&gt; 1423, to =&gt; 1424}], template =&gt; [], weblink =&gt; []}
{anchortext =&gt; [{body =&gt; [[チューリッヒ大学]], from =&gt; 1444, to =&gt; 1456}], rawtext =&gt; [], template =&gt; [], weblink =&gt; []}
doctoral_advisor
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 1476, to =&gt; 1477}], template =&gt; [{body =&gt; {{仮リンク|アルフレート・ク
ライナー|en|Alfred Kleiner}}, from =&gt; 1477, to =&gt; 1516}], weblink =&gt; []}
academic_advisors
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 1537, to =&gt; 1538}], template =&gt; [{body =&gt; {{仮リンク|ハインリヒ・フリ
ードリヒ・ウェーバー|en|Heinrich Friedrich Weber}}, from =&gt; 1538, to =&gt; 1593}], weblink =&gt; []}
doctoral_students
Nil
known_for
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 1627, to =&gt; 1628}], template =&gt; [{body =&gt; {{Plainlist|
*[[一般相対性理論]]
*[[特殊相対性理論]]
*[[光電効果]]
*[[ブラウン運動]]
*link:E=mc&lt;sup&gt;2&lt;/sup&gt;[[E=mc2|質量とエネルギーの等価性]]
*[[アインシュタイン方程式]]
*[[ボース分布関数]]
*[[宇宙定数]]
*[[ボース＝アインシュタイン凝縮]]
*[[EPRパラドックス]]
*{{仮リンク|古典統一場論|en|Classical unified field theories}}
}}, from =&gt; 1628, to =&gt; 1861}], weblink =&gt; []}
influenced
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 1877, to =&gt; 1878}], template =&gt; [{body =&gt; {{Plainlist|
* {{仮リンク|エルンスト・G・シュトラウス|en|Ernst G. Straus}}
* [[ネイサン・ローゼン]]
* [[レオ・シラード]]
}}, from =&gt; 1878, to =&gt; 1968}], weblink =&gt; []}
prizes
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; , from =&gt; 1978, to =&gt; 1979}], template =&gt; [{body =&gt; {{Plainlist|
*{{仮リンク|バーナード・メダル|en|Barnard Medal for Meritorious Service to Science}}(1920)
*link:1921[[ノーベル物理学賞]]
*link:1921[[マテウチ・メダル]]
*link:1925[[コプリ・メダル]]
*link:1926[[王立天文学会ゴールドメダル]]
*link:1929[[マックス・プランク・メダル]]
}}, from =&gt; 1979, to =&gt; 2181}], weblink =&gt; []}
religion
Nil
signature
{anchortext =&gt; [], rawtext =&gt; [{body =&gt; Albert Einstein signature 1934.svg, from =&gt; 2206, to =&gt; 2241}], template =&gt; [], weblink =&gt; []}
footnotes
Nil</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_结论_4">12.2.11. 结论</h4>
<div class="paragraph">
<p>我演示了信息框的解析技术。如果您有机会将 Wikipedia 用作 NLP 的资源，我强烈建议您创建自己的解析器。它不仅会加深你对 Raku 的理解而且还会加深关于维基百科知识的理解。</p>
</div>
<div class="paragraph">
<p>再见！</p>
</div>
</div>
<div class="sect3">
<h4 id="_引文">12.2.12. 引文</h4>
<div class="paragraph">
<p>[0] Lehmann，Jens 等人。 “DBpedia—​一种从维基百科中提取的大型多语言知识库。”Semantic Web 6.2（2015）：167-195。</p>
</div>
<div class="paragraph">
<p>[1]阿里，Esraa，Annalina Caputo 和 SéamusLawless。 “使用学习排序的实体属性排名”。</p>
</div>
<div class="paragraph">
<p>[2]莫拉莱斯，阿尔瓦罗等人。 “学会回答维基百科信息框的问题。”2016年自然语言处理实证方法会议论文集。 2016年</p>
</div>
</div>
<div class="sect3">
<h4 id="_license">12.2.13. License</h4>
<div class="paragraph">
<p>所有来自维基百科的资料都是根据Creative Commons Attribution-ShareAlike 3.0 Unported License 授权使用的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Itsuki丰田，日本的网页开发人员。
== <a href="https://rakuadvent.wordpress.com/2017/12/14/day-14-the-little-match-girl-building-and-testing-big-grammars-in-perl-6/">第十四天-在 Raku 中构建和测试 Big Grammars</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Raku Grammars 很棒，但在项目中使用它们会是什么样呢？在圣诞节前和圣诞节后，我的经历是一个令人心酸的故事。你可以在<a href="https://github.com/albastev/Grammar-Modelica/tree/parse_modelica_library">这里</a>找到版本库。我不是来自计算机科学背景，所以也许它看起来很简陋，但是当我学习 Raku Grammars 时，这是我的困难和胜利。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_第一根火柴">12.3. 第一根火柴</h3>
<div class="paragraph">
<p>就像卖火柴的小女孩一样，我们的故事发生在圣诞节前。卖火柴的小女孩的任务是在圣诞节前夕销售一捆火柴棍（实际上是新年，我确实回去读了那个故事。圣诞节更适合 Raku），而我的任务是从 Modelica 模型中提取注释渲染为矢量图形。现在，Modelica 是一个非常棒的面向对象的建模语言，除了提及其附录中包含一个具体语法部分的非常好的<a href="https://www.modelica.org/documents/ModelicaSpec34.pdf">规范文档</a>（pdf）之外，我将完全理解它。仔细阅读本节，我意识到“语法元符号”和“词法单位”看起来像我最近读过的一篇博客文章中的 Raku Grammars，并且急于尝试。</p>
</div>
<div class="paragraph">
<p>来自 Modelica 的示例具体语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">class-definition :
[ encapsulated ] class-prefixes
class-specifier</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku <strong>rule</strong> 的示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule class_definition {
  [&lt;|w&gt;&#39;encapsulated&#39;&lt;|w&gt;]?
  &lt;class_prefixes&gt;
  &lt;class_specifier&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就像卖火柴的小女孩划第一颗火柴一样，第一次看到了一个超越她现实的奇妙世界。一个温暖的小炉子。然后它熄灭了。</p>
</div>
<div class="paragraph">
<p>它非常接近，我把它放到了一个文本编辑器中，并且用一些 Raku 的东西替换了不是 Raku 的部分，以查看它是否会运行。它没有运行。我砍掉了它，我指出了不同的位来解决更小的块。无处不在的空白符号，正则表达式，标记，规则。我能够解析某些部分，其他部分神秘地没有起效。回顾过去，这一定很糟糕。与此同时，我们一起破解传统的正则表达式来提取注释，并将我的 Grammar 放在架子上。</p>
</div>
</div>
<div class="sect2">
<h3 id="_第二根火柴">12.4. 第二根火柴</h3>
<div class="paragraph">
<p>不久之后，发布了 Grammar::Profiler 和 Grammar::Debugger，并且我受到启发，决定再试一试。我被授予了对我的规则出乎意料表现的很好的见解。我能够比以前更深入地理解 grammar。第二支火柴一直亮着，我有一场盛宴。然后它熄灭了。</p>
</div>
<div class="paragraph">
<p>在调试器中，我陷入了回溯的深渊。分析器一直运行，因为它一次又一次地陷入泥潭。我能够走得更远，但最终遇到了一堵墙。成功似乎非常接近，但我自己的经历中有太多缺失的部分，并且有文档让我度过难关。</p>
</div>
</div>
<div class="sect2">
<h3 id="_第三根火柴">12.5. 第三根火柴</h3>
<div class="paragraph">
<p>时间流逝，圣诞节来了。我有了新的职位，有时间做个人项目。我有不断改进的 <a href="https://docs.raku.org/language/grammars">Grammar 文档</a>来指导我。我已经阅读了使用遗留代码高效工作的书。这足以让我再次迎难而上。</p>
</div>
</div>
<div class="sect2">
<h3 id="_面向对象">12.6. 面向对象</h3>
<div class="paragraph">
<p>这对我来说是最大的突破。当我从文档中了解到 Tokens，rules 和  regex 都是有趣的外观方法时，我突然发现了所有的东西。当我回到家时，我立即检查我是否可以重写 TOP，并检查是否可以将 Grammar 方法变为 role。两人都很愉快地工作，而且我在做生意。我可以把它分成块，而不是一个单一的，全有或全无的 grammar。这极大地改进了代码的组织和可测试性。</p>
</div>
<div class="paragraph">
<p>其中一个特别突出的问题是，我能够将 Grammar 整齐地分解成与 Modelica 规范中相应的角色。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">lib
----Grammar
--------Modelica
------------LexicalConventions.pm6
------------ClassDefinition.pm6
------------Extends.pm6
------------ComponentClause.pm6
------------Modification.pm6
------------Equations.pm6
------------Expressions.pm6
--------Modelica.pm6</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Unit testing: one layer at a time</strong></p>
</div>
<div class="paragraph">
<p>面向对象开辟了一个明智的单元测试方案，并通过将Modelica的部分内容传递到语法中，使我摆脱了临时测试的无稽之谈。您可以像继承其他任何类一样继承和重写语法。这允许您分别测试每个规则或标记，将您的语法分割为一口大小的层。您只需使用要测试的规则或标记覆盖TOP，并使用占位符方法覆盖任何依赖关系。</p>
</div>
<div class="paragraph">
<p>Expressions.pm6中表达式的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule expression {
  [
  &lt;|w&gt;&#39;if&#39;&lt;|w&gt; &lt;expression&gt; &lt;|w&gt;&#39;then&#39;&lt;|w&gt; &lt;expression&gt; [
  &lt;|w&gt;&#39;elseif&#39;&lt;|w&gt; &lt;expression&gt; &lt;|w&gt;&#39;then&#39;&lt;|w&gt; &lt;expression&gt;
  ]*
  &lt;|w&gt;&#39;else&#39;&lt;|w&gt; &lt;expression&gt;
  ]
  ||
  &lt;simple_expression&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里我们看到表达式取决于它自己和simple_expression。为了测试，我们用一个占位符替换了通常的simple_expression规则。在这种情况下，它只是匹配字符串’simple_expression&#39;。</p>
</div>
<div class="paragraph">
<p>从Expressions.t覆盖测试语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar TestExpression is Grammar::Modelica {
    rule TOP {^ &lt;expression&gt; $}
    rule simple_expression { &#39;simple_expression&#39; }
}
ok TestExpression.parse(&#39;simple_expression&#39;);
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你可以分离代码中有问题的部分时，回归测试也会更加愉快，并创建一个专门针对它的重写语法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_w_is_your_friend">12.7. &lt;|w&gt; is your friend</h3>
<div class="paragraph">
<p>在我的第一次努力中，试图让Modelica保留字等正常工作的东西是我“存在的一些障碍”之一。在找到单词边界匹配标记&lt;| w&gt;后，这个改变了。当我在每边击打一个时，它可以工作，无论是在空白区还是标点符号旁边。</p>
</div>
<div class="paragraph">
<p>从ComponentClause.pm6：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule type_prefix {
  [&lt;|w&gt;[ &#39;flow&#39; || &#39;stream&#39; ]&lt;|w&gt;]?
  [&lt;|w&gt;[ &#39;discrete&#39; || &#39;parameter&#39; || &#39;constant&#39; ]&lt;|w&gt;]?
  [&lt;|w&gt;[ &#39;input&#39; || &#39;output&#39; ]&lt;|w&gt;]?
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_token_rule_and_regex">12.7.1. Token, rule and regex</h4>
<div class="paragraph">
<p>现在有很好的文档，但是我也会简要介绍一下我的经验。我发现规则和它的：sigspace魔术是大多数时候最好的选择。令牌在需要严格控制格式的情况下很有用。</p>
</div>
<div class="paragraph">
<p>正则表达式用于回溯。对于Modelica，我发现它是无益的，可能是因为它被设计成单通口语。令牌和规则在我认为我需要的地方工作。所有的单元测试都在我将它们删除后通过，并且语法成功了四个Modelica标准库文件。只有在需要时才使用它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_以开始结束">12.7.2. 以开始结束</h4>
<div class="paragraph">
<p>另一个让我感到沮丧的是类定义语法。 Modelica使用形式some_identifier …​结束some_identifier的类。如何确保在开始和结束时使用相同的标识符对我来说很麻烦。幸运的是，Raku允许您在语法方法中使用捕获。下面的（&lt;IDENT&gt;）捕获将填充$ 0，然后可以用它来确保我们的long_class_specifier以适当的标识符结束。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule long_class_specifier {
  [(&lt;IDENT&gt;) &lt;string_comment&gt; &lt;composition&gt; &lt;|w&gt;&#39;end&#39;&lt;|w&gt; $0 ]
  ||
  [&lt;|w&gt;&#39;extends&#39;&lt;|w&gt; (&lt;IDENT&gt;) &lt;class_modification&gt;? &lt;string_comment&gt; &lt;composition&gt; &lt;|w&gt;&#39;end&#39;&lt;|w&gt; $0 ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Integration Testing: lighting all the matches at once</strong></p>
</div>
<div class="paragraph">
<p>在我的单元测试全部过去后，我感到有点不安。当然，它可以解析我设计的测试案例，但它对真正的Modelica会如何呢？颤抖的手，我从他的Modelica电子书中提供了一些Michael Tiller的示例代码。有效！没有摆弄我忽略的微妙东西，没有有趣的解析错误或永恒的回溯。只是成功。</p>
</div>
<div class="paragraph">
<p>现在，星星偶尔会对齐。奇迹确实发生。充分巧妙的单元测试可以非常好地预防错误。我已经有足够的时间来验证了。回顾Damian Conway的演讲，我决定针对整个Modelica标准库运行它。并不是所有的CPAN，但305个文件都比我迄今尝试过的仅仅两个示例模型要好。</p>
</div>
<div class="paragraph">
<p>我编写了脚本，将它指向了Modelica目录，并将它解雇了。它通过图书馆搅动，喘息一下。 150次失败。现在这是熟悉的领域。经过几次迭代后，当我在parse_modelica_library分支上运行它时，我的性能下降到了66次。我只是通过一个失败的文件，找出有问题的代码，并为其编写回归测试。</p>
</div>
<div class="paragraph">
<p>所以，最后小火柴女郎点燃了她捆绑的其余部分。然后，她死了。不要死，但可以同时点亮所有305场比赛，例如/ parseThemAll.p6：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!raku

use v6;
use Test;
use lib &#39;../lib&#39;;
use Grammar::Modelica;


plan 305;

sub light($file) {
  my $fh = open $file, :r;
  my $contents = $fh.slurp-rest;
  $fh.close;

  my $match = Grammar::Modelica.parse($contents);
  say $file;
  ok $match;
}

sub MAIN($modelica-dir) {
    say &#34;directory: $modelica-dir&#34;;
    die &#34;Can&#39;t find directory&#34; if ! $modelica-dir.IO.d;

    # modified from the lovely docs at
    # https://docs.raku.org/routine/dir
    my @stack = $modelica-dir.IO;
    my @files;
    while @stack {
      for @stack.pop.dir -&gt; $path {
        light($path) if $path.f &amp;&amp; $path.extension.lc eq &#39;mo&#39;;
        @stack.push: $path if $path.d;
      }
    }
    # faster to do in parallel
    @files.race.map({light($_)});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我会看到在圣诞节前我能说服多少。那么也许我会弄清楚如何编写一些规则来构建QAST。</p>
</div>
<div class="paragraph">
<p>圣诞节快乐！</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十五天_带有_promise_的简单网络爬虫">13. <a href="https://rakuadvent.wordpress.com/2017/12/15/a-simple-web-spider-with-promises/">第十五天-带有 Promise 的简单网络爬虫</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>承诺，承诺
去年夏天，我申请了一项编程工作，面试官要求我编写一个程序来抓取给定的域，只在该域中的链接之后，找到它引用的所有页面。我被允许以任何语言编写程序，但我选择使用Go语言执行任务，因为这是该公司使用的主要语言。这对于并发编程来说是一个理想的任务，并且Go具有非常好的现代化功能，即使有些低级别的并发支持。网络蜘蛛中的主要工作是执行与在域中发现的唯一锚链接相同的次数，即在每个页面上执行HTTP GET并解析页面文本以获取新链接。这个任务可以并行安全地完成，因为没有可能（除非你做得很糟糕），任何调用爬取代码都会干扰其他任何调用。</p>
</div>
<div class="paragraph">
<p>Go和Raku的创造者受到安东尼霍尔爵士1978年的开创性工作“沟通顺序过程”的启发，但值得注意的是，Raku代码更加简洁，因此更容易隐藏到博客文章中。事实上，Go设计者总是将他们的结构称为“并发原语”。 Go为我的作业应用程序编写的并发spider代码大约有200行，而在Raku中大小不到这个大小的一半。</p>
</div>
<div class="paragraph">
<p>下面我们来看看如何在Raku中实现一个简单的Web爬虫。内置的Promise类允许您启动，调度和检查异步计算的结果。所有你需要做的就是给Promise.start方法一个代码引用，然后调用await方法，这会阻塞，直到promise完成执行。然后您可以测试结果方法以确定承诺是否已被保留或中断。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">您可以通过将其保存到本地文件中来运行本文中的代码，例如网络spider.p6。如果您希望抓取https网站，请使用zef安装HTML </dt>
<dd>
<p>Parser :: XML和HTTP :: UserAgent以及IO :: Socket :: SSL。我会提醒你，SSL支持目前看起来有点狼狈，所以最好坚持http站点。 Raku程序中的MAIN子程序存在时表示一个独立程序，这就是执行开始的地方。 MAIN的参数表示命令行参数。我编写了这个程序，以便默认情况下它会抓取Perlmonks站点，但是您可以覆盖它，如下所示：</p>
<div class="literalblock">
<div class="content">
<pre>$ raku web-spider.p6 [–domain=http://example.com]</pre>
</div>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>简单的Raku域蜘蛛</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use HTML::Parser::XML;
use XML::Document;
use HTTP::UserAgent;

sub MAIN(:$domain=&#34;http://www.perlmonks.org&#34;) {

    my $ua =  HTTP::UserAgent.new;
    my %url_seen;
    my @urls=($domain);

    loop {
        my @promises;
        while ( @urls ) {
            my $url = @urls.shift;
            my $p = Promise.start({crawl($ua, $domain, $url)});
            @promises.push($p);
        }
        await Promise.allof(@promises);
        for @promises.kv -&gt; $index, $p {
            if $p.status ~~ Kept {
                my @results =  $p.result;
                for @results {
                    unless %url_seen{$_} {
                        @urls.push($_);
                        %url_seen{$_}++;
                    }
                }
            }
        }
        # Terminate if no more URLs to crawl
        if @urls.elems == 0 {
            last;
        }
    }
    say %url_seen.keys;
}

# Get page and identify urls linked to in it. Return urls.
sub crawl($ua, $domain, $url) {
    my $page = $ua.get($url);
    my $p = HTML::Parser::XML.new;
    my XML::Document $doc = $p.parse($page.content);
    # URLs to crawl
    my %todo;
    my @anchors = $doc.elements(:TAG&lt;a&gt;, :RECURSE);
    for @anchors -&gt; $anchor {
        next unless $anchor.defined;
        my $href =  $anchor.attribs&lt;href&gt;;

        # Convert relative to absolute urls
        if $href.starts-with(&#39;/&#39;) or $href.starts-with(&#39;?&#39;) {
            $href = $domain ~ $href;
        }

        # Get unique urls from page
        if $href.starts-with($domain) {
              %todo{$href}++;
        }
    }
    my @urls = %todo.keys;

    return @urls;
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_结论是">13.1. 结论是</h3>
<div class="paragraph">
<p>并发编程总是会有很多陷阱，从竞争状态到资源匮乏和死锁，但我认为很显然，Raku 已经使得这种编程形式更容易被大家接受。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十六天_raku_性能改进">14. <a href="https://rakuadvent.wordpress.com/2017/12/16/day-16-%F0%9F%8E%B6-deck-the-halls-with-perf-improvements-%F0%9F%8E%B6/">第十六天-Raku 性能改进</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>在英国，我们缺乏感恩节给圣诞节带来了新的一年，感谢和反思。为此，我想围绕Raku性能的状态放置一些我已经坐了一段时间的零碎片断，这些片断强调了这个过程需要付出多少努力。我不确定更广泛的编程社区对正在发生的努力的速度和数量表示赞赏。</p>
</div>
<div class="paragraph">
<p>我不是核心开发人员，但自2010年推出Rakudo *之后，我一直是Raku的低级用户。通常情况下，已经进入Rakudo的努力被未知的努力所掩盖。人们重新审视Rakudo Raku时尤其如此，他可能会想象下一个圣诞节将会如何。但是Raku在历史上证明，在下一个圣诞节之前，事情总会有所改善，无论您选择哪个圣诞节，</p>
</div>
<div class="paragraph">
<p>回到2014年的圣诞节，我写了一篇关于为什么我认为Raku能够完成生物信息学工作的出色文章。那篇文章中没有提到的是，为什么在Rakudo上实现Raku根本没有准备好去做任何严肃的生物信息学。表演真的没有！我在Raku中的第一次尝试（当Parrot虚拟机完全使用时）让我执行了几十分钟的简单操作，我期望它是毫秒级的性能。这很遗憾，因为我没有跟踪时间。但这当然不是一个好起点。</p>
</div>
<div class="paragraph">
<p>然而，快速转发到2014年和MoarVM，我觉得自己写这篇来临邮件感觉很舒服，因为我知道在作为用户的4年中有多少改进。而且，所有的发展都是在完成语言定义和正确的实施。然而，我是一直在等待perf到达那里的用户。我认为大部分时间到了。为此，我要感谢所有核心开发者所付出的巨大的日常努力。观看它展现出令人难以置信的动力。对我来说，这个圣诞节是圣诞节的目标，它已经到来。 👏🏻🎊</p>
</div>
<div class="paragraph">
<p>我一直在为我的BioInfo模块运行和计时测试，这些模块对生物序列数据进行了多年的基本操作。它以非常糟糕的方式做到了这一点。在紧密循环中分配和丢弃哈希时出现了很多错误等等。但是我已经将这些代码留给了现在 - 在五年多的时间里。悄悄地进行私人基准测试，偶尔鼓励在IRC频道看到大幅飞跃的努力。 Sub 10s是一个很大的！它从30/40秒突然发生。在我暗示IRC一个地方，我的代码在分析时特别慢，这是一次跳跃！</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2017/12/bioinfo_runtime.png">img</a></p>
</div>
<div class="paragraph">
<p>这是一个长期观点，如果我放大去年的这一年，可以看到，如果时间不是很长，整个系数的性能仍然在提高。</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2017/12/bioinfo_runtime_2017.png">img</a></p>
</div>
<div class="paragraph">
<p>请记住，所有这些配置文件都不是来自Rakudo编译器的发布版本，而是来自当天的HEAD。所以偶尔会有一些奇怪的表现回归，正如你上面看到的，通常不会留下来发布。</p>
</div>
<div class="paragraph">
<p>发生什么了？情况如何变好？有几个原因。 Raku中的许多算法选择和核心功能都已经在源代码级别（更晚些时候）逐步和积极地进行了优化。但支持Rakudo的MoarVM虚拟机的优化能力也得到了提高，并且可以降低到原生代码和内联专用版本的代码。这部分得益于2014年以来Rakudo Raku提供的-profile选项，它提供了所有这些信息。</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2017/12/bioinfo_frame_optimisations.png">img</a></p>
</div>
<div class="paragraph">
<p>在上面关于MoarVM如何处理我编译过的Raku测试的代码框的情节中，应该很清楚的是，自从今年夏天以来，有相当多的框架被JIT编译，解释较少，并且几乎所有专用框架（橙色）结束原生JIT（绿色）。如果您想了解更多有关“spesh”MoarVM代码专门工具的最新工作，您可以在他的博客上阅读Jonathan Worthington的4篇文章。 Baart Weigmans还有一篇博客概述了他在JIT编译器方面的工作，最近还谈到了许多尚未登陆的新功能，希望能让许多新开发人员加入并帮助改进JIT。所以如果这对你来说是一件有趣的事情，我建议你查看一下上面的链接。</p>
</div>
<div class="paragraph">
<p>所以这是我的基准和我的目标，其中大部分是围绕数据结构创建和解析。但是，数字作品等其他内容呢？那也保持了吗？没有任何人推动，就像我推动我对事情可以改进的地方的看法。答案是肯定的！</p>
</div>
<div class="paragraph">
<p>曾几何时，早在2013年，一位名叫Tim King的绅士就开始对Raku中的素数感兴趣.Tim对他发现的性能颇为不满。正确如此。他从以下漂亮的代码开始：</p>
</div>
<div class="paragraph">
<p>通过定义一个素数的交叉点找到任何素数，真是一个不错的优雅解决方案！但是蒂姆惊讶地发现联赛很慢，上面的代码让他看到了前1000个素数。今天，超级高级代码需要0.96s。</p>
</div>
<div class="paragraph">
<p>对于基于联结的代码的缓慢程度，蒂姆继续做更标准的迭代方法感到不满。 Tim在这些帖子后不久就从网上消失。但他留下了我继续留下的遗产。他的主要基准测试代码和我对时间结果的适应性可以在这个要点中找到。以下是另一张图表，其中显示了每个超过100次试验找到前1000个素数所需的平均时间。 2015年的垂直线是较高的标准偏差。</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2017/12/timking_primes.png">img</a></p>
</div>
<div class="paragraph">
<p>再次以最近的放大视图（最新的数据点让我担心一点，我以某种方式搞砸了…​…​）</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2017/12/timking_primes_2017_improvement.png">img</a></p>
</div>
<div class="paragraph">
<p>上面的收敛到一个点，是启动和停止Rakudo运行时和MoarVM的开销。发现素数并不是它曾经的努力，它比Rakudo的开始稍微慢一些。无论您选择的代码解决方案的级别和优雅程度如何，至少要快一个数量级。</p>
</div>
<div class="paragraph">
<p>好吧，我们已经看到MoarVM获得了一些闪亮的新运动部件。但是像Liz，jnthn，Zoffix以及最近在字符串Samcv世界中开发人员已经付出了巨大的努力，以改进MoarVM和Rakudo在算法上实际上正在做的事情。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>旁注：我相信我根本不会做大多数其他开发人员的正义，特别是在这篇文章中忽略了JVM的努力。我建议每个人都去，并检查提交日志，看看有多少人现在参与使Rakudo更快，更好，更强大。我确定他们想在本文的底部看到您的感谢！</pre>
</div>
</div>
<div class="paragraph">
<p>因此，节省你一份查看提交日志的工作我已经做了一些挖掘，看看自上个圣诞节以来与提高性能有关的提交。 N％或Nx更快的东西。如下所示：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>3c6277c77 Have .codes use nqp::codes op. 350% faster for short strings</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>ee4593601 Make Baggy (^) Baggy about 150x faster</pre>
</div>
</div>
<div class="paragraph">
<p>这两项承诺将以一年的核心发展时间表推动编程项目的发展。但是，今年，它们仅仅是数百次提交中的两次。</p>
</div>
<div class="paragraph">
<p>下面是一些提交数量的直方图以及他们提到的性能的百分比和x乘数的增加。你可以用上面的代码自己grep日志。在2016年有一些更令人兴奋的收益值得检查。</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2017/12/percent_improvements_since_xmas2016.png">img</a></p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2017/12/x_improvements_since_xmas2016.png">img</a></p>
</div>
<div class="paragraph">
<p>这仅仅是2017年的性能提升承诺，几乎每天都会有更多的降落。这甚至不包括许多来自Zoffix授予的I / O性能收益，因为它们在之前/之后并不总是基准。 2016年同样密集，一些疯狂的&gt; 1000倍的改进。今年只有十个左右提交，提高40倍！看到这真是令人印象深刻。至少对我来说。我认为这对项目的许多人来说并不明显，他们正在完成多少。记住这些是单数提交。有些甚至在一年中复合改进！</p>
</div>
<div class="paragraph">
<p>我会把它留在这里。但是真的很感谢核心开发者，你们所有人。这是一个很棒的观看和等待体验。但现在是时候在2018年继续使用一些Raku代码了！终于圣诞节了。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十七天_关于消息传递">15. <a href="https://rakuadvent.wordpress.com/2017/12/17/something-about-messaging-but-i-couldnt-think-of-a-snappier-title/">第十七天-关于消息传递</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_为什么要传递消息">15.1. 为什么要传递消息</h3>
<div class="paragraph">
<p>当我第一次开始考虑写今年的 Advent 文章时，我反思我在过去的十二个月里并没有真正写过大量的 Raku，与往年相比，我似乎写了大量的模块。我一直在做的事情（至少在我的日常工作中）正在考虑和实施大量使用某些消息传递系统的应用程序。所以我认为将这些想法引入 Raku 会很有趣。</p>
</div>
<div class="paragraph">
<p>作为一种“胶水语言”，Perl一直享有盛誉，Raku 具有与之竞争的功能，最显着的是响应式和并发功能，因此非常适合创建基于消息的集成服务。</p>
</div>
</div>
<div class="sect2">
<h3 id="_传递什么信息">15.2. 传递什么信息</h3>
<div class="paragraph">
<p>现在我的脚下就是优秀的<a href="http://www.enterpriseintegrationpatterns.com/">企业集成模式</a>，尽管它现在已经有近15年的历史了，但我仍然建议任何有兴趣（或工作于）该领域的人。然而，它是一个重量级的书（字面上，它在硬书中的重量接近一点五公斤），所以我用它来提醒自己不要试图在这个主题上详尽无遗，以免这会变成一本书本身。</p>
</div>
<div class="paragraph">
<p>有相当多的自由和商业管理消息系统，使用一系列开放和专有的协议，但我将限制自己到我熟悉的 <a href="https://www.rabbitmq.com/">RabbitMQ</a>，并且在 Raku 中由 <a href="https://github.com/retupmoca/P6-Net-AMQP">Net::AMQP</a> 支持。</p>
</div>
<div class="paragraph">
<p>如果你想亲自尝试一下这些例子，你将需要访问一个 RabbitMQ 代理（它可以作为大多数操作系统发行版的包），但是你可以使用 <a href="https://hub.docker.com/_/rabbitmq/">Docker Image</a>，它看起来工作得很好。</p>
</div>
<div class="paragraph">
<p>您还需要安装 Net::AMQP，这可以通过以下方式完成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install Net::AMQP</code></pre>
</div>
</div>
<div class="paragraph">
<p>在示例中，我将使用 RabbitMQ 服务器的默认连接详细信息（即代理正在本地主机上运行，​​并且默认 <code>guest</code> 处于活动状态），如果您需要提供不同的详细信息，则可以更改 Net::AMQP 的构造函数以反映适当的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = Net::AMQP.new(
  host =&gt; &#39;localhost&#39;,
  port =&gt; 5672,
  login =&gt; &#39;guest&#39;,
  password =&gt; &#39;guest&#39;,
  vhost =&gt; &#39;/&#39;
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>一些示例可能需要其他模块，但我会在介绍时介绍它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="_强制性的你好世界">15.3. 强制性的你好，世界</h3>
<div class="paragraph">
<p>RabbitMQ实现了由AMQP v0.9规范描述的丰富的代理体系结构，由ActiveMQ实现的最新的v1.0规范取消了大部分规定的代理语义，以至于它基本上是一种不同的协议，它共享一个类似的电线格式。</p>
</div>
<div class="paragraph">
<p>发送消息（生产者）的最简单可能的例子可能是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Net::AMQP;

my $n = Net::AMQP.new;

await $n.connect;
my $channel = $n.open-channel(1).result;
my $exchange = $channel.exchange.result;
$exchange.publish(routing-key =&gt; &#34;hello&#34;, body =&gt; &#34;Hello, World&#34;.encode);
await $n.close(&#34;&#34;, &#34;&#34;);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">这演示了RabbitMQ和Net </dt>
<dd>
<p>AMQP的大部分核心功能。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>首先你会注意到许多方法返回一个Promise，它将大部分保留在实际的返回值中，这反映了代理的异步性质，它发送（大多数情况但不是全部）确认消息（AMQP说法中的方法，）当操作在服务器上完成时。</p>
</div>
<div class="paragraph">
<p>这里的连接建立到代理的网络连接并且协商某些参数，如果网络连接失败，提供的凭证不正确或者服务器拒绝某个其他连接，则返回一个Promise，如果成功或失败，它将保留一个真值原因。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">开放通道打开一个逻辑代理通信通道，在这个通道中交换消息，您可以在应用程序中使用多个通道。当服务器确认后，返回的Promise将保留在初始化的Net </dt>
<dd>
<p>AMQP :: Channel对象中。</p>
</dd>
<dt class="hdlist1">通道对象上的交换方法返回一个Net </dt>
<dd>
<p>AMQP :: Exchange对象，在AMQP模型中，所有消息都发布到交换机上，根据交换机的定义，代理可以将消息路由到一个或多个队列由此消息可能被另一客户消耗。在这个简单的例子中，我们将使用默认交换（名为amq.default。）</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>发布方法是在交换对象上调用的，它没有返回值，因为它只是简单的触发和遗忘，代理不会确认收到和交付，否则队列与发布消息的行为是分离的。顾名思义，路由密钥参数是由代理用来确定将消息路由到哪个队列（或多个队列）。在这个例子中使用默认交换的情况下，交换的类型是直接的，这基本上意味着消息传递到具有与路由密钥匹配的名称的队列中的一个消费者。正文总是一个Buf，并且可以是任意长度，在这种情况下，我们使用的是编码字符串，但它可以同样编码为JSON，MessagePack或BSON blob，无论适合消费应用程序。事实上可以提供内容类型和内容编码参数，如果应用程序的设计需要它，消息将传递给消费者，但代理本身完全不知道有效内容的内容。还有其他可选参数，但在这个例子中不需要。</p>
</div>
<div class="paragraph">
<p>当然，我们也需要阅读我们发布的消息（消费者）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Net::AMQP;

my $n = Net::AMQP.new;

my $connection = $n.connect.result;

react {
    whenever $n.open-channel(1) -&gt; $channel {
        whenever $channel.declare-queue(&#34;hello&#34;) -&gt; $queue {
            $queue.consume;
            whenever $queue.message-supply.map( -&gt; $v { $v.body.decode }) -&gt; $message {
                say $message;
                $n.close(&#34;&#34;, &#34;&#34;);
                done();
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们使用的是一个命名队列，而不是像我们在制作人那样在交易所进行操作;如果队列尚不存在，declare-queue将导致队列被创建，并且代理默认将该队列绑定到默认交换，“绑定”实质上意味着发送到交换的消息可以被路由到队列取决于交换类型，消息的路由键以及可能来自消息的其他元数据。在这种情况下，默认交换的“直接”类型将导致消息被路由到与路由密钥相匹配的队列（如果存在的话，如果消息不存在，消息将被无声地丢弃）。</p>
</div>
<div class="paragraph">
<p>当您准备好开始接收消息时调用消费方法，它将返回一个Promise，该Promise将与“消费者标签”一起保存，该标签将消费者唯一标识给服务器，但由于我们不需要它，因此我们可以忽略它。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">一旦我们调用了消费（并且代理发送了确认），那么路由到我们队列的消息将作为Net </dt>
<dd>
<p>AMQP :: Queue :: Message对象发送到由消息供应返回的Supply，但是因为我们对这个例子中的消息元数据不感兴趣映射被用来创建具有消息的解码体的新的Supply;这是安全的，因为在这种情况下，您可以保证您将接收utf-8编码，但是在真实世界的应用程序中，如果您不控制发送者，您可能希望在处理身体方面更强壮一些（当与第三方应用程序集成时通常是这种情况）。发布消息时提供的内容类型和内容编码在Message对象的headers属性（一个Hash）中可用，但它们不是必需的因此您可能需要考虑适合您的应用的替代方案。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在这个例子中，连接被关闭，并且在接收到第一条消息之后退出响应，但实际上您可能需要删除这些行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$n.close(&#34;&#34;, &#34;&#34;);
done();</code></pre>
</div>
</div>
<div class="paragraph">
<p>从内到外，如果你想退出一个信号例如添加：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">whenever signal(SIGINT) {
    $n.close(&#34;&#34;, &#34;&#34;);
    done();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在反应区的最高层。但是，如果您选择退出程序，则应始终在连接对象上调用close，因为这会在代理日志中引发警告消息，如果不这样做，可能会使管理服务器的人感到不安。</p>
</div>
<div class="paragraph">
<p>我们当然可以用类似的方式在生产者示例中使用反应语法，但是它会增加冗长的好处，但是在一个更大的程序中，例如，您可能正在处理一个Supply，它可以很好地工作很好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Net::AMQP;

my $supply = Supply.from-list(&#34;Hello, World&#34;, &#34;Bonjour le monde&#34;, &#34;Hola Mundo&#34;);
my $n = Net::AMQP.new;

react {
    whenever $n.connect {
        whenever $n.open-channel(1) -&gt; $channel {
            whenever $channel.exchange -&gt; $exchange {
                whenever $supply.map(-&gt; $v { $v.encode }) -&gt; $body {
                    $exchange.publish(routing-key =&gt; &#34;hello&#34;, :$body );
                    LAST {
                        $n.close(&#34;&#34;, &#34;&#34;);
                        done();
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_一些更有用的东西">15.4. 一些更有用的东西</h3>
<div class="paragraph">
<p>你可能会认为“这一切都很好，但这不是我不能做的事情，比如说，一个HTTP客户端和一个小型Web服务器”，好吧，你得到可靠的排队，未读消息的持久性等等，但是，对于简单的应用程序来说，它可能会被过度杀死，直到您添加了将消息发送给多个可能未知的消费者的需求为止。这种模式是使用“扇出”交换类型，它将向绑定到交换的所有队列传递消息。</p>
</div>
<div class="paragraph">
<p>在这个例子中，我们需要声明自己的队列，以便我们可以指定类型，但是生产者不会变得更加复杂：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Net::AMQP;

my $n = Net::AMQP.new;
my $con =  await $n.connect;
my $channel = $n.open-channel(1).result;
my $exchange = $channel.declare-exchange(&#39;logs&#39;, &#39;fanout&#39;).result;
$exchange.publish(body =&gt; &#39;Hello, World&#39;.encode);
await $n.close(&#34;&#34;, &#34;&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里唯一的区别是我们使用声明交换而不是在通道上交换来获得我们发送消息的交换，这样做的好处是使交换在指定类型的代理上创建已经存在，这在这里很有用，因为我们不需要依赖事先创建的交换（使用命令行工具rabbitmqctl或通过web管理界面），但它同样返回一个Promise，它将与Exchange交换目的。您可能还注意到，这里的路由密钥没有被传递给发布方法，这是因为对于扇出交换，路由密钥被忽略，并且消息被传递到绑定到交换机的所有消耗队列。</p>
</div>
<div class="paragraph">
<p>消费者代码与我们的原始消费者同样不存在差异：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Net::AMQP;

my $n = Net::AMQP.new;

my $connection = $n.connect.result;

react {
    whenever $n.open-channel(1) -&gt; $channel {
        whenever $channel.declare-exchange(&#39;logs&#39;, &#39;fanout&#39;) -&gt; $exchange {
            whenever $channel.declare-queue() -&gt; $queue {
                whenever $queue.bind(&#39;logs&#39;) {
                    $queue.consume;
                    whenever $queue.message-supply.map( -&gt; $v { $v.body.decode }) -&gt; $message {
                        say $*PID ~ &#34; : &#34; ~ $message;
                    }
                }
                whenever signal(SIGINT) {
                    say $*PID ~ &#34; exiting&#34;;
                    $n.close(&#34;&#34;, &#34;&#34;);
                    done();
                }

            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>交换的声明与生产者示例中声明的方式相同，这非常方便，因此您不必担心启动程序的顺序，第一次运行将创建队列，但是如果您在消费者启动之前运行生产者，发送的消息将被丢弃，因为默认情况下没有路由它们。这里我们还声明了一个没有提供名称的队列，这会创建一个“匿名”队列（该名称由代理组成），因为队列的名称在此路由消息中不起作用案件。</p>
</div>
<div class="paragraph">
<p>您可以提供一个队列名称，但如果名称重复，那么这些消息将以“先到先得”的方式路由到具有相同名称的队列，这可能不是预期的行为（尽管可能并可能有用。）</p>
</div>
<div class="paragraph">
<p>同样在这种情况下，队列必须明确地绑定到我们已经声明的交易所，在第一个例子中，默认交易所的绑定是由代理自动执行的，但在大多数情况下，您将不得不在队列上使用绑定交易所的名称。与许多方法一样，绑定返回一个Promise，当代理确认操作已完成时将保留Promise（尽管在这种情况下，值不重要）。</p>
</div>
<div class="paragraph">
<p>您应该能够根据需要启动尽可能多的消费者，并且他们都将按照发送的顺序接收所有消息。当然，在真实世界的应用程序中，消费者可能是用各种不同语言编写的完全不同的程序。</p>
</div>
</div>
<div class="sect2">
<h3 id="_保持主题">15.5. 保持主题</h3>
<div class="paragraph">
<p>一种常见模式是一组消费者，他们只对发布到特定交易所的某些消息感兴趣，其典型例子可能是记录系统，其中有专门针对不同日志级别的消费者。 AMQP提供了一种话题交换类型，允许通过生产者提供的路由密钥上的模式匹配将消息路由到特定的队列。</p>
</div>
<div class="paragraph">
<p>最简单的生产者可能是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Net::AMQP;

multi sub MAIN(Str $message = &#39;Hello, World&#39;, Str $level = &#39;application.info&#39;) {
	my $n = Net::AMQP.new;
	my $con =  await $n.connect;
	my $channel = $n.open-channel(1).result;
	my $exchange = $channel.declare-exchange(&#39;topic-logs&#39;, &#39;topic&#39;).result;
	$exchange.publish(routing-key =&gt; $level, body =&gt; $message.encode);
	await $n.close(&#34;&#34;, &#34;&#34;);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这应该从前面的例子中相当清楚，除了在这种情况下，我们将交换声明为主题类型，并且还提供将由代理用于匹配消费队列的路由密钥。</p>
</div>
<div class="paragraph">
<p>消费者代码本身又与前面的例子非常相似，只不过它会在命令行上列出一些用于匹配发送到交换机的路由密钥的模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Net::AMQP;

multi sub MAIN(*@topics ) {
    my $n = Net::AMQP.new(:debug);
    unless @topics.elems {
        say &#34;will be displaying all the messages&#34;;
        @topics.push: &#39;#&#39;;
    }
    my $connection = $n.connect.result;
    react {
        whenever $n.open-channel(1) -&gt; $channel {
            whenever $channel.declare-exchange(&#39;topic-logs&#39;, &#39;topic&#39;) -&gt; $exchange {
                whenever $channel.declare-queue() -&gt; $queue {
                    for @topics -&gt; $topic {
                        await $queue.bind(&#39;topic-logs&#39;, $topic);
                    }
                    $queue.consume;
                    my $body-supply = $queue.message-supply.map( -&gt; $v { [ $v.routing-key, $v.body.decode ] }).share;
                    whenever $body-supply -&gt; ( $topic , $message ) {
                            say $*PID ~ &#34; : [$topic]  $message&#34;;
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里基本上与前面的消费者示例的唯一区别是（除了提供给交换声明的类型）该主题提供给绑定方法。该主题可以是一个简单模式，其中＃将匹配任何提供的路由密钥，并且行为将与扇出交换相同，否则*可以在绑定主题的任何部分用作通配符，以匹配任何字符在这个例子中，在这个例子中，应用程序*将匹配使用路由关键字application.info或application.debug发送的消息。</p>
</div>
<div class="paragraph">
<p>如果有多于一个队列使用相同的模式绑定，则它们的行为也会像绑定到扇出交换机一样。如果绑定模式既不包含哈希也不包含星号字符，那么队列的行为就好像它被绑定到一个直接交换的那个名称的队列一样（也就是说它将有先到先服务基础。）</p>
</div>
</div>
<div class="sect2">
<h3 id="_但是生命比amqp更重要">15.6. 但是，生命比AMQP更重要</h3>
<div class="paragraph">
<p>当然。 Raku反应模型的优点在于可以将上面提到的供应商提供的各种源集成到您的生产者代码中，并且类似地，消费者可以将消息推送到另一个传输机制。</p>
</div>
<div class="paragraph">
<p>我很高兴地发现，当我想到这个例子的时候，下面的工作是正常的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use EventSource::Server;
use Net::AMQP;
use Cro::HTTP::Router;
use Cro::HTTP::Server;

my $supply = supply {
	my $n = Net::AMQP.new;
	my $connection = $n.connect.result;
	whenever $n.open-channel(1) -&gt; $channel {
		whenever $channel.declare-queue(&#34;hello&#34;) -&gt; $queue {
			$queue.consume;
			whenever $queue.message-supply.map( -&gt; $v { $v.body.decode }) -&gt; $data {
				emit EventSource::Server::Event.new(type =&gt; &#39;hello&#39;, :$data);
			}
		}
	}
};

my $es = EventSource::Server.new(:$supply);

my $application = route {
	get -&gt; &#39;greet&#39;, $name {
		content &#39;text/event-stream; charset=utf-8&#39;, $es.out-supply;
	}
}
my Cro::Service $hello = Cro::HTTP::Server.new:
	:host, :port, :$application;
$hello.start;

react whenever signal(SIGINT) { $hello.stop; exit; }</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">这是EventSource </dt>
<dd>
<p>Server中的示例的变体，您当然可以修改它以使用上面讨论的任何交换类型。它应该适用于第一个例子中的生产者代码。而且（如果你是这么说服的话），你可以用一小段node.js代码（或者在一些面向浏览器的javascript中）来消费事件：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">	var EventSource = require(&#39;eventsource&#39;);

	var event = process.argv[2] || &#39;message&#39;;

	console.info(event);
	var v = new EventSource(&#39; http://127.0.0.1:10000&#39;);

	v.addEventListener(event, function(e) {
		console.info(e);

	}, false);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_把它包起来">15.7. 把它包起来</h3>
<div class="paragraph">
<p>在输入第一段之后，我总结道，在一篇短文中，我永远无法做到这个主题正义，所以我希望你认为这是一个开胃菜，我不认为我会永远找到时间来写书，它可能值得。但是我确实有基于 <a href="https://github.com/jonathanstowe/Raku-RMQ-Examples">RabbitMQ 教程</a>的所有示例，因此请检查并随意贡献。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十八天_raku_支持的工作流">16. <a href="https://rakuadvent.wordpress.com/2017/12/18/raku-powered-work-flow/">第十八天-Raku 支持的工作流</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>保持流畅的编码可能是一个挑战。分心和讨厌的句法错误是潜在的流量瓶颈。</p>
</div>
<div class="paragraph">
<p>然后是7 +/- 2短期内存限制，我们都必须耍弄。与计算机不同，我们不能仅仅增加更多的硬件来增加大脑工作内存缓冲区的大小 - 至少目前还没有。保持流量需要管理这个缓冲区以避免井喷。幸运的是，我们有电脑帮助。</p>
</div>
<div class="paragraph">
<p>自计算开始以来，使用计算机扩展记忆的想法一直存在。早在1945年，Vannevar Bush就设想了一种Memex（MEMory EXtender），这是一种“扩大了对个人记忆的贴心补充”。</p>
</div>
<div class="paragraph">
<p>在2017年，卑微的文本文件可以像一个穷人的memex。该文本文件包含三个部分的时间轴：过去，现在和下一个。这有点像改变日志，但也有未来。过去的部分会随着时间的推移填满，包含完成的任务和信息供以后召回。现在部分可帮助您专注于手头的任务，而下一部分将排队完成将来要完成的任务。</p>
</div>
<div class="paragraph">
<p>任务通过三种状态：do（+ next），done（！now）和done（-past）。</p>
</div>
<div class="paragraph">
<p>为了保持畅通，你有时需要快速回忆一些事情，记下将来要做的事情，并专注于现在的进步。保留一个123.do文件可以帮助您减轻编码时的认知负担。</p>
</div>
<div class="paragraph">
<p>123.do文件的格式很简单，因此您可以直接使用文本编辑器对其进行破解，并使用此Raku语法进行描述。</p>
</div>
<div class="paragraph">
<p>这是驱动它的Raku命令行模块。</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2017/12/tty.gif?w=652&amp;zoom=2">img</a></p>
</div>
<div class="paragraph">
<p>安装它只需:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">shell&gt; zef install Do123
shell&gt; 123 +7 Merry Christmas
shell&gt; 123 +13 Happy New Year</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十九天_language_independent_validation_rules_livr_for_raku">17. <a href="https://rakuadvent.wordpress.com/2017/12/19/day-19-language-independent-validation-rules-livr-for-raku/">第十九天-Language Independent Validation Rules (LIVR) for Raku</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>我刚刚将 LIVR <a href="https://modules.raku.org/dist/LIVR:cpan:KOORCHIK">移植</a>到了 Raku。在 Raku 中编写代码非常有趣。而且，LIVR 的测试套件让我能够在 Raku 的 Email::Valid 模块中发现 bug，而在 Rakudo 中则发现另一个 bug。更有趣的是，不仅仅实现了一个模块，而且还帮助其他开发人员进行了一些测试:)</p>
</div>
<div class="paragraph">
<p>什么是 LIVR？ LIVR 代表“语言独立验证规则”。所以，它就像 “<a href="https://mustache.github.io/">Mustache</a>” ，但在验证的世界。所以，LIVR 由以下几部分组成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://livr-spec.org/">LIVR规范</a></p>
</li>
<li>
<p><a href="http://livr-spec.org/introduction/implementations.html">针对不同语言的实现</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/LIVR/tree/master/test_suite">通用测试套件</a>，用于检查实现是否正常工作。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>LIVR 有如下语言的实现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/koorchik/Validator-LIVR">Perl 5 (LIVR 2.0)</a> available at <a href="https://metacpan.org/pod/Validator::LIVR">CPAN</a>, 维护者 <a href="https://github.com/koorchik">@koorchik</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/raku-livr">Raku (LIVR 2.0)</a> available at <a href="https://modules.raku.org/dist/LIVR:cpan:KOORCHIK">CPAN</a>, 维护者 <a href="https://github.com/koorchik">@koorchik</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/js-validator-livr">JavaScript (LIVR 2.0)</a> available at <a href="https://www.npmjs.com/package/livr">npm</a>, 维护者 <a href="https://github.com/koorchik">@koorchik</a></p>
</li>
<li>
<p><a href="https://github.com/WebbyLab/php-validator-livr">PHP (LIVR 2.0)</a> available at <a href="https://packagist.org/packages/validator/livr">packagist</a>, 维护者 <a href="https://github.com/WebbyLab">@WebbyLab</a></p>
</li>
<li>
<p><a href="https://github.com/asholok/python-validator-livr">Python (LIVR 2.0)</a> available at <a href="https://pypi.python.org/pypi/LIVR">pypi</a>, 维护者 <a href="https://github.com/asholok">@asholok</a></p>
</li>
<li>
<p><a href="https://github.com/Prots/olifer">OLIFER Erlang (LIVR 2.0)</a>, 维护者 <a href="https://github.com/Prots">@Prots</a></p>
</li>
<li>
<p><a href="https://github.com/erlangbureau/liver">LIVER Erlang (LIVR 2.0)</a>, 维护者 <a href="https://github.com/erlangbureau">@erlangbureau</a></p>
</li>
<li>
<p><a href="https://github.com/vlbaluk/java-validator-livr">Java (LIVR 2.0)</a>, 维护者 <a href="https://github.com/vlbaluk">@vlbaluk</a></p>
</li>
<li>
<p><a href="https://github.com/maktwin/ruby-validator-livr">Ruby (LIVR 0.4, previous version)</a> at <a href="https://rubygems.org/gems/livr">rubygems</a>, 维护者 <a href="https://github.com/maktwin">@maktwin</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我会在这里给你一个关于LIVE的简短介绍，但是对于细节，我强烈推荐阅读这篇文章 <a href="http://blog.webbylab.com/language-independent-validation-rules-library/">“LIVR – Data Validation Without Any Issues”</a></p>
</div>
<div class="sect2">
<h3 id="_livr_介绍">17.1. LIVR 介绍</h3>
<div class="paragraph">
<p>数据验证是一项非常普遍的任务。我确信每个开发者都会一次又一次面对它。尤其是，当您开发Web应用程序时，这一点很重要。这是一条通用规则 - 绝对不要相信用户的输入。看起来，如果任务如此普遍，应该有大量的图库。是的，但它是很难找到一个理想的。有些库做了太多事情（如 HTML 表单生成等），其他库很难扩展，有些没有分层数据支持等。</p>
</div>
<div class="paragraph">
<p>而且，如果您是一名 Web 开发人员，则可能需要在服务器和客户端上进行相同的验证。</p>
</div>
<div class="paragraph">
<p>在 WebbyLab 中，我们主要使用 3 种编程语言 -  Perl，JavaScript，PHP。因此，对我们来说，重用跨语言的类似验证方法是理想的选择。</p>
</div>
<div class="paragraph">
<p>因此，决定创建一个可以跨不同语言工作的通用验证器。</p>
</div>
<div class="sect3">
<h4 id="_验证器要求">17.1.1. 验证器要求</h4>
<div class="paragraph">
<p>在尝试了大量的验证库之后，我们对我们想要解决的问题有了一些想法。以下是验证器的要求：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>规则是声明式并独立于语言的。因此，验证规则只是一个数据结构，而不是方法调用等。您可以对其进行转换，在对其他数据结构进行更改时进行更改</p>
</li>
<li>
<p>每个字段的任何数量的规则</p>
</li>
<li>
<p>验证器应该返回所有字段的错误。例如，我们想突出显示表单中的所有错误</p>
</li>
<li>
<p>剪掉所有没有描述验证规则的字段。 （否则，你不能依赖你的验证，如果验证器不符合这个属性，总有一天你会遇到安全问题）</p>
</li>
<li>
<p>可以验证复杂的层次结构。特别适用于 JSON APIs</p>
</li>
<li>
<p>易于描述和理解验证</p>
</li>
<li>
<p>返回可理解的错误代码（既不是错误消息也不是数字代码）</p>
</li>
<li>
<p>易于实现自己的规则（通常你会在每个项目中有几个）</p>
</li>
<li>
<p>规则应该能够改变结果输出（例如，“trim”，“nested_object”）</p>
</li>
<li>
<p>多用途（用户输入验证，配置验证等）</p>
</li>
<li>
<p>Unicode 支持</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_livr规范">17.1.2. LIVR规范</h4>
<div class="paragraph">
<p>由于该任务设置为独立于编程语言（某种胡须/句柄的东西）创建验证器，但在数据验证领域内，我们从规范的组成开始。</p>
</div>
<div class="paragraph">
<p>规范的目标是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>标准化数据描述格式。</p>
</li>
<li>
<p>描述每个实现必须支持的最小验证规则集。</p>
</li>
<li>
<p>标准化错误代码。</p>
</li>
<li>
<p>成为所有实现的单个基本文档。</p>
</li>
<li>
<p>具有一组测试数据，可以检查实现是否符合规范。</p>
</li>
<li>
<p>基本思想是验证规则的描述必须看起来像数据方案，并且尽可能与数据类似，但是使用规则而不是值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>该规范可在 <a href="http://livr-spec.org/" class="bare">http://livr-spec.org/</a> 获得。</p>
</div>
<div class="paragraph">
<p>这是基本的介绍。更多细节在我上面提到的文章中。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_livr和raku">17.2. LIVR和Raku</h3>
<div class="paragraph">
<p>让我们玩得开心，玩一段代码。我将通过几个例子，并在每个例子后提供一些内部细节。所有示例的源代码都可以在 <a href="https://github.com/koorchik/raku-livr-advent-calendar-post/tree/master/examples">GitHub</a> 上找到</p>
</div>
<div class="paragraph">
<p>首先，从 CPAN 安装 Raku 的 LIVR 模块</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install LIVR</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>示例1：注册数据验证</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use LIVR;

# Automatically trim all values before validation
LIVR::Validator.default-auto-trim(True);

my $validator = LIVR::Validator.new(livr-rules =&gt; {
    name      =&gt; &#39;required&#39;,
    email     =&gt; [ &#39;required&#39;, &#39;email&#39; ],
    gender    =&gt; { one_of =&gt; [&#39;male&#39;, &#39;female&#39;] },
    phone     =&gt; { max_length =&gt; 10 },
    password  =&gt; [ &#39;required&#39;, {min_length =&gt; 10} ],
    password2 =&gt; { equal_to_field =&gt; &#39;password&#39; }
});

my $user-data = {
    name      =&gt; &#39;Viktor&#39;,
    email     =&gt; &#39;viktor@mail.com&#39;,
    gender    =&gt; &#39;male&#39;,
    password  =&gt; &#39;mypassword123&#39;,
    password2 =&gt; &#39;mypassword123&#39;
}


if my $valid-data = $validator.validate($user-data) {
    # $valid-data is clean and does contain only fields
    # which have validation and have passed it
    $valid-data.say;
} else {
    my $errors = $validator.errors();
    $errors.say;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>那么，如何理解规则？</strong></p>
</div>
<div class="paragraph">
<p>这个想法很简单。每条规则都是一个散列. key  - 验证规则的名称。value - 一个参数数组。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    name  =&gt; { required =&gt; [] },
    phone =&gt; { max_length =&gt; [10] }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但如果只有一个参数，则可以使用较短的形式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    phone =&gt; { max_length =&gt; 10 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有参数，则可以将规则的名称作为字符串传递：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    name =&gt; &#39;required&#39;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在数组中给字段传递一个规则列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    name =&gt; [ &#39;required&#39;, { max_length =&gt; 10 } ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，规则将陆续应用。因此，在这个例子中，首先，“required” 规则将被应用，“max_length” 之后，并且只有当 “required” 成功通过时。</p>
</div>
<div class="paragraph">
<p>这里是 <a href="http://livr-spec.org/validation-rules/how-it-works.html">LIVR 规范的细节</a>。</p>
</div>
<div class="paragraph">
<p>你可以在<a href="http://livr-spec.org/validation-rules.html">这里</a>找到标准规则的列表。</p>
</div>
<div class="paragraph">
<p>例2：分层数据结构的验证</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use LIVR;

my $validator = LIVR::Validator.new(livr-rules =&gt; {
    name  =&gt; &#39;required&#39;,
    phone =&gt; {max_length =&gt; 10},
    address =&gt; {&#39;nested_object&#39; =&gt; {
        city =&gt; &#39;required&#39;,
        zip  =&gt; [&#39;required&#39;, &#39;positive_integer&#39;]
    }}
});

my $user-data = {
    name  =&gt; &#34;Michael&#34;,
    phone =&gt; &#34;0441234567&#34;,
    address =&gt; {
        city =&gt; &#34;Kiev&#34;,
        zip  =&gt; &#34;30552&#34;
    }
}

if my $valid-data = $validator.validate($user-data) {
    # $valid-data is clean and does contain only fields
    # which have validation and have passed it
    $valid-data.say;
} else {
    my $errors = $validator.errors();
    $errors.say;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>这个例子中有趣的是什么？</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>模式（验证规则）形状与数据形状非常相似。例如，读取比 JSON Schema 容易得多。</p>
</li>
<li>
<p>看起来 “nested_object” 是一种特殊的语法，但它不是。验证器在 “required”，“nested_object”，“max_length” 之间没有任何区别。所以，核心非常小，您可以轻松地使用自定义规则引入新功能。</p>
</li>
<li>
<p>通常你想重用复杂的验证规则，比如 “address”，并且可以使用别名来完成。</p>
</li>
<li>
<p>您将收到分层错误消息。例如，如果您错过 city 和 name，错误对象将显示 <code>{name ⇒&#39;REQUIRED&#39;，address ⇒ {city ⇒&#39;REQUIRED&#39;}}</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_别名">17.2.1. 别名</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use LIVR;

LIVR::Validator.register-aliased-default-rule({
    name  =&gt; &#39;short_address&#39;, # names of the rule
    rules =&gt; {&#39;nested_object&#39; =&gt; {
        city =&gt; &#39;required&#39;,
        zip  =&gt; [&#39;required&#39;, &#39;positive_integer&#39;]
    }},
    error =&gt; &#39;WRONG_ADDRESS&#39; # custom error (optional)
});

my $validator = LIVR::Validator.new(livr-rules =&gt; {
    name    =&gt; &#39;required&#39;,
    phone   =&gt; {max_length =&gt; 10},
    address =&gt; &#39;short_address&#39;
});

my $user-data = {
    name  =&gt; &#34;Michael&#34;,
    phone =&gt; &#34;0441234567&#34;,
    address =&gt; {
        city =&gt; &#34;Kiev&#34;,
        zip  =&gt; &#34;30552&#34;
    }
}

if my $valid-data = $validator.validate($user-data) {
    # $valid-data is clean and does contain only fields
    # which have validation and have passed it
    $valid-data.say;
} else {
    my $errors = $validator.errors();
    $errors.say;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你愿意，你可以只为你的验证器实例注册别名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use LIVR;

my $validator = LIVR::Validator.new(livr-rules =&gt; {
    password =&gt; [&#39;required&#39;, &#39;strong_password&#39;]
});

$validator.register-aliased-rule({
    name  =&gt; &#39;strong_password&#39;,
    rules =&gt; {min_length =&gt; 6},
    error =&gt; &#39;WEAK_PASSWORD&#39;
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>示例3：数据修改，流水线</strong>
有规则可以做数据修改。以下是他们的列表：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>trim</p>
</li>
<li>
<p>to_lc</p>
</li>
<li>
<p>to_uc</p>
</li>
<li>
<p>remove</p>
</li>
<li>
<p>leave_only</p>
</li>
<li>
<p>default</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你可以在这里<a href="http://livr-spec.org/validation-rules/modifiers.html">阅读细节</a>。</p>
</div>
<div class="paragraph">
<p>用这种方法，你可以创建某种管道。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use LIVR;

my $validator = LIVR::Validator.new(livr-rules =&gt; {
    email =&gt; [ &#39;trim&#39;, &#39;required&#39;, &#39;email&#39;, &#39;to_lc&#39; ]
});

my $input-data = { email =&gt; &#39; EMail@Gmail.COM &#39; };
my $output-data = $validator.validate($input-data);

$output-data.say;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>这里重要的是什么？</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>正如我之前提到的，对于验证器来说，任何规则都没有区别。它以同样的方式处理 “trim”，“default”，“required”，“nested_object”。</p>
</li>
<li>
<p>规则一个接一个地应用。规则的输出将被传递给下一个规则的输入。这就像一个 bash 管道 <code>echo &#39; <a href="mailto:EMail@Gmail.COM">EMail@Gmail.COM</a> &#39; | trim | required | email | to_lc</code></p>
</li>
<li>
<p><code>$input-data</code> <strong>永远不会</strong>改变 <code>$output-data</code> 是验证后使用的数据。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>示例4：自定义规则</strong></p>
</div>
<div class="paragraph">
<p>您可以使用别名作为自定义规则，但有时这还不够。编写自己的自定义规则绝对没问题。你可以用自定义规则做几乎所有事情。</p>
</div>
<div class="paragraph">
<p>通常，我们在每个项目中都有 1-5 个自定义规则。此外，您可以将自定义规则组织为单独的可重用模块（甚至可以将其上传到 CPAN）。</p>
</div>
<div class="paragraph">
<p><strong>那么，如何为 LIVR 编写自定义规则？</strong></p>
</div>
<div class="paragraph">
<p>这里是’strong_password’的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use LIVR;

my $validator = LIVR::Validator.new(livr-rules =&gt; {
    password =&gt; [&#39;required&#39;, &#39;strong_password&#39;]
});

$validator.register-rules( &#39;strong_password&#39; =&gt;  sub (@rule-args, %builders) {
    # %builders - are rules from original validator
    # to allow you create new validator with all supported rules
    # my $validator = LIVR::Validator.new(livr-rules =&gt; $livr).register-rules(%builders).prepare();
    # See &#34;nested_object&#34; rule implementation for example
    # https://github.com/koorchik/raku-livr/blob/master/lib/LIVR/Rules/Meta.pm6#L5

    # Return closure that will take value and return error
    return sub ($value, $all-values, $output is rw) {
        # We already have &#34;required&#34; rule to check that the value is present
        return if LIVR::Utils::is-no-value($value); # so we skip empty values

        # Return value is a string
        return &#39;FORMAT_ERROR&#39; if $value !~~ Str &amp;&amp; $value !~~ Numeric;

        # Return error in case of failed validation
        return &#39;WEAK_PASSWORD&#39; if $value.chars &lt; 6;

        # Change output value. We want always return value be a string
        $output = $value.Str;
        return;
    };
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>查看更多示例的现有规则实现:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/koorchik/raku-livr/blob/master/lib/LIVR/Rules/Common.pm6">Common rules</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/raku-livr/blob/master/lib/LIVR/Rules/Numeric.pm6">Numeric rules</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/raku-livr/blob/master/lib/LIVR/Rules/String.pm6">String rules</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/raku-livr/blob/master/lib/LIVR/Rules/Special.pm6">Special rules</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/raku-livr/blob/master/lib/LIVR/Rules/Modifiers.pm6">Modifiers rules</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/raku-livr/blob/master/lib/LIVR/Rules/Meta.pm6">Meta rules</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>示例5：Web 应用程序</strong></p>
</div>
<div class="paragraph">
<p>LIVR 适用于 REST API。通常，很多 REST API 在返回可理解的错误方面存在问题。如果您的 API 用户将收到 HTTP 错误 500，它不会帮助他。更好的时候，他会得到类似的错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">{
    &#34;name&#34;: &#34;REQUIRED&#34;,
    &#34;phone&#34;: &#34;TOO_LONG&#34;,
    &#34;address&#34;: {
        &#34;city&#34;: &#34;REQUIRED&#34;,
        &#34;zip&#34;: &#34;NOT_POSITIVE_INTEGER&#34;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而不仅仅是“服务器错误”。</p>
</div>
<div class="paragraph">
<p>所以，让我们试着做一个带有两个端点的小型 Web 服务：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>GET /notes → get list of notes</p>
</li>
<li>
<p>POST /notes → create a note</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您需要为其安装 Bailador：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install Bailador</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们来创建一些服务。我更喜欢带有 “run”模板方法的服务中的 “Command”模式。</p>
</div>
<div class="paragraph">
<p>我们将有 2 项服务：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Service::Notes::Create</p>
</li>
<li>
<p>Service::Notes::List</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>服务使用示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %CONTEXT = (storage =&gt; my @STORAGE);

my %note = title =&gt; &#39;Note1&#39;, text =&gt; &#39;Note text&#39;;

my $new-note = Service::Notes::Create.new(
    context =&gt; %CONTEXT
).run(%note);

my $list = Service::Notes::Create.new(
    context =&gt; %CONTEXT
).run({});</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了上下文，你可以注入任何依赖关系。 “run” 方法接受用户传递的数据。</p>
</div>
<div class="paragraph">
<p>以下是创建笔记服务的源代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Service::Base;
my $LAST_ID = 0;
class Service::Notes::Create is Service::Base {
    has %.validation-rules = (
        title =&gt; [&#39;required&#39;, {max_length =&gt; 20} ],
        text  =&gt; [&#39;required&#39;, {max_length =&gt; 255} ]
    );

    method execute(%note) {
        %note&lt;id&gt; = $LAST_ID++;
        $.context&lt;storage&gt;.push(%note);

        return %note;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>和 Service::Base 类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use LIVR;
LIVR::Validator.default-auto-trim(True);

class Service::Base {
    has $.context = {};

    method run(%params) {
        my %clean-data = self!validate(%params);
        return self.execute(%params);
    }

    method !validate($params) {
        return $params unless %.validation-rules.elems;

        my $validator = LIVR::Validator.new(
            livr-rules =&gt; %.validation-rules
        );

        if my $valid-data = $validator.validate($params) {
            return $valid-data;
        } else {
            die $validator.errors();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>“run” 方法保证所有过程都被保留：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>数据已经过验证。</p>
</li>
<li>
<p>“execute” 仅在验证后才会调用。</p>
</li>
<li>
<p>“execute” 将只收到干净的数据。</p>
</li>
<li>
<p>在验证错误的情况下引发异常。</p>
</li>
<li>
<p>在调用“execute”之前可以检查权限。</p>
</li>
<li>
<p>可以执行额外的工作，如缓存验证器对象等。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这是<a href="https://github.com/koorchik/raku-livr-advent-calendar-post/tree/master/examples/example5-restapi">完整的工作示例</a>。</p>
</div>
<div class="paragraph">
<p>运行应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku app.pl6</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建一个 note：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">curl -H &#34;Content-Type: application/json&#34; -X POST -d &#39;{&#34;title&#34;:&#34;New Note&#34;,&#34;text&#34;:&#34;Some text here&#34;}&#39; http://localhost:3000/notes</code></pre>
</div>
</div>
<div class="paragraph">
<p>检查验证：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">curl -H &#34;Content-Type: application/json&#34; -X POST -d &#39;{&#34;title&#34;:&#34;&#34;,&#34;text&#34;:&#34;&#34;}&#39; http://localhost:3000/notes</code></pre>
</div>
</div>
<div class="paragraph">
<p>获取notes列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">curl http://localhost:3000/notes</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_livr_链接">17.3. LIVR 链接</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/koorchik/raku-livr-advent-calendar-post/tree/master/examples">The source code of all examples</a></p>
</li>
<li>
<p>文章 <a href="http://blog.webbylab.com/language-independent-validation-rules-library/">“LIVR – Data Validation Without Any Issues”</a></p>
</li>
<li>
<p><a href="http://livr-spec.org/">LIVR specifications and docs (the latest version – 2.0)</a></p>
</li>
<li>
<p><a href="https://github.com/koorchik/LIVR/tree/master/test_suite">Universal test suite</a></p>
</li>
<li>
<p>你可以在线玩 <a href="http://webbylab.github.io/livr-playground/">LIVR Playground</a></p>
</li>
<li>
<p>你可以在线玩 <a href="http://livr-multi-playground.webbylab.com/">LIVR Multi-Language Playground</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我希望你会喜欢 LIVR。我会很感激任何反馈。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十天_宏的进阶">18. <a href="https://rakuadvent.wordpress.com/2017/12/20/day-20-advancements-in-macrotechnologies/">第二十天-宏的进阶</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>你好！</p>
</div>
<div class="paragraph">
<p>请允许我，在出现日历的这一天，一个小切线。我不会直接谈论一个很酷的熟练的Raku特性。相反，我会打开一个小窗口，讨论可能会发生什么 - 希望在某些时候！</p>
</div>
<div class="paragraph">
<p>如果你像我一样，在Rakudo上继续了几年的进步，你在版本中经常看到这一点：&gt;一些不太有效的功能包括：&gt;  - 高级宏</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">那么，这究竟意味着什么？ Raku确实有宏，但它们目前的限制超出了人们通常想要做的。这并不是说它们目前是无用的，它们仍然是有用的，从前几年出现的其他帖子到OO </dt>
<dd>
<p>Monitor使用宏来提前报告拼写错误。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>输入007. 007是“具有宏观许可的小型实验语言”。这是什么意思？！这是一种用于对宏进行调试和实验的语言，因此当他们被集成到Raku中时，他们的设计就已经准备好并经过战斗测试。</p>
</div>
<div class="paragraph">
<p>那么，它有什么？ 007试图模仿Raku的“强大”部分，因此我们不会为完全不同的语言设计宏。这意味着阶段，中缀操作员，（MOP和正则表达式的要点）。</p>
</div>
<div class="paragraph">
<p>它是什么样子的？ 007的核心就是喜欢Raku.然而，它的确存在一些问题。让我们来看看你想写的最重要的片段：FizzBu​​zz。注意：此博客帖子中的所有代码片段都是可执行的007代码，而不是Raku代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my n = 1;
while n &lt;= 100 {
    if n %% 15 {
        say(&#34;FizzBuzz&#34;);
    }
    else if n %% 3 {
        say(&#34;Fizz&#34;);
    }
    else if n %% 5 {
        say(&#34;Buzz&#34;);
    }
    else {
        say(n);
    }
    n = n + 1;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>什么？你不在乎吗？很明显，我确实答应过你的宏。我们将看看一个简单的宏“name”，它返回最后一个索引对象的名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">macro name(expr) {
    if expr ~~ Q::Postfix::Property {
        expr = expr.property;
    }
    if expr !~~ Q::Identifier {
        throw new Exception {
            message: &#34;Cannot turn a &#34; ~ type(expr) ~ &#34; into a name&#34;
        };
    }
    return quasi { expr.name };
}

my info = {
    foo: &#34;Bond&#34;,
    bar: {
        baz: &#34;James Bond&#34;
    },
};

say(name(info));           # info
say(name(info.foo));       # foo
say(name(info.bar.baz));   # baz</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以，你可能会在这里“WAT”。你是对的 - 这个要点缺少一些解释。宏的一个最重要的功能是访问AST（抽象语法树）。宏需要能够混淆代码的结构（如Lisp），而不是代码文本（如C）。 Q ::类型是代表程序形状的标准化类型。他们并不特别需要表示编译器/解释器如何考虑代码，但他们需要保持稳定，因为我们正在编写我们的代码 - 我们的宏 - 针对这种内省API。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">在这个代码示例中，我们使用了两种Q类型：表示点访问的Q </dt>
<dd>
<p>Postfix :: Property和表示标识符的Q :: Identifier。首先，我们检查我们是否有财产。如果是这种情况，我们提取点右侧的内容（记住，a.b.c是（a.b）.c）。然后我们检查我们是否结束了一个标识符（而不是一个数字），并打印出来。这是例如我们如何才能实现C＃的操作符名称，而不必为语言添加任何内容！</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>几天前，masak ++发布了一篇名为“三年过去”的博客文章，标志着007的第三个生日。虽然有些地区仍然非常粗糙，但它看起来越来越像一种可用的语言，日复一日。</p>
</div>
<div class="paragraph">
<p>接下来我们要看的是正在解析的实现。下面是它的外观：（这个例子适用于PR，但是现在使用特殊外壳）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">macro statement:() is parsed(/&#34;whoa!&#34;/) {
    return quasi @ Q::Statement {
        say(&#34;whoa!&#34;);
    }
};

whoa!;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也可能是我们希望他们在Raku中看起来…​…​或者不是？讨论仍在进行中！鼓励你加入自行车…​…​讨论:-)。这种语言还很年轻，需要大量的丰富功能，以及它的高级功能和简单功能。</p>
</div>
<div class="paragraph">
<p>在我向你提供大量的元乐趣之前，这里是007想要达到目前坐落在分支中的一个里程碑：实现infix：&lt;ff&gt;作为库的一部分（如果你不确定，Raku文档如果在这里适用），而不是语言的一部分。代码在这里！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># our infix macro takes a lhs (left hand side) and a rhs (right hand side).
macro infix:&lt;ff&gt;(lhs, rhs) is tighter(infix:&lt;=&gt;) {
    my active = False; # our current value when starting
    return quasi {
        if {{{lhs}}} {
            active = True; # if the bit on the left is true, we switch to active mode
        }
        my result = active; # the result we are returning
        if {{{rhs}}} {
            active = False; # if the bit on the right is true, we switch to inactive mode
        }
        result; # return the result stored *before* the rhs ran.
    };
}

my values = [&#34;A&#34;, &#34;B&#34;, &#34;A&#34;, &#34;B&#34;, &#34;A&#34;];
for values -&gt; v {
    if v == &#34;B&#34; ff v == &#34;B&#34; {
        say(v);
    }
    else {
        say(&#34;x&#34;);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是今天！如果您需要更多，请随时查看教程或示例文件夹。如果你想了解意愿，我们也有路线图。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十一天_数独与junctions和集合">19. <a href="https://rakuadvent.wordpress.com/2017/12/21/day-21-sudoku-with-junctions-and-sets/">第二十一天-数独与Junctions和集合</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 中有许多核心元素为您提供强大的工具，以简洁而强大的方式完成任务。其中两个是具有许多特征的联结和集合，但也是截然不同的。为了演示这些功能，我将介绍如何将它们用于一个简单的问题，Sudoku拼图。</p>
</div>
<div class="paragraph">
<p>数独：进修
所以对于那些不知道数独谜题的人来说，它是一个9乘9的网格，它提供了一些填充了数字1-9的单元格。目标是填充数字在1和9之间的所有单元格，所以没有任何行，列或子广场具有多于一个的数字。</p>
</div>
<div class="paragraph">
<p>有几种方法来表示一个数独谜题，我个人最喜欢的是 9×9 嵌套数组，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @game = [
    [4,0,0,0,0,0,0,0,0],
    [0,9,0,3,4,6,0,5,0],
    [5,8,0,0,9,0,0,0,6],
    [0,4,0,8,1,3,0,0,9],
    [0,0,0,5,0,4,0,0,0],
    [8,0,0,6,2,9,0,4,0],
    [3,0,0,0,5,0,0,6,2],
    [0,5,0,9,3,2,0,8,0],
    [0,0,0,0,0,0,0,0,1]
];</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，没有赋值的单元格被赋值为0，这样所有的单元格都有一个赋值给它们的整数值。使用这种格式要记住的主要事情是你需要使用@game [$ y] [$ x]而不是@game [$ x] [$ y]来引用单元格，</p>
</div>
<div class="sect2">
<h3 id="_junctions量子逻辑测试">19.1. Junctions：量子逻辑测试</h3>
<div class="paragraph">
<p>在 Raku 中使用 Junction 的最简单方法之一是逻辑测试。 Junction可以表示您想要测试的值的选择。例如 ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if ( 5 &lt; 1|10 &lt; 2 ) { say &#34;Spooky&#34; } else { say &#34;Boo&#34; }
Spooky</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，这不仅证明了操作符链（经验丰富的程序员可能已经看起来很困惑），而且对于5 &lt;10和1 &lt;2，任何连接点（1 | 10）的计算结果都为True。这样，连接点可以非常已经很强大了，当你为它们分配一个变量容器时，它变得非常有趣。</p>
</div>
<div class="paragraph">
<p>我们希望能够在我们的数独游戏中做出的一个测试就是看它是否已满。我的意思是每个单元格的赋值都大于0.完整的拼图可能无法正确完成，但每个单元格都有一个猜测。另一种方法是，没有任何单元格的值为0.因此，我们可以定义一个Junction并将其存储在一个标量变量中，我们可以在任何时候测试它以查看拼图是否已满。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $full-test = none( (^9 X ^9).map(-&gt; ($x,$y) {
    @game[$y][$x];
} ) );
say so $full-test == 0;
False</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，游戏中仍然有0个数字，因此看看$ full-test是否等于0，结果为False。请注意，如果没有将结果强制转换为布尔值，只有当所有这些值都为False时，才会得到等于0的单元格的细分。</p>
</div>
<div class="paragraph">
<p>还要注意使用^ 9和X运算符来生成0到8的两个范围，然后使用这两个9个字符的列表的叉积来列出所有可能的X，Y坐标的列表。这就是这种强大的简单性，这是我喜欢Raku的原因之一。但我离题了。</p>
</div>
<div class="paragraph">
<p>这种方法的优点是，一旦你定义了Junction，你就不需要修改它。如果您更改存储在数组中的值，那么连接将会查看新的值（注意，这仅适用于更新单个单元格，如果用新的数组替换整个子数组，您将打破连接点）。</p>
</div>
<div class="paragraph">
<p>所以这是一个简单的使用连接点，因此存储一个可以重复使用的多变量测试。但是当你意识到连接点中的值本身就是连接点时，它会变得更有趣。</p>
</div>
<div class="paragraph">
<p>让我们看看更复杂的测试，如果拼图中的每一行，每列和每个数字中只有一个，则拼图就完成了。为了做这个测试，我们需要三个帮助函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset Index of Int where 0 &lt;= * &lt;= 8;
sub row( Index $y ) {
    return (^9).map( { ( $_, $y ) } );
}
sub col( Index $x ) {
     return (^9).map( { ( $x, $_ ) } );
}
multi sub square( Index $sq ) {
    my $x = $sq % 3 * 3;
    my $y = $sq div 3 * 3;
    return self.square( $x, $y );
}
multi sub square( Index $x, Index $y ) {
     my $tx = $x div 3 * 3;
     my $ty = $y div 3 * 3;
     return ( (0,1,2) X (0,1,2) ).map( -&gt; ( $dx, $dy ) {
        ( $tx + $dx, $ty + $dy )
    } );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，我们在这里定义一个索引作为0到8之间的值，然后定义我们的子索引来返回一个列表列表，其中子列表是一对X和Y索引。请注意，我们的平方函数可以接受一个或两个位置参数。在单个参数中，我们定义了0在左上角然后从左到右，8是右下角的子广场。两个参数版本给出了给定单元格（包括它自己）的正方形单元格列表。</p>
</div>
<div class="paragraph">
<p>所以在这些地方我们可以为每一行，列和方块定义我们的一个（）列表。一旦我们拥有了它们，我们就可以将它们放入一个全部（）连接点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $complete-all = all(
     (^9).map(
        {
            |(
                one( row( $_ ).map( -&gt; ( $x, $y ) {
                    @game[$y][$x]
                } ) ),
                one( col( $_ ).map( -&gt; ( $x, $y ) {
                    @game[$y][$x]
                } ) ),
                one( square( $_ ).map( -&gt; ( $x, $y ) {
                    @game[$y][$x]
                } ) )
            )
        }
    )
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦我们进行了测试，看看这个难题是否完整，那就很简单了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [&amp;&amp;] (1..9).map( so $complete-all == * );
False</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们测试1到9的每个可能的单元格值，对于交叉点，在每种情况下，如果所有的一个（）连接仅包含一个值，则这将为真。然后，我们使用[]缩减元运算符来链接这些结果以给出最终的真/假值（如果所有结果均为真，否则为真）。再次，这个测试可以在您向单元格添加值时重新使用，并且只有在拼图完成且正确时才会返回True。</p>
</div>
<div class="paragraph">
<p>我们再一次将复杂的测试归结为一行代码。我们的$ complete-all变量需要定义一次，然后在会话的其余部分有效。</p>
</div>
<div class="paragraph">
<p>这种嵌套联结测试可以达到很多级别，最后一个例子是如果我们想测试当前的难题是否有效。我的意思是它没有完成，但它没有任何重复的数字和行，列或方块。我们可以再次为此创建一个Junction，对于每一行，每列或每个方块，如果其中一个或没有一个单元格设置为每个可能的值，则它是有效的。因此，我们创建的Junction类似于$ complete-全部。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$valid-all = all(
    (^9).map(
        {
            |(
                one(
                    none( row( $_ ).map( -&gt; ( $x, $y ) {
                        @game[$y][$x]
                    } ) ),
                    one( row( $_ ).map( -&gt; ( $x, $y ) {
                        @game[$y][$x]
                    } ) )
                ),
                one(
                    none( col( $_ ).map( -&gt; ( $x, $y ) {
                        @game[$y][$x]
                    } ) ),
                    one( col( $_ ).map( -&gt; ( $x, $y ) {
                        @game[$y][$x]
                    } ) )
                ),
                one(
                    none( square( $_ ).map( -&gt; ( $x, $y ) {
                        @game[$y][$x]
                    } ) ),
                    one( square( $_ ).map( -&gt; ( $x, $y ) {
                        @game[$y][$x]
                    } ) )
                )
            )
        }
    )
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>有效性测试与完整性测试基本相同。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [&amp;&amp;] (1..9).map( so $valid-all == * );
True</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了在这种情况下我们的谜题是有效的，所以我们得到一个真实的结果。</p>
</div>
</div>
<div class="sect2">
<h3 id="_集合对象的集合">19.2. 集合：对象的集合</h3>
<div class="paragraph">
<p>虽然结点对测试值很有用，但如果我们想尝试解决这个难题，它们就不那么有用。但是Raku有另一种类型的集合，可以派上用场。套装（及其相关类型的手袋和混合物）可让您收集物品，然后对其进行数学设定操作，以找出不同套装之间的互动方式。</p>
</div>
<div class="paragraph">
<p>作为一个例子，我们将定义一个可能的函数，它返回给定单元格可能的值。如果单元格具有设置的值，我们将返回空列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub possible( Index $x, Index $y, @game ) {
    return () if @game[$y][$x] &gt; 0;

    (
        (1..9)
            (-)
        set(
            ( row($y).map( -&gt; ( $x, $y ) {
                @game[$y][$x]
            } ).grep( * &gt; 0 ) ),
            ( col($x).map( -&gt; ( $x, $y ) {
                @game[$y][$x]
            } ).grep( * &gt; 0 ) ),
            ( square($x,$y).map( -&gt; ( $x, $y ) {
                @game[$y][$x]
            } ).grep( * &gt; 0 ) )
        )
    ).keys.sort;
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们发现数字1到9与由给定单元格所在的行，列和平方值组成的集合之间的差异。我们使用grep忽略具有0值的单元格。 As Sets将他们的细节存储为无序的键/值对，我们得到这些键，然后对它们进行排序以保持一致性。请注意，这里我们使用的是运算符的ascii（ - ）版本，我们也可以使用Unicode版本。</p>
</div>
<div class="paragraph">
<p>我们可以将该集合定义为来自行，列和平方的每个结果的并集，并且结果将是相同的。在这种情况下，我们也使用square的两个参数版本。</p>
</div>
<div class="paragraph">
<p>应该指出的是，这是可能值最简单的定义，没有附加的逻辑进行，但即使这个简单的结果，我们也可以做最简单的求解算法。如果是这种情况，我们会在网格中的每个单元格中循环，如果它有1个可能的值，我们可以将该值设置为该值。在这种情况下，我们将循环，获取要设置的单元列表，然后遍历列表并设置值。如果要设置的列表为空或拼图完成，则停止。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @updates;
repeat {
    @updates = (^9 X ^9).map( -&gt; ($x,$y) {
        ($x,$y) =&gt; possible($x,$y,@game)
    } ).grep( *.value.elems == 1 );
    for @updates -&gt; $pair {
        my ( $x, $y ) = $pair.key;
        @game[$y][$x] = $pair.value[0];
    }
} while ( @updates.elems &gt; 0 &amp;&amp;
          ! [&amp;&amp;] (1..9).map( so $complete-all == * ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，我们列出了对的列表，其中关键是x，y坐标，值是可能的值。然后我们删除所有那些没有一个价值的东西。这一直持续到没有找到具有单个可能值的细胞或者谜题已完成为止。</p>
</div>
<div class="paragraph">
<p>找到解决方案的另一种方法是获得只出现在给定，行，列或方块的一组可能性中的值。例如，如果我们有以下可能性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1,2,3),(2,3,4),(),(),(4,5),(),(),(2,3,4),()</code></pre>
</div>
</div>
<div class="paragraph">
<p>1和5只在每行出现一次。我们可以利用对称集合差分算子和算子链来得到它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1,2,3) (^) (2,3,4) (^) () (^) () (^) (4,5) (^) () (^) () (^) (2,3,4) (^) ()
set(1 5)</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，在这种情况下，我们可以在列表中使用简化元运算符</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [(^)] (1,2,3),(2,3,4),(),(),(4,5),(),(),(2,3,4),()
set(1 5)</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以在这种情况下，算法很简单（在这种情况下，我只是覆盖行，列和方形代码基本相同）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @updates;
for ^9 -&gt; $idx {
    my $only = [(^)] row($idx).map( -&gt; ( $x,$y ) {
        possible($x,$y,@game)
    } );
    for $only.keys -&gt; $val {
        for row($idx) -&gt; ($x,$y) {
            if $val (elem) possible($x,$y,@game) {
                @updates.push( ($x,$y) =&gt; $val );
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们可以遍历与上面类似的更新数组。结合这两种算法可以自己解决大量的数独难题并简化其他难题。</p>
</div>
<div class="paragraph">
<p>请注意，我们必须进行两次传球，首先我们得到我们正在查找的数字，然后我们必须查看每一行并找出数字出现的位置。为此，我们使用（elem）运算符。集合也可以使用关联引用来引用，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say set(1,5){1}
True</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_关于对象的说明">19.3. 关于对象的说明</h3>
<div class="paragraph">
<p>因此，迄今为止所有的例子都使用了基本整数。但是没有任何东西阻止你在连接和集合中使用对象。有几件事要记住，虽然，集合使用===身份运算符进行测试。大多数对象都不能通过身份检查，除非你已经克隆了它们或者已经定义了WHICH方法以便能够进行比较。</p>
</div>
<div class="paragraph">
<p>对于数独谜题，您可能需要创建一个CellValue类，用于存储该数字是否为谜题中的初始值之一。如果你这样做，尽管你需要覆盖WHICH并使其返回Cell的Integer值。只要你在这种情况下身体检查技术无效（两个不同的CellValues可能具有相同的值，但不会是同一个对象），那么你可以将它们放入集合中。</p>
</div>
<div class="paragraph">
<p>我希望你已经发现了这个有趣的东西，Junctions和Sets是Raku的许多不同部分中的两个，它们可以帮助你轻松完成复杂的任务。如果您对代码感兴趣，可以使用以下基于对象的版本进行安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install Game::Sudoku</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十二天_raku_d_的特性">20. <a href="https://rakuadvent.wordpress.com/2017/12/22/day-22-features-of-perl-6-d/">第二十二天-Raku.d 的特性</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>所以我们就是这样。 Rakudo Raku第一次正式发布两年后，或者更准确的说是6.c。自从马特奥茨从那时起就开始关注性能的提升之后，圣诞老人认为要对此进行对比，描述自那时起实施的6.d的新功能。因为有很多，圣诞老人不得不做出选择。</p>
</div>
<div class="sect2">
<h3 id="_在创建时调整对象">20.1. 在创建时调整对象</h3>
<div class="paragraph">
<p>您创建的任何课程现在都可以使用TWEAK方法。在新的类的新实例的所有其他初始化完成之前，这个方法将被调用。一个简单的，有点人为的例子，其中一个类A有一个属性，默认值是42，但如果在创建对象时指定了默认值，它应该更改该值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    has $.value = 42;
    method TWEAK(:$value = 0) { # default prevents warning
        # change the attribute if the default value is specified
        $!value = 666 if $value == $!value;
    }
}
# no value specified, it gets the default attribute value
dd A.new;              # A.new(value =&gt; 42)

# value specified, but it is not the default
dd A.new(value =&gt; 77); # A.new(value =&gt; 77)

# value specified, and it is the default
dd A.new(value =&gt; 42); # A.new(value =&gt; 666)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_并发性改进">20.2. 并发性改进</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Rakudo Raku的并发功能在引擎盖下看到了许多改进。其中一些暴露为新功能。最显着的是Lock </dt>
<dd>
<p>Async（一个返回Promise的非阻塞锁）和原子操作符。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在大多数情况下，您不需要直接使用它们，但是如果您正在编写使用并发功能的程序，那么您可能知道原子操作符。经常发生的逻辑错误，特别是如果你在Pumpking Perl 5中使用线程，是因为在Rakudo Raku中没有对共享变量的隐式锁定。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my int $a;
    await (^5).map: {
        start { ++$a for ^100000 }
    }
    say $a; # something like 419318</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么为什么没有显示500000？原因是我们有5个线程同时递增相同的变量。由于增量由读步骤，增量步骤和写步骤组成，因此一个线程与另一个线程同时执行读取步骤变得非常容易。因此失去了一个增量。在我们有原子操作符之前，做上述代码的正确方法是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">   my int $a;
    my $l = Lock.new;
    await (^5).map: {
       start {
           for ^100000 {
               $l.protect( { ++$a } )
           }
       }
    }
    say $a; # 500000</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会给你正确的答案，但速度至少要慢20倍。</p>
</div>
<div class="paragraph">
<p>现在我们有了原子变量，上面的代码就变成了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">   my atomicint $a;
    await (^5).map: {
        start { ++⚛$a for ^100000 }
    }
    say $a; # 500000</code></pre>
</div>
</div>
<div class="paragraph">
<p>这非常类似于原始（不正确）的代码。这至少是使用Lock.protect的正确代码的6倍。</p>
</div>
</div>
<div class="sect2">
<h3 id="_unicode_goodies">20.3. Unicode goodies</h3>
<div class="paragraph">
<p>太多了，太多了。例如，现在可以使用≤，≥，≠作为Unicode版本的⇐，&gt; =和！=（完整列表）。</p>
</div>
<div class="paragraph">
<p>您现在还可以通过指定字形的Unicode名称来创建字形，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;BUTTERFLY&#34;.parse-names; # 🦋</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者在运行时创建Unicode名称字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t = &#34;THUMBS UP SIGN, EMOJI MODIFIER FITZPATRICK TYPE&#34;;
print &#34;$t-$_&#34;.parse-names for 3..6; # 👍🏼👍🏽👍🏾👍🏿</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者整理而不是仅仅排序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># sort by codepoint value
say &lt;ä a o ö&gt;.sort; # (a o ä ö)
# sort using Unicode Collation Algorithm
say &lt;ä a o ö&gt;.collate; # (a ä o ö)</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者使用unicmp而不是cmp：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;a&#34; cmp &#34;Z&#34;; # More
say &#34;a&#34; unicmp &#34;Z&#34;; # Less</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者您现在可以使用任何Unicode数字匹配变量（$ 1为$ 1），负数（-1为-1）和基数基数（：3（“22”）为3（“22”））。</p>
</div>
<div class="paragraph">
<p>圣诞老人认为Rakudo Raku拥有世界上任何编程语言的最佳Unicode支持！</p>
</div>
</div>
<div class="sect2">
<h3 id="_跳过值">20.4. 跳过值</h3>
<div class="paragraph">
<p>您现在可以在Seq和Supply上调用.skip跳过正在生成的多个值。与.head和.tail一起，这给了你Iterables和Supplies充足的操作性。</p>
</div>
<div class="paragraph">
<p>顺便说一下，.head现在也会带一个WhateverCode，所以你可以指明除了最后N以外的所有值（例如.head（*  -  3）会给你除了最后三个以外的所有值）。 .tail也是如此（例如.tail（*  -  3）会为您提供除前三个之外的所有值）。</p>
</div>
<div class="paragraph">
<p>对迭代器角色的一些补充使得迭代器可以更好地支持.skip功能。如果一个迭代器可以更有效地跳过一个值而不是实际产生它，它应该实现skip-one方法。派生于此的是可以由迭代器提供的跳过至少和跳过至少拉一个方法。</p>
</div>
<div class="paragraph">
<p>使用.skip查找第1000个素数的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (^Inf).grep(*.is-prime)[999]; # 7919</code></pre>
</div>
</div>
<div class="paragraph">
<p>与</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (^Inf).grep(*.is-prime).skip(999).head; # 7919</code></pre>
</div>
</div>
<div class="paragraph">
<p>后者的CPU效率略高一些，但更重要的是内存效率更高，因为它不需要保留内存中的前999个素数。</p>
</div>
</div>
<div class="sect2">
<h3 id="_of_bufs_and_blobs">20.5. Of Bufs and Blobs</h3>
<div class="paragraph">
<p>Buf变得更像一个Array，因为它现在支持.push，.append，.pop，.unshift，.prepend，.shift和.splice。它也变得更像Str，增加了一个subbuf-rw（类似于.substr-rw），例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $b = Buf.new(100..105);
$b.subbuf-rw(2,3) = Blob.new(^5);
say $b.perl; # Buf.new(100,101,0,1,2,3,4,105)</code></pre>
</div>
</div>
<div class="paragraph">
<p>您现在也可以使用给定数量的元素和模式来分配Buf或Blob。或者用.reallocate改变Buf的大小：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $b = Buf.allocate(10,(1,2,3));
say $b.perl; # Buf.new(1,2,3,1,2,3,1,2,3,1)
$b.reallocate(5);
say $b.perl; # Buf.new(1,2,3,1,2)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_测试测试测试">20.6. 测试，测试，测试！</h3>
<div class="paragraph">
<p>Test.pm的计划子例程现在还采用可选的：skip-all参数来指示文件中的所有测试都应该跳过。或者您可以拨打救助中止测试运行，将其标记为失败。或者将PERL6_TEST_DIE_ON_FAIL环境变量设置为真值，以指示您希望测试一旦第一次测试失败就立即结束。</p>
</div>
</div>
<div class="sect2">
<h3 id="_这是怎么回事">20.7. 这是怎么回事</h3>
<div class="paragraph">
<p>您现在可以通过调用Kernel.cpu-cores来反思计算机中CPU内核的数量。程序启动后使用的CPU数量在Kernel.cpu-usage中可用，但您可以使用VM.osname轻松检查操作系统的名称。</p>
</div>
<div class="paragraph">
<p>就好像这还不够，还有一个新的遥测模块，您需要在需要时加载，就像测试模块一样。遥测模块提供了许多可直接使用的基元，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Telemetry;
say T&lt;wallclock cpu max-rss&gt;; # (138771 280670 82360)</code></pre>
</div>
</div>
<div class="paragraph">
<p>它显示自程序启动以来的微秒数，所用CPU的微秒数以及调用时正在使用的内存数量。</p>
</div>
<div class="paragraph">
<p>如果你想得到你的程序中发生的事情的报告，你可以使用管理单元，并在程序完成时显示报告。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Telemetry;
snap;
Nil for ^10000000;  # something that takes a bit of time</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果将显示在STDERR上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Telemetry Report of Process #60076
Number of Snapshots: 2
Initial/Final Size: 82596 / 83832 Kbytes
Total Time:           0.55 seconds
Total CPU Usage:      0.56 seconds
No supervisor thread has been running

wallclock  util%  max-rss
   549639  12.72     1236
--------- ------ --------
   549639  12.72     1236

Legend:
wallclock  Number of microseconds elapsed
    util%  Percentage of CPU utilization (0..100%)
  max-rss  Maximum resident set size (in Kbytes)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想要每秒1次的程序状态，你可以使用snapper：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Telemetry;
snapper;
Nil for ^10000000;  # something that takes a bit of time</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Telemetry Report of Process #60722
Number of Snapshots: 7
Initial/Final Size: 87324 / 87484 Kbytes
Total Time:           0.56 seconds
Total CPU Usage:      0.57 seconds
No supervisor thread has been running

wallclock  util%  max-rss
   103969  13.21      152
   101175  12.48
   101155  12.48
   104097  12.51
   105242  12.51
    44225  12.51        8
--------- ------ --------
   559863  12.63      160

Legend:
wallclock  Number of microseconds elapsed
    util%  Percentage of CPU utilization (0..100%)
  max-rss  Maximum resident set size (in Kbytes)</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有更多选项可用，例如以.csv格式获取输出。</p>
</div>
</div>
<div class="sect2">
<h3 id="_main_函数">20.8. MAIN 函数</h3>
<div class="paragraph">
<p>您现在可以通过设置％* SUB-MAIN-OPTS中的选项来修改MAIN参数的处理方式。默认的USAGE消息现在可以在MAIN中作为$ * USAGE动态变量使用，所以如果你愿意，你可以改变它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_嵌入_raku">20.9. 嵌入 Raku</h3>
<div class="paragraph">
<p>两个新功能使嵌入Rakudo Raku更易于处理：
现在可以设置＆* EXIT动态变量来指定调用exit（）时要执行的操作。</p>
</div>
<div class="paragraph">
<p>将环境变量RAKUDO_EXCEPTIONS_HANDLER设置为“JSON”将引发JSON中的异常，而不是文本，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ RAKUDO_EXCEPTIONS_HANDLER=JSON raku -e &#39;42 = 666&#39;
{
  &#34;X::Assignment::RO&#34; : {
    &#34;value&#34; : 42,
    &#34;message&#34; : &#34;Cannot modify an immutable Int (42)&#34;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_礼品袋的底部">20.10. 礼品袋的底部</h3>
<div class="paragraph">
<p>在翻看仍然相当完整的礼品袋的同时，圣诞老人发现了以下较小的惊悚片：</p>
</div>
<div class="paragraph">
<p>本地字符串数组现在实现（我的str @a）
IO :: CatHandle允许您将多个数据源抽象为单个虚拟IO :: Handle
parse-base（）执行base（）的相反操作</p>
</div>
</div>
<div class="sect2">
<h3 id="_赶上雪橇的时间">20.11. 赶上雪橇的时间</h3>
<div class="paragraph">
<p>圣诞老人想留下来告诉你更多有关已添加的内容，但是没有足够的时间来做到这一点。如果您真的想了解新功能的最新情况，您应该查看Changelog中的Additions部分，这些部分随每个Rakudo编译器版本一起更新。</p>
</div>
<div class="paragraph">
<p>所以，明年再来抓你！</p>
</div>
<div class="paragraph">
<p>来自美好的祝福</p>
</div>
<div class="paragraph">
<p>🎅🏾</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十三天_raku_高尔夫">21. <a href="https://rakuadvent.wordpress.com/2017/12/23/day-23-the-wonders-of-raku-golf/">第二十三天-Raku 高尔夫</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>啊，圣诞节！还有什么比和你的朋友与家人一起坐在桌子旁边玩高尔夫球代码还好呢！ …​等等，什么？</p>
</div>
<div class="paragraph">
<p>哦，对，这还不是圣诞节。但是你可能想要为它做好准备！</p>
</div>
<div class="paragraph">
<p>如果你还没有注意到，有一个不错的网站可以玩高尔夫球代码：<a href="https://code-golf.io/">https://code-golf.io/</a>。这个网站很酷的地方是，它不仅仅只支持 perl 6！在撰写本文时，它还支持其他 6 种语言。嗯…​</p>
</div>
<div class="paragraph">
<p>无论如何，因为我在那个网站的成绩还不错，我会分享一些我觉得最好的解决方案。所有的 trickety-hackety，unicode-cheatery 和 mind-blowety。在我们看来，也许我们甚至会看到即使在代码高尔夫中，perl 6 也非常<a href="https://raw.githubusercontent.com/raku/marketing/master/TablePosters/6lang-Concise/v1—​6lang-Concise—​square.png">简洁</a>易读。也就是说，如果你很难将你的圣诞愿望放在一张卡片上，那么可能会放得下一行 perl 6 代码。</p>
</div>
<div class="paragraph">
<p>我不会提供完整的解决方案，不会破坏你的圣诞乐趣，但我会给你足够的提示，以提出有竞争力的解决方案。</p>
</div>
<div class="paragraph">
<p>这个圣诞节我就是想让你得到一些乐趣。所以你先下载一份 <a href="https://raku.org/downloads/">rakudo</a>，以确保你可以跟随。稍后我们会有一些南瓜派，我们会<a href="https://www.youtube.com/watch?v=Y51JyG7M3dw#t=26s">做一些颂歌</a>。如果您在运行 perl 6 时遇到任何问题，可以在 freenode 上加入 <a href="https://docs.raku.org/webchat.html">＃raku 频道</a>以获得一些帮助。这就是说，<a href="https://code-golf.io/">https://code-golf.io/</a> 本身为你提供了一个很好的编辑器来编写和评估你的代码，所以应该没有问题。</p>
</div>
<div class="sect2">
<h3 id="_一些基本的例子">21.1. 一些基本的例子</h3>
<div class="paragraph">
<p>让我们以<a href="https://code-golf.io/pascals-triangle">帕斯卡三角形</a>任务为例。我听到了，我听到了！圣诞节前的数学，这太残酷了。残忍，但很有必要。</p>
</div>
<div class="paragraph">
<p>只有一个你必须知道的基本技巧。如果从 Pascal 三角形中取出任何一行，将它移动一个元素，然后用原始行对结果进行 zip-sum，就会得到下一行！</p>
</div>
<div class="paragraph">
<p>所以如果你有一行数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">1 3 3 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>你所做的只是把它移到右边：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">0 1 3 3 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>并将其与原始行相加：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">1 3 3 1
+ + + +
0 1 3 3 1
=
1 4 6 4 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>就是如此容易！所以我们还是写代码吧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for ^16 { put (+combinations($^row,$_) for 0..$row) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>你看！简单的很！</p>
</div>
<div class="paragraph">
<p>哦…​…​等等，这有一个完全不同的解决方案。好吧，让我们来看看：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.put for 1, { |$_,0 Z+ 0,|$_ } ... 16</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
1 6 15 20 15 6 1
1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1
1 9 36 84 126 126 84 36 9 1
1 10 45 120 210 252 210 120 45 10 1
1 11 55 165 330 462 462 330 165 55 11 1
1 12 66 220 495 792 924 792 495 220 66 12 1
1 13 78 286 715 1287 1716 1716 1287 715 286 78 13 1
1 14 91 364 1001 2002 3003 3432 3003 2002 1001 364 91 14 1
1 15 105 455 1365 3003 5005 6435 6435 5005 3003 1365 455 105 15 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>啊哈！ 我们做到了。 所以究竟是怎么回事儿？ 那么，在 perl 6 中，你可以用一个非常简单的语法创建 <code>2,4,8 …​ ∞</code> 这样的序列。 通常你会让它自己计算序列，但你也可以提供一个代码块来求值。 这太棒了！ 在其他语言中，你经常需要一个带有状态变量的循环，而序列操作符为你做了所有的事情！ 这个功能可能单独需要一篇<a href="https://raku.party/post/Perl-6-Seqs-Drugs-and-Rock-n-Roll">文章</a>或<a href="https://raku.party/post/Perl-6-Seqs-Drugs-and-Rock-n-Roll—​Part-2">𝍪</a>。</p>
</div>
<div class="paragraph">
<p>其余的只是一个 for 循环和 <a href="https://docs.raku.org/routine/put">put</a> 调用。 这里唯一的技巧就是理解它使用的是列表，所以当你指定序列的端点时，它实际上是检查元素的数量。 另外，您需要用 <code>|</code> 来展平列表。</p>
</div>
<div class="paragraph">
<p>如果删除空格并应用本文中提到的所有技巧，这应该会让您的字符数为 26。 这相当有竞争力。</p>
</div>
<div class="paragraph">
<p>同样，其他任务通常有相当直接的解决方案。 例如，对于 <a href="https://code-golf.io/evil-numbers">Evil NUmbers</a>，你可以写这样的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.base(2).comb(~1) %% 2 &amp;&amp; .say for ^50</code></pre>
</div>
</div>
<div class="paragraph">
<p>删除一些空格，应用一些技巧，你几乎就达到要求了。</p>
</div>
<div class="paragraph">
<p>我们再举一个例子：<a href="https://code-golf.io/pangram-grep">Pangram Grep</a>。在这里我们可以使用 <a href="https://docs.raku.org/language/setbagmix">set操作符</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">‘a’..‘z’ ⊆ .lc.comb &amp;&amp; .say for @*ARGS</code></pre>
</div>
</div>
<div class="paragraph">
<p>基本上，几乎所有的 perl 6 解决方案看起来都是真正的代码。这是额外的-1角色，需要额外的眼睛疼痛，但你没有来这里听简洁，对吧？是时候变脏了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_numbers">21.2. Numbers</h3>
<div class="paragraph">
<p>让我们来谈谈数字吧！ 1 ² ③ ٤ ⅴ ߆…  <strong>咳嗽</strong>。 你看，在 perl 6 中，任何数字字符（具有相应的数值属性）都可以在源代码中使用。 该功能的目的是让我们得到一些好处，如 ½ 和其他整洁的东西，但这意味着，而不是写 50 你可以写 ㊿。 有些高尔夫平台会以 UTF-8 编码来计算字节数，所以看起来你没有赢得任何东西。 但是 <code>1000000000000</code> 和 ` 𖭡` 呢？ 在任何情况下，<a href="https://code-golf.io/">code-golf.io</a> 都可以识别 unicode，所以这些字符的长度都是 1。</p>
</div>
<div class="paragraph">
<p>所以你可能会想，你能用这种方式写出哪些数字？ 你试试看：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">-0.5 0.00625 0.025 0.0375 0.05 0.0625 0.083333 0.1
0.111111 0.125 0.142857 0.15 0.166667 0.1875 0.2
0.25 0.333333 0.375 0.4 0.416667 0.5 0.583333 0.6
0.625 0.666667 0.75 0.8 0.833333 0.875 0.916667 1
1.5 2 2.5 3 3.5 4 4.5 5 5.5 6 6.5 7 7.5 8 8.5 9 10
11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27
28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44
45 46 47 48 49 50 60 70 80 90 100 200 300 400 500
600 700 800 900 1000 2000 3000 4000 5000 6000 7000
8000 9000 10000 20000 30000 40000 50000 60000 70000
80000 90000 100000 200000 216000 300000 400000
432000 500000 600000 700000 800000 900000 1000000
100000000 10000000000 1000000000000</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着，例如，在某些情况下，如果需要否定结果，则可以节省 1 个字符。有很多方法可以使用，我只会提到一个特定的情况。其余的你自己去找，以及如何找到可用于任何特定值的实际字符（提示：循环所有 0x10FFFF 字符并检查它们的 `.unival`s）。</p>
</div>
<div class="paragraph">
<p>例如，当打高尔夫时，你想略去不必要的空白，所以也许你会想写一些这样的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 5max3  # ERROR</code></pre>
</div>
</div>
<div class="paragraph">
<p>这当然不起作用，我们也不能责怪编译器没有解决这个混乱问题。但是，试试这个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ⑤max③  # OUTPUT: «5␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>哇噢！这在许多其他情况下会起作用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_条件">21.3. 条件</h3>
<div class="paragraph">
<p>如果有很好的高尔夫语言，但不是 Raku. 我的意思是，看看这个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">puts 10&lt;30?1:2   # ruby</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10 &lt;30??1!!2 # perl 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 的三元操作符不仅多需要俩个字符，而且 <code>&lt;</code> 运算符周围还要有一些必要的的空白字符！他们有什么问题，对吧？他们怎么敢设计一种无代码高尔夫语言?!</p>
</div>
<div class="paragraph">
<p>那么，我们可以通过某些方法解决它。其中之一是链式操作符。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 5&gt;3&gt;say(42)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 5≤3，则不需要进行其他比较，因此它不会运行它。这样我们可以节省至少一个字符。在略有相关的说明中，请记住，junctions 也可能派上用场：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ‘yes!’ if 5==3|5</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，不要忘记 unicode 操作符：<code>≥</code>，<code>≤</code>，<code>≠</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_打字很难让我们使用一些预定义的字符串">21.4. 打字很难，让我们使用一些预定义的字符串！</h3>
<div class="paragraph">
<p>你不会相信这有时是多么的有用。想要打印所有棋子的名字？好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (‘♔’…‘♙’)».uniname».words»[2]
#   KING QUEEN ROOK BISHOP KNIGHT PAWN</code></pre>
</div>
</div>
<div class="paragraph">
<p>这仅仅节省了几个字符，但有时可以将解决方案的大小减半。但是，不要停在那里，想想错误消息，方法名称等。你还能挽回什么？</p>
</div>
</div>
<div class="sect2">
<h3 id="_base_16_base_36_nah_base_0x10ffff">21.5. Base 16? Base 36? Nah, Base 0x10FFFF!</h3>
<div class="paragraph">
<p><a href="https://code-golf.io/φ">其中一项任务</a>告诉我们打印 φ 的前1000个小数位。那么，这很容易！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ‘1.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911374847540880753868917521266338622235369317931800607667263544333890865959395829056383226613199282902678806752087668925017116962070322210432162695486262963136144381497587012203408058879544547492461856953648644492410443207713449470495658467885098743394422125448770664780915884607499887124007652170575179788341662562494075890697040002812104276217711177780531531714101170466659914669798731761356006708748071013179523689427521948435305678300228785699782977834784587822891109762500302696156170025046433824377648610283831268330372429267526311653392473167111211588186385133162038400522216579128667529465490681131715993432359734949850904094762132229810172610705961164562990981629055520852479035240602017279974717534277759277862561943208275051312181562855122248093947123414517022373580577278616008688382952304592647878017889921990270776903895321968198615143780314997411069260886742962267575605231727775203536139362’</code></pre>
</div>
</div>
<div class="paragraph">
<p>是的！！！</p>
</div>
<div class="paragraph">
<p>好吧，这需要 1000 多个字符…​…​当然，我们可以尝试计算它，但这不完全符合<a href="https://rakuadvent.wordpress.com/2017/12/01/">圣诞节的精神</a>。我们想作弊。</p>
</div>
<div class="paragraph">
<p>如果我们看一下 <a href="https://docs.raku.org/type/Int#method_polymod">polymod</a> 的文档，有一点提示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @digits-in-base37 = 9123607.polymod(37 xx *); # Base conversion</code></pre>
</div>
</div>
<div class="paragraph">
<p>嗯…​…​这样就给了我们任意数量的数字。我们可以走多高？那么，这取决于我们想要存储数字的形式。鉴于 code-golf.io 计算码位，我们可以使用base 0x10FFFF（即使用所有可用的码位）。或者，在这种情况下，我们将使用base 0x10FFFE，<a href="https://docs.raku.org/language/traps#All_Text_is_Normalized_By_Default">因为</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">☠☠☠⚠⚠⚠ WARNING! WARNING! WARNING! ⚠⚠⚠☠☠☠
THIS WILL MAKE YOUR COMPUTER IMPLODE!
UNICODE STRINGS ARE SUBJECT TO NORMALIZATION SO YOUR
DATA WILL NOT BE PRESERVED. HIDE YOUR KIDS, HIDE YOUR
WIFE. HIDE YOUR KIDS, HIDE YOUR WIFE. HIDE YOUR KIDS,
HIDE YOUR WIFE. AND HIDE YOUR HUSBAND.
☠☠☠⚠⚠⚠ WARNING! WARNING! WARNING! ⚠⚠⚠☠☠☠</code></pre>
</div>
</div>
<div class="paragraph">
<p>当应用于我们的常数时，它应该给出这样的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">󻁾񤍠򷒋󜹕󘶸񙦅񨚑򙯬񗈼𢍟𪱷򡀋𢕍򌠐񘦵𔇆򅳒򑠒󌋩򯫞򶝠򚘣򣥨񫵗𿞸􋻩񱷳󟝐󮃞󵹱񿢖𛒕𺬛󊹛󲝂򺗝𭙪񰕺𝧒򊕆𘝞뎛􆃂򊥍񲽤򩻛󂛕磪󡯮끝򰯬󢽈󼿶󘓥򮀓񽑖򗔝󃢖񶡁􁇘󶪼񌍌񛕄񻊺򔴩寡񿜾񿸶򌰘񡇈򦬽𥵑󧨑򕩃򳴪񾖾򌯎󿥐񱛦𱫞𵪶򁇐󑓮򄨠򾎹𛰑𗋨䨀򡒶𰌡򶟫񦲋𧮁􍰍񲍚񰃦𦅂󎓜󸾧󉦩󣲦򄉼񿒣𸖉񿡥󬯞嗟𧽘񿷦򠍍🼟򇋹񖾷𖏕񟡥󜋝􋯱񤄓򭀢򌝓𱀉𫍡󬥝򈘏򞏡񄙍𪏸࿹𺐅񢻳򘮇𐂇񘚡ந򾩴󜆵𰑕򰏷񛉿򢑬򭕴𨬎󴈂􋵔򆀍񖨸􂳚󽡂󎖪񡉽񕧣񎗎򝤉򡔙񆔈󖾩󅾜񋩟򝼤񯓦󐚉񟯶򄠔𦔏򲔐o</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们如何翻转操作？在其中一次 <a href="https://github.com/rakudo/rakudo/wiki/Monthly-Bug-Squash-Day">squashathons</a> 我找到一张关于我以前不知道的功能的票。基本上，票据说 Rakudo 正在做它不应该做的事情，这当然是我们下一次会被滥用的事情。但现在我们处于相对理智的范围之内：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ‘1.’,:1114110[‘o򲔐𦔏򄠔񟯶󐚉񯓦򝼤񋩟󅾜󖾩񆔈򡔙򝤉񎗎񕧣񡉽󎖪󽡂􂳚񖨸򆀍􋵔󴈂𨬎򭕴򢑬񛉿򰏷𰑕󜆵򾩴ந񘚡𐂇򘮇񢻳𺐅࿹𪏸񄙍򞏡򈘏󬥝𫍡𱀉򌝓򭀢񤄓􋯱󜋝񟡥𖏕񖾷򇋹🼟򠍍񿷦𧽘嗟󬯞񿡥𸖉񿒣򄉼󣲦󉦩󸾧󎓜𦅂񰃦񲍚􍰍𧮁񦲋򶟫𰌡򡒶䨀𗋨𛰑򾎹򄨠󑓮򁇐𵪶𱫞񱛦󿥐򌯎񾖾򳴪򕩃󧨑𥵑򦬽񡇈򌰘񿸶񿜾寡򔴩񻊺񛕄񌍌󶪼􁇘񶡁󃢖򗔝񽑖򮀓󘓥󼿶󢽈򰯬끝󡯮磪󂛕򩻛񲽤򊥍􆃂뎛𘝞򊕆𝧒񰕺𭙪򺗝󲝂󊹛𺬛𛒕񿢖󵹱󮃞󟝐񱷳􋻩𿞸񫵗򣥨򚘣򶝠򯫞󌋩򑠒򅳒𔇆񘦵򌠐𢕍򡀋𪱷𢍟񗈼򙯬񨚑񙦅󘶸󜹕򷒋񤍠󻁾’.ords]</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，字符串必须相反。除此之外，它看起来非常好。 192 个字符包括解码器。</p>
</div>
<div class="paragraph">
<p>这对于打印另外可计算的常量来说并不是一个好主意，但考虑到解码器的长度和数据的相对密集的打包率，这在其他任务中很方便。</p>
</div>
</div>
<div class="sect2">
<h3 id="_所有的好事都必须结束可怕的事情_更是如此">21.6. 所有的好事都必须结束;可怕的事情 - 更是如此</h3>
<div class="paragraph">
<p>这是关于这篇文章的。更多代码高尔夫技巧我已经启动了这个存储库：<a href="https://github.com/AlexDaniel/6lang-golf-cheatsheet">https://github.com/AlexDaniel/6lang-golf-cheatsheet</a></p>
</div>
<div class="paragraph">
<p>希望能在 <a href="https://code-golf.io/">https://code-golf.io/</a> 上看到你！无论是否使用 perl 6，我都希望看到我提交的所有内容都被打败了。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十四天_解魔方">22. <a href="https://rakuadvent.wordpress.com/2017/12/24/">第二十四天-解魔方</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_介绍_2">22.1. 介绍</h3>
<div class="paragraph">
<p>我在圣诞节的愿望清单上有一个速度魔方，我真的很兴奋。 :)我想分享一些Raku代码的热情。</p>
</div>
<div class="paragraph">
<p>我在89年从高中毕业，所以我恰好是在青少年时期拥有魔方的合适年龄。我记得试图在巴士上炫耀，让我的时间缩短到不到一分钟。我在80年代从当地的一家玩具店拿到了一本小册子，其中展示了一个关于如何解决我记忆的立方体的算法。我再也没有这本小册子了。多年来我一直坚持，但从来没有达到竞争水平。</p>
</div>
<div class="paragraph">
<p>在过去的几个月里，YouTube根据我对立体声频道的兴趣，向我推荐了一些立方体视频;看到世界纪录在5秒以内，使我一分钟的旧时间看起来很慢。</p>
</div>
<div class="paragraph">
<p>我所讲过的每个人都可以解决魔方问题，他们使用的算法与我所学的算法不同，而在立体魔法中讨论的方法却与众不同。不过，这种先进的版本似乎被定期制定世界记录的人们普遍使用。</p>
</div>
<div class="paragraph">
<p>拾取这个算法并不难，我找到了几个视频，尤其是描述如何解决最后一层的视频。这样做了几天之后，我将步骤转录为几个笔记，其中列出了步骤列表，以及每个步骤的关键部分：所需的方向，然后是该步骤的各个转弯。然后，我可以参考我的笔记本的一个页面，而不是一个30分钟的视频，并且在几天后，记住了以下步骤：能够从记谱法移动到仅仅做这些移动是一个很大的加速。</p>
</div>
<div class="paragraph">
<p>一周后，我能够在两分钟内使用新方法可靠地解决问题;退后一步，但在休息时间里一周的努力并不坏。从那以后（几个星期后），我一直下到1:20以下。再次，这是初学者的方法，没有任何先进的技术，而且我可以在不查看立方体的情况下完成各个算法步骤。 （尽管如此，我仍然有很长的路要走。）</p>
</div>
</div>
<div class="sect2">
<h3 id="_符号">22.2. 符号</h3>
<div class="paragraph">
<p>关于移动符号的快速注释 - 考虑到您将立方体的一边保持在顶部，一边朝向您，相对边是：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>L (Left) R (Right) U (Up) D (Down) F (Front) B (Back)</pre>
</div>
</div>
<div class="paragraph">
<p>如果在步骤中看到一个单独的字母，如B，则表示顺时针转动该面（相对于立方体的中心，而不是您）。如果你在信里加了一个&#39;&#39;，那就意味着逆时针方向，所以R’会让最上面的部分下来，而R会让底部的部分出现。</p>
</div>
<div class="paragraph">
<p>此外，您可能必须翻转两次，写成U2; （顺时针或逆时针无关紧要，因为它从起点开始为180º。）</p>
</div>
</div>
<div class="sect2">
<h3 id="_算法">22.3. 算法</h3>
<div class="paragraph">
<p>我正在使用的初学者算法有以下基本步骤：</p>
</div>
<div class="paragraph">
<p>1.白色十字架2.白色拐角3.第二层4.黄色十字架5.黄色边缘6.黄色拐角7.定位黄色拐角</p>
</div>
<div class="paragraph">
<p>如果您对每个步骤的具体内容感到好奇，您可以浏览Rubik的wiki或上面链接的YouTube视频。该算法的更高级版本（由Jessica Fridrich提供的CFOP）允许您合并步骤，具有处理特定立方体状态的特定“快捷方式”，或者解决任何颜色作为第一面，而不仅仅是白色。</p>
</div>
</div>
<div class="sect2">
<h3 id="_设计一个模块">22.4. 设计一个模块</h3>
<div class="paragraph">
<p>当我开始研究这个模块时，我知道我希望能够以某种熟悉算法的人熟悉的方式展示每一步所需的位置，并且让各个步骤也是自然的，就像是：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>F.R.U.Rʼ.Uʼ.Fʼ</pre>
</div>
</div>
<div class="paragraph">
<p>我也希望能够转储立方体的现有状态;现在作为文本，但最终也能够将其与视觉表示相结合，</p>
</div>
<div class="paragraph">
<p>我们需要能够判断立方体是否已解决;我们需要能够检查相对于当前方向的棋子，并且能够改变我们的方向。</p>
</div>
<div class="paragraph">
<p>由于我要开始渲染立方体状态的能力，然后快速添加转向两侧的能力，我选择了一个内部结构，使其变得相当容易。</p>
</div>
</div>
<div class="sect2">
<h3 id="_代码">22.5. 代码</h3>
<div class="paragraph">
<p>github上提供了该模块的最新版本。这里介绍的代码来自最初的版本。</p>
</div>
<div class="paragraph">
<p>Raku允许您创建Enumerations，因此您可以在代码中使用实际的单词而不是查找值，所以让我们从一些我们需要的内容开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Side «:Up(&#39;U&#39;) :Down(&#39;D&#39;) :Front(&#39;F&#39;) :Back(&#39;B&#39;) :Left(&#39;L&#39;) :Right(&#39;R&#39;)»;
enum Colors «:Red(&#39;R&#39;) :Green(&#39;G&#39;) :Blue(&#39;B&#39;) :Yellow(&#39;Y&#39;) :White(&#39;W&#39;) :Orange(&#39;O&#39;)»;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这个语法，我们可以直接在我们的代码中使用Up，并且它的关联值是U.</p>
</div>
<div class="paragraph">
<p>我们需要一个类，以便我们可以存储属性并拥有方法，所以我们的类定义具有：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Cube::Three {
    has %!Sides;
    ...
    submethod BUILD() {
        %!Sides{Up}    = [White  xx 9];
        %!Sides{Front} = [Red    xx 9];
        ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们有一个属性，一个叫做％.Sides的Hash;每个键对应于其中一个Enum边。该值是Colors的9元素数组。数组上的每个元素对应于立方体上的一个位置。默认情况下，顶部的白色和正面的红色将在此处显示颜色和单元格位置，并带有数字和颜色。 （白色，红色是前面）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">         W0 W1 W2
         W3 W4 W5
         W6 W7 W8
G2 G5 G8 R2 R5 R8 B2 B5 B8 O2 O5 O8
G1 G4 G7 R1 R4 R7 B1 B4 B7 O1 O4 O7
G0 G3 G6 R0 R3 R6 B0 B3 B6 B0 B3 B6
         Y0 Y1 Y2
         Y3 Y4 Y5
         Y6 Y7 Y8</code></pre>
</div>
</div>
<div class="paragraph">
<p>我添加的第一种方法是做每个脸部顺时针转动。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method F {
    self!rotate-clockwise(Front);
    self!fixup-sides([
        Pair.new(Up,    [6,7,8]),
        Pair.new(Right, [2,1,0]),
        Pair.new(Down,  [2,1,0]),
        Pair.new(Left,  [6,7,8]),
    ]);
    self;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个公共方法调用两个私有方法（用！表示）;一个顺时针方向旋转一个侧面，第二个取对的列表，其中键是一个侧面，并且该值是一个位置列表。如果您想象顺时针旋转立方体的顶部，您可以看到位置正在从一个换成另一个。</p>
</div>
<div class="paragraph">
<p>请注意，我们从方法中返回自己;这允许我们按照原始设计中的方式调用方法调用。</p>
</div>
<div class="paragraph">
<p>单面的顺时针旋转显示正在传递的原始面，并使用阵列切片来改变原始面的顺序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># 0 1 2    6 3 0
# 3 4 5 -&gt; 7 4 1
# 6 7 8    8 5 2
method !rotate-clockwise(Side \side) {
    %!Sides{side}[0,1,2,3,5,6,7,8] = %!Sides{side}[6,3,0,7,1,8,5,2];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要为移动添加其余的符号，我们添加一些简单的包装方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method F2 { self.F.F; }
method Fʼ { self.F.F.F; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>F2只需要移动两次; F’作弊：3个权利左转。</p>
</div>
<div class="paragraph">
<p>在这一点上，我必须确保我的回合正在做他们应该做的事情，所以我添加了一个gist方法（当一个对象用say输出时被调用）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Cube::Three.new.U2.D2.F2.B2.R2.L2;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">      W Y W
      Y W Y
      W Y W
G B G R O R B G B O R O
B G B O R O G B G R O R
G B G R O R B G B O R O
      Y W Y
      W Y W
      Y W Y</code></pre>
</div>
</div>
<div class="paragraph">
<p>gist 的源代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method gist {
    my $result;
    $result = %!Sides{Up}.rotor(3).join(&#34;\n&#34;).indent(6);
    $result ~= &#34;\n&#34;;

    for 2,1,0 -&gt; $row {
        for (Left, Front, Right, Back) -&gt; $side {
            my @slice = (0,3,6) &gt;&gt;+&gt;&gt; $row;
            $result ~= ~%!Sides{$side}[@slice].join(&#39; &#39;) ~ &#39; &#39;;
        }
        $result ~= &#34;\n&#34;;
    }
    $result ~= %!Sides{Down}.rotor(3).join(&#34;\n&#34;).indent(6);
    $result;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有几件事要注意：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用.rotor（3）将9单元阵列分解为3个3单元列表。</p>
</li>
<li>
<p>.indent（6）预先在Up和Down两边加上空格。</p>
</li>
<li>
<p>（0,3,6）&gt;&gt; + &gt;&gt; $ row，这会增加列表中的每个值</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个要点非常适合逐步检查，但为了调试，我们需要一些更紧凑的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method dump {
    gather for (Up, Front, Right, Back, Left, Down) -&gt; $side {
        take %!Sides{$side}.join(&#39;&#39;);
    }.join(&#39;|&#39;);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将按照特定的顺序在边上迭代，然后使用gather take语法收集每一边的字符串表示形式，然后使用|将它们连接在一起。现在我们可以编写像：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Test; use Cube::Three;
my $a = Cube::Three.new();
is $a.R.U2.Rʼ.Uʼ.R.Uʼ.Rʼ.Lʼ.U2.L.U.Lʼ.U.L.dump,
    &#39;WWBWWWWWB|RRRRRRRRW|BBRBBBBBO|OOWOOOOOO|GGGGGGGGG|YYYYYYYYY&#39;,
    &#39;corners rotation&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这实际上是算法最后一步中使用的方法。通过这个调试输出，我可以拍摄一个原始的立方体，自己动手，然后将生成的立方体状态快速转录成字符串进行测试。</p>
</div>
<div class="paragraph">
<p>虽然计算机不一定需要旋转立方体，但如果我们可以旋转立方体，则会更容易遵循该算法，因此我们为六个可能的旋转中的每一个添加一个，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method rotate-F-U {
     self!rotate-clockwise(Right);
     self!rotate-counter-clockwise(Left);

     # In addition to moving the side data, have to
     # re-orient the indices to match the new side.
     my $temp = %!Sides{Up};
     %!Sides{Up}    = %!Sides{Front};
     self!rotate-counter-clockwise(Up);
     %!Sides{Front} = %!Sides{Down};
     self!rotate-clockwise(Front);
     %!Sides{Down}  = %!Sides{Back};
     self!rotate-clockwise(Down);
     %!Sides{Back}  = $temp;
     self!rotate-counter-clockwise(Back);
     self;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们将立方体从正面转到向上时，我们将左侧和右侧旋转到位。由于细胞的方向随着我们改变面部而改变，因为我们从面部到面部复制细胞，我们也可能需要旋转它们以确保它们最终以正确的方向朝向。和以前一样，我们返回自我以允许方法链接。</p>
</div>
<div class="paragraph">
<p>在我们开始测试时，我们需要确保我们可以知道何时立方体已解决;我们不关心立方体的方向，所以我们验证中心颜色与脸上的所有其他颜色相匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method solved {
    for (Up, Down, Left, Right, Back, Front) -&gt; $side {
        return False unless
            %!Sides{$side}.all eq %!Sides{$side}[4];
    }
    return True;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于每一侧，我们使用一侧的所有颜色的交界处与中心细胞进行比较（总是位置4）。我们很早就失败了，只有通过所有方面才能成功。</p>
</div>
<div class="paragraph">
<p>接下来，我添加了一种方法来搅乱魔方，所以我们可以考虑实施一种解决方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method scramble {
    my @random = &lt;U D F R B L&gt;.roll(100).squish[^10];
    for @random -&gt; $method {
        my $actual = $method ~ (&#34;&#34;, &#34;2&#34;, &#34;ʼ&#34;).pick(1);
        self.&#34;$actual&#34;();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这需要六个基本方法名称，挑选一堆随机值，然后挤压它们（确保连续没有模糊），然后选取前10个值。然后，我们可能会添加一个2或&#39;。最后，我们使用间接方法语法按名称调用各个方法。</p>
</div>
<div class="paragraph">
<p>最后，我准备好开始解决问题了！这就是事情变得复杂的地方。初学者方法的第一步经常被描述为直观的。这意味着它很容易解释…​…​但不容易编码。所以，扰流警报，截至本文发布时，解决的第一步就完成了。对于第一步的完整算法，请查看链接的github网站。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method solve {
    self.solve-top-cross;
}

method solve-top-cross {
    sub completed {
        %!Sides{Up}[1,3,5,7].all eq &#39;W&#39; &amp;&amp;
        %!Sides{Front}[5] eq &#39;R&#39; &amp;&amp;
        %!Sides{Right}[5] eq &#39;B&#39; &amp;&amp;
        %!Sides{Back}[5]  eq &#39;O&#39; &amp;&amp;
        %!Sides{Left}[5]  eq &#39;G&#39;;
    }
    ...
    MAIN:
    while !completed() {
        # Move white-edged pieces in second row up to top

        # Move incorrectly placed pieces in the top row to the middle

        # Move pieces from the bottom to the top
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意非常具体的检查，看看我们是否完成;我们使用一个词汇子来弥补复杂性 - 虽然我们在这里有一个相当内部的检查，但是我们可以看到，我们可能想要将这个抽象描述为可以说“这个边缘部分是正确的”。首先，我们将坚持单个单元格。</p>
</div>
<div class="paragraph">
<p>目前解决十字架的内容长达100多行，所以我不会经历所有的步骤。这是“简单”部分</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @middle-edges =
    [Front, Right],
    [Right, Back],
    [Back,  Left],
    [Left,  Front],
;

for @middle-edges -&gt; $edge {
    my $side7 = $edge[0];
    my $side1 = $edge[1];
    my $color7 = %!Sides{$side7}[7];
    my $color1 = %!Sides{$side1}[1];
    if $color7 eq &#39;W&#39; {
        # find number of times we need to rotate the top:
        my $turns = (
            @ordered-sides.first($side1, :k) -
            @ordered-sides.first(%expected-sides{~$color1}, :k)
        ) % 4;
        self.U for 1..$turns;
        self.&#34;$side1&#34;();
        self.Uʼ for 1..$turns;
        next MAIN;
    } elsif $color1 eq &#39;W&#39; {
        my $turns = (
            @ordered-sides.first($side7, :k) -
            @ordered-sides.first(%expected-sides{~$color7}, :k)
        ) % 4;
        self.Uʼ for 1..$turns;
        self.&#34;$side1&#34;();
        self.U for 1..$turns;
        next MAIN;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在真正的立方体上进行这一部分时，您可以旋转立方体而不考虑侧面部件，然后将十字架放在适当位置。为了让算法更“友好”一点，我们让这些中心保持在这个位置;我们将上侧旋转到位，然后将单个侧面旋转到顶部位置，然后将上侧旋转回原始位置。</p>
</div>
<div class="paragraph">
<p>这里有一些有趣的代码是.first（…​，：k）语法，它说找到匹配的第一个元素，然后返回匹配的位置。然后，我们可以在有序列表中查找事物，以便计算双方的相对位置。</p>
</div>
<div class="paragraph">
<p>请注意，解决方法只调用公共方法来转动立方体;虽然我们使用原始自省来获取立方体状态，但我们只使用“合法”的方式来解决问题。</p>
</div>
<div class="paragraph">
<p>有了这个方法的完整版本，我们现在用这个程序来解决白十字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cube::Three;
my $cube = Cube::Three.new();
$cube.scramble;
say $cube;
say &#39;&#39;;
$cube.solve;
say $cube;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它在给定这组移动的情况下产生这个输出（F’B2B2LR’U’RF’D2B2）。首先是争夺战，然后是解决白十字的版本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">    W G G
      Y W W
      Y Y Y
O O B R R R G B O Y Y B
R G O B R R G B G W O B
Y B B R O W G G G W W O
      W W O
      Y Y O
      B R R

      Y W W
      W W W
      G W R
O G W O R Y B B G R O G
Y G G R R B R B Y R O G
O O R Y O W O O R W Y B
      G G B
      B Y Y
      Y B B</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个例子打印出用来进行争夺的动作，显示乱数立方体，“解决”这个难题（在撰写本文时，它只是白色的十字），然后打印出立方体的新状态。</p>
</div>
<div class="paragraph">
<p>请注意，随着我们的进一步发展，这些步骤变得不那么“直观”，并且根据我的估计，编码更容易。例如，最后一步需要检查四个部分的方向，必要时旋转立方体，然后执行14步移动。 （在上面的测试中显示）。</p>
</div>
<div class="paragraph">
<p>希望我对Cubing和Raku的喜爱让你期待你的下一个项目！</p>
</div>
<div class="paragraph">
<p>对于未来的读者，我将在模块解决完成后的评论中注明。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十五天_圣诞奖金_并发http服务器实施和scripter的方法">23. <a href="https://rakuadvent.wordpress.com/2017/12/25/bonus-xmas-concurrent-http-server-implementation-and-the-scripters-approach/">第二十五天-圣诞奖金 - 并发HTTP服务器实施和scripter的方法</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>首先，我想强调 <a href="http://www.jnthn.net/">Jonathan Worthington</a> 在 <a href="http://rakudo.org/">Rakudo Raku</a> 和 <a href="https://docs.raku.org/type/IO::Socket::Async">IO::Socket::Async</a> 中的工作。谢谢 Jon！</p>
</div>
<div class="paragraph">
<p>我喜欢制作脚本;编写组织良好的动作序列，<strong>获得结果</strong>并对它们进行<strong>处理</strong>。</p>
</div>
<div class="paragraph">
<p>当我从 Raku 开始时，我发现了一个壮观的生态系统，我可以<strong>按照自己喜欢的方式</strong>实践我的想法：<strong>脚本方式</strong>。其中一个想法是实现一个小型的 HTTP 服务器来玩玩。查看与 <strong>Raku</strong>，HTTP 和套接字相关的其他项目和模块，我发现背后的作者是具有<strong>面向对象</strong>编程经验的程序员。</p>
</div>
<div class="sect2">
<h3 id="_raku_范式">23.1. Raku 范式</h3>
<div class="paragraph">
<p>Raku 支持三种最流行的编程范式:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>面向对象</p>
</li>
<li>
<p>函数式</p>
</li>
<li>
<p>过程式</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我认为，当你设计一个<strong>将会增长</strong>的应用程序或服务时，<strong>面向对象</strong>的范式是很好的，它会做许多<strong>不同的事情</strong>并且会有<strong>很多变化</strong>。但我不喜欢那些变化太大，会有很多变化的东西;这就是为什么我喜欢使用原生过程式方法的脚本，因为它能够<strong>快速提升简单性和有效性</strong>。我喜欢小（一步一步）但能快速完成伟大东西的事物。</p>
</div>
<div class="paragraph">
<p><strong>函数式</strong>范式在我看来非常棒;你可以使用一个函数，并像 var 一样使用它，以及其他令人惊讶的事情。</p>
</div>
</div>
<div class="sect2">
<h3 id="_raku_supplies_就像一个_v12_引擎">23.2. Raku Supplies 就像一个 V12 引擎</h3>
<div class="paragraph">
<p>在我开始将 <a href="http://rakuintro.com/">rakuintro.com</a> 翻译成<a href="http://es.rakuintro.com/">西班牙语</a>后不久，我开始使用 Raku。看看 <strong>Raku</strong> 的文档，我发现了 <strong>Raku</strong> 巨大的<strong>并发</strong>潜力。 Raku在<a href="https://docs.raku.org/language/concurrency">并发方面</a>比我想象的更加强大。</p>
</div>
<div class="paragraph">
<p>我使用 <strong>Raku</strong> 的 HTTP 服务器的思想始于 <a href="https://docs.raku.org/type/Supply">Raku Supplies</a>（具有多个订阅者的异步数据流），具体来说就是 <a href="https://docs.raku.org/type/IO::Socket::Async">IO::Socket::Async</a>类。所有的套接字管理，数据传输和并发性实际上都是<strong>自动</strong>且易于理解的。制作并玩一玩小并发但强大的服务是极好的。</p>
</div>
<div class="paragraph">
<p>基于 <a href="https://docs.raku.org/type/IO::Socket::Async">IO::Socket::Async</a> 文档的示例，我开始在 <a href="https://github.com/ramiroencinas/mini-http-cgi-server">mini-http-cgi-server</a> 项目中实现一个支持 pseudoCGI 的小型 HTTP 服务器，并且按照我的预期工作。当我得到我想要的东西时，我很满意，我离开了这个项目一段时间。我不喜欢事情发展太多。</p>
</div>
<div class="paragraph">
<p>但之后，为马德里 <a href="http://madrid.pm.org/workshop">Perl Workshop 2017</a> 做了一次演讲（感谢<a href="http://madrid.pm.org/">马德里 Perl Mongers</a> 和 <a href="http://barcelona.pm/">巴塞罗那 Perl Mongers</a> 团队为这次活动提供的支持），我有足够的动力去做<strong>更实际的</strong>事情，让网络<strong>前端</strong>编码人员可以完成他们的工作并且与 <strong>Raku正在等待的后端</strong>进行交流。一方面是典型的<strong>公共 html 静态结构</strong>，另一方面是一个包含多个 web 服务的 <strong>Raku</strong> 模块，用于等待来自前端人员的 web 请求。</p>
</div>
<div class="paragraph">
<p>然后 <a href="https://github.com/ramiroencinas/wap6">Wap6</a> 诞生了（Web App Raku）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_wap6_的结构">23.3. Wap6 的结构</h3>
<div class="paragraph">
<p>我喜欢 Wap6 实现的 Web 应用程序的结构：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>public</p>
</li>
<li>
<p>webservices</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>公共</strong>文件夹包含友好的前端东西，比如静态 html，javascript，css 等，也就是<strong>前端</strong>开发者空间。 <strong>webservices</strong> 文件夹包含<strong>后端</strong>的东西：一个 <strong>Raku</strong> 模块，包括每个 webservice 的一个函数。</p>
</div>
<div class="paragraph">
<p>相同的文件夹级别包含解决方案入口点，一个 <strong>Raku</strong> 脚本，其中包括初始化服务器参数，其中包含路由和 webservices 之间的映射：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %webservices =
  &#39;/ws1&#39; =&gt; ( &amp;ws1, &#39;html&#39; ),
  &#39;/ws2&#39; =&gt; ( &amp;ws2, &#39;json&#39; )
;</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你所看到的，不仅路由被映射到相应的 webservices，而且还指定 webservice 的返回内容类型(content-type )（如 HMTL 或 JSON）。也就是说，在 Web 浏览器中键入 <a href="http://domain/ws1">http://domain/ws1</a>，ws1 函数会返回具有相应内容类型的响应数据，我们将在稍后看到。</p>
</div>
<div class="paragraph">
<p>所有到 webservices 的路由都在 <strong>％webservices</strong> 散列中，并通过其他有用的命名参数传递给主函数 <strong>wap</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">wap(:$server-ip, :$server-port, :$default-html, :%webservices);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_wap6_的核心">23.4. Wap6 的核心</h3>
<div class="paragraph">
<p><strong>wap</strong> 函数位于 Wap6 使用的核心 lib 模块的外面，并包含并发和优雅的 V12 引擎：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
  whenever IO::Socket::Async.listen($server-ip,$server-port) -&gt; $conn {
    whenever $conn.Supply(:bin) -&gt; $buf {
      my $response = response(:$buf, :$current-dir, :$default-html, :%webservices);
      $conn.write: $response.encode(&#39;UTF-8&#39;);
      $conn.close;
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个三分（react – whenever – IO::Socket::Async）响应式，并发和异步的上下文。当传输从Web客户端（<strong>$conn</strong>）到达时，它将被放置在 bin 类型的新 Supply <strong>$buf</strong> (<strong>$conn.Suply(:bin)</strong>)中，<strong>$buf</strong> 和 <strong>％webservices</strong> 哈希等其他内容被发送到运行 HTTP 逻辑的响应函数。最后，响应函数的返回被写回到 Web 客户端。</p>
</div>
<div class="paragraph">
<p>响应函数（也位于核心库 lib 中）包含 <strong>HTTP 解析器</strong>的东西：它将传入数据（HTTP 实体）分割为头和主体，它执行验证，它需要基本的 HTTP 头信息，如方法（<strong>GET</strong> 或 <strong>POST</strong>）和 <strong>URI</strong>（统一资源标识符），它确定所请求的资源是 webservice（来自 webservices 文件夹）还是静态文件（来自公共文件夹），从资源中获取数据（来自静态文件或 webservice）并返回到 <strong>wap</strong> 函数以将响应写入 Web 客户端，如我们以前所见。</p>
</div>
</div>
<div class="sect2">
<h3 id="_webservices">23.5. Webservices</h3>
<div class="paragraph">
<p>响应函数验证 <strong>$buf</strong> 并从请求头中提取 HTTP 方法，可以是 <strong>GET</strong> 或 <strong>POST</strong>（我认为将来它不会支持更多的 HTTP 方法）。使用 <strong>GET</strong> 方法时，它将 URL 参数（如果有的话）放入 <strong>$get-params</strong>。 <strong>POST</strong> 方法的情况下，它将主体请求放入 <strong>$body</strong>。</p>
</div>
<div class="paragraph">
<p>然后是时候检查 Web 客户端是否请求了 webservice。 <strong>$get-params</strong> 包含了 <strong>URI</strong> 并用 <a href="https://github.com/raku-community-modules/uri">URI 模块</a>提取，最终结果放在 <strong>$path</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given $path {
  when %webservices{&#34;$_&#34;}:exists {
    my ( &amp;ws, $direct-type ) = %webservices{&#34;$_&#34;};
    my $type = content-type(:$direct-type);
    return response-headers(200, $type) ~ &amp;ws(:$get-params, :$body);
  }
  ..
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <strong>％webservices</strong> 哈希中存在 <strong>$path</strong>，则客户端需要一个 webservice。然后它从 <strong>％webservices</strong> 散列（是的，我也喜欢函数式范式:-)）和对应的内容类型中提取相应的 webservice 可调用函数 <strong>＆ws</strong>。然后它使用 <strong>$get-params</strong> 和请求 <strong>$body</strong> 参数调用 webservice 函数 <strong>＆ws</strong>。最后它返回连接的 HTTP 响应实体：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>具有状态 HTTP 200 OK 和给定内容类型（来自内容类型函数）的响应头。</p>
</li>
<li>
<p>webservice 输出。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可调用 webservice <strong>＆ws</strong> 可以是 <strong>ws1</strong>，位于 webservices 文件夹的 Raku 模块中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub ws1 ( :$get-params, :$body ) is export {
  if $get-params { return &#39;From ws1: &#39; ~ $get-params; }
  if $body { return &#39;From ws1: &#39; ~ $body; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个演示上下文中，webservice 简单地返回输入，即 <strong>$get-params</strong>（当 GET）或 <strong>$body</strong>（POST时）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_当客户端请求静态文件时">23.6. 当客户端请求静态文件时</h3>
<div class="paragraph">
<p>放弃所有其他可能性后，如果客户端请求公用文件夹中托管的静态文件（如html，js，css等），则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given $path {
..
  default {
    my $filepath = &#34;$current-dir/public/$path&#34;;
    my $type = content-type(:$filepath);
    return response-headers(200, $type) ~ slurp &#34;$current-dir/public/$path&#34;;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它返回包含匹配内容类型和请求文件内容的响应头。</p>
</div>
<div class="paragraph">
<p>这就是所有的了！以脚本过程式方式使用并发 Web服务：<strong>Wap6</strong>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结语">23.7. 结语</h3>
<div class="paragraph">
<p>我很满意 <strong>Wap6</strong> 的结果。我并不假装它增长很多，但我总是想继续添加<strong>更多功能</strong>：SSL支持（完成！），会话管理（进行中），Cookie，文件上传等。</p>
</div>
<div class="paragraph">
<p>Raku 为表执行并发网络操作提供了非常强大的方法：<a href="https://docs.raku.org/type/IO::Socket::Async">IO::Socket::Async</a>，一个杰作。另外，使用 <strong>Raku</strong>，您可以根据需要混合使用面向对象，过程式和函数式范式。借助这些功能，您可以设计一个并发异步服务并快速实现。</p>
</div>
<div class="paragraph">
<p>如果您希望在 <strong>Raku</strong> 生态系统中使用 HTTP 服务和并发性更严肃的方法，请看看 <a href="http://cro.services/">Cro</a>，它代表了一个很好的机会，可以将 <strong>Raku</strong> 作为 HTTP 服务空间中的强大实体。Jonathan Worthington 在同样的 Advent Calendar 的第九天写的就是<a href="https://rakuadvent.wordpress.com/2017/12/09/http-and-web-sockets-with-cro">关于 Cro</a>。</p>
</div>
<div class="paragraph">
<p>同时，我将继续使用 <strong>Wap6</strong>，以脚本的方式，贡献 <strong>Raku</strong> 生态系统，并从世界上最好的编程人员那里学习，我的意思是：<strong>Perl</strong> 和 <strong>Raku</strong> 程序员，当然:-)</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第一天_移植_vigilance将raku与标准工具集成在一起">24. 第一天 - 移植 Vigilance，将Raku与标准工具集成在一起</h2>
<div class="sectionbody">
<div class="paragraph">
<p>大家好，今天我们将采用基础设施脚本并将其从Perl 5移植到Raku.本文基于James Clark的一对帖子，你可以在这里找到：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://blog.lazycat.com.au/2014/05/integrating-integrity-part-1.html">第1部分</a></p>
</li>
<li>
<p><a href="http://blog.lazycat.com.au/2014/05/integrating-integrity-part-2.html">第2部分</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此脚本用于创建和验证MD5总和。 这些是128位值，可用于验证数据完整性。 虽然MD5已经被证明在防范恶意行为者方面不安全，但它对于检测磁盘损坏仍然很有用。</p>
</div>
<div class="paragraph">
<p>Raku生态系统正在发展，其中包含多种工具，这些工具可以从Perl 5 CPAN移植，也可以替代。 我将介绍原始脚本和移植的几个方面，并说明我为什么要进行一些特定的更改。 希望这会鼓励你出去移植你自己的小脚本。</p>
</div>
<div class="sect2">
<h3 id="_shebang_和导入">24.1. Shebang 和导入</h3>
<div class="paragraph">
<p>Perl 5版本使用一些基础设施和一些实用程序来处理Unicode并使命令行输出更好：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">#!/usr/bin/perl -CSDA

use strict;
use warnings;
use utf8;
use Encode qw/encode_utf8 decode_utf8/;
use Getopt::Long;
use Digest::MD5;
use Term::ANSIColor;
use Term::ProgressBar;
use File::Find;
use File::Basename;
use Data::Dumper;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku默认启用了警告和限制，并且内置了Unicode支持，因此我们可以将其保留。 Data::Dumper也已经实现，它具有非常有用的IO功能。 将所有这些加在一起我们可以得到一个非常精益的标头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Digest::MD5;
use Terminal::ANSIColor;
use Terminal::Spinners;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_命令行选项">24.2. 命令行选项</h3>
<div class="paragraph">
<p>Perl 5有许多用于处理命令行参数的很棒的模块，在我们使用 Getopt::Long 的原始脚本中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># Define our command-line arguments.
my %opts = ( &#39;blocksize&#39; =&gt; 16384 );
GetOptions(\%opts, &#34;verify=s&#34;, &#34;create=s&#34;, &#34;update=s&#34;, &#34;files&#34;, &#34;blocksize=s&#34;, &#34;help!&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在Raku中，我们可以直接在MAIN方法中定义命令行选项。 我们使用多个调度来根据传递的参数来控制脚本的执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi MAIN (Str :$create, *@files where { so @files }) { ... }
multi MAIN (Str :$update, *@files) { ... }
multi MAIN (Str :$verify, *@files) { ... }
multi MAIN (*@files where { so @files }) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也意味着我们不必定义帮助选项/sub，因为我们可以文档化我们的MAIN子例程，因此：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| Verify the MD5 sums in a file that conforms to md5sum output:
#|
multi MAIN (Str :$verify, *@files) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能已经注意到Raku版本没有定义blocksize选项，我将回过头来看看。</p>
</div>
</div>
<div class="sect2">
<h3 id="_io_读写文件">24.3. IO: 读写文件</h3>
<div class="paragraph">
<p>我们将校验和存储在一个文件中，其中每一行的格式都与GNU coreutils中的md5sum程序的输出相同：32个十六进制数字，两个空格和文件名。</p>
</div>
<div class="paragraph">
<p>一些基本的IO，我们使用正则表达式来解析每一行。 使用有意义的空格有助于保持每个正则表达式相当简洁：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub load_md5sum_file
{
	my ($filename) = @_;
	my @plan;

	open(my $fh, &#39;&lt;:utf8&#39;, $filename) or die &#34;Couldn&#39;t open &#39;$filename&#39; : $!\n&#34;;
	my $linenum = 0;
	while (my $line = &lt;$fh&gt;) {
		chomp $line;
		$linenum++;
		if ($line =~ /^(?\p{ASCII_Hex_Digit}{32})  (?.*)$/) {
			# Checksum and filename compatible with md5sum output.
			push @plan, create_plan_for_filename($+{filename}, $+{md5});

		} elsif ($line =~ /^(?\p{ASCII_Hex_Digit}{32})  (?.*)$/) {
			# Checksum and filename compatible with md5sum&#39;s manpage but not valid for the actual program.
			# We&#39;ll use it, but complain.
			print STDERR colored(&#34;Warning: &#34;, &#39;bold red&#39;), colored(&#34;md5sum entry &#39;&#34;, &#39;red&#39;), $line, colored(&#34;&#39; on line $linenum of file $filename is using only one space, not two - this doesn&#39;t match the output of the actual md5sum program!.&#34;, &#39;red&#39;), &#34;\n&#34;;
			push @plan, create_plan_for_filename($+{filename}, $+{md5});

		} elsif ($line =~ /^\s*$/) {
			# Blank line, ignore.

		} else {
			# No idea. Best not to keep quiet, it could be a malformed checksum line and we don&#39;t want to just quietly skip the file if so.
			print STDERR colored(&#34;Warning: &#34;, &#39;bold red&#39;), colored(&#34;Unrecognised md5sum entry &#39;&#34;, &#39;red&#39;), $line, colored(&#34;&#39; on line $linenum of file $filename.&#34;, &#39;red&#39;), &#34;\n&#34;;
			push @plan, { error =&gt; &#34;Unrecognised md5sum entry&#34; };
		}
	}
	close($fh) or die &#34;Couldn&#39;t close &#39;$filename&#39; : $!\n&#34;;

	return @plan;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku允许我们验证我们是否通过签名传递了实际存在的文件。 此外，我们用 grammar 替换正则表达式，如果需要，我们可以在脚本的不同位置使用该 grammar：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar MD5SUM {
	token TOP        { &lt;md5&gt; &lt;spacer&gt; &lt;filehandle&gt; }
	token md5        { &lt;xdigit&gt; ** 32 }
	token spacer     { \s+ }
	token filehandle { .* }
}

sub load-md5sum-file (Str $filehandle where { $filehandle.IO.f }) {
	my MD5Plan @plans;

	PARSE: for $filehandle.IO.lines(:close) -&gt; $line {
		next PARSE if !$line; # We don&#39;t get worked up over blank lines.

		my $match = MD5SUM.parse($line);

		if (!$match) {
			say $*ERR: colored(&#34;Couldn&#39;t parse $line&#34;, $ERROR_COLOUR);
			next PARSE;
		}

		if (!$match&lt;filehandle&gt;.IO.f) {
			say $*ERR: colored(&#34;{ $match&lt;filehandle&gt; } isn&#39;t an existing file.&#34;, $ERROR_COLOUR);
			next PARSE;
		}

		if ($match&lt;spacer&gt;.chars == 2) {
			@plans.push(MD5Plan.new($match&lt;filehandle&gt;.Str, $match&lt;md5&gt;.Str));
		}
		else {
			say $*ERR: colored(&#34;&#39;$line&#39; does not match the output of md5sum: wrong number of spaces.&#34;, $WARNING_COLOUR);
			@plans.push(MD5Plan.new($match&lt;filehandle&gt;.Str, $match&lt;md5&gt;.Str));
		}
	}

	 return @plans;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>写出数据非常相似：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">sub save_md5sum_file
{
	my ($filename, @plan) = @_;

	my $fh;
	unless (open($fh, &#39;&gt;:utf8&#39;, $filename)) {
		...
	}
	foreach my $plan_entry (@plan) {
		next unless $plan_entry-&gt;{correct_md5} &amp;&amp; $plan_entry-&gt;{filename};
		print $fh &#34;$plan_entry-&gt;{correct_md5}  $plan_entry-&gt;{filename}\n&#34;;
	}
	close($fh) or die &#34;Couldn&#39;t close &#39;$filename&#39; : $!\n&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>值得注意的是，Raku默认以Unicode格式写入文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub save-md5sum-file (Str $filehandle, @plans) {
	my $io = $filehandle.IO.open: :w;

	WRITE: for @plans -&gt; $plan {
		next WRITE unless $plan.computed-md5 &amp;&amp; $plan.filehandle;

		$io.say(&#34;{ $plan.computed-md5 }  { $plan.filehandle }&#34;);
	}

	$io.close;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_获得md5校验和">24.4. 获得MD5校验和</h3>
<div class="paragraph">
<p>Perl 5版本的Digest::MD5使用了相当多的XS来提高性能。 XS中包含了以块的形式添加数据以进行整体解析的方法。 这允许我们使用ProgressBar向用户展示用户等待时的进度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">sub run_md5_file
{
	my ($plan_entry, $progress_fn) = @_;

	# We use the OO interface to Digest::MD5 so we can feed it data a chunk at a time.
	my $md5 = Digest::MD5-&gt;new();
	my $current_bytes_read = 0;
	my $buffer;
	$plan_entry-&gt;{start_time} = time();
	$plan_entry-&gt;{elapsed_time} = 0;
	$plan_entry-&gt;{elapsed_bytes} = 0;

	# 3 argument form of open() allows us to specify &#39;raw&#39; directly instead of using binmode and is a bit more modern.
	open(my $fh, &#39;&lt;:raw&#39;, $plan_entry-&gt;{filename}) or die &#34;Couldn&#39;t open file $plan_entry-&gt;{filename}, $!\n&#34;;

	# Read the file in chunks and feed into md5.
	while ($current_bytes_read = read($fh, $buffer, $opts{blocksize})) {
		$md5-&gt;add($buffer);
		$plan_entry-&gt;{elapsed_bytes} += $current_bytes_read;
		$plan_entry-&gt;{elapsed_time} = time() - $plan_entry-&gt;{start_time};
		&amp;$progress_fn($plan_entry-&gt;{elapsed_bytes});
	}
	# The loop will exit as soon as read() returns 0 or undef. 0 is normal EOF, undef indicates an error.
	die &#34;Error while reading $plan_entry-&gt;{filename}, $!\n&#34; if ( ! defined $current_bytes_read);

	close($fh) or die &#34;Couldn&#39;t close file $plan_entry-&gt;{filename}, $!\n&#34;;

	# We made it out of the file alive. Store the md5 we computed. Note that this resets the Digest::MD5 object.
	$plan_entry-&gt;{computed_md5} = $md5-&gt;hexdigest();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku版本使用纯Perl并且缺少添加功能，因此我使用微调器而不是进度条。 我们还需要专门设置我们的编码，以避免在将二进制数据读取为Unicode时出现的错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub calc-md5-sum (MD5Plan $plan) {
    my $md5 = Digest::MD5.new;

    print &#34;Calculating MD5 sum for { $plan.filehandle }       &#34;; # We need some space for the spinner to take up.
	                                                             # I like &#39;bounce&#39;, so I need 6 spaces for the spinner
	                                                             # + an extra one to separate it from the filehandle.

	my Buf $buffer = $plan.filehandle.IO.slurp(:close, :bin);

	my $decoded = $buffer.decode(&#39;iso-8859-1&#39;);

	my $spinner = Spinner.new(type =&gt; &#39;bounce&#39;);

	my $promise = Promise.start({
		$md5.md5_hex($decoded)
	});

	until $promise.status {
		$spinner.next;
	}

	say &#39;&#39;; # Add a new line after the spinner.

	$plan.computed-md5 = $promise.result;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_结束之前的思考">24.5. 结束之前的思考</h3>
<div class="paragraph">
<p>我没有在我的系统上使用Raku版本因为Digest::MD5的低性能，在我的系统上我用md5sum调用替换它。 其他可能性是使用Inline::Perl5和Perl 5版本的Digest::MD5，或使用惊人的Raku原生调用接口来运行C实现。 我希望这篇文章能激发您将一些自己的Perl 5脚本移植到Raku，或者至少为您提供一些命令行交互的技巧。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二天_like_6_perls_in_a_pod_document_everything">25. 第二天 – Like 6 Perls in a Pod: document everything</h2>
<div class="sectionbody">
<div class="paragraph">
<p>圣诞节即将到来，圣诞老人很沮丧。 他的收件箱被来自全国各地的男孩和女孩的来信塞爆了。</p>
</div>
<div class="paragraph">
<p>但，</p>
</div>
<div class="paragraph">
<p>这些信是写给圣诞老人的吗？ 是否通过签名正确识别了孩子，以便将礼物送给对的人而不是给其他可能不值得的人？ 他们是针对圣诞老人的，而不是那些冒名顶替者，复活节兔子，或者更糟糕的是，三个所谓的 - 我不知道为什么 - 来自东方的智者？ 最糟糕的是，他个人是否必须通过他的王室和神圣的自我来检查所有这些东西？</p>
</div>
<div class="paragraph">
<p>没有。</p>
</div>
<div class="paragraph">
<p>Raku 以下面的方式来救援：</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/syntax/Creating%20grammars">grammar</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit grammar Santa-Letter;

token TOP           { &lt;dear&gt; \v+ &lt;paragraph&gt; [\v+ &lt;paragraph&gt;]* \v+ &lt;signature&gt;\v*}
token paragraph     { &lt;superword&gt;[ \h+ &lt;superword&gt;]+ }
token superword     { &lt;word&gt; | &lt;enhanced-word&gt;       }
token word          { \w+                            }
token enhanced-word { &lt;word&gt; [\,|\.|\:]              }
token dear          { Dear \h+ [S|s]anta [\,|\:]?    }
token signature     { \h+ \w+ \h* \w*                }</code></pre>
</div>
</div>
<div class="paragraph">
<p>该单位向圣诞老人宣布一封致敬的信，其后是一个或多个段落，最后是一个签名，其前面应有一个水平的空格，如 <code>\h</code> 所示。</p>
</div>
<div class="paragraph">
<p>像这样的信件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Dear Santa:

This year I have been a really good boy, I have been in all Squashathons.

So I want a plush Camelia studded with diamonds.

 JJ</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个简单的脚本将使用该 grammar 并在单封信中获取签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Santa-Letter;

sub MAIN ( Str $file = &#34;letter.txt&#34; ) {
    my $letter =$file.IO.slurp;
    my $parsed = Santa-Letter.parse($letter);
    say $parsed&lt;signature&gt;.trim;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这很好，很不错，但圣诞老人需要将这些数据与信件和索引一起提供给北极的CRM，同时他不得不与贸易战给他们造成严重破坏的供应商打交道…​所以他叫上他最亲密的IT精灵，来跟他一起做事。</p>
</div>
<div class="paragraph">
<p>演讲结束后，IT精灵站在那里，他的耳朵在颤抖。</p>
</div>
<div class="paragraph">
<p>“什么？”，圣诞老人咆哮道。 当然是以神圣的方式。</p>
</div>
<div class="paragraph">
<p>耳朵的尖变红了，并伴随着颤抖的辐射热量，使小冰柱融化并落到地上。</p>
</div>
<div class="paragraph">
<p>“你可以阅读消息来源，对吧？”</p>
</div>
<div class="paragraph">
<p>鲁道夫被冰柱融化的噪音惊醒，因为那是他的超级能量之一，介入。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_大多数人都可以阅读源代码但每个人都可以阅读文档">26. 大多数人都可以阅读源代码，但每个人都可以阅读文档。</h2>
<div class="sectionbody">
<div class="paragraph">
<p>鲁道夫说。</p>
</div>
<div class="paragraph">
<p>“而且每个人都应该写下这些文件”，他劝告道，他的头部前面有红色的鼻子。</p>
</div>
<div class="paragraph">
<p>圣诞老人嘟嚷着，但最终检查了他的 Santa-Letter grammar 的主分支并开始着手研究它。 当然，使用 Pod 6</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pod_6_stands_for_plain_old_documentation_for_raku">27. Pod 6 stands for “Plain Old documentation for Raku”</h2>
<div class="sectionbody">
<div class="paragraph">
<p>它（显然）不是首字母缩略词。 Pod6 是一个帮助 Raku 编码人员编写文档的 DSL。 它是一种标记语言，它使用 <code>=</code> 来启动命令和段落级标记。 我们会做到这一点，但目前，Santa 意识到最好的事情之一是它如何与 Raku 本身集成。 因此，他对检查程序进行了第二次迭代：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| This reads a letter file
sub MAIN ( Str $file = &#34;letter.txt&#34; ) {
    my $letter =$file.IO.slurp;
    my $parsed = Santa-Letter.parse($letter);
    say $parsed&lt;signature&gt;.trim;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在注释中有一个有趣的标志，<code>|</code>。 该标志将其与注释背后的代码联系起来。 在这种情况下，它是MAIN子例程。</p>
</div>
<div class="paragraph">
<p>圣诞老人将该程序发布到了生产环境。 IT精灵试图运行该程序，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">./get-signed.p6 --help</code></pre>
</div>
</div>
<div class="paragraph">
<p>它得到了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">Usage:
  ./get-signed.p6 [] -- This reads a letter file</code></pre>
</div>
</div>
<div class="paragraph">
<p>“有文档比没有文档更好”，他想。 但这还不够。 他完全使用自由软件进入北极票务系统，并要求提供更多文档并将任务分配给圣诞老人。 圣诞老人大声抗议，但顺从了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#|{ This reads a letter file in text format.
With no arguments, it will read the C&lt;letter.txt&gt; file.
}
sub MAIN ( Str $file = &#34;letter.txt&#34; ) {
    my $letter =$file.IO.slurp;
    my $parsed = Santa-Letter.parse($letter);
    say $parsed&lt;signature&gt;.trim;
    say $=pod[0].perl;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当使用 <code>--help</code> 调用时，这会打印相同的消息。 这是文档。 运行时:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku --doc get-signed.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">sub MAIN(
	Str $file = &#34;letter.txt&#34;,
)
This reads a letter file in text format. With no arguments, it will read the C file.</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以Raku理解注释和附加到它的代码，并自动打印两者。 记录例程就像这样简单。</p>
</div>
<div class="paragraph">
<p>此外，当在实际文件上运行时，最后一句被踢了，它打印出来：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Pod::Block::Declarator.new(WHEREFORE =&gt; sub MAIN (Str $file = &#34;letter.txt&#34;) { #`(Sub|81308800) ... }, config =&gt; {}, contents =&gt; [])</code></pre>
</div>
</div>
<div class="paragraph">
<p>与其他语言中用于注释的其他DSL不同，例如Perl 5中的Markdown或Pod本身，Pod 6不仅是用于注释的DSL，它还是Raku本身的一部分，因此，它由Raku解析器解释，其内部结构可用于 <code>$=pod</code> 变量中的内省。 在这种情况下，注释是一个 <code>Pod::Block::Declarator</code>，该数据结构包含`WHEREFORE`键，其中包含声明的函数和注释。 但是，`contents`和`config`为空。 他们不应该这样做。</p>
</div>
<div class="paragraph">
<p>更重要的是，注释中使用的一点点实际格式不起作用。 更不用说实际模块没有真正文档化。 现在是圣诞老人不高兴了。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_给模块添加文档">28. 给模块添加文档</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在编写实际代码之前，编写文档可能是您应该做的第一件事。 文档适用于模块客户端，但首先，它是作者的指南，模块应该做什么以及应该如何做的路线图。 如上所述，使用Pod 6可以很容易地记录单个方法或例程; 但是，模块的大图片视图也很方便。 这里是`Santa-Letter`的Pod:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">=begin pod

=head1 NAME

Santa-Letter - A grammar for letters to Santa for the L&lt;Raku Advent Calendar|https://rakuadvent.wordpress.com&gt;

=head1 SYNOPSIS

Parses letters formatted nicely and written by all good kids in the world.

=end pod</code></pre>
</div>
</div>
<div class="paragraph">
<p>方便地放在文件的末尾，当用`raku -doc Santa-Letter.pm6`调用时，或简单地`raku --doc Santa-Letter`如果它
已安装，甚至`p6doc Santa-Letter`如果是`raku/doc`的
在场，会写出类似的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">NAME

Santa-Letter - A grammar for letters to Santa for the Raku Advent
Calendar

SYNOPSIS

Parses letters formatted nicely and written by all good kids in the
world.</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是你会注意到这种类型的输出已经消除了一段标记。 `L`创建链接，但显然只有在输出格式支持时才这样做。 那么让我们试试其中一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku --doc=HTML Santa-Letter.pm6</code></pre>
</div>
</div>
<div class="paragraph">
<p>将输出大量代码，其中包括以下行：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Santa-Letter - A grammar for letters to Santa for the <a href="https://rakuadvent.wordpress.com/">Raku Advent Calendar</a></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>清楚地显示链接的输出。</p>
</div>
<div class="paragraph">
<p>事实上，此命令将使用 <code>Pod::To::HTML</code> 模块将 Pod 数据结构转换为 HTML。 使用任何其他东西将调用相应的模块，并且生态系统上有许多可用的<a href="https://modules.raku.org/search/?q=pod%3A%3Ato">模块</a>。 例如，<code>Pod::To::Pager</code> 将使用系统的分页使东西更美观。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku --doc=Pager Santa-Letter.pm6</code></pre>
</div>
</div>
<div class="paragraph">
<p>会输出这个</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/pager.png">img</a></p>
</div>
<div class="paragraph">
<p>此外，该文档遵循所有模块中使用的约定。 <code>NAME</code> 应描述名称和简短的 oneliner，告诉模块的内容，而 <code>SYNOPSIS</code> 包含更长的描述。 虽然这很好，但真正的文档应包含示例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">=begin code

use Santa-Letter;

say Santa-Letter.parse(&#34;Dear Santa\nAll I want for Christmas\nIs you\n Mariah&#34;);

=end code</code></pre>
</div>
</div>
<div class="paragraph">
<p>示例包含在代码块中，从Pod6的角度来看，它们是 `Pod::Block::Code`对象。 实际上，这是一件好事。 让我们将这一小段代码添加到我们的 grammar 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">our $pod = $=pod[0];</code></pre>
</div>
</div>
<div class="paragraph">
<p>Grammar 是类，它们具有类作用域的变量。 我们无法导出 <code>$=pod</code> 变量以避免与其他人发生冲突，但我们可以导出它，然后在我们的程序中使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $Santa-Letter::pod.perl;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，甚至更好， 安装 <code>Data::Dump</code> 并写下这样的东西:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Dump( $Santa-Letter::pod, :indent(4), :3max-recursion );</code></pre>
</div>
</div>
<div class="paragraph">
<p>它使用我们声明的 <code>pod</code> 类变量, 并且它是这样打印的:</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/structure.png">img</a></p>
</div>
<div class="paragraph">
<p>这个树可以称为POM（Pod对象模型），除了与每个块一起使用的已知的 <code>name</code> 和 <code>config</code> 元数据外，还包括同一级别的Pod6块数组。 每个人都有通用属性和特定属性，例如标题中的级别。 无论如何，有趣的是我们作为示例使用的代码本身可以作为 <code>Pod::Block::Code</code> 对象的内容。</p>
</div>
<div class="paragraph">
<p>圣诞老人想，“哼哼”。 我们可以做得更好。 我们真的可以检查包含的代码是否有效吗？ 我们可以！ 我们来扩展一下 <code>SYNOPSIS</code> 部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">=head1 SYNOPSIS

Parses letters formatted nicely and written by all good kids in the world.

=begin code

use Santa-Letter;

say Santa-Letter.parse(&#34;Dear Santa\nAll I want for Christmas\nIs you\n Mariah&#34;);

=end code

You can also access particular elements in the letter, as long as they are included on the grammar

    my $letter=&#34;Dear Santa,\nI have not been that good.\nJust a paper clip will do\n Donald&#34;
    say Santa-Letter.parse($letter)&lt;signature&gt;

Also

=for code :notest :reason(&#34;Variable defined above&#34;)
say &#34;The letter signed by &#34;, Santa-Letter.parse($letter),
    &#34; has &#34;, Santa-Letter.parse($letter).elems, &#34; paragraphs&#34;;

=end pod</code></pre>
</div>
</div>
<div class="paragraph">
<p>代码可以在Pod中以不同方式表示。 第一个是已知的; 第二个使用缩进，即Markdown，来表示同一件事情。 我们也可以使用 <code>=for</code> 作为段落块，在这种情况下使用代码类型声明，并将继续直到下一个空白行。 这是一种不需要 <code>=end</code> 指令的缩写方式。 但是还有更多的东西：配置变量 <code>:notest :reason(&#34;Variable defined above&#34;)</code>。 这些配置变量是任意的，我们可以添加任意多个。 他们将转到块的 <code>config</code> 属性，我们可以使用它们。 这正是我们将在此脚本中处理代码示例的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $Santa-Letter::pod.contents -&gt; $block {
    next if $block !~~ Pod::Block::Code;
    if $block.config&lt;notest&gt; {
        say &#34;→ Block\n\t&#34;~ $block.contents
            ~ &#34;\n\t❈ Not tested since \&#39;&#34; ~ $block.config&lt;reason&gt; ~ &#34;\&#39;&#34;;
    } else {
        my $code = $block.contents.join(&#34;&#34;);
        say &#34;→ Block\n\t&#34;~ $block.contents;
        try {
            EVAL $code;
        }
        if ( $! ) {
            say &#34;\n\t✘ Produces error \&#34;$!\&#34;&#34;, &#34;\n&#34; xx 2;
        } else {
            say &#34;✔ is OK\n&#34;;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如我们在上面的结构中看到的那样，<code>contents`属性将包含一个第一级Pod块的数组，在我们的例子中包括我们想要求值的所有三个块（或者可能不包括）。 跳过非代码块（但也可以检查拼写）。 我们在这里做了两件有趣的事情：我们通过 `$block.config</code> 检查配置中的 <code>notest</code> 标志，如果是这种情况我们打印一些注释，但是如果它应该被测试，那么它是`EVAL`ed（我们需要使用`MONKEY-SEE-NO-EVAL` 指令。</p>
</div>
<div class="paragraph">
<p>圣诞老人在文档上运行它，瞧瞧！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">→ Block
	my $letter=&#34;Dear Santa,\nI have not been that good.\nJust a paper clip will do\n Donald&#34;
say Santa-Letter.parse($letter)

	✘ Produces error &#34;Two terms in a row across lines (missing semicolon or comma?)&#34;(

)</code></pre>
</div>
</div>
<div class="paragraph">
<p>他立刻感到高兴和谦卑。 一个简单的分号破坏了示例的质量。 它始终是分号。 他把分号放回到示例中，模块文档以快速的颜色通过了测试。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_回到生产">29. 回到生产</h2>
<div class="sectionbody">
<div class="paragraph">
<p>提供了这个<a href="https://github.com/JJ/my-raku-examples/blob/master/grammars/Santa-Letter.pm6">文档模块</a>，IT精灵非常高兴，他的耳朵停止颤抖和发红。 他也可以给每个 token 编写文档，但足够了，至少他有一些例子可以让应用程序运行。 鲁道夫睡得很熟，现在他必须在信件接收微服务和客户关系宏服务之间建立桥梁。 他可能会使用 <a href="https://cro.services/">Cro</a>，但这是另一天的主题。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第三天_raku_跳转到那儿">30. 第三天 – Raku – 跳转到那儿</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://github.com/nige123/jmp.nigelhamilton.com">jmp</a>是一个Raku驱动的命令行程序，我每天都使用它来浏览成堆的Perl并快速跳转到我的$EDITOR。 我尝试在编码时保持<a href="https://rakuadvent.wordpress.com/2015/12/20/perl-6-christmas-have-an-appropriate-amount-of-fun/">流状态</a>，并且能够快速搜索文件然后直接跳转到编辑器中。</p>
</div>
<div class="paragraph">
<p><strong>jmp</strong> 是一个简单的基于终端的前端到您最喜欢的代码搜索工具（例如，rgrep，ag，ack，git grep等）。 它会显示一个搜索结果列表，您可以在跳转到编辑文件之前快速浏览（例如，vim，nano，<a href="https://commaide.com/">comma</a>等）。</p>
</div>
<div class="paragraph">
<p>它的工作原理如下：</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/11/jmp2-final.gif?w=600&amp;zoom=2">img</a></p>
</div>
<div class="paragraph">
<p>最近我重构了 <strong>jmp</strong>，以便在 <a href="https://github.com/ab5tract/Terminal-Print">Terminal::Print</a> 模块的帮助下改进用户界面。 Terminal::Print 提供了一个方便的二维网格，用于在终端屏幕上绘图。 还有一个用于异步处理用户输入的模块。</p>
</div>
<div class="paragraph">
<p>这是 <strong>jmp</strong> 代码，只要用户按下某个键，它就会响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $in-supply = decoded-input-supply;
my $timer     = Supply.interval(1).map: { Tick };
my $supplies  = Supply.merge($in-supply, $timer);

react {
    whenever $supplies -&gt; $_ {
        when Tick {}
        when &#39;CursorUp&#39;                 { self.pager.cursor-up;   }
        when &#39;CursorDown&#39;               { self.pager.cursor-down; }
        when &#39;CursorRight&#39; | &#39;PageDown&#39; { self.pager.next;        }
        when &#39;CursorLeft&#39;  | &#39;PageUp&#39;   { self.pager.previous;    }
        when &#39;x&#39; | &#39;X&#39;                  { self.pager.exit-page;   }
        when &#39;e&#39; | &#39;E&#39; {
             self.pager.edit-selected($!editor);
        }
        when $_ ~~ Str and $_.ord == 13 {
             # the user pressed ENTER
             self.pager.edit-selected($!editor);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码设置用户输入事件的异步 supply，并且只要事件触发（例如，用户按下PageUp），它就会做出反应。 但是如果用户一次按下很多键会发生什么？ 如何以有序的方式更新终端屏幕？</p>
</div>
<div class="paragraph">
<p>由于 Jonathan Worthington的 <a href="https://github.com/jnthn/oo-monitors">OO::Monitors</a> 模块和 <strong>monitor</strong> 关键字，解决方案在 <a href="https://github.com/ab5tract/Terminal-Print/blob/master/lib/Terminal/Print/Grid.pm6">Terminal::Print::Grid</a> 中找到。 这确保了一次只有一个线程可以在 grid 对象的方法中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use OO::Monitors;
unit monitor Terminal::Print::Grid;</code></pre>
</div>
</div>
<div class="paragraph">
<p>制作自己的 Raku 驱动的命令行工具是学习该语言的好方法。 如果您需要终端接口，请查看 <a href="https://github.com/ab5tract/Terminal-Print">Terminal::Print</a>。 为了加速命令行工具，将代码放在模块中是一个很好的技巧，因此Raku可以预编译它以加快启动时间（例如，<a href="https://github.com/nige123/jmp.nigelhamilton.com/blob/master/lib/JMP/CLI.pm">CLI.pm</a>）。</p>
</div>
<div class="paragraph">
<p>要安装jmp的第2版，首先安装<a href="https://raku.org/downloads/">Raku</a>，然后使用<a href="https://github.com/ugexe/zef">zef</a> Raku模块管理器来安装它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">shell&gt; zef install jmp   # or zef upgrade jmp
shell&gt; jmp config        # set up jmp to use your tools
shell&gt; jmp find sub MAIN # find files containing &#34;sub MAIN&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>随着我们越来越接近圣诞节，请留意更多的命令行工具会被打开。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第四天_献给新年的_raku_pod_新功能">31. 第四天 - 献给新年的 Raku Pod 新功能</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_介绍_3">31.1. 介绍</h3>
<div class="paragraph">
<p>Rakudo NQP 文件包含解析 Raku 输入文件并将其转换为正在运行的 Raku 程序的代码。 本文将重点介绍最近使用 Rakudo NQP 文件时的经验所学到的一些细节。 这项工作涉及实现一些尚未实现的（NYI）Raku POD 功能，我希望尽快合并这些更改。</p>
</div>
</div>
<div class="sect2">
<h3 id="_准备">31.2. 准备</h3>
<div class="paragraph">
<p>使用的 NQP 文件保存在 <a href="https://github.com/rakudo/rakudo/tree/master/src/Raku">https://github.com/rakudo/rakudo/src/Raku</a> 的git存储库中。 有关我的开发设置和工作流的更多背景信息，请参阅 <a href="https://rakuadvent.wordpress.com/2017/12/08/">https://rakuadvent.wordpress.com/2017/12/08/</a> 上的 2017 年 Raku Advent 条目。</p>
</div>
</div>
<div class="sect2">
<h3 id="_背景_2">31.3. 背景</h3>
<div class="paragraph">
<p>在我实现 NYI POD 功能的过程中，我已经给我添加到 Rakudo 仓库中的文档添加了注释: <a href="https://github.com/rakudo/rakudo/blob/master/docs/rakudo-nqp-and-pod-notes.md">rakudo/docs/rakudo-nqp-and-pod-notes.md</a>。我更新它，因为我发现了可能没有记录的新内容或者可能不容易找到其文档。该文件还包含一份完整的清单，通过我的计算，NYI POD 功能。以下是我已经工作了几个月的 NYI POD 功能列表，我希望在今年或新年初完成（以及每个功能的 roast 测试）:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>NYI: %config :numbered 对于段落或分隔的POD块，使用&#39;#&#39;别名</p>
</li>
<li>
<p>NYI: POD 数据块</p>
</li>
<li>
<p>NYI: 以defn块术语格式化代码</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>缺少的项目描述在由 Damian Conway 博士撰写的精美制作的<a href="https://design.raku.org/S26.html">概要S26</a>中，Larry Wall 是多产的得力男人 - 世界知名的 Perl 专家和著名的 Perl 作者。（请注意，现在很少有人在积极研究 POD，我的 NYI 功能列表可能不完整. S26 写得非常密实，如果不高度集中就不容易理解。我花了不少时间试图实现一个我认为已被描述的功能但我误读了文档！）</p>
</div>
<div class="paragraph">
<p>受许多因素的影响, 这项工作比我预期的时间更长，因为我将简要讨论，希望它可以帮助未来的开发人员。</p>
</div>
</div>
<div class="sect2">
<h3 id="_rakudo_nqp_grammar_和_actions_学到的东西">31.4. Rakudo NQP grammar 和 actions: 学到的东西</h3>
<div class="sect3">
<h4 id="_match_对象">31.4.1. Match 对象</h4>
<div class="paragraph">
<p>在 token 上完成一个 grammar 匹配会产生一个匹配对象。 如果 token 具有与该 token 同名的 action 操作方法，则使用匹配对象作为隐式或显式参数调用该 action 方法。 按照惯例，&#39;$/&#39; 用作显式参数，但可以使用另一个名称（不要这样做！）。 我不建议依赖隐式参数。 如果需要，可以添加其他参数。</p>
</div>
<div class="paragraph">
<p>请注意，随着解析的继续，匹配数据将保留在匹配对象中，因为它在其他 token 和方法中使用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_断言">31.4.2. 断言</h4>
<div class="paragraph">
<p>断言在 POD 处理中发现的动态 grammar 中很重要。 在主匹配期间，通常必须选择几种匹配路径。 调试错误使用给我带来很多麻烦的一个例子是在定义分隔文本块的 token 内。</p>
</div>
<div class="paragraph">
<p>触发问题的测试用例是文件’b.t&#39;:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">=begin pod
text
=end pod

my $o = $=pod[0];
say $o;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我对它运行raku时，我得到了</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ ./raku b.t
Preceding context expects a term, but found infix = instead.
Did you make a mistake in Pod syntax?
at /usr/local/people/tbrowde/mydata/tbrowde-home-bzr/raku/raku-repo-forks/rakudo/b.t:1
------&gt; =begin ⏏pod</code></pre>
</div>
</div>
<div class="paragraph">
<p>不是很有帮助！ 然后我尝试了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ ./raku b.t --ll-exception b.t
Preceding context expects a term, but found infix = instead.
Did you make a mistake in Pod syntax?
   at SETTING::src/core/Exception.pm6:57  (./CORE.setting.moarvm:throw)
 from src/Raku/World.nqp:4955  (blib/Raku/World.moarvm:throw)
 from gen/moar/Raku-Grammar.nqp:301  (blib/Raku/Grammar.moarvm:typed_panic)
 from gen/moar/Raku-Grammar.nqp:3609  (blib/Raku/Grammar.moarvm:)
 ...more files and line numbers...</code></pre>
</div>
</div>
<div class="paragraph">
<p>更没用了！ 我尝试手动调查列出的文件，并且无法很好地解密代码以获得线索。</p>
</div>
<div class="paragraph">
<p>然后我尝试了另一个似乎有效的类似测试用例，文件’b2.t&#39;：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">=begin table
text
=end table

my $o = $=pod[0];
say $o;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我对它运行raku时，我得到了</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ ./raku b2.t
Pod::Block::Table
  text</code></pre>
</div>
</div>
<div class="paragraph">
<p>成功了！</p>
</div>
<div class="paragraph">
<p>但是这个失败的测试案例导致我几周尝试各种调试技术，直到最后，再次查看 Grammar.nqp 中的 <strong>delimited</strong> token 并在心里计算每个子匹配组正在做什么。 然后我仔细查看了包含<strong>断言</strong>的这个组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[
    # defn-line is all text to the newline
    &lt;?{ ~$&lt;type&gt; eq &#39;defn&#39; }&gt; # &lt;== assertion: this is a &#39;defn&#39; type
    \s* &lt;defn-line&gt;
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <strong>delimited</strong> 块 token 定义中，该组是顺序的而不是备选分支的一部分，必须匹配或全部 token 失败。不幸的是，失败的结果是 LTA , 对于这种情况是例外（这在 NQP 中并不常见，并且在其中工作的危险之一），并且我在寻找原因的过程中犯了太长时间的错误。欺骗我的一件事就是认为在一个没有得到满足的小组中的断言就像是&#39;?&#39;量词意味着忽略失败的匹配。在我仔细研究之后，我认为绝对不是这样！该组是否匹配，因此如果不匹配是可接受的，则量词必须在那里。</p>
</div>
<div class="paragraph">
<p>当我将 <strong>delimited</strong> token 的代码与 <strong>delimited_table</strong> 块 token 的起作用代码（之前我曾做过很多次）进行比较时，我看到 <strong>delimited_table</strong> 块中的同一匹配组具有&#39;?&#39;量词。在我给 <strong>delimited</strong> 块 token 中的组添加&#39;?&#39;后, 坏的测试用例再次起作用！</p>
</div>
</div>
<div class="sect3">
<h4 id="_调试">31.4.3. 调试</h4>
<div class="paragraph">
<p>对我来说最有用的 grammar 和 actions 调试技术是经典的：print 语句用于显示执行期间变量的值。该方法取决于哪种文件类型以及希望显示的值。以下是一些例子：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1、显示匹配对象的内容：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method do-foo($/) {
    say(&#34;DEBUG: dumping method &#39;do-foo&#39; match:&#34;);
    say($/.dump);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>2、显示 grammar 匹配期间的结果</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token blah {
    \h* $&lt;tok&gt; = [ foo | bar ] # &lt;== note &#39;=&#39; instead of &#39;:=&#39;
    { say(&#34;DEBUG: \$&lt;tok&gt; value: &#39;{$&lt;tok&gt;}&#39;&#34;); }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，say 语句位于由花括号定义的块内。另请注意，即使在 NQP 源文件中，grammar 中使用的匹配对象的赋值运算符（&#39;=&#39;）也不是绑定运算符（&#39;:=&#39;）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_动态变量">31.4.4. 动态变量</h4>
<div class="paragraph">
<p>grammar 和 action 大量使用动态变量（带有 <code>*</code> twigil 的变量，例如 <strong>$*IN-DEFN-BLOCK</strong>）。当需要在解析树中深入更改变量时，它们显示了它们的多功能性，并且该值在该解析的剩余部分（调用者）和子解析操作期间保持不变。</p>
</div>
</div>
<div class="sect3">
<h4 id="_make_made_和_ast">31.4.5. make, made 和 ast</h4>
<div class="paragraph">
<p>尽管在所有已发表的 Raku 书籍中都有解释，但 grammar 和 action 中使用的术语 “make”，“made” 和 “ast”一直让我很困惑。感谢 Raku 作者 <strong>Moritz Lenz</strong> 对 <strong>IRC#raku-dev</strong> 的问题的进一步解释和回答，他们更清楚了。</p>
</div>
<div class="paragraph">
<p>基本上，在 action 方法中，使用 <code>make</code> 会将当前值分配给匹配对象的 <code>.ast</code> 属性（或其别名 <code>.made</code>）和方法的名字。因此，给出以下方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method do-foo($/) {
    my $val = 6;
    make $val;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或可选地：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method do-foo($/) {
    $/.ast := 6;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们以后可以用这些惯用法中的一个来获得这个值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say(&#34;do-foo.ast = {$&lt;do-foo&gt;.ast}&#34;);  # output: 6
say(&#34;do-foo.ast = {$&lt;do-foo&gt;.made}&#34;); # output: 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>选择属性名称 <code>.ast</code> 是误导性的，因为它通常是指抽象语法树（AST），但在这种情况下，它与 AST 无关（尽管它可能具有 QAST 节点或任何其他类型的 NQP 对象值）。</p>
</div>
<div class="paragraph">
<p>请注意，分配给 <code>.ast</code> 属性的任何值都可能在 grammar 或 action 的稍后阶段被覆盖或删除。</p>
</div>
</div>
<div class="sect3">
<h4 id="_推迟生成qast节点">31.4.6. 推迟生成QAST节点</h4>
<div class="paragraph">
<p>有时在现有 grammar 中过早生成QAST节点阻止了正确的POD功能实现。一个例子是POD块的%config部分，它具有稍后解析所需的一些值。我正在做的部分工作需要重新编写%config匹配代码，因此在父对象（通常是POD类）的所有部分都已根据需要进行计算或构建之前，不会生成QAST节点。</p>
</div>
</div>
<div class="sect3">
<h4 id="_隔离pod_only代码">31.4.7. 隔离POD-only代码</h4>
<div class="paragraph">
<p>当前的 grammar 和 grammar action 代码是复杂的，并且有些谜题，因为插入了块并且超过15年没有再次触及。因此，很难避免合并冲突与大而必要的变化。核心开发人员提出的一个建议是帮助将 POD 代码与其他代码分开，这就是创建一个与其他现有方言类似的单独POD方言（子语言）。我曾经认为这将是一个有用的改变，但现在，在理解了更多的代码后，创建一个单独的POD方言似乎并不是特别有利。但是，将所有 POD-only 代码移动到封闭类或 grammar 块的末尾将有助于在个人合并重叠代码时最小化版本控制意外和冲突。</p>
</div>
<div class="paragraph">
<p>因此，几个星期前我抓住机会（1）询问了几个关键开发人员，如 @lizmat 和 @jnthn，如果他们对该计划没有问题，（2）创建并测试这样的更改作为拉取请求（PR），（3）合并相当大的PR。不幸的是，这一重大变化令一些开发人员感到意外，并在 IRC#raku-dev 上引发了一些惊讶的评论和投诉！幸运的是，发布经理 @AlexDaniel 运用了他惯用的外交和 git 代码讽刺风度，因为他让人群平静下来，并演示了改变实际上只是一个简单（但很大）的代码转换。所以我即将推出的PR不应该导致合并问题，因为我所知道的其他人都不会在同一个区域工作。</p>
</div>
<div class="paragraph">
<p>您可以通过在每个文件中搜索 POD-ONLY 来查看 Grammar.nqp 和 Actions.nqp 中 POD-only 代码的起点，您会发现：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>#================================================================
# POD-ONLY CODE HANDLERS
#================================================================
# move ALL Pod-only [grammar|action] objects here</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_3">31.5. 总结</h3>
<div class="paragraph">
<p>我逐渐了解了如何改进 Rakudo Raku grammar 和实现一些 NYI POD 功能的 actions，我希望尽快交付它们。在工作期间，我从困难的方式学到了许多课程，并希望我对 POD 解析的黑暗角落有所了解。</p>
</div>
<div class="paragraph">
<p>从任何主要编码项目中拿走的最后一课：为合并提交制作，测试和提交小的（即有限的）更改！我在 POD 特征的有时弯曲的解析路径中被包裹起来，我做了太多的改变，并且不能轻易地撤消它们。我希望我不要重蹈覆辙。</p>
</div>
<div class="paragraph">
<p>我希望你和你的 Rakuish 圣诞快乐和新年快乐，并且用 Charles Dickens 的 Tiny Tim（圣诞颂歌）不朽的话来说，“上帝保佑我们，每一个人！”
== 第五天 - 变量</p>
</div>
<div class="paragraph">
<p>这么简单的事，不是吗？ 变量是一个保存着值的名字。</p>
</div>
<div class="paragraph">
<p>有时候，它持有的值可能会被另一个值所取代 - 因此就是名字。 （根据外科医生的说法，没有经常变化的变量应该看医生，并要求被诊断为常数。）</p>
</div>
<div class="paragraph">
<p>虽然它们很容易掌握，而且基本上每种语言都有它们，但我今天的目标是让你相信变量实际上非常棘手。 好的方式！ 我的目的是让你被这篇博文绊倒，茫然，喃喃自语“我以为我知道变量，但我真的不知道…​…​”。</p>
</div>
<div class="paragraph">
<p>接近最后，<a href="http://github.com/masak/007/">实验语言007</a>也将会出现，我考虑变量这么多完全是这种语言的过错。</p>
</div>
</div>
<div class="sect2">
<h3 id="_左还是右">31.6. 左还是右？</h3>
<div class="paragraph">
<p>变量奇怪的第一种方式是它们以两种完全不同的方式使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = &#34;Christmas&#34;;

say(&#34;Merry &#34; ~ $x);       # reading
$x = &#34;Easter&#34;;            # writing</code></pre>
</div>
</div>
<div class="paragraph">
<p>有时我们使用变量来读取值，有时我们使用它们来写一个值。但在这两种情况下，语法看起来完全一样！一些较旧的语言（例如Forth）实际上对这两种用法有不同的语法，我喜欢它们。但是这样的惯例似乎并没有幸存到现代。</p>
</div>
<div class="paragraph">
<p>相反，我们通过语法位置来区分这两种用法。如果你在赋值的左侧，那么你就被写了。否则，你正在被读取。</p>
</div>
<div class="paragraph">
<p>在文献中，这两种用途分别称为 <strong>lvalues</strong> 和 <strong>rvalues</strong>。分别为“左”和“右”。</p>
</div>
<div class="paragraph">
<p>Rvalues 非常正常，与我们对变量的一般考虑方式相对应;他们只是计算它们包含的值。然而，Lvalues 很奇怪。它们更像是盒子，你可以把东西放入（或内存位置？引用？），或者如果不是盒子本身，那么分离的能力放入其中。如果 lvalues 有一个类型，它看起来像 <code>(T) → void</code>，接受 <code>T</code> 但不返回任何东西的东西。</p>
</div>
</div>
<div class="sect2">
<h3 id="_参数">31.7. 参数</h3>
<div class="paragraph">
<p>变量对现代编程至关重要。 还有一个原则表明它们完全没有必要。</p>
</div>
<div class="paragraph">
<p>那就对了！ Tennent 的通信原则！ （我知道你在想什么。不，我说的不是那个 <a href="https://en.wikipedia.org/wiki/Tenth_Doctor">Tennant</a>。</p>
</div>
<div class="paragraph">
<p>这个原则主要指向一种在程序中重写所有变量声明的方法，因此它们是参数声明。 一个例子应该足以展示一般原则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Before
my $veggie = &#34;potato&#34;;
say &#34;$veggie, and that&#39;s all I have to say about that!&#34;;

# After
(-&gt; $veggie {
    say &#34;$veggie, and that&#39;s all I have to say about that!&#34;;
})(&#34;potato&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>看看变量声明如何变成参数声明，相应的赋值转变为参数？有经验的（或者我应该说是饱受争吵蹂躏的）JavaScript开发人员将这种结构视为 <a href="https://stackoverflow.com/questions/8228281/what-is-the-function-construct-in-javascript">IIFE</a>。</p>
</div>
<div class="paragraph">
<p>由于我们总能进行这种转换，因此我们并不需要变量。只有参数。我主要是告诉你这个，所以你可以有点特别感谢你不必用参数编写你的代码。</p>
</div>
<div class="paragraph">
<p>关于Tennent的通信原则的最后注释：它的原始用法在<a href="https://en.wikipedia.org/wiki/S-algol#Semantic_principles">维基百科</a>上有简要描述。它基本上被遗忘了，直到Java即将获得闭包并且它的名称被调用并且原则<a href="https://softwareengineering.stackexchange.com/questions/116395/what-is-the-good-explanation-of-tennents-correspondence-principle">被过度使用了一些</a>，也许。</p>
</div>
</div>
<div class="sect2">
<h3 id="_动态范围">31.8. 动态范围</h3>
<div class="paragraph">
<p>在Raku中，只要变量范围偏离词法范围，变量就会产生额外的“twigil”（sigil之后的可选符号）。这些替代范围中最重要的可能只是动态范围。</p>
</div>
<div class="paragraph">
<p>同样，我们最好用一个例子来说明差异：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $lexical = &#34;mainline&#34;;
my $*dynamic = &#34;mainline&#34;;

sub foo() {
    my $lexical = &#34;foo&#34;;
    my $*dynamic = &#34;foo&#34;;
    bar();
}

sub bar() {
    say $lexical;       # &#34;mainline&#34;
    say $*dynamic;      # &#34;foo&#34;
}

foo();</code></pre>
</div>
</div>
<div class="paragraph">
<p>忘记处女座和Saggitarius以及其他占星术的迹象。对于你更深层次的个性而言，值得做的唯一区别就是你是在做词法查找还是动态查找。毕竟，只有两种人。</p>
</div>
<div class="paragraph">
<p>无论我们喜不喜欢，查找都是一个过程。我们给了一个名字，然后我们去找相应的值。我知道，这令人沮丧。但无论如何，让我们这样做，看看它在哪里。</p>
</div>
<div class="paragraph">
<p>对于 <code>$lexical</code>，通过查看程序文本本身来进行查找。该变量是否定义在我们所在的最小范围内，那个 <code>bar</code> sub？ （事实并非如此。）然后我们向外走，直到周围的范围 - 这最终成为整个计划的范围。它是在那里定义的吗？是!真幸运的是我们从查找中获得胜利，其值为 <code>“mainline”</code>。</p>
</div>
<div class="paragraph">
<p><code>$*dynamic</code> - 请注意名字中的星号？我告诉过你有占星术！ - 我们也从最里面的范围，<code>bar</code> sub开始，并在那里寻找定义。 （我们找不到。）但现在发生了一些不同的事情。我们不会向外跟随块结构，而是向上跟随调用链。谁调用给我们？ <code>foo</code>。这就是我们的目标。那里有定义吗？是!所以我们已经完成并且成功了。</p>
</div>
<div class="paragraph">
<p>从历史的角度来看，动态查找是“明显的”，大多数语言最初都有它。词汇查找只是逐渐证明了它的价值，现在已成为流行病。 Perl 5实际上跨越了这段历史，而我的变量是词法，但较旧的我们/包变量是动态的。这就是你在历史发生时从身边得到的东西。</p>
</div>
<div class="paragraph">
<p>在Raku中，我们也通过禁止术语“父范围”来履行自己的职责。在一个词法和动态查找的世界里，它太混乱了。相反，我们更喜欢术语 <code>OUTER</code>（用于词法查找）和`CALLER`（用于动态查找）。</p>
</div>
<div class="paragraph">
<p>如果可能的话，Raku中的一些结构（例如`return`和`next`）会尝试词法，但如果找不到任何词汇周围的东西来“附加”，则会回归到动态。这种类型的行为似乎没有真正的学术术语，所以Raku的概要称它为“lexotic”。</p>
</div>
</div>
<div class="sect2">
<h3 id="_宏里面的变量">31.9. 宏里面的变量</h3>
<div class="paragraph">
<p>还在我这儿？礼包。 我们来谈谈宏。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use experimental :macros;

macro moo {
    my $counter = 0;
    quasi {
        say ++$counter;
    }
}

for ^10 {
    moo;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个简单的宏，只是将代码中的 <code>++$counter</code> 注入到 <code>for</code> 循环中。该程序将在各行上打印从1到10的所有数字。</p>
</div>
<div class="paragraph">
<p>很好，但…​…​怎么样？请注意，宏扩展代码引用 <code>$counter</code>，但词法查找（如上所述）将找不到在周围词法范围内声明的变量。但是，这个程序仍然有效，或者更确切地说，是有效的。</p>
</div>
<div class="paragraph">
<p>那么使程序运作的基本原则是什么呢？事实证明，通过一个非常幸运的偶然事件，在宏体内定义的变量可以被“无法统一”并被左值替换。注入的代码说 <code>$counter` 实际上看起来更像是 `☐</code>，其中 <code>☐</code> 代表那个（代表不可代理的）左值。</p>
</div>
<div class="paragraph">
<p>我知道这是一件小事，但是当我最终把它放在一起时我很高兴。事实上，我很高兴我把它写成<a href="https://github.com/masak/007/issues/410">github iuuse</a>，只是为了确保细节都能解决。请继续关注此项的实现，从而保持卫生。</p>
</div>
<div class="paragraph">
<p>（对于那些在家中保持分数的人来说，卫生宏是<a href="http://news.perlfoundation.org/2011/09/hague-grant-application-implem.html">本拨款申请</a>中的里程碑D3。）</p>
</div>
<div class="paragraph">
<p>需要明确的是 - 这更像是一种实现意图。 Raku（和007）尚未实现完全卫生。但是，拥有明确的前进道路令人振奋。</p>
</div>
<div class="paragraph">
<p>无论如何，这是变数。他们很可爱，有点奇怪，但最后我们很高兴他们在那里。快乐的历险。☺</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第六天_懒惰精灵与勤劳精灵">32. 第六天 - 懒惰精灵与勤劳精灵</h2>
<div class="sectionbody">
<div class="paragraph">
<p>对圣诞老人来说，圣诞节总是一年中最忙碌的时刻。 幸运的是，圣诞老人有很多帮手。 他们总是做一些小工作和家务，只是为了创造最好的假日季节体验！</p>
</div>
<div class="paragraph">
<p><a href="https://modules.raku.org/dist/Object::Delayed">Object::Delayed</a> 模块为圣诞老人的快乐精灵添加了两个非常有趣的精灵！ 他们的名字是 <code>slack</code> 和 <code>catchup</code>!</p>
</div>
<div class="sect2">
<h3 id="_lazy_slack">32.1. Lazy slack</h3>
<div class="paragraph">
<p>那个懒散的(<code>slack</code>)精灵确实非常懒惰。 懒散(<code>slack</code>)精灵不会做任何事情，直到你真的需要他去做。 虽然人们可以认为这是精灵中非常糟糕的性格特征，但它也是一种非常生态的特征。 人们可以认为这个懒散的(<code>slack</code>)精灵是他们所有人中最环保的精灵！ 你有多少次要求精灵为你做点事情，然后却没用过那个精灵辛苦工作的结果？ 即使它只是到处移动的被回收的电子，但仍然需要能量来移动它们！ 特别是, 如果那些电子被用来告诉其他精灵做一些遥远的事情，就像在外部数据库中一样！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Object::Delayed;
my $dbh = slack { DBIish.connect(...) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是你需要的 <code>$dbh</code> 变量，它只在实际需要时才与数据库建立连接。 当然，如果你想对该数据库进行查询，那么也可以使其懒惰！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Object::Delayed;
my $dbh = slack { DBIish.connect(...) }
my $sth = slack { $dbh.prepare(...) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于语句句柄也是懒惰的，因此在实际需要之前它实际上不会进行查询准备。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Object::Delayed;
my $dbh = slack { DBIish.connect(...) }
my $sth = slack { $dbh.prepare(...) }
# lotsa program
if $needed {
    $sth.execute;  # opens database handle + prepares query
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，如果 <code>$needed</code> 为 true，调用 <code>.execute</code> 函数将使 <code>$sth</code> 成为一个真正的 statemement 句柄，因为它使 <code>$dbh</code> 成为真正的数据库句柄。 那不是很好吗？ 因为如果你不需要它，所有进行查询准备的精灵都可以做其他的事情，而建立数据库连接的精灵也可以做其他事情。 更不用说数据库中的精灵们根本不知道你最初计划建立一个数据库连接！</p>
</div>
<div class="paragraph">
<p>当然，如果您确实需要数据库连接，那么告诉数据库的精灵们您已经完成了这一点总是一个好主意。 在 Raku 中，这不会自动发生，因为圣诞老人不会跟踪每个精灵的行为。 圣诞老人喜欢委派责任！ 当您离开需要数据库句柄的代码部分时，通常会告诉数据库精灵您已完成的工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">LEAVE .disconnect with $dbh;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>LEAVE</code> 精灵的特殊之处在于，当你离开被称为 <code>LEAVE</code> 精灵的街区时，它将完成被告知要做的事情。 在这种情况下，如果 <code>$dbh</code> 被定义，则在 <code>$<em></em></code><em> 上调用 <code>.disconnect</code> 方法：<code>with</code> 精灵不仅测试是否定义了给定值，还设置 <code>$</code></em>。</p>
</div>
<div class="paragraph">
<p>但是，但是，不会检查 <code>$dbh</code> 是否实际定义了与数据库的连接？ 不，这个懒散的精灵足够聪明，如果你问的是某个东西是 <code>.defined</code>，还是真或假，它实际上不会开始为你做这项工作。 这与 <code>catchup</code> 精灵有什么不同！</p>
</div>
</div>
<div class="sect2">
<h3 id="_尽力追赶">32.2. 尽力追赶</h3>
<div class="paragraph">
<p>如果懒惰精灵是圣诞老人雇佣的最环保的精灵，那么 <code>catchup</code> 肯定是最红的精灵。 因为你总是试图赶上 <code>catchup</code> 精灵。 但是追赶精灵似乎只是非常勤奋。</p>
</div>
<div class="paragraph">
<p>当你告诉 <code>catchup</code> 精灵做某事时，<code>catchup</code> 精灵会立即找到另一个精灵去做实际的工作并告诉你它完成了。 最有可能的不是。 当你真正想要使用你要求 <code>catchup</code> 精灵做的结果时，有两种可能性：如果另一个精灵完成并且结果可用，你将立即从`catchup` 精灵那里得到它。 如果其他精灵尚未完成，它将让你等到另一个精灵完成：它会迫使你赶上！ 那看起来怎么样？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Object::Delayed;
my $foo = catchup { sleep 5; &#34;Merry&#34; }      # sleep is just
my $bar = catchup { sleep 9; &#34;Christmas&#34; }  # another word
my $baz = catchup { sleep 8; &#34;everyone&#34; }   # for baking
say “$foo $bar, $baz!”;
say “Took { now - INIT now } seconds”;
# Merry Christmas, everybody!
# Took 9.008 seconds</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，<code>catchup</code> 精灵有另外3个精灵正在制作那些带有甜味硬壳釉的精美烘焙刻字，每个字母花费大约一秒钟。 如果只有一个精灵这样做，它至少需要5 + 9 + 8 = 22秒。 感谢 <code>catchup</code> 精灵，只用了9秒多一点！ 快了两倍多！</p>
</div>
<div class="paragraph">
<p>当然，如果所有其他精灵都在忙着做其他事情，那实际上可能需要一点时间而不是超过9秒。 或者甚至超过22秒，如果其他精灵正在处理更重要的事情，而不是用正确的玻璃烘焙字母。 所以你的精灵里程可能会有所不同。 你不想过度劳累你的精灵，也不要太久。 几秒钟应该没问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_use_the_right_elf">32.3. Use the right elf</h3>
<div class="paragraph">
<p>如果你想尽可能的绿色，请使用 <code>slack</code> 精灵。 如果你想要它，并且你现在想要它（嗯，尽快），那么如果你能够合理地确定有足够的其他精灵来完成实际的工作，那么使用 <code>catchup</code> 精灵是一个选择！</p>
</div>
<div class="paragraph">
<p>参与此博客文章的所有精灵们都欢呼！ 你真的非常确定没有任何快速，慢速或任何其他精灵以任何方式受到伤害。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第七天_细胞自动机">33. 第七天 – 细胞自动机</h2>
<div class="sectionbody">
<div class="paragraph">
<p>今天的降临日历帖子涉及Cellular Automata。</p>
</div>
<div class="paragraph">
<p>什么是细胞自动机？我很高兴你问！它们是由几个部分组成的系统：由细胞组成的一种场或“世界”，每个细胞可以在任何点处的一组状态，描述每个细胞可见的细胞的“邻域” ，以及一套规则，用于管理一个单元将其状态改变为什么状态以及其邻域中所有单元的状态。</p>
</div>
<div class="paragraph">
<p>当然，这是一个非常抽象的描述，所以让我举一些个别部分的例子，希望能让你了解你在细胞自动机中看到的内容：</p>
</div>
<div class="paragraph">
<p>在典型的世界中，你可能会发现细胞像串珠一样排列，或者像国际象棋或中国跳棋板上的字段。您还可以组成更多奇特的配置：任何二维场都可以映射到任何表面，例如<a href="https://en.wikipedia.org/wiki/Stanford_bunny">斯坦福兔子</a></p>
</div>
<div class="paragraph">
<p>你可以在野外找到的状态集是“从0到n的数字”，“这里有细菌”，“黑白颜色”（或更多）。由于您基本上可以将任何信息表示为“数字”，并且允许任意数量的状态，因此还可以存在表示“此时此单元格中有多少粒子在上升，下降，向左或向右移动的状态？ “作为整数或甚至浮点数。</p>
</div>
<div class="paragraph">
<p>邻域可以被认为是细胞“连接在一起”的模式。典型的社区将是“前面的一个，后面的一个”的“串珠”字段，以及“北，东，南，西”或“北，东北，东，东南，南，西南，西，西北“对于棋盘场 - 这两个分别是冯诺依曼附近和摩尔附近。</p>
</div>
<div class="paragraph">
<p>管理每个单元的邻域中的状态的一组规则将导致哪个状态转到其他状态可被视为特定元胞自动机的核心。</p>
</div>
<div class="paragraph">
<p>在今天的降临日历中，我们将探索您可能称之为最简单的自动机。我们将字段串起来像字符串上的珠子，我们将尝试一个或两个和一些不同的状态集。</p>
</div>
<div class="paragraph">
<p>为了让家里的人感兴趣，我将为您提供链接，让您在浏览器中运行示例代码，或在家中使用您的本地raku编译器！</p>
</div>
<div class="sect2">
<h3 id="_为学习而做">33.1. 为学习而做</h3>
<div class="paragraph">
<p>让我们开始，然后：</p>
</div>
<div class="paragraph">
<p>首先，我们需要什么？世界上必须有存储空间，需要一些代码来获得一个符合条件的邻居，以及一些代码来计算一个单元的下一个状态，给定它自己的状态和邻居的状态。最重要的是，我们想看看发生了什么，所以我们也有一些代码。</p>
</div>
<div class="paragraph">
<p>在确定每个单元可以具有哪些状态之后，我们将知道什么存储适合于我们的世界。使用8位整数数组将允许我们从任何不超过255个单独状态的状态集中进行选择。不过，让我们现在共计3个州。我们可以随心所欲地初始化世界，但是将每个字段设置为随机有效状态是一个很好的起点。另一个是将一个状态的单个单元放在中间，并使每个其他单元具有不同的状态。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant number-of-states = 3;
constant field-width = 60;

my int8 @field;

sub init-field {
    @field = (^number-of-states).roll(field-width);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>显示字段非常简单，具体取决于我们使用的输出。 这是一段可以在任何控制台中运行的代码，下面是一个6pad的链接，它在pad的HTML部分输出很少的彩色方块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub output-a-row {

    for @field {
        # Using the unicode characters &#34;Light shade&#34;, &#34;Medium shade&#34;, and &#34;Dark shade&#34;
        # and printing each field twice so they look square rather than slim and tall.
        print [&#34;\x2591&#34;, &#34;\x2592&#34;, &#34;\x2593&#34;][$_] x 2
    }

    say &#34;&#34;;
}

init-field;
output-a-row;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在<a href="https://raku.github.io/6pad/#baa305eff795ed1f7a1957b83a9d4b26">浏览器</a>中运行此代码。 你将不得不等待几秒钟来获得当前相当大的raku编译器在javascript中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_走在前面">33.2. 走在前面</h3>
<div class="paragraph">
<p>从单个行到单元格的自动机的模拟运行需要一次完成一大堆部分。</p>
</div>
<div class="paragraph">
<p>根据他们的定义，细胞自动机将同时推进其所有细胞。 我们当然不会去云端获得拥有与我们领域中的单元一样多的cpu内核的机器。 我们将通过一个简单的循环遍历所有字段来解决“根据它们的相邻单元格在上一步中计算每个单元格的下一步”。</p>
</div>
<div class="paragraph">
<p>对此的直接方法是在每个步骤之后有一个额外的字段来放置计算结果并将结果复制到“真实”字段数组中。 让我们尝试一下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub simulate-step {
    my int8 @output;

    for ^field-width -&gt; $x {
        # do some calculations here
    }

    @field = @output;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们看看我们需要什么来进行计算：新状态将取决于邻域和单元本身。 我们可能会选择最明显的社区：一个小区，它是该领域的前身和继承者。 但等等，第一个和最后一个细胞会发生什么？ 让我们假装他们有一个额外的邻居，它总是处于0状态。这样</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub simulate-step {
    my int8 @output;

    for ^field-width -&gt; $x {
        my $left   = $x - 1 &lt; 0 ?? 0 !! @field[$x - 1];
        my $middle = @field[$x];
        my $right  = $x + 1 &gt;= field-width ?? 0 !! @field[$x + 1];

        # do some calculation with $left, $middle, and $right
        # then push the result into @output
    }

    @field = @output;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以，我们终于到了我们需要决定我们的细胞自动机实际上应该首先做什么的地方。 但是，当我们甚至没有赋予“0,1和2”状态的含义时，我们应该如何弄清楚它应该做什么？</p>
</div>
<div class="paragraph">
<p>答案很简单！ 从字面上理解这一切。</p>
</div>
</div>
<div class="sect2">
<h3 id="_制作东西">33.3. 制作东西</h3>
<div class="paragraph">
<p>我的意思是，我们目前并不关心细胞自动机的作用，只要看起来不错。 那么为什么不预先通过滚动一些想象中的骰子来预先决定应该发生什么呢？</p>
</div>
<div class="paragraph">
<p>为此目的，它有助于知道有多少可能的“配置”甚至是单元及其邻居所在的。幸运的是，这很简单。 您可以将三个单元格想象为由三位数组成的数字，并且每个数字都允许为0,1或2。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">000  001  002
010  011  012
020  021  022
100  101  102
110  111  112
120  121  122
200  201  202
210  211  212
220  221  222</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我没有陷入困境，那就是左，中，右单元组成的所有可能性。 就像四位二进制数可以是2⁴数之一一样，这个三位三进制数可以是  3³。 这意味着我们只需要在0到2之间选择  3³ 个数字，上面表格中每个数字一个。</p>
</div>
<div class="paragraph">
<p>这样做真的很愉快！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my int8 @lookup-table = (^number-of-states).roll(3³);</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且给定 <code>$left</code>，<code>$middle</code> 和 <code>$right</code> 变量，我们可以将第一个与9相乘，第二个与3相乘，并将三者相加以获得查询表中的索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub simulate-step {
    my int8 @output;

    for ^field-width -&gt; $x {
        my $left   = $x - 1 &lt; 0 ?? 0 !! @field[$x - 1];
        my $middle = @field[$x];
        my $right  = $x + 1 &gt;= field-width ?? 0 !! @field[$x + 1];

        my $index = $left * 9 + $middle * 3 + $right;

        @output.push(@lookup-table[$index]);
    }

    @field = @output;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行这个已经让我们看起来很闪亮。 我们需要做的就是连接潜艇：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant number-of-states = 3;
constant field-width = 60;

my int8 @field;

sub init-field {
    @field = (^number-of-states).roll(field-width);
}
init-field;

sub output-a-row {

    for @field {
        # Using the unicode characters &#34;Light shade&#34;, &#34;Medium shade&#34;, and &#34;Dark shade&#34;
        # and printing each field twice so they look square rather than slim and tall.
        print [&#34;\x2591&#34;, &#34;\x2592&#34;, &#34;\x2593&#34;][$_] x 2
    }

    say &#34;&#34;;
}

my int8 @lookup-table = (^number-of-states).roll(3³);

sub simulate-step {
    my int8 @output;

    for ^field-width -&gt; $x {
        my $left   = $x - 1 &lt; 0 ?? 0 !! @field[$x - 1];
        my $middle = @field[$x];
        my $right  = $x + 1 &gt;= field-width ?? 0 !! @field[$x + 1];

        my $index = $left * 9 + $middle * 3 + $right;

        @output.push(@lookup-table[$index]);
    }

    @field = @output;
}

for ^100 {
    simulate-step;
    output-a-row;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果在某些时候看起来非常有趣！ 当然，我们需要通过随机查找表获得幸运。 如果你有很多无趣的东西，我喜欢这里的一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my int8 @lookup-table = &lt;0 0 2 0 0 0 1 2 0 0 1 1 2 1 1 2 1 1 1 0 1 2 2 0 2 1 1&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里是<a href="https://raku.github.io/6pad/#cb1856d301959e3d3dca95925eab2bee">6pad</a>的链接，您可以在浏览器中试用它。</p>
</div>
<div class="paragraph">
<p>第三，这是我的机器的截图，以防您在移动设备上阅读或其他无法运行raku的内容。</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/fish-tmp_112.png">img</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_改变">33.4. 改变</h3>
<div class="paragraph">
<p>现在我们的模拟器完成了它应该做的事情，让我们通过一些调整获得一些乐趣。</p>
</div>
<div class="paragraph">
<p>首先，让我们看看增加不同状态数量需要做些什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant number-of-states = 4;

# the size of the lookup table should be based on the number of states
my int8 @lookup-table = (^number-of-states).roll(number-of-states³);

sub output-a-row {

    for @field {
        # add unicode character &#34;Full block&#34; for the fourth state
        print [&#34;\x2591&#34;, &#34;\x2592&#34;, &#34;\x2593&#34;, &#34;\x2588&#34;][$_] x 2
    }

    say &#34;&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且计算也需要基于状态数进行计算：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $index = $left * number-of-states * number-of-states
            + $middle * number-of-states
            + $right;</code></pre>
</div>
</div>
<div class="paragraph">
<p>那已经是它了！ 到目前为止，甚至都不是很难。</p>
</div>
</div>
<div class="sect2">
<h3 id="_改变邻居">33.5. 改变邻居</h3>
<div class="paragraph">
<p>现在这个更有趣了。 更改邻域将需要我们的计算循环来为索引计算获取更多变量，并且查找表也将再次更改其大小。</p>
</div>
<div class="paragraph">
<p>让我们回到3个状态而不是4个状态，用一个只有一个单元格的单元替换邻域：我们将采用单元格的前任及其后继者，但忽略单元格本身。 然后我们添加了前任的前任和后继者的继任者：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># three states, but four neighbors
constant number-of-states = 3;
constant number-of-neighbors = 4;

# ...

# exponentiate number-of-states with number-of-neighbors, like
# you would to get a number-of-neighbors number in base number-of-states.
my int8 @lookup-table = (^number-of-states).roll(number-of-states ** number-of-neighbors);

sub simulate-step {
   my int8 @output;

   for ^field-width -&gt; $x {
       my $leftleft   = $x &lt;= 1 ?? 0 !! @field[$x - 2];
       my $left       = $x == 0 ?? 0 !! @field[$x - 1];

       my $right      = $x == field-width - 1 ?? 0 !! @field[$x + 1];
       my $rightright = $x &gt;= field-width - 2 ?? 0 !! @field[$x + 2];

       # many multiplications later ...
       my $index = $leftleft * number-of-states * number-of-states * number-of-states
                   + $left   * number-of-states * number-of-states
                   + $right  * number-of-states
                   + $rightright;

       @output.push(@lookup-table[$index]);
   }

   @field = @output;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/fish-tmp_113.png">img</a></p>
</div>
<div class="paragraph">
<p>这是试用它的 <a href="https://raku.github.io/6pad/#98c06c9c9aafaf36c9c4fbf320d9c9cc">6pad</a></p>
</div>
<div class="paragraph">
<p>可悲的是，它似乎只是让输出变得更加混乱。</p>
</div>
</div>
<div class="sect2">
<h3 id="_优化机会">33.6. 优化机会？</h3>
<div class="paragraph">
<p>目前，代码是高性能和可读性之间的折衷。 它也可能看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (0, |@field, 0).rotor(3 =&gt; -2) -&gt; ($left, $middle, $right) {
    my $index = :3[$right, $middle, $left];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然我的直觉告诉我，这会明显变慢。</p>
</div>
<div class="paragraph">
<p>但是我们可以使代码更快一点，甚至不会牺牲太多的可读性！</p>
</div>
<div class="paragraph">
<p>有一件事我们的计算循环太多了：数组访问！ 连续三次访问每个单元格：一旦它变为 <code>$right</code>，再次变为 <code>$middle</code>，另一次变为 <code>$left</code>。</p>
</div>
<div class="paragraph">
<p>那么我们怎样才能做得更好呢？ 我想到的第一件事是让变量 <code>$left</code>，<code>$middle</code> 和 <code>$right</code> 在迭代之间保持不变并通过以下方式移动单元格值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $left   = 0;
my $middle = @field[0];
my $right  = @field[1];

for ^field-width -&gt; $x {
    my $index = $left * number-of-states * number-of-states
            + $middle * number-of-states
            + $right;

    @output.push: @lookup-table[$index];
    $left = $middle;
    $middle = $right;
    $right = $x + 1 &gt;= field-width ?? 0 !! @field[$x + 1];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>很酷，我们甚至已经摆脱了 <code>$x</code> vs field-width的检查！ 但是还有另一件事情一遍又一遍地发生，我们可以做一点点简单。 我们可以让 <code>$left</code>，<code>$middle</code> 和 <code>$right</code> 变量已经保存了添加所需的确切值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $left   = 0;
my $middle = @field[0] * 3;
my $right  = @field[1];

for ^field-width -&gt; $x {
    my $index = $left + $middle + $right;

    @output.push: @lookup-table[$index];
    $left = $middle * 3;
    $middle = $right * 3;
    $right = $x + 1 &gt;= field-width ?? 0 !! @field[$x + 1];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我认为看起来很整洁！</p>
</div>
</div>
<div class="sect2">
<h3 id="_其他变化">33.7. 其他变化？</h3>
<div class="paragraph">
<p>我遇到的一种细胞自动机是每个细胞都有机会在每一步上进行计算的细胞自动机，否则只需保持其状态一步。 让我们看看它是如何实现的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant probability = 0.75e0;

my $left   = 0;
my $middle = @field[0] * 3;
my $right  = @field[1];

for ^field-width -&gt; $x {
    if rand &lt; probability {
        my $index = $left + $middle + $right;

        @output.push: @lookup-table[$index];
    }
    else {
        @output.push: $middle;
    }
    $left = $middle * 3;
    $middle = $right * 3;
    $right = $x + 1 &gt;= field-width ?? 0 !! @field[$x + 1];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>较低的概率很容易被发现，因为它们会使得到的图像看起来垂直拉伸。 较高的概率可以导致完全规则的模式保持大部分完整，但在某些时候可以在一两个点被分解。</p>
</div>
<div class="paragraph">
<p>这是给你的截图！</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/fish-tmp_114.png">img</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_这有用吗">33.8. 这有用吗？</h3>
<div class="paragraph">
<p>细胞自动机通常是非常通用的，甚至非常简单的自动机也可以处理通用计算，如“<a href="http://mathworld.wolfram.com/Rule110.html">规则110</a>”。还有更复杂的自动机，如<a href="https://en.wikipedia.org/wiki/Von_Neumann_universal_constructor">Von Neumann的能够自我复制的机器</a>和WireWorld，它已被用来构建<a href="https://www.quinapalus.com/wires11.html">一台可以计算素数并在七段显示器上显示它们的小机器</a>。</p>
</div>
<div class="paragraph">
<p>非常令人惊讶的是，有一台<a href="http://conwaylife.com/wiki/Turing_machine">图灵机</a>带有一个由非常受欢迎的生命游戏构建的文字磁带，并且可能更令人惊讶的是，它可以计算并显示<a href="http://conwaylife.com/wiki/OTCA_metapixel">生命游戏的生命游戏配置</a>。</p>
</div>
<div class="paragraph">
<p>总而言之，我发现细胞自动机是一个引人入胜的话题。在这篇文章中几乎没有提到二维细胞自动机，但除了本节已经提到的那些之外，还有许多有趣的自动机。</p>
</div>
<div class="paragraph">
<p>实施方面，您很可能不会使用CPU代码来模拟细胞自动机。至少，你不会使用遍历每个单独单元的循环 - 请参阅奇妙的<a href="http://conwaylife.com/wiki/Hashlife">HashLife算法</a>，该算法将世界切换为经常出现的越来越大的块，并立即执行许多全世界的步骤。否则，您很可能会在GPU上模拟CA，当每个单元的代码运行相同时，它会提供极高的并行度。</p>
</div>
<div class="paragraph">
<p>感谢您通过这个非常长的帖子陪伴我！</p>
</div>
<div class="paragraph">
<p>我希望我甚至可以唤醒对细胞自动机的奇妙和广阔世界的空洞兴趣！</p>
</div>
<div class="paragraph">
<p>每个人都有一个可爱的十二月！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第八天_让你的_raku_grammar_紧凑一点">34. 第八天 — 让你的 Raku grammar 紧凑一点</h2>
<div class="sectionbody">
<div class="paragraph">
<p>欢迎来到今年的 Raku Advent Calendar 的第8天！</p>
</div>
<div class="paragraph">
<p>Grammars 是使 Raku 成为一种优秀编程语言的众多因素之一。 我甚至不会尝试预测轮询的结果，以便在 grammars，Unicode 支持，并发功能，超运算符或集合语法之间进行选择，或者选择 Whatever star。 谷歌发现了自己在互联网上发布的最好的 Raku 功能列表。</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/screen-shot-2018-12-01-at-13-15-01.png">img</a></p>
</div>
<div class="paragraph">
<p>无论如何，今天我们将讨论 Raku grammars，我将分享一些技巧，用于使 grammars 更紧凑。</p>
</div>
<div class="sect2">
<h3 id="_1_拆分_actions">34.1. 1.拆分 actions</h3>
<div class="paragraph">
<p>假设您正在编写 grammar 来解析 Perl 的变量声明。 您希望它与以下语句匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s; my @a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它们都声明了一个变量，因此我们可以制定一个通用规则来解析这两种情况。 下面是完整的程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
    rule TOP {
        &lt;variable-declaration&gt;* %% &#39;;&#39;
    }

    rule variable-declaration {
        | &lt;scalar-declaration&gt;
        | &lt;array-declaration&gt;
    }

    rule scalar-declaration {
        &#39;my&#39; &#39;$&#39; &lt;variable-name&gt;
    }

    rule array-declaration {
        &#39;my&#39; &#39;@&#39; &lt;variable-name&gt;
    }

    token variable-name {
        \w+
    }
}

class A {
    has %!var;

    method TOP($/) {
        dd %!var;
    }

    method variable-declaration($/) {
        if $&lt;scalar-declaration&gt; {
            %!var{$&lt;scalar-declaration&gt;&lt;variable-name&gt;} = 0;
        }
        elsif $&lt;array-declaration&gt; {
            %!var{$&lt;array-declaration&gt;&lt;variable-name&gt;} = [];
        }
    }
}

G.parse(&#39;my $s; my @a;&#39;, :actions(A.new));</code></pre>
</div>
</div>
<div class="paragraph">
<p>我不解释这个程序的每一点; 如果您有兴趣，可以在最近的 <a href="http://perl.nl/amsterdam">Amsterdam.pm</a> 会议上观看<a href="https://www.youtube.com/watch?v=YWTmd4Hdfa4">80分钟的视频</a>。</p>
</div>
<div class="paragraph">
<p>现在感兴趣的对象是规则 <code>variable-declaration</code> 及其相应的 action。</p>
</div>
<div class="paragraph">
<p>该规则包含两个选项：是否声明了标量或数组。 该 action 还在选项之间进行选择，并使用 <code>if-else</code> 块执行该 action 操作。 Raku 允许你省略布尔条件周围的括号，但是，整个结构仍然很大。 例如，想想如果添加哈希声明，则需要添加另一个 <code>elsif</code> 分支。</p>
</div>
<div class="paragraph">
<p>为每个子分支分别采取 action 操作会更清楚：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method scalar-declaration($/) {
    %!var{$&lt;variable-name&gt;} = 0;
}

method array-declaration($/) {
    %!var{$&lt;variable-name&gt;} = [];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，每个方法的主体包含单行代码，你可以立即看到它正在做什么。 更不用说它变得不那么容易出错了。</p>
</div>
<div class="paragraph">
<p>在我们继续讨论下一个技巧之前，你可能需要实现另一个优化：<code>my</code> 关键字出现在任一声明中，因此请使用非捕获括号并将公用字符串从它们之中移出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule variable-declaration {
    &#39;my&#39; [
        | &lt;scalar-declaration&gt;
        | &lt;array-declaration&gt;
    ]
}

rule scalar-declaration {
    &#39;$&#39; &lt;variable-name&gt;
}

rule array-declaration {
    &#39;@&#39; &lt;variable-name&gt;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用_multi_方法">34.2. 使用 multi 方法</h3>
<div class="paragraph">
<p>让我们改进 grammar 以允许使用目标语言进行赋值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s; my @a; $s = 3; $a[1] = 4;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，赋值是以 Perl 5 样式完成的，数组元素为 sigil。 有了这个，可以使用以美元开头的单个规则来完成赋值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
    rule TOP {
        [
            | &lt;variable-declaration&gt;
            | &lt;assignment&gt;
        ]
        * %% &#39;;&#39;
    }

    # . . .

    rule assignment {
        &#39;$&#39; &lt;variable-name&gt; &lt;index&gt;? &#39;=&#39; &lt;value&gt;
    }

    rule index {
        &#39;[&#39; &lt;value&gt; &#39;]&#39;
    }

    token value {
        \d+
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，<code>assignment</code> action 操作必须推断出它目前正在处理的赋值类型。</p>
</div>
<div class="paragraph">
<p>同样，您可以使用我们的老朋友，action 操作中的 <code>if-else</code> 块。 根据索引的存在，您可以确定这是一个简单的标量还是数组的元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method assignment($/) {
    if $&lt;index&gt; {
        %!var{$&lt;variable-name&gt;}[$&lt;index&gt;&lt;value&gt;] = +$&lt;value&gt;;
    }
    else {
        %!var{$&lt;variable-name&gt;} = +$&lt;value&gt;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码也可以轻松简化，但这次使用 multi 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method assignment($/ where !$&lt;index&gt;) {
    %!var{$&lt;variable-name&gt;} = +$&lt;value&gt;;
}

multi method assignment($/ where $&lt;index&gt;) {
    %!var{$&lt;variable-name&gt;}[$&lt;index&gt;&lt;value&gt;] = +$&lt;value&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>where</code> 子句允许 Raku 决定哪个候选方法在给定情况下更适合。</p>
</div>
<div class="paragraph">
<p>另请注意在第二个 multi 方法中如何使用 <code>&lt;value&gt;</code> 键两次。 <code>&lt;value&gt;</code> 的每个条目指的是目标代码的不同部分：一个用于索引值，另一个用于右侧值。</p>
</div>
</div>
<div class="sect2">
<h3 id="_3_让_perl_完成这项工作">34.3. 3. 让 Perl 完成这项工作</h3>
<div class="paragraph">
<p>有时，Perl 可以为我们完成工作，特别是如果你想实现 Perl 熟悉的东西。 例如，让我们在赋值中允许不同类型的数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a; my $b; $a = 3; $b = -3.14;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 grammar 中引入浮点数比较容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token value {
    | &#39;-&#39;? \d+
    | &#39;-&#39;? \d+ &#39;.&#39; \d+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您想添加其他类型的数字，请参阅 <a href="https://www.perl.com/article/perl-6-grammers-part-1/">perl.com</a> 上的文章。 现在，我们可以用上面两个选项限制 grammar，因为这足以阐明这个技巧。</p>
</div>
<div class="paragraph">
<p>如果您使用更改运行代码，您可能会对获得所需结果感到惊讶。 两个变量都接收值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Hash %!var = {:a(3), :b(-3.14)}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下，都触发了相同的 action 操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method assignment($/ where !$&lt;index&gt;) {
    %!var{$&lt;variable-name&gt;} = +$&lt;value&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在赋值的右侧，我们看到 <code>+$&lt;value&gt;</code>，这是从 Match 对象转换为数字的类型。 grammar 将 <code>3</code> 或 <code>-3.14</code> 放在 <code>$&lt;value&gt;</code> 中，两者都作为字符串。 <code>+</code> 这个一元运算符尝试将字符串转换为数字。 两个字符串都是有效数字，因此 Raku 不会抱怨。</p>
</div>
<div class="paragraph">
<p>自己编写代码将字符串转换为数字会更加困难，因为需要考虑数值的所有不同形式。 要了解 Raku 知道的其他格式，请查看 <a href="https://github.com/rakudo/rakudo/blob/master/src/Raku/Grammar.nqp">Raku grammar</a> 中 <code>numish</code> 标记的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token numish {
    [
    | &#39;NaN&#39; &gt;&gt;
    | &lt;integer&gt;
    | &lt;dec_number&gt;
    | &lt;rad_number&gt;
    | &lt;rat_number&gt;
    | &lt;complex_number&gt;
    | &#39;Inf&#39; &gt;&gt;
    | $&lt;uinf&gt;=&#39;∞&#39;
    | &lt;unum=:No+:Nl&gt;
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您在自己的 grammar 中允许任何上述类型，Perl 将能够为您转换它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="_4_使用_multi_rules_和_multi_tokens">34.4. 4. 使用 multi-rules 和 multi-tokens</h3>
<div class="paragraph">
<p>它不仅是方法，也可以是 multi-things。 grammar 的规则和标记也是方法，您也可以创建它们的多个变体。</p>
</div>
<div class="paragraph">
<p>让我们更新我们的 grammar，以允许在赋值的右侧使用数学表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a; $a = 6 + 5 * (4 - 3);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的新问题是解析表达式并处理运算符优先级和括号。 您可以通过以下方式描述任何表达式：</p>
</div>
<div class="paragraph">
<p>1、表达式是由 <code>+</code> 或 <code>-</code> 分隔的项的序列。
2、上一个规则中的任何项都是由 <code>*</code> 或 <code>/</code> 分隔的项的序列。
3、括号内的任何内容都是另一个表达式，因此请转到规则1。</p>
</div>
<div class="paragraph">
<p>话虽如此，您最终会得到以下 grammar 变更：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
    # . . .

    rule assignment {
        &#39;$&#39; &lt;variable-name&gt; &lt;index&gt;? &#39;=&#39; &lt;expression&gt;
    }

    multi token op(1) {
        &#39;+&#39; | &#39;-&#39;
    }

    multi token op(2) {
        &#39;*&#39; | &#39;/&#39;
    }

    rule expression {
        &lt;expr(1)&gt;
    }

    multi rule expr($n) {
        &lt;expr($n + 1)&gt;+ %% &lt;op($n)&gt;
    }

    multi rule expr(3) {
        | &lt;value&gt;
        | &#39;(&#39; &lt;expression&gt; &#39;)&#39;
    }

    # . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，rules 和 tokes 都是 multi 方法，它采用反映表达式深度的单个整数值。 操作符也是如此：在第一级，你期望 <code>+</code> 和 <code>-</code> ，在第二级 -  <code>*</code> 和 <code>/</code>。</p>
</div>
<div class="paragraph">
<p>不要忘记 Raku 中的 multi 方法（以及 multi-subs）可以基于常量进行调度，这就是为什么你可以, 例如, 使用你在 <code>multi token op(2)</code> 中看到的签名。</p>
</div>
<div class="paragraph">
<p><code>expr($n)</code> 规则通过 <code>expr($n + 1)</code> 递归定义。 <code>$n</code> 达到3时递归停止，Raku 选择最后一个候选 <code>multi rule expr(3)</code>。</p>
</div>
<div class="paragraph">
<p>让我懒惰，并使用以前的建议让 Perl 计算表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method assignment($/ where !$&lt;index&gt;) {
    use MONKEY-SEE-NO-EVAL;
    %!var{$&lt;variable-name&gt;} = EVAL($&lt;expression&gt;);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一般来说，我建议只在神奇的圣诞节期间使用 <code>EVAL</code>。 在今年余下的时间里，请自己计算表达式并使用抽象语法树和 <code>make</code> 和 <code>made</code> 方法对儿保存部分结果。 例如，请参阅此处的<a href="https://github.com/ash/lingua/blob/master/LinguaActions.pm">示例</a>。</p>
</div>
<div class="paragraph">
<p>我还建议一些额外的阅读，以便更好地了解如何使用 <code>multi</code> 和 <code>proto</code> 关键字：</p>
</div>
<div class="paragraph">
<p>1、<a href="https://raku.online/2017/12/21/the-proto-keyword/">Raku 中的 proto 关键字</a>
2、<a href="https://raku.online/2018/02/21/63-more-on-the-proto-keyword-in-perl-6/">有关 Raku 中 proto 关键字的更多信息</a></p>
</div>
<div class="paragraph">
<p>此时此刻，令人惊叹的 Raku grammar 之旅就要结束了。 你可以在 <a href="https://github.com/ash/advent-2018-day8">GitHub</a> 上找到今天帖子的完整例子。 祝你读完其余的 Perl Advent Calendars，祝你愉快！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第九天_raku_中的常量">35. 第九天 - Raku 中的常量</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我自豪地告诉人们在<a href="https://act.yapc.eu/lpw2018">伦敦 Perl 工作室</a>前一天我写了我的第一个 Raku 程序（也就是一个能工作的程序）。 所以，JJ 说：“为什么不为 Raku 写一个 Advent 日历帖？”</p>
</div>
<div class="paragraph">
<p>我名下只有区区一个程序，我该写些什么呢？ 嗯…​…​我在 Perl 5 中创作了 <a href="https://metacpan.org/pod/Astro::Constants">Astro::Constants</a>，那么将它迁移到 Raku 有多难？</p>
</div>
<div class="paragraph">
<p>话匣子打开就关不上了，我给你讲一个 Perl 5 模块作者在 Raku 的领地中徘徊的故事。</p>
</div>
<div class="paragraph">
<p>如果在<a href="https://rakuadvent.wordpress.com/2018/12/04/day-5-variables/">第5天</a>你被“诊断”为常数，那么你正好需要今天的帖子。</p>
</div>
<div class="paragraph">
<p>我们习惯使用变量来计算东西和持有东西。 随着我们获得更多“东西”，总量会发生变化。 <a href="https://docs.raku.org/language/variables#The_constant_prefix">常量</a>是那些永远不会改变的值。 像一天中的秒数或光速。 当然，我们在计算中使用它们就像使用变量一样，但是你不想通过赋值意外地改变常量</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$SPEED_LIGHT = 30;</code></pre>
</div>
</div>
<div class="paragraph">
<p>甚至意外地当你打算测试它是否等于某个值时，就像这样</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if ( $SECONDS_IN_A_DAY = $seconds_waited) {</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你真正想的是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if ( $SECONDS_IN_A_DAY == $seconds_waited) {</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这些情况下，你希望编译器说“对不起，戴夫。 恐怕我不能这样做。“ Perl 编译器关闭了。 如果你尝试运行第一行，你会得到</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Cannot modify an immutable Num (299792458)
  in block  at im_sorry_dave.p6 line 12</code></pre>
</div>
</div>
<div class="paragraph">
<p>单击此处获取<a href="https://docs.raku.org/language/terms#Constants">完整解释</a></p>
</div>
<div class="sect2">
<h3 id="_如何制作一个常数">35.1. 如何制作一个常数</h3>
<div class="paragraph">
<p>要使变量保持不变，请使用 <code>constant</code> 关键字声明它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant $tau = pi * 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>嘿！ sigil 是可选的，所以我可以使用我最喜欢的样式进行常量声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my constant SPEED_LIGHT is export = 2.99792458e8;</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有这些乐趣不仅仅适用于<a href="https://docs.raku.org/type/Scalar">标量</a>。 <a href="https://docs.raku.org/type/List">列表</a>和<a href="https://docs.raku.org/type/Hash">散列</a>也可以声明为常量！</p>
</div>
<div class="paragraph">
<p>为什么要使 List 保持不变？ 一年中的月份是列表吧, 它阻止这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my constant @months = ;
...
@months[9] = &#39;Hacktober&#39;;   # changing a name
push @months, &#39;Hogmannay&#39;;  # we&#39;d all like more time after Christmas</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你尝试其中任何一个，你得到</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Cannot modify and immutable Str (D)       # error for the assignment
# or
Cannot call &#39;push&#39; on an immutable &#39;List&#39; # error for the push</code></pre>
</div>
</div>
<div class="paragraph">
<p>顺便说一句，<code>tau</code>，<code>pi</code>，<code>e</code> 和 <code>i</code> 都是 Raku 中的内置常量，以及它们的 Unicode 等价物，<code>τ</code>，<code>π</code> 和 <code>𝑒</code>。 似乎你可以使用<a href="https://docs.raku.org/language/variables#Sigilless_variables">无 sigil 变量</a>获得相同的行为但是今天暂且不表。</p>
</div>
</div>
<div class="sect2">
<h3 id="_从模块导出常量">35.2. 从模块导出常量</h3>
<div class="paragraph">
<p>如果你要在代码中反复使用相同的常量，那么将它们放在一个模块（一个单独的文件）中并将其加载到程序中是有意义的。 现在我不得不在这里加一些土鳖编程，但这对我有用，我会尽力解释它的能力。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6;
unit class Astro::Constants:ver&lt;0.0.1&gt;:auth;

my constant SPEED_LIGHT is export = 2.99792458e8;
...</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>第1行</strong> - 轻松入手。<code>use v6;</code> 告诉编译器这是一个 Raku 程序。等等！我不需要它。这只是编写程序的一个习惯。我可以摆脱它。</p>
</div>
<div class="paragraph">
<p><strong>第2行</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.raku.org/language/module-packages#The_unit_keyword">unit</a> 表示此文件只提供一个模块 - 不知道这意味着什么</p>
</li>
<li>
<p><a href="https://docs.raku.org/syntax/class">class</a> 创建文件的词法范围 - 但我可能已经使用了<a href="https://docs.raku.org/language/module-packages">模块</a>，而不是用于不属于类的代码。嗯，我想我必须更深入地考虑我的代码设计。但它仍然奏效！</p>
</li>
<li>
<p><code>Astro::Constants</code>  - 模块名称</p>
</li>
<li>
<p><code>ver&lt;0.0.1&gt;</code>  - 版本字符串，现在在包声明中。</p>
</li>
<li>
<p><code>auth</code>  - 嗯，这是作者。为包名添加更高的维度有点怪，但它确实允许您指定要使用的模块的版本。在 PAUSE 中没有名称空间露营的问题。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>第N行</strong> <code>my</code> 词汇范围; <code>constant</code> 使其成为只读; <code>SPEED_LIGHT</code> 是常量的名称; <code>is export</code> 允许常量<a href="https://docs.raku.org/language/modules#Exporting_and_selective_importing">在模块外部使用</a>，即在代码中使用; <code>2.99792458e8</code> 只是 Perl 表达 <code>2.99×10⁸</code> 的方式。</p>
</div>
<div class="paragraph">
<p>…​为了完整起见，加上版本方法和一些<a href="https://rakuadvent.wordpress.com/2015/12/10/day-10-perl-6-pod/">文档</a>来完成模块怎么样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method ver { v0.0.1 }

=begin pod

=head1 DESCRIPTION

A set of constants used in Physics, Chemistry and Math

=end pod</code></pre>
</div>
</div>
<div class="paragraph">
<p>将常量放入模块的一个副作用是它们<a href="https://docs.raku.org/language/traps#Constants_are_computed_at_compile_time">在编译时计算</a>。它应该使您的代码运行得更快，但编译后的模块仍然存在。 这对于常量非常有用，但如果您的模块包含您可能想要更改的内容，则需要重新编译它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_在程序中使用模块">35.3. 在程序中使用模块</h3>
<div class="paragraph">
<p>一旦你有了一个模块，你如何在程序中使用它？</p>
</div>
<div class="paragraph">
<p>在这个例子中，我创建了一个目录 <code>mylib/Astro</code>，并将该模块放在一个名为 <code>mylib/Astro/Constants.pm6</code> 的文件中。 这是我的程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6;
use lib ;
use Astro::Constants;

say &#34;speed of light =\t&#34;, SPEED_LIGHT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它<strong>起作用了</strong>！ 解释一下前3行：<code>use v6</code> 说使用 Raku; <code>use lib</code> 表示把路径添加到库搜索路径; <code>use Astro::Constants</code> 表示在库路径中搜索文件 <code>Astro/Constants.pm6</code> 并加载它。</p>
</div>
<div class="sect3">
<h4 id="_我必须做这一切吗_不">35.3.1. 我必须做这一切吗？ …​…​不。</h4>
<div class="paragraph">
<p>为什么要重新发明轮子？ 前面提到的JJ有<a href="https://github.com/JJ/p6-math-constants">以前的常量形式</a>，但你需要一个包管理器来完成它的安装工作。 在 Fedora 28 中，使用 <code>dnf install rakudo-zef</code> 来安装包管理器 <strong>zef</strong>。 然后，您可以搜索任何处理常量的模块。运行</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">zef search Constants</code></pre>
</div>
</div>
<div class="paragraph">
<p>将为您提供至少15个在生态系统中注册的软件包，并非所有软件包都是你正在寻找的软件包。您可以立即开始使用 <code>zef install Math::Constants</code> 并使用JJ的模块，或者您可以使用搜索来查看我是否已经找到时间上传我的尝试（当时可能名为 <strong>*Physics::Constants</strong>），即将于2019年发布。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_最后对代码维护进行了一些注释">35.4. 最后，对代码维护进行了一些注释</h3>
<div class="paragraph">
<p>对我来说，代码维护是科学编程中最重要的考虑因素。想想那位走进美学院门口的新科学专业的学生，​​并在第1天交给你维护的代码。在第20天保证，他们被要求做出改变。为了他们的缘故，我喜欢为了清晰而不是简洁而写作，因为科学中存在如此多的重载符号。因此，我对将符号投入计算时很谨慎。也许我什么都不担心，但找到答案的唯一方法就是去做，看看是否有害。</p>
</div>
<div class="paragraph">
<p>我现在发生的一种可能性是能够指定你所指的常数。这个组成的例子看起来有点像 Python。可能值得偷窃。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">import GRAVITATIONAL as G;
...
$F_between_two_bodies = G * $mass1 * $mass2 / $distance**2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我将在圣诞节阅读 <a href="https://www.packtpub.com/application-development/perl-6-deep-dive">Raku Deep Dive</a>，我会告诉你我明年的表现。</p>
</div>
<div class="paragraph">
<p>快乐地搞科学！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十天_跳转_开启你的工作流">36. 第十天 - 跳转, 开启你的工作流</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这是另一个版本的 <a href="https://github.com/nige123/jmp.nigelhamilton.com">jmp</a> 供你在圣诞节前解开。</p>
</div>
<div class="paragraph">
<p><strong>jmp</strong> 是一个命令行工具，用于搜索成堆的代码，然后快速跳转到 <code>$EDITOR</code>。这有助于<a href="https://rakuadvent.wordpress.com/2015/12/20/perl-6-christmas-have-an-appropriate-amount-of-fun/">保持流动</a>。</p>
</div>
<div class="paragraph">
<p>然而，计算机编程具有许多潜在的<a href="https://rakuadvent.wordpress.com/2016/12/19/fixing-flow/">流阻塞器</a>。要在编码时保持流状态，通常需要在其他情况下快速<strong>跳转</strong>(jmp)到一行代码：修复错误，运行测试，检查日志文件，检查git状态等. <strong>jmp</strong> 也可以帮助加速这些任务吗？</p>
</div>
<div class="paragraph">
<p>幸运的是，重构 <strong>jmp</strong> 以容纳这些额外的使用场景相对容易。最新版本的 <strong>jmp</strong> 现在的工作原理如下：</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/demo.gif?w=600&amp;zoom=2">img</a></p>
</div>
<div class="paragraph">
<p>在命令前加上 <strong>jmp</strong> 将导致命令再次执行，并且其输出会被吞噬并被分页。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| find matching lines
method find-files-in-command-output ($command) {

    # execute the command
    my $shell-cmd = shell $command, :out, :err;

    # join STDOUT and STDERR
    my $result = join(&#34;\n&#34;, $shell-cmd.out.slurp,
                            $shell-cmd.err.slurp);

    # don&#39;t actually look for filenames just yet
    # do that lazily on demand by the user
    return $result.lines.map({
               JMP::File::HitLater.new(context =&gt; $_)
           });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>jmp</strong> 为每一行创建结果提示，并对结果进行分页。然后，如果需要，您可以快速浏览输出并将 <strong>jmp</strong> 导入文本编辑器（请参阅 <strong>jmp config</strong> 以将其更改为您最喜欢的编辑器）。</p>
</div>
<div class="paragraph">
<p>速度对命令行工具很重要。<strong>jmp</strong> 只在用户选择编辑特定行时查找文件名, 而不是提前扫描每一行的文件名。这是懒惰地解析查找文件的行的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">submethod find-file-path {

    given self.context {

        # matches Perl 5 error output (e.g., at SomePerl.pl line 12)
        when /at \s (\S+) \s line \s (\d+)/ {
            proceed unless self.found-file-path($/[0], $/[1]);
        }

        # matches Raku error output (e.g., at SomeRaku.p6:12)
        when /at \s (&lt;-[\s:]&gt;+) &#39;:&#39; (\d+)/ {
            proceed unless self.found-file-path($/[0], $/[1]);
        }

        # matches Raku error output (e.g., SomeRaku.p6 (Some::Raku):12)
        when /at \s (&lt;-[\s:]&gt;+) &#39;(&#39; \S+ &#39;)&#39; &#39;:&#39; (\d+)/ {
            proceed unless self.found-file-path($/[0], $/[1]);
        }

        # more file finding patterns HERE - PR&#39;s welcome?

        # go through each token
        default {
            for self.context.words -&gt; $token {
                # keep trying to set the file path
                proceed if self.found-file-path($token);
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>when</strong> 块匹配不同类型的错误格式（例如，Perl 5 和 Raku）以提取文件名和行号。 <strong>proceed</strong> 语句对于移动到下一个 <strong>when</strong> 块非常有用。</p>
</div>
<div class="paragraph">
<p>这意味着你可以跳转(<strong>jmp</strong>)到工作流程中出现错误的任何位置：例如命令行的输出，测试输出，日志文件等。</p>
</div>
<div class="paragraph">
<p>要升级到 <strong>jmp</strong> 的第3版：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">shell&gt; zef upgrade jmp</code></pre>
</div>
</div>
<div class="paragraph">
<p>要首次安装 <strong>jmp</strong>，请<a href="https://raku.org/downloads/">安装 Raku</a>，然后使用 <a href="https://github.com/ugexe/zef">zef</a> Raku 模块管理器来安装它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">shell&gt; zef install jmp   # install the jmp command line tool
shell&gt; jmp config        # set up jmp to use your tools
shell&gt; jmp to sub MAIN   # find files containing &#34;sub MAIN&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>圣诞节前还有更多工具可以打开。在第17天再次与你联系，获取有助于您的非编码工作流的工具。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十一天_使用_raku_测试你的时刻表">37. 第十一天 - 使用 Raku 测试你的时刻表</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这几乎是在北极附近的精灵小学冬季学期结束之时。对于精灵而言，敏锐的人物头脑非常重要，而小精灵的数学老师 Hopper 女士希望确保他们在任期的倒数第二天保持他们的算术技能。（学期的最后一天保留用于观看电影和玩耍 -  很嗨皮）。</p>
</div>
<div class="paragraph">
<p>小精灵刚刚学会了他们的时间表（乘法表），最多12个，但他们并不像他们所想的那样擅长，其中一些人在圣诞节前将在玩具工作坊帮忙，那时候他们可能需要快速告诉大精灵有多少特定类型的玩具。</p>
</div>
<div class="paragraph">
<p>幸运的是，Elf Hopper 是一个非常聪明的精灵，拥有出色的数学和编码能力 - 自己。所以她起了一个快速的控制台应用程序来运行小精灵的学校颁发的 Perlix 6.0 boxen。</p>
</div>
<div class="paragraph">
<p>该程序允许小精灵通过运行它们在2至12次表中测试自己，或者如果它们提供单个数字参数，他们可以尝试任何他们喜欢的乘法表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fixednum;
my %score;
my @exits = &lt;exit quit&gt;;

$fixednum = @*ARGS[0] || 0;
put &#34;Type the answer, or quit or exit to end the test.&#34;;


loop {
    my $coefficient = (2..12).pick;
    my $number = $fixednum || (2..12).pick;

    my $answer = prompt ( &#34;$coefficient × $number = &#34; );
    my $rightanswer = $coefficient × $number;

    last if $answer.lc ~~ any @exits;

    if $answer == $rightanswer {
        put &#34;Correct!&#34;;
        %score&lt;correct&gt;++;
    } else {
        put &#34;Sorry, that wasn&#39;t right! The answer is $rightanswer&#34;;
    }
    %score&lt;total&gt;++;
}

if %score&lt;total&gt;:exists {
    my $pc = 100 * %score&lt;correct&gt; / %score&lt;total&gt;;
    put &#34;You scored %score&lt;correct&gt; out of %score&lt;total&gt;, i.e. &#34;, sprintf &#34;%2.2f%%.&#34;, $pc;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Elf Hopper 向其它小精灵解释代码如下。</p>
</div>
<div class="paragraph">
<p>“可爱的小精灵们！这是关于程序如何工作的一些背景知识。</p>
</div>
<div class="paragraph">
<p>我在顶部附近添加了 <code>use v6;</code>，以便代码也可以在 Perl 5下 运行，它将自动使用 Raku 仿真器。</p>
</div>
<div class="paragraph">
<p>您将看到程序在特殊的 <code>@*ARGS</code> 数组的命令行上运行时选择一个可选参数。这是 Perl 5 的 <code>@ARGV</code> 数组的 Raku 等价物。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，数组，数组元素和数组切片总是使用 <code>@</code> sigil，与 Perl 5 不同，其中各个数组元素使用 <code>$</code> sigil。同样，哈希和哈希元素现在总是带有 <code>%</code> sigil，无论是整个哈希，它的切片还是单个元素都在使用。</p>
</div>
<div class="paragraph">
<p>那里还有另一个符号，星号 &#39;twigil&#39;，<code>*</code>。这表明 <code>@*ARGS</code> 是一个动态特殊变量。</p>
</div>
<div class="paragraph">
<p><code>prompt</code> 和 <code>loop</code> 关键字是 Raku 中的新功能，两者都是令人钦佩的名字！</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>prompt</code> 只返回用户输入的值，在本例中为变量。</p>
</li>
<li>
<p><code>loop</code> 是 Raku 的新块控制关键字之一。像这样的简单循环块只是创建了一个无限循环，可以由程序员以显式的方式结束，例如在满足条件时使用 <code>last</code> 关键字;或者例如由用户手动终止程序。</p>
</li>
<li>
<p>或者，循环可以采用三个参数，并且表现得像传统的C风格 <code>for</code> 循环。 （在 Raku 中，小精灵，<code>for</code> 只用于迭代列表或其他容器。）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在循环内部，小精灵，你可以看到范围对象。一切都是 Raku 中的一个对象，所以我可以在范围上调用 <code>pick</code> 方法来返回一个随机数。（好吧，无论如何，这是一个非加密安全的伪随机数！）</p>
</div>
<div class="paragraph">
<p><code>any</code> 关键字将 <code>@exits</code> 数组转换为 Raku 中许多新的有用数据结构之一：一个 <a href="https://rakuadvent.wordpress.com/2009/12/13/">Junction</a>。这使得使用 smartmatch 运算符 <code>~~</code> 直截了当地找到一个数组元素。<code>last</code> 关键字退出循环，如 Perl 5 中所示。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Junction">Junction</a> 是一种新类型的容器或列表，允许进行许多最有用的比较，例如 <code>any</code>，<code>all</code>，<code>one</code> 或 <code>none</code>，我们在 Perl 5 中使用 <code>grep</code> 或 <code>List::Util</code> 等模块进行比较，但它使它们成为可能键入更容易，并允许它们同时执行！这样做的一个副作用是 junction 是无序的：但它们主要是为了产生单个真值或假值，所以通常都可以。如果你想快速想要根据一些特定值的简短列表检查一个值，那么 junction 就很棒。但是如果需要的话，它们还能够让你匹配更大的值集。</p>
</div>
<div class="paragraph">
<p>在最后一个代码段落的顶部，您将看到 <code>:exists</code> 应用于 <code>%score&lt;total&gt;</code> 哈希键。<code>:exists</code> 是一个 Raku 副词！副词通常会修改方法的工作方式。<code>:exists</code> 是下标副词。它是一个副词，因为它改变了读取哈希键时发生的事情：不是返回值，而是查明值是否存在。这通常是使用 Perl 5 类中关注的那些熟悉的已定义方法的更好的替代方法。</p>
</div>
<div class="paragraph">
<p>当然，<code>exists</code> 测试就是为了确保在用户第一次退出程序时不会出现错误。</p>
</div>
<div class="paragraph">
<p>为什么我使用锯齿形符号来引用哈希键？好吧，花括号 <code>{}</code> 是散列键的标准下标运算符，如 Perl 5. 但是，大多数情况下你可能想要使用尖括号/锯齿形符号，因为它们提供单字键的自动引用。用于在 Perl 5 中执行此操作的简单`{}` 括号，但在 Raku 中不再执行此操作。需要引起括号内的字符串。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，放置了用于向终端输出文本的标准命令。这将输出以下列表项，然后是换行符。<code>say</code> 和 <code>print</code> 仍然可用; <code>say</code> 和 <code>put</code> 这两个都打印到标准输出并添加换行符; <code>print</code> 不会追加换行符。</p>
</div>
<div class="paragraph">
<p>如果你使用这个程序以及知道它是如何工作的，小精灵，你将有选择和知识，是否，何时以及如何在你自己的头脑中执行乘法，以及什么时候最好让 Raku -有动力的电脑做它。您的圣诞节作业是让您自己熟悉<a href="https://docs.raku.org/">https://docs.raku.org</a> 上的 Raku 文档。“</p>
</div>
<div class="paragraph">
<p>小精灵开始使用乘法测试程序，试图超越对方以获得最高的完美分数。他们发现它如此令人上瘾，以至于比赛甚至会加时到在学校的最后一天，当时他们应该正在观看’精灵&#39;！</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十二天_构建灵活的_grammar">38. 第十二天 - 构建灵活的 grammar</h2>
<div class="sectionbody">
<div class="paragraph">
<p>圣诞老人夫人写了一个基础的 Grammar，以配合 GDPR 无知精灵从世界各地收集的有关今年 naughty 或 nice 的人的简单列表。</p>
</div>
<div class="paragraph">
<p>每个记录都是一个名称，后跟一个标签，后跟一个地址，然后是一个标签，然后是 naughty 或 nice 的评估，然后用换行符结束。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Batman 1 Batman Street, Gotham Nice
Joker 5 Joker Street, Arkham Naughty
Riddler 12 Riddler Street, Arkham Naughty
Robin 2 Robin Street, Gotham Nice</code></pre>
</div>
</div>
<div class="paragraph">
<p>她希望将 naughty 的人排除在一个列表中，将 nice 的人过滤到另一个列表中，因为 Krampus 将在今年处理所有 naughty 的人。</p>
</div>
<div class="paragraph">
<p>S.夫人用这样的 grammar 开头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar naughty-nice-list {
    token TOP { &lt;details&gt;+ } # Find one or more records made up of name, address, assessment (defined below)

    token details { &lt;name&gt; &lt;address&gt; &lt;assessment&gt; }  # Find the elements from below, in this order

    token name { .*? \t } # Find any characters up to the earliest tab

    token address { .*? \t } # Find any characters up to the earliest tab

    token assessment { Naughty|Nice \n } # Find either &#39;Naughty&#39; or &#39;Nice&#39; followed by a newline
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并在列表上调用它，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">naughty-nice-list.parsefile(&#34;./list.txt&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，当然，她必须做一些事情将细节放入单独的列表中。</p>
</div>
<div class="paragraph">
<p>为此，她创建了一个 action 动作类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class santa-list-actions {
    has %!filtered-lists; # Create a private hash for this class

    method show { return %!filtered-lists } # Create a method to return our hash to the user

    # This method is automatically called when the token with the same name makes a match
    method details ($/) {
        # Create an array of just the name and address matches converted to strings
        my @details.push($&lt;name&gt;.Str, $&lt;address&gt;.Str);
        # Push the @details array into an array accessed with the &#39;Naughty&#39; or &#39;Nice&#39; key
        # Note the curly braces to interpolate { $ } instead of .
        # Otherwise we would get literally what we typed for the hash key.
        %!filtered-lists{ $&lt;assessment&gt;.Str }.push(@details);
    };
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>她这样使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $actions = santa-list-actions.new;
naughty-nice-list.parsefile(&#34;./list.txt&#34;, actions=&gt;$actions); # As Mrs S. called the object &#39;actions&#39;, the same as the keyword, she could write :$actions instead of actions=&gt;$actions
my %hash-naughty-nice = $actions.show;</code></pre>
</div>
</div>
<div class="paragraph">
<p>圣诞老人非常开心，她现在有一个哈希表，其中包含 &#39;Naughty&#39; 和 &#39;Nice&#39; 的键，每个键都包含一系列每个人的详细信息。</p>
</div>
<div class="paragraph">
<p>但是钓鱼洞里总是有一只北极熊爪子，尽管有圣诞老人的保证，来自世界各地的精灵们并不只是 “Naughty” 或 “Nice”。他们用自己的语言说出来！</p>
</div>
<div class="paragraph">
<p>圣诞老人特别问过，但圣诞老人坚持不懈。只有 &#39;Naughty&#39; 或 &#39;Nice&#39;。但有些列表看起来像这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Batman 1 Bat Street, Gotham Nice
Joker 5 Joker Street, Arkham Naughty
Riddler 12 Riddler Street, Arkham Naughty
Robin 2 Robin Street, Gotham Nice
El Gato Negro 1 Gato Street, South Texas Bueno
Victor Mancho 3 Mancho Street, New York City Malo</code></pre>
</div>
</div>
<div class="paragraph">
<p>圣诞老人简单地认为只是对新词进行硬编码，但她知道这不是懒惰的时候。世界各地都有精灵，她需要能够进化的东西。</p>
</div>
<div class="paragraph">
<p>所以，为了现在调用她的脚本，她创建了两个数组并将它们传递给 grammar：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @nice = [&#39;Nice&#39;, &#39;Bueno&#39;];
my @naughty = [&#39;Naughty&#39;, &#39;Malo&#39;];
naughty-nice-list.parsefile(&#34;./list.txt&#34;, args=&gt;(@nice, @naughty), actions=&gt;$actions);</code></pre>
</div>
</div>
<div class="paragraph">
<p>她改变了这样的 grammar 来使用新的数组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar naughty-nice-list {
    token TOP (@*nice-words, @*naughty-words) { &lt;details&gt;+ } # Create dynamic arrays with the passed in arrays, available throughout the grammar
    token details { &lt;name&gt; &lt;address&gt; &lt;assessment&gt; }
    token name { .*? \t }
    token address { .*? \t }
    token assessment { @*naughty-words|@*nice-words \n } # Find either a word from the naughty-words array or from the nice-words array followed by a newline
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是S.太太意识到她现在最终会在她的 action 动作类中的哈希表中创建许多不同的键。 键将是 &#39;Nice&#39;，&#39;Naughty&#39;，&#39;Bueno&#39; 或 &#39;Malo&#39;，因为这些将是 <code>$</code> 可能拥有的匹配单词（未来有更多可能出现）。</p>
</div>
<div class="paragraph">
<p>因此，她进行了另一项更改，为评估令牌命名语法中的潜在匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token assessment { $&lt;Naughty&gt;=@*naughty-words|$&lt;Nice&gt;=@*nice-words \n } # Mrs S. has now added names to the potential matches</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 action 动作类中，必须进行更改以适应这种情况。使用 <code>make</code> 和 <code>made</code>，圣诞老人将存储相应匹配的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class santa-list-actions {
    has %!filtered-lists;

    method show { return %!filtered-lists };

    method details ($/) {
        my @details.push($&lt;name&gt;.Str, $&lt;address&gt;.Str);
        %filtered-lists{ $&lt;assessment&gt;.made }.push(@details); # This will now use the value from &#39;assessment.made&#39; as the key, rather than the match in &#39;assessment.Str&#39;
    };

    method assessment ($/) {
        if $&lt;Naughty&gt; { # If the named pattern &#39;Naughty&#39; matched...
            make &#34;Naughty&#34; # ... set assessment.made to &#34;Naughty&#34;
        } elsif $&lt;Nice&gt;; { # Or if the named pattern &#39;Nice&#39; matched...
            make &#34;Nice&#34; # ... set assessment.made to &#34;Nice&#34;
        };
     };
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦圣诞老人将数据捕获到她自己的哈希中，她就可以轻松地检查出今年已经被马洛的 Victor Mancho 将其列入正确的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %hash-naughty-nice&lt;Naughty&gt;[2][0]; # Produces the output &#39;Victor Mancho&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以现在，圣诞老人可以将 “Naughty” 或 “Nice” 的任何新翻译添加到相关数组，而不会触及 grammar。</p>
</div>
<div class="paragraph">
<p>圣诞老人发现自己对 Raku grammar 的灵活性非常满意。圣诞老人对这个问题的研究起初不那么重要…​…​但是她知道她在确保每个人都能得到一个礼物或者在这个圣诞节的窗户上扔蛋的方法上做得很好。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十三天_使用_cro_和_debian_从头构建_web_服务">39. 第十三天 - 使用 Cro 和 Debian 从头构建 Web 服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我和圣诞老人​​谈过，他说他不知道如何在 <strong>Debian</strong> 上安装 <strong>Cro</strong>，所以我对自己说：我要帮助他。</p>
</div>
<div class="paragraph">
<p>如果您对 <strong>Apache</strong> 等 Web 服务器有一些经验，并且您已经听说过 <strong>Raku</strong> 强大的并发/响应方面，那么您肯定有兴趣了解 <a href="https://cro.services/">Cro 服务</a>。这篇文章的受众是<strong>具有 Debian 基本经验的人</strong>，或者在 <strong>Raku</strong> 新手…​就像圣诞老人一样。</p>
</div>
<div class="paragraph">
<p><strong>Cro</strong> 是一个 <strong>Raku 模块</strong>，它提供了轻松构建反应式和并发服务所需的一切，例如：Web 服务器。</p>
</div>
<div class="paragraph">
<p>在这篇文章中，我们将看到如何在 <strong>Debian</strong> 中安装 <strong>Cro</strong>，这是最受欢迎的 Linux 发行版之一。然后，我将解释 <strong>Cro</strong> 的演示示例。</p>
</div>
<div class="paragraph">
<p>我们将使用 <strong>Debian 9,64 位</strong>（Stretch），我们将在安装后启动它。</p>
</div>
<div class="sect2">
<h3 id="_安装_rakudo_raku_编译器">39.1. 安装 Rakudo Raku 编译器</h3>
<div class="paragraph">
<p><a href="https://rakudo.org/">Rakudo</a> 是 <strong>Cro</strong> 模块运行的当前 <strong>Raku</strong> 编译器。安装 <strong>Rakudo</strong> 的常规方法是安装 <a href="https://rakudo.org/files">Rakudo Star</a>，但我更喜欢快速的方式：<a href="https://github.com/nxadm/rakudo-pkg">rakudo-pkg</a> …​…​怎么样？只需从此 <a href="https://github.com/nxadm/rakudo-pkg#direct-downloads">repo</a> 下载并安装相应的 <strong>Debian 软件包</strong>。在我们的例子中，是来自 <strong>Debian 9, 64位</strong>的 <strong>.deb</strong> 文件。</p>
</div>
<div class="paragraph">
<p>使用 <strong>Debian</strong> 中的 root 用户，我们可以在 root home 中为 <strong>Rakudo</strong> 创建一个包文件夹，进入这个目录，下载 <strong>Debian 9, 64 位</strong>的当前 <strong>Rakudo</strong> 包，并安装它。就我而言：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">mkdir ~/rakudo-packages &amp;&amp; cd $_
wget https://github.com/nxadm/rakudo-pkg/releases/download/v2018.10-02/rakudo-pkg-Debian9_2018.10-02_amd64.deb
dpkg -i rakudo-pkg-Debian9_2018.10-02_amd64.deb</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Rakudo</strong> 运行时编译器和相关工具现在安装在 <strong>/opt/rakudo-pkg</strong> 文件夹中。在 <strong>export PATH</strong> 行之前，让所有用户在 <strong>/etc/profile</strong> 文件中插入以下行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">PATH=$PATH:/opt/rakudo-pkg/bin</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">source /etc/profile</code></pre>
</div>
</div>
<div class="paragraph">
<p>为所有用户重新加载 <strong>Debian</strong> 配置文件。</p>
</div>
<div class="paragraph">
<p>输入 <strong>raku -v</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku -v
This is Rakudo version 2018.10 built on MoarVM version 2018.10
implementing Raku.c.</code></pre>
</div>
</div>
<div class="paragraph">
<p>欢迎来到 <strong>Rakudo Raku!</strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_安装_cro_服务">39.2. 安装 Cro 服务</h3>
<div class="paragraph">
<p><strong>Cro</strong> 是 Raku 模块，<strong>Zef</strong> 是已经安装的当前 <strong>Raku</strong> 模块管理器。我们来安装 <strong>Cro</strong> 吧！</p>
</div>
<div class="paragraph">
<p>首先，我们将安装一些 <strong>Cro 包依赖项</strong>，例如 <strong>git</strong> 来连接和下载来自 Cro 相关存储库的文件，<strong>libssl-dev</strong> 以提供对安全套接字层的支持，<strong>build-essential</strong> 用于构建在安装期间 <strong>Cro</strong> 所使用的一些依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">apt-get install git libssl-dev build-essential</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您位于仅允许 Web 流量（端口80和443）的防火墙下，它将阻止 <strong>git</strong> 协议使用的端口，并且 <strong>Cro</strong> 安装将失败。要避免这种情况，请键入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">git config --global url.&#34;https://&#34;.insteadOf git://</code></pre>
</div>
</div>
<div class="paragraph">
<p>这告诉 <strong>git</strong> 使用 <strong>https</strong> 而不是 <strong>git</strong> 协议来连接 git 远程仓库。</p>
</div>
<div class="paragraph">
<p>现在我们准备用 <strong>Zef</strong>（及其所有依赖项）安装 <strong>Cro</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">zef install cro</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在测试阶段安装失败，请尝试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">zef install --/test cro</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <strong>Cro</strong> 安装正确完成，<strong>Cro</strong> 就准备好了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_cro_实战">39.3. Cro 实战</h3>
<div class="paragraph">
<p>让我们继续演示脚本。创建一个工作区文件夹，输入它并将下面的代码粘贴到名为 <strong>server.p6</strong> 的新文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::HTTP::Router;
use Cro::HTTP::Server;

my $application = route {
  get -&gt; &#39;greet&#39;, $name {
  content &#39;text/plain&#39;, &#34;Hello, $name!&#34;;
  }
}

my Cro::Service $hello = Cro::HTTP::Server.new(:host&lt;0.0.0.0&gt;, :port&lt;10000&gt;, :$application);

$hello.start;

react whenever signal(SIGINT) { $hello.stop; exit; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个脚本有 <strong>4个部分</strong>：</p>
</div>
<div class="paragraph">
<p>“use”使<strong>路由</strong>和<strong>服务</strong>类可用于下面。</p>
</div>
<div class="paragraph">
<p><strong>$application</strong> 是包含我们的 Web 应用程序的路由逻辑的对象，接收数据并将数据从客户端分发到我们的服务器。在这种情况下，<strong>get  →&#39;greet&#39;，$name</strong> 映射来自客户端 Web 浏览器的传入 URL <strong>/greet/Ramiro</strong>，在对象 <strong>$name</strong> 中推送 Ramiro。然后将代码转换为花括号 {}，返回响应 HTTP 请求头 <strong>content &#39;text/plain&#39;</strong> 和 HTTP 请求体 <strong>Hello, Ramiro!</strong> 到客户端 Web 浏览器。在一个严肃的应用程序中，在这部分中将会调用应用程序本身，并且它将等待响应，如示例所示。</p>
</div>
<div class="paragraph">
<p><strong>$hello</strong> 是一个服务对象，它使传入的数据通过新的侦听套接字传递给我们的 <strong>$application</strong>。它有3个参数，<strong>:host&lt;0.0.0.0&gt;</strong> 是服务启动的 localhost, <strong>:port&lt;10000&gt;</strong> 是用于监听传入数据的端口，<strong>$application</strong> 是我们的Web 应用程序。 下面的行 <strong>$hello.start</strong> 开始侦听。</p>
</div>
<div class="paragraph">
<p><strong>react whenever</strong> 等待按下 CTRL-C 时停止 Web 服务。</p>
</div>
<div class="paragraph">
<p>现在是从 shell 运行 Web 服务的时刻：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku server.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在您需要知道服务器主机的当前 IP 地址，尝试使用 <strong>ip addr</strong>。我的 Ip 地址是: <strong>192.168.1.48</strong>。</p>
</div>
<div class="paragraph">
<p>然后，从同一网络中的其他主机，打开 Web 浏览器并键入（在我这儿）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">http://192.168.1.48:10000/greet/Ramiro</code></pre>
</div>
</div>
<div class="paragraph">
<p>答案应该是 <strong>Hello, Ramiro!</strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_4">39.4. 总结</h3>
<div class="paragraph">
<p>从 <strong>Debian</strong> 的新安装开始，我们已经了解了如何安装 <strong>Cro</strong> 并运行演示脚本。现在，您已准备好继续使用 Cro 文档，并发现 <strong>Raku</strong> 可提供的最有前途的并发/异步服务平台。</p>
</div>
<div class="paragraph">
<p>我希望在阅读这篇文章并查看 <a href="https://cro.services/docs">Cro 文档</a>后，圣诞老人可以将他的网站迁移到 Cro Services。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十四天_使用_raku_设计小航天器">40. 第十四天 - 使用 Raku 设计(小)航天器</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_寻找共同点">40.1. 寻找共同点</h3>
<div class="paragraph">
<p>大家好！</p>
</div>
<div class="paragraph">
<p>那些日子我花了一些时间在基础部件上工作，揭示了可能的惊喜，Raku 的 <a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">LDAP（轻量级目录访问协议）</a>实现。</p>
</div>
<div class="paragraph">
<p>然而，现在谈论这个还为时尚早，所以我现在将有一些神秘的封面覆盖这个话题，因为我们有另一个 - 宇宙飞船！</p>
</div>
<div class="paragraph">
<p>航天器和LDAP之间的共同点是：LDAP规范使用一种称为符号的符号 <code>ASN.1</code>，它允许使用特定的文本语法定义抽象类型，并在 `ASN.1`编译器的帮助下，为特定的编程语言创建类型定义，以及什么是更多：此类型值的编码器和解码器，可以将您的值序列化为某些数据，例如，可以通过网络发送并在另一台计算机上很好地解析。</p>
</div>
<div class="paragraph">
<p>通过这种方式，您可以轻松地在应用程序中获得跨平台类型。编码器和解码器可以自动生成，不仅针对某些指定的编码格式，而且针对整个范围的二进制（例如 <code>BER</code>，<code>PER`和其他）和文本（例如`SOAP</code>）编码格式。</p>
</div>
<div class="paragraph">
<p>因此，为了完成工作，我必须至少实现 `ASN.1`Raku中的一些子集- 不是完整的规范，这很大，只关注LDAP规范中使用的功能。</p>
</div>
<div class="paragraph">
<p>“这听起来很有趣，但我们的宇宙飞船在哪里！？”，你可能会问。事实证明，这种 <code>Rocket</code> 类型是您在 <a href="http://asn1-playground.oss.com/">ASN.1 Playground</a> 网站上看到的第一件事，它让您可以免费访问 `ASN.1`编译器，它可以作为参考！</p>
</div>
</div>
<div class="sect2">
<h3 id="_asn_1_和限制">40.2. <code>ASN.1</code> 和限制</h3>
<div class="paragraph">
<p>这是花哨的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">World-Schema DEFINITIONS AUTOMATIC TAGS ::=
BEGIN
  Rocket ::= SEQUENCE
  {
     name      UTF8String (SIZE(1..16)),
     message   UTF8String DEFAULT &#34;Hello World&#34; ,
     fuel      ENUMERATED {solid, liquid, gas},
     speed     CHOICE
     {
        mph    INTEGER,
        kmph   INTEGER
     }  OPTIONAL,
     payload   SEQUENCE OF UTF8String
  }
END</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们快速浏览一下这个定义：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Rocket</code> 是一个 <code>SEQUENCE</code>  - 一组某类型的有序值，可以看作是异构列表/数组或类。</p>
</li>
<li>
<p>场 <code>name</code> 和 <code>message</code> 有 <code>UTF8String</code> 型，这是肯定的，一种字符串表示的 <code>ASN.1</code>。字段name已应用长度限制，<code>(SIZE(1..16))</code> 和 <code>message</code> 具有指定的默认值 <code>DEFAULT &#34;Hello World&#34;</code>。</p>
</li>
<li>
<p>字段 <code>fuel`有 `ENUMERATED</code> 类型：它只是一个可供选择的标签枚举。</p>
</li>
<li>
<p>字段 <code>speed</code> 是一个 <code>CHOICE</code>，它是一种特殊类型，它描述了一个字段，该值可以是指定类型之一。不同的是 <code>ENUMERATED</code>，价值不仅仅是标签。<code>OPTIONAL</code> 如你所知，关键字意味着如果不存在，该字段可能会被省略。</p>
</li>
<li>
<p>字段 <code>payload</code> 是一个 <code>SEQUENCE</code>，但指定了类型。这意味着我们可以根据需要在这里拥有尽可能多的 <code>UTF8String</code> 值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这里我们将应用两个重要的限制：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们将使用 <code>Basic Encoding Rules（BER）</code> - 将 `ASN.1`类型编码指定为特定字节序列的规则。如上所述，有不同的格式，但我们将使用这一种。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Basic Encoding Rules</code> 标准是基于一个所谓的“TLV编码”的事情-的类型的值被编码为字节序列表示：“ Ť AG”，“ 大号 ength”和“ V传递类型的某些值的ALUE”。让我们更仔细地看一下…​…​以相反的顺序！</p>
</div>
<div class="paragraph">
<p>“值”是包含值的字节表示的部分。每种类型都有自己的编码模式（例如，<code>INTEGER</code> 编码方式不同 <code>UTF8String</code>）。</p>
</div>
<div class="paragraph">
<p>“长度”是表示“值”部分中的字节数的数字。这允许我们很好地处理增量解析（通常也是！）。它也可以具有“未知”值，这允许我们以未知的长度流式传输数据，但我们将把它放在一边。</p>
</div>
<div class="paragraph">
<p>“标签”简单地说是一个字节或一些字节，我们可以用它来确定我们手头有什么类型。其确切值由标记规则的数量（“标记模式”）确定，并且存在好的或更差的不同模式。</p>
</div>
<div class="paragraph">
<p>并且，如果您已经等待某些段落的第二个限制，那么它是：</p>
</div>
<div class="paragraph">
<p>我们将 <code>IMPLICIT</code> 在这里使用 BER 的类型标记模式。正如您所猜测的那样，<code>EXPLICIT</code> 标记模式也同时存在 <code>AUTOMATIC</code>（在上面的 Rocket 示例中使用）。</p>
</div>
<div class="paragraph">
<p>考虑到这一点，我们需要将 <code>ASN.1</code> 上面的类型更改为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">World-Schema DEFINITIONS IMPLICIT TAGS ::=
BEGIN
  Rocket ::= SEQUENCE
  {
     name      UTF8String (SIZE(1..16)),
     message   UTF8String DEFAULT &#34;Hello World&#34; ,
     fuel      ENUMERATED {solid, liquid, gas},
     speed     CHOICE
     {
        mph   [0] INTEGER,
        kmph  [1] INTEGER
     }  OPTIONAL,
     payload   SEQUENCE OF UTF8String
  }
END</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>IMPLICIT TAGS</code> 用于代替字段中的 <code>AUTOMATIC TAGS</code> 和 <code>[$n]</code> 字符串 <code>speed</code>。</p>
</div>
<div class="paragraph">
<p>如果你看一下这个模式，事实证明，这是，其实，暧昧，因为 <code>mph</code> 和 <code>kmph</code> 都有 <code>INTEGER</code> 型。因此，如果我们 <code>INTEGER</code> 从字节流中读取了一个，它是 <code>mph</code> 值还是 <code>kmph</code> 值？如果我们谈论宇宙飞船，它会产生巨大的变化！</p>
</div>
<div class="paragraph">
<p>为了避免这种混淆，使用了特殊的标签，这里我们指定了我们想要的标签，因为与 <code>AUTOMATIC</code> 模式不同，<code>IMPLICIT</code> 它不适用于我们。</p>
</div>
</div>
<div class="sect2">
<h3 id="_逐步建设问题答案">40.3. 逐步建设。问题答案。</h3>
<div class="paragraph">
<p>那么，我们可以用 Raku 中的所有功能做什么呢？虽然编译器可能很有趣，但是可以通过可扩展的方式编译成 Raku，并且包含了奇特的功能？必须有一些更简单的东西。</p>
</div>
<div class="paragraph">
<p>比方说，我们有一个适用于航天器的脚本。当然，我们需要一个类型来表示一个，特别是一个类，让我们称之为 <code>Rocket</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class  Rocket {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，我们想知道一些有关它的数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Rocket {
    has $.name;
    has $.message is default(&#34;Hello World&#34;);
    has $.fuel;
    has $.speed;
    has @.payload;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们必须使我们的 <code>Rocket</code> 定义更明确，那么我们指定一些类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Fuel &lt;Solid Liquid Gas&gt;;

class Rocket {
    has Str $.name;
    has Str $.message is default(&#34;Hello World&#34;);
    has Fuel $.fuel;
    has $.speed;
    has Str @.payload;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在它开始提醒我们一些事情…​…​</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Str</code> 类似 <code>UTF8String</code>，只是我们不能离开它这样，因为 <code>ASN.1`我们不仅有 `UTF8String</code>，而且 <code>BIT STRING</code>，<code>OCTET STRING</code> 和其他字符串类型。</p>
</li>
<li>
<p><code>Fuel</code> 枚举类似于 <code>ENUMERATED</code> 类型。</p>
</li>
<li>
<p><code>@.payload</code> 中的 <code>@</code> 符号告诉我们，这将是一个序列，而且 <code>Str</code> 指定其元素的类型。</p>
</li>
<li>
<p>但是虽然有一些类似的观点，但从我们 `ASN.1`的观点来看，我们没有足够的数据。让我们一步一步解决这些问题！</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>我们怎么知道这完全Rocket是 `ASN.1`序列类型？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>通过应用角色：<code>class Rocket does ASNSequence</code>。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>我们怎么知道确切的字段顺序？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>通过实现此角色的存根方法：<code>method ASN-order { &lt;$!name $!message $!fuel $!speed @!payload&gt; }</code></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>我们怎么知道这 <code>$.speed</code> 是可选的？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>我们只是应用它的特征！<a href="https://docs.raku.org/language/traits">Traits</a> 允许我们在代码部分上执行自定义代码，特别是 <code>Attributes</code>。例如，虚构的API可以是这样的：<code>has $.speed is optional</code>。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>我们怎么知道 $.speed 是多少？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>由于 <code>CHOICE</code> 类型是“特殊的”，但仍然是一流的（例如，你可以使它递归），我们需要在这里发挥作用：<code>ASNChoice</code> 来救援。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="literalblock">
<div class="content">
<pre>我们怎么知道 `ASN.1`我们的 Str 类型是什么类型的字符串？</pre>
</div>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>我们来写吧 <code>has Str $.name is UTF8String;</code>。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>我们如何指定字段的默认值？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>虽然 Raku 已经具有内置 <code>is default</code> 特性，但对我们来说不好的是我们无法“很好地”检测到它。因此，我们必须引入另一个自定义特征，以满足我们的目的并应用内置特征：<code>has Str $.message is default-value(&#34;Hello World&#34;);</code></p>
</div>
<div class="paragraph">
<p>让我们在一个包中回答所有这些问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role ASNSequence { #`[ Elves Special Magic Truly Happens Here ] }

role ASNChoice { #`[ And even here ]  }

class SpeedChoice does ASNChoice {
    method ASN-choice() {
        # Description of: names, tags, types specificed by this CHOICE
        { mph =&gt; (0 =&gt; Int), kmph =&gt; (1 =&gt; Int) }
    }
}

class Rocket does ASNSequence {
    has Str $.name is UTF8String;
    has Str $.message is default-value(&#34;Hello World&#34;) is UTF8String;
    has Fuel $.fuel;
    has SpeedChoice $.speed is optional;
    has Str @.payload is UTF8String;

    method ASN-order { &lt;$!name $!message $!fuel $!speed @!payload&gt; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>值可能类似于：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $rocket = Rocket.new(
    name =&gt; &#39;Falcon&#39;,
    fuel =&gt; Solid,
    speed =&gt; SpeedChoice.new((mph =&gt; 18000)),
    payload =&gt; [ &#34;Car&#34;, &#34;GPS&#34; ]);</code></pre>
</div>
</div>
<div class="paragraph">
<p>答案越多，问题就越多</p>
</div>
<div class="paragraph">
<p>对于这个微小的例子（另一方面，它已经 `ASN.1`展示了许多特性），实际上，我们需要在我们的应用程序中使用这个类的实例，并可能根据需要对其进行编码和解码。</p>
</div>
<div class="paragraph">
<p>那么精灵们对我们的数据秘密做了什么？让我们在下一篇文章中找到答案！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十五天_使用_raku_构建小型航天器">41. 第十五天 - 使用 Raku 构建(小型)航天器</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_炫耀长耳朵">41.1. 炫耀长耳朵</h3>
<div class="paragraph">
<p>在<a href="https://rakuadvent.wordpress.com/2018/12/14/designing-a-space-ship-with-perl-6/">上一篇文章</a>中，我们遇到了某种特殊精灵的魔力：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Fuel &lt;Solid Liquid Gas&gt;;

class SpeedChoice does ASNChoice {
    method ASN-choice { { mph =&gt; (1 =&gt; Int), kmph =&gt; (0 =&gt; Int) } }
}

class Rocket does ASNSequence {
    has Str $.name is UTF8String;
    has Str $.message is default-value(&#34;Hello World&#34;) is UTF8String;
    has Fuel $.fuel;
    has SpeedChoice $.speed is optional;
    has Str @.payload is UTF8String;

    method ASN-order { &lt;$!name $!message $!fuel $!speed @!payload&gt; }
}

my $rocket = Rocket.new(
    name =&gt; &#39;Falcon&#39;,
    fuel =&gt; Solid,
    speed =&gt; SpeedChoice.new((mph =&gt; 18000)),
    payload =&gt; [ &#34;Car&#34;, &#34;GPS&#34; ]);

my $rocket-bytes = ASN::Serializer.serialize($rocket, :mode(Implicit));

#`[ Result:
      Blob.new(
          0x30, 0x1B, # Outermost SEQUENCE
          0x0C, 0x06, 0x46, 0x61, 0x6C, 0x63, 0x6F, 0x6E, # NAME, MESSAGE is missing
          0x0A, 0x01, 0x00, # ENUMERATED
          0x81, 0x02, 0x46, 0x50, # CHOICE
          0x30, 0x0A, # SEQUENCE OF UTF8String
              0x0C, 0x03, 0x43, 0x61, 0x72,  # UTF8String
              0x0C, 0x03, 0x47, 0x50, 0x53); # UTF8String
]

say ASN::Parser.new(:type(Rocket)).parse($rocket-bytes) eqv $rocket; # Certainly true!</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类型类型类型">41.2. 类型，类型，类型</h3>
<div class="paragraph">
<p>有些事情是不言而喻的（或者对于我来说，用了无数个小时来看精灵如何玩魔法）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># 1
role ASNSequence {
    # every descendant has to fulfill this important vow!
    method ASN-order {...}
}

# 2
role ASNChoice {
    has $.choice-value;

    # if you have to choose, choose wisely!
    method ASN-choice() {...}
    method ASN-value() { $!choice-value }

    method new($choice-value) { $?CLASS.bless(:$choice-value) }
}

# 3
role ASN::StringWrapper {
    has Str $.value;

    # Don&#39;t do this at home. :]
    method new(Str $value) { self.bless(:$value) }
}

# UTF8String wrapper
role ASN::Types::UTF8String does ASN::StringWrapper {}

# Yes, it is _this_ short
multi trait_mod:(Attribute $attr, :$UTF8String) is export { $attr does ASN::Types::UTF8String }</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>第一个是一个简单的角色，它允许我们强制执行 <code>ASN-order</code> 方法</p>
</li>
<li>
<p>第二个是持有 CHOICE 实际值的角色，并强制执行用户必须描述可能选项的方法</p>
</li>
<li>
<p>第三个描述了一个特性，如 <code>is UTF8String</code>，它为属性添加一个角色，这将在以后帮助我们，并提供角色本身以及一些包装代码</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>与第三部分表达的方式相同，可以表达 <code>OPTIONAL</code>，<code>DEFAULT</code> “traits”和其他字符串类型。</p>
</div>
</div>
<div class="sect2">
<h3 id="_进步进化序列化">41.3. 进步，进化，序列化！</h3>
<div class="paragraph">
<p>通过一系列规则可以做什么来序列化事物？鉴于 <code>Basic Encoding Rules</code> 对不同类型的值有不同的处理方式（如果你思考一下就不会觉得太奇怪！）以及一个类型可以嵌套在另一个类型中的事实，更不用说是递归的了？我觉得它可能不太难实现。 Raku 的 multi-dispatch 正派上用场！</p>
</div>
<div class="paragraph">
<p>一般来说，事情如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class ASN::Serializer {
    ...

    # like this:
    multi method serialize(ASNSequence $sequence, Int $index = 48, :$debug, :$mode = Implicit) { ... }

    # or this:
    multi method serialize(Int $int is copy where $int.HOW ~~ Metamodel::ClassHOW, Int $index = 2, :$debug, :$mode) { ... }
    multi method serialize($enum-value where $enum-value.HOW ~~ Metamodel::EnumHOW, Int $index = 10, :$debug, :$mode) { ... }

    # or even this:
    multi method serialize(Positional $sequence, Int $index is copy = 16, :$debug, :$mode) { ... }

    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>描述该领域所有内容的规则是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于复杂类型，必须引入一个 <strong>has</strong>，如 <code>ASNStructure</code>，迭代其内容，逐个序列化内部，并正确加入它。在一天结束时，对于每个这样的 <code>Serializer</code> 程序都具有已知的属性类型或者可以基于特征应用的角色（方便！）推断它，可以具有属性的值（或者如果属性是可选的并且可以省略则可以跳过该属性） ，可以包装/解包基于 <code>Str</code> 的类型 - 所有这些都允许一个序列化类型</p>
</li>
<li>
<p>对于简单类型，可以根据给定的规则对其进行序列化</p>
</li>
<li>
<p>对于一些方便的“特殊情况”，例如像 <code>@.foo</code> 那样的属性，需要推断发生了什么（在这种情况下，它将是 <code>SEQUENCEOF</code> 类型）并正确地序列化它</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>除了带有值的第一个参数外，还有三个参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>$index</code> 整数派上用场，特别是对于 BER 特定的索引</p>
</li>
<li>
<p><code>$debug</code> flag 启用调试输出（当调试一些二进制协议时，这非常有用！）</p>
</li>
<li>
<p>将来可能会使用 <code>$mode</code> 值来支持 <code>IMPLICIT</code> 以外的标记模式。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_如果有时间进行编码总会有时间进行解码">41.4. 如果有时间进行编码，总会有时间进行解码</h3>
<div class="paragraph">
<p>什么是解析器？如果序列化程序是“向后解析器”，那么解析器就是…​…​是的，它是一个向后的序列化器！但是这是什么意思？通常，序列化器接收一些 A 并产生一些给定形式的 B。并且解析器获取给定形式的一些 B 并产生一些 A。</p>
</div>
<div class="paragraph">
<p>假设有人知道正在解析的确切类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $parser = ASN::Parser.new(type =&gt; Rocket);
say $parser.parse($rocket-ber); # Yes, here goes our rocket!</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要解析此 <code>Buf</code> 内容，则必须指定其类型，就像下面这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method parse(Blob $input, ...) {
    ...
    self.parse($input, $!type, ...);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个方法不知道它所解析的类型，但它调用了它的朋友：<code>parse($input, SomeCoolType, …​)</code> 超出了传递的内容和它可以得到的类型。如果知道了类型，多重分派将很乐意为我们提供必要的解析实现。对于简单的类型。对于复杂的类型。对于“特殊”类型。有了 Raku，任何一天都会发生便利的奇迹！</p>
</div>
<div class="paragraph">
<p>让我们再看一眼：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Details and basic indentation are omitted for clarity

...

multi method parse(Buf $input is rw, ASNSequence $type, :$debug, :$mode) {
    # `$type` here is, really, not a value, but a Type Object. As `ASN-order` is defined on
    # type, there are no problems with gathering necessary info:
    my @params = do gather {
        for $type.ASN-order.kv -&gt; $i, $field {
            # Here be dragons! Or, rather, MOP is used here!
        }
    }
    # A-a-and a ready object of a type our parser has no clue about is returned.
    # Yes, it is kind of neat. :)
    $type.bless(|Map.new(@params));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上，更简单的类型更简单，就像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method parse(Buf $input is rw, $enum-type where $enum-type.HOW ~~ Metamodel::EnumHOW, :$debug, :$mode) {
    say &#34;Parsing `$input[0]` out of $input.perl()&#34; if $debug;
    $enum-type($input[0]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，必须保持规则，以表明错误，并做各种“无聊”的事情，而不是“必要”的事情。虽然 Raku 允许我们在这个区域使用一些不错的技巧，但在圣诞节前看它并不是太感兴趣。</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_oclock_supply_oclock">41.5. What o’clock? Supply o’clock!</h3>
<div class="paragraph">
<p>如果你已经厌倦了所有这些与 <code>ASN.1</code> 相关的东西，我有一个好消息：它已经快结束了。 \O/</p>
</div>
<div class="paragraph">
<p>虽然所有这些“类型是我的一等公民而我很酷”技巧很有趣，但还有一个技巧可以展示，虽然是相关的，但却有点完全不同。</p>
</div>
<div class="paragraph">
<p><code>ASN.1</code> 解析器应该是增量的。更重要的是，它必须是非常明确的，因为人们可以使用未知长度的值。可以做些什么来快速使我们的解析器增量？我们快点做吧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class ASN::Parser::Async {
    has Supplier::Preserving $!out = Supplier::Preserving.new;
    has Supply $!values = $!out.Supply;
    has Buf $!buffer = Buf.new;
    has ASN::Parser $!parser = ASN::Parser.new(type =&gt; $!type);
    has $.type;

    method values(--&gt; Supply) {
        $!values;
    }

    method process(Buf $chunk) {
        $!buffer.append: $chunk;
        loop {
            # Minimal message length
            last if $!buffer.elems &lt; 2;
            # Message is incomplete, good luck another time
            last unless $!parser.is-complete($!buffer);
            # Cut off tag, we know what it is already in this specific case
            $!parser.get-tag($!buffer);
            my $length = $!parser.get-length($!buffer);
            # Tag and length are already cut down here, take only value
            my $item-octets = $!buffer.subbuf(0, $length);
            $!out.emit: $!parser.parse($item-octets, :!to-chop); # `!to-chop`, because &#34;prefix&#34; is already cut
            $!buffer .= subbuf($length);
        }
    }

    method close() {
        $!out.done;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它可以像这样使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $parser = ASN::Parser::Async.new(type =&gt; Rocket);

$parser.values.tap({ say &#34;I get a nice thing!&#34;; });

react {
    whenever $socket.data-arrived -&gt; $chunk {
        $parser.process($chunk);
        LAST { $parser.close; }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是所有必须添加的，以使这种 <code>Parser</code> 增量为这个最小的情况。</p>
</div>
<div class="paragraph">
<p>当然，正如你可以猜到的那样，我正在写的东西有点过于具体，不仅仅是我的想象力，不仅是精灵，而是一群完整的冒险者（他们也可以处理一些二进制的东西！）。该实现已在 <a href="https://github.com/Altai-man/ASN-BER">ASN::BER 仓库</a>中提供。虽然它可能是一个非常早期的 alpha 版本，有许多东西甚至还没有计划好，并且有很长的篇幅可以用来改善这个模块的整体状态，它已经对我有用了解我的工作前面提到的半秘密。仓库肯定会打开建议，错误报告（甚至可能是 hug 报告），因为还有大量工作要做，但这是另一个故事了。</p>
</div>
<div class="paragraph">
<p>祝您度过愉快的一天，并确保在圣诞假期休息好！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十六天_检查你的列表俩次">42. 第十六天 - 检查你的列表俩次</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_从命令行了解_raku">42.1. 从命令行了解 Raku</h3>
<div class="paragraph">
<p>这是 Sniffles the Elf 的大好机会！在丝带矿山经过多年的苦差事后，他们终于被提升到了清单管理部门。作为一名闪亮的新助理尼斯名单审核员，Sniffles 正在走向重要时刻。</p>
</div>
<div class="paragraph">
<p>在 Sniffles 到达的第一天，他们的新老板格伦布尔先生正等着他。“好人清单管理很麻烦，当有人在服务器上洒了牛奶和饼干时，我们的数据被意外删除了。我们一直在忙着检查列表，我们忘了检查备份！现在我们必须从头开始重建一切！裁员后，我们有点人手不足，所以由你来挽救这一天。“</p>
</div>
<div class="paragraph">
<p>Sniffles，特别勤劳，津津乐道于这个问题。经过一些研究，他们意识到他们需要的所有数据都可用，他们只需要收集它。</p>
</div>
<div class="paragraph">
<p>他们的朋友在丝带矿山中，一位名叫 Hermie 的自称口述历史学家一直在谈论 Raku 有多么伟大。Sniffles 决定尝试一下。</p>
</div>
</div>
<div class="sect2">
<h3 id="_就像拔牙">42.2. 就像拔牙?</h3>
<div class="paragraph">
<p>Sniffles 首先用一种新语言抛出标准的第一个脚本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.d;

say &#34;Nice List restored!!!&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该脚本运行并尽职尽责地打印出消息。距离圣诞节还有几天了，是时候认真对待 <a href="https://docs.raku.org/">Raku文档</a>了。</p>
</div>
<div class="paragraph">
<p>稍微浏览一下 Sniffles 的 <a href="https://docs.raku.org/language/create-cli">Raku 命令行界面实用程序</a> 页面。他们喜欢它描述的 <code>MAIN</code> 这个特殊子程序的外观。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#39;Started initializing nice lister.&#39;;
sub MAIN() { say &#34;Nice List restored!!!&#34; }
say &#39;Finished initializing nice lister.&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Started initializing nice lister.
Finished initializing nice lister.
Nice List restored!!!</pre>
</div>
</div>
<div class="paragraph">
<p>好吧，至少那是他们的启动代码。Sniffles 抛弃了初始化消息，它们只是噪音。但他们确信这个 <code>MAIN</code> 函数必须有更多的技巧才能让 Hermie 如此兴奋。</p>
</div>
<div class="paragraph">
<p>回到文档…​检查了<a href="https://learnxinyminutes.com/docs/raku/">Y分钟学会X语言的 Raku 页面</a>。<code>MAIN</code> 接近尾声的额外部分是金矿！Sniffles 对这个念头打了个寒颤。</p>
</div>
<div class="paragraph">
<p>“好的，所以如果我们提供 <code>MAIN子</code> 程序签名，Raku 会为我们处理命令行解析。更好的是，它会自动生成帮助内容，“他们对自己嘟囔道。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN (
    :$list-of-all-kids,
    :$naughty-list
) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ nice-list
Usage:
  nicelist [--list-of-all-kids=&lt;Any&gt;] [--naughty-list=&lt;Any&gt;]</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行脚本得到：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Stub code executed
  in sub MAIN at foo line 1
  in block &lt;unit&gt; at foo line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>真棒。</p>
</div>
<div class="paragraph">
<p>但是开关名称有点长。由于 TheNorthPole.io 是一个专门的商店，Sniffles 认为他们可能不得不输入一堆。呸。如果您可以添加一些解释性文字，更短的名称将没有问题。Raku 支持使用 POD6 标记进行文字编程，因此可以轻松添加注释。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| Rebuild the Nice List
sub MAIN (
    :$all,    #= path to file containing the list of all children
    :$naughty #= path to file containing the Naughty List
) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Usage:
  nicelist [--all=&lt;Any&gt;] [--naughty=&lt;Any&gt;] -- Rebuild the Nice List

    --all=&lt;Any&gt;        path to file containing the list of all children
    --naughty=&lt;Any&gt;    path to file containing the Naughty List</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sniffles 印象深刻，但他们知道参数验证是编写 CLI 的另一部分，可能会变得乏味。“Raku 最近为我做了什么？”他们想知道。</p>
</div>
</div>
<div class="sect2">
<h3 id="_一种强大的沉默的类型">42.3. 一种强大的，沉默的类型</h3>
<div class="paragraph">
<p>Raku 有一个渐进式<a href="https://docs.raku.org/language/typesystem">类型系统</a>，包括编译和运行时类型检查。渐进类型允许 Sniffles 到目前为止忽略类型检查。他们添加了一些类型，看看发生了什么。</p>
</div>
<div class="paragraph">
<p>Sniffles 使用<a href="https://docs.raku.org/type/Signature#Constraining_argument_definiteness">类型 smiley</a>定义了 Str 的子集，该类型使用 <a href="https://docs.raku.org/type/Whatever">whatevercode</a> 来验证给定路径上是否存在文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset FilePath of Str:D where *.IO.f;

#| Rebuild the Nice List
sub MAIN (
    FilePath :$all,    #= path to file containing the list of all children
    FilePath :$naughty #= path to file containing the Naughty List
) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>他们运行这个脚本:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$nice-list  --naughty=naughty.kids --all=notAFile.bleh
Usage:
  nice-list [--all=&lt;FilePath&gt;] [--naughty=&lt;FilePath&gt;] -- Rebuild the Nice List</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>--all=&lt;FilePath&gt;        path to file containing the list of all children
--naughty=&lt;FilePath&gt;    path to file containing the Naughty List</pre>
</div>
</div>
<div class="paragraph">
<p>Sniffles 在没有争论和其他一些无效方式的情况下再次运行脚本。每次捕获无效输入并自动显示使用消息。 “非常好，”Sniffles 想道，“事实上，错误报告仍然很糟糕。如果你抛出一个参数就好像传入一个丢失的文件一样，你会得到相同的结果。”</p>
</div>
</div>
<div class="sect2">
<h3 id="_精灵类型不匹配_弥补改进的错误处理">42.4. 精灵类型不匹配 - 弥补改进的错误处理</h3>
<div class="paragraph">
<p>&#34;Ugh! How do I get around <strong>this</strong> problem?&#34; Sniffles shuffled around the docs some more.  <a href="https://docs.raku.org/syntax/multi">Multiple Dispatch</a> and <a href="https://docs.raku.org/type/Signature#index-entry-slurpy_argument">slurpy parameters</a>.  They added another subset and a couple of new definitions of MAIN:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset FileNotFound of Str:D where !*.IO.f();

multi sub MAIN (
    FilePath :$all,    #= path to file containing the list of all children
    FilePath :$naughty #= path to file containing the Naughty List
) { ... }

multi sub MAIN (
    FileNotFound :$all,
    *%otherStuff
) {
    die &#34;List of all children file does not exist&#34;;
}

multi sub MAIN (
    FileNotFound :$naughty,
    *%otherStuff
) {
    die &#34;Naughty List file does not exist&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>他们得到了:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Usage:
  nice-list [--all=&lt;FilePath&gt;] [--naughty=&lt;FilePath&gt;] -- Rebuild the Nice List
  nice-list [--all=&lt;FileNotFound&gt;] [--naughty=&lt;FilePath&gt;]
  nice-list [--all=&lt;FilePath&gt;] [--naughty=&lt;FileNotFound&gt;]</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>--all=&lt;FilePath&gt;        path to file containing the list of all children
--naughty=&lt;FilePath&gt;    path to file containing the Naughty List</pre>
</div>
</div>
<div class="paragraph">
<p>哪个工作完美…​除了现在他们在使用中有错误生成条目！双翘。Sniffles返回到CLI界面上的文章。将正确的特征添加到MAIN潜艇将使它们从自动生成的使用中消失：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN (
    FileNotFound :$all,
    *%otherStuff
) is hidden-from-USAGE {
    die &#34;List of all children file does not exist&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一团糟不见了！</p>
</div>
</div>
<div class="sect2">
<h3 id="_我们不会去直到我们得到一些">42.5. 我们不会去，直到我们得到一些！</h3>
<div class="paragraph">
<p>Grumble 先生走了过来，他停下来看着 Sniffles 的屏幕。“那里有趣的工作，Sniffles。我们需要那个脚本，我们昨天需要它。哦，我们需要它能够审核现有的 Nice List 并重建一个。我们也需要这个。看到你。“在Sniffles眨眼之前他消失了。</p>
</div>
<div class="paragraph">
<p>Sniffles 认为，做一个爬行的功能比被迫吃无花果布丁更好。他们添加了这些命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| Rebuild the Nice List
multi sub MAIN (
    &#39;build&#39;,
    FilePath :$all,    #= path to file containing the list of all children
    FilePath :$naughty #= path to file containing the Naughty List
) { ... }

#| Compare all the lists for correctness
multi sub MAIN (
    &#39;audit&#39;,
    FilePath :$all,     #= path to file containing the list of all children
    FilePath :$naughty, #= path to file containing the Naughty List
    FilePath :$nice,    #= path to file containing the Nice List
) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>“好极了，”他们想，“但你必须像这样运行脚本 <code>nicelist --all=foo --naughty=bar build</code>。可怕。”</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %*SUB-MAIN-OPTS =
    :named-anywhere,    # allow named variables at any location
;</code></pre>
</div>
</div>
<div class="paragraph">
<p>“它被修复了！” Sniffles 在座位上跳起来了。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Usage:
  nicelist build [--all=&lt;FilePath&gt;] [--naughty=&lt;FilePath&gt;] -- Rebuild the Nice List
  nicelist audit [--all=&lt;FilePath&gt;] [--naughty=&lt;FilePath&gt;] [--nice=&lt;FilePath&gt;] -- Compare all the lists for correctness</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>--all=&lt;FilePath&gt;        path to file containing the list of all children
--naughty=&lt;FilePath&gt;    path to file containing the Naughty List
--nice=&lt;FilePath&gt;       path to file containing the Nice List</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_跑步者走上了这条路">42.6. 跑步者走上了这条路。</h3>
<div class="paragraph">
<p>好的，现在 Sniffles 拥有一个完美的框架来构建一个优秀的实用程序脚本。是时候实际写出实际的东西了。Sniffles 知道他们真的打算雪橇这个项目。</p>
</div>
<div class="paragraph">
<p>很快，Snuffles发现Raku的功能集帮助他们制作了一个功能强大，正确的脚本。他们创建了一个 Child <a href="https://docs.raku.org/language/classtut">类</a>，在其上<a href="https://docs.raku.org/language/mop#index-entry-syntax_WHICH-WHICH">定义了身份操作</a>，编写了一个用于加载列表数据的简洁 CSV 解析器和一个报告函数。内置的 <a href="https://docs.raku.org/type/Set">Set 数据类型</a>提供了操作符，可以轻松查找不合适的条目，甚至更容易重建 Nice List。</p>
</div>
<div class="paragraph">
<p>一旦<a href="https://gist.github.com/daotoad/47bcbc6f1dc066fff982a72481c6bcd2">完成</a>，他们就恢复了 Nice List，并向 Grumbles 先生及其他团队发送了一封部门电子邮件，宣布他们取得了成功。当格罗布尔斯先生看到脚本有多好，它的用法和错误检查，仅此一次，他辜负了他们的期望。</p>
</div>
<div class="paragraph">
<p>为了表彰他们的辛勤工作和机智，Sniffles 被要求在圣诞老人最新工作室的开幕处剪彩。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第17天_通往幸福的编译之路">43. <a href="https://rakuadvent.wordpress.com/2018/12/17/day-17-compiling-our-way-to-happiness/">第17天 - 通往幸福的编译之路</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果我们选择接受它，我们的任务就是解决`SEND + MORE = MONEY`代码中的问题。不，请等一下，让我这样说吧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">    S E N D
+   M O R E
-----------
  M O N E Y</code></pre>
</div>
</div>
<div class="paragraph">
<p>它意味着相同，但是这样放置它更具<a href="https://en.wikipedia.org/wiki/Carry_(arithmetic">视觉冲击力</a>)，特别是因为我们很多人在学校这样做了。</p>
</div>
<div class="paragraph">
<p>基本规则很简单。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每个字母代表0到9之间的数字。</p>
</li>
<li>
<p>字母代表*不同的*数字; 两个字母可能不共享相同的数字。</p>
</li>
<li>
<p>前导数字（在我们的拼图中，<code>S</code> 和 <code>M</code>）不能为零。如果为零他们就不会是前导数字！</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>鉴于这些限制因素，上述难题有一个独特的解决方案。</p>
</div>
<div class="paragraph">
<p>我鼓励你找到解决方案。写一点代码，坚持一下！在这篇文章中，我们会这样做，但后来（关键）*不满足*于此，并最终陷入嵌套玩偶的情况，其中代码编写代码直到出现真正整洁的东西。结论将拼出最终目标-坚持不住了，我被实时地通过多个委员会获悉，正确的说法是“ *一个*终极愿景” -为了 Raku。</p>
</div>
<div class="paragraph">
<p>我们开工吧。</p>
</div>
<div class="sect2">
<h3 id="_marcus_junius_brute_forcethe_younger">43.1. Marcus Junius Brute Force（The Younger）</h3>
<div class="paragraph">
<p>我们当天的第一语言及其相应的解决方案是 Raku 本身。这里没有技巧; 我们只是像愤怒的公牛一样向问题域冲去，尝试一切。事实上，我们确保不要在这个问题上耍小聪明，只是尝试尽可能直接地表达解决方案。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 0..9 -&gt; int $d {
    for 0..9 -&gt; int $e {
        next if $e == $d;

        my int $y = ($d + $e) % 10;
        my int $_c1 = ($d + $e) div 10;

        for 0..9 -&gt; int $n {
            next if $n == $d;
            next if $n == $e;
            next if $n == $y;

            for 0..9 -&gt; int $r {
                next if $r == $d;
                next if $r == $e;
                next if $r == $y;
                next if $r == $n;

                next unless ($_c1 + $n + $r) % 10 == $e;
                my int $_c2 = ($_c1 + $n + $r) div 10;

                for 0..9 -&gt; int $o {
                    next if $o == $d;
                    next if $o == $e;
                    next if $o == $y;
                    next if $o == $n;
                    next if $o == $r;

                    next unless ($_c2 + $e + $o) % 10 == $n;
                    my int $_c3 = ($_c2 + $e + $o) div 10;

                    for 1..9 -&gt; int $s {
                        next if $s == $d;
                        next if $s == $e;
                        next if $s == $y;
                        next if $s == $n;
                        next if $s == $r;
                        next if $s == $o;

                        for 1..9 -&gt; int $m {
                            next if $m == $d;
                            next if $m == $e;
                            next if $m == $y;
                            next if $m == $n;
                            next if $m == $r;
                            next if $m == $o;
                            next if $m == $s;

                            next unless ($_c3 + $s + $m) % 10 == $o;
                            my int $_c4 = ($_c3 + $s + $m) div 10;

                            next unless $_c4 % 10 == $m;

                            say &#34;$s$e$n$d + $m$o$r$e == $m$o$n$e$y&#34;;
                        }
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你又看到了，它不*漂亮*，但它起作用了。这是你母亲警告你的那种缩进程度。不过，如果你问我，我更讨厌缩进。对于我们需要扫描其搜索空间的每个变量，我们都有一个。（只有有`Y`我们才能走捷径。）</p>
</div>
<div class="paragraph">
<p>虽然这是今天猛烈冲击的迂回而已，但MJD曾<a href="https://blog.plover.com/prog/haskell/monad-search.html">在博客上发表过关于此事的博客</a>，然后我<a href="http://strangelyconsistent.org/blog/send-more-money-in-raku">也在</a><a href="https://blog.plover.com/prog/haskell/monad-search.html">博客上写了这篇文章</a>。从某种意义上说，这些博客文章非常关注“删除缩进”。今天的帖子是我三年后的想法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_我让路径遍历少了以及所有其他路径">43.2. 我让路径遍历少了（以及所有其他路径）</h3>
<div class="paragraph">
<p>我们的第二语言仍然主要是 Raku，但有一个简洁的假象扩展名`amb`，但是拼写为（令人回味）<code>←</code>。它摆脱了所有显式`for`循环和缩进层级。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $d &lt;- 0..9;
my $e &lt;- 0..9;
guard $e != any($d);
my $y = ($d + $e) % 10;
my $_c1 = ($d + $e) div 10;

my $n &lt;- 0..9;
guard $n != any($d, $e, $y);
my $r &lt;- 0..9;
guard $r != any($d, $e, $y, $n);
guard ($_c1 + $n + $r) % 10 == $e;
my $_c2 = ($_c1 + $n + $r) div 10;

my $o &lt;- 0..9;
guard $o != any($d, $e, $y, $n, $r);
guard ($_c2 + $e + $o) % 10 == $n;
my $_c3 = ($_c2 + $e + $o) div 10;

my $s &lt;- 1..9;
guard $s != any($d, $e, $y, $n, $r, $o);
my $m &lt;- 1..9;
guard $m != any($d, $e, $y, $n, $r, $o, $s);
guard ($_c3 + $s + $m) % 10 == $o;
my $_c4 = ($_c3 + $s + $m) div 10;

guard $_c4 % 10 == $m;

say &#34;$s$e$n$d + $m$o$r$e == $m$o$n$e$y&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种解决方案更短，更紧凑，并且感觉不那么“聒噪”，并且只是通过摆脱`for`循环来加重。（我怀疑这与人们有时提到的那些命令性的声明谱有关。我们对循环不是那么感兴趣，只看到它完成了。）</p>
</div>
<div class="paragraph">
<p>我知道它不会完全弥补Raku没有`amb`运算符并且 `guard`在核心中（甚至在模块空间中）实现的事实，但是这里有一个简短的脚本将上述程序转换为今天的第一个版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $indent = 0;
constant SPACE = chr(0x20);
sub indent { SPACE x 4 * $indent }

for lines() {
    when /^ my \h+ (&#39;$&#39; \w) \h* &#39;&lt;-&#39; \h* (\d+ \h* &#39;..&#39; \h* \d+) &#39;;&#39; $/ {
        say indent, &#34;for $1 -&gt; int $0 \{&#34;;
        $indent++;
    }

    when /^ guard \h+ (&#39;$&#39; \w) \h* &#39;!=&#39; \h* &#39;any(&#39; (&#39;$&#39; \w)+ % [\h* &#39;,&#39; \h*] &#39;)&#39; \h* &#39;;&#39; $/ {
        say indent, &#34;next if $0 == $_;&#34;
            for $1;
        say &#34;&#34;;
    }

    when /^ guard \h+ ([&lt;!before &#39;==&#39;&gt; .]+ &#39;==&#39; &lt;-[;]&gt;+) &#39;;&#39; $/ {
        say indent, &#34;next unless $0;&#34;;
    }

    when /^ my \h+ (&#39;$&#39; \w+) \h* &#39;=&#39; \h* (&lt;-[;]&gt;+) &#39;;&#39; $/ {
        say indent, &#34;my int $0 = $1;&#34;;
    }

    when /^ \h* $/ {
        say &#34;&#34;;
    }

    when /^ say \h+ (&lt;-[;]&gt;+) &#39;;&#39; $/ {
        say indent, $_;
    }

    default {
        die &#34;Couldn&#39;t match $_&#34;;
    }
}

while $indent-- {
    say indent, &#34;\}&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但我们也不会就此满意。哦，不。</p>
</div>
</div>
<div class="sect2">
<h3 id="_在方程式中思考">43.3. 在方程式中思考</h3>
<div class="paragraph">
<p>第三种语言将我们进一步引入声明，摆脱了所有仅仅表明变量应该是不同项的 `guard ` 从句。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">ALL_DISTINCT

$d in 0..9
$e in 0..9
$n in 0..9
$r in 0..9
$o in 0..9
$s in 1..9
$m in 1..9

$y = ($d + $e) % 10
$_c1 = ($d + $e) div 10

($_c1 + $n + $r) % 10 == $e
$_c2 = ($_c1 + $n + $r) div 10

($_c2 + $e + $o) % 10 == $n
$_c3 = ($_c2 + $e + $o) div 10

($_c3 + $s + $m) % 10 == $o
$_c4 = ($_c3 + $s + $m) div 10

$_c4 % 10 == $m</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们现在完全处于<a href="https://en.wikipedia.org/wiki/Constraint_programming">约束编程</a>领域，如果不提这一点，是不诚实的。我们已经抛弃了Raku的必要方面，我们只关注描述我们正在解决的问题的约束。</p>
</div>
<div class="paragraph">
<p>上述程序最重要的方面是我们赋值时。即使这主要是一种优化，在我们知道我们可以直接计算变量的值而不是搜索变量的情况下。</p>
</div>
<div class="paragraph">
<p>即使在这种情况下，我们也可以转换回以前的解决方案。不过，我现在会省略这样一个翻译。</p>
</div>
<div class="paragraph">
<p>我将在结论中回到这种语言，因为它在很多方面证明了，这是最有趣的一种。</p>
</div>
</div>
<div class="sect2">
<h3 id="_第四语言">43.4. 第四语言</h3>
<div class="paragraph">
<p>到目前为止，我们还有哪些必要的复杂性可以剥离？具体而言，这些方程式来自前一解决方案中指定的位置？我们怎样才能更简洁地表达它们？</p>
</div>
<div class="paragraph">
<p>我想你会喜欢这个。第四种语言只是表达了这样的搜索：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">    S E N D
+   M O R E
-----------
  M O N E Y</code></pre>
</div>
</div>
<div class="paragraph">
<p>等一下，为什么又来？是的，你没有看错。这个问题最具声明性的解决方案只是问题规范本身的ASCII布局！当问题域和答案域如此相遇时，难道你不喜欢它吗？</p>
</div>
<div class="paragraph">
<p>从这个布局上，我们可以再次转换回约束编程解决方案，从手动算法中编写方程式，以便我们在学校学习。</p>
</div>
<div class="paragraph">
<p>因此，我们不仅不需要编写那些加重`for`循环的东西; 如果我们足够顽强，我们可以从问题到解决方案一直生成代码。我们只需找到合适的语言就可以了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论_5">43.5. 结论</h3>
<div class="paragraph">
<p>我对007的探索使我思考了上述事情：翻译程序。Raku 已经很好地公开了编译过程的一部分：解析。我们可以在用户空间和Raku工具链中使用 grammars。</p>
</div>
<div class="paragraph">
<p>我开始相信我们需要对编译管道的所有方面都这样做。在这里，让我把它作为口号或声明：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>当我们带来操作文本/数据的所有功能也可以向内转到编译过程本身时，Raku将充分发挥其潜力。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>我在不同语言之间编写（或想象）的那些翻译器，他们在压力下工作，但他们也很脆弱，有点浪费。问题在很大程度上是我们一直下降到文本。我们应该在AST级别执行此操作，其中所有结构都可用。</p>
</div>
<div class="paragraph">
<p>这种思想转变所带来的收益不容小觑。这是我们在Raku中找到Lispy启蒙的地方。</p>
</div>
<div class="paragraph">
<p>例如，带方程的第三种语言不必盲目地翻译成代码。它可以被*优化*，方程式篡改成更窄和更精确的方程式。从<a href="https://en.wikipedia.org/wiki/Verbal_arithmetic#Solving_cryptarithms">维基百科</a>可以看出，有可能做到如此优秀，以至于一旦程序运行就没有剩下的搜索。</p>
</div>
<div class="paragraph">
<p>我的梦想：能够进行上述转换，而不是在文本文件之间，而是在Raku中的*俚语*之间。并且能够进行优化步骤。一切都没有离开语言的舒适。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十八天_一棵_avg_格式的圣诞树">44. 第十八天 - 一棵 AVG 格式的圣诞树</h2>
<div class="sectionbody">
<div class="paragraph">
<p>圣诞树是一种传统的象征，可以追溯到欧洲四百多年前，所以对于一篇关于创造圣诞树图像的出现文章来说，这可能更好。</p>
</div>
<div class="paragraph">
<p>树的典型，简化的表示是几个尺寸逐渐减小的三角形，彼此叠加并且具有小的重叠，因此使用计算机程序很容易创建。</p>
</div>
<div class="paragraph">
<p>在这里，我将使用可缩放矢量图形（SVG）绘制图像，如上所述，它似乎非常适合任务。</p>
</div>
<div class="sect2">
<h3 id="_关于svg并创建它">44.1. 关于SVG并创建它</h3>
<div class="paragraph">
<p>SVG是一种XML文档格式，它将图像描述为点之间的一组矢量，它具有线条和形状的基元，并提供所描述对象的样式。</p>
</div>
<div class="paragraph">
<p>也许最简单的SVG文档是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34;
     xmlns:svg=&#34;http://www.w3.org/2000/svg&#34;
     xmlns:xlink=&#34;http://www.w3.org/1999/xlink&#34;
     width=&#34;100&#34;
     height=&#34;100&#34;&gt;
	&lt;g&gt;
		&lt;rect x=&#34;5&#34; y=&#34;5&#34; width=&#34;90&#34; height=&#34;90&#34; stroke=&#34;black&#34; fill=&#34;green&#34; /&gt;
	&lt;/g&gt;
&lt;/svg&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这描述了侧面90的绿色填充正方形（单元基本上是抽象的并且相对于显示器的尺寸，因为图像的可缩放特性意味着它们可能不等同于例如像素。）</p>
</div>
<div class="paragraph">
<p>现在我们可以在程序中使用一些变量插值打印出XML，但是对于比上面的例子更复杂的事情，这可能会非常繁琐且容易出错。幸运的是Raku有一个方便的<a href="https://github.com/moritz/svg">SVG</a>模块，它负责从描述它的数据结构中实际创建格式良好的XML文档。因此，我们的示例矩形可以使用以下内容创建：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use SVG;

say SVG.serialize(
    svg =&gt; [
        width =&gt; 100, height =&gt; 100,
        :g[:rect[:x&lt;5&gt;, :y&lt;5&gt;, :width&lt;90&gt;, :height&lt;90&gt;, :stroke&lt;black&gt;, :file&lt;green&gt;]],
    ],
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>本质上，参数`serialize`是一组嵌套的<a href="https://docs.raku.org/type/Pair">Pairs</a>：其中value是标量类型，键和值用于形成XML属性，其中值是List of Pairs，这将创建一个以键命名的XML元素，列表中的每个对都被解释为如上所述，从而允许以简单的声明方式构建复杂文档。</p>
</div>
<div class="paragraph">
<p>所以我们可以通过构造适当的数据结构来生成我们的示例圣诞树，但是因为我们的图像中可能至少有四个对象（三个三角形和一个用于树干的矩形）及其相关属性，这可能会非常不合适如果我们想改变某些东西，很难改变。</p>
</div>
<div class="paragraph">
<p>所以…</p>
</div>
</div>
<div class="sect2">
<h3 id="_我们抽象吧">44.2. 我们抽象吧！</h3>
<div class="paragraph">
<p>为了使我们的SVG生成更加灵活并为未来的代码重用开辟了机会，创建一组代表我们可能想要使用的SVG原语的类并抽象出将要生成的数据结构可能是有意义的。序列化为XML。</p>
</div>
<div class="paragraph">
<p>所以让我们从可以生成原始矩形示例的东西开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">use SVG;

class SVG::Drawing {
    role Element {
        method serialize() {
            ...
        }
    }

    has Element @.elements;

    has Int $.width;
    has Int $.height;

    class Group does Element {
        has Element @.elements;
        method serialize( --&gt; Pair ) {
            g =&gt; @!elements.map( -&gt; $e { $e.serialize }).list;
        }
    }

    class Rectangle does Element {
        has Int $.x;
        has Int $.y;
        has Int $.width;
        has Int $.height;
        has Str $.stroke;
        has Str $.fill;

        method serialize( --&gt; Pair) {
            rect =&gt; [x =&gt;  $!x, y =&gt; $!y, width =&gt; $!width, height =&gt; $!height, stroke =&gt; $!stroke, fill =&gt; $!fill ];
        }
    }

    method serialize( --&gt; Str ) {
        SVG.serialize(svg =&gt; @!elements.map(-&gt; $e { $e.serialize }).list);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要运行此示例，则应将其保存为`SVG/Drawing.pm`当前目录。</p>
</div>
<div class="paragraph">
<p>这给出了一个类来描述我们的图像作为一个整体，并协调数据结构的创建，这些数据结构将被序列化为我们的SVG文档，并且每个类都用于我们在原始示例中使用的`g`（Group）和`rect`（Rectangle）基元所以我们可以这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">use SVG::Drawing;

my SVG::Drawing $drawing = SVG::Drawing.new(elements =&gt; [
    SVG::Drawing::Group.new(elements =&gt; [
        SVG::Drawing::Rectangle.new(x =&gt; 5, y =&gt; 5, width =&gt; 100, height =&gt; 100, stroke =&gt; &#34;black&#34;, fill =&gt; &#34;green&#34; )
    ]);
]);

say $drawing.serialize;</code></pre>
</div>
</div>
<div class="paragraph">
<p>生成与第一个类似的文档。</p>
</div>
<div class="paragraph">
<p>您可能已经注意到了`Element`stubbed方法的作用`serialize`：这是为了描述基本类所需的接口，以便收集基本类对象的类可以取决于`serialize`它们何时到来时序列化这些收集的对象。生成XML文档。从一开始就添加它可以更容易，更可靠地添加类来描述绘图的新基元。</p>
</div>
</div>
<div class="sect2">
<h3 id="_让我们延伸">44.3. 让我们延伸！</h3>
<div class="paragraph">
<p>因此，除非我们有兴趣用相互叠加的不同大小的正方形制作圣诞树的相当现代主义的表示，否则我们需要一种创建我们需要的三角形的方法。幸运的是，SVG提供了许多从一组坐标点创建任意闭合形状的方法，但我们将使用最简单的方法，<code>polygon`它有一个属性`points</code>，它是以逗号分隔的顶点坐标的空格分隔列表。形状，最后一个连接到第一个以关闭形状。</p>
</div>
<div class="paragraph">
<p>我们将使用一个新的Polygon类来描述`polygon`原语：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use SVG;

class SVG::Drawing {
    role Element {
        method serialize() {
            ...
        }
    }

    has Element @.elements;

    has Int $.width;
    has Int $.height;

    class Group does Element {
        has Element @.elements;
        method serialize( --&gt; Pair ) {
            g =&gt; @!elements.map( -&gt; $e { $e.serialize }).list;
        }
    }

    class Rectangle does Element {
        has Int $.x;
        has Int $.y;
        has Int $.width;
        has Int $.height;
        has Str $.stroke;
        has Str $.fill;

        method serialize( --&gt; Pair) {
            rect =&gt; [x =&gt;  $!x, y =&gt; $!y, width =&gt; $!width, height =&gt; $!height, stroke =&gt; $!stroke, fill =&gt; $!fill ];
        }
    }

    class Point {
        has Int $.x;
        has Int $.y;

        method Str( --&gt; Str ) {
            ($!x, $!y).join: &#39;,&#39;;
        }
    }

    class Polygon does Element {
        has Str $.stroke;
        has Str $.fill;

        has Point @.points;

        method serialize( --&gt; Pair ) {
            polygon =&gt; [ points =&gt; @!points.join(&#39; &#39;), fill =&gt; $!fill, stroke =&gt; $!stroke ];
        }

    }

    method serialize( --&gt; Str ) {
        SVG.serialize(svg =&gt; @!elements.map(-&gt; $e { $e.serialize }).list);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了我们新的Polygon类之外，还有一个Point类描述了多边形顶点的坐标：<code>Str`提供的方法是为了简化`serialize`Polygon类方法的实现，因为</code>@.points`属性的元素将被字符串化为他们加入了`serialize`。</p>
</div>
<div class="paragraph">
<p>所以现在我们可以生成类似外观的图像，但是以不同的方式构造，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use SVG::Drawing;

my SVG::Drawing $drawing = SVG::Drawing.new(elements =&gt; [
    SVG::Drawing::Group.new(elements =&gt; [
        SVG::Drawing::Polygon.new(stroke =&gt; &#34;black&#34;, fill =&gt; &#34;green&#34;, points =&gt; [
            SVG::Drawing::Point.new(x =&gt; 5, y =&gt; 5),
            SVG::Drawing::Point.new(x =&gt; 105, y =&gt; 5),
            SVG::Drawing::Point.new(x =&gt; 105, y =&gt; 105),
            SVG::Drawing::Point.new(x =&gt; 5, y =&gt; 105)
        ])
    ]);
]);

say $drawing.serialize;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将生成一个XML文档，如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34;
     xmlns:svg=&#34;http://www.w3.org/2000/svg&#34;
     xmlns:xlink=&#34;http://www.w3.org/1999/xlink&#34;&gt;
	&lt;g&gt;
		&lt;polygon points=&#34;5,5 105,5 105,105 5,105&#34; fill=&#34;green&#34; stroke=&#34;black&#34; /&gt;
	&lt;/g&gt;
&lt;/svg&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以现在我们几乎拥有了绘制Chritmas树所需的一切，但在这一点上，值得退一步，展示对未来自我（或者其他可能需要处理代码的人）的爱。</p>
</div>
</div>
<div class="sect2">
<h3 id="_一个重构点">44.4. 一个重构点</h3>
<div class="paragraph">
<p>当我们创建新的Polygon类时，我们复制了`S.stroke`和`$.fill`属性，并安排它们以类似于Rectangle类的方式进行序列化。如果我们赶时间这可能是有意义的，这些是他们可能被使用的唯一地方，但是当我们阅读SVG文档时，很明显它们可以应用于许多SVG原语，因此重构是有意义的。现在，在我们添加任何可能需要它们的类之前。</p>
</div>
<div class="paragraph">
<p>最明显的方法是创建一个包含属性的新角色，并提供一个方法，该方法返回表示序列化中属性的对列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use SVG;

class SVG::Drawing {
    role Element {
        method serialize() {
            ...
        }
    }

    role Styled {
        has Str $.stroke;
        has Str $.fill;

        method styles() {
            ( stroke =&gt; $!stroke, fill =&gt; $!fill ).grep( { .value.defined } );
        }

    }

    has Element @.elements;

    has Int $.width;
    has Int $.height;

    class Group does Element {
        has Element @.elements;
        method serialize( --&gt; Pair ) {
            g =&gt; @!elements.map( -&gt; $e { $e.serialize }).list;
        }
    }

    class Rectangle does Element does Styled {
        has Int $.x;
        has Int $.y;
        has Int $.width;
        has Int $.height;

        method serialize( --&gt; Pair) {
            rect =&gt; [x =&gt;  $!x, y =&gt; $!y, width =&gt; $!width, height =&gt; $!height, |self.styles ];
        }
    }

    class Point {
        has Int $.x;
        has Int $.y;

        method Str( --&gt; Str ) {
            ($!x, $!y).join: &#39;,&#39;;
        }
    }

    class Polygon does Element does Styled {

        has Point @.points;

        method serialize( --&gt; Pair ) {
            polygon =&gt; [ points =&gt; @!points.join(&#39; &#39;), |self.styles ];
        }

    }

    method serialize( --&gt; Str ) {
        SVG.serialize(svg =&gt; @!elements.map(-&gt; $e { $e.serialize }).list);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以现在我们有一个双重好处，我们可以添加一个新的样式类而不必复制属性，而且我们可以添加我们可能想要的新样式属性，而无需更改消耗类。</p>
</div>
<div class="paragraph">
<p>通过一些额外的工作，我们可能失去了从the中的角色调用方法的需要`serialize`，比如说，使用属性上的特征，这将允许我们选择要序列化的属性，但我将把它当作一个随着圣诞节的到来，我们仍然没有树。</p>
</div>
</div>
<div class="sect2">
<h3 id="_一个进一步的抽象">44.5. 一个进一步的抽象</h3>
<div class="paragraph">
<p>现在我们处于一个很好的位置来创建我们的圣诞树，因为我们需要的三角形只是一个多边形的三面形状，但我们想要不止一个并且顶点的计算将是相当重复，加上，因为我为了简单而任意选择使用等边三角形，其他两个角的坐标可以从顶点和边长度的坐标计算，所以如果我们有一个三角类它可以自我计算，我们只需关注自己的大小和位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use SVG;

class SVG::Drawing {
    role Element {
        method serialize() {
            ...
        }
    }

    role Styled {
        has Str $.stroke;
        has Str $.fill;

        method styles() {
            ( stroke =&gt; $!stroke, fill =&gt; $!fill ).grep( { .value.defined } );
        }

    }

    has Element @.elements;

    has Int $.width;
    has Int $.height;

    class Group does Element {
        has Element @.elements;
        method serialize( --&gt; Pair ) {
            g =&gt; @!elements.map( -&gt; $e { $e.serialize }).list;
        }
    }

    class Rectangle does Element does Styled {
        has Int $.x;
        has Int $.y;
        has Int $.width;
        has Int $.height;

        method serialize( --&gt; Pair) {
            rect =&gt; [x =&gt;  $!x, y =&gt; $!y, width =&gt; $!width, height =&gt; $!height, |self.styles ];
        }
    }

    class Point {
        has Numeric $.x;
        has Numeric $.y;

        method Str( --&gt; Str ) {
            ($!x, $!y).join: &#39;,&#39;;
        }
    }

    class Polygon does Element does Styled {

        has Point @.points;

        method serialize( --&gt; Pair ) {
            polygon =&gt; [ points =&gt; @.points.join(&#39; &#39;), |self.styles ];
        }

    }

    class Triangle is Polygon {
        has Point $.apex is required;
        has Int   $.side is required;

        method points() {
            ($!apex, |self.base-points);
        }

        method base-points() {
            my $y = $!apex.y + self.get-height;

            (Point.new(:$y, x =&gt; $!apex.x - ( $!side / 2 )), Point.new(:$y, x =&gt; $!apex.x + ( $!side / 2 )));
        }

        method get-height(--&gt; Num ) {
            sqrt($!side**2 - ($!side/2)**2)
        }

    }

    method dimensions() {
        ( height =&gt; $!height, width =&gt; $!width ).grep( { .value.defined } );

    }

    method serialize( --&gt; Str ) {
        SVG.serialize(svg =&gt;  [ |self.dimensions, |@!elements.map(-&gt; $e { $e.serialize })]);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这需要在其他地方进行一些小的改动。在`Int`作为三角形的顶点的计算结果可能不是整数（或我们会风了一个靠不住的三角形，如果我们roumded他们）还点的属性是放宽到数字`serialize`多边形的方法是改变使用访问器方法`points`而不是直接使用属性，因此可以在我们的Triangle类中过度使用以计算三角形基线的附加点。</p>
</div>
<div class="paragraph">
<p>计算本身只使用一些初级几何来确定基线到顶点的高度，使用毕达哥拉斯定理得到两个基线点的y坐标，x坐标是两侧边长的一半。顶点x坐标。</p>
</div>
<div class="paragraph">
<p>此外，当我测试这个时，我注意到我之前没有实现高度和宽度属性的序列化，我们已经离开它，因为矩形没有超出默认绘图区域，但是三角形做了，因此没有显示。</p>
</div>
<div class="paragraph">
<p>无论如何，现在我们可以用最少的代码绘制一个三角形：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use SVG::Drawing;

my SVG::Drawing $drawing = SVG::Drawing.new(
    elements =&gt; [
        SVG::Drawing::Group.new(elements =&gt; [
            SVG::Drawing::Triangle.new(stroke =&gt; &#34;black&#34;, fill =&gt; &#34;green&#34;,
                apex =&gt; SVG::Drawing::Point.new(x =&gt; 100, y =&gt; 50),
                side =&gt; 50,
            )
        ])
    ],
    height  =&gt; 300,
    width   =&gt; 200
);

say $drawing.serialize;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将在足够大的空间中提供一个漂亮的绿色等边三角形来绘制我们的树。</p>
</div>
</div>
<div class="sect2">
<h3 id="_最后是我们的树">44.6. 最后是我们的树</h3>
<div class="paragraph">
<p>现在我们有了创建简单树的组成部分的方法，因此我们可以将它们与一个相对简单的脚本放在一起：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use SVG::Drawing;

my SVG::Drawing $drawing = SVG::Drawing.new(
    elements =&gt; [
        SVG::Drawing::Group.new(elements =&gt; [
            SVG::Drawing::Triangle.new(stroke =&gt; &#34;green&#34;, fill =&gt; &#34;green&#34;,
                apex =&gt; SVG::Drawing::Point.new(x =&gt; 100, y =&gt; 50),
                side =&gt; 50,
            ),
            SVG::Drawing::Triangle.new(stroke =&gt; &#34;green&#34;, fill =&gt; &#34;green&#34;,
                apex =&gt; SVG::Drawing::Point.new(x =&gt; 100, y =&gt; 75),
                side =&gt; 75,
            ),
            SVG::Drawing::Triangle.new(stroke =&gt; &#34;green&#34;, fill =&gt; &#34;green&#34;,
                apex =&gt; SVG::Drawing::Point.new(x =&gt; 100, y =&gt; 100),
                side =&gt; 100,
            ),
            SVG::Drawing::Rectangle.new(stroke  =&gt; &#34;brown&#34;,
                                        fill    =&gt; &#34;brown&#34;,
                                        x       =&gt;  90,
                                        y       =&gt; 185,
                                        width   =&gt; 20,
                                        height  =&gt; 40),
        ])
    ],
    height  =&gt; 300,
    width   =&gt; 200
);

say $drawing.serialize;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我通过反复试验选择了形状的大小和位置，它可能更科学地完成。</p>
</div>
<div class="paragraph">
<p>无论如何，这会产生这样的XML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34;
     xmlns:svg=&#34;http://www.w3.org/2000/svg&#34;
     xmlns:xlink=&#34;http://www.w3.org/1999/xlink&#34;
     height=&#34;300&#34;
     width=&#34;200&#34;&gt;
	&lt;g&gt;
		&lt;polygon points=&#34;100,50 75,93.30127018922192 125,93.30127018922192&#34; stroke=&#34;green&#34; fill=&#34;green&#34; /&gt;
		&lt;polygon points=&#34;100,75 62.5,139.9519052838329 137.5,139.9519052838329&#34; stroke=&#34;green&#34; fill=&#34;green&#34; /&gt;
		&lt;polygon points=&#34;100,100 50,186.60254037844385 150,186.60254037844385&#34; stroke=&#34;green&#34; fill=&#34;green&#34; /&gt;
		&lt;rect x=&#34;90&#34; y=&#34;185&#34; width=&#34;20&#34; height=&#34;40&#34; stroke=&#34;brown&#34; fill=&#34;brown&#34; /&gt;
	&lt;/g&gt;
&lt;/svg&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个合理的程式化圣诞树，用户代码最少。</p>
</div>
<div class="paragraph">
<p>由于我们设计模块的方式，我们已经把自己放在一个好的地方进一步扩展它，比如说，一个Circle类可以用来轻松地为我们的树添加彩色小玩意。</p>
</div>
<div class="paragraph">
<p>SVG是一个非常丰富的规范，具有大量基元，可满足大多数绘图需求，我们只实现了绘制树所需的最小值，但这可以扩展为支持您想要的任何类型的绘图。</p>
</div>
<div class="paragraph">
<p><a href="https://rakuadvent.files.wordpress.com/2018/12/tree.png?w=788">树</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十九天_交互式桌面应用">45. 第十九天 - 交互式桌面应用</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我是地下城与龙等角色扮演游戏的忠实粉丝。这些游戏中的大多数都有屏幕来帮助你隐藏你在运行游戏时所做的事情，并为你提供游戏中使用的一些图表，以减少书中的内容。</p>
</div>
<div class="paragraph">
<p>我的游戏收藏很广泛而且我宁愿使用我的笔记本电脑不仅隐藏在后面并跟踪信息，而且我还可以自动化骰子和图表使用。虽然我可以用文本编辑器和命令行魔法拼凑一些东西，但我宁愿拥有一些时髦的桌面应用程序，我可以向人们展示。</p>
</div>
<div class="paragraph">
<p>输入<a href="https://github.com/raku/gtk-simple">GTK::Simple</a>是Linux Gnome桌面使用的gtk3 UI库的包装器，但也可以在Windows和Mac上使用。该库通过Native Call 的强大功能为你提供了一个简单易用的界面，让你可以创建简单的桌面应用程序。</p>
</div>
<div class="sect2">
<h3 id="_骰子滚动">45.1. 骰子滚动</h3>
<div class="paragraph">
<p>由于历史原因，角色扮演游戏大多数倾向于选择使用基于柏拉图固体的骰子。骰子的标准组合是4,6,8,10,12,20，并且通过组合2个10面骰子100的骰子。骰子可以多次滚动，用于写入的标准符号是“ x<strong>d</strong>y ”，其中 “<strong>x</strong>“ 是掷骰子的数量，”<strong>y</strong>“ 是掷骰子的大小。单个骰子在开始时跳过1，例如“roll a d6”意味着掷出六面骰子。</p>
</div>
<div class="paragraph">
<p>有趣的是，在 Raku 中制作 “<strong>d</strong>” 运算符非常简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix: ( UInt $count, UInt $size ) { (1..$size).roll($count) }
sub prefix: ( UInt $size ) { 1 d $size }</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，你需要将数字与空格分开，并且 “<strong>d</strong>” 运算符或编译器会混淆。</p>
</div>
<div class="paragraph">
<p>我想要的是一个骰子滚轮应用程序，它提供了选择滚动标准骰子组的选项。现在我不会看到一些游戏使用的不同骰子，或者修改滚动，很多游戏都使用这些骰子。我想看看每个掷骰子，因为这可能很重要，具体取决于系统。如果可能的话，我也想要总数。</p>
</div>
</div>
<div class="sect2">
<h3 id="_简单的_gtksimple">45.2. 简单的 GTK::Simple</h3>
<div class="paragraph">
<p>GTK::Simple 的基本用法很简单。创建一个应用程序，添加内容，放入一些事件处理程序，然后离开。</p>
</div>
<div class="paragraph">
<p>首先，我们创建我们的应用程序，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Get the GTK::Simple libraries
use GTK::Simple;
use GTK::Simple::App;

# Create the main app
my $app = GTK::Simple::App.new( title =&gt; &#34;Dice Roller&#34; );

# Start the app running
$app.run;</code></pre>
</div>
</div>
<div class="paragraph">
<p>但…。这不是很有趣：</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/empty.png?w=788">空</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_网格布局">45.3. 网格布局</h3>
<div class="paragraph">
<p>要在应用程序中布局小部件，我们有各种选项，但建议使用的是网格。网格布局从左上角的0,0开始并根据需要延伸的小部件。</p>
</div>
<div class="paragraph">
<p>正是在这一点上，我尝试构建一个应用程序，我打了一个墙。网格选项很好，我在下面的最后一个例子中使用它但是当我尝试的时候它没有按照我的预期工作。我仍然可以得到一个简单的网格，所以显示它的工作，但似乎需要更多的学习。无论如何这里是一个基本网格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Get the GTK::Simple libraries
use GTK::Simple;
use GTK::Simple::App;

# Create the main app
my $app = GTK::Simple::App.new( title =&gt; &#34;Grid&#34; );

$app.set-content(
    GTK::Simple::Grid.new(
        # Grid key is [x,y,height,width]
        [0,0,1,1] =&gt; GTK::Simple::Button.new( label =&gt; &#34;a&#34; ),
        # A Button is a simple push button with a label
        [0,1,1,1] =&gt; GTK::Simple::Button.new( label =&gt; &#34;b&#34; ),
        [0,2,1,1] =&gt; GTK::Simple::Button.new( label =&gt; &#34;c&#34; ),
        [1,0,1,3] =&gt; GTK::Simple::Button.new( label =&gt; &#34;d&#34; ),
    )
);

$app.border-width = 10;
# Start the app
$app.run;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个产生：</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/grid-1.png?w=788">格</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_交互">45.4. 交互</h3>
<div class="paragraph">
<p>这很整洁，但按钮还没有做任何事情。为此，我们需要事件处理程序。GUI应用程序需要事件驱动才能对用户操作做出反应，幸运的是 Raku 具有处理 Supplies 形式的事件的功能。每个按钮都有一个名为 clicked 的 supply，它可以附加一个 tap 处理程序。</p>
</div>
<div class="paragraph">
<p>事件处理程序可以执行各种操作，包括操作其他UI对象。例如 ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Get the GTK::Simple libraries
use GTK::Simple;
use GTK::Simple::App;

# Create the main app
my $app = GTK::Simple::App.new( title =&gt; &#34;Grid&#34; );

$app.set-content(
    GTK::Simple::Grid.new(
        # As we want to refer to our buttons later we assign them
        # to variables
        [0,0,1,1] =&gt; my $b1 = GTK::Simple::Button.new( label =&gt; &#34;Push Me&#34; ),
        [1,1,1,1] =&gt; my $b2 = GTK::Simple::Button.new( label =&gt; &#34;---&#34; ),
        [2,2,1,1] =&gt; my $b3 = GTK::Simple::Button.new( label =&gt; &#34;---&#34; ),
        [3,3,1,1] =&gt; my $b4 = GTK::Simple::Button.new( label =&gt; &#34;---&#34; ),
    )
);

# The sensitive flag controls whether you can click on the button
$b2.sensitive = False;
$b3.sensitive = False;
$b4.sensitive = False;

# In the
$b1.clicked.tap( {
    # $_ is the clicked button. Turn it off
    .sensitive = False;
    # Change the label on the next button
    $b2.label = &#34;Now Me!&#34;;
    # Make it clickable
    $b2.sensitive = True
} );

# Leaving on one line to cut down on space
$b2.clicked.tap( { .sensitive = False; $b3.label = &#34;Me Next&#34;; $b3.sensitive = True } );
$b3.clicked.tap( { .sensitive = False; $b4.label = &#34;Me! Me!&#34;; $b4.sensitive = True } );
# App.exit closes the app.
$b4.clicked.tap( { $app.exit } );

$app.border-width = 10;
# Start the app
$app.run;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这使得：</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/buttons.png?w=788">纽扣</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_把它们放在一起">45.5. 把它们放在一起</h3>
<div class="paragraph">
<p>有了这个和另一个小部件，Label 给了我们一些文本，我们可以把骰子滚动应用程序放在一起：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Get the GTK::Simple libraries
use GTK::Simple;
use GTK::Simple::App;

# Define our `d` operator
sub infix: ( UInt $count, UInt $size ) { (1..$size).roll($count) }

# Create the main app
my $app = GTK::Simple::App.new( title =&gt; &#34;Dice Roller&#34; );

# Output Box : Define here so the buttons can access it.
my $output = GTK::Simple::Label.new( text =&gt; &#39;Roll : &#39;);

# Ouput box updater.
sub roll( $label, $count, $size ) {
    my @roll = $count d $size;
    $label.text = &#34;Roll : {@roll.join(&#34; + &#34;)} = {@roll.sum}&#34;;
}

# Create a grid and put the output box at the bottom filling the width
my @grid = ( [0,6,7,1] =&gt; $output );

# Track our depth in tthe grid
my $y = 0;

# Loop through counts
for (1..6) -&gt; $count {

    # Track our postion along the grid
    my $x = 0;

    # Loop through standard dice sizes
    for (4,6,8,10,12,20,100) -&gt; $size {

	# Standard labelling
	my $label = $count &gt; 1 ?? &#34;{$count}d{$size}&#34; !! &#34;d{$size}&#34;;

	# Create our button
	my $button = GTK::Simple::Button.new(label =&gt; $label);

	# Buttons get a supply which emit when they are clicked
	# Assign our roll function with the current count and size to it
	# Note we do it in a block so it&#39;s not called right now but when
	# the button is clicked
	$button.clicked.tap(
	    { roll( $output, $count, $size ) }
	);

	# Put the button in the valid place in the grid taking up one space
	@grid.push( [$x,$y,1,1] =&gt; $button );

	$x++;
    }
    $y++
}

# Create a grid object and assign it to the app.
$app.set-content(
    GTK::Simple::Grid.new( |@grid )
);

$app.border-width = 10;

# Start the app running
$app.run;</code></pre>
</div>
</div>
<div class="paragraph">
<p>看起来像（这里滚动3d6）：</p>
</div>
<div class="paragraph">
<p>!<a href="https://rakuadvent.files.wordpress.com/2018/12/dice-roller.png?w=788">骰子辊</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_最后的想法">45.6. 最后的想法</h3>
<div class="paragraph">
<p>考虑到我今天早上没有触及 GTK::Simple，我对我的最终结果非常满意。我认为我可以构建许多其他游戏工具。此外，我可能会参与模块本身的工作，尝试将更多的GTK功能添加到其中，并添加一些文档。</p>
</div>
<div class="paragraph">
<p>尽管如此，使用 GTK::Simple 还是很容易使桌面应用程序在Raku中遇到特殊的问题，而且代码并不多。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十天_raku_中的命题组合">46. 第二十天 - Raku 中的命题组合</h2>
<div class="sectionbody">
<div class="paragraph">
<p>来临是一个激动人心的时刻，是一个期待的时刻。不仅对我们人类而言 - 正是精灵变得最具创造力的时候。今天，我想在圣诞节压力下休闲一些时间来报道礼品包装领域正在开展的一些开创性工作。即使你没有预料到任何消息，这份报告仍然可以帮助你改进你的技术，因为 - 我不必提醒你 - 圣诞节快到了。</p>
</div>
<div class="paragraph">
<p>你知道哪个小孩子最喜欢吗？大礼物。因此，Northpole的现有扩大研究实验室的任务是寻找实用的方法来扩大礼物。现在，“大”可能意味着多种事物。我承认，第6单元弯曲的意思了一点，但他们的工作是迄今为止最有趣的：他们增加了<strong>音量</strong>的礼物，通过增加的礼品盒的尺寸。</p>
</div>
<div class="paragraph">
<p>“你如何包装6维礼物？”是管理层提出的有效问题。就好像天才击中了UX精灵的回应：«只需将它包裹起来，从每个三维视角看起来都像是一个正常的礼物»（他们实际上从<a href="https://gaussoids.de/">高斯</a>中学到了一个技巧，但谁也不想被视为天才偶尔？）。管理层感到满意，资金安全，数学精灵喜欢UX精灵提出的复杂性降低 - 只是制造技术还没有到那里生产那些高维盒子。因此他们决定在Raku中进行编程，因为在等待技术赶上100年语言时，最好使用什么？</p>
</div>
<div class="paragraph">
<p>“让我们开始工作，”他们说，并且他们得到了工作。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_你如何以数学方式包装礼物">47. 你如何以数学方式包装礼物？</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我在实验室逗留期间真正带回家的是，只有很多社会可接受或物理上可能的方式来包装礼物。首先，你需要一个礼物，然后一个盒子。你必须把礼品包装在盒子周围。这些步骤非常自然，精灵认为这是理所当然的。对于他们来说，“礼物”是礼品包装盒内的礼物。“包装”的挑战，以及将包装工与艺术大师分开的关键点，就是<strong>丝带</strong>和<strong>蝴蝶结</strong>发挥作用。你认为这应该够容易吗？好吧，再想一想！</p>
</div>
<div class="sect2">
<h3 id="_一个立方体卡罗尔">47.1. 一个立方体卡罗尔</h3>
<div class="paragraph">
<p>此设置中的礼物由<a href="https://en.wikipedia.org/wiki/Hypercube">n维立方体</a>建模，或简称为“n立方体”。n-cube是一个非常好的东西，因为它的所有面都是较小尺寸的立方体。计算机科学家喜欢它，因为它的顶点实际上只是长度为n 的`0`s和`1`s的串。在这里，我们关心n立方体的二维面或“正方形”。通常的三维立方体有六个正方形，正如你从骰子中所知道的那样。</p>
</div>
<div class="paragraph">
<p>精灵采取的方法将这些方块视为变量并分配给它们</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>没有</strong>如果的礼品盒，这部分上有唯一的礼品包装，因为我们同意需要，</p>
</li>
<li>
<p><strong>色带</strong>，如果有两端礼品丝带运行，或</p>
</li>
<li>
<p><strong>弓</strong>如果在立方体的这一侧弓或循环。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>是时候看一些代码了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#|« A square on the n-cube with wrapping.
In the n-cube there are 3*(n choose 2)*2**(n-2) WrapSquare variables,
one for every square and every kind of value that can be assigned to it.
»
class WrapSquare is Cube::Face does Propositional::Variable {
    has $.kind is required;

    method WHICH {
        ValueObjAt.new: &#34;WrapSquare|$!kind|{callsame}&#34;
    }

    # ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此片段告诉您这`WrapSquare`是多维数据集的一个面，其中`Cube::Face`该类实现了我们期望从多维数据集表面执行的大部分功能。它也是一种变量，并且具有一个`$.kind`属性，该属性将保存字符串`□<code>，</code>■<code>或者</code>!<a href="https://s0.wp.com/wp-content/mu-plugins/wpcom-smileys/twemoji/2/svg/1f380.svg">🎀</a>`，取决于为该正方形分配了哪个值（<strong>没有</strong>，<strong>功能区</strong>或<strong>弓形</strong>）。</p>
</div>
<div class="paragraph">
<p>有一些整洁的运算符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi prefix: (Str $s) {
    WrapSquare.new: :kind&lt;□&gt;,
        Cube::Face.from-word($s)
}

multi prefix: (Str $s) {
    WrapSquare.new: :kind&lt;■&gt;,
        Cube::Face.from-word($s)
}

multi prefix: (Str $s) {
    WrapSquare.new: :kind&lt;🎀&gt;,
        Cube::Face.from-word($s)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这让你 <code>WrapSquare</code> 通过写作来制作 ■&lt;0**010&gt;。该字符串 0**010 指定6维立方体中的正方形：让其中的 <code>*</code>  符号为通配符，它们在 <code>0</code> 和 <code>1</code> 之间变化。然后你得到四个二进制字符串 <code>000010</code>，<code>001010</code>，<code>010010</code> 和 <code>011010</code>。回想一下，长度为n（这里n = 6）的二进制字符串是n-cube的顶点，这四个碰巧绑定了它的二维面。这些 <code>WrapSquare</code> 文字将在以后全部出现。</p>
</div>
<div class="paragraph">
<p>经过所有这些解释后 <code>WrapSquare</code>，我几乎可以听到你心中想要满足的痒：“为什么会这样 <code>WrapSquare</code> <code>Variable</code> <code>Propositional</code>？”</p>
</div>
</div>
<div class="sect2">
<h3 id="_sat_a_clause的令人满意的故事">47.2. SAT-a-Clause的令人满意的故事</h3>
<div class="paragraph">
<p>回想一下UX精灵的建议是：«只需将其包裹起来，从每个三维视角看起来都像一个正常的礼物»。虽然这听起来非常简单，但它会产生一个非常复杂的问题。</p>
</div>
<div class="paragraph">
<p>“有多少种方式来包装n维礼物？”可能是精灵们问自己的第一个问题。UX精灵要我们做的是选择一个合适的三维包装，其中精灵已经是专家，对于n立方体表面上的每个三维立方体，<strong>但是</strong>所有这些三维包装都适合在高维立方体。n立方体有½n⋅（n-1）⋅2ⁿ-2平方但是通过选择3d包裹，你可以选择½n⋅（n-1）⋅（n-2）⋅2ⁿ-2平方，这是（n -2）你有变量的选择次数。原因是3立方体在n立方体中彼此共享正方形，就像在3维中一样，骰子的侧面具有共同的立方体边缘。</p>
</div>
<div class="paragraph">
<p>UX精灵创建的问题是为n-cube上的3-cube选择3d包装，只要它们具有公共方形，它们就彼此兼容。但这真的有多糟糕？在尺寸4中，您有24个正方形，因此3²= 282,429,536,481种选择包装的方式。如果您是随机进行的，那么您找到UX认可包装的机会甚至不是0.0000007％。正如我们将要看到的那样，正好有1848个正确的包装。</p>
</div>
<div class="paragraph">
<p>“我们怎么可能探索这样一个巨大的空间？” - 精灵们感到震惊。直到他们发现SAT求解器。`SAT`指的是<a href="https://en.wikipedia.org/wiki/Propositional_calculus">命题</a> <a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">满足性问题</a>，决定使用布尔变量和运算的公式是否具有使公式成立的赋值，“满足”它的任务。</p>
</div>
<div class="paragraph">
<p>事实证明，礼品包装可以变成这种可满足性问题的一个例子。为简单起见，精灵决定为n-cube的每个方块分配三个布尔变量。他们主张这个广场是否装饰有□，■或🎀。这些变量中的一个必须是真的。然后，他们编码要求，每个3立方体必须包含一个适当的3d包装，并且所选择的包装在n立方体中兼容为命题公式。他们把这个公式的成分称为*giftoid公理* - 包装高维礼品的规则。</p>
</div>
<div class="paragraph">
<p>有些求解器比找到一个令人满意的任务更进一步（或确定找不到一个任务的不可能性）：他们可以返回这些任务的确切数量，甚至可以列出所有这些任务。正是精灵需要的东西，幸运的是，Raku可以使用命题演算和SAT求解器。</p>
</div>
<div class="paragraph">
<p>SAT求解器的输入是<a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form">Conjunctive Normal Form中</a>的布尔公式。该`Propositional`模块有一个特别好的实现，虽然我可能有偏见：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method NNF {
    self.rewrite(
        (  ^:p ⇔ ^:q ) =&gt; { ($:p ⇒  $:q) ∧ ($:q ⇒ $:p) },
        (  ^:p ⇒ ^:q ) =&gt; { ¬$:p ∨  $:q },
        (¬(^:p ∨ ^:q)) =&gt; { ¬$:p ∧ ¬$:q },
        (¬(^:p ∧ ^:q)) =&gt; { ¬$:p ∨ ¬$:q },
        (¬¬^:p)        =&gt; {  $:p        },
    )
    andthen .squish
}

method CNF {
    self.NNF.rewrite(
        (^:p ∨ (^:q ∧ ^:r)) =&gt; { ($:p ∨ $:q) ∧ ($:p ∨ $:r) },
        ((^:q ∧ ^:r) ∨ ^:p) =&gt; { ($:p ∨ $:q) ∧ ($:p ∨ $:r) },
    )
    andthen .squish
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该`CNF`方法首先将公式转换为中间形式，称为<a href="https://en.wikipedia.org/wiki/Negation_normal_form">否定范式</a>，然后将其转换为CNF。这两种方法都使用模块的中心齿轮之一，该`rewrite`方法。顾名思义，它重写了一个基于规则的公式，这些规则作为成对给出，例如`(^:p ⇔ ^:q ) ⇒ { ($:p ⇒ $:q) ∧ ($:q ⇒ $:p) }`。关键是一个公式对象，这里只是`⇔<code>两个变量的等价，</code><sup>:p`并且`</sup>:q`在整个公式内是模式匹配的。“限量印记”，在变量前面表明上的两侧发现子式`⇔<code>操作应当<strong>帽</strong>捕获的原始内部<a href="https://docs.raku.org/language/variables#index-entry-%24%3A">命名参数</a> `p`和`q`它们被传递到对fatarrow右侧的代码块，以确定</code>⇔<code>表达式的替换是什么。在这种情况下，等价被两个含义所取代 - 这个重写规则实现了定义</code>⇔<code>。上面的下一条规则实现了</code>⇒`。的定义。实际上，如果你想要一个NNF，必须消除这两个符号。</p>
</div>
<div class="paragraph">
<p>重写引擎执行所有列出的重写，直到找不到更多匹配项。现在，逻辑学家会告诉你，如果你这样做，你会将任何命题公式变成CNF。这应该足够内部。让我们公理化礼物吧！</p>
</div>
</div>
<div class="sect2">
<h3 id="_比你想知道的3d礼品包装更多">47.3. 比你想知道的3D礼品包装更多</h3>
<div class="paragraph">
<p>看到所有的高级成分落到实处，每个人都兴奋不已，我不得不停下来问：«基本情况怎么样？你如何包装3D礼物？»。问这个精灵和他们的眼睛开始发光。这是他们的第二天性，甚至是研究精灵。这些是每个精灵在学校学到的规则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>只是包装：</strong>没有丝带或蝴蝶结的礼物是好的，但永远不要忘记礼品包装，</p>
</li>
<li>
<p><strong>胶合弓：</strong>它可以有一个单面粘在一边，没有色带，</p>
</li>
<li>
<p><strong>色带：</strong>如果你使用色带，你必须把它包在盒子周围的“腰带”上，</p>
</li>
<li>
<p><strong>蝴蝶结腰带：</strong>你可以将蝴蝶结融入蝴蝶结腰带，</p>
</li>
<li>
<p><strong>一个弓：</strong>你可能只使用一个弓或没有，</p>
</li>
<li>
<p><strong>消歧：</strong>如果所有方面都有缎带，就必须有弓。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最后一个公理与其他公理不同。它不是小学包装表的一部分，后来被致力于高维包装的精灵们发现。（也许有一天会进入课程？）在谈论色带时，“立方体的方块”公式是一种简化，因为有两种方法可以将色带垂直或水平地包裹在立方体的给定方格中。在只有一条皮带的情况下，带状皮带公制用于定义色带的方向。类似地，实际上有三种方法可以围绕立方体包裹色带，这样所有方法都会导致每个边都被色带触摸，即每种方式都可以从三个方向中挑选出两个带。因此，立方体的这种“包裹”是模糊的，必须禁止。</p>
</div>
<div class="paragraph">
<p>该`Propositional`包可以采取不将任何对象`Propositional::Variable`作为式中的变量的作用。如上所示，通常的逻辑连接符被重载，因此您可以在Raku程序中编写公式，就像在纸上一样。仅要求变量角色是一个重要的设计决策，并具有一些巧妙的含义。例如，重写捕获`^:p`我们之前看到的，也是`Propositional::Variable`在智能匹配时特别表现的对象。</p>
</div>
<div class="paragraph">
<p>在精灵的情况下，`Variable`是`WrapSquare`类和允许任意对象作为变量的另一个优点显示自己：任意变量可以有任意方法或操作符作用于它们。精灵用它来完成另一个*复杂性的减少*。他们只需要对3立方体的<strong>一个角</strong>进行公理化，然后使用3立方体的<a href="https://en.wikipedia.org/wiki/Hyperoctahedral_group">对称组进行处理</a>。这个群体动作将公理化的角落移动到立方体的<strong>每个</strong>角落，因此连接该动作的轨道给出了3d礼品包装的完全公理化。现在我们同意这听起来很棒，让我们看看它是如何在Raku中完成的。（*注意：*公理化涉及<a href="https://en.wikipedia.org/wiki/Logical_connective">逻辑连接词</a>你可能想要熟悉并遵循上面人类可读的公理。）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">multi axioms ($n = 3) {
    my \φ = .CNF with [∧] gather {
        take □&lt;**0&gt; ∨ ■&lt;**0&gt; ∨ 🎀&lt;**0&gt;;
        take □&lt;**0&gt; ⇒ ¬(■&lt;**0&gt; ∨ 🎀&lt;**0&gt;);
        take ■&lt;**0&gt; ⇒ ¬(□&lt;**0&gt; ∨ 🎀&lt;**0&gt;);
        take 🎀&lt;**0&gt; ⇒ ¬(□&lt;**0&gt; ∨ ■&lt;**0&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们选择二维面`<strong>0`作为公理化的特定角落。有三个关联布尔变量，即`□&lt;</strong>0&gt;`，<code>■&lt;<strong>0&gt;`和</strong></code><strong>!<a href="https://s0.wp.com/wp-content/mu-plugins/wpcom-smileys/twemoji/2/svg/1f380.svg">🎀</a>&lt;</strong>0&gt;`（方便，他们也可以被称为是在Raku的代码，这要归功于我们的`WrapSquare`构造函数运算符）。要具有明确定义的包装，必须至少设置这三个变量中的一个。</p>
</div>
<div class="paragraph">
<p>公理说必须设置三个变量*中的至少*一个。下一个公理规则如果碰巧是活跃的（意味着广场上只有礼品包装），那么（）它也不能（）是真的，或者（）也被设置。任何令人满意的任务，即SAT求解器将为我们找到的最终公式将实现这个公理，因为我们采取了一个大的AND超过块。</p>
</div>
<div class="paragraph">
<p>您被邀请将其他公式追溯到包装表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">        take ■&lt;**0&gt; ⇒ (■&lt;**1&gt; ∨ 🎀&lt;**1&gt;);
        take (■&lt;**0&gt; ∧ ■&lt;**1&gt;) ⇒ (■&lt;*0*&gt; ∨ 🎀&lt;*0*&gt; ∨ ■&lt;0**&gt; ∨ 🎀&lt;0**&gt;);
        take (🎀&lt;**0&gt; ∧ ■&lt;**1&gt;) ⇒ (■&lt;*0*&gt; ∨ ■&lt;0**&gt;);
        take (🎀&lt;**0&gt; ∧ (■&lt;*0*&gt; ∨ ■&lt;0**&gt;)) ⇒ ■&lt;**1&gt;;
        take 🎀&lt;**0&gt; ⇒ ¬(🎀&lt;**1&gt; ∨ 🎀&lt;*0*&gt; ∨ 🎀&lt;*1*&gt; ∨ 🎀&lt;0**&gt; ∨ 🎀&lt;1**&gt;);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们对3立方体的一个角进行了公理化，我们采用了超八面体组。这可以通过所谓的二元性的组合来实现，该二元性是`&amp;postfix:&lt;°&gt;`操作者实现的`Cube::Face`，并且`&amp;infix:&lt;⤩&gt;`操作者存在的立方体的轴的排列。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    my \ψ = φ.rewrite(:1ce,
        (^:s(WrapSquare)) =&gt; { $:s° }
    );
    return [∧] gather for (1,2,3).permutations -&gt; \π {
        take (φ ∧ ψ).rewrite(:1ce,
            (^:s(WrapSquare)) =&gt; { $:s ⤩ π }
        );</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个`rewrite`方法再次闪耀在这里。捕获变量可以使用smartmatcher进行约束，例如类型`WrapSquare`。它们只匹配并捕获匹配约束的内容。因此，上述重写规则仅对公式中的变量起作用，并且它们只执行它`:1ce`- 因为否则重写引擎会一遍又一遍地重写相同的变量，因为它们在每次迭代中都会重新匹配。</p>
</div>
<div class="paragraph">
<p>你注意到了什么吗？看起来精灵们忘记了消歧公理。但是 - 它没有被遗忘。它已经是对称的，不必参与上面的对称化过程。如果确实如此，就会不必要地重复。它来了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">        LAST take ¬(■&lt;**0&gt; ∧ ■&lt;**1&gt; ∧ ■&lt;*0*&gt; ∧ ■&lt;*1*&gt; ∧ ■&lt;0**&gt; ∧ ■&lt;1**&gt;);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，三维礼品包装公理是完整的。精灵们兴高采烈地跳舞。</p>
</div>
</div>
</div>
</div>
<h1 id="_把它包起来_2" class="sect0">把它包起来</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>让我们总结一下。为了包装更高维度的礼物，我们将三维礼物包裹起来并将包装拼凑在一起。为了使三维包裹物公理化，在其一个角落周围进行公理化并转动立方体并重复该过程就足够了，因此立方体的每个角落都是一个公理化的角落。这给出了描述所有正确包装的布尔公式。</p>
</div>
<div class="paragraph">
<p>但是，嘿，我们还没完成！giftoids和SAT求解器在哪里？为了使n-giftoids公理化，上面构造的3立方公理化必须在n立方体的每个3面复制。另一个`Cube::Face`操作员出现在这里，再次出现在`rewrite`。它将一个正方形嵌入到n立方体的三个面中，正如我们所需要的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi axioms ($n where * &gt; 3) {
    my \Φ = axioms;
    [∧] gather for Faces($n, 3) -&gt; \Δ {
        take Φ.rewrite(:1ce,
            (^:s(WrapSquare)) =&gt; { $:s ↗ Δ }
        )
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用SAT工具`Propositional`，我们现在可以获得3-4G和5-Giftoids的实数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say count-sat Giftoid::axioms(3), :now
#= OUTPUT: 28
say count-sat(Giftoid::axioms(3), :now)
#= OUTPUT: 1848
say  count-sat(Giftoid::axioms(3), :now)
#= OUTPUT: 58213276</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了感受SAT求解者所做的惊人工作，考虑到它`28`在729种可能性中找到了3-giftoids 的数量，`1848`在282429536481种可能性中找到了4-giftoids的数量，以及可能`58213276`总共为147808829414345923316083210206383297601可能性的5-giftoids。</p>
</div>
<div class="paragraph">
<p>当你自己尝试上面的代码示例时，你应该知道的是SAT求解器，特别是计数器，是非常需要内存的。5-giftoid计数需要5:14处理器分钟，笔记本电脑上有4 GiB RAM，不是没有交换，但它可以在笔记本电脑上完成！大多数求解器允许限制时间和内存使用，但Raku模块中尚未实现求解器配置。</p>
</div>
<div class="paragraph">
<p>绝对可行的是获得一个3-giftoids列表，其中3-cube的所有六个方块的赋值按特定顺序列出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">.put for all-sat(Giftoid::axioms).map({ Giftoid.new: n =&gt; 3, deco =&gt; $_ })
#=« OUTPUT:
■■■🎀■■
□□■🎀■■
■■■■🎀■
■■■■■🎀
■■🎀■■■
■🎀■■■■
□□■■🎀■
□□🎀■■■
□□■■■🎀
□□■■■■
■■□□■🎀
■■□□🎀■
...
»</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者确定固定维度的giftoids中的平均弓箭数，尽管你不会对这些弓箭走得太远：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub mean-bows ($n) {
    my ($sum, $count);
    all-sat(Giftoid::axioms($n)).map({
        $sum += +.keys.grep(*.kind eq &lt;🎀&gt;);
        $count++;
    });
    $sum / $count;
}

say mean-bows(3);
#= OUTPUT: 0.857143
say mean-bows(4);
#= OUTPUT: 2.766234</code></pre>
</div>
</div>
<div class="paragraph">
<p>预算精灵谨慎地提出一个问题：«如果你任意增加giftoids的维度，这是否意味着保持有限？毕竟，弓是最昂贵的…​…​»</p>
</div>
<div class="paragraph">
<p>我会让你在假期里思考这个问题。快乐的包装。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十一天_一个红色的圣诞老人">48. 第二十一天 - 一个红色的圣诞老人</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这一年即将结束，我们有很多值得庆祝的事情！与家人和朋友相比，庆祝今年年底更好的方式是什么？为了帮助实现这一目标，在我家，我们决定开办秘密圣诞老人游戏！所以，我的目标是写一个秘密圣诞老人计划！这就是我可以使用这个名为<a href="https://github.com/FCO/Red">Red的</a>精彩项目的地方。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/FCO/Red">Red</a>是一个仍在开发中的<strong>raku</strong>的*ORM* （对象关系模型），尚未作为模块发布。但它正在增长，而且接近发布。</p>
</div>
<div class="paragraph">
<p>因此，让我们创建我们的第一张桌子：一张桌子，用于存储参与我们的秘密圣诞老人的人。代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Red;

model Person {
   has UInt     $.id        is serial;
   has Str      $.name      is column;
   has Str      $.email     is column{ :nullable };
}

my $*RED-DB = database &#34;SQLite&#34;;

Person.^create-table;

Person.^create: :name&lt;Fernando&gt;,    :email&lt;fco@aco.com&gt;;
Person.^create: :name&lt;Aline&gt;,       :email&lt;aja@aco.com&gt;;
Person.^create: :name&lt;Fernanda&gt;;
Person.^create: :name&lt;Sophia&gt;;

.say for Person.^all.grep(*.email.defined).map: *.name;</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://github.com/FCO/Red">Red</a>将<strong>关系数据库</strong>映射  到<strong>OOP</strong>。每个表都映射到一个  <a href="https://github.com/FCO/Red"><strong>Red</strong></a>类（<strong>模型</strong>），每个表的  <strong>对象*代表*一行</strong>。</p>
</div>
<div class="paragraph">
<p>我们创建*模型的方式*是使用<strong>模型</strong>特殊单词。一个*模型*仅仅是延伸的正常类<strong>红::型号</strong> ，具有<strong>MetamodelX ::红::型号</strong>的对象作为它的  <strong>元类</strong>。 <a href="https://github.com/FCO/Red"><strong>Red</strong></a>不会向您的模型添加任何未明确创建的方法。因此，要与*数据库*进行交互，您应该使用*元类*。</p>
</div>
<div class="paragraph">
<p>但是让我们继续吧。</p>
</div>
<div class="paragraph">
<p>代码创建一个名为  <strong>Person*的新*模型</strong>。此*模型*表示的*表*的名称将与模型名称相同：“Person”。如有必要，您可以使用特征更改表的名称 （例如  <strong>:)</strong>。<code>is table&lt;…​&gt;</code> <code>model Person is table&lt;another_name&gt; {…​}</code></p>
</div>
<div class="paragraph">
<p>该*模型*有3个*属性*：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>$ .name</strong>有一个  <code>is column</code> <strong>特征</strong> ;</p>
</li>
<li>
<p><strong>$ .email</strong>有  <code>is column{ :nullable }</code>;</p>
</li>
<li>
<p>和<strong>$ .id</strong>有一个  <code>is serial</code>。这意味着同样的`is column{ :id, :auto-increment }`。</p>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><a href="https://github.com/FCO/Red"><strong>Red</strong></a>默认 使用*非空*列，因此如果要创建可以为空的列，则应使用 <code>is column{ :nullable }</code>。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>因此*Person*上的所有属性都是*列*。在`is serial`（我指的是  <code>:id</code> 一部分）意味着它是表的主键。</p>
</div>
<div class="paragraph">
<p>之后，它为结果设置*动态变量*（<code>$*RED-DB</code>）<code>database &#34;SQLite&#34;</code>。该<strong>数据库</strong> *子*收到*司机*的名字和它期望的参数。</p>
</div>
<div class="paragraph">
<p>在这种情况下，它使用*SQLite*  驱动程序，如果您不传递任何参数，它将使用它作为  <strong>内存</strong> <strong>数据库</strong>。如果要使用名为*secret-santa.db*  的文件作为数据库文件，则可以执行此操作`database &#34;SQLite&#34;, :database&lt;secret-santa.db&gt;`。或者，如果您想使用本地*Postgres*，只需使用   <code>database &#34;Pg&#34;</code>。 <a href="https://github.com/FCO/Red"><strong>Red</strong></a>  使用变量  <code>$*RED-DB</code> 来知道要使用的数据库。</p>
</div>
<div class="paragraph">
<p>好的，现在让我们创建*表*！正如我之前所说，<a href="https://github.com/FCO/Red"><strong>红</strong></a>没有添加任何*方法*你没有明确要求。因此，要创建*表，<strong>使用*元类</strong> &#39; <strong>方法</strong>。`Person.^create-table`是你如何创建*表*。</p>
</div>
<div class="paragraph">
<p>这将运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">CREATE TABLE person(
    id integer NOT NULL primary key AUTOINCREMENT,
    name varchar(255) NOT NULL,
    email varchar(255) NULL
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们应该插入一些数据。我们用另一个*meta方法*（<code>.^create</code>）来做到这一点。该  <code>.^create</code> <strong>元方法*预期相同*参数</strong> <code>.new</code>  的期望。每个*命名参数*都将设置一个具有相同名称的  <strong>属性</strong>。 <code>.^create`将创建一个新的*Person*对象，将其保存在  <strong>数据库中</strong>（with `.^save: :insert</code>），然后返回它。</p>
</div>
<div class="paragraph">
<p>它运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">INSERT INTO person(
    email,
    name
) VALUES(
    &#39;fco@aco.com&#39;,
    &#39;Fernando&#39;
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个*模型*都有一个*ResultSeq*。这是代表每一个序列*行*的*表*。我们可以 用（或）得到它的*ResultSeq*。<strong>ResultSeq*有一些方法可以帮助您从*表中*获取信息，例如：  将过滤*行</strong>（就像在普通*Seq中一样*），但它不会在内存中执行此操作，它会返回带有该过滤器集的新  <strong>ResultSeq</strong>。检索其*迭代器时*，它使用*ResultSeq*上设置的所有内容运行<strong>SQL</strong>查询  。<code>.<sup>all<code>.</code></sup><code>rs</code>.grep</code></p>
</div>
<div class="paragraph">
<p>在我们的示例中，`Person.^all.grep(*.email.defined).map: *.name`将运行如下查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">SELECT
    person.name
FROM
    person
WHERE
    email IS NOT NULL</code></pre>
</div>
</div>
<div class="paragraph">
<p>它会打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Fernando
Aline</code></pre>
</div>
</div>
<div class="paragraph">
<p>好的，我们有一个代码可以保存谁进入我们的秘密圣诞老人游戏。但每个人都想要不同的礼物。我们怎么知道每个人的意愿？</p>
</div>
<div class="paragraph">
<p>让我们修改代码，使其为参与秘密圣诞老人的每个人保存心愿单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Red;

model Person { ... }

model Wishlist {
    has UInt    $!id        is serial;
    has UInt    $!wisher-id is referencing{ Person.id };
    has Person  $.wisher    is relationship{ .wisher-id };
    has Str:D   $.name      is column is required;
    has Str     $.link      is column;
}

model Person is rw {
   has UInt     $.id        is serial;
   has Str      $.name      is column;
   has Str      $.email     is column;
   has Wishlist @.wishes    is relationship{ .wisher-id }
}

my $*RED-DB = database &#34;SQLite&#34;;

Wishlist.^create-table;
Person.^create-table;

my \fernando = Person.^create: :name&lt;Fernando&gt;, :email&lt;fco@aco.com&gt;;
fernando.wishes.create: :name&lt;Comma&gt;,          :link&lt;https://commaide.com&gt;;
fernando.wishes.create: :name(&#34;raku books&#34;),  :link&lt;https://rakubook.com&gt;;
fernando.wishes.create: :name(&#34;mac book pro&#34;), :link&lt;https://www.apple.com/shop/buy-mac/macbook-pro/15-inch-space-gray-2.6ghz-6-core-512gb#&gt;;

my \aline = Person.^create: :name&lt;Aline&gt;, :email&lt;aja@aco.com&gt;;
aline.wishes.create: :name(&#34;a new closet&#34;), :link&lt;https://i.pinimg.com/474x/02/05/93/020593b34c205792a6a7fd7191333fc6--wardrobe-behind-bed-false-wall-wardrobe.jpg&gt;;

my \fernanda = Person.^create: :name&lt;Fernanda&gt;, :email&lt;faco@aco.com&gt;;
fernanda.wishes.create: :name(&#34;mimikyu plush&#34;), :link&lt;https://www.pokemoncenter.com/mimikyu-poké-plush-%28standard-size%29---10-701-02831&gt;;
fernanda.wishes.create: :name(&#34;camelia plush&#34;), :link&lt;https://farm9.static.flickr.com/8432/28947786492_80056225f3_b.jpg&gt;;

my \sophia = Person.^create: :name&lt;Sophia&gt;, :email&lt;saco@aco.com&gt;;
sophia.wishes.create: :name(&#34;baby alive&#34;), :link&lt;https://www.target.com/p/baby-alive-face-paint-fairy-brunette/-/A-51304817&gt;;

say &#34;\n{ .name }\n{ .wishes.map({&#34; { .name } =&gt; { .link }&#34; }).join(&#34;\n&#34;).indent: 3 }&#34; for Person.^all</code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Fernando
    Comma =&gt; https://commaide.com
    raku books =&gt; https://rakubook.com
    mac book pro =&gt; https://www.apple.com/shop/buy-mac/macbook-pro/15-inch-space-gray-2.6ghz-6-core-512gb#

Aline
    a new closet =&gt; https://i.pinimg.com/474x/02/05/93/020593b34c205792a6a7fd7191333fc6--wardrobe-behind-bed-false-wall-wardrobe.jpg

Fernanda
    mimikyu plush =&gt; https://www.pokemoncenter.com/mimikyu-poké-plush-%28standard-size%29---10-701-02831
    camelia plush =&gt; https://farm9.static.flickr.com/8432/28947786492_80056225f3_b.jpg

Sophia
    baby alive =&gt; https://www.target.com/p/baby-alive-face-paint-fairy-brunette/-/A-51304817</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们有一个新的  <strong>模型</strong> <strong>愿望清单</strong>  ，它引用了一个名为*withlist*的表  。它  <code>$!id</code> 作为  <strong>ID</strong>，  <code>$!name</code> 并  <code>$!link</code> 为列，也有一些新的东西！ <code>has UInt $!wisher-id is referencing{ Person.id };</code> 是一样  <code>has UInt $!wisher-id is column{ :references{ Person.id } };</code> ，这意味着它是一个*列*，这是一个  <strong>外键</strong>  引用  <strong>ID</strong> <strong>的人*的*列</strong>。它也有  <code>has Person $.wisher is relationship{ .wisher-id };</code> 它<strong>不是</strong>一个*列*，这是一个“虚拟”。在  <strong>$</strong>  <strong>印记</strong>  意味着有  <strong>只有1</strong>好心人˚F <strong>或</strong>愿望。并  <code>is relationship</code> 期待一个  <strong>Callable</strong> 这将获得一个  <strong>模型</strong>。如果它是  <strong>标量</strong>  ，它将接收当前  <strong>模型</strong>  作为唯一参数。所以，在这种情况下，它将是  <strong>愿望清单</strong>。该relationsip的回报  <strong>可赎回</strong>  必须是*列*引用其他一些*列*。</p>
</div>
<div class="paragraph">
<p>让我们看看这个表是如何创建的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">CREATE TABLE wishlist(
   id integer NOT NULL primary key,
   name varchar(255) NOT NULL,
   link varchar(255) NULL,
   wisher_id integer NULL references person(id)
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，没有   创建*wisher*列。</p>
</div>
<div class="paragraph">
<p>该  <strong>人</strong> <strong>模式</strong>  也发生了变化！现在它有一个  <code>@.wishes</code> <strong>关系</strong>（<code>has Wishlist @.wishes is relationship{ .wisher-id }</code>）。它使用  <strong>@</strong>  <strong>sigil，</strong>  因此每个  <strong>人</strong> 都可以拥有多个愿望。 传递的  <strong>Callable*将接收*Positional</strong> <strong>属性*的类型   （ 在此情况下为*Wishlist</strong>），并且必须返回引用其他列的列。</p>
</div>
<div class="paragraph">
<p>创建的表与以前相同。</p>
</div>
<div class="paragraph">
<p>我们之前创建了一个新的  <strong>Person</strong>  ：  <code>my \fernando = Person.^create: :name&lt;Fernando&gt;, :email&lt;<a href="mailto:fco@aco.com">fco@aco.com</a>&gt;;</code> 现在我们可以使用*关系*（<strong>愿望</strong>）来创建一个新的愿望（）。这为Fernando运行以下SQL创建了一个新的愿望：<code>fernando.wishes.create: :name&lt;Comma&gt;, :link<a href="https://commaide.com" class="bare">https://commaide.com</a></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">INSERT INTO wishlist(
   name,
   link,
   wisher_id
) VALUES(
   &#39;Comma&#39;,
   &#39;https://commaide.com&#39;,
   1
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>你看过了吗？ <code>wisher_id</code> 是  <strong>1</strong> …​ 1是费尔南多的身份。一旦你创建了Fernando的<strong>.wishes（）</strong>的愿望  ，它已经知道它属于Fernando。</p>
</div>
<div class="paragraph">
<p>然后我们为我们创造的每个人定义愿望。</p>
</div>
<div class="paragraph">
<p>然后我们遍历 数据库中的每个  <strong>Person</strong>（<code>Person.^all</code>）并打印其名称并循环该人的意愿并打印其名称和链接。</p>
</div>
<div class="paragraph">
<p>哦，我们可以拯救谁参与…​…​得到他们想要的东西…​…​但是平局？我应该送谁礼物？为此，我们再次更改程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use lib &lt;lib&gt;;
use Red;

model Person { ... }

model Wishlist {
    has UInt    $!id        is id;
    has UInt    $!wisher-id is referencing{ Person.id };
    has Person  $.wisher    is relationship{ .wisher-id };
    has Str:D   $.name      is column is required;
    has Str     $.link      is column;
}

model Person is rw {
   has UInt     $.id        is id;
   has Str      $.name      is column;
   has Str      $.email     is column;
   has UInt     $!pair-id   is referencing{ ::?CLASS.^alias.id };
   has ::?CLASS $.pair      is relationship{ .pair-id };
   has Wishlist @.wishes    is relationship{ .wisher-id }

   method draw(::?CLASS:U:) {
      my @people = self.^all.pick: *;
      for flat @people.rotor: 2 =&gt; -1 -&gt; $p1, $p2 {
         $p1.pair = $p2;
         $p1.^save;
      }
      given @people.tail {
         .pair = @people.head;
         .^save
      }
   }
}

my $*RED-DB = database &#34;SQLite&#34;;

Wishlist.^create-table;
Person.^create-table;

my \fernando = Person.^create: :name&lt;Fernando&gt;, :email&lt;fco@aco.com&gt;;
fernando.wishes.create: :name&lt;Comma&gt;,            :link&lt;https://commaide.com&gt;;
fernando.wishes.create: :name(&#34;raku books&#34;),    :link&lt;https://rakubook.com&gt;;
fernando.wishes.create: :name(&#34;mac book pro&#34;),   :link&lt;https://www.apple.com/shop/buy-mac/macbook-pro/15-inch-space-gray-2.6ghz-6-core-512gb#&gt;;

my \aline = Person.^create: :name&lt;Aline&gt;, :email&lt;aja@aco.com&gt;;
aline.wishes.create: :name(&#34;a new closet&#34;), :link&lt;https://i.pinimg.com/474x/02/05/93/020593b34c205792a6a7fd7191333fc6--wardrobe-behind-bed-false-wall-wardrobe.jpg&gt;;

my \fernanda = Person.^create: :name&lt;Fernanda&gt;, :email&lt;faco@aco.com&gt;;
fernanda.wishes.create: :name(&#34;mimikyu plush&#34;), :link&lt;https://www.pokemoncenter.com/mimikyu-poké-plush-%28standard-size%29---10-701-02831&gt;;
fernanda.wishes.create: :name(&#34;camelia plush&#34;), :link&lt;https://farm9.static.flickr.com/8432/28947786492_80056225f3_b.jpg&gt;;

my \sophia = Person.^create: :name&lt;Sophia&gt;,   :email&lt;saco@aco.com&gt;;
sophia.wishes.create: :name(&#34;baby alive&#34;),      :link&lt;https://www.target.com/p/baby-alive-face-paint-fairy-brunette/-/A-51304817&gt;;

Person.draw;

say &#34;{ .name } -&gt; { .pair.name }\n\tWishlist: { .pair.wishes.map(*.name).join: &#34;, &#34; }&#34; for Person.^all</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在<strong>Person</strong>  有两个新*属性*  （<strong>$！pair-id</strong>和<strong>$ .pair</strong>）和一个新方法（<strong>draw</strong>）。 <strong>$！pair-id</strong>  是一个 引用 同一个*表*  （<strong>Person</strong>）上  的字段<strong>id</strong>的*外键*，因此我们必须使用  <strong>别名</strong>  （）。另一个是使用该*外键*的*关系*  （<strong>$ .pair</strong>）。<code>.^alias</code></p>
</div>
<div class="paragraph">
<p>新方法（<strong>平局</strong>）是神奇发生的地方。它使用方法  <strong>.pick：\</strong>*  在普通的  <strong>Positional</strong>  上将洗牌。它在这里做同样的事情，查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT
   person.email , person.id , person.name , person.pair_id as &#34;pair-id&#34;
FROM
   person
ORDER BY
   random()</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦我们有了洗牌列表，我们就会使用  <strong>.rotor</strong>  来获取两个项目并返回一个，所以我们保存每个人给予下一个人的那一对，并且列表中的最后一个人将给第一个人。</p>
</div>
<div class="paragraph">
<p>这是我们最终代码的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Fernando -&gt; Sophia
	Wishlist: baby alive
Aline -&gt; Fernanda
	Wishlist: mimikyu plush, camelia plush
Fernanda -&gt; Fernando
	Wishlist: COMMA, raku books, mac book pro
Sophia -&gt; Aline
	Wishlist: a new closet</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为奖励，让我们看一下Red将要跟随的曲目。这是当前的工作代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Red;

model Person {
   has UInt     $.id        is id;
   has Str      $.name      is column;
   has Str      $.email     is column{ :nullable };
}

my $*RED-DB = database &#34;SQLite&#34;;

Person.^create-table;

Person.^create: :name&lt;Fernando&gt;,    :email&lt;fco@aco.com&gt;;
Person.^create: :name&lt;Aline&gt;,       :email&lt;aja@aco.com&gt;;
Person.^create: :name&lt;Fernanda&gt;;
Person.^create: :name&lt;Sophia&gt;;

.say for Person.^all.map: { &#34;{ .name }{ &#34; =&gt; { .email }&#34; if .email }&#34; };</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是它运行的SQL：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT
   CASE
      WHEN (email == &#39;&#39; OR email IS NULL) THEN name
   ELSE name || &#39; =&gt; &#39; || email
   END
    as &#34;data&#34;
FROM
   person</code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Fernando =&gt; fco@aco.com
Aline =&gt; aja@aco.com
Fernanda
Sophia</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十二天_测试_cro_http_api">49. 第二十二天 - 测试 Cro HTTP API</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_测试cro_http_api">49.1. 测试Cro HTTP API</h3>
<div class="paragraph">
<p>今年我花了大量的工作时间用于构建一些 Raku 应用程序。经过为 Raku 编译器和运行时开发贡献代码十年之后，最终使用它来提供解决实际问题的生产解决方案感觉很棒。我还不确定在我创建的<a href="http://www.commaide.com/">IDE中</a>编写代码，使用我设计的<a href="https://cro.services/">HTTP库</a>，由我实现大部分的<a href="https://rakudo.org/">编译器编译</a>，并在我扮演架构师的<a href="https://moarvm.org/">VM</a>上运行，是否会使我成为世界上最差的“尚未发明”的案例，或者只是真正的全栈。</p>
</div>
<div class="paragraph">
<p>无论我在做什么，我都非常重视自动化测试。每一次通过测试我都知道有东西能工作了  - 当我改进有问题的软件时，我不会破坏这些测试。即使使用自动化测试，也会发生错误，但是添加测试来弥补错误至少意味着我将来会犯下*不同的*错误，这可能有点可以原谅。</p>
</div>
<div class="paragraph">
<p>我目前正在处理的系统中的大多数代码和复杂性都在其域对象中。这些是通过使用Cro实现的HTTP API实现的 - 与系统的其他部分一样，此 HTTP API 具有自动化测试。他们使用我的一个旧模块`Test::Mock`- 以及今年发布的新模块，<code>Cro::HTTP::Test</code>。在今天的 Advent 文章中，我将讨论我如何一起使用它们，结果我觉得非常讨人喜欢。</p>
</div>
<div class="sect3">
<h4 id="_一个示例问题">49.1.1. 一个示例问题</h4>
<div class="paragraph">
<p>这是 advent 日历，所以当然我需要一个足够节日化的例子问题。对我而言，中欧圣诞时间的亮点之一是圣诞市场，有许多都坐落在美丽的历史城市广场上。除了香肠和热葡萄酒之外，我们还需要在广场上吗？当然，这是一棵高大帅气的圣诞树！但如何找到最好的树？好吧，我们通过建立一个系统来提供互联网帮助，他们可以提交他们认为可能适合的圣诞树的建议。什么可能出错？</p>
</div>
<div class="paragraph">
<p>可以 PUT 到路由 <code>/trees/{latitude}/{longitude}</code> 以在该位置提交候选圣诞树。预期的有效负载是带有树的高度( <code>height</code>) 的 JSON blob，以及 10-200 个文本字符的描述(<code>description</code>)，解释为什么这棵圣诞树太棒了。如果同一位置已经提交了圣诞树，则应返回 <code>409 Conflict</code> 响应。如果圣诞树被接受，那么将生成一个简单的 <code>200 OK</code> 响应，并带有一个 JSON 格式的主体描述该圣诞树。</p>
</div>
<div class="paragraph">
<p>同一 URI 的 GET 将返回相关树的描述，而 GET <code>/trees</code> 将返回已提交的树，最高的圣诞树排第一个。</p>
</div>
</div>
<div class="sect3">
<h4 id="_可测性">49.1.2. 可测性</h4>
<div class="paragraph">
<p>回到高中，科学课肯定是我最喜欢的。我们不时地做实验。当然，每个实验都需要编写 - 包括之前的计划，结果和对它们的分析。规划中最重要的部分之一是关于如何确保“公平测试”：我们如何试图控制我们还未尝试测试的所有事情，以便我们可以信任我们的观察并从中得出结论？</p>
</div>
<div class="paragraph">
<p>软件测试涉及大致相同的思考过程：我们如何运用我们感兴趣的组件，同时控制它们运行的上下文？有时，我们很幸运，我们正在测试纯粹的逻辑：它不依赖于我们提供给它的东西以外的任何东西。事实上，我们可以在这方面*创造自己的运气*，发现我们系统中可以是纯函数或不可变对象的部分。从我正在研究的当前系统中获取示例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们有一个由一堆规范文件构建的对象模型。
构建它的过程非常复杂，包括一系列健全性
检查，一些图形算法等等。但结果是
一堆*不可变的对象*。一旦建成，它们永远不会改变。
测试很简单：丢出一堆测试输入，并检查它是否
构建了预期的对象。</p>
</li>
<li>
<p>我们有一个计算器的小语言。
语言中表达式使用的数据作为参数传递给计算器，
然后我们可以检查结果是否符合预期。因此，计算器
是一个*纯函数*。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，为可测试性做的第一件事就是找到可以像这样的系统部分并以这种方式构建它们。唉，并非所有事情都如此简单。HTTP API 通常是可变状态的网关，数据库操作等。此外，良好的 HTTP API 会将域级别的错误条件映射到适当的 HTTP 状态代码。我们希望能够在我们的测试中创建这样的情况，以便覆盖它们。这是一个类似 `Test::Mock`工具入场的地方, 但要使用它，我们需要以一种对测试友好的方式考虑我们的Cro服务。</p>
</div>
</div>
<div class="sect3">
<h4 id="_打桩服务">49.1.3. 打桩服务</h4>
<div class="paragraph">
<p>对于那些刚接触Cro的人，让我们来看看我们可以编写的最低限度，以便启动和运行HTTP服务，提供有关树的一些假数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">use Cro::HTTP::Router;
use Cro::HTTP::Server;

my $application = route {
    get -&gt; &#39;trees&#39; {
        content &#39;application/json&#39;, [
            {
                longitude =&gt; 50.4311548,
                latitude =&gt; 14.586079,
                height =&gt; 4.2,
                description =&gt; &#39;Nice color, very bushy&#39;
            },
            {
                longitude =&gt; 50.5466504,
                latitude =&gt; 14.8438714,
                height =&gt; 7.8,
                description =&gt; &#39;Really tall and wide&#39;
            },
        ]
    }
}

my $server = Cro::HTTP::Server.new(:port(10000), :$application);
$server.start;
react whenever signal(SIGINT) {
    $server.stop;
    exit;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这不是一个能够测试我们路由的好方法。更好的方法是将路由放入 <code>lib/BestTree.pm6</code> 模块中的子例程中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module BestTree;
use Cro::HTTP::Router;

sub routes() is export {
    route {
        get -&gt; &#39;trees&#39; {
            content &#39;application/json&#39;, [
                {
                    longitude =&gt; 50.4311548,
                    latitude =&gt; 14.586079,
                    height =&gt; 4.2,
                    description =&gt; &#39;Nice color, very bushy&#39;
                },
                {
                    longitude =&gt; 50.5466504,
                    latitude =&gt; 14.8438714,
                    height =&gt; 7.8,
                    description =&gt; &#39;Really tall and wide&#39;
                },
            ]
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并从脚本中使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use BestTree;
use Cro::HTTP::Server;

my $application = routes();
my $server = Cro::HTTP::Server.new(:port(10000), :$application);
$server.start;
react whenever signal(SIGINT) {
    $server.stop;
    exit;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，如果我们有一些东西可以用来测试`route`块做正确的事情，我们可以使用(<code>use</code>)这个模块，继续我们的测试。</p>
</div>
</div>
<div class="sect3">
<h4 id="_存储模型等">49.1.4. 存储、模型等</h4>
<div class="paragraph">
<p>然而，还有另一个问题。我们的圣诞树服务将在一些数据库中存储树信息，并执行各种规则。这个逻辑应该去哪里？</p>
</div>
<div class="paragraph">
<p>我们有许多方法来安排这段代码，但最关键的是，这种逻辑并不属于我们的Cro路由处理程序。他们的工作是在域对象和HTTP世界之间进行映射，例如将域异常转换为适当的HTTP错误响应。那个映射是我们想要测试的。</p>
</div>
<div class="paragraph">
<p>所以，在我们继续之前，让我们来定义一些这些东西的外观。我们将有一个`BestTree::Tree`代表树的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class BestTree::Tree {
    has Rat $.latitude;
    has Rat $.longitude;
    has Rat $.height;
    has Str $.description;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将使用一个`BestTree::Store`对象。我们实际上不会将此作为此帖的一部分来实现; 这将是我们在测试中假装的东西。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class BestTree::Store {
    method all-trees() { ... }
    method suggest-tree(BestTree::Tree $tree --&gt; Nil) { ... }
    method find-tree(Rat $latitude, Rat $longitude --&gt; BestTree::Tree) { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是我们如何安排事情以便我们可以控制路由使用的存储，以进行测试？一个简单的方法是使它成为我们`routes`子程序的参数，这意味着它将在`route`块中可用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">sub routes(BestTree::Store $store) is export {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个功能因素。有些人可能更喜欢使用某种容器来使用某种基于OO的依赖注入。这也适用于Cro：只需要一个返回`route`块的方法。（如果使用Cro构建非常小的东西，请查看<a href="https://cro.services/docs/structuring-services">有关结构化服务</a>的<a href="https://cro.services/docs/structuring-services">文档，</a>以获得有关此方面的一些进一步建议。）</p>
</div>
</div>
<div class="sect3">
<h4 id="_获取树的清单">49.1.5. 获取树的清单</h4>
<div class="paragraph">
<p>现在我们准备开始编写测试了！让我们存根测试文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use BestTree;
use BestTree::Store;
use Cro::HTTP::Test;
use Test::Mock;
use Test;

# Tests will go here

done-testing;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用`BestTree`，它包含我们想要测试的路由，以及：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Cro::HTTP::Test</code>，我们将用它来轻松编写我们的路由测试</p>
</li>
<li>
<p><code>Test::Mock</code>，我们将用它来伪造存储</p>
</li>
<li>
<p><code>Test</code>，我们并不严格需要，但有权访问`subtest`将
让我们产生更有条理的测试输出</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>接下来，我们将在测试中使用几个树对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fake-tree-a = BestTree::Tree.new:
        latitude =&gt; 50.4311548,
        longitude =&gt; 14.586079,
        height =&gt; 4.2,
        description =&gt; &#39;Nice color, very bushy&#39;;
my $fake-tree-b = BestTree::Tree.new:
        latitude =&gt; 50.5466504,
        longitude =&gt; 14.8438714,
        height =&gt; 7.8,
        description =&gt; &#39;Really tall and wide&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是第一次测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subtest &#39;Get all trees&#39; =&gt; {
    my $fake-store = mocked BestTree::Store, returning =&gt; {
        all-trees =&gt; [$fake-tree-a, $fake-tree-b]
    };
    test-service routes($fake-store), {
        test get(&#39;/trees&#39;),
                status =&gt; 200,
                json =&gt; [
                    {
                        latitude =&gt; 50.4311548,
                        longitude =&gt; 14.586079,
                        height =&gt; 4.2,
                        description =&gt; &#39;Nice color, very bushy&#39;
                    },
                    {
                        latitude =&gt; 50.5466504,
                        longitude =&gt; 14.8438714,
                        height =&gt; 7.8,
                        description =&gt; &#39;Really tall and wide&#39;
                    }
                ];
        check-mock $fake-store,
                *.called(&#39;all-trees&#39;, times =&gt; 1, with =&gt; \());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，我们伪造一个 <code>BestTree::Store</code>，无论何时`all-trees`被调用，都将返回我们指定的伪数据。然后我们使用`test-service`，传递`route`用假存储创建的块。随后的块内的所有 <code>test</code> 调用都将针对该`route`块执行。</p>
</div>
<div class="paragraph">
<p>请注意，在这里我们不必担心运行HTTP服务来托管我们要测试的路由。实际上，由于Cro的管道架构，我们很容易就可以使用Cro HTTP客户端，连接其TCP消息输出以将它想要的数据发送到 Raku `Channel`中，然后将这些数据推送到服务管道的TCP消息的输入管道中，反之亦然。这意味着我们一路测试到发送和接收的字节，但实际上不必命中本地网络堆栈。（旁白：您也可以使用`Cro::HTTP::Test`URI，这意味着如果您真的想要启动测试服务器，或者甚至想针对在不同进程中运行的其他服务编写测试，您可以这样做。）</p>
</div>
<div class="paragraph">
<p>该`test`程序规定了测试案例。它的第一个参数描述了我们希望执行的请求 - 在这种情况下，是一个到 <code>/trees</code> 的`get` 。然后，命名参数指定响应的外观。该`status`检查将确保我们取回了预期的HTTP状态代码。该`json`检查实际上是一个里面有俩个：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它检查 HTTP 的 content-type 是否为 JSON</p>
</li>
<li>
<p>它检查反序列化为提供的JSON的正文（如果你不想
测试它的每一个，在那里传递一个块，应该计算为`True`）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果这就是我们所做的，并且我们运行了测试，我们会发现它们神秘地通过了，即使我们还没有编辑我们的`route`块的`get`处理程序来实际使用存储！为什么？因为事实证明我很懒，并且使用我之前的小服务器示例中的数据作为我的测试数据。不用担心：为了使测试更强大，我们可以添加一个对 <code>check-mock</code> 的调用，然后断言我们的假存储确实调用了一次 <code>all-trees</code> 方法，并且没有传递参数。</p>
</div>
<div class="paragraph">
<p>这让我们通过正确实现处理程序来使测试通过：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;trees&#39; {
    content &#39;application/json&#39;, [
        $store.all-trees.map: -&gt; $tree {
            {
                latitude =&gt; $tree.latitude,
                longitude =&gt; $tree.longitude,
                height =&gt; $tree.height,
                description =&gt; $tree.description
            }
        }
    ]
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_得到一棵树">49.1.6. 得到一棵树</h4>
<div class="paragraph">
<p>下一次测试的时间：获得一棵树。这里有两种情况需要考虑：一个是树是在哪里找到的，以及树是在哪里找不到的。这是对树是在哪里找到的情况的测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subtest &#39;Get a tree that exists&#39; =&gt; {
    my $fake-store = mocked BestTree::Store, returning =&gt; {
        find-tree =&gt; $fake-tree-b
    };
    test-service routes($fake-store), {
        test get(&#39;/trees/50.5466504/14.8438714&#39;),
                status =&gt; 200,
                json =&gt; {
                    latitude =&gt; 50.5466504,
                    longitude =&gt; 14.8438714,
                    height =&gt; 7.8,
                    description =&gt; &#39;Really tall and wide&#39;
                };
        check-mock $fake-store,
                *.called(&#39;find-tree&#39;, times =&gt; 1, with =&gt; \(50.5466504, 14.8438714));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在运行它失败了。事实上，`status`代码检查首先失败，因为我们还没有实现路由，因此得到404，而不是预期的200. 所以，这是一个让它通过的实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">        get -&gt; &#39;trees&#39;, Rat() $latitude, Rat() $longitude {
            given $store.find-tree($latitude, $longitude) -&gt; $tree {
                content &#39;application/json&#39;, {
                    latitude =&gt; $tree.latitude,
                    longitude =&gt; $tree.longitude,
                    height =&gt; $tree.height,
                    description =&gt; $tree.description
                }
            }
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>从其他路由来看，这部分看起来有些熟悉，不是吗？所以，有了两次通过测试，让我们继续重构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;trees&#39; {
    content &#39;application/json&#39;,
            [$store.all-trees.map(&amp;tree-for-json)];
}

get -&gt; &#39;trees&#39;, Rat() $latitude, Rat() $longitude {
    given $store.find-tree($latitude, $longitude) -&gt; $tree {
        content &#39;application/json&#39;, tree-for-json($tree);
    }
}

sub tree-for-json(BestTree::Tree $tree --&gt; Hash) {
    return {
        latitude =&gt; $tree.latitude,
        longitude =&gt; $tree.longitude,
        height =&gt; $tree.height,
        description =&gt; $tree.description
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>测试通过，我们知道我们的重构很好。但是等一下，如果那里没有树怎么办？在这种情况下，存储将返回`Nil`。我们想把它映射到404.这是另一个测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subtest &#39;Get a tree that does not exist&#39; =&gt; {
    my $fake-store = mocked BestTree::Store, returning =&gt; {
        find-tree =&gt; Nil
    };
    test-service routes($fake-store), {
        test get(&#39;/trees/50.5466504/14.8438714&#39;),
                status =&gt; 404;
        check-mock $fake-store,
                *.called(&#39;find-tree&#39;, times =&gt; 1, with =&gt; \(50.5466504, 14.8438714));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上，由于我们在路由块中没有考虑这种情况，因此失败了, 返回 500 错误码。令人高兴的是，这个很容易处理：把 <code>given`变成 `with</code>，它检查我们得到了一个已定义的对象，然后添加一个`else`并生成404 Not Found响应。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; &#39;trees&#39;, Rat() $latitude, Rat() $longitude {
    with $store.find-tree($latitude, $longitude) -&gt; $tree {
        content &#39;application/json&#39;, tree-for-json($tree);
    }
    else {
        not-found;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_提交一棵树">49.1.7. 提交一棵树</h4>
<div class="paragraph">
<p>最后但并非最不重要的是，让我们测试建议新树的路由。这是成功的情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subtest &#39;Suggest a tree successfully&#39; =&gt; {
    my $fake-store = mocked BestTree::Store;
    test-service routes($fake-store), {
        my %body = description =&gt; &#39;Awesome tree&#39;, height =&gt; 4.25;
        test put(&#39;/trees/50.5466504/14.8438714&#39;, json =&gt; %body),
                status =&gt; 200,
                json =&gt; {
                    latitude =&gt; 50.5466504,
                    longitude =&gt; 14.8438714,
                    height =&gt; 4.25,
                    description =&gt; &#39;Awesome tree&#39;
                };
        check-mock $fake-store,
                *.called(&#39;suggest-tree&#39;, times =&gt; 1, with =&gt; :(
                    BestTree::Tree $tree where {
                        .latitude == 50.5466504 &amp;&amp;
                        .longitude == 14.8438714 &amp;&amp;
                        .height == 4.25 &amp;&amp;
                        .description eq &#39;Awesome tree&#39;
                    }
                ));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>大部分都很熟悉，除了这次`check-mock` 调用看起来有点不同。<code>Test::Mock`让我们用两种不同的方式测试参数： `Capture</code>（我们到目前为止）或者 <code>Signature</code>。这个`Capture`案例非常适用于所有简单情况，我们只处理无聊的值。但是，一旦我们进入引用类型，或者如果我们实际上并不关心确切的值并且只是想断言我们关心的事情，签名就会让我们灵活地做到这一点。这里，我们使用一个`where`子句来检查路由处理程序构造的树对象是否包含预期的数据。</p>
</div>
<div class="paragraph">
<p>这是执行此操作的路由处理程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put -&gt; &#39;trees&#39;, Rat() $latitude, Rat() $longitude {
    request-body -&gt; (Rat(Real) :$height!, Str :$description!) {
        my $tree = BestTree::Tree.new: :$latitude, :$longitude,
                :$height, :$description;
        $store.suggest-tree($tree);
        content &#39;application/json&#39;, tree-for-json($tree);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意Cro如何让我们使用Raku签名来构建请求体。在一行中，我们说过：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>请求正文必须具有高度和描述</p>
</li>
<li>
<p>我们希望高度是一个`Real`数字</p>
</li>
<li>
<p>我们希望描述是一个字符串</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果其中任何一个失败，Cro将自动为我们产生400不良请求。事实上，我们可以编写测试来覆盖它 - 以及一个新的测试，以确保冲突将导致409。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subtest &#39;Problems suggesting a tree&#39; =&gt; {
    my $fake-store = mocked BestTree::Store, computing =&gt; {
        suggest-tree =&gt; {
            die X::BestTree::Store::AlreadySuggested.new;
        }
    }
    test-service routes($fake-store), {
        # Missing or bad data.
        test put(&#39;/trees/50.5466504/14.8438714&#39;, json =&gt; {}),
                status =&gt; 400;
        my %bad-body = description =&gt; &#39;ok&#39;;
        test put(&#39;/trees/50.5466504/14.8438714&#39;, json =&gt; %bad-body),
                status =&gt; 400;
        %bad-body&lt;height&gt; = &#39;grinch&#39;;
        test put(&#39;/trees/50.5466504/14.8438714&#39;, json =&gt; %bad-body),
                status =&gt; 400;

        # Conflict.
        my %body = description =&gt; &#39;Awesome tree&#39;, height =&gt; 4.25;
        test put(&#39;/trees/50.5466504/14.8438714&#39;, json =&gt; %body),
                status =&gt; 409;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的主要新事物是我们使用`computing`而不是带有 <code>mocked</code> 的`returning`。在这种情况下，我们传递一个块，它将被执行。（然而，该块不会获取方法参数。如果我们想要获取这些参数，则有第三个选项，<code>overriding</code>, 其中我们可以获取参数并编写一个假的方法体。）</p>
</div>
<div class="paragraph">
<p>以及如何处理？通过使我们的路由处理程序捕获并映射类型化的异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put -&gt; &#39;trees&#39;, Rat() $latitude, Rat() $longitude {
    request-body -&gt; (Rat(Real) :$height!, Str :$description!) {
        my $tree = BestTree::Tree.new: :$latitude, :$longitude,
                :$height, :$description;
        $store.suggest-tree($tree);
        content &#39;application/json&#39;, tree-for-json($tree);
        CATCH {
            when X::BestTree::Store::AlreadySuggested {
                conflict;
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_结束思考">49.1.8. 结束思考</h4>
<div class="paragraph">
<p>有了`Cro::HTTP::Test`，现在有一种很好的方法可以在Raku中编写HTTP测试。结合可测试的设计，也许是一个类似的模块`Test::Mock`，我们也可以将我们的Cro路由处理程序与其他所有东西隔离开来，从而简化测试。</p>
</div>
<div class="paragraph">
<p>我们的路由处理程序中的逻辑相对简单; 通常是小样本问题。然而，即使在这里，我发现旅程中有价值，而不仅仅是在目的地。为HTTP API编写测试的行为让我置身于任何将调用API的人的心中，这可能是一个有用的观点。经验还告诉我们，测试“太简单到失败”最终会导致错误：我可能会认为我犯得太聪明了。纪律有很长的路要走。在哪个方面，我现在会受到纪律处分，不时地从键盘上休息一下，然后去享受圣诞市场。-Ofun！</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十三天_blin很快就到圣诞节了">50. 第二十三天 - Blin，很快就到圣诞节了！</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rakuadvent.wordpress.com/2016/12/23/">两年前</a>我已经在出现一篇 advent 文章里提到过 Bisectable，但自那时以来发生了很多变化，所以我觉得是时候简要介绍一下 <code>bisectable</code> 机器人和它的朋友们了。</p>
</div>
<div class="paragraph">
<p>首先，让我们来定义正在解决的问题。有时会<a href="https://github.com/rakudo/rakudo/issues?q=is%3Aopen+is%3Aissue+label%3Aregression">发生</a>提交引入意外更改行为（错误）。通常我们称之为回归，在某些情况下，找出错误并修复它的最简单方法是首先找到引入回归的提交。</p>
</div>
<div class="paragraph">
<p>Rakudo 2015.12 和 2018.12 之间有<a href="https://github.com/Rakudo/Rakudo/compare/2015.12…​2018.12">9000个</a>提交，尽管它不*超过9000*，但仍然很多。</p>
</div>
<div class="paragraph">
<p>幸运的是，我们不需要测试所有修改。假设行为不是一直来回变化，我们可以使用<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">二分法查找</a>。</p>
</div>
<div class="sect2">
<h3 id="_git_bisect_和二分法查找">50.1. <code>git bisect</code> 和二分法查找</h3>
<div class="paragraph">
<p>基本上，给定任何提交范围，我们在范围的“中间”取一个提交提交并测试它。如果它是“坏”或者它显示“新”（现在是不正确的）行为，那么我们就可以抛弃我们范围的后半部分（因为我们知道更改必须在该提交之前发生或完全在该提交之后）。同样，如果它是“好”（或“旧”），我们会扔掉另一半。因此，我们只需检查`log n`个修改（≈13），而不是测试所有 9000 次提交。</p>
</div>
<div class="paragraph">
<p>Git 附带了<a href="https://git-scm.com/docs/git-bisect"><code>git bisect</code></a>为您实现二分法查找逻辑的命令。你所要做的就是给它一些起点，然后对于每次提交它跳转过去，告诉它是好还是坏。如果你做了足够多次，它会告诉你哪个提交有问题。</p>
</div>
<div class="paragraph">
<p>这一切都很好，但有两个问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_问题跳过">50.2. 问题❶：跳过</h3>
<div class="paragraph">
<p>让我们想象一下`2 + 2`用来返回的情况`4`（正确！），但现在返回`42`（…​…​也正确，但不完全对）。</p>
</div>
<div class="paragraph">
<p>所以你启动了 bisection 过程，git 在修改之间跳转，你测试它们。如果它是`4`那么`good`（或`old`），如果它是`42`那么它是`bad`（或`new`）。但后来你偶然发现了这种行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">&gt; 2 + 2

Merry Christmas!</code></pre>
</div>
</div>
<div class="paragraph">
<p>… 怎么办？显然，那个具体修改有点特殊。我们无法判断我们的错误是否存在，我们根本无法知道。是的，它不会打印`4`，但我们正在寻找一个非常具体的错误，因此它也不会被归类为“新”行为。当然，我们可以抛硬币并随机标记为`old`或者`new`，并希望圣诞节奇迹…​…​但是有50％的概率（如果我们只看到其中一个）将二分法查找转移到错误的方向。</p>
</div>
<div class="paragraph">
<p>对于这些情况，git 提供了一个特殊<a href="https://git-scm.com/docs/git-bisect#_bisect_skip">`skip`命令</a>。</p>
</div>
<div class="paragraph">
<p>如果你是手动测试，那么处理这些修改就有点简单（只要你记得你应该跳过(<code>skip</code>)他们）。但是，由于问题❷，很多人都倾向于使用`git bisect run`脚本自动化过程。也可以使用脚本跳过修改（使用退出代码`125`），但是如何确定应该跳过哪些修改并不是那么明显。</p>
</div>
</div>
<div class="sect2">
<h3 id="_问题构建时间">50.3. 问题❷：构建时间</h3>
<div class="paragraph">
<p>让我们用乐观的数字13来估计我们要测试的修改量。请记住，它不包括我们必须跳过的提交，以及可能需要测试的其他额外构建。</p>
</div>
<div class="paragraph">
<p>构建rakudo所需的时间因硬件而异，但我们乐观地说，在特定的提交中构建rakudo需要2分钟时间并对其进行测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">13 × 2 = 26 (minutes)</code></pre>
</div>
</div>
<div class="paragraph">
<p>那不是很方便，对吧？如果在此过程中出现问题…​…​你重新开始，<a href="https://www.youtube.com/watch?v=mPzjbXgaVOk&amp;feature=youtu.be&amp;t=16">然后等待</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_bisectable">50.4. Bisectable</h3>
<div class="paragraph">
<p>在2016年，在看到那些必须手动运行 <code>git bisect</code> 的人（实际上，大部分是<a href="https://colabti.org/irclogger/irclogger_log/raku?date=2016-05-17#l1353">我自己</a>）的痛苦之后，<a href="https://colabti.org/irclogger/irclogger_log/raku?date=2016-05-17#l1335">我想知道</a>：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>有没有人想过为每一次提交构建rakudo，以便你可以快速运行git bisect？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>该想法的成本效益分析受到了迅速质疑：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>AlexDaniel：你认为未来二分法将会很普遍吗？</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>我提供了非常详细的理由：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>perlpilot：是的</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>三天后，机器人加入了频道。<a href="https://colabti.org/irclogger/irclogger_log/raku?date=2016-05-20#l345">这些反应</a>非常有趣：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>哇
哦
OooOOOoooh
Cooooool</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>当时我们很少知道结果会怎样。即使我不知道它会变得多么有用。<a href="https://colabti.org/irclogger/irclogger_log/raku?date=2018-11-13#l678">快进2年</a>：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>关于提交的大小：我尽量保持它们尽可能小，并且尽可能地包含它们，以便
在这种意义上更容易二分，bisectable6 也改变了我编码的方式
还有：bisectable6 让我更少担心我提交的更改
因为它通常限制很多地点寻找以修复问题，他们可以在几分钟而不是几小时内修复
或至少很快显示原因（所以短时间修复可能意味着 revert）
\ o /</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>但它并不总是完美的。引入机器人大约一小时后，它被用于其目的：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>bisect：<code>try { NaN.Rat == NaN; exit 0 }; exit 1</code>
moritz：（2016-05-02）<a href="https://github.com/rakudo/rakudo/commit/949a7c7" class="bare">https://github.com/rakudo/rakudo/commit/949a7c7</a></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>但是，由于一个<a href="https://github.com/raku/whateverable/commit/68ba961854b17298225dd9b886b2af874e567556">off-by-one</a>，它返回了错误的提交。实际提交是<a href="https://github.com/rakudo/rakudo/commit/e2f1fa7">e2f1fa7</a>，而<a href="https://github.com/rakudo/rakudo/commit/949a7c7">949a7c7</a>是其父级。</p>
</div>
<div class="paragraph">
<p>老实说，那时机器人非常糟糕。例如，它完全依赖于退出代码，所以你不能只是把 `2 + 2`抛给它并期望它检查输出。最终，实施了不同的模式，现在机器人首先检查起点上的行为（例如2015.12和HEAD），并确定执行二分法的最佳策略。例如，如果信号不同（例如SEGV），则它基于信号一分为二。如果信号相同，但退出代码不同，则使用退出代码。如果无法使用其他所有内容，则使用输出进行一分为二。</p>
</div>
<div class="paragraph">
<p>请记住，如果`raku`无法构建二进制文件，则可以检查二分法。这意味着在大多数情况下，您不需要添加自己的逻辑来跳过。它不仅将二分法时间从几十分钟缩短到几秒钟，而且还提供更可靠/正确的结果。</p>
</div>
</div>
<div class="sect2">
<h3 id="_存储">50.5. 存储</h3>
<div class="paragraph">
<p>一段时间之后，提交范围扩展到`2014.01`…​…​ <code>HEAD</code>，意味着所有提交都是从第一个有关Moar的Rakudo发布开始的。目前它有超过17000个构建。它可能听起来很多，但每个rakudo安装只需≈28MB，这不是*太多*。拥有几TB存储空间可以让您在未来几年内继续使用。</p>
</div>
<div class="paragraph">
<p>话虽如此，我的服务器上没有那么奢侈。它有一个120 GB SSD的RAID，因此整个事情不仅要适应这么小的空间，而且还应该为系统的其余部分留出足够的空间。</p>
</div>
<div class="paragraph">
<p>有很多实验（<a href="https://github.com/raku/whateverable/issues/23">一</a>，<a href="https://github.com/raku/whateverable/issues/117">二</a>）涉及找出节省空间的最佳策略，但*长话短说*，我们可以低至每个版本大约半兆字节！当然，它总是在压缩比和解压缩速度之间进行权衡，但使用现代压缩算法（<a href="https://github.com/facebook/zstd">zstd</a>，<a href="https://github.com/ckolivas/lrzip">lrzip</a>）一切都相对容易。</p>
</div>
</div>
<div class="sect2">
<h3 id="_更多机器人更好">50.6. 更多机器人，更好</h3>
<div class="paragraph">
<p>在Bisectable发布后不久，人们看到了其他工具的机会。想要在特定提交上运行一些代码吗？当然，这有<a href="https://github.com/raku/whateverable/wiki/Committable">一个机器人</a>。想下载预构建的rakudo存档而不是浪费你自己的cpu时间吗？是的，<a href="https://github.com/raku/whateverable/wiki/Shareable">还有另一个机器人</a>。想要绘制一些关于rakudo的信息吗？<a href="https://github.com/raku/whateverable/wiki/Statisfiable">当然有一个机器人！</a></p>
</div>
<div class="paragraph">
<p>机器人一直持续增加直到我们有了共计<a href="https://github.com/raku/whateverable/wiki"><strong>17个机器人！</strong></a>有些人认为这些机器人应该停止这样的倍增，也许人们是正确的。但我想重点是，现在很容易在Whateverable上为开发人员创建更多工具，这当然很棒。</p>
</div>
</div>
<div class="sect2">
<h3 id="_好的现在怎么样">50.7. 好的，现在怎么样？</h3>
<div class="paragraph">
<p>因此，bisectable可以在很短的时间内将数千个提交一分为二。它占用的存储空间非常小，并且用户不需要完全理解二分过程。既然二分是免费且容易的，我们可以做更多吗？</p>
</div>
</div>
<div class="sect2">
<h3 id="_是的blin">50.8. 是的，Blin！</h3>
<div class="paragraph">
<p>你可能听说过<a href="https://raku.party/post/Perl-6-Release-Quality-Assurance-Full-Ecosystem-Toaster">Toaster</a>。Toaster是一种尝试在两个或多个修订版中安装生态系统中的每个模块的工具。例如，假设最后一个版本是2018.12，发布经理即将从主HEAD中删除rakudo版本。然后，您可以在 <code>2018.12`和`master</code> 上运行 toaster，它会显示哪些模块用于干净安装，但不再做。</p>
</div>
<div class="paragraph">
<p>这给了我们Rakudo可能出错的信息，但并没有告诉我究竟是什么。鉴于此帖主要是关于Bisectable，你可能会猜到这是怎么回事。</p>
</div>
</div>
<div class="sect2">
<h3 id="_blin_项目_重新发明了_toasting">50.9. Blin 项目- 重新发明了 Toasting</h3>
<div class="paragraph">
<p>Blin是Rakudo版本的质量保证工具。它用于在rakudo中查找回归，但与Toaster不同，它不仅告诉哪些模块不再可安装，还将rakudo一分为二，以找出导致问题的提交。当然，它是围绕Whateverable构建的，因此额外的功能不会花费太多（甚至不需要很多代码）。作为奖励，它生成了<a href="https://gist.github.com/AlexDaniel/d7b789eefb34db31ee14f16dadd9a3ad">很好的图形</a>来可视化问题如何从模块依赖性传播（虽然这不是很常见）。</p>
</div>
<div class="paragraph">
<p>Blin的一个重要特性是它只尝试安装每个模块一次。因此，如果模块B依赖于模块A，A将被测试并安装一次，然后重新用于B的测试。因为这个过程是并行化的，您可能想知道它是如何实现的。<a href="https://github.com/raku/Blin/blob/b535dc0d727a61047199dd6ee67d07d626941965/bin/blin.p6#L285">基本上</a>，它使用被低估的`react/whenever`功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># slightly simplified
react {
    for @modules -&gt; $module {
        whenever Promise.allof($module.depends.keys».done) {
            start { process-module $module, … }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于每个模块（我们现在有超过1200个），它会创建自己的`whenever`块，在满足其依赖关系时触发。在我看来，这是Blin中主要逻辑的全部实现，其他一切只是粘合剂以获得Whateverable和Zef协同工作以实现我们所需要的，+一些输出生成。</p>
</div>
<div class="paragraph">
<p>在某种程度上，Blin对我们为Rakudo做质量保证的方式没有太大的改变。Toaster已经能够给我们一些基本的信息（尽管速度较慢），以便我们可以开始调查，而在过去，我知道将奇怪的东西（例如带有依赖关系的完整模块）推入二分法。只是现在它变得更容易了，当<a href="https://en.wikipedia.org/wiki/AI_takeover"><strong>The Day</strong></a>到来时，我不会因机器人滥用而受到惩罚。</p>
</div>
</div>
<div class="sect2">
<h3 id="_未来">50.10. 未来</h3>
<div class="paragraph">
<p><a href="https://github.com/raku/whateverable/issues">Whateverable</a>和<a href="https://github.com/raku/Blin/issues">Blin</a>一起有243个未解决的问题。这两个项目都非常有用，而且非常有用，但正如我们所说，它们不是很棒。大多数问题相对容易和有趣，但它们需要时间。如果您有任何帮助，或者您想维护这些项目，请随时这样做。如果你想基于Whateverable构建自己的工具（我们可能需要很多！），请参阅这个<a href="https://gist.github.com/AlexDaniel/88b38af5db9adcf0b711ac3df31dd431">hello world gist</a>。</p>
</div>
<div class="paragraph">
<p>🎅🎄， 🥞</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十四天_使用_raku_进行主题建模">51. 第二十四天 - 使用 Raku 进行主题建模</h2>
<div class="sectionbody">
<div class="paragraph">
<p>嗨，大家好。</p>
</div>
<div class="paragraph">
<p>今天，让我介绍<a href="https://github.com/titsuki/p6-Algorithm-LDA">Algorithm::LDA</a>。
该模块是用于主题建模的Latent Dirichlet Allocation（即LDA）实现。</p>
</div>
<div class="sect2">
<h3 id="_介绍_4">51.1. 介绍</h3>
<div class="paragraph">
<p>什么是LDA？LDA是一种流行的无监督机器学习方法。
它模拟文档生成过程，并将每个文档表示为主题的混合。</p>
</div>
<div class="paragraph">
<p>那么，“混合主题”是什么意思呢？图1显示了一篇文章，其中一些单词以三种颜色突出显示：黄色，粉红色和蓝色。关于遗传学的词语用黄色标出; 关于进化生物学的文字用粉红色标出; 有关数据分析的文字标有蓝色。想象一下，本文中的所有单词都是彩色的，然后我们可以将这篇文章表示为主题（即颜色）的混合。</p>
</div>
<div class="paragraph">
<p>图1 :( 此图片来自“概率主题模型”。（David Blei 2012））
<a href="https://camo.githubusercontent.com/464a19ca7cf15ea83e712cd8145afacc46c55cae/68747470733a2f2f7065726c36616476656e742e66696c65732e776f726470726573732e636f6d2f323031382f31322f73637265656e73686f742d66726f6d2d323031382d31322d31302d30302d31342d33312e706e673f773d363830">![图。1</a>](<a href="https://camo.githubusercontent.com/464a19ca7cf15ea83e712cd8145afacc46c55cae/68747470733a2f2f7065726c36616476656e742e66696c65732e776f726470726573732e636f6d2f323031382f31322f73637265656e73686f742d66726f6d2d323031382d31322d31302d30302d31342d33312e706e673f773d363830" class="bare">https://camo.githubusercontent.com/464a19ca7cf15ea83e712cd8145afacc46c55cae/68747470733a2f2f7065726c36616476656e742e66696c65732e776f726470726573732e636f6d2f323031382f31322f73637265656e73686f742d66726f6d2d323031382d31322d31302d30302d31342d33312e706e673f773d363830</a>)</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">好的，那么我将在下一节中演示如何使用Algorithm </dt>
<dd>
<p>LDA。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_建模报价">51.2. 建模报价</h3>
<div class="paragraph">
<p>在本文中，我们将探索<a href="https://www.wikiquote.org/">Wikiquote</a>。Wikiquote是一个提供源代码报价的云源平台。
通过使用Wikiquote API，我们获得用于LDA估计的报价。之后，我们执行LDA并绘制结果。
最后，我们使用生成的模型创建信息检索应用程序。</p>
</div>
<div class="sect3">
<h4 id="_初步">51.2.1. 初步</h4>
<div class="sect4">
<h5 id="_wikiquote_api">Wikiquote API</h5>
<div class="paragraph">
<p>Wikiquote具有<a href="https://en.wikiquote.org/w/api.php?action=help&amp;modules=query">动作API</a>，提供获取Wikiquote资源的方法。
例如，您可以按如下方式获取主页面的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ curl &#34;https://en.wikiquote.org/w/api.php?action=query&amp;prop=revisions&amp;titles=Main%20Page&amp;rvprop=content&amp;format=json&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述命令的结果是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">{&#34;batchcomplete&#34;:&#34;&#34;,&#34;warnings&#34;:{&#34;main&#34;:{&#34;*&#34;:&#34;Subscribe to the mediawiki-api-announce mailing list at &lt;https://lists.wikimedia.org/mailman/listinfo/mediawiki-api-announce&gt; for notice of API deprecations and breaking changes. Use [[Special:ApiFeatureUsage]] to see usage of deprecated features by your application.&#34;},&#34;revisions&#34;:{&#34;*&#34;:&#34;Because \&#34;rvslots\&#34; was not specified, a legacy format has been used for the output. This format is deprecated, and in the future the new format will always be used.&#34;}},&#34;query&#34;:{&#34;pages&#34;:{&#34;1&#34;:{&#34;pageid&#34;:1,&#34;ns&#34;:0,&#34;title&#34;:&#34;Main Page&#34;,&#34;revisions&#34;:[{&#34;contentformat&#34;:&#34;text/x-wiki&#34;,&#34;contentmodel&#34;:&#34;wikitext&#34;,&#34;*&#34;:&#34;\n
{{Main page header}}
\n
{{Main Page Quote of the day}}
\n&lt;/div&gt;\n\n \n{{Main Page Selected pages}}\n{{Main categories}}\n\n\n \n{{New pages}}\n{{Main Page Community}}\n\n\n\n==Wikiquote&#39;s sister projects==\n{{otherwiki}}\n\n==Wikiquote languages==\n{{Wikiquotelang}}\n\n__NOTOC__ __NOEDITSECTION__\n{{noexternallanglinks:ang|simple}}\n[[Category:Main page]]&#34;}]}}}}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_www">WWW</h5>
<div class="paragraph">
<p><a href="https://github.com/zoffixznet/raku-WWW">WWW</a>通过Zoffix Znet是它提供了易于使用的API，包括获取和解析JSON非常简单的库。
例如，正如README所说，您可以轻松地按`jget(URL)&lt;HASHKEY&gt;`样式获取内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say jget(&#39;https://httpbin.org/get?foo=42&amp;bar=x&#39;)&lt;args&gt;&lt;foo&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要安装WWW：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">zef install WWW</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_chartgnuplot">Chart::Gnuplot</h5>
<div class="paragraph">
<p><a href="https://github.com/titsuki/p6-Chart-Gnuplot">Chart::Gnuplot</a> by titsuki是<a href="http://www.gnuplot.info/">gnuplot</a>的绑定。</p>
</div>
<div class="paragraph">
<p>要安装 Chart::Gnuplot：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ zef install Chart::Gnuplot</code></pre>
</div>
</div>
<div class="paragraph">
<p>在本文中，我们使用此模块; 但是，如果你不熟悉gnuplot，有很多选择：<a href="https://github.com/moritz/svg-plot">SVG::Plot</a>，<a href="https://github.com/azawawi/raku-graphics-plplot">Graphics::PLplot</a>，<a href="https://0racle.info/articles/matplotlib_in_p6_intro">通过Inline::Python调用matplotlib函数</a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_来自nltk的stopwords">来自NLTK的Stopwords</h5>
<div class="paragraph">
<p>NLTK是一个用于自然语言处理的工具包。
不仅是 API，它还提供语料库。
您可以通过“70”获得英语的停用词。关键词语料库“：<a href="http://www.nltk.org/nltk_data/">http</a>：//www.nltk.org/nltk_data/</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_练习1获取报价并创建已清理的文档">51.2.2. 练习1：获取报价并创建已清理的文档</h4>
<div class="paragraph">
<p>一开始，我们必须从Wikiquote获取引用并创建干净的文档。</p>
</div>
<div class="paragraph">
<p>本部分的主要目标是根据以下格式创建文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">&lt;docid&gt; &lt;personid&gt; &lt;word&gt; &lt;word&gt; &lt;word&gt; ...
&lt;docid&gt; &lt;personid&gt; &lt;word&gt; &lt;word&gt; &lt;word&gt; ...
&lt;docid&gt; &lt;personid&gt; &lt;word&gt; &lt;word&gt; &lt;word&gt; ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>整个源代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.c;
use WWW;
use URI::Escape;

sub get-members-from-category(Str $category --&gt; List) {
    my $member-url = &#34;https://en.wikiquote.org/w/api.php?action=query&amp;list=categorymembers&amp;cmtitle={$category}&amp;cmlimit=100&amp;format=json&#34;;
    @(jget($member-url)&lt;query&gt;&lt;categorymembers&gt;.map(*&lt;title&gt;));
}

sub get-pages(Str @members, Int $batch = 50 --&gt; List) {
    my Int $start = 0;
    my @pages;
    while $start &lt; @members {
        my $list = @members[$start..^List($start + $batch, +@members).min].map({ uri_escape($_) }).join(&#39;%7C&#39;);
        my $url = &#34;https://en.wikiquote.org/w/api.php?action=query&amp;prop=revisions&amp;rvprop=content&amp;format=json&amp;formatversion=2&amp;titles={$list}&#34;;
        @pages.push($_) for jget($url)&lt;query&gt;&lt;pages&gt;.map({ %(body =&gt; .&lt;revisions&gt;[0]&lt;content&gt;, title =&gt; .&lt;title&gt;) });
        $start += $batch;
    }
    @pages;
}

sub create-documents-from-pages(@pages, @members --&gt; List) {
    my @documents;
    for @pages -&gt; $page {
        my @quotations = $page&lt;body&gt;.split(&#34;\n&#34;)\
        .map(*.subst(/\[\[$&lt;text&gt;=(&lt;-[\[\]|]&gt;+?)\|$&lt;link&gt;=(&lt;-[\[\]|]&gt;+?)\]\]/, { $&lt;text&gt; }, :g))\
        .map(*.subst(/\[\[$&lt;text&gt;=(&lt;-[\[\]|]&gt;+?)\]\]/, { $&lt;text&gt; }, :g))\
        .map(*.subst(&#34;[&#34;, &#34;[&#34;, :g))\
        .map(*.subst(&#34;]&#34;, &#34;]&#34;, :g))\
        .map(*.subst(&#34;&amp;amp;&#34;, &#34;&amp;&#34;, :g))\
        .map(*.subst(&#34;&amp;nbsp;&#34;, &#34;&#34;, :g))\
        .map(*.subst(/:i [ \&lt;\/?\s?br\&gt; | \&lt;br\s?\/?\&gt; ]/, &#34; &#34;, :g))\
        .grep(/^\*&lt;-[*]&gt;/)\
        .map(*.subst(/^\*\s+/, &#34;&#34;));

        # Note: The order of array wikiquote API returned is agnostic.
        my Int $index = @members.pairs.grep({ .value eq $page&lt;title&gt; }).map(*.key).head;
        @documents.push(%(body =&gt; $_, personid =&gt; $index)) for @quotations;
    }
    @documents.sort({ $^a&lt;personid&gt; &lt;=&gt; $^b&lt;personid&gt; }).pairs.map({ %(docid =&gt; .key, personid =&gt; .value&lt;personid&gt;, body =&gt; .value&lt;body&gt;) }).list
}

my Str @members = get-members-from-category(&#34;Category:1954_births&#34;);
my @pages = get-pages(@members);
my @documents = create-documents-from-pages(@pages, @members);

my $docfh = open &#34;documents.txt&#34;, :w;
$docfh.say((.&lt;docid&gt;, .&lt;personid&gt;, .&lt;body&gt;).join(&#34; &#34;)) for @documents;
$docfh.close;

my $memfh = open &#34;members.txt&#34;, :w;
$memfh.say($_) for @members;
$memfh.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，我们获得“Category：1954births”页面中列出的成员。我选择了Raku设计师诞生的那一年：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Str @members = get-members-from-category(&#34;Category:1954_births&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中，`get-members-from-category`通过维基语录API获取成员：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub get-members-from-category(Str $category --&gt; List) {
    my $member-url = &#34;https://en.wikiquote.org/w/api.php?action=query&amp;list=categorymembers&amp;cmtitle={$category}&amp;cmlimit=100&amp;format=json&#34;;
    @(jget($member-url)&lt;query&gt;&lt;categorymembers&gt;.map(*&lt;title&gt;));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，调用`get-pages`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @pages = get-pages(@members);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>get-pages</code> 获取给定标题（即成员）页面的子例程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub get-pages(Str @members, Int $batch = 50 --&gt; List) {
    my Int $start = 0;
    my @pages;
    while $start &lt; @members {
        my $list = @members[$start..^List($start + $batch, +@members).min].map({ uri_escape($_) }).join(&#39;%7C&#39;);
        my $url = &#34;https://en.wikiquote.org/w/api.php?action=query&amp;prop=revisions&amp;rvprop=content&amp;format=json&amp;formatversion=2&amp;titles={$list}&#34;;
        @pages.push($_) for jget($url)&lt;query&gt;&lt;pages&gt;.map({ %(body =&gt; .&lt;revisions&gt;[0]&lt;content&gt;, title =&gt; .&lt;title&gt;) });
        $start += $batch;
    }
    @pages;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中`@members[$start..^List($start + $batch, +@members).min]<code>是一段长度</code>$batch`，并且切片的元素由百分比编码`uri_escase`和联合`%7C`（即，编码的管道符号百分比）。
在这种情况下，结果之一`$list`是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">Mumia%20Abu-Jamal%7CRene%20Balcer%7CIain%20Banks%7CGerard%20Batten%7CChristie%20Brinkley%7CJames%20Cameron%20%28director%29%7CEugene%20Chadbourne%7CJackie%20Chan%7CChang%20Yu-hern%7CLee%20Child%7CHugo%20Ch%C3%A1vez%7CDon%20Coscarelli%7CElvis%20Costello%7CDaayiee%20Abdullah%7CThomas%20H.%20Davenport%7CGerardine%20DeSanctis%7CAl%20Di%20Meola%7CKevin%20Dockery%20%28author%29%7CJohn%20Doe%20%28musician%29%7CF.%20J.%20Duarte%7CIain%20Duncan%20Smith%7CHerm%20Edwards%7CAbdel%20Fattah%20el-Sisi%7CRob%20Enderle%7CRecep%20Tayyip%20Erdo%C4%9Fan%7CAlejandro%20Pe%C3%B1a%20Esclusa%7CHarvey%20Fierstein%7CCarly%20Fiorina%7CGary%20L.%20Francione%7CAshrita%20Furman%7CMary%20Gaitskill%7CGeorge%20Galloway%7C%C5%BDeljko%20Glasnovi%C4%87%7CGary%20Hamel%7CFran%C3%A7ois%20Hollande%7CKazuo%20Ishiguro%7CJean-Claude%20Juncker%7CAnish%20Kapoor%7CGuy%20Kawasaki%7CRobert%20Francis%20Kennedy%2C%20Jr.%7CLawrence%20M.%20Krauss%7CAnatoly%20Kudryavitsky%7CAnne%20Lamott%7CJoep%20Lange%7CAng%20Lee%7CLi%20Bin%7CRay%20Liotta%7CPeter%20Lipton%7CJames%20D.%20Macdonald%7CKen%20MacLeod</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>get-pages`子例程使用哈希上下文相关器</code>%()`来创建哈希序列：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@pages.push($_) for jget($url)&lt;query&gt;&lt;pages&gt;.map({ %(body =&gt; .&lt;revisions&gt;[0]&lt;content&gt;, title =&gt; .&lt;title&gt;) });</code></pre>
</div>
</div>
<div class="paragraph">
<p>在那之后，我们调用 <code>create-documents-from-pages</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @documents = create-documents-from-pages(@pages, @members);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>create-documents-from-pages</code> 从每个页面创建文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub create-documents-from-pages(@pages, @members --&gt; List) {
    my @documents;
    for @pages -&gt; $page {
        my @quotations = $page&lt;body&gt;.split(&#34;\n&#34;)\
        .map(*.subst(/\[\[$&lt;text&gt;=(&lt;-[\[\]|]&gt;+?)\|$&lt;link&gt;=(&lt;-[\[\]|]&gt;+?)\]\]/, { $&lt;text&gt; }, :g))\
        .map(*.subst(/\[\[$&lt;text&gt;=(&lt;-[\[\]|]&gt;+?)\]\]/, { $&lt;text&gt; }, :g))\
        .map(*.subst(&#34;[&#34;, &#34;[&#34;, :g))\
        .map(*.subst(&#34;]&#34;, &#34;]&#34;, :g))\
        .map(*.subst(&#34;&amp;amp;&#34;, &#34;&amp;&#34;, :g))\
        .map(*.subst(&#34;&amp;nbsp;&#34;, &#34;&#34;, :g))\
        .map(*.subst(/:i [ \&lt;\/?\s?br\&gt; | \&lt;br\s?\/?\&gt; ]/, &#34; &#34;, :g))\
        .grep(/^\*&lt;-[*]&gt;/)\
        .map(*.subst(/^\*\s+/, &#34;&#34;));

        # Note: The order of array wikiquote API returned is agnostic.
        my Int $index = @members.pairs.grep({ .value eq $page&lt;title&gt; }).map(*.key).head;
        @documents.push(%(body =&gt; $_, personid =&gt; $index)) for @quotations;
    }
    @documents.sort({ $^a&lt;personid&gt; &lt;=&gt; $^b&lt;personid&gt; }).pairs.map({ %(docid =&gt; .key, personid =&gt; .value&lt;personid&gt;, body =&gt; .value&lt;body&gt;) }).list
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中`.map(<strong>.subst(/\<a href="https://docs.raku.org/language/regexes#Named_captures">\[$&lt;text&gt;=(←[\[]|</a>&gt;?)\|$&lt;link&gt;=(&lt;-[\[\]|]&gt;?)\]\]/, { $&lt;text&gt; }, :g))<code>和</code>.map(</strong>.subst(/\[\[$&lt;text&gt;=(←[\[\]|]&gt;+?)\]\]/, { $&lt;text&gt; }, :g))<code>是隐藏命令，提取文本以显示和删除文本，以便从锚文本进行内部链接。例如，</code><a id="Perl"></a><code>被缩减为`Perl</code>。有关更多语法信息，请参阅：[https]：<a href="https://docs.raku.org/language/regexes#Named_captures">//docs.raku.org/language/regexes#Named_captures</a>或<a href="https://docs.raku.org/routine/subst" class="bare">https://docs.raku.org/routine/subst</a></p>
</div>
<div class="paragraph">
<p>经过一些清理操作（.eg，<code>.map(*.subst(&#34;[&#34;, &#34;[&#34;, :g))</code>）后，我们提取引号线。</p>
</div>
<div class="paragraph">
<p>`.grep(/^*←[*]&gt;/)`查找以单星号开头的行，因为大多数引号都出现在这种行中。</p>
</div>
<div class="paragraph">
<p>接下来，`.map(<strong>.subst(/^\</strong>\s+/, &#34;&#34;))`删除每个星号，因为星号本身不是每个报价的组成部分。</p>
</div>
<div class="paragraph">
<p>最后，我们保存文档和成员（即标题）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $docfh = open &#34;documents.txt&#34;, :w;
$docfh.say((.&lt;docid&gt;, .&lt;personid&gt;, .&lt;body&gt;).join(&#34; &#34;)) for @documents;
$docfh.close;

my $memfh = open &#34;members.txt&#34;, :w;
$memfh.say($_) for @members;
$memfh.close;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_练习2执行lda并可视化结果">51.2.3. 练习2：执行LDA并可视化结果</h4>
<div class="paragraph">
<p>在上一节中，我们保存了已清理的文档。
在本节中，我们使用文档进行LDA估计并将结果可视化。
本部分的目标是绘制文档主题分布并编写主题词表。</p>
</div>
<div class="paragraph">
<p>整个源代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.c;
use Algorithm::LDA;
use Algorithm::LDA::Formatter;
use Algorithm::LDA::LDAModel;
use Chart::Gnuplot;
use Chart::Gnuplot::Subset;

sub create-model(@documents --&gt; Algorithm::LDA::LDAModel) {
    my $stopwords = &#34;stopwords/english&#34;.IO.lines.Set;
    my &amp;tokenizer = -&gt; $line { $line.words.map(*.lc).grep(-&gt; $w { ($stopwords !(cont) $w) and $w !~~ /^[ &lt;:S&gt; | &lt;:P&gt; ]+$/ }) };
    my ($documents, $vocabs) = Algorithm::LDA::Formatter.from-plain(@documents.map({ my ($, $, *@body) = .words; @body.join(&#34; &#34;) }), &amp;tokenizer);
    my Algorithm::LDA $lda .= new(:$documents, :$vocabs);
    my Algorithm::LDA::LDAModel $model = $lda.fit(:num-topics(10), :num-iterations(500), :seed(2018));
    $model
}

sub plot-topic-distribution($model, @members, @documents, $search-regex = rx/Larry/) {
    my $target-personid = @members.pairs.grep({ .value ~~ $search-regex }).map(*.key).head;
    my $docid = @documents.map({ my ($docid, $personid, *@body) = .words; %(docid =&gt; $docid, personid =&gt; $personid, body =&gt; @body.join(&#34; &#34;)) })\
    .grep({ .&lt;personid&gt; == $target-personid and .&lt;body&gt; ~~ /:i &lt;&lt; perl &gt;&gt;/}).map(*&lt;docid&gt;).head;

    note(&#34;@documents[$docid] is selected&#34;);
    my ($row-size, $col-size) = $model.document-topic-matrix.shape;
    my @doc-topic = gather for ($docid X ^$col-size) -&gt; ($i, $j) { take $model.document-topic-matrix[$i;$j]; }
    my Chart::Gnuplot $gnu .= new(:terminal(&#34;png&#34;), :filename(&#34;topics.png&#34;));
    $gnu.command(&#34;set boxwidth 0.5 relative&#34;);
    my AnyTicsTic @tics = @doc-topic.pairs.map({ %(:label(.key), :pos(.key)) });
    $gnu.legend(:off);
    $gnu.xlabel(:label(&#34;Topic&#34;));
    $gnu.ylabel(:label(&#34;P(z|theta,d)&#34;));
    $gnu.xtics(:tics(@tics));
    $gnu.plot(:vertices(@doc-topic.pairs.map({ @(.key, .value.exp) })), :style(&#34;boxes&#34;), :fill(&#34;solid&#34;));
    $gnu.dispose;
}

sub write-nbest($model) {
  my $topics := $model.nbest-words-per-topic(10);
  for ^(10/5) -&gt; $part-i {
    say &#34;|&#34; ~ (^5).map(-&gt; $t { &#34;topic { $part-i * 5 + $t }&#34; }).join(&#34;|&#34;) ~ &#34;|&#34;;
    say &#34;|&#34; ~ (^5).map({ &#34;----&#34; }).join(&#34;|&#34;) ~ &#34;|&#34;;
    for ^10 -&gt; $rank {
        say &#34;|&#34; ~ gather for ($part-i * 5)..^($part-i * 5 + 5) -&gt; $topic {
            take @($topics)[$topic;$rank].key;
        }.join(&#34;|&#34;) ~ &#34;|&#34;;
    }
    &#34;&#34;.say;
  }
}

sub save-model($model) {
  my @document-topic-matrix := $model.document-topic-matrix;
  my ($document-size, $topic-size) = @document-topic-matrix.shape;
  my $doctopicfh = open &#34;document-topic.txt&#34;, :w;

  $doctopicfh.say: ($document-size, $topic-size).join(&#34; &#34;);
  for ^$document-size -&gt; $doc-i {
    $doctopicfh.say: gather for ^$topic-size -&gt; $topic { take @document-topic-matrix[$doc-i;$topic] }.join(&#34; &#34;);
  }
  $doctopicfh.close;

  my @topic-word-matrix := $model.topic-word-matrix;
  my ($, $word-size) = @topic-word-matrix.shape;
  my $topicwordfh = open &#34;topic-word.txt&#34;, :w;

  $topicwordfh.say: ($topic-size, $word-size).join(&#34; &#34;);
  for ^$topic-size -&gt; $topic-i {
    $topicwordfh.say: gather for ^$word-size -&gt; $word { take @topic-word-matrix[$topic-i;$word] }.join(&#34; &#34;);
  }
  $topicwordfh.close;

  my @vocabulary := $model.vocabulary;
  my $vocabfh = open &#34;vocabulary.txt&#34;, :w;

  $vocabfh.say($_) for @vocabulary;
  $vocabfh.close;
}

my @documents = &#34;documents.txt&#34;.IO.lines;
my $model = create-model(@documents);
my @members = &#34;members.txt&#34;.IO.lines;
plot-topic-distribution($model, @members, @documents);
write-nbest($model);
save-model($model);</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，我们加载已清理的文档并调用`create-model`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @documents = &#34;documents.txt&#34;.IO.lines;
my $model = create-model(@documents);</code></pre>
</div>
</div>
<div class="paragraph">
<p>`create-model`通过加载给定文档来创建LDA模型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub create-model(@documents --&gt; Algorithm::LDA::LDAModel) {
    my $stopwords = &#34;stopwords/english&#34;.IO.lines.Set;
    my &amp;tokenizer = -&gt; $line { $line.words.map(*.lc).grep(-&gt; $w { ($stopwords !(cont) $w) and $w !~~ /^[ &lt;:S&gt; | &lt;:P&gt; ]+$/ }) };
    my ($documents, $vocabs) = Algorithm::LDA::Formatter.from-plain(@documents.map({ my ($, $, *@body) = .words; @body.join(&#34; &#34;) }), &amp;tokenizer);
    my Algorithm::LDA $lda .= new(:$documents, :$vocabs);
    my Algorithm::LDA::LDAModel $model = $lda.fit(:num-topics(10), :num-iterations(500), :seed(2018));
    $model
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$stopwords`来自NLTK的一组英语停用词在哪里（我提到了初步部分），并且</code>&amp;tokenizer`是一个自定义标记器`Algorithm::LDA::Formatter.from-plain`。标记器转换给定句子如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1. 通过空格拆分句子并生成令牌列表。</p>
</li>
<li>
<p>1. 用小写字符替换标记的每个字符。</p>
</li>
<li>
<p>1. 删除停用词列表中存在的令牌或分类为符号或标点符号的单长令牌。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Algorithm::LDA::Formatter.from-plain</code> 创建数字原生文档（即，文档中的每个单词被映射到其对应的词汇表id，并且该id由C int32表示）和来自文本列表的词汇表。</p>
</div>
<div class="paragraph">
<p>在`Algorithm::LDA`使用上述数值文档创建实例后，我们可以通过启动LDA估计`Algorithm::LDA.fit`。在此示例中，我们将主题数设置为10，将迭代次数设置为100，将srand的种子设置为2018。</p>
</div>
<div class="paragraph">
<p>接下来，我们绘制文档主题分布。在此绘图之前，我们加载已保存的成员</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @members = &#34;members.txt&#34;.IO.lines;
plot-topic-distribution($model, @members, @documents);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>plot-topic-distribution</code> 使用Chart </dt>
<dd>
<p>Gnuplot绘制主题分布：</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub plot-topic-distribution($model, @members, @documents, $search-regex = rx/Larry/) {
    my $target-personid = @members.pairs.grep({ .value ~~ $search-regex }).map(*.key).head;
    my $docid = @documents.map({ my ($docid, $personid, *@body) = .words; %(docid =&gt; $docid, personid =&gt; $personid, body =&gt; @body.join(&#34; &#34;)) })\
    .grep({ .&lt;personid&gt; == $target-personid and .&lt;body&gt; ~~ /:i &lt;&lt; perl &gt;&gt;/}).map(*&lt;docid&gt;).head;

    note(&#34;@documents[$docid] is selected&#34;);
    my ($row-size, $col-size) = $model.document-topic-matrix.shape;
    my @doc-topic = gather for ($docid X ^$col-size) -&gt; ($i, $j) { take $model.document-topic-matrix[$i;$j]; }
    my Chart::Gnuplot $gnu .= new(:terminal(&#34;png&#34;), :filename(&#34;topics.png&#34;));
    $gnu.command(&#34;set boxwidth 0.5 relative&#34;);
    my AnyTicsTic @tics = @doc-topic.pairs.map({ %(:label(.key), :pos(.key)) });
    $gnu.legend(:off);
    $gnu.xlabel(:label(&#34;Topic&#34;));
    $gnu.ylabel(:label(&#34;P(z|theta,d)&#34;));
    $gnu.xtics(:tics(@tics));
    $gnu.plot(:vertices(@doc-topic.pairs.map({ @(.key, .value.exp) })), :style(&#34;boxes&#34;), :fill(&#34;solid&#34;));
    $gnu.dispose;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，我们绘制了Larry Wall的引文的主题分布（“虽然Perl口号是不仅仅有一种方法可以做到这一点，但我还是犹豫了10种方法来做某事。”）：</p>
</div>
<div class="paragraph">
<p>!<a href="https://camo.githubusercontent.com/787f04318d3c341aa81deaa2c2793054d48403ee/68747470733a2f2f7065726c36616476656e742e66696c65732e776f726470726573732e636f6d2f323031382f31322f746f706963732d312e706e673f773d363430">img</a></p>
</div>
<div class="paragraph">
<p>在绘图之后，我们称之为`write-nbest`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">write-nbest($model);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在LDA中，XXX表示的主题表示为单词列表。`write-nbest`写一个降价风格的主题词分配表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub write-nbest($model) {
  my $topics := $model.nbest-words-per-topic(10);
  for ^(10/5) -&gt; $part-i {
    say &#34;|&#34; ~ (^5).map(-&gt; $t { &#34;topic { $part-i * 5 + $t }&#34; }).join(&#34;|&#34;) ~ &#34;|&#34;;
    say &#34;|&#34; ~ (^5).map({ &#34;----&#34; }).join(&#34;|&#34;) ~ &#34;|&#34;;
    for ^10 -&gt; $rank {
        say &#34;|&#34; ~ gather for ($part-i * 5)..^($part-i * 5 + 5) -&gt; $topic {
            take @($topics)[$topic;$rank].key;
        }.join(&#34;|&#34;) ~ &#34;|&#34;;
    }
    &#34;&#34;.say;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果是：</p>
</div>
<div class="paragraph">
<p>| topic 0  | topic 1   | topic 2  | topic 3  | topic 4   |
| -------- | --------- | -------- | -------- | --------- |
| would    | scotland  | black    | could    | one       |
| itâ€™s   | country   | mr.      | first    | work      |
| believe  | one       | lot      | law      | new       |
| one      | political | play     | college  | human     |
| took     | world     | official | basic    | process   |
| much     | need      | new      | speak    | business  |
| donâ€™t  | must      | reacher  | language | becomes   |
| ever     | national  | five     | every    | good      |
| far      | many      | car      | matter   | world     |
| fighting | us        | road     | right    | knowledge |</p>
</div>
<div class="paragraph">
<p>| topic 5 | topic 6   | topic 7 | topic 8   | topic 9 |
| ------- | --------- | ------- | --------- | ------- |
| apple   | united    | people  | like      | */      |
| likely  | war       | would   | one       | die     |
| company | states    | i’m     | something | und     |
| jobs    | years     | know    | think     | quantum |
| even    | would     | think   | way       | play    |
| steve   | american  | want    | things    | noble   |
| life    | president | get     | perl      | home    |
| like    | human     | going   | long      | dog     |
| end     | must      | say     | always    | student |
| small   | us        | go      | really    | ist     |</p>
</div>
<div class="paragraph">
<p>正如你所看到的那样，引用“虽然Perl Slogan不仅仅是一种方法，我还有10种方法可以做某事。”包含“one”，“way”和“perl”。这就是为什么这个引用主要由主题8组成的原因。</p>
</div>
<div class="paragraph">
<p>对于下一节，我们按`save-model`子程序保存模型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub save-model($model) {
  my @document-topic-matrix := $model.document-topic-matrix;
  my ($document-size, $topic-size) = @document-topic-matrix.shape;
  my $doctopicfh = open &#34;document-topic.txt&#34;, :w;

  $doctopicfh.say: ($document-size, $topic-size).join(&#34; &#34;);
  for ^$document-size -&gt; $doc-i {
    $doctopicfh.say: gather for ^$topic-size -&gt; $topic { take @document-topic-matrix[$doc-i;$topic] }.join(&#34; &#34;);
  }
  $doctopicfh.close;

  my @topic-word-matrix := $model.topic-word-matrix;
  my ($, $word-size) = @topic-word-matrix.shape;
  my $topicwordfh = open &#34;topic-word.txt&#34;, :w;

  $topicwordfh.say: ($topic-size, $word-size).join(&#34; &#34;);
  for ^$topic-size -&gt; $topic-i {
    $topicwordfh.say: gather for ^$word-size -&gt; $word { take @topic-word-matrix[$topic-i;$word] }.join(&#34; &#34;);
  }
  $topicwordfh.close;

  my @vocabulary := $model.vocabulary;
  my $vocabfh = open &#34;vocabulary.txt&#34;, :w;

  $vocabfh.say($_) for @vocabulary;
  $vocabfh.close;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_练习3创建报价搜索引擎">51.2.4. 练习3：创建报价搜索引擎</h4>
<div class="paragraph">
<p>在本节中，我们创建一个报价搜索引擎，它使用上一节中创建的模型。
更具体地说，我们创建了基于LDA的文档模型（Xing Wei和W. Bruce Croft 2006），并创建了一个可以搜索报价的CLI工具。（注意，“token”和“word”这两个词在本节中是可互换的）</p>
</div>
<div class="paragraph">
<p>整个源代码是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.c;

sub MAIN(Str :$query!) {
    my \doc-topic-iter = &#34;document-topic.txt&#34;.IO.lines.iterator;
    my \topic-word-iter = &#34;topic-word.txt&#34;.IO.lines.iterator;
    my ($document-size, $topic-size) = doc-topic-iter.pull-one.words;
    my ($, $word-size) = topic-word-iter.pull-one.words;

    my Num @document-topic[$document-size;$topic-size];
    my Num @topic-word[$topic-size;$word-size];

    for ^$document-size -&gt; $doc-i {
        my \maybe-line := doc-topic-iter.pull-one;
        die &#34;Error: Something went wrong&#34; if maybe-line =:= IterationEnd;
        my Num @line = @(maybe-line).words&gt;&gt;.Num;
        for ^@line {
            @document-topic[$doc-i;$_] = @line[$_];
        }
    }

    for ^$topic-size -&gt; $topic-i {
        my \maybe-line := topic-word-iter.pull-one;
        die &#34;Error: Something went wrong&#34; if maybe-line =:= IterationEnd;
        my Num @line = @(maybe-line).words&gt;&gt;.Num;
        for ^@line {
            @topic-word[$topic-i;$_] = @line[$_];
        }
    }

    my %vocabulary = &#34;vocabulary.txt&#34;.IO.lines.pairs&gt;&gt;.antipair.hash;
    my @members = &#34;members.txt&#34;.IO.lines;
    my @documents = &#34;documents.txt&#34;.IO.lines;
    my @docbodies = @documents.map({ my ($, $, *@body) = .words; @body.join(&#34; &#34;) });
    my %doc-to-person = @documents.map({ my ($docid, $personid, $) = .words; %($docid =&gt; $personid) }).hash;
    my @query = $query.words.map(*.lc);

    my @sorted-list = gather for ^$document-size -&gt; $doc-i {
        my Num $log-prob = gather for @query -&gt; $token {
            my Num $log-ml-prob = Pml(@docbodies, $doc-i, $token);
            my Num $log-lda-prob = Plda($token, $topic-size, $doc-i, %vocabulary, @document-topic, @topic-word);
            take log-sum(log(0.2) + $log-ml-prob, log(0.8) + $log-lda-prob);
        }.sum;
        take %(doc-i =&gt; $doc-i, log-prob =&gt; $log-prob);
    }.sort({ $^b&lt;log-prob&gt; &lt;=&gt; $^a&lt;log-prob&gt; });

    for ^10 {
        my $docid = @sorted-list[$_]&lt;doc-i&gt;;
        sprintf(&#34;\&#34;%s\&#34; by %s %f&#34;, @docbodies[$docid], @members[%doc-to-person{$docid}], @sorted-list[$_]&lt;log-prob&gt;).say;
    }

}

sub Pml(@docbodies, $doc-i, $token --&gt; Num) {
    my Int $num-tokens = @docbodies[$doc-i].words.grep({ /:i^ $token $/ }).elems;
    my Int $total-tokens = @docbodies[$doc-i].words.elems;
    return -100e0 if $total-tokens == 0 or $num-tokens == 0;
    log($num-tokens) - log($total-tokens);
}

sub Plda($token, $topic-size, $doc-i, %vocabulary is raw, @document-topic is raw, @topic-word is raw --&gt; Num) {
    gather for ^$topic-size -&gt; $topic {
        if %vocabulary{$token}:exists {
            take @document-topic[$doc-i;$topic] + @topic-word[$topic;%vocabulary{$token}];
        } else {
            take -100e0;
        }
    }.reduce(&amp;log-sum);
}

sub log-sum(Num $log-a, Num $log-b --&gt; Num) {
    if $log-a &lt; $log-b {
        return $log-b + log(1 + exp($log-a - $log-b))
    } else {
        return $log-a + log(1 + exp($log-b - $log-a))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在beggining，我们加载保存的模型和准备`@document-topic`，<code>@topic-word</code>，<code>%vocabulary</code>，<code>@documents</code>，<code>@docbodies</code>，<code>%doc-to-person`和</code>@members`</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> my \doc-topic-iter = &#34;document-topic.txt&#34;.IO.lines.iterator;
    my \topic-word-iter = &#34;topic-word.txt&#34;.IO.lines.iterator;
    my ($document-size, $topic-size) = doc-topic-iter.pull-one.words;
    my ($, $word-size) = topic-word-iter.pull-one.words;

    my Num @document-topic[$document-size;$topic-size];
    my Num @topic-word[$topic-size;$word-size];

    for ^$document-size -&gt; $doc-i {
        my \maybe-line = doc-topic-iter.pull-one;
        die &#34;Error: Something went wrong&#34; if maybe-line =:= IterationEnd;
        my Num @line = @(maybe-line).words&gt;&gt;.Num;
        for ^@line {
            @document-topic[$doc-i;$_] = @line[$_];
        }
    }

    for ^$topic-size -&gt; $topic-i {
        my \maybe-line = topic-word-iter.pull-one;
        die &#34;Error: Something went wrong&#34; if maybe-line =:= IterationEnd;
        my Num @line = @(maybe-line).words&gt;&gt;.Num;
        for ^@line {
            @topic-word[$topic-i;$_] = @line[$_];
        }
    }

    my %vocabulary = &#34;vocabulary.txt&#34;.IO.lines.pairs&gt;&gt;.antipair.hash;
    my @members = &#34;members.txt&#34;.IO.lines;
    my @documents = &#34;documents.txt&#34;.IO.lines;
    my @docbodies = @documents.map({ my ($, $, *@body) = .words; @body.join(&#34; &#34;) });
    my %doc-to-person = @documents.map({ my ($docid, $personid, $) = .words; %($docid =&gt; $personid) }).hash;</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，我们`@query`使用选项设置`:$query`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @query = $query.words.map(*.lc);</code></pre>
</div>
</div>
<div class="paragraph">
<p>之后，我们计算`P(query|document)`基于Eq 的概率。前面提到的9篇文章（注意我们使用对数来避免不流动并将参数mu设置为零）并对它们进行排序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    my @sorted-list = gather for ^$document-size -&gt; $doc-i {
        my Num $log-prob = gather for @query -&gt; $token {
            my Num $log-ml-prob = Pml(@docbodies, $doc-i, $token);
            my Num $log-lda-prob = Plda($token, $topic-size, $doc-i, %vocabulary, @document-topic, @topic-word);
            take log-sum(log(0.2) + $log-ml-prob, log(0.8) + $log-lda-prob);
        }.sum;
        take %(doc-i =&gt; $doc-i, log-prob =&gt; $log-prob);
    }.sort({ $^b&lt;log-prob&gt; &lt;=&gt; $^a&lt;log-prob&gt; });</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Plda`为每个主题添加给定文档概率（即lnP（主题| theta，文档））和单词给定主题概率（即lnP（word | phi，topic））的对数主题，并将它们加起来</code>.reduce(&amp;log-sum);`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub Plda($token, $topic-size, $doc-i, %vocabulary is raw, @document-topic is raw, @topic-word is raw --&gt; Num) {
    gather for ^$topic-size -&gt; $topic {
        if %vocabulary{$token}:exists {
            take @document-topic[$doc-i;$topic] + @topic-word[$topic;%vocabulary{$token}];
        } else {
            take -100e0;
        }
    }.reduce(&amp;log-sum);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而且 <code>Pml</code>（ml表示最大似然）计数`$token`并将其标准化为文档中的总标记（注意，此计算也在日志空间中进行）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub Pml(@docbodies, $doc-i, $token --&gt; Num) {
    my Int $num-tokens = @docbodies[$doc-i].words.grep({ /:i^ $token $/ }).elems;
    my Int $total-tokens = @docbodies[$doc-i].words.elems;
    return -100e0 if $total-tokens == 0 or $num-tokens == 0;
    log($num-tokens) - log($total-tokens);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>好的，那就让我们执行吧！</p>
</div>
<div class="paragraph">
<p>查询“perl”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">$ raku search-quotation.p6 --query=&#34;perl&#34;
&#34;Perl will always provide the null.&#34; by Larry Wall -3.301156
&#34;Perl programming is an *empirical* science!&#34; by Larry Wall -3.345189
&#34;The whole intent of Perl 5&#39;s module system was to encourage the growth of Perl culture rather than the Perl core.&#34; by Larry Wall -3.490238
&#34;I dunno, I dream in Perl sometimes...&#34; by Larry Wall -3.491790
&#34;At many levels, Perl is a &#39;diagonal&#39; language.&#34; by Larry Wall -3.575779
&#34;Almost nothing in Perl serves a single purpose.&#34; by Larry Wall -3.589218
&#34;Perl has a long tradition of working around compilers.&#34; by Larry Wall -3.674111
&#34;As for whether Raku will replace Perl 5, yeah, probably, in about 40 years or so.&#34; by Larry Wall -3.684454
&#34;Well, I think Perl should run faster than C.&#34; by Larry Wall -3.771155
&#34;It&#39;s certainly easy to calculate the average attendance for Perl conferences.&#34; by Larry Wall -3.864075</code></pre>
</div>
</div>
<div class="paragraph">
<p>查询“apple”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku search-quotation.p6 --query=&#34;apple&#34;
&#34;Steve Jobs is the&#34;With phones moving to technologies such as Apple Pay, an unwillingness to assure security could create a Target-like exposure that wipes Apple out of the market.&#34; by Rob Enderle -3.841538
&#34;*:From Joint Apple / HP press release dated 1 January 2004 available [http://www.apple.com/pr/library/2004/jan/08hp.html here].&#34; by Carly Fiorina -3.904489
&#34;Samsung did to Apple what Apple did to Microsoft, skewering its devoted users and reputation, only better. ... There is a way for Apple to fight back, but the company no longer has that skill, and apparently doesn&#39;t know where to get it, either.&#34; by Rob Enderle -3.940359
&#34;[W]hen it came to the iWatch, also a name that Apple didn&#39;t own, Apple walked away from it and instead launched the Apple Watch. Certainly, no risk of litigation, but the product&#39;s sales are a fraction of what they otherwise might have been with the proper name and branding.&#34; by Rob Enderle -4.152145
&#34;[W]hen Apple wanted the name &#34;iPhone&#34; and it was owned by Cisco, Steve Jobs just took it, and his legal team executed so he could keep it. It turned out that doing this was surprisingly inexpensive. And, as the Apple Watch showcased, the Apple Phone likely would not have sold anywhere near as well as the iPhone.&#34; by Rob Enderle -4.187223
&#34;The cause of [Apple v. Qualcomm] appears to be an effort by Apple to pressure Qualcomm into providing a unique discount, largely because Apple has run into an innovation wall, is under increased competition from firms like Samsung, and has moved to a massive cost reduction strategy. (I&#39;ve never known this to end well, as it causes suppliers to create unreliable components and outright fail.)&#34; by Rob Enderle -4.318575
&#34;Apple tends to aggressively work to not discover problems with products that are shipped and certainly not talk about them.&#34; by Rob Enderle -4.380863
&#34;Apple no longer owns the tablet market, and will likely lose dominance this year or next. ... this level of sustained dominance doesn&#39;t appear to recur with the same vendor even if it launched the category.&#34; by Rob Enderle -4.397954
&#34;Apple is becoming more and more like a typical tech firm â€” that is, long on technology and short on magic. ... Apple is drifting closer and closer to where it was back in the 1990s. It offers advancements that largely follow those made by others years earlier, product proliferation, a preference for more over simple elegance, and waning excitement.&#34; by Rob Enderle -4.448473
&#34;[T]he litigation between Qualcomm and Apple/Intel ... is weird. What makes it weird is that Intel appears to think that by helping Apple drive down Qualcomm prices, it will gain an advantage, but since its only value is as a lower cost, lower performing, alternative to Qualcomm&#39;s modems, the result would be more aggressively priced better alternatives to Intel&#39;s offerings from Qualcomm/Broadcom, wiping Intel out of the market. On paper, this is a lose/lose for Intel and even for Apple. The lower prices would flow to Apple competitors as well, lowering the price of competing phones. So, Apple would not get a lasting benefit either.&#34; by Rob Enderle -4.469852 Ronald McDonald of Apple, he is the face.&#34; by Rob Enderle -3.822949
&#34;With phones moving to technologies such as Apple Pay, an unwillingness to assure security could create a Target-like exposure that wipes Apple out of the market.&#34; by Rob Enderle -3.849055
&#34;*:From Joint Apple / HP press release dated 1 January 2004 available [http://www.apple.com/pr/library/2004/jan/08hp.html here].&#34; by Carly Fiorina -3.895163
&#34;Samsung did to Apple what Apple did to Microsoft, skewering its devoted users and reputation, only better. ... There is a way for Apple to fight back, but the company no longer has that skill, and apparently doesn&#39;t know where to get it, either.&#34; by Rob Enderle -4.052616
&#34;*** The previous line contains the naughty word &#39;$&amp;&#39;.\n if /(ibm|apple|awk)/; # :-)&#34; by Larry Wall -4.088445
&#34;The cause of [Apple v. Qualcomm] appears to be an effort by Apple to pressure Qualcomm into providing a unique discount, largely because Apple has run into an innovation wall, is under increased competition from firms like Samsung, and has moved to a massive cost reduction strategy. (I&#39;ve never known this to end well, as it causes suppliers to create unreliable components and outright fail.)&#34; by Rob Enderle -4.169533
&#34;[T]he litigation between Qualcomm and Apple/Intel ... is weird. What makes it weird is that Intel appears to think that by helping Apple drive down Qualcomm prices, it will gain an advantage, but since its only value is as a lower cost, lower performing, alternative to Qualcomm&#39;s modems, the result would be more aggressively priced better alternatives to Intel&#39;s offerings from Qualcomm/Broadcom, wiping Intel out of the market. On paper, this is a lose/lose for Intel and even for Apple. The lower prices would flow to Apple competitors as well, lowering the price of competing phones. So, Apple would not get a lasting benefit either.&#34; by Rob Enderle -4.197869
&#34;Apple tends to aggressively work to not discover problems with products that are shipped and certainly not talk about them.&#34; by Rob Enderle -4.204618
&#34;Today&#39;s tech companies aren&#39;t built to last, as Apple&#39;s recent earnings report shows all too well.&#34; by Rob Enderle -4.209901
&#34;[W]hen it came to the iWatch, also a name that Apple didn&#39;t own, Apple walked away from it and instead launched the Apple Watch. Certainly, no risk of litigation, but the product&#39;s sales are a fraction of what they otherwise might have been with the proper name and branding.&#34; by Rob Enderle -4.238582</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_结论_6">51.3. 结论</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">在本文中，我们探索了Wikiquote，并使用Algoritm </dt>
<dd>
<p>LDA创建了一个LDA模型。
之后我们构建了一个信息检索应用程序。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>感谢您阅读我的文章！下次见！</p>
</div>
</div>
<div class="sect2">
<h3 id="_引文_2">51.4. 引文</h3>
<div class="ulist">
<ul>
<li>
<p>Blei，David M.“Probabilistic topic models。”ACM 55.4（2012）的通讯：77-84。</p>
</li>
<li>
<p>Wei，Xing和W. Bruce Croft。“基于LDA的文档模型，用于临时检索。”第29届年度国际ACM SIGIR研究与开发信息检索会议论文集。ACM，2006。
== 第二十五天 - 以数之名</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个学期学期我参加了我的第一个校对课程，题为“数学证明研讨会简介”。在学习了其他数学课程（微积分，矩阵代数等）之后，我觉得我没有那么多的数学基础，到目前为止，我所做的只是纯粹的计算数学，到处撒上了一些证明。回想起来，我发现课程非常有趣，并且学习不同的定理及其证明，主要来自数论，给了我一个新的数学视角。</p>
</div>
<div class="paragraph">
<p>你可能会问，“这与 Raku 有什么关系？”。正如我所提到的，课堂上讨论的大多数证明或家庭作业都与数论有关。如果 Raku 和数论有一个共同点就是它们的可访问性。类似于数论的内容如何具体和熟悉，Raku 对初学者来说非常平易近人。事实上，鼓励初学者写出所谓的“婴儿 Perl”。</p>
</div>
<div class="paragraph">
<p>似乎他们分享的另一件事是他们的浩瀚。例如，在 Raku 中可以找到许多运算符，而在数论中，可以找到从偶数到可爱数字的过多不同类型的数字。在大多数情况下，这些数字很容易理解，如果有一个数字的定义，那么很容易检查该类别中是否包含给定的整数。例如，素数正式定义如下：</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>如果整数p&gt; 1的唯一正数除数为1且p为p，则称p为素数，或简称为素数。否则，称整数p为合数。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>通过使用这个定义，我们可以非常简单地弄清楚某个数字是否是素数。例如，在前十个正整数中，2,3,5和7是素数。对于小数字来说这是微不足道的，但是用更大的数字手工完成它会很快变得单调乏味。这就是 Raku 的用武之地。Raku 提供了许多构造/函数，即使它们不能简化工作，它们也可以简化它。例如，考虑到素数的定义，我们可以轻松实现在 Raku 中测试素数的算法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub isPrime( $number ) {
    return $number &gt; 1 if $number ≤ 3;

    loop (my $i = 2; $i² ≤ $number; $i++) {
        return False if $number %% $i;
    }

    return True;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住，这不是关于编写高性能代码。如果代码以这种方式拒绝，那么它将是优秀的，但它不是目标。我的目的是展示初学者在 Raku 中表达数学结构的容易程度。值得一提的是，Raku 已经包含了`is-prime`测试素数的子程序（或方法）。然而，尽管对于素数这是正确的，但对于你可能遇到的另一种类型的数字可能并非如此，例如阶乘，因子或甚至加泰罗尼亚数字。在这种情况下，Raku 会很有帮助。</p>
</div>
<div class="paragraph">
<p>在了解了不同类型的数字后，我开始寻找一些奇特的数字，看看如何使用 Raku 实现它们。在这个过程中，我发现这个<a href="http://www.daviddarling.info/encyclopedia/N/numbers_types.html">有用的网站</a>列出了一堆数字，它们的定义和一些例子。从所有这些中，我选择了四种类型的数字，这些数字并非愚蠢地难以实现（我仍然在编写 Perl 宝宝!😅），同时足以说明一些 Raku 构造。另一方面，我避免了那些可能过于简单的事情。</p>
</div>
<div class="paragraph">
<p>让我们开始于…​</p>
</div>
</div>
<div class="sect2">
<h3 id="_友善的数字">51.5. 友善的数字</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Amicable 数字是一对数字，也称为<strong>友好数字</strong>，每个<strong>数字</strong>的等分部分添加给另一个数字。</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub aliquot-parts( $number ) {
   (^$number).grep: $number %% *;
}

sub infix:&lt;amic&gt;( $m, $n ) {
    $m == aliquot-parts($n).sum &amp;&amp;
    $n == aliquot-parts($m).sum;
}

say 12 amic 28;   # False, 12 and 28 aren&#39;t amicables.
say 220 amic 284; # True, 220 and 284 are though.</code></pre>
</div>
</div>
<div class="paragraph">
<p>数字的等分部分是排除数字本身的因素。为了找到数字的等分部分，我创建了一个子程序`aliquot-parts`，用于`1..^$number`创建从1到`$numbers`（不包括）的数字列表。随后对该列表进行了追踪，以找出列表中均匀分割的那些数字`$number`。在这个片段中，它是通过使用中缀运算符实现的`%%<code>，`True`如果第一个操作数可被第二个操作数整除，则返回该操作符。否则，它返回`False</code>。第二个操作数代表前面提到的列表中的任何数字，所以我使用过`*<code>，在这种情况下，它被称为*任何星形，*并在表达式上创建一个闭包</code>$number %% *<code>。因此，子程序中的整个表达式相当于</code>(^$number).grep: { $number %% $_ };`。最后，子程序返回`$number`排除`$number`自身的因子列表。</p>
</div>
<div class="paragraph">
<p>为了确定两个数字是否友好，我们可以只使用一个子程序。但是，Raku允许创建新的运算符，这些运算符*只是具有有趣名称的子程序*，我就是这么做的。我创建了中缀运算符（意思是两个操作数之间）<code>amic</code> ，<code>True`如果两个数字是友好的，则返回。否则，`False</code>。如你所见，创建新运算符的语法很简单：关键字`sub`，后跟运算符的类型（前缀，中缀，后缀等），引用构造内的运算符名称，预期参数和代码块。</p>
</div>
</div>
<div class="sect2">
<h3 id="_factorion">51.6. Factorion</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>因子是一个自然数，等于给定基数中其数字的阶乘的总和。</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset Whole of Int where * ≥ 0;

sub postfix:&lt;!&gt;( Whole $N --&gt; Whole ) {
    [*] 1..$N;
}

sub is-factorion( Whole $number --&gt; Bool ) {
    $number == $number.comb.map({ Int($_)! }).sum
}

say is-factorion(25);  # False
say is-factorion(145); # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>回想一下，通常用数字<strong>N</strong>表示的阶乘`N!<code>是产品`1 x 2 x …​ x N</code>。例如，<code>3! = 1 x 2 x 3 = 6</code>。在代码片段中，我创建了postfix运算符`!<code>以返回整数操作数的阶乘。因此`say 3!;</code>，在代码片段和打印中工作得很好`6`。计算阶乘是如何直接的：范围`1..$N`创建一个从1到`$N`（包括）的数字列表然后我使用`[…​]<code>，这被称为*减少*元运算符，运算符</code>*<code>减少创建的列表`1 x 2 x …​ $N</code>，有效地给了我阶乘的`$N`。Raku中有许多运算符，元运算符`[…​]`可以与其中许多运算符一起使用。</p>
</div>
<div class="paragraph">
<p>至于因子，我想知道一个数字是否是一个因子，所以我创建了一个采用整数并返回一个布尔值的子程序。Raku逐渐输入，因此它允许显式输入变量，指定子的返回类型等。我决定键入子程序的参数和子程序的返回类型。</p>
</div>
<div class="paragraph">
<p>关于友好数字的部分，我对子程序的论点非常自由。但是，在这里，我决定遵循阶乘的定义，只允许整数，因此定义和使用该`Whole`类型。在Raku中，运算符`subset`使用基类型声明一个新类型。但是，如果我没有使用该`where`条款，那么我最终只会使用另一个名称，这个`Int`类型将是多余的。所以我使用该`where`子句来约束对所需输入的任何赋值的类型。在这种情况下，赋值给类型的变量`Whole`。</p>
</div>
<div class="paragraph">
<p>使用`is-factorion`sub，我使用该方法`comb`分解`$number`成数字，然后用`map`它们找到各自的阶乘并总结它们。子返回`True`if `$number`等于其数字的阶乘的总和。`False`否则返回。</p>
</div>
</div>
<div class="sect2">
<h3 id="_循环数">51.7. 循环数</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>循环数是具有<strong>N个</strong>数字的数字，当乘以时`1, 2, 3, …​, N`，以不同的顺序产生相同的数字。</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub is-cyclic( Int $n --&gt; Bool ) {
    for 1..$n.chars -&gt; $d {
        return False if $n.comb.Bag != ($n * $d).comb.Bag;
    }
    return True;
}

say is-cyclic(142857); # True
say is-cyclic(95678);  # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我创建了`is-cyclic`一个采用整数并返回布尔值的子程序。我使用`for`循环遍历数字位数（第1个，第2个等）并使用它们乘以每次迭代中的数字。然后我使用之前看到的`comb`方法，然后使用该`Bag`方法。在Raku中，a <code>Bag`是不同元素的不可变集合，没有特定顺序，其中每个元素按集合中的副本数加权。这是我需要的那种结构，因为只有数字的数字及其数量很重要，而不是它们的顺序，并且`Bag`完全实现了这一点。`False`如果行李不具有相同的数字或具有相同的数字但是加权不同，则子程序返回。除此以外，`True</code> 返回，表示数字的循环。</p>
</div>
</div>
<div class="sect2">
<h3 id="_快乐的数字">51.8. 快乐的数字</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>幸福数字由以下过程定义：从任何正整数开始，将数字替换为其在十进制数字中的数字的平方和，并重复该过程，直到该数字等于1（它将保留的位置），或者它在一个不包括1的循环中无休止地循环。</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub is-happy( $n is copy ) {
    my $seen-numbers = :{};
    while $n &gt; 1 {
        return False if $n ∈ $seen-numbers;
        $seen-numbers{$n} = True;
        $n = $n.comb.map(*²).sum
    }
    return True;
}

say is-happy(7);     # True
say is-happy(2018);  # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>在完成定义中描述的过程之后，一个快乐的数字结束等于1.另一方面，一个非快乐的数字跟随一个到达循环的序列，该序列`4, 16, 37, 58, 89, 145, 42, 20, 4,…<code>不包括1.有了这个事实，我创建了散列</code>$seen-numbers`到跟踪这些数字。如while循环所示，该过程一次又一次地重复，同时`$n`大于1或直到看到数字。这里突出的线是包含符号∈的线。在集合论中，如果元素p是集合A的成员（或元素），则它由p∈A表示，这正是在此处测试的内容。如果数字`$n`是散列的元素，则子返回`False`。否则，它返回`True`，表示数字的幸福。</p>
</div>
</div>
<div class="sect2">
<h3 id="_摘要">51.9. 摘要</h3>
<div class="paragraph">
<p>在这篇文章中，我略微进行了逐步打字，如何定义一个新的运算符，使用`subset`关键字`set`和`bag`数据结构进行子类化。正如你可能已经意识到的那样，Raku 提供了许多可以促进许多不同任务的构造。在这种情况下，我希望以更加程序化的方式表达数字的定义。你可能会完全不同，但你可以放心，Raku 可以让你的工作更轻松，更有乐趣。</p>
</div>
<div class="paragraph">
<p>嗯…​…​这就是所有人！圣诞节快乐，新年快乐！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第一天_来自_perl_的_raku">52. 第一天 - 来自 Perl 的 Raku</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_介绍_5">52.1. 介绍</h3>
<div class="paragraph">
<p>自 2015 年年中以来，我一直在使用 <a href="https://raku.org/">Raku</a>（Perl 6 的新名称），真的很感谢它为程序员提供的出色功能，这些程序员可能是懒惰的，非接触式的打字员，业余爱好者，老 Perl 爱好者，非并行用户或想成为黑客的，其中包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>kebab-case 名称</p>
</li>
<li>
<p>无括号的控制语句</p>
</li>
<li>
<p>简易类构造</p>
</li>
<li>
<p>词法块变量</p>
</li>
<li>
<p>丰富的内置例程</p>
</li>
<li>
<p>使用原生的 unicode</p>
</li>
<li>
<p>强大的、易于使用的函数签名</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但它的一个特色非核心模块最近确实对我有帮助，所以，我把它作为今年送给我的一份惊喜的 Raku 礼物：Raku 模块 Inline::Perl5，由 Stefan Seifert 编写(IRC#raku: &#39;nine&#39;; Github: &#39;niner&#39;)。</p>
</div>
<div class="paragraph">
<p>在继续之前，请注意新的 Raku 链接，包括 <a href="https://raku.org/">Raku 主页</a>、<a href="https://docs.raku.org/">Raku 文档</a>和 <a href="https://modules.raku.org/">Raku 模块</a>。</p>
</div>
<div class="paragraph">
<p>注意：目前，我只在 Debian Linux 主机上使用 Raku，所以如果你在 Windows 或 Mac OSX 上遇到以下任何问题，我无法提供帮助。</p>
</div>
</div>
<div class="sect2">
<h3 id="_背景_3">52.2. 背景</h3>
<div class="paragraph">
<p>我形容自己是一个务实的程序员（即不加修饰地尽快完成工作），除了在大学期间接受过主框架、批处理工作时代的编程训练外，几乎没有接受过正规的编程训练，后来在美国空军的最后一份工作中，也没有接受过正规的编程训练。详见本 <a href="https://github.com/tbrowder/raku-advent-extras/blob/master/2019/BACKGROUND.md">文档</a>）。</p>
</div>
<div class="paragraph">
<p>在 1993 年中被我的最后一个民用雇主（另一个美国国防部承包商，我于 2016-01-11 从该雇主处退休）雇用后不久，我发现了 Perl 4，并发现它是我创建我们的小型地方办公室所需的工具的理想语言，使我们的小型办公室从一个密集的手工流程转向一个更自动化的流程（我当时大量使用 C，Perl 是我自 Basic 以来使用的第一个解释语言）。多年来，我最终转到了 Perl 5（比我应该用的要晚得多），并继续发展和改进我公司的软件工具箱（大部分是我利用自己的时间在家里写的），现在是在 Redhat Linux 计算机上，全部用 Perl 写的，其中包括自动生成图像和文档制作（用 Perl 写 PostScript 转换为 PDF）。制作出来的文档使我的分析师团队能够看到标准的结果图、表格和其他生成的指标，从而有更多的时间，可以轻松地写出他们的详细分析，然后纳入最终产品。</p>
</div>
<div class="paragraph">
<p>此外，我还建立了其他个人使用的产品，包括集成数据库的个性化日历、带标签制作器的圣诞卡地址数据库和几个网站。总之，我家里有很多老的以及最新的 Perl 代码！。</p>
</div>
</div>
<div class="sect2">
<h3 id="_2015_和_raku">52.3. 2015 和 Raku</h3>
<div class="paragraph">
<p>我一直希望看到 Raku（Perl 6）能尽快到来，因为现有的语言似乎有些笨拙，但 CPAN 及其出色的模块作者，尤其是 Damian Conway，帮助减轻这种麻烦。</p>
</div>
<div class="paragraph">
<p>因此，当我在 2015 年年中查看 Raku 的进展，看到即将发布的初始稳定版时，我非常高兴地加入了 -Ofun。我立即开始尝试将我的一些 Perl 产品转换为纯 Raku，首先是在我个人项目中对我很重要的一些 CPAN 模块。首先是 Perl 的 Geo::Ellipsoid，这是一次真正的学习经历，花费的时间比我想象的要长得多。最终，我向 CPAN 发布了八个纯 Raku 模块。</p>
</div>
</div>
<div class="sect2">
<h3 id="_快进到_2019_年">52.4. 快进到 2019 年</h3>
<div class="paragraph">
<p>当我今年开始把自己的工具移植到 Raku 上时，真正的乐趣开始了。当我构建最初的工具时，大部分都是在匆忙中完成的，几乎没有时间进行思考和设计，也很少进行测试，当然也没有测试套件。因此，我有很多丑陋的代码放在那里，准备移植到 Raku 上。套用 Dr. Strangelove[参考文献 1]的话，我不再担心这些乱七八糟的东西，而是开始着手 Raku 的移植工作。</p>
</div>
</div>
<div class="sect2">
<h3 id="_第一部分_初步测试">52.5. 第一部分: 初步测试</h3>
<div class="paragraph">
<p>我首先从移植模块开始，然后再移植使用这些模块的程序，但发现在许多情况下这太费力了。我遇到的问题有：缺乏签名、大量使用 GOTO、在长主程序（也就是脚本）中使用全局变量和大量子程序等等。</p>
</div>
<div class="paragraph">
<p>所以我终于在今年决定尝试使用 Inline::Perl5 来简化我的工作。我把我的移植过程改为:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>把 Perl 程序中现有的子程序移到 Perl 模块中。</p>
</li>
<li>
<p>确保 Perl 程序在第 1 步后继续按照预期工作。</p>
</li>
<li>
<p>将现在短得多的 Perl 程序移植到 Raku 中，这个任务比以前简单多了。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在我认真开始之前，我创建了一个 Raku 脚本来查找我所有的 Perl 文件(使用 File::Find 和正则表达式 <code>/[&#39;.pm&#39;|&#39;.pl&#39;]$/</code>)，逐行读取它们，然后再把它们写出来，看看用 Raku 处理它们是否有任何问题，当然，我确实做到了：在我的一些非常老的代码中(20 世纪 90 年代中期)，我得到了关于畸形 utf8 的错误，就像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">ERROR: something failed in file &#39;make_color_book.pl&#39;: Malformed UTF-8</code></pre>
</div>
</div>
<div class="paragraph">
<p>我尝试了几种方法来隔离坏的行，包括使用 <code>*nix</code> 工具 <code>od</code>，但那太慢了，而且用 vim 进行目测也不一定有效。(由于我是远程工作，我没有来得及使用 Emacs 或 comma，所以我不知道这是否会有帮助。) 幸运的是，我在使用一组有限的文件进行测试时偶然发现了一个窍门，当我在程序中使用这个片段时:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">try { my $string = slurp $infile }
if $! {
    note &#34;Error attempting to slurp file &#39;$infile&#39;&#34;;
    note &#34;$!&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>检测到 UTF-8 错误，我会得到一个错误信息，如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Error attempting to slurp file &#39;PP.pm&#39;
Malformed UTF-8 at line 179 col 66</code></pre>
</div>
</div>
<div class="paragraph">
<p>这使我能够很容易地看到原始文件中的问题字符，并将其改为有效的 UTF-8。</p>
</div>
</div>
<div class="sect2">
<h3 id="_将_perl_模块同时导入_perl_和_raku_中">52.6. 将 Perl 模块同时导入 Perl 和 Raku 中</h3>
<div class="paragraph">
<p>在修改现有的 Perl 模块，使其既能被 Perl 使用，又能被 Raku 使用时，我发现了两个最后的问题，它们是重叠的。</p>
</div>
<div class="paragraph">
<p>在 Perl 程序和它们的 Perl 模块中，当程序的子程序被移到一个现有的或新的 Perl 模块中时，如何处理全局变量集的丢失？</p>
</div>
<div class="paragraph">
<p>如何将 Perl 模块中的子程序和变量导出到 Perl 和 Raku 程序中？</p>
</div>
<div class="sect3">
<h4 id="_问题_1_全局变量">52.6.1. 问题 1: 全局变量</h4>
<div class="paragraph">
<p>Inline::Perl5 目前并没有描述访问变量的方法，当然，这种做法根本不推荐，但是，在作者（Stefan Seifert）的帮助下，我找到了一个方法。我们先从一个同时用于 Perl 和 Raku 程序的 Perl 模块开始，比如说 P5.pm，它的样子是这样的（文件 P5.pm）:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">package P5;

use feature &#39;say&#39;;
use strict;
use warnings;

#| The following module does NOT affect exporting to Raku, it only
#| affects exporting to Perl programs. See program `usep5.pl` for
#| examples.
use Perl6::Export::Attrs; #= [from CPAN] by Damian Conway

our $VERSION = &#39;1.00&#39;;

#| Always exported (no matter what else is explicitly or implicitly
#| requested):
our %h :Export(:MANDATORY);
our $pa :Export(:MANDATORY);

#| Export $pb when explicitly requested or when the &#39;:ALL&#39; export set
#| is requested.
our $pb :Export(:DEFAULT :pb);

#| Always exported:
sub set_vars :Export(:MANDATORY) {
    %h = ();
    $h{a} = 2;
    $pa = 3;
    $pb = 5;
}

#| Always exported (no matter what else is explicitly or implicitly
#| requested):
sub sayPA :Export(:MANDATORY) {
    say &#34;  \$pa = $pa&#34;;
}

#| Always exported:
sub sayPB :Export(:DEFAULT :sayPB) {
    say &#34;  \$pb = $pb&#34;;
}

#| Always exported:
sub sayH :Export(:MANDATORY) {
    foreach my $k (sort keys %h) {
        my $v = $h{$k};
        say &#34;  key &#39;$k&#39;, value &#39;$v&#39;&#34;;
    }
}
1; #= mandatory true return</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_问题_2_导出全局变量">52.6.2. 问题 2: 导出全局变量</h4>
<div class="paragraph">
<p>正如在 <code>P5.pm</code> 模块中所指出的，<code>Perl6::Export::Attrs</code> 所提供的导出信息只供使用 <code>P5.pm</code> 的 Perl 代码使用（它不会影响使用 <code>P5.pm</code> 的 Raku 程序）。然而，在任何 Perl 模块中插入 &#34;use Perl6::Export::Attrs;&#34;，可以大大简化导出任务，无需大量的 Perl 代码。人们不一定非要使用它，但我强烈推荐使用它。还有一个好处是，最终将 Perl 模块移植到 Raku 上会更容易。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用_p5_模块的_perl_程序">52.6.3. 使用 P5 模块的 Perl 程序</h4>
<div class="paragraph">
<p>可以在 Perl 程序中像这样访问 Perl 模块中的对象（文件 use5.pl）:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use feature &#39;say&#39;;
use strict;
use warnings;

use lib qw(.);
use P5 qw($pb sayPB); # &lt;== notice the explicit requests

set_vars;

my %h = %P5::h;
say &#34;Current globals in P5:&#34;;
foreach my $k (sort keys %h) {
    my $v = $h{$k};
    say &#34;  key &#39;$k&#39;, value &#39;$v&#39;&#34;;
}
sayPA();
sayPB();

say &lt;&lt; &#34;HERE&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>修改 P5 中的当前全局变量</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">  \$P5::h{a} = 3
  \$P5::h{c} = 5 # a new key/value pair
  \$P5::pa = 4
  \$P5::pb = 6
HERE

$P5::h{a} = 3;
$P5::h{c} = 5;
$P5::pa = 4;
$P5::pb = 6;

say &#34;Revised globals in P5:&#34;;
sayH();
sayPA();
sayPB();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用模块_p5_的_raku_程序">52.6.4. 使用模块 P5 的 Raku 程序</h4>
<div class="paragraph">
<p>而在 Raku 程序中可以像这样访问 Perl 模块的对象(文件 use5.raku):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| IMPORTANT
#| Notice no explicit use of Inline::Perl5, but it
#| must be installed.
use lib:from &#39;.&#39;; #= Must define the Perl lib location with this syntax.
use P5:from;      #= Using the Perl module.

#| IMPORTANT
#| =========
#| Bind the hash variable so we can modify the hash.
#| For access only, use of the &#39;=&#39; alone is okay.
set_vars;

my %h := %*PERL5;

say &#34;Current globals in P5:&#34;;
for %h.keys.sort -&gt; $k {
    my $v = %h{$k};
    say &#34;  key &#39;$k&#39;, value &#39;$v&#39;&#34;;
}
sayPA();
sayPB();

say qq:to/HERE/;

Modify current globals in P5:
  \%h = 3
  \%h = 5 # a new key/value pair
  \$P5::pa = 4
  \$P5::pb = 6
HERE

%h = 3;
%h = 5;

#| IMPORTANT
#| Need this syntax to access or modify a scalar:
$P5::pa = 4;
$P5::pb = 6;

say &#34;Revised globals in P5:&#34;;
sayH();
sayPA();
sayPB();</code></pre>
</div>
</div>
<div class="paragraph">
<p>这三个测试文件都一起工作，为我的真实代码提供了工作蓝图。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_第二部分_使用真实代码">52.7. 第二部分: 使用真实代码</h3>
<div class="paragraph">
<p>在本节中，我将使用我的一个项目中的文件：我的大学班级网站（见这里）。我在 2009 年开始做这个网站，并经常对它进行添加和维护，所以它有很多残缺的 Perl 代码。我已经创建了一个 Github 仓库，其中包含了我将在下面的讨论中使用的代码。你可以像这样克隆它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ git clone https://github.com/tbrowder/raku-advent-extras.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>我将使用的代码在 raku-advent-extras/2019/ 目录下。这段代码应该是经过消毒的，所以不会显示任何非公开的信息，而且它也不会完全发挥作用，但是主脚本 manage-website.pl，如果在没有任何参数的情况下执行，应该会一直运行。游戏开始吧。</p>
</div>
<div class="sect3">
<h4 id="_查找全局变量">52.7.1. 查找全局变量</h4>
<div class="paragraph">
<p>在我的实际 Perl 模块中使用上面的语法例子，我首先将 Perl 程序中明显标记的全局变量移到一个新的 Perl 模块中，用一个字母命名，以方便使用，如 G.pm（代表 Global）。例如，在主程序中找到一个变量 <code>$start_time</code>，我会把它改名为 <code>$G::start_time</code>，并把它放到 G.pm 模块中，作为我们的 <code>$start_time</code>。</p>
</div>
<div class="paragraph">
<p>然后我重复行使程序，在每次运行时找到更多的全局变量，将它们添加到模块中，以此类推，直到找到所有的 globals。</p>
</div>
<div class="paragraph">
<p>在定义了 Perl 全局变量之后，第一个真正要使用的文件是程序文件 manage-web-site.pl，以及两个 Perl 模块 PicFuncs.pm 和 G.pm，在本文的其余部分将使用它们。为了达到一个共同的起点，在 git repo 中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ git checkout stage-0</code></pre>
</div>
</div>
<div class="paragraph">
<p>并确保主脚本运行时不带参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ ./manage-web-site.pl
Usage: ./manage-web-site.pl -gen | -cvt [-final][-useborder][-usepics][-debug][-res=X]
                      [-force][-typ=X][-person][-stats][-warn]
Options:
[...snip...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在开始一个新分支：<code>$ git checkout -b stage-1</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_阶段_1将主程序中的所有子程序移到一个新的_perl_模块中">52.7.2. 阶段 1：将主程序中的所有子程序移到一个新的 Perl 模块中。</h4>
<div class="paragraph">
<p>这时我打算把 manage-web-site.pl 中的所有 Perl subs 移动到一个新的模块 OtherSubs.pm 中。我会一次一个，执行程序看看是否有问题，一直到所有（或大部分）子程序都存放在新的 Perl 模块中。步骤如下:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建 OtherSubs.pm</p>
</li>
<li>
<p>在程序中添加使用 OtherSubs</p>
</li>
<li>
<p>删除副引号(不需要)</p>
</li>
<li>
<p>将子例程 Build_web_pages 移到 OtherSubs.pm 中。</p>
</li>
<li>
<p>执行 manage-web-site.pl: PROBLEMS WITH GLOBAL VARS!!</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我缺少以下符号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Global symbol &#34;$CL_HAS_CHANGED&#34;...
Global symbol &#34;$CL_WAS_CHECKED&#34;...
Global symbol &#34;$GREP_pledge_form&#34;...
Global symbol &#34;$USAFA1965&#34;...
Global symbol &#34;$USAFA1965_tweetfile&#34;...
Global symbol &#34;$debug&#34;...
Global symbol &#34;$dechref&#34;...
Global symbol &#34;$force_xls&#34;...
Global symbol &#34;$real_xls&#34;...</code></pre>
</div>
</div>
<div class="paragraph">
<p>在我解决了这个问题之后，我继续移动子，并解决新的全局变量，直到所有的子都被移动。在每个子被成功移动后，你应该会看到一条提交信息。我停止了一个子离开程序文件，子 zero_modes，因为它是选项处理的一部分，通常不应该在一个模块中。</p>
</div>
</div>
<div class="sect3">
<h4 id="_阶段_2将_perl_程序移植到_raku_中">52.7.3. 阶段 2：将 Perl 程序移植到 Raku 中</h4>
<div class="paragraph">
<p>在这部分，我从 stage-1 分支开始了一个新的分支： <code>$ git checkout -b stage-2</code>。</p>
</div>
<div class="paragraph">
<p>我相信每个 Raku 程序员都会以不同的方式将 Perl 程序移植到 Raku 中，但以下是我的一般配方。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将现有的程序，在本例中是 manage-web-site.pl，复制到一个等价的 Raku 名下，- manage-web-site.raku（见下面的注释 1 和 2）。</p>
</li>
<li>
<p>执行 manage-web-site.pl：PROBLEMS!</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我得到了以下错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">===SORRY!===
Could not find feature at line 3 in:
    inst#/home/tbrowde/.perl6
    inst#/usr/local/rakudo.d/share/perl6/site
    inst#/usr/local/rakudo.d/share/perl6/vendor
    inst#/usr/local/rakudo.d/share/perl6
    ap#
    nqp#
    perl5#</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我发现了一个我在一般过程中没有解决的问题：全局符号冲突。当我试图使用 Raku 版本的模块 Geo::Ellipsoid，而一些 Perl 版本也在使用它时，就发生了这种情况。我通过在程序文件中注释掉 Raku 版本并使用 Perl 版本解决了眼前的问题。</p>
</div>
<div class="paragraph">
<p>在解决了这个问题之后，我继续删除或替换使用过的模块，处理更多的全局变量，查找或忽略缺失的子程序，用 <code>=begin comment/=end comment</code> 替换 <code>=pod/=cut</code>，删除不需要的圆括号，使用 Raku 惯用法（例如，Raku 的 &#39;for&#39; 与 Perl 的 &#39;foreach&#39;），并修复问题，直到所有问题都得到解决。在每个问题成功解决后，你应该会看到一条提交信息。我还试图在工作时清理代码。</p>
</div>
</div>
<div class="sect3">
<h4 id="_阶段_3整理_raku_程序">52.7.4. 阶段 3：整理 Raku 程序</h4>
<div class="paragraph">
<p>最后，程序 manage-website.raku 运行（没有输入参数），没有错误。这时我检查出了一个 stage-3 分支，用于清理一下程序：<code>git checkout -b stage-3</code>。我删除了很多注释，并删除了圆括号。我还从使用模块中删除了子程序文件中现在没有实际使用的模块，在子程序被移动后。此外，我还把帮助系统做得更干净了一些。我留下一个明显的 Raku 功能，作为用户的练习：在选项选择的丑陋的 <code>if/else</code> 块中，改为使用 Raku 的 <code>when</code> 块。</p>
</div>
<div class="paragraph">
<p>我们从一个有大约 6600 行丑陋 Perl 代码的 manage-web-site.pl 文件开始，完成了一个 Raku 版本，manage-web-site.raku。只有不到 800 行，看起来更干净。我们还没有完成移植：我们还得测试每个选项的正常功能（我相信一定会有龙🐉！）。理想情况下，我们还会在这个过程中加入测试。但我们还没有所有必要的内容，所以我们就到此为止了（不过，请在第 9 天跟随我在本篇文章的第二部分中了解我的下一步工作）。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_5">52.8. 总结</h3>
<div class="paragraph">
<p>您已经看到了一种将 Perl 代码轻松移植到 Raku 的方法，我希望它能帮助那些正在考虑转向 Raku 的人看到，它可以通过较小的步骤反复完成，而不是花费大量的时间。第 9 天这篇文章的第 2 部分将尝试迈出下一步，将一个 Perl 模块转换为 Raku，并让它同时被 Perl 和 Raku 调用者使用。</p>
</div>
<div class="paragraph">
<p>我 ❤️❤️ Raku！😊。</p>
</div>
<div class="paragraph">
<p>🎅圣诞快乐🎅和🥂祝大家新年快乐🎉，用查尔斯-狄更斯的 Tiny Tim 的不朽名言，愿✝&#34;上帝保佑我们，每一个人！&#34;✝[参考文献 2] ✝&#34;上帝保佑我们，每一个人！</p>
</div>
<div class="sect3">
<h4 id="_附录_2">52.8.1. 附录</h4>
<div class="sect4">
<h5 id="_笔记">笔记</h5>
<div class="paragraph">
<p>其实我是在 stage-1 分支的时候不小心开始重命名文件的，抱歉。</p>
</div>
<div class="paragraph">
<p>&#39;.raku&#39; 的文件扩展名是社区公认的 Raku 可执行程序的约定。然而，在可预见的将来，它的使用（在 <code>*nix</code> 系统上）取决于是否安装了 Rakudo 编译器和其他两个条件之一。(1)用户的程序文件用 <code>chmod x</code> 标记为可执行文件(2)以 <code>raku myprog.raku</code> 的方式执行程序。希望不久的某一天，当 Rakudo 编译器的可执行文件以 raku 的形式出现，并且安装在你的系统上时，将上面指令中的 perl6 替换为 raku。(Windows 和 Mac 用户将不得不从其他来源获得他们的指令。)</p>
</div>
</div>
<div class="sect4">
<h5 id="_参考文献">参考文献</h5>
<div class="paragraph">
<p>电影（1964 年）。&#34;奇异博士&#34;或：&#34;我是如何学会停止担心和爱上炸弹的&#34; (见 Imdb.com)</p>
</div>
<div class="paragraph">
<p>《圣诞颂歌》是查尔斯-狄更斯（1812-1870）的短篇小说，狄更斯是维多利亚时代著名的流行作家，他的众多作品包括《匹克威克文件》、《奥利弗-特威斯特》、《大卫-科波菲尔》、《荒凉山庄》、《伟大的期望》和《双城记》。</p>
</div>
</div>
<div class="sect4">
<h5 id="_使用的_raku_模块用_zef_安装">使用的 Raku 模块（用 zef 安装）。</h5>
<div class="ulist">
<ul>
<li>
<p>Inline::Perl5</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_cpan_使用的_perl_模块与_cpanm_一起安装">CPAN 使用的 Perl 模块（与 cpanm 一起安装）</h5>
<div class="ulist">
<ul>
<li>
<p>Perl6::Export::Attrs</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://rakuadventcalendar.wordpress.com/2019/12/01/day-1-raku-from-perl/" class="bare">https://rakuadventcalendar.wordpress.com/2019/12/01/day-1-raku-from-perl/</a></p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二天_crohttp_crud_指南">53. 第二天 - Cro::HTTP CRUD 指南</h2>
<div class="sectionbody">
<div class="paragraph">
<p>大家好！</p>
</div>
<div class="paragraph">
<p>今天我们将通过本篇教程来介绍使用 <a href="https://cro.services/">Cro</a> 编写一个简单的 CRUD 服务。不耐烦的朋友，源码链接在文章最后。</p>
</div>
<div class="sect2">
<h3 id="_为什么我要看这段文字和代码">53.1. 为什么我要看这段文字和代码？</h3>
<div class="ulist">
<ul>
<li>
<p>Cro::HTTP 的用法, 用于服务器端应用的认证+授权和 CRUD 资源的服务</p>
</li>
<li>
<p>Cro::WebApp 模板的用法</p>
</li>
<li>
<p>Cro::HTTP::Test 的用法</p>
</li>
<li>
<p>设置服务：Docker、nginx 反向代理</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_我今天为什么要看别的东西">53.2. 我今天为什么要看别的东西？</h3>
<div class="ulist">
<ul>
<li>
<p>使用了一个过于简化的模拟内存数据库。使用任何你认为合适的工具来获得可靠的解决方案。</p>
</li>
<li>
<p>对于服务器端应用来说，项目复杂度被降到最低：客户端没有智能 javascript，没有用户友好的 UX 模式。</p>
</li>
<li>
<p>这篇文章涵盖了很多基础知识，并不是针对有经验的用户。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_我们开始吧">53.3. 我们开始吧</h3>
<div class="paragraph">
<p>因此，我们要写一个博客聚合器。</p>
</div>
<div class="paragraph">
<p>用户可以注册、登录和注销。他们可以创建新的帖子、查看帖子、编辑和删除他们的帖子。</p>
</div>
<div class="paragraph">
<p>让我们开始使用 Cro 命令行工具来存根一个新的项目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">➜  CommaProjects&gt; cro stub http rest-blog ./rest-blog
Stubbing a HTTP Service &#39;rest-blog&#39; in &#39;./rest-blog&#39;...</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，请提供更多信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">Secure (HTTPS) (yes/no) [no]:
Support HTTP/1.1 (yes/no) [yes]:
Support HTTP/2.0 (yes/no) [no]:
Support Web Sockets (yes/no) [no]:
➜  CommaProjects&gt; cd rest-blog/</code></pre>
</div>
</div>
<div class="paragraph">
<p>像往常一样，我们还想为我们的项目初始化一个 git 仓库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ git init
$ git add .
$ git commit -m &#39;Initial commit&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们看看创建的存根的结构：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>lib</strong> 目录包含了应用程序本身的源码。目前，它只有一个声明了单个路由的示例路由。</p>
</li>
<li>
<p><strong>META6.json</strong> 包含我们项目的描述。</p>
</li>
<li>
<p><strong>service.raku</strong> 描述了如何启动我们的服务。默认情况下，它在环境变量指定的主机和端口上启动 Cro 服务器，并为请求提供服务，直到用户发送 Ctrl-C。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要启动该应用程序，可以直接运行 <strong>service.raku</strong>，但更灵活的是编辑 <strong>.cro.yml</strong> 文件，该文件描述了这个项目由一个或多个服务组成。在那里，<strong>service.raku</strong> 被指定为入口点的路径，所以 Cro 命令行工具会根据配置为你运行脚本。</p>
</div>
<div class="paragraph">
<p>我们来试一试吧：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cro" data-lang="cro">➜  rest-blog git:(master) ✗ cro run .
▶ Starting rest-blog (rest-blog)
🔌 Endpoint HTTP will be at http://localhost:20000/
📓 rest-blog Listening at http://localhost:20000
📓 rest-blog [OK] 200 / - ::1</code></pre>
</div>
</div>
<div class="paragraph">
<p>服务启动后，你可以在浏览器中访问 <strong><a href="localhost://20000">localhost://20000</a></strong> 并查看 Cro 的 Lorem Ipsum。</p>
</div>
<div class="paragraph">
<p>一切准备就绪后，那我们就来深入了解一下。</p>
</div>
</div>
<div class="sect2">
<h3 id="_数据库">53.4. 数据库</h3>
<div class="paragraph">
<p>我们先来编写 <strong>Blog::Database</strong> 类。我们在新目录 <strong>lib/Blog</strong> 中创建文件 <strong>Database.pm6</strong>，这样完整路径就是 <strong>lib/Blog/Database.pm6</strong>。如果你使用的是 Comma IDE，这个过程就更简单了。不要忘记在 <strong>META6.json</strong> 文件的 provides 部分添加新条目。我们将处理用户和帖子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| A mock in-memory database.
class Blog::Database {
    has %.users;
    has %.posts;

    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见，用户和帖子被定义为哈希。其内容将是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用户包含：用户 ID、用户名、密码</p>
</li>
<li>
<p>帖子包含：帖子 ID、标题、正文、作者 ID 和创建日期</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于用户，我们需要一种方法来添加用户（注册），通过 ID（从会话中）或用户名（登录时）来获取用户。这里就不一样了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method add-user(:$username, :$password) {
    my $id = %!users.elems + 1;
    %!users{$id} = { :$id, :$username, :$password }
}

multi method get-user(Int $id) { %!users{$id} }

multi method get-user(Str $username) { %!users.values.first(*&lt;username&gt; eq $username) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用当前的哈希大小来生成新的 ID，getters 是作为哈希的琐碎操作来实现的。</p>
</div>
<div class="paragraph">
<p>帖子是我们的 CRUD 资源，所以我们希望有更多的方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method add-post(:$title, :$body, :$author-id) {
    my $id = %!posts.elems + 1;
    %!posts{$id} = { :$id, :$title, :$body, :$author-id, created =&gt; now }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Read</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method get-post(UInt $id) { %!posts{$id} }</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Update</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method update-post($id, $title, $body) {
        %!posts{$id}&lt;title&gt; = $title;
        %!posts{$id}&lt;body&gt; = $body
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Delete</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method delete-post($id) { %!posts{$id}:delete }</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这些，我们就可以继续了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_授权与认证">53.5. 授权与认证</h3>
<div class="paragraph">
<p>关于授权与认证的话题，有很多文章都有解释，这里我们就从 Cro 用户的角度看看它的工作原理。</p>
</div>
<div class="paragraph">
<p>首先，我们需要定义一个 <strong>Session</strong> 类。会话在服务器端保存着用户当前的数据。对于每个新的客户端，我们的服务都会创建一个新的会话对象，并给客户端发回一个特殊的 “key”（会话 ID），并说：“这是你的 session key，你可别把它丢到某个地方！”。这样一来，客户对其特定的会话一无所知，但它知道如何说：“我想要这个页面，哦，对了，这是你给我的钥匙，也许会有更多糖果只给我！”。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2019/12/jukfalvpdp-1.jpg" alt="session"/>
</div>
</div>
<div class="paragraph">
<p>服务器知道如何将 key 与对应到特定的会话对象，并且可以根据其数据决定如何处理这个请求。</p>
</div>
<div class="paragraph">
<p>让我们在 <strong>Blog::Session</strong> 中定义一个非常简单的会话类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::HTTP::Auth;

class Blog::Session does Cro::HTTP::Auth {
    has $.user-id is rw;

    method logged-in { $!user-id.defined }
}

subset LoggedIn of Blog::Session is export where *.logged-in;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的类必须要 does <code>Cro::HTTP::Auth</code> 角色，才能被 Cro 识别为会话持有者类。我们还将用户的 ID 存储在一个属性中，并提供了一个方法来检查用户是否已经登录：如果用户有 ID，那么这绝对不是什么匿名潜伏。</p>
</div>
<div class="paragraph">
<p>我们还为创建的类型提供了一个方便的子集（<code>LoggedIn</code> 是 <code>Blog::Session</code> 的子集，其中 <code>logged-in</code> 方法返回 True）。</p>
</div>
<div class="paragraph">
<p>设置 “key” 有不同的方式（cookie，headers 等），Cro 也支持各种设置（内存存储，持久化存储，redis 存储，可以添加更多），但为了简单起见，我们将使用内存、cookie 为基础的会话支持。</p>
</div>
<div class="paragraph">
<p>那么，其次，我们如何启用呢？我们的服务器从网络上接收到一个请求，对其进行解析，然后传递处理，再发回一个响应。在这中间的某个环节，我们需要添加一些东西：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于新用户，创建一个会话，并在响应中加入“这是你的 key，勇敢的人！”。</p>
</li>
<li>
<p>对于有 key 的用户，检索会话，并告诉路由“这是用户的会话数据！”</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们可以在很多地方添加这样一个软件在中间工作，例如中间件。</p>
</div>
<div class="paragraph">
<p>第一个“正常”的地方是服务器级，第二个“正常”的地方是路由级。它们有不同的利弊，但是这次我们要到 <strong>service.raku</strong> 中，给我们的服务器添加一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">...
    application =&gt; routes(),
    before =&gt; [
        Cro::HTTP::Session::InMemory[Blog::Session].new(
                expiration =&gt; Duration.new(60 * 15),
                cookie-name =&gt; &#39;XKHxsoOwMNdkRrgqVFaB&#39;);
    ],
    after =&gt; [
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>不要忘记导入我们的 <code>Blog::Session</code> 类。</p>
</div>
<div class="paragraph">
<p>除了递给 <code>Cro::HTTP::Server</code> 构造函数的其他选项（如主机、端口和要服务的应用程序），我们在参数前指定包含我们要应用的中间件列表。我们配置 <code>Cro::HTTP::Session::InMemory</code> 时，将我们的会话类作为类型参数，并说“我想使用这种类型的会话对象”。我们还指定了 cookie 的名称和过期时间，这样用户就需要再次登录。每当用户发出新的请求时，过期时间都会重新设置，所以积极浏览网站的用户不会看到突然出现的&#34;登录&#34;页面。</p>
</div>
<div class="paragraph">
<p>我们为什么要在服务器级而不是路由级添加呢？这是一个惊喜工具，以后会对我们有所帮助！</p>
</div>
<div class="paragraph">
<p>当我们在 <code>service.raku</code> 中的时候，创建一个应用程序范围的数据库并将其传递给我们的路由会很方便。</p>
</div>
<div class="paragraph">
<p>创建一个新的 <code>Blog::Database</code> 对象，并将其传递给 <code>routes</code> 子例程，同时将其签名打上补丁，使其有一个参数。在更复杂的应用中，我们可以在这里连接到一个持久化的数据库，做各种检查等。</p>
</div>
<div class="paragraph">
<p>现在终于可以编写一些路由代码了！</p>
</div>
</div>
<div class="sect2">
<h3 id="_路由原理">53.6. 路由：原理</h3>
<div class="paragraph">
<p>在我们的应用中，我们有两个模块，即 <code>Auth</code> 和 <code>Blog</code>，分别负责认证和博客功能。尽管它们本身并不大，但为了便于演示，我们会把它们分成不同的模块。</p>
</div>
<div class="paragraph">
<p>正如一篇关于 <a href="https://cro.services/docs/approach">Cro 方法</a>的文章中所描述的那样，用 <code>Cro::HTTP</code> 构建的 Web 应用程序只是一条从“网络输入”到“网络输出”的双向管道。所有的底层业务如解析都已经为用户完成了。</p>
</div>
<div class="paragraph">
<p>当管道建立起来之后（这是用 service.raku 入口点中的 <code>Cro::HTTP::Server</code> 用法来完成的），中间件也到位了，我们应用的“核心”就是路由。</p>
</div>
<div class="paragraph">
<p>从高层次的角度讲，路由就是一种接受请求并发出响应的东西。</p>
</div>
<div class="paragraph">
<p>只要满足约束条件，我们就可以用任何合适的方式编写路由，但对于大多数应用来说，使用一个方便的 <code>route</code> 子程序和一堆辅助子程序就足以完成任务了。</p>
</div>
<div class="paragraph">
<p>正如你在我们的存根项目中看到的那样，我们的 <code>Blog::Routes</code> 模块已经包含一个单一的示例路由，该路由为我们之前看到的虚拟对象提供服务。</p>
</div>
<div class="paragraph">
<p>为了使我们的应用更有用，我们将添加更多的路由。关于 API 的详细描述请参考 <a href="https://cro.services/docs/reference/cro-http-router">Cro::HTTP::Router 文档</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_路由开始">53.7. 路由：开始</h3>
<div class="paragraph">
<p>我喜欢我的模块保持有序。由于我们写的是一个博客应用，自然博客路由器应该在 <code>Blog::Routes</code> 模块中，但存根只用 <code>Routes</code> 来迎接我们。只要将文件移动到新的目录下，调整 <code>META6.json</code> 数据即可（如果使用 Comma，则直接拖拽即可）。</p>
</div>
<div class="paragraph">
<p>现在，我们来调整一下它的内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::HTTP::Router;

sub routes($db) is export {
    route {
        after { redirect &#39;/auth/login&#39;, :see-other if .status == 401 };

        get -&gt; &#39;css&#39;, *@path {
            static &#39;static-content/css&#39;, @path
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们用几行代码替换了默认路由。</p>
</div>
<div class="paragraph">
<p>用 block 调用 <code>after</code> 子程序，在路由层面增加了一个新的中间件。对于每一个响应，block 都会被执行，它是一个主题，中间件会检查响应的状态码。如果是 401(Unauthorized)，我们设置一个重定向到我们的(未来)登录页面。</p>
</div>
<div class="paragraph">
<p>第二个子程序调用是定义路由，它将服务于静态内容—​我们的 CSS 文件。为了让我们的 HTML 页面看起来不那么悲伤，我们将使用 Bootstrap 工具包，所以我们在项目的根目录下创建 <code>static-content/css</code> 目录，并在那里添加 <code>bootstrap.min.css</code> 文件。这个文件可以从 <a href="https://getbootstrap.com/docs/4.3/getting-started/download/">官方的 Bootstrap 框架页面</a>、各种 CDN 服务或者任何你可能想要的样式服务方式获得。当然，布局是由你自己决定的，没有什么必要。</p>
</div>
</div>
<div class="sect2">
<h3 id="_路由授权">53.8. 路由：授权</h3>
<div class="paragraph">
<p>让我们为与授权相关的路由创建一个新的路由。</p>
</div>
<div class="paragraph">
<p>创建 <code>Blog::Routes::Auth</code> 模块，并声明 <code>auth-routes</code> 子程序，该子程序返回路由调用的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Cro::HTTP::Router;

sub auth-routes(Blog::Database $db) is export {
    route {
        # Routes will be here!
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它暂时没有路由，但我们已经可以把它加入到我们的&#34;主&#34;路由中。让我们把它添加到 <code>Blog::Routes</code> 模块中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Blog::Routes::Auth;

sub routes(Blog::Database $db) is export {
    route {
        ...
        include auth =&gt; auth-routes($db);
        ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了包含一个路由，我们使用 <code>include</code>，这应该很容易记住!</p>
</div>
<div class="paragraph">
<p>如果这个调用看起来像个魔术，我们可以把它改写成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">include(auth =&gt; auth-routes($db));</code></pre>
</div>
</div>
<div class="paragraph">
<p>这只是一个带有命名参数的调用。<code>key</code> 可以是一个字符串或一个字符串列表，并为包含的路由的每个路由定义一个前缀。值只是调用我们的 <code>auth-routes</code>，创建一个新的路由。</p>
</div>
<div class="paragraph">
<p>我们还传递了 <code>$db</code> 参数，因为我们当然希望在新路由的路由中使用我们的模型。</p>
</div>
<div class="paragraph">
<p>在跳转到路由的实现之前，我们还有一个问题需要看…​</p>
</div>
</div>
<div class="sect2">
<h3 id="_crowebapp_模板">53.9. Cro::WebApp 模板</h3>
<div class="paragraph">
<p>Cro::HTTP 不是一个 web 框架。但它可以成为一个框架。怎么做？</p>
</div>
<div class="paragraph">
<p>它给了你响应 HTTP 请求的能力，而不是用它自己决定的&#34;如何&#34;来束缚你。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>你想对你的数据进行建模吗？只要建模就好了，不管你想用什么方式。</p>
</li>
<li>
<p>你想为你的用户提供 HTML 服务吗？只要准备好它，无论你想要什么方式。</p>
</li>
<li>
<p>你想处理请求和响应吗？那就交给 Cro::HTTP 吧!</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们还没有讨论的是 HTML 模板。事实上，除了从用户那里获取请求数据之外，我们还需要在之前用一些漂亮的页面来迎接他们。要做到这一点，我们将使用 <code>Cro::WebApp</code> 模块。</p>
</div>
<div class="paragraph">
<p>它是一个语法接近 Raku 的模板引擎，因此需要一些时间来适应它。在阅读模板代码之前，非常建议先浏览一下 <a href="https://github.com/croservices/cro-webapp">它的文档页面</a>。</p>
</div>
<div class="paragraph">
<p>模板代码由于种种原因（没有人喜欢枯燥的 HTML，大家更不喜欢模板），特意没有包含在这篇文章中，但在代码仓库中可以找到。</p>
</div>
</div>
<div class="sect2">
<h3 id="_路由_授权的反击">53.10. 路由: 授权的反击</h3>
<div class="paragraph">
<p>我们的注册页面 URL 将看起来像 <code>/auth/register</code>。它接受 GET 和 POST 请求。最后是代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub auth-routes(Blog::Database $db) is export {
    route {
        get -&gt; Blog::Session $session, &#39;register&#39; {
            template &#39;register.crotmp&#39;, { :logged-in($session.user-id.defined), :!error };
        }

        post -&gt; Blog::Session $session, &#39;register&#39; {
            request-body -&gt; (:$username!, :$password!, *%) {
                with $db.get-user($username) {
                    template &#39;register.crotmp&#39;, { error =&gt; &#34;User $username is already registered&#34; };
                } else {
                    $db.add-user(:$username, :password(argon2-hash($password)));
                    redirect :see-other, &#39;/auth/login&#39;;
                }
            }
        }
        ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一次调用 get 会创建一个处理程序，用于 GET 请求到 <code>/auth/register</code> URL。<code>auth</code> 部分在这个路由中是一个默认的前缀，因为我们把它指定为一个命名参数。</p>
</div>
<div class="paragraph">
<p>它调用 <code>Cro::WebApp</code> 模块中的 <code>template</code>，用第二个参数中指定的数据来渲染我们的模板。处理程序块的第一个参数 <code>$session</code> 与 URL 部分无关，指定这个处理程序需要一个会话对象来处理这个用户。</p>
</div>
<div class="paragraph">
<p>第二条路由是对同一 URL 的 POST 请求。它使用 <code>request-body</code> 将表单数据解包到变量中。接下来的几行检查用户是否已经存在，在这种情况下会呈现一个错误，否则就创建一个新用户。不要忘记对密码进行哈希处理! 当新用户账户被创建后，我们设置一个重定向到登录页面。</p>
</div>
<div class="paragraph">
<p><code>request-body</code> 很聪明，可以不做任何改变地根据内容类型解析请求数据，无论是 json、普通表单、multipart 表单数据还是任何你可以实现处理的内容类型。</p>
</div>
<div class="paragraph">
<p>登录页面非常相似：GET 返回一个模板，POST 收集数据并处理，但有一个变化。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">post -&gt; Blog::Session $session, &#39;login&#39; {
    request-body -&gt; (:$username!, :$password!, *%) {
        my $user = $db.get-user($username);
        with $user {
            if (argon2-verify($_&lt;password&gt;, $password)) {
                $session.user-id = $_&lt;id&gt;;
                redirect :see-other, &#39;/&#39;;
            } else {
                template &#39;login.crotmp&#39;, { :!logged-in, error =&gt; &#39;Incorrect password.&#39; };
            }
        } else {
            template &#39;login.crotmp&#39;, { :!logged-in, error =&gt; &#39;Incorrect username.&#39; };
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然几乎所有的东西都是相似的，因此并不难理解，但我们可以看到这个路由处理程序实际上是使用 <code>$session</code> 对象在登录时分配一个用户 ID。</p>
</div>
<div class="paragraph">
<p>其他的事情都不需要做，Cro::HTTP 会把这个 session 保存在一个存储空间里，在这个用户的下一次请求中，只要传递了 session key，处理程序就可以检查这个用户是否已经登录，如果是，ID 是什么。</p>
</div>
<div class="paragraph">
<p>其他的东西都是典型的：<code>request-body</code> 来解析表单、模板、重定向和 Raku 代码。</p>
</div>
<div class="paragraph">
<p>至于注销，代码也很短。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; Blog::Session $session, &#39;logout&#39; {
    $session.user-id = Nil;
    redirect :see-other, &#39;/&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们可以随意擦除会话对象数据，然后重定向。</p>
</div>
</div>
<div class="sect2">
<h3 id="_路由博客">53.11. 路由：博客</h3>
<div class="paragraph">
<p>除了写无聊的模板，现在我们应该有一个简单的应用程序，具有创建新用户和登录的功能。</p>
</div>
<div class="paragraph">
<p>但是当用户被重定向到我们网站的索引页时，一个可悲的错误欢迎他们。让我们让它变得更受欢迎吧!</p>
</div>
<div class="paragraph">
<p>这就需要一个新的模块，<code>Blog::Routes::Blog</code>。</p>
</div>
<div class="paragraph">
<p>再次，将其纳入我们的主路由中，用一段简单的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Blog::Routes::Blog;
...
include blog-routes($db);</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，我们没有传递一个命名参数。原因是，虽然我们希望与博客相关的路由在 <code>/blog</code> 前缀下服务，但这个路由也会处理索引页，<code>/</code>，没有前缀。相反，我们可以在后面做一个简单的技巧。</p>
</div>
<div class="paragraph">
<p>在索引页，我们显示所有用户的帖子。首先，我们需要在 <code>Blog::Database</code> 中定义一个方法来收集我们需要的所有信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method get-posts {
    %!posts.values.map({
        $_&lt;username&gt; = %!users{$_&lt;author-id&gt;}&lt;username&gt;;
        $_;
    }).sort(*.&lt;created&gt;);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然看起来有点神秘，其实我们只是模仿 SQL JOIN 子句，因为我们想在帖子中显示作者的用户名，而不仅仅是 ID。</p>
</div>
<div class="paragraph">
<p>可以这样理解。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于 <code>%!posts</code> hash, take all values ⇒</p>
</li>
<li>
<p>对于每个值，也就是哈希值本身，添加一个新的 item ⇒</p>
</li>
<li>
<p>item 的键是用户名，item 的值是由帖子记录中存储的 <code>author-id</code> 键获得的 <code>%!users</code> 项的 username 值 ⇒</p>
</li>
<li>
<p>我们不使用显式返回，隐式返回一个块执行的最后结果。由于新的哈希键的赋值会返回赋值项的值而不是哈希值，所以我们需要一个单一的 <code>$_;</code> 来返回哈希值 ⇒</p>
</li>
<li>
<p>按创建日期对所有条目进行排序</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有了这些，我们就可以为索引页写一个处理程序。唉，那里没有什么有趣的东西在等着我们。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">get -&gt; Blog::Session $session {
    my $user = $session.logged-in ?? $db.get-user($session.user-id) !! {};
    $user&lt;logged-in&gt; = $session.logged-in;
    my $posts = $db.get-posts.map({
        $_&lt;created&gt; = Date.new($_&lt;created&gt;).Str;
        $_;
    });
    template &#39;index.crotmp&#39;, { :$user, :$posts };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了可用的会话对象和强大的数据库，我们收集数据并将其推送到一个模板中。很好!</p>
</div>
<div class="paragraph">
<p>由于我们现在已经有了 CRUD 的 R 部分，我们需要计划剩下的部分（这次不是 REST！）：创建、编辑和删除。</p>
</div>
<div class="paragraph">
<p>每个操作的 URL 将以 <code>/blog</code> 为前缀。我们是否需要创建另一个路由模块来避免为每个路由处理程序写出这个恼人的前缀？也许是，但也许不是。在这种情况下，我们就内联 <code>include</code> 吧。或者是内联 include？</p>
</div>
<div class="paragraph">
<p>不管它是什么方式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">include &lt;blog&gt; =&gt; route {
    get -&gt; ...
    post -&gt; ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于我们刚刚调用了我们的 <code>*-routes</code> 子程序，所以我们可以直接省略这层间接，牺牲四个空格的缩进。</p>
</div>
<div class="paragraph">
<p>(顺便说一下，<code>*-routes</code> 的命名方案的使用没有义务，但它很容易记忆和使用)</p>
</div>
<div class="paragraph">
<p>看完注册路由处理程序，创建帖子的那个是典型的：get 会用表单服务一个模板，而 post 会用 request-body 解析表单，做一个调用 DB 保存帖子，并做一个重定向。</p>
</div>
<div class="paragraph">
<p>接下来的两条路线是更新和删除。我们把它们写出来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">post -&gt; LoggedIn $session, UInt $id, &#39;update&#39; {
    with $db.get-post($id) -&gt; $post {
        if $post&lt;author-id&gt; == $session.user-id {
            request-body -&gt; (:$title!, :$body!) {
                $db.update-post($id, $title, $body);
                redirect :see-other, &#39;/&#39;;
            }
        } else {
            forbidden;
        }
    } else {
        not-found;
    }
}

post -&gt; LoggedIn $session, UInt $id, &#39;delete&#39; {
    with $db.get-post($id) -&gt; $post {
        if $post&lt;author-id&gt; == $session.user-id {
            $db.delete-post($id);
            redirect :see-other, &#39;/&#39;;
        } else {
            forbidden;
        }
    } else {
        not-found;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意我们使用 <code>LoggedIn</code> 子集作为 <code>$session</code> 对象的类型。在路由请求的过程中，它的 session 对象将被检查是否符合要求（在本例中，用户是否登录），如果不符合要求，将形成 Unauthorized response。</p>
</div>
<div class="paragraph">
<p>现在仔细看这段代码，我是看到它来了…​</p>
</div>
<div class="paragraph">
<p>当在罗马的时候，做罗马人做的事，他们说，而且，事实上，当在 Raku 中写代码时，这种疯狂的模板数量是荒谬的！我要求神和女神，甚至是圣诞老人自己，我们希望并能做得比这更好。我要求诸神和女神，甚至是圣诞老人本人，我们想要并且能够做得更好！而这些都是由可怕的贡献者所带来的语言和库。</p>
</div>
<div class="paragraph">
<p>而来自全球各地的了不起的贡献者给我们带来的语言和库，让我们让它变得更整洁吧。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| A helper for executing code blocks
#| only on posts one can access
sub process-post($session, $id, &amp;process) {
    with $db.get-post($id) -&gt; $post {
        if $post&lt;author-id&gt; == $session.user-id {
            &amp;process($post);
        } else {
            forbidden;
        }
    } else {
        not-found;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们取一个会话，帖子的 <code>$id</code> 和要做的操作。如果帖子存在，检查该用户是否有权限修改它。一切正常？执行代码! 有问题吗？通知用户!</p>
</div>
<div class="paragraph">
<p>现在我们可以把上面的 POST 路由重新写成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">post -&gt; LoggedIn $session, UInt $id, &#39;update&#39; {
    process-post($session, $id, -&gt; $ {
        request-body -&gt; (:$title!, :$body!) {
            $db.update-post($id, $title, $body);
            redirect :see-other, &#39;/&#39;;
        }
    });
}

post -&gt; LoggedIn $session, UInt $id, &#39;delete&#39; {
    process-post($session, $id, -&gt; $ {
        $db.delete-post($id);
        redirect :see-other, &#39;/&#39;;
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使是现在，我也想和 Santa 讨论一下，是否值得把重定向调用的因素纳入我们的 helper 子程序。我的回答是：没有。</p>
</div>
<div class="paragraph">
<p>希望在这里采取的观点是，可以灵活地将处理请求的逻辑因子化。还有应用程序中的角色。还有 cookie。Om-nom-nom。</p>
</div>
</div>
<div class="sect2">
<h3 id="_将_nginx_设置为反向代理">53.12. 将 nginx 设置为反向代理</h3>
<div class="paragraph">
<p>比方说，你想把你的应用程序隐藏在 nginx 反向代理后面。无论是负载均衡、免费缓存还是其他原因，都有理由这么做。因为我们做的应用可以用它的原生工具来服务，所以不需要做那么多配置来实现。前提是你的服务器上要安装 nginx。</p>
</div>
<div class="paragraph">
<p>接下来，你用 Cro 命令行工具运行器运行它，有了工作的端口，你就可以修改 nginx 配置中的服务器部分（最简单的情况下，GNU/Linux 系统上的位置是 <code>/etc/nginx/nginx.conf</code>）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nginx" data-lang="nginx">server {
    listen       80;
    server_name  localhost;

    location / {
        proxy_pass http://localhost:20000/;
    }
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一步，使用 <code>nginx -t</code> 命令检查结果配置是否正确，并使用 <code>nginx -s reload</code> 重新加载服务器。</p>
</div>
<div class="paragraph">
<p>鉴于你的应用程序已经启动并运行，你应该能够访问 localhost 并看到主页面。</p>
</div>
<div class="paragraph">
<p>还可以做很多其他的事情：写一个单元，以便在故障或机器重启的情况下轻松管理你的服务，你的 nginx 配置可能会更有趣，还可以添加 HTTPS 支持（强烈推荐），因为我们的服务有 auth 片段，通过纯 HTTP 发送密码是很危险的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_构建_docker_镜像">53.13. 构建 docker 镜像</h3>
<div class="paragraph">
<p>所以服务是很酷的，但现在大家谈论的是 Docker 和 Kubernetes。介意把你的应用容器化吗？想个好听的名字，然后在你的项目根目录下用它执行这个命令。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">docker build -t $my-cool-app-name-here</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是全部! 一个容器就为你准备好了，你可以按照自己的意愿来管理它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结束语">53.14. 结束语</h3>
<div class="paragraph">
<p>在这个比较长的教程中，我们讨论了一些基本的话题。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>中小型 Cro 应用的结构。</p>
</li>
<li>
<p>一般的授权和认证部分以及具体的实现实例。</p>
</li>
<li>
<p>常用的路由处理程序的实现。</p>
</li>
<li>
<p>你的应用程序的服务和部署。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当然，还有更多的功能以及很酷的技巧，然而这远远超出了这篇已经很长的文章。</p>
</div>
<div class="paragraph">
<p>包括模板在内的完整源码可以在 <a href="https://github.com/Altai-man/sample-cro-crud">这里</a>获得。</p>
</div>
<div class="paragraph">
<p>恭喜你完成本教程! 在 12 月到来之际，祝你喝上一杯热饮，度过美好的一天。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://raku-advent.blog/2019/12/02/crud-cro-http-tutorial/" class="bare">https://raku-advent.blog/2019/12/02/crud-cro-http-tutorial/</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第三天_栈帧规约">54. 第三天 - 栈帧规约</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_什么是栈帧">54.1. 什么是栈帧?</h3>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2019/12/plates-by-brooke-lark.jpg?w=750&amp;zoom=2" alt="Stack Frame"/>
</div>
</div>
<div class="paragraph">
<p>对于那些不熟悉栈的人来说，它是你的程序使用的一点内存。它的速度很快，但有限。</p>
</div>
<div class="paragraph">
<p>每当你调用一个过程(函数、方法…​ 命名是一件很复杂的事情)，你的程序就会在栈上得到一点存储空间，我们称之为帧。</p>
</div>
<div class="paragraph">
<p>栈帧被用来存储参数、局部变量、临时存储以及一些关于调用上下文的信息。</p>
</div>
<div class="paragraph">
<p>这意味着，如果你有一个递归过程调用，你的程序会不断地要求栈帧，直到你最终返回一个值, 内存被释放出来。</p>
</div>
</div>
<div class="sect2">
<h3 id="_一个快速而简单的例子">54.2. 一个快速而简单的例子</h3>
<div class="paragraph">
<p>让我们举一个基本递归排序算法的标准例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub factorial (Int $n --&gt; Int) {
        $n == 0 ?? 1 !! $n * factorial($n - 1)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个非常简单的递归示例，通常我们在这段代码中不必担心栈帧的堆积。也就是说，这是一个很好的起点，可以展示如何减少堆积。</p>
</div>
<div class="paragraph">
<p><strong>GOTO reduction:</strong></p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2019/12/basic.png?w=461&amp;zoom=2" alt="Goto"/>
</div>
</div>
<div class="paragraph">
<p>这种减少栈帧堆积的方式对大多数人来说应该是很熟悉的，这就是程序化编程处理递归的方式。</p>
</div>
<div class="paragraph">
<p>这种模式最基本的实现是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub factorial (Int $n is copy --&gt; Int) {
        my Int $result = 1;
        MULT:
        $result *= $n;
        $n--;
        goto MULT if $n &gt; 0;
        return $result;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>GOTO 在 Raku 中还没有实现，但应该相当明显，我们可以很容易地用一个现有的关键词来代替它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub factorial (Int $n is copy --&gt; Int) {
        my Int $result = 1;
        while $n &gt; 0 {
                $result *= $n;
                $n--;
        }
        return $result;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>不过这确实违背了试图使用递归的目的。因此，Raku 提供了 <code>samewith</code> 这个关键词:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub factorial (Int $n --&gt; Int) {
        $n == 0 ?? 1 !! $n * samewith($n - 1);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这下好了，递归而不至于产生上千个栈帧。虽然我还是觉得我们缺少了一些东西…​</p>
</div>
</div>
<div class="sect2">
<h3 id="_蹦床">54.3. 蹦床</h3>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2019/12/trampoline-by-charles-cheng.jpg?w=750&amp;zoom=2" alt="TRAMPOLINE"/>
</div>
</div>
<div class="paragraph">
<p>蹦床是功能编程中的一种设计模式。 与普通的 GOTO 式换算相比，它有点复杂，但在正确的人手中，它可以非常强大。</p>
</div>
<div class="paragraph">
<p>蹦床模式背后的基本原理如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们可以期望用我们正在计算的值做一些事情。</p>
</li>
<li>
<p>我们可以将我们的 TODO 传递到计算值的函数中。</p>
</li>
<li>
<p>我们可以让我们的函数生成自己的延续。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub trampoline (Code $cont is copy) {
        $cont = $cont() while $cont;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以我们给 <code>trampoline</code> 传递一个函数。该函数被调用。这个函数有选择地返回一个后续函数。只要我们得到一个后续函数，我们就会继续调用它并分配结果，直到我们完成。</p>
</div>
<div class="paragraph">
<p>这就需要对 <code>factorial</code> 函数进行一下改写。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub factorial (Int $n, Code $res --&gt; Code) {
        $n == 0 ?? $res(1) !! sub { factorial($n - 1, sub (Int $x) { $res($n * $x) }) }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要解开那个堆积的函数堆:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果 <code>$n</code> 是 0, 我们就可以继续进行下去.</p>
</li>
<li>
<p>否则我们返回一个匿名函数，再次调用 <code>factorial</code>。</p>
</li>
<li>
<p>前面的步骤一直传播到我们到达 0，在这里我们得到用 1 调用的结果。</p>
</li>
<li>
<p>这就将之前的 <code>$n</code> 与 1 相乘，并将结果向后传播。</p>
</li>
<li>
<p>最后，结果被传播到最外层的块，并被传递到延续中。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>那么，我们会使用 <code>trampoline</code> 的方式如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">trampoline(sub { factorial($n, sub (Int $x) { say $x; Nil }) });</code></pre>
</div>
</div>
<div class="paragraph">
<p>又是一堆纠缠不清的函数要解包。</p>
</div>
<div class="paragraph">
<p>我们向 <code>trampoline</code> 发送一个匿名函数 调用一个数字 <code>$n</code> 的 <code>factorial</code> 和一个匿名的 <code>continuation</code>。</p>
</div>
<div class="paragraph">
<p>阶乘的延续是说阶乘的结果，然后停止（Nil）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_奖励回合">54.4. 奖励回合</h3>
<div class="paragraph">
<p>为什么你要用 <code>trampoline</code> 来做一些可以用普通的循环来做的事情呢？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub factorial-bounce (Int $n --&gt; Code) {
        sub { factorial($n, sub ($x) { say $x, factorial-bounce($x) }) }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://rakuadventcalendar.wordpress.com/2019/12/03/day-3-stack-frame-reduction/" class="bare">https://rakuadventcalendar.wordpress.com/2019/12/03/day-3-stack-frame-reduction/</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第四天_不被_tripscodes_绊倒">55. 第四天 - 不被 tripscodes 绊倒</h2>
<div class="sectionbody">
<div class="paragraph">
<p>大家好，今天我们要看的是三联码的实现，三联码是一种用于在互联网上匿名签署帖子的散列法。</p>
</div>
<div class="paragraph">
<p>有不同的算法可以做到这一点，但我们感兴趣的是一种生成非安全的老式三联码的算法。</p>
</div>
<div class="sect2">
<h3 id="_那么它是什么呢">55.1. 那么它是什么呢？</h3>
<div class="paragraph">
<p>假如有一个网站允许在匿名的情况下留言。无需注册，无需登录，无需用户名。</p>
</div>
<div class="paragraph">
<p>你回复一个帖子，然后一个人在回复你的回复。你开始了一段对话。你知道你的帖子是你的。但其他用户呢？你是在和同一个人说话，还是一群孩子在玩弄你的把戏？不知道! 在某些情况下，为了解决这种混乱，可以使用一个三联码。</p>
</div>
<div class="paragraph">
<p>这个想法很简单：随着你的帖子，你可以传递你想要的昵称和密码。网站会把一个密码和哈希值转换成一个三联码。在显示帖子时，三联码会附在信息上，所以你可以确定这是同一个知道密码的人。当然，没有人要求人们宣称自己帖子的作者身份，但我们暂且不说，因为我们对一个实现方式很感兴趣。</p>
</div>
</div>
<div class="sect2">
<h3 id="_手边的例子">55.2. 手边的例子</h3>
<div class="paragraph">
<p>实现这个算法只需要一个子程序。然而我们需要一种方法来测试我们的三联码。让我们为你的 <code>tripcode</code> 子程序定义一些测试规则。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Test;

is tripcode(&#39;a&#39;), &#39;!ZnBI2EKkq.&#39;;
is tripcode(&#39;¥&#39;), &#39;!9xUxYS2dlM&#39;;
is tripcode(&#39;\\&#39;), &#39;!9xUxYS2dlM&#39;;
is tripcode(&#39;»&#39;), &#39;!cPUZU5OGFs&#39;;
is tripcode(&#39;?&#39;), &#39;!cPUZU5OGFs&#39;;
is tripcode(&#39;&amp;&#39;), &#39;!MhCJJ7GVT.&#39;;
is tripcode(&#39;&amp;amp;&#39;), &#39;!QfHq1EEpoQ&#39;;
is tripcode(&#39;!@#heheh&#39;), &#39;!eW4OEFBKDU&#39;;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_raku_代码">55.3. Raku 代码</h3>
<div class="paragraph">
<p>现在我们来看看算法。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>转义 HTML 字符</p>
</li>
<li>
<p>将所有字符转换为 CP932 编码。对于无法转换的字符，使用 <code>?</code> 符号</p>
</li>
<li>
<p>将产生的字节解码为 UTF8</p>
</li>
<li>
<p>为我们的哈希生成盐。要做到这一点，将 <code>H.</code> 字符串添加到我们的解码字符串中（因为它可能是空的！），取第二个和第三个字符。接下来，用点来代替任何&#34;奇怪&#34;的字符（在 ASCII 术语中，任何代码低于 46 (.) 而高于 122 (z) 的字符）。</p>
</li>
<li>
<p>将一些非单词字符(:;&lt;=&gt;?@[\\]^_`)翻译成 ABCDEFGabcdef。</p>
</li>
<li>
<p>使用 UNIX 函数 crypt 与解码后的字符串和我们得到的盐，并采取了它的最后 10 个字符。</p>
</li>
<li>
<p>这就是全部了!</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有相当多的步骤，但让我们看看如何在 Raku 中编写这样一个任务。</p>
</div>
<div class="paragraph">
<p>让我们从一个子例程声明开始。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub tripcode($pass is copy) {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将在原地修改 <code>$str</code> 变量，所以参数的复制特性将帮助我们防止&#34;传递的 Str 值是不可变的&#34;错误。</p>
</div>
<div class="paragraph">
<p>接下来，对 HTML 进行转义:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub tripcode($pass is copy) {
    $pass .= trans([&#39;&amp;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;] =&gt; [&#39;&amp;amp;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;gt;&#39;]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过 <code>trans</code> 方法，我们可以用&#34;从左到右&#34;的对应关系替换字符串中的字符，所以 <code>&amp;</code> 被替换为 <code>&amp;</code>，<code>&lt;</code> 被替换为 <code>&lt;</code> 等等。</p>
</div>
<div class="paragraph">
<p>接下来的事情-与 Windows 932 共舞。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$pass .= trans([&#39;&amp;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;] =&gt; [&#39;&amp;amp;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;gt;&#39;]);
$pass = ([~] $pass.comb.map({ (try .encode(&#39;windows-932&#39;)) // Buf.new(0x3F) })).decode;</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们想象一下，一步步写出这些行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># split $pass into single characters
$pass.comb
# for every character in the list resultring from `comb` method call
$pass.comb.map({  })
# try to encode it into the encoding we want
$pass.comb.map({ try .encode(&#39;windows-932&#39;) })
# when `try` returned `Nil`, use `//` operator which means `If the left side is not defined,`use the right side
$pass.comb.map({ ((try .encode(&#39;windows-932&#39;)) // Buf.new(0x3F) })
# Use [~] unary metaoperator, which is a shortcut for &#34;join this array using this operator to join two single elements&#34;
([~] $pass.comb.map({ (try .encode(&#39;windows-932&#39;)) // Buf.new(0x3F) }))
# At last, decode the resulting buffer and assign it to the variable
$pass = ([~] $pass.comb.map({ (try .encode(&#39;windows-932&#39;)) // Buf.new(0x3F) })).decode;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们需要为我们的哈希生成一些盐。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $salt = &#34;{$pass}H.&#34;.substr(1, 2).subst(/&lt;-[. .. z]&gt;/, &#39;.&#39;).trans(&#39;:;&lt;=&gt;?@[\\]^_`&#39; =&gt; &#39;ABCDEFGabcdef&#39;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，我们在密码中添加 <code>H.</code> 部分，然后使用 <code>substr</code> 调用取第二个和第一个字符。 请注意，第二个调用是 <code>subst</code>，它将 regex 范围外的任何字符用点来代替。在这里，<code>substr</code> 是 <code>substring</code> 的简称，而 <code>subst</code> 是 <code>substitution</code> 的简称。 然后就是我们的 <code>trans</code> 方法了。</p>
</div>
<div class="paragraph">
<p>作为接下来的事情，我们需要调用 UNIX 加密函数。幸运的是，我们不需要实现它! 在 Raku 的生态系统中，已经有一个由 <code>Jonathan Stove++</code> 编写的 Crypt::Libcrypt 模块。让我们安装它吧。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">zef install Crypt::Libcrypt</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以导入这个模块，并在我们的服务中使用 <code>crypt</code> 子例程。最后一行很简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#39;!&#39; ~ crypt($pass, $salt).substr(*-10, 10);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们不需要编写显式的 <code>return</code> 语句，因为块的最后一条语句被视为其返回值。调用 <code>crypt</code> 子例程和我们的老朋友 <code>substr</code>，第一个参数看起来很有趣。第二个参数照例是我们想要的字符数，而第一个参数是一个表达式, 用的是 Whatever Star。在调用时，<code>substr</code> 调用者的长度会被传递到这个微型代码块中，因此将其翻译为 ’foo&#39;.substr(&#39;foo&#39;.chars() - 10, 10)（但里面更聪明）。</p>
</div>
<div class="paragraph">
<p>梳理好一切，我们得到一个完整的定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub tripcode($pass is copy) {
    $pass .= trans([&#39;&amp;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;] =&gt; [&#39;&amp;amp;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;gt;&#39;]);
    $pass = ([~] $pass.comb.map({ (try .encode(&#39;windows-932&#39;)) // Buf.new(0x3F) })).decode;
    my $salt = &#34;{$pass}H.&#34;.substr(1, 2).subst(/&lt;-[. .. z]&gt;/, &#39;.&#39;).trans(&#39;:;&lt;=&gt;?@[\\]^_`&#39; =&gt; &#39;ABCDEFGabcdef&#39;);
    &#39;!&#39; ~ crypt($pass, $salt).substr(*-10, 10);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>检查：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; perl6 tripcode.p6
ok 1 -
ok 2 -
ok 3 -
ok 4 -
ok 5 -
ok 6 -
ok 7 -
ok 8 -</code></pre>
</div>
</div>
<div class="paragraph">
<p>成功了，我们准备的所有检查都通过了！由于我们只用了四行代码就成功地实现了这个算法，现在是时候补充一些热饮了。祝你有个愉快的一天!</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://raku-advent.blog/2019/12/04/not-tripping-over-tripcodes/" class="bare">https://raku-advent.blog/2019/12/04/not-tripping-over-tripcodes/</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第五天_模块化_raku_命令行应用">56. 第五天 - 模块化 Raku 命令行应用</h2>
<div class="sectionbody">
<div class="paragraph">
<p>圣诞节前三个星期，圣诞老人的工作坊一团糟。精灵们四处奔波，试图将一切准备就绪，看起来一切都不会。</p>
</div>
<div class="paragraph">
<p>圣诞老人一走进去，他就被一群不幸的精灵包围，所有人立刻抱怨。</p>
</div>
<div class="paragraph">
<p>&#34;这个系统太慢了！&#34;一个管道说道：&#34;仅仅打印出一个帮助文件就需要一秒钟。&#34;</p>
</div>
<div class="paragraph">
<p>&#34;并且帮助文件是错误的！它已经过时了。</p>
</div>
<div class="paragraph">
<p>&#34;我刚刚发现增加一个将孩子从顽皮的孩子转移到尼斯的命令，除了别的事情之外，都会默默地死去！！！&#34;第三个声音非常骚扰，属于一个名单很长的精灵。</p>
</div>
<div class="paragraph">
<p>圣诞老人很担心，他一年中的大部分时间都在与许多开发精灵合作，以更新其较旧的系统以使用 <a href="https://raku.org/">Raku</a>，他们认为一切都在进行中。所有不同的模块在测试中都运行得非常好，并且管理该系统的单个命令是他真正没有参与的唯一部分。</p>
</div>
<div class="paragraph">
<p>他四处寻找负责该项目的精灵 Snowneth，但没有看到他。一连串的问题，圣诞老人发现 Snowneth 几个月前得了小儿流感，当时他仍然生病。</p>
</div>
<div class="paragraph">
<p>圣诞老人因为没有跟上事情而踢自己，但还有很多事情要做，他记下了便条，然后在 Snowneth 进行检查。现在找出问题出在哪里，为什么没人告诉他！</p>
</div>
<div class="paragraph">
<p>他打开笔记本电脑，以测试模式试用了主要的系统服务：</p>
</div>
<div class="paragraph">
<p>helper -?</p>
</div>
<div class="paragraph">
<p>几秒钟后，系统给了他一个命令行提示符……没别的。</p>
</div>
<div class="paragraph">
<p>helper -h</p>
</div>
<div class="paragraph">
<p>这次，他得到了一个文档页面，对其进行了快速扫描，他可以看到许多命令被错误地记录下来，并且至少丢失了两个最新的命令。由于害怕他会看到他打开了 git 日志，所有提交都由他认识的多个名称完成。分配给 Snowneth 团队的初级 Dev-elf。</p>
</div>
<div class="paragraph">
<p>他关上笔记本电脑，去找咖啡机。</p>
</div>
<div class="paragraph">
<p>几个小时，然后喝咖啡，圣诞老人和许多年轻的，看上去很担心的精灵挤在一个小办公室里。圣诞老人打开了笔记本电脑，并在他们面前打开了服务脚本的代码，其中有 1000 行。</p>
</div>
<div class="paragraph">
<p>到现在为止，圣诞老人发现发生了什么事，斯诺思病了，每个人都以为别人会任命新的团队负责人。同时，大三学生竭尽所能完成这项工作。圣诞老人花了一点时间屏住呼吸，并写下了声音。</p>
</div>
<div class="paragraph">
<p>&#34;首先，我必须道歉。我敢肯定，你们所有人都承受着很大的压力，并且你们都竭尽所能完成这项至关重要的工作。&#34;</p>
</div>
<div class="paragraph">
<p>大三学生振作起来，到现在，他们都已经收到了这样的信息：他们的工作导致车间运行缓慢，甚至可能取消圣诞节！他们原本期望被大吼大叫，甚至被送去嘲弄驯鹿。
一个陷入困境的小精灵的传统工作。</p>
</div>
<div class="paragraph">
<p>&#34;我们可以了解以后发生的情况，现在我们需要尽快修复此代码，并畅通无阻。我希望大家都能帮助我完成这项工作。&#34;</p>
</div>
<div class="paragraph">
<p>到现在，三年级学生在点点头和微笑的时候，圣诞老人很高兴，他应该早已陷入困境，他希望通过让他们参与清理工作，他们可以重新获得信心。</p>
</div>
<div class="paragraph">
<p>&#34;对，那么我们有什么问题？&#34;</p>
</div>
<div class="paragraph">
<p>每个人都说了出来，他们很快就列出了一个清单：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>任何命令启动缓慢</p>
</li>
<li>
<p>某些命令输入验证不正确</p>
</li>
<li>
<p>过时的文档</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>还有其他几件事，但似乎有三件事是主要的。</p>
</div>
<div class="paragraph">
<p>&#34;好。这么慢的启动。我认为这很明显吧？&#34;</p>
</div>
<div class="paragraph">
<p>所有的小学生都看着他，然后一个人举起了手。</p>
</div>
<div class="paragraph">
<p>&#34;不是吗？你怎么看？无需举手，只需大声说…​反过来，不要互相喊叫。&#34;</p>
</div>
<div class="paragraph">
<p>&#34;是因为脚本太长了吗？我想我读到一个 Raku 脚本在您调用时已编译？如果我们使脚本更短，它将运行得更快？&#34;</p>
</div>
<div class="paragraph">
<p>&#34;虽然可以，但复杂程度降低可能是一个更好的目标。我们有很多 if 子句之类。要记住的重要一点是，<a href="https://docs.raku.org/language/modules">模块</a>代码是预编译的，而主脚本不是。因此，我们将尽可能使用模块。&#34;</p>
</div>
<div class="paragraph">
<p>初中生点了点头。然后一个人说了出来。</p>
</div>
<div class="paragraph">
<p>&#34;但是我们使用的是模块，它们都位于脚本顶部，但是我们必须确定人们正在调用的命令，然后确定要传递的参数。然后……&#34;圣诞老人举起了手。</p>
</div>
<div class="paragraph">
<p>&#34;我可以看到那颤抖。我认为那是我们应该开始的地方。&#34;他指着屏幕上的一段代码。 &#34;谁能告诉我这是怎么回事。&#34;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Workshop::ListController::Nice;

my $command = @*ARGV[0];

if ( $command ~~ &#39;list&#39; ) {
    my $list-command = @*ARGV[1];
    if ( $list-command ~~ &#39;add&#39; ) {
        if ( @*ARGV[2] ~~ &#39;nice&#39; ) {
           Workshop::ListController::Nice.add-child( @*ARGV[3] );
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>等等。 大三学生看着它，互相交谈。 Sniffy 再次开口。</p>
</div>
<div class="paragraph">
<p>&#34;这有点复杂，它不是以这种方式开始的，但是随着我们添加命令的增加，它变得更大。 而且我们也不会检查孩子的名字是否有效&#34;</p>
</div>
<div class="paragraph">
<p>&#34;是真的，但我想知道你为什么读 <a href="https://docs.raku.org/language/variables#index-entry-@*ARGS">@*ARGS</a>？&#34;</p>
</div>
<div class="paragraph">
<p>他们的脸上有些困惑。</p>
</div>
<div class="paragraph">
<p>&#34;为什么我们没有 <a href="https://docs.raku.org/language/create-cli#index-entry-MAIN">MAIN</a> 子程序？&#34;</p>
</div>
<div class="paragraph">
<p>仍然很混乱。</p>
</div>
<div class="paragraph">
<p>&#34;好。 你们都去查一下。 我会举一个例子。&#34;</p>
</div>
<div class="paragraph">
<p>当精灵们进入 <a href="https://docs.raku.org/">Raku 文档</a>网站并开始搜索时，他迅速打字。 当他听到他们的惊叹声升起，然后逐渐安静时，他转身离开了键盘。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Workshop::ListController::Nice;

multi sub MAIN( &#34;list&#34;, &#34;add&#34;, &#34;nice&#34;, ValidChildName $child ) { Workshop::ListController::Nice.add-child( @*ARGV[3] ); }
multi sub MAIN( &#34;list&#34;, &#34;add&#34;, &#34;nice&#34;, Str $invalid-child ) { die &#34;Invalid childname {$invalid-child}&#34;; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>初中同学鼓掌。</p>
</div>
<div class="paragraph">
<p>&#34;因此，我们可以将 Raku multi 调度与 <strong>MAIN</strong> 一起使用，以将我们的所有命令创建到相当细致的级别，并进行类型检查。 我认为这是一个不错的起点。 我希望我们能使脚本中的所有内容全部消失。&#34;</p>
</div>
<div class="paragraph">
<p>第二天，情况看起来更好，脚本启动速度更快，输入验证问题也已解决。 每个人都感觉好多了。 圣诞老人甚至有时间去看 Snoweth 并确保他没事。</p>
</div>
<div class="paragraph">
<p>&#34;好吧…​现在让我们看看。&#34;</p>
</div>
<div class="paragraph">
<p>他指着文件中剩余的最大子程序，它从此开始。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub MAIN( :$h where so * ) {
    say &#34;Usage:&#34;;
    say &#34;  helper list add nice [child] : Adds a child to the Nice list.&#34;
    say &#34;  helper stable rota list : Lists the current rota for cleaning the stables.&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>一只精灵跳到她的脚上，眼睛闪闪发光。</p>
</div>
<div class="paragraph">
<p>&#34; Gimlina，我相信您对此有一些想法。&#34;</p>
</div>
<div class="paragraph">
<p>&#34;我们应该使用<a href="https://docs.raku.org/language/pod#index-entry-declarator_blocks_#=">声明符块</a>！&#34;圣诞老人笑着说，他昨天不得不抑制小精灵的热情，以使团队专注于手头的任务。 他微笑着点了点头。</p>
</div>
<div class="paragraph">
<p>&#34;继续。&#34;</p>
</div>
<div class="paragraph">
<p>&#34;如果在子例程和参数中添加声明符块，则会免费获得预生成的文档。 只要代码更改，它就会更新。&#34;</p>
</div>
<div class="paragraph">
<p>&#34;你能示范吗？&#34;</p>
</div>
<div class="paragraph">
<p>她笑了，提出了一些密码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| Add a child to the nice list
multi sub MAIN( &#34;list&#34;, &#34;add&#34;, &#34;nice&#34;,
    ValidChildName $child #= Child name to add
) {
    Workshop::ListController::Nice.add-child( @*ARGV[3] );
}

multi sub MAIN( &#34;list&#34;, &#34;add&#34;, &#34;nice&#34;, Str $invalid-child ) is hidden-from-USAGE { die &#34;Invalid childname {$invalid-child}&#34;; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#34;所以 #| 是做什么的？&#34;</p>
</div>
<div class="paragraph">
<p>&#34;将障碍物固定在其后的任何东西上。 #= 将块附加到前一项。&#34;</p>
</div>
<div class="paragraph">
<p>&#34;还有 <a href="https://docs.raku.org/language/create-cli#is_hidden-from-USAGE">is hidden-from-USAGE</a> 呢？&#34;</p>
</div>
<div class="paragraph">
<p>&#34;好吧，当您调用脚本时却不知道该怎么办，或者您通过了-？ 它调用 <a href="https://docs.raku.org/language/create-cli#sub_USAGE">USAGE</a> 函数，并显示 <a href="https://docs.raku.org/language/variables#index-entry-$*USAGE">$*USAGE</a> 字符串。 这是从声明程序块生成的。 但是您不想显示某些潜艇，因此可以将其隐藏。&#34;</p>
</div>
<div class="paragraph">
<p>她很快打出了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">helper -?
Usage:
  helper list add nice [child] -- Add a child to the nice list

        Child name to add</code></pre>
</div>
</div>
<div class="paragraph">
<p>圣诞老人点了点头，其余的大三学生都欢呼雀跃。 Gimlina 看起来很高兴，因为他们都转向向帮助程序脚本添加文档。</p>
</div>
<div class="paragraph">
<p>情况看起来更好，研讨会听起来更加快乐，并且文档进展顺利。当他在一个模块存储库中看到一个合并请求时，圣诞老人正坐在大三学生那里检查最后的事情。他看上去很困惑，他们已经被冻结了一个星期的代码，只能提出紧急的错误修复，并且除了帮助程序脚本之外，他没有其他问题。他再次诅咒自己，以为也许他确实需要一些产品经理精灵。</p>
</div>
<div class="paragraph">
<p>当他打开合并请求时，他的眼睛睁大了，他转向一个安静的初级人员，他们很聪明，但往往不说话，只是低着头做事。</p>
</div>
<div class="paragraph">
<p>&#34;嗯？ Workshop::ListController::Nice 模块中的 MR 是什么？&#34;</p>
</div>
<div class="paragraph">
<p>按照他的要求，等待他们过来，他看了看代码，现在他的眼睛已经睁大了，看起来好像从他的脑袋里鼓出来了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| Add a child to the nice list
multi sub MAIN is export(:MAIN) ( &#34;list&#34;, &#34;add&#34;, &#34;nice&#34;,
    ValidChildName $child #= Child name to add
) {
    Workshop::ListController::Nice.add-child( @*ARGV[3] );
}

multi sub MAIN( &#34;list&#34;, &#34;add&#34;, &#34;nice&#34;, Str $invalid-child ) is hidden-from-USAGE is export(:MAIN) { die &#34;Invalid childname {$invalid-child}&#34;; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#34;好吧，我在想先生，&#34;精灵以惊人的声音从他旁边说。 &#34;您说模块代码是预编译的。 因此，如果我们将 MAIN 子目录移入模块中，则会对其进行预编译。&#34;</p>
</div>
<div class="paragraph">
<p>&#34;模块团队可以管理自己的命令行界面和文档！&#34;圣诞老人高兴地叫道，埃里微笑着点了点头。</p>
</div>
<div class="paragraph">
<p>当天的其余时间很忙，其他所有开发人员（他们一直希望在假期后的积压之战之前冻结一个月的代码，好几个月）被告知新计划。</p>
</div>
<div class="paragraph">
<p>到最后，帮助程序脚本包含了很长的模块使用语句和一个单独的功能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Workshop::ListController::Nice :MAIN;

#| Display the help
multi sub MAIN( :h($help) where so * ) {
    say $*USAGE;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>圣诞老人看着它，然后看着 Snowneth，后者终于在当天下午将它带回了车间。 他耸了耸肩。</p>
</div>
<div class="paragraph">
<p>&#34;我不知道-？ 我已经习惯了-h。 不能伤害对吗？&#34;</p>
</div>
<div class="paragraph">
<p>圣诞老人点了点头，他们去帮忙在车间工作。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第六天_在你的_raku仓库中添加一些github动作">57. 第六天 - 在你的 Raku(仓库)中添加一些(GitHub)动作</h2>
<div class="sectionbody">
<div class="paragraph">
<p>经过一段时间的测试后，GitHub 动作终于在 2019 年 11 月向公众推出。它们很快就变得无处不在，并且与 GitHub 最近发布的其他发行版（包（和容器）注册表）结合在一起。</p>
</div>
<div class="paragraph">
<p>我们可以通过 Raku 模块充分利用它们。好吧，看看如何。</p>
</div>
<div class="sect2">
<h3 id="_我们可以使用一些动作">57.1. 我们可以使用一些动作</h3>
<div class="paragraph">
<p>操作是由存储库中的事件触发的脚本。原则上，您或程序与存储库进行交互时所做的任何操作都可能触发操作。当然，这包括 git 操作，这些操作基本上包括推送到存储库，还包括从 Wiki 中的更改到对拉取请求添加审阅的各种事件。</p>
</div>
<div class="paragraph">
<p>那你能做什么呢？ GitHub 创建了一个包含一些基本工具链以及您选择的语言解释器和编译器的容器。从根本上讲，您拥有的是一个容器，您可以在其中运行由事件触发的脚本。</p>
</div>
<div class="paragraph">
<p>GitHub 操作位于您存储库中 .github/workflows 目录内的 YAML 文件位置。让我们开始第一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">name: &#34;Merry Christmas&#34;
on: [push]

jobs:
  seasonal_greetings:
    runs_on: ubuntu-latest
    steps:
      - name: Merry Xmas!
        run: echo Merry Xmas!</code></pre>
</div>
</div>
<div class="paragraph">
<p>该脚本非常简单。它包含一个工作，只有一个步骤。让我们一点一点地走：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们给它起一个名字，“圣诞快乐”。该名称将显示在您的动作列表中。</p>
</li>
<li>
<p>on 是将触发此操作的事件列表。我们将只列出一个事件。</p>
</li>
<li>
<p>jobs 是一个数组，其中包含将顺序运行的作业列表。</p>
</li>
<li>
<p>每个作业都将具有自己的键，该键将用于引用它（以及存储变量，稍后将对此进行更多介绍），并且可以在自己的环境中运行，您必须选择该环境。我们将使用 <a href="https://help.github.com/es/actions/automating-your-workflow-with-github-actions/virtual-environments-for-github-hosted-runners#supported-runners-and-hardware-resources">ubuntu-latest</a>，这是一个仿生盒子，但还有其他选择（稍后会详细介绍）。</p>
</li>
<li>
<p>job 有一系列步骤，每个步骤都有一个名称，然后是一系列命令。 run 将在该特定步骤中定义的任何环境下运行；在这种情况下，一个简单的 shell 脚本将显示 Merry Xmas！</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于我们已通过 on 命令指示每次在推送到存储库时都运行，因此“操作”标签将显示 <a href="https://github.com/JJ/raku-advent-calendar-article-2019/commit/1cbe9578458dcd7b425e94a58998c53a1af49fe9/checks?check_suite_id=340377462">运行它的结果，就像这样</a>。如果没有问题，怎么办，因为它只是一个脚本，所以它将显示绿色的复选标记并产生结果：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://jj.github.io/raku-advent-calendar-article-2019/img/hello-action.png" alt="hello-action"/>
</div>
</div>
<div class="paragraph">
<p>这些步骤形成一种管道，每个步骤都可以产生输出或更改将在下一步中使用的环境； 这意味着您可以创建仅处理输入并为输出产生某些结果的管道操作，例如此操作</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">name: &#34;One step up&#34;
on: [push]

jobs:
  seasonal_greetings:
    runs-on: ubuntu-latest
    steps:
      - name: Pre-Merry Xmas!
        env:
          greeting: &#34;Merry&#34;
          season: &#34;Xmas&#34;
        run: |
          sentence=&#34;$greeting $season!&#34;
          echo ::set-env name=SENTENCE::$sentence
      - name: Greet
        id: greet
        run: |
          output=$(python -c &#34;import os; print(os.environ[&#39;SENTENCE&#39;])&#34;)
          echo ::set-output name=printd::$output
      - name: Run Ruby
        env:
          OUTPUT: ${{ steps.greet.outputs.printd }}
        run: /opt/hostedtoolcache/Ruby/2.6.3/x64/bin/ruby -e &#34;puts ENV[&#39;OUTPUT&#39;]&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此操作的第一步（代号为 &#34;Pre-Merry Xmas!&#34;）通过 env 声明了几个环境变量。我们将用一个句子整理它们。但是要点在于：GitHub Actions 使用元句，其前面带有 <code>::</code>，这些元句被打印以输出并解释为下一步的命令。在这种情况下，<code>::set-env</code> 设置环境变量。</p>
</div>
<div class="paragraph">
<p>下一步展示了 Python 的使用，这是该环境中的另一个默认工具。实际上，它与 Node 一起包含在每个环境中；您可以使用其默认版本，也可以将版本设置为操作变量。此步骤还使用类似的机制（而不是环境变量）来设置可用于下一步的输出。</p>
</div>
<div class="paragraph">
<p>与 Python 不同，Ruby 在路径中没有可用的默认版本。但是，这只是找到路径的问题，您可以像在这里一样使用它。此步骤还使用上一步骤的输出。 GHA 具有上下文，在这种情况下为步骤上下文，可用于访问先前步骤的输出。 steps.greet.outputs.printd 访问其 ID 被迎接的步骤的上下文（我们在此处通过 id 键声明了该步骤），并且由于我们声明输出为 printd，所以 output.printd 将使用该名称检索输出。动作环境中没有上下文，这就是为什么我们需要首先将其分配给环境变量的原因。输出将 <a href="https://github.com/JJ/raku-advent-calendar-article-2019/commit/01da3afeb1a5258293e328a9985a088bc7aa60d0/checks?check_suite_id=341279210">看起来像这样</a>，它将使用绿色的复选标记，并在原始日志中显示输出，如果您单击步骤名称，则将其显示出来。</p>
</div>
<div class="paragraph">
<p>如果您像我一样长期使用 Perl，那么您会错过的。 Ruby，Python，Node，流行语言，足够公平。但是 Perl 在 Ubuntu 16.04 的基础安装中。即使我们可以使用该环境，它似乎也已被淘汰。我们必须去哪里使用 Perl？到 Windows 环境。让我们用它来创建一个礼貌的机器人，在您创建或编辑问题时向您致意：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">name: &#34;We 🎔 Perl&#34;
on:
  issues:
    types: [opened, edited, milestoned]

jobs:
  seasonal_greetings:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2-beta
      - name: Maybe greet
        id: maybe-greet
        env:
          HEY: &#34;Hey you!&#34;
          GREETING: &#34;Merry Xmas to you too!&#34;
          BODY: ${{ github.event.issue.body }}
          TOKEN: ${{ secrets.GITHUB_TOKEN}}
          ISSUE: ${{ github.event.issue.number }}
        run: |
          $output=(perl utils/printenv.pl)
          $body= @{ &#39;body&#39;= $output } | ConvertTo-Json
          $header= @{
              &#39;Authorization&#39;=&#34;token $ENV:TOKEN&#34;
          }
          Invoke-RestMethod -Uri &#34;https://api.github.com/repos/JJ/raku-advent-calendar-article-2019/issues/$ENV:ISSUE/comments&#34; -Method &#39;Post&#39; -Body $body -Headers $header</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先检查 on 命令，该命令被设置为在每次创建，编辑或分配里程碑事件时将其触发，由于某种原因，该操作被称为里程碑。</p>
</div>
<div class="paragraph">
<p>![img](<a href="https://rakuadventcalendar.files.wordpress.com/2019/12/milestoned-lawn.jpg?w=2048" class="bare">https://rakuadventcalendar.files.wordpress.com/2019/12/milestoned-lawn.jpg?w=2048</a>)</p>
</div>
<div class="paragraph">
<p>您在上方看到的主要区别是，该操作将在运行该环境的环境中存在于 Windows 的最新版本中。但是接下来，我们将看到另外一件有趣的事情：它们可以简单地发布在 GitHub 上，并且可以重复使用。此签出操作将执行其说明：签出回购代码，默认情况下不可用。我们实际上不会对代码进行任何检查，但是我们需要创建的小 Perl 脚本。稍后对此进行更多讨论。</p>
</div>
<div class="paragraph">
<p>下一步是在创建，更改或等待问题里程碑时实际运行的步骤。我们声明了两个不同的环境变量：一个用于注释未提及 &#34;Merry&#34; 的问题，另一个用于注释。但是，接下来发生的事情是：我们可以使用问题正文，它可以作为上下文变量使用：github.event.issue.body。下一个变量是魔术键，它为 GitHub API 打开了大门。无需上传它或任何东西，它就可以为您准备好了，GitHub 会跟踪它并将其隐藏在任何出现的位置。我们还将需要发行号对此进行评论，并将其存储在 $ISSUE 变量中。</p>
</div>
<div class="paragraph">
<p>接下来，执行操作。我们将使用以下微型脚本，使用奇妙的 Perl 正则表达式来检查体内是否存在单词 Merry：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">print( ( ($ENV{BODY} =~ /Merry/) == 1)? $ENV{GREETING} : $ENV{HEY});</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>The next few PowerShell commands are, by far, the most difficult part of this article.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>我们运行脚本，以便将结果捕获并存储在变量中。 接下来的命令将创建 PowerShell 哈希，然后 $body 转换为 JSON。 通过使用 Invoke-RestMethod，我们使用 GitHub API 创建注释，其中包含里程碑式或任何其他问题的问候。</p>
</div>
<div class="paragraph">
<p>![img](<a href="https://jj.github.io/raku-advent-calendar-article-2019/img/issue-action.png" class="bare">https://jj.github.io/raku-advent-calendar-article-2019/img/issue-action.png</a>)</p>
</div>
<div class="paragraph">
<p>如上图所示，有几条注释：一个是创建时的注释，另一个是检查该图像。</p>
</div>
<div class="paragraph">
<p>但是，上次我们检查的是 Raku 降临日历，对吗？ 我们要我们的 Raku！</p>
</div>
</div>
<div class="sect2">
<h3 id="_在_github_actions_中使用_raku">57.2. 在 GitHub actions 中使用 Raku</h3>
<div class="paragraph">
<p>上次我检查时，Raku 并不是在任何环境中都可用的非常有限的语言之一。 但是，这并不意味着我们不能使用它。 在 Windows 中使用 Chocolatey 的情况下（或通过 curl 或任何其他命令下载），可以使用可以安装的任何东西升级操作。 我们还将使用它来进行真实的测试。 虚拟，但真实。 所有动作实际上要么成功要么失败。 您可以将其用于进行测试。 看看这个动作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">name: &#34;We 🎔 Raku&#34;
on: [push, pull_request]

jobs:
  test:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2-beta
      - name: Install and update
        run: |
          cinst rakudostar
          $env:Path = &#34;C:\rakudo\bin;C:\rakudo\share\perl6\site\bin;$env:Path&#34;
          refreshenv
          zef test .</code></pre>
</div>
</div>
<div class="paragraph">
<p>正在使用此脚本进行测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Test;

constant $greeting = &#34;Merry Xmas!&#34;;
constant $non-greeting = &#34;Hey!&#34;;
is( greet( &#34;Hey&#34;, $greeting, $non-greeting), $non-greeting, &#34;Non-seasonal salutation OK&#34;);
is( greet( &#34;Merry Xmas!&#34;, $greeting, $non-greeting), $greeting, &#34;Seasonal salutation OK&#34;);
done-testing;

sub greet( $body, $greeting, $non-greeting ) {
    ($body ~~ /M|m &#34;erry&#34;/)??$greeting!!$non-greeting;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的 <a href="https://docs.raku.org/type/Regex">regex</a> 使用 Raku 语法来执行与上一个 Perl 脚本大致相同的操作，但让我们集中于上面的操作。 它运行三个 PowerShell 命令，其中一个使用 Chocolatey 安装 <a href="https://rakudo.org/files/star">Rakudo Star</a>，然后设置命令路径并刷新它，以便可以在最后一个命令, 即通常的 <code>zef test .</code> 中使用它。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Rakudo Star 自 3 月以来未更新； 新的更新即将推出，但同时，Windows/GitHub Actions/Rakudo 的组合并不是真正的最佳选择，因为捆绑的 zef 版本已损坏，无法在 GitHub action 中进行更新。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>这个 <a href="https://github.com/JJ/raku-advent-calendar-article-2019/commit/828099c1a661dfe6ddab83592ad992d2f4facd0b/checks?check_suite_id=343254130">测试</a>需要相当长的时间。 您必须每次都下载并安装 Raku，如果您需要安装任何其他模块，它就无法工作。 幸运的是，还有更多的方法可以做到这一点。 认识 Raku 容器。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_dockerized_动作">57.3. 使用 dockerized 动作</h3>
<div class="paragraph">
<p>GitHub 动作可以在两个不同的环境中创建。 其中一个叫做 node12，实际上可以运行任何操作系统，另一个是 docker，这是 Linux 专有的。</p>
</div>
<div class="paragraph">
<p>这些容器将在运行时构建，然后执行，命令直接在容器内部执行。 默认情况下，将像往常一样运行容器的 ENTRYPOINT。 以前，我们使用动作/签出来签出存储库； 这些官方行动可以辅以我们自己的行动； 在这种情况下，我们将使用 <a href="https://github.com/JJ/raku-container-action">Raku 容器操作</a>，您也可以在 <a href="https://github.com/marketplace/actions/raku-container-action">Actions markecplace</a> 中检出该操作。</p>
</div>
<div class="paragraph">
<p>这个动作基本上包含一个 Dockerfile，这个是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">FROM jjmerelo/alpine-perl6:latest
LABEL version=&#34;4.0.2&#34; maintainer=&#34;JJ Merelo &lt;jjmerelo@GMail.com&gt;&#34;

# Set up dirs

ENV PATH=&#34;/root/.rakudobrew/versions/moar-2019.11/install/bin:/root/.rakudobrew/versions/moar-2019.11/install/share/perl6/site/bin:/root/.rakudobrew/bin:${PATH}&#34;
RUN mkdir /test
VOLUME /test
WORKDIR /test


# Will run this
ENTRYPOINT raku -v &amp;&amp; zef install --deps-only . &amp;&amp; zef test .</code></pre>
</div>
</div>
<div class="paragraph">
<p>该 Dockerfile 所做的只是建立系统 PATH 和可用于测试的入口点。 它没有任何特定于操作的内容。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>它使用最基本的 <a href="https://hub.docker.com/r/jjmerelo/alpine-perl6/">Alpine Raku</a> 容器，这是整个 Raku 测试容器系列的基础。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>但是，让我们回到动作所在的位置，即动作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">name: &#34;We 🎔 Ubuntu, Docker and Raku&#34;
on: [push, pull_request]

jobs:
  adventest:
    runs-on: ubuntu-latest
    name: AdvenTest
    steps:
    - name: Checkout
      uses: actions/checkout@v1
    - name: Runs tests
      uses: JJ/raku-container-action@master</code></pre>
</div>
</div>
<div class="paragraph">
<p>甜美而简单，对吗？</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>是的，我忍不住打电话给 Advent Calendar AdvenTest 测试。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>它使用正式的检出操作检出存储库，然后运行测试，这是在该操作中创建的 Dockerfile 中的默认命令。 如果有，还将安装生态系统依赖性。</p>
</div>
<div class="paragraph">
<p>这需要多长时间？ 短短 30 秒，或其他人的四分之一。</p>
</div>
</div>
<div class="sect2">
<h3 id="_告诉我更多">57.4. 告诉我更多！</h3>
<div class="paragraph">
<p>GitHub 上的行动充满了可能性（有时也是痛苦的世界）。 容器化工具意味着您将能够使用自己喜欢的语言（即 Raku ）在存储库和整个世界上工作，可以从任何类型的事件（交互性或定期性）中启动操作； 例如，您可以每周安排测试，或者在清除测试后开始部署。</p>
</div>
<div class="paragraph">
<p>如果您喜欢 Travis 或 CircleCI 等 CI 工具，那么您会喜欢 GitHub 上的动作。 在您的 Raku 存储库中充分利用它们。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第七天_使用_raku_解析_firefox_的_user_js第一部分">58. 第七天 - 使用 Raku 解析 Firefox 的 user.js(第一部分)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>正确配置 <a href="https://en.wikipedia.org/wiki/Firefox">Firefox</a> 并进行配置的最简单方法之一, 可通过 Firefox 配置文件中的 <a href="http://kb.mozillazine.org/User.js_file">user.js</a> 文件在设备之间进行同步，而无需第三方服务。 这是一个简单的 JavaScript 文件，通常包含 user_pref 函数调用的列表。 今天，我将向您展示如何使用 Raku 编程语言的 <a href="https://docs.raku.org/language/grammars">Grammars</a> 来解析 user.js 文件的内容。 明天，我将在此处创建的基础上进行扩展，以允许人们以编程方式与 user.js 文件进行交互。</p>
</div>
<div class="sect2">
<h3 id="_格式">58.1. 格式</h3>
<div class="paragraph">
<p>首先让我们看一下文件的格式。 举例来说，让我们使用我自己的 <a href="https://gitlab.com/tyil/dotfiles/raw/master/.local/etc/firefox/user.js">user.js</a> 中的启动页面配置设置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">user_pref(&#34;browser.startup.homepage&#34;, &#34;https://searx.tyil.nl&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>来看一下，我们可以将一行解构为以下元素：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>函数名称：在我们的例子中，几乎总是字符串 user_pref；</p>
</li>
<li>
<p>开口括号；</p>
</li>
<li>
<p>参数列表，以 ; 分隔。</p>
</li>
<li>
<p>闭合支架；</p>
</li>
<li>
<p>一个以 ; 结束语句。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们还可以看到字符串参数括在 &#34; 中。JavaScript 中不引用整数，布尔值和 null 值，因此我们也需要考虑这一点。但是现在让我们将其放在一边，首先获取示例 行解析。</p>
</div>
</div>
<div class="sect2">
<h3 id="_设置测试场">58.2. 设置测试场</h3>
<div class="paragraph">
<p>我发现开始编写语法的最简单方法之一就是编写一个小的 Raku 脚本，我可以执行该脚本以查看事情是否正常运行，然后逐步扩展语法。 起始情况如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar UserJS {
  rule TOP { .* }
}

sub MAIN () {
  my @inputs = (&#39;user_pref(&#34;browser.startup.homepage&#34;, &#34;https://searx.tyil.nl&#34;);&#39;);

  for @inputs {
    say UserJS.parse($_);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行此脚本应产生一个包含完整测试字符串的 Match 对象。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢user_pref(&#34;browser.startup.homepage&#34;, &#34;https://searx.tyil.nl&#34;);｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>｢和｣标记表示我们有一个 Match 对象，在这种情况下，它表示语法正确地解析了输入。 这是因为我们首先使用的占位符 .*。 我们的下一步将是在 .* 前面添加规则，直到该特定位不再匹配为止，并且我们已经为 user.js 文件的所有部分定义了明确的规则。</p>
</div>
</div>
<div class="sect2">
<h3 id="_添加第一条规则">58.3. 添加第一条规则</h3>
<div class="paragraph">
<p>由于该示例以静态字符串 user_pref 开头，因此我们首先将其与语法进行匹配。 由于这是函数的名称，因此我们将在语法中添加一个名为 function-name 的规则，该规则只需匹配静态字符串即可。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule function-name {
  &#39;user_pref&#39;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，此规则需要与 TOP 规则合并，因此将实际使用它。 规则对空格不敏感，因此您可以对 TOP 规则重新排序，以将我们要查找的所有元素依次放置。 从长远来看，这将使它更具可读性，因为随着我们的继续，将会涉及更多内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {

  .*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在运行脚本将产生比以前更多的输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢user_pref(&#34;browser.startup.homepage&#34;, &#34;https://searx.tyil.nl&#34;);｣
 function-name =&gt; ｢user_pref｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一行仍然相同，即完全匹配。 它仍然匹配所有内容，这很好。 如果不是，则匹配失败，并且返回 Nil。 这就是为什么我们将 .* 保留在末尾的原因。</p>
</div>
<div class="paragraph">
<p>不过这次有一条额外的线。 此行显示具有匹配项的函数名规则，且匹配项为 user_pref。 这符合我们的期望，因为我们告诉它匹配该字面值，确切的字符串。</p>
</div>
</div>
<div class="sect2">
<h3 id="_解析参数列表">58.4. 解析参数列表</h3>
<div class="paragraph">
<p>下一个要匹配的部分是参数列表，该列表包含一个左括号，一个用于匹配的右括号以及它们之间的许多参数。 让我们再制定一条规则来解析这部分。 现在可能有点天真，我们将在以后进行改进。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule argument-list {
  &#39;(&#39;
  .+
  &#39;)&#39;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，TOP 规则也需要扩展以包括此规则。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {


  .*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行脚本将产生另一行，表明参数列表规则与整个参数列表匹配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">｢user_pref(&#34;browser.startup.homepage&#34;, &#34;https://searx.tyil.nl&#34;);｣
 function-name =&gt; ｢user_pref｣
 argument-list =&gt; ｢(&#34;browser.startup.homepage&#34;, &#34;https://searx.tyil.nl&#34;)｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们知道此基本规则有效，我们可以尝试对其进行改进以使其更加准确。 如果我们可以从中得到一个参数列表，并且不包括方括号，将会更加方便。 卸下支架是比较容易的部分，所以我们首先来做。 您可以使用 <code>&lt;(</code> 和 <code>)&gt;</code> 标记来指示匹配结果应分别在何处开始和结束。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule argument-list {
  &#39;(&#39;

  &#39;)&#39;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以看到脚本的输出现在没有在参数列表匹配项中显示括号。 现在，要列出参数，最简单的方法是创建一个附加规则以匹配单个参数，然后将匹配作为参数的分隔符。 我们可以为此使用 % 运算符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule argument-list {
  &#39;(&#39;
  &lt;( + % &#39;,&#39; )&gt;
  &#39;)&#39;
}

rule argument {
  .+
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，当您尝试运行此命令时，只会看到 Nil 作为输出。</p>
</div>
</div>
<div class="sect2">
<h3 id="_调试_grammar">58.5. 调试 grammar</h3>
<div class="paragraph">
<p>没有任何工具的语法调试非常麻烦，因此我不建议您尝试这样做。 取而代之的是，我们使用一个使它变得更容易的模块：Grammar::Tracer。 这将显示有关语法如何匹配所有内容的信息。 如果您使用 Rakudo Star，那么您已经安装了此模块。 否则，您可能需要安装它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install Grammar::Tracer</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，您可以通过在脚本顶部在 grammar 声明之前添加 <code>use Grammar::Tracer</code> 在脚本中使用它。 现在运行脚本将产生一些内容，然后您会看到 Nil。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">TOP
| function-name
| * MATCH &#34;user_pref&#34;
| argument-list
| | argument
| | * MATCH &#34;\&#34;browser.startup.homepage\&#34;, \&#34;https://searx.tyil.nl\&#34;);&#34;
| * FAIL
* FAIL</code></pre>
</div>
</div>
<div class="paragraph">
<p>看到这个，您可以看到一个参数正在匹配，但是它太贪心了。 它匹配直到行尾的所有字符，因此参数列表不再匹配右括号。 要解决此问题，我们必须将参数规则更新为较少贪婪。 目前，我们只是匹配双引号中出现的字符串，因此让我们更改规则以使其更准确地匹配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule argument {
  &#39;&#34;&#39;
  &lt;( +? )&gt;
  &#39;&#34;&#39;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该规则匹配以 &#34; 开头的字符，然后是不是 &#34; 的任何字符，然后是另一个 &#34;。&#34; 还再次使用了 <code>&lt;(</code> 和 <code>)&gt;</code> 以使周围的字符 &#34; 不以结果结尾。 如果再次运行该脚本，您将看到参数列表包含两个参数匹配项。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">｢user_pref(&#34;browser.startup.homepage&#34;, &#34;https://searx.tyil.nl&#34;);｣
 function-name =&gt; ｢user_pref｣
 argument-list =&gt; ｢&#34;browser.startup.homepage&#34;, &#34;https://searx.tyil.nl&#34;｣
  argument =&gt; ｢browser.startup.homepage｣
  argument =&gt; ｢https://searx.tyil.nl｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于没有问题，我现在暂时忽略 Grammar::Tracer 的输出。 通常，我建议您一直呆在那里，直到您对自己的语法完全满意为止，这样您就可以立即查看开发过程中出了什么问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_语句的结尾">58.6. 语句的结尾</h3>
<div class="paragraph">
<p>现在，剩下的要在 TOP 规则中明确匹配的是语句终止符 <code>;</code>。 这可以替换 <code>.*</code>，因为它是字符串的最后一个字符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {


  &#39;;&#39;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最终的 grammar 应如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar UserJS {
  rule TOP {


    &#39;;&#39;
  }

  rule function-name {
    &#39;user_pref&#39;
  }

  rule argument-list {
    &#39;(&#39;
    &lt;(
    &#39;)&#39;
  }

  rule argument {
    &#39;&#34;&#39;
    &lt;(  )&gt;
    &#39;&#34;&#39;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，这里的问题是它还很幼稚。 它不会处理字符串中的双引号，也不会处理布尔值或整数。 当前的语法也无法匹配多行。 所有这些问题都可以解决，有些问题比其他问题容易。 明天回到这里学习方法！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第八天_使用_raku_解析_firefox_的_user_js第二部分">59. 第八天 - 使用 Raku 解析 Firefox 的 user.js(第二部分)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>昨天，我们做了一个简短的 Grammar，可以解析 Firefox 使用的 <strong>user.js</strong> 的一行。 今天，我们将添加一些测试用例，以确保我们要匹配的所有内容都能正确匹配。 另外，可以扩展 Grammar 以匹配多行，因此我们可以让 Grammar 在单次调用中解析整个 <strong>user.js</strong> 文件。</p>
</div>
<div class="sect2">
<h3 id="_添加更多测试">59.1. 添加更多测试</h3>
<div class="paragraph">
<p>要开始匹配其他参数类型，我们应该扩展 <strong>MAIN</strong> 中定义的测试用例。 让我们添加几个测试用例以匹配 true，false，null 和整数值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @inputs = (
  &#39;user_pref(&#34;browser.startup.homepage&#34;, &#34;https://searx.tyil.nl&#34;);&#39;,
  &#39;user_pref(&#34;extensions.screenshots.disabled&#34;, true);&#39;,
  &#39;user_pref(&#34;browser.search.suggest.enabled&#34;, false);&#39;,
  &#39;user_pref(&#34;i.have.no.nulls&#34;, null);&#39;,
  &#39;user_pref(&#34;browser.startup.page&#34;, 3);&#39;,
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我建议也更新 <strong>for</strong> 循环，以指示当前正在尝试匹配的输入。 假如不匹配，如果我们将其打印出来，将更容易看到哪个输出属于哪个输入。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @inputs {
  say &#34;\nTesting $_\n&#34;;
  say UserJS.parse($_);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您现在运行脚本，您会看到只有第一个测试用例实际上是工作的，而其他参数上的测试用例都失败了。 让我们修复每个测试，从顶部开始。</p>
</div>
</div>
<div class="sect2">
<h3 id="_匹配其他类型">59.2. 匹配其他类型</h3>
<div class="paragraph">
<p>为了使各种类型的匹配变得容易，让我们介绍一下 <a href="https://docs.raku.org/language/grammars#index-entry-:sym%3C%3E-_proto_regex-_declarator_grammar-Proto_regexes">原型正则表达式</a>。 这将有助于将所有内容分成较小的可管理块。 我们还要将 <strong>argument</strong> 规则重命名为 <strong>constant</strong>，这将更恰当地描述我们将要与之匹配的东西。 在添加新功能之前，让我们看一下重写后的结构。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule argument-list {
  &#39;(&#39;
  &lt;( &lt;constant&gt;+ % &#39;,&#39; )&gt;
  &#39;)&#39;
}

proto rule constant { * }

rule constant:sym {
  &#39;&#34;&#39;
  &lt;( &lt;-[&#34;]&gt;+? )&gt;
  &#39;&#34;&#39;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，我给了常量名为字符串 <code>string</code> 的 sym 副词。 这使我们很容易看出它与常量字符串有关。 现在，我们还可以轻松添加其他常量类型，例如布尔值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule constant:sym {
  | &#39;true&#39;
  | &#39;false&#39;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将匹配裸词 <strong>true</strong> 和 <strong>false</strong>。 仅添加此内容并再次运行脚本将向您显示接下来的两个测试用例正在运行。 添加 <strong>null</strong> 类型同样简单。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule constant:sym {
  &#39;null&#39;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们需要通过第 5 个测试用例的就是解析数字。 在 JavaScript 中，一切都是浮点数，因此我们在 Grammar 上也要坚持这一点。 我们接受一个或多个数字，可以选择在其后接一个点和另一组数字。 当然，我们还应该在它们前面允许 <code>-</code> 或 <code>+</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule constant:sym {
  &lt;[+-]&gt;? \d+ [ &#34;.&#34; \d+ ]?
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_找出一些极端情况">59.3. 找出一些极端情况</h3>
<div class="paragraph">
<p>看来我们现在可以匹配所有重要的类型。 但是，有些允许的情况尚无法解决。 一个大的当然是一个包含 &#34; 的字符串。如果我们为此添加一个测试用例，则在运行脚本时我们会看到它失败。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @inputs = (
  ...
  &#39;user_pref(&#34;double.quotes&#34;, &#34;\&#34;my value\&#34;&#34;);&#39;,
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>要解决此问题，我们需要回到 <code>constant: sym</code>，并更改规则以考虑转义的双引号。 我们可以更改它以查找不直接跟 <code>\</code> 的任何字符，而不是寻找不是 &#34; 的任何字符，因为那样会使它转义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule constant:sym {
  &#39;&#34;&#39;
  &lt;( .*? &lt;!after &#39;\\&#39;&gt; )&gt;
  &#39;&#34;&#39;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_解析多行">59.4. 解析多行</h3>
<div class="paragraph">
<p>现在看来我们已经能够处理 Firefox 可能向我们抛出的所有不同 user_pref 值，是时候更新脚本以解析整个文件了。 让我们将当前输入的内容移至 user.js，并更新 <strong>MAIN</strong> 子例程以读取该文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN () {
  say UserJS.parse(&#39;user.js&#39;.IO.slurp);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在运行脚本将在 STDOUT 上打印一个 Nil 值，但是如果您仍然启用了 Grammar::Tracer，您还会注意到它没有任何抱怨。 全都是绿色！</p>
</div>
<div class="paragraph">
<p>这里的问题是，目前仅指示 TOP 规则解析单个 user_pref 行，但是我们的文件包含多个此类行。 UserJS Grammar 的 parse 方法期望与被告知要解析的整个字符串匹配，这将导致 Gramamr 最终失败。</p>
</div>
<div class="paragraph">
<p>因此，我们需要更改 TOP 规则以允许多行匹配。 最简单的方法是将当前内容包装到一个组中，并在其中添加一个量词。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
  [
    &lt;function-name&gt;
    &lt;argument-list&gt;
    &#39;;&#39;
  ]*
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，它匹配所有行，并再次正确提取 user_pref 语句的值。</p>
</div>
</div>
<div class="sect2">
<h3 id="_任何注释">59.5. 任何注释？</h3>
<div class="paragraph">
<p>还有另一个需要说明的极端情况：评论。 在 user.js 文件中允许使用这些文件，并且当在线查找此类文件以进行预设配置时，它们通常会大量使用它们。 在 JavaScript 中，注释以 <code>//</code> 开头，直到行尾。</p>
</div>
<div class="paragraph">
<p>我们将为此使用 token 而不是 rule，因为这不能为我们处理空格。 换行符是一个空白字符，对于注释表示其结束很重要。 此外，TOP 规则还需要进行一些小的改动才能接受注释行。 为了保持可读性，我们应该将匹配组的当前内容移到它自己的规则上。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule TOP {
  [
  | &lt;user-pref&gt;
  | &lt;comment&gt;
  ]*
}

token comment {
  &#39;//&#39;
  &lt;( &lt;-[\n]&gt;* )&gt;
  &#34;\n&#34;
}

rule user-pref {
  &lt;function-name&gt;
  &lt;argument-list&gt;
  &#39;;&#39;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，您还应该能够解析注释。 无论它们是单独运行还是在 user_pref 语句之后，都无关紧要。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使其成为一个对象">59.6. 使其成为一个对象</h3>
<div class="paragraph">
<p>如果您以后无法轻松使用它，解析数据有什么用。 因此，让我们利用语法操作将 Match 对象转换为 UserPref 对象列表。 首先，让我们声明类的外观。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class UserPref {
  has $.key;
  has $.value;

  submethod Str () {
    my $value;

    given ($!value) {
      when Str  { $value = &#34;\&#34;$!value\&#34;&#34; }
      when Num  { $value = $!value }
      when Bool { $value = $!value ?? &#39;true&#39; !! &#39;false&#39; }
      when Any  { $value = &#39;null&#39; }
    }

    sprintf(&#39;user_pref(&#34;%s&#34;, %s);&#39;, $!key, $value);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个简单的类，包含一个键和一个值，以及一些将其转换为在 user.js 文件中可用的字符串的逻辑。 接下来，创建一个 Action 类来制作这些对象。 动作类就像任何常规类一样。 您需要注意的是将方法命名为与语法中使用的规则相同的名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class UserJSActions {
  method TOP ($/) {
    make $/.map({
      UserPref.new(
        key =&gt; $_[0].made,
        value =&gt; $_[1].made,
      )
    })
  }

  method constant:sym ($/) {
    make (~$/ eq &#39;true&#39; ?? True !! False)
  }

  method constant:sym ($/) {
    make +$/
  }

  method constant:sym ($/) {
    make Any
  }

  method constant:sym ($/) {
    make ~$/
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>值方法将在 user.js 中看到的值转换为 Raku 类型。 TOP 方法映射所有已解析的 user_pref 语句，并将每个语句转换为 UserPref 对象。 现在剩下的就是将 UserJSActions 类添加为 MAIN 中的解析调用的 Action 类，并使用其值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN () {
  my $match = UserJS.parse(&#39;user.js&#39;.IO.slurp, :actions(UserJSActions));

  say $match.made;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们也可以使用它来做事。 例如，我们可以按字母顺序对所有 user_pref 语句进行排序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN () {
  my $match = UserJS.parse(&#39;user.js&#39;.IO.slurp, :actions(UserJSActions));
  my @prefs = $match.made;

  for @prefs.sort(*.key) {
    .Str.say
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>按字母排序可能有点无聊，但是现在您有各种各样的可能性，例如过滤掉某些选项或注释，或者合并来自多个来源的多个文件。</p>
</div>
<div class="paragraph">
<p>我希望这是使用 Raku 极其强大的语法来解析整个其他编程语言的有趣旅程！</p>
</div>
</div>
<div class="sect2">
<h3 id="_完整代码">59.7. 完整代码</h3>
<div class="paragraph">
<p><strong>parser.pl6</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class UserPref {
  has $.key;
  has $.value;

  submethod Str () {
    my $value;

    given ($!value) {
      when Str  { $value = &#34;\&#34;$!value\&#34;&#34; }
      when Num  { $value = $!value }
      when Bool { $value = $!value ?? &#39;true&#39; !! &#39;false&#39; }
      when Any  { $value = &#39;null&#39; }
    }

    sprintf(&#39;user_pref(&#34;%s&#34;, %s);&#39;, $!key, $value);
  }
}

class UserJSActions {
  method TOP ($/) {
    make $/.map({
      UserPref.new(
        key =&gt; $_[0].made,
        value =&gt; $_[1].made,
      )
    })
  }

  method constant:sym ($/) {
    make (~$/ eq &#39;true&#39; ?? True !! False)
  }

  method constant:sym ($/) {
    make +$/
  }

  method constant:sym ($/) {
    make Any
  }

  method constant:sym ($/) {
    make ~$/
  }
}

grammar UserJS {
  rule TOP {
    [
    | &lt;user-prefix&gt;
    | &lt;comment&gt;
    ]*
  }

  token comment {
    &#39;//&#39; &lt;( &lt;-[\n]&gt;* )&gt; &#34;\n&#34;
  }

  rule user-pref {
    &lt;function-name&gt;
    &lt;argument-list&gt;
    &#39;;&#39;
  }

  rule function-name {
    &#39;user_pref&#39;
  }

  rule argument-list {
    &#39;(&#39;
    &lt;( &lt;constant&gt;+ % &#39;,&#39; )&gt;
    &#39;)&#39;
  }

  proto rule constant { * }

  rule constant:sym {
    &#39;&#34;&#39;
    &lt;( .*? &lt;!after &#39;\\&#39;&gt; )&gt;
    &#39;&#34;&#39;
  }

  rule constant:sym {
    | &#39;true&#39;
    | &#39;false&#39;
  }

  rule constant:sym {
    &#39;null&#39;
  }

  rule constant:sym {
    &lt;[+-]&gt;? \d+ [ &#34;.&#34; \d+ ]?
  }
}

sub MAIN () {
  my $match = UserJS.parse(&#39;user.js&#39;.IO.slurp, :actions(UserJSActions));
  my @prefs = $match.made;

  for @prefs.sort(*.key) {
    .Str.say
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>user.js</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">// Comments are welcome!

user_pref(&#34;browser.startup.homepage&#34;, &#34;https://searx.tyil.nl&#34;);
user_pref(&#34;extensions.screenshots.disabled&#34;, true); //uwu
user_pref(&#34;browser.search.suggest.enabled&#34;, false);
user_pref(&#34;i.have.no.nulls&#34;, null);
user_pref(&#34;browser.startup.page&#34;, +3);
user_pref(&#34;double.quotes&#34;, &#34;\&#34;my value\&#34;&#34;);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第九天_容器链">60. 第九天 - 容器链</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rakuadventcalendar.wordpress.com/2019/12/09/day-9-a-chain-or-russian-doll-of-containers/" class="bare">https://rakuadventcalendar.wordpress.com/2019/12/09/day-9-a-chain-or-russian-doll-of-containers/</a></p>
</div>
<div class="paragraph">
<p>如果您从事的是企业，那么现在您可能已经听说过容器。它们既可以描述为类固醇上的可执行文件，也可以被描述为类固醇上的可执行文件，是将应用程序运送到任何地方的一种好方法，或者可以将其存储起来并随时随地使用。这些有点可执行文件称为映像，您可以在许多称为注册表的地方找到它们，从 Docker Hub 开始，最近由 GitHub Container Registry 和 Quay.io 或 RedHat 容器目录等其他地方加入。最后的这些即将到来，您必须将它们添加到默认配置中。无论如何，大多数容器都已在 Docker Hub 中注册。</p>
</div>
<div class="paragraph">
<p>而且，由于它们是某种可执行文件，因此它们是体系结构和操作系统特定的。 Docker Hub 标志着其架构和操作系统，其中 Linux 是最常见的。但是，只要 Docker 守护程序在 Linux 虚拟机中运行，您就可以在任何地方运行 Linux 映像。这也是 Mac 中的默认配置。</p>
</div>
<div class="paragraph">
<p>当然，有很多容器可以与 Raku 一起使用，即使我们还没有真正可以称之为官方的容器。我将用我 <a href="https://hub.docker.com/u/jjmerelo">自己的</a>，因为我对它们更加熟悉。但是，例如，有（Tilil）每晚提供的这些 <a href="https://hub.docker.com/r/tyil/perl6">镜像</a> ，或有点官方的 <a href="https://hub.docker.com/_/rakudo-star">Rakudo Star 镜像</a>，这些图片自从去年 3 月更新 Rakudo Star 以来就没有更新过。</p>
</div>
<div class="paragraph">
<p>![img](<a href="https://rakuadventcalendar.files.wordpress.com/2019/12/alpes-desde-el-avic3b3n.jpg?w=2048" class="bare">https://rakuadventcalendar.files.wordpress.com/2019/12/alpes-desde-el-avic3b3n.jpg?w=2048</a>)</p>
</div>
<div class="paragraph">
<p>让我们从基本图片开始，沙皇尼基小俄罗斯小娃娃。 由于它要放在里面，因此我们需要使其变得很小。 这是 <a href="https://hub.docker.com/r/jjmerelo/alpine-perl6/">jjmerelo/alpine-perl6</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">FROM alpine:latest
LABEL version=&#34;2.2&#34; maintainer=&#34;JJMerelo@GMail.com&#34; perl6version=&#34;2019.11&#34;

# Environment
ENV PATH=&#34;/root/.rakudobrew/versions/moar-2019.11/install/bin:/root/.rakudobrew/versions/moar-2019.11/install/share/perl6/site/bin:/root/.rakudobrew/bin:${PATH}&#34; \
    PKGS=&#34;curl git perl&#34; \
    PKGS_TMP=&#34;curl-dev linux-headers make gcc musl-dev wget&#34; \
    ENV=&#34;/root/.profile&#34; \
    VER=&#34;2019.11&#34;

# Basic setup, programs and init
RUN mkdir /home/raku \
    apk update &amp;&amp; apk upgrade \
    &amp;&amp; apk add --no-cache $PKGS $PKGS_TMP \
    &amp;&amp; git clone https://github.com/tadzik/rakudobrew ~/.rakudobrew \
    &amp;&amp; echo &#39;eval &#34;$(~/.rakudobrew/bin/rakudobrew init Sh)&#34;&#39; &gt;&gt; ~/.profile \
    &amp;&amp; eval &#34;$(~/.rakudobrew/bin/rakudobrew init Sh)&#34;\
    &amp;&amp; rakudobrew build moar $VER \
    &amp;&amp; rakudobrew global moar-$VER \
    &amp;&amp; rakudobrew build-zef\
    &amp;&amp; zef install Linenoise App::Prove6\
    &amp;&amp; apk del $PKGS_TMP \
    &amp;&amp; RAKUDO_VERSION=`sed &#34;s/\n//&#34; /root/.rakudobrew/CURRENT` \
       rm -rf /root/.rakudobrew/${RAKUDO_VERSION}/src /root/zef \
       /root/.rakudobrew/git_reference

# Runtime
WORKDIR /home/raku
ENTRYPOINT [&#34;raku&#34;]</code></pre>
</div>
</div>
<div class="paragraph">
<p>该映像是在 Raku 2019.11 发布之后的上周创建的，这是第一个实际称为 Raku 的映像，也称为可执行文件 Raku。</p>
</div>
<div class="paragraph">
<p>您首先看到的是 FROM，它声明了该容器内的小容器。我们使用的是 Alpine Linux，这是在容器技术人员社区之外鲜为人知的发行版，它使用了一些技巧来避免膨胀文件的数量以及容器的大小。该映像总共将少于 300 MB，而与 Debian 或 Ubuntu 等效的映像将是原来的两倍。这意味着下载所需的时间减少了一半，这正是我们所需要的。</p>
</div>
<div class="paragraph">
<p>因为也有这样的东西：现实的容器，空的时候，可以用俄制的美元放入另一个容器中，这样就不会占用太多空间。容器也会发生类似的情况。它们的构建使各层相互重叠，内层通常是一个操作系统。让我们看看其余的。</p>
</div>
<div class="paragraph">
<p>接下来的标签只是可以通过检查从图像中提取的标签或元数据。没那么重要。</p>
</div>
<div class="paragraph">
<p>但是，在所有第一个中，ENV 块有点，它定义了将在整个俄罗斯娃娃积木中使用的 PATH。其余变量主要在构建图像时使用。它们还将有助于使其具有某种通用性，以便我们可以更改变量的值并获得新版本；我们将其放入 VER。</p>
</div>
<div class="paragraph">
<p>到目前为止，尚未进行任何构建，但是在这个庞大的 RUN 语句中，我们下载了 rakudobrew，将其用于构建 VER 中包含的版本，将该版本设置为默认版本，安装 zef 和我们将要使用的几个模块需要，然后删除其余外部玩偶中不再需要的东西，以使整个东西变小。</p>
</div>
<div class="paragraph">
<p>最后，在设置工作目录之后，我们定义一个入口点，它是真正的可执行文件内部可执行文件。可以使用该容器代替该命令，以便可以使用此可执行文件来完成 raku 可以执行的任何操作。例如，让我们运行以下程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @arr;
my ($a, $b) = (1,1);
for ^5 {
    ($a,$b) = ($b, $a+$b);
    @arr.push: ($a.item, $b.item);
    say @arr
};
say @arr;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将为容器化的 Raku 命名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">alias raku-do=&#39;docker run --rm -t -v `pwd`:/home/raku  jjmerelo/alpine-perl6&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用以下命令运行上面的程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku-do itemizer-with-container.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是您可以更进一步。 创建此 shell 脚本并将其放在路径中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/bin/bash

docker run --rm -t -v `pwd`:/home/raku  jjmerelo/alpine-perl6 $@</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，可以在 shebang 行中使用它：!/usr/bin/env raku-do.sh。 这将创建一个一次性图像，将临时创建该图像以运行脚本，然后将其丢弃（这是该行中的 <code>--rm</code>）。 当前目录（pwd）将作为 /home/raku 的别名，请记住，我们的工作目录，这意味着容器内的 raku 将在此处看到它。 你看？ 有了这个，你可以在安装了 docker 的任何地方运行 raku。 如今，到处都有。</p>
</div>
<div class="paragraph">
<p>但是，让我们以此为基础。 容器广泛用于测试，因为您无需构建和安装即可将所有内容放入单个容器中，然后立即下载并用于测试。 实际上，这就是让我成为一名集装箱运输商的原因，这需要花费 20 分钟的时间来酿造 rakudo，并对每个模块进行几秒钟的测试。 在该基本容器之后，我创建了一个 <a href="https://hub.docker.com/r/jjmerelo/test-perl6">jjmerelo/test-perl6</a>。 这里是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">FROM jjmerelo/alpine-perl6:latest
LABEL version=&#34;4.0.2&#34; maintainer=&#34;JJ Merelo &lt;jjmerelo@GMail.com&gt;&#34;

# Set up dirs
RUN mkdir /test
VOLUME /test
WORKDIR /test


# Will run this
ENTRYPOINT perl6 -v &amp;&amp; zef install --deps-only . &amp;&amp; zef test .</code></pre>
</div>
</div>
<div class="paragraph">
<p>实际上，这本身就是简单性：唯一更改的是入口点和工作目录。 它没有直接运行 raku 编译器，而是做了两件事：安装运行测试所需的依赖项，然后发出 zef test。 运行测试。</p>
</div>
<div class="paragraph">
<p>真正加快了测试速度。 通过以下方式将其放入您的.travis.yml 文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">language: minimal

services:
  - docker

install: docker pull jjmerelo/test-perl6

script: docker run -t -v  $TRAVIS_BUILD_DIR:/test jjmerelo/test-perl6</code></pre>
</div>
</div>
<div class="paragraph">
<p>而且您很高兴。 整个过程耗时一分半钟，如果您使用基于 rakudobrew 的官方 Travis 图像，则要花费 20 多分钟。</p>
</div>
<div class="paragraph">
<p>俄语玩偶并不止于此：<a href="https://hub.docker.com/r/jjmerelo/perl6-test-openssl/dockerfile">jjmerelo/perl6-test-openssl</a> 包括安装 OpenSSL 所需的其他 Alpine 软件包。 并且基于 <a href="https://hub.docker.com/r/jjmerelo/perl6-doccer/dockerfile">jjmerelo/perl6-doccer</a>，它包含了测试 <a href="https://docs.raku.org/">Raku 文档</a>所需的一切。</p>
</div>
<div class="paragraph">
<p>您应该亲自尝试一下。 如果您在测试模块时甚至只有几个其他模块要下载，那么只需从 test-perl6 映像中构建并获得自己的模块即可！ 您不仅可以节省时间，还可以节省计算时间，从而节省能源。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十天_急转弯">61. 第十天 - 急转弯</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rakuadventcalendar.wordpress.com/2019/12/10/day-10-a-teaser/" class="bare">https://rakuadventcalendar.wordpress.com/2019/12/10/day-10-a-teaser/</a></p>
</div>
<div class="paragraph">
<p>圣诞老人有一种特殊待遇：如果愿意的话，可以传情。即将于 2020 年 1 月出版的《将 Perl 迁移到 Raku》一书中一章的一部分。</p>
</div>
<div class="sect2">
<h3 id="_优化注意事项">61.1. 优化注意事项</h3>
<div class="paragraph">
<p>如果您是经验丰富的 Perl 程序员，那么您（可能无意中）学到了一些技巧，可以更快地执行 Perl 程序。其中一些习语在 Raku 中起反作用。本章将介绍其中的一些，并提供 Raku 中的其他惯用语。</p>
</div>
</div>
<div class="sect2">
<h3 id="_祝福的哈希_vs_对象">61.2. 祝福的哈希 Vs.对象</h3>
<div class="paragraph">
<p>Perl 中的对象通常由祝福的哈希组成。如我们之前所见，这意味着需要为它们创建访问器。这意味着更高级别的间接和开销。如此多的 Perl 程序员“知道”该对象基本上是一个哈希，并直接访问经过祝福的哈希中的键。</p>
</div>
<div class="paragraph">
<p>因此，许多 Perl 程序员决定完全放弃创建对象，而只使用哈希。如果您只是将散列用作键和关联值的存储库，那么从功能上来说还可以。但是在 Raku 中，从性能的角度来看，最好实际使用对象。以以下示例为例，该哈希使用两个键/值创建：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    # Raku
    for ^1000000 {    # do this a million times
        my %h = a =&gt; 42, b =&gt; 666;
    }
    say now - INIT now;  # 1.4727555</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，如果我们使用具有两个属性的对象，则速度快了四倍：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    # Raku
   class A {
       has $.a;
       has $.b;
   }
    for ^1000000 {
       my $obj = A.new(a =&gt; 42, b =&gt; 666);
    }
    say now - INIT now;  # 0.3511395</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，您可能会争辩说，访问散列中的键要比调用访问器来获取值更快？</p>
</div>
<div class="paragraph">
<p>不。 在 Raku 中使用存取器也更快。 比较这段代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    # Raku
   my %h = a =&gt; 42, b =&gt; 666;
    for ^10000000 {    # do this ten million times
       my $a = %h;
   }
   say now - INIT now;  # 0.4713363</code></pre>
</div>
</div>
<div class="paragraph">
<p>为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    # Raku
    class A {
        has $.a;
       has $.b;
   }
   my $obj = A.new(a =&gt; 42, b =&gt; 666);
    for ^10000000 {
        my $a = $obj.a;
    }
    say now - INIT now;  # 0.36870995</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，使用访问器也更快，尽管速度虽然不快，但仍然非常快。</p>
</div>
<div class="paragraph">
<p>那么，为什么在 Raku 中访问器方法更快？ 好吧，这真的是因为 Raku 能够优化对象在列表中的属性，并且很容易在内部用数字索引。 而对于哈希查找，必须先对字符串进行哈希处理，然后才能对其进行查找。 这不仅需要按索引查找，还需要做更多的工作。</p>
</div>
<div class="paragraph">
<p>当然，与所有基准测试一样，这只是时间的快照。 Raku 将继续进行优化工作，这可能会在将来改变这些测试的结果。 因此，如果您想确保某些优化是一种有效的方法，请务必进行自我测试，但前提是您确实真正有兴趣从 Raku 代码中压缩性能。 记住，过早的优化是万恶之源！</p>
</div>
<div class="paragraph">
<p>圣诞老人希望您喜欢它。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十一天_使用_libarchive_打包">62. 第十一天 - 使用 libarchive 打包</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rakuadventcalendar.wordpress.com/2019/12/11/day-11-packaging-with-libarchive/" class="bare">https://rakuadventcalendar.wordpress.com/2019/12/11/day-11-packaging-with-libarchive/</a></p>
</div>
<div class="paragraph">
<p>分发实物礼物需要将它们包装成包装，但是假设您要分发数字礼物。 您如何使用 Raku 来帮助您打包？ 输入 Libarchive！</p>
</div>
<div class="sect2">
<h3 id="_将文件简单包装到包中">62.1. 将文件简单包装到包中</h3>
<div class="paragraph">
<p>让我们仅将两个文件 myfile1 和 myfile2 打包到一个 package.zip 文件中。 （Libarchive 就像为 cds 或 dvds 轻松创建 tar 文件，cpio，rar 甚至 iso9660 映像一样。）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Libarchive::Simple;

given archive-write(&#39;package.zip&#39;) {
    .add: &#39;myfile1&#39;, &#39;myfile2&#39;;
    .close;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于那些不熟悉的人来说，这种非常简单的语法有点奇怪……这是写同一件事的一种更“传统”的方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Libarchive::Write;

my $handle = Libarchive::Write.new(&#39;package.zip&#39;);
$handle.add(&#39;myfile1&#39;, &#39;myfile2&#39;);
$handle.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有什么区别？ Libarchive::Simple 提供了一些速记例程，用于访问各种 Libarchive 功能。 其中之一是 archive-write()，与 Libarchive::Write.new() 相同。</p>
</div>
<div class="paragraph">
<p>第二个示例从 new() 获取返回值，并将其存储在变量 <code>$handle</code> 中。 然后，我们对该变量调用两个方法以添加文件并关闭文件。</p>
</div>
<div class="paragraph">
<p>给定的语句通过对该变量进行主题化（即将其存储在主题变量 $_ 中），使此操作变得更加简单。 由于 $_ 可以用作方法调用的默认对象，因此在调用方法时我们不需要显式引用它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.add(&#39;myfile1&#39;) is equivalent to $_.add(&#39;myfile1&#39;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是括号发生了什么？ 调用方法时的另一个小写法-您可以在冒号前面加上冒号，而不必在括号中加上参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.add: &#39;myfile1&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>真好！ 我喜欢用 Raku 编程！</p>
</div>
</div>
<div class="sect2">
<h3 id="_通过智能匹配打包一堆文件">62.2. 通过智能匹配打包一堆文件</h3>
<div class="paragraph">
<p>dir() 是帮助包装的便捷例程。 它将返回目录的 IO::Path 对象的惰性列表。 碰巧的是，Libarchive add 可以像输入文件名一样轻松地使用 IO::Path。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given archive-write(&#39;package.zip&#39;) {
    .add: &#39;mydir&#39;, dir(&#39;mydir&#39;);
    .close;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，我们首先添加了目录本身，然后使用 dir() 获取 mydir 中的文件列表，该列表也被添加。 如果您不包括目录本身，则该目录将不包含在软件包中。 根据您的格式和解压缩程序，大多数情况下该方法都可以正常工作，但是最好包含该目录以确保按照您希望的方式创建该目录。</p>
</div>
<div class="paragraph">
<p>dir 有一个额外的功能-它可以通过将字符串与：test 参数智能匹配来过滤目录。 让我们只包含 jpeg 文件，使它们以 <code>.jpg</code> 或 <code>.jpeg</code> 结尾：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given archive-write(&#39;package.zip&#39;) {
    .add: &#39;mydir&#39;, dir(&#39;mydir&#39;, test =&gt; /:i &#39;.&#39; jpe?g $/);
    .close;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>诸如 File::Find 或 Concurrent::File::Find 之类的生态系统模块可以通过将整个层次结构递归添加到包中来轻松生成甚至更复杂的文件列表。</p>
</div>
</div>
<div class="sect2">
<h3 id="_打包时即时创建文件">62.3. 打包时即时创建文件</h3>
<div class="paragraph">
<p>您不仅限于添加现有文件。 您可以使用 write() 方法动态地为软件包生成文件。 您可以将内容指定为 Str，Blob 或 IO::Handle 或 IO::Path 来获取内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given archive-write(&#39;package.zip&#39;) {
    .write: &#39;myfile&#39;, q:to/EOF/;
        Myfile
        ------
        A special file for a special friend!
        EOF
    .close;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们使用了一种特殊的 Raku 报价结构，称为 heredoc。</p>
</div>
<div class="paragraph">
<p><code>q:to/EOF/</code> 表示使用后续的行直到 EOF 标记，并将它们放入包文件中包含的名为 &#34;myfile&#34; 的文件的内容中。 作为一个友好的好处，终止符的缩进量会自动从每行删除到引用的行。 多么方便！</p>
</div>
</div>
<div class="sect2">
<h3 id="_流式打包而不是制作文件">62.4. 流式打包而不是制作文件</h3>
<div class="paragraph">
<p>使用软件包制作文件非常好，但是我有一个网站希望从中返回我的自定义 CD 映像-为什么要使用临时文件呢？ 只需实时输出流！</p>
</div>
<div class="paragraph">
<p>在此示例中，我们将打包文件作为 iso9660 文件（用于 CD 刻录机的映像）流式传输到 STDOUT，但是您也可以流式传输到其他程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given archive-write($*OUT, format =&gt; &#39;iso9660&#39;) {
    .add: &#39;myfile1&#39;, &#39;myfile2&#39;, &#39;mydir&#39;, dir(&#39;mydir&#39;);
    .close;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常，可以从后缀上根据指定的文件名推断格式，但是由于我们正在流传输，因此没有文件名，因此必须指定格式。<code>$*OUT</code> 是一个特殊的文件句柄，将自动为您打开以写入 STDOUT。</p>
</div>
<div class="paragraph">
<p>将该图像刻录到 CD 上并进行安装，您将看到指定的文件。 太简单！</p>
</div>
<div class="paragraph">
<p>Libarchive 具有许多很酷的功能，需要花几天的时间才能浏览完所有功能，但是我希望这个小介绍能引起您打包东西的胃口。 Raku 具有出色的语法，功能和表达能力，可轻松与此类库进行交互。</p>
</div>
<div class="paragraph">
<p>打包自己的东西，无论是物理的还是数字的，都可以玩得开心！</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十二天_在_raku_中制作一个简单的机器人">63. 第十二天 - 在 Raku 中制作一个简单的机器人</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rakuadventcalendar.wordpress.com/2019/12/12/making-a-simple-bot-in-raku/">bot</a></p>
</div>
<div class="paragraph">
<p>在 Raku 中制作 IRC 机器人是非常简单的，这要感谢 <a href="https://modules.raku.org/dist/IRC::Client:github:Zoffix%20Znet">IRC::Client</a>。它允许你在 20 行代码中创建一个非常简单的机器人。有一个插件系统，允许在多个机器人之间轻松地重用代码，添加自定义功能可以像在匿名类中添加一样简单。</p>
</div>
<div class="paragraph">
<p>那么，让我们开始吧!</p>
</div>
<div class="sect2">
<h3 id="_安装你的依赖关系">63.1. 安装你的依赖关系</h3>
<div class="paragraph">
<p>Raku 使用 <a href="https://modules.raku.org/dist/zef:github:Nick%20Logan">zef</a> 作为标准的模块安装程序，如果你正在阅读这篇文章，我假设你已经有了它。用 zef 安装 IRC::Client，你就可以开始使用了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">zef install IRC::Client</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_设置机器人">63.2. 设置机器人</h3>
<div class="paragraph">
<p>要设置机器人，我们需要有一个要使用的昵称，一个要连接的服务器和一个要加入的频道列表。为了使它更容易运行, 下面是一个可以从你的 shell 运行的程序，我将使用一个 <strong>MAIN</strong> 子例程。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use IRC::Client;

sub MAIN () {
  IRC::Client.new(
    nick =&gt; &#39;raku-advent&#39;,
    host =&gt; &#39;irc.darenet.org&#39;,
    channels =&gt; &lt; #advent &gt;,
  ).run;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们把这个文件保存在一个叫 bot.raku 的文件中，然后运行它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku bot.raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将运行，如果你在 <strong>channels</strong> 中指定的频道中，你应该在很短的时间内看到机器人加入。然而，程序本身似乎并没有提供任何输出。如果能显示出它在做什么，将会非常方便，尤其是在开发过程中。这可以通过启用调试模式来实现。在 <strong>new</strong> 方法调用中加入这个功能，使其看起来如下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">IRC::Client.new(
  nick =&gt; &#39;raku-advent&#39;,
  host =&gt; &#39;irc.darenet.org&#39;,
  channels =&gt; &lt; #advent &gt;,
  debug =&gt; True,
).run;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你现在重新启动应用程序，你会看到突然有很多输出，展示了机器人正在接收和发送响应的 IRC 命令。现在我们需要做的就是添加一些功能。</p>
</div>
</div>
<div class="sect2">
<h3 id="_让机器人工作">63.3. 让机器人工作</h3>
<div class="paragraph">
<p>如前所述，机器人的功能是使用插件添加进来的。这些可以是任何实现正确方法名的类。现在，我们将坚持使用 irc-to-me，这是一个方便的方法，只要在私人消息中对机器人说话，或者在频道中直接对机器人说话，就会触发这个方法。</p>
</div>
<div class="paragraph">
<p>这里最简单的例子就是简单地让它回复你发给机器人的消息。我们通过在新方法调用中添加一个匿名类作为插件来实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">IRC::Client.new(
  nick =&gt; &#39;raku-advent&#39;,
  host =&gt; &#39;irc.darenet.org&#39;,
  channels =&gt; &lt; #advent &gt;,
  debug =&gt; True,
  plugins =&gt; [
    class {
      multi method irc-to-me ($e) {
        $e.text
      }
    }
  ],
).run;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你重启机器人，并在 IRC 上与它对话时，你会看到它用你发给它的相同的信息来回应你。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt"> &lt;@tyil&gt; raku-advent: hi
 &lt;raku-advent&gt; tyil, hi
 &lt;@tyil:&gt; raku-advent: how are you doing
 &lt;raku-advent&gt; tyil, how are you doing</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_增加一些真正的功能">63.4. 增加一些真正的功能</h3>
<div class="paragraph">
<p>所以，你已经看到了一个简单的 IRC 机器人是多么容易上手，只需十几行。让我们添加两个你可能希望你的机器人支持的功能。</p>
</div>
<div class="paragraph">
<p>为了方便起见，我将只涵盖实现这些功能的类，而不是整个 <code>IRC::Client.new</code> 块。</p>
</div>
<div class="sect3">
<h4 id="_正常运行时间">63.4.1. 正常运行时间</h4>
<div class="paragraph">
<p>首先，让我们让机器人能够显示其运行的时间。为此，我会让它响应人们向它询问&#34;正常运行时间&#34;。我们又可以使用 <code>irc-to-me</code> 的方便方法来实现。毕竟，我们可能不希望它在每次有人讨论正常运行时间时都做出回应，只有当机器人被直接问到这个问题时才会做出回应。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，有一个特殊的变量叫 <code>$*INIT-INSTANT</code>，其中包含了程序启动瞬间的 Instant。我们可以用它来轻松获得程序运行的持续时间。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class {
  multi method irc-to-me ($ where *.text eq &#39;uptime&#39;) {
    my $response = &#34;I&#39;ve been alive for&#34;;
    my ($seconds, $minutes, $hours, $days, $weeks) =
      (now - $*INIT-INSTANT).polymod(60, 60, 24, 7);

    $response ~= &#34; $weeks weeks&#34; if $weeks;
    $response ~= &#34; $days days&#34; if $days;
    $response ~= &#34; $hours hours&#34; if $hours;
    $response ~= &#34; $minutes minutes&#34; if $minutes;
    $response ~= &#34; $seconds seconds&#34; if $seconds;

    $response ~ &#39;.&#39;;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，每当你向机器人询问正常运行时间时，它都会以人类友好的正常运行时间通知做出回应。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt"> &lt;@tyil&gt; uptime
 &lt;@tyil&gt; raku-advent: uptime
 &lt;raku-advent&gt; tyil, I&#39;ve been alive for 5 minutes 8 seconds.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_用户积分">63.4.2. 用户积分</h4>
<div class="paragraph">
<p>大多数频道都有一个机器人来跟踪用户的积分，或者说是业力，有时也被称为业力。已经有一个模块为我们做了这个工作，叫做 <code>IRC::Client::Plugin::UserPoints</code>。除了安装它并将其添加到插件列表中，我们不需要做太多事情。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install IRC::Client::Plugin::UserPoints</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦这一切完成，这个模块就可以在你的代码中使用了，你需要用 <code>use</code> 语句导入它，你可以直接把它放在 <code>use IRC::Client</code> 行下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use IRC::Client;
use IRC::Client::Plugin::UserPoints;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，在插件列表中，将其添加为一个新条目。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">plugins =&gt; [
  IRC::Client::Plugin::UserPoints.new,
  class {
    ...
  },
],</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个插件可以让机器人对 <code>!scores</code>, <code>!sum</code> 以及每当一个昵称使用 <code>` 后缀获得分数时做出响应，例如，`tyil</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt"> &lt;@tyil&gt; raku++
 &lt;@tyil&gt; raku++
 &lt;@tyil&gt; !scores
 &lt;raku-advent&gt; tyil, « raku » points: main: 2</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_寻找插件">63.5. 寻找插件</h3>
<div class="paragraph">
<p>所有在社区上分享的 IRC::Client 的插件都有 <code>IRC::Client::Plugin::</code> 的前缀，所以你可以在 <a href="https://modules.raku.org/search/?q=IRC%3A%3AClient%3A%3APlugin">modules.raku.org</a> 上搜索，找到要使用的插件。当然，你也可以轻松地将自己的插件添加到生态系统中去!</p>
</div>
</div>
<div class="sect2">
<h3 id="_收尾">63.6. 收尾</h3>
<div class="paragraph">
<p>正如你所看到的，通过一些非常简单的代码，你可以使用 Raku 编程语言为你的 IRC 社区添加一些有趣或重要的工具。试试吧，享受一下乐趣，并与他人分享你的想法。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十三天_一点_rust_和_raku">64. 第十三天 - 一点 Rust 和 Raku</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rakuadventcalendar.wordpress.com/2019/12/13/day-4-a-little-rr/" class="bare">https://rakuadventcalendar.wordpress.com/2019/12/13/day-4-a-little-rr/</a></p>
</div>
<div class="paragraph">
<p>A Little R&amp;R</p>
</div>
<div class="paragraph">
<p>![img](<a href="https://rakuadventcalendar.files.wordpress.com/2019/12/camelialoveferris.png" class="bare">https://rakuadventcalendar.files.wordpress.com/2019/12/camelialoveferris.png</a>)</p>
</div>
<div class="sect2">
<h3 id="_介绍_6">64.1. 介绍</h3>
<div class="paragraph">
<p>Raku 是一种非常不错的语言。 多才多艺，富有表现力，快速，敏捷。 我有时遇到的唯一问题是它可能会有点慢。 幸运的是，可以通过 <a href="https://docs.raku.org/language/nativecall#index-entry-nativecall">NativeCall</a> 接口轻松解决，这使得在 Raku 程序中轻松调用 C 代码成为可能。 现在，和 C 语言一样好，它是一种相当古老的语言，但有一些限制。 可以填补其空白的一种较新的语言称为 Rust。 我将展示一些 Raku 与 Rust 交谈的例子。</p>
</div>
</div>
<div class="sect2">
<h3 id="_ffi">64.2. FFI</h3>
<div class="paragraph">
<p>可以使用 FFI 标准从其他语言调用 Rust 代码。 FFI 代表“外部功能接口”，并允许您将 Rust 库导出为标准共享库（Linux 上的.so 文件或 Windows 上的.dll）。 这是通过在 Cargo.toml 中添加以下部分来完成的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-toml" data-lang="toml">[lib]
crate-type = [&#34;cdylib&#34;]</code></pre>
</div>
</div>
<div class="paragraph">
<p>添加此部分后，使用 Cargo 构建库时，您将在 target/debug 或 target/release 文件夹中找到库。 另外，请确保添加 libc 依赖项以访问标准 C 类型。</p>
</div>
</div>
<div class="sect2">
<h3 id="_primitives">64.3. Primitives</h3>
<div class="paragraph">
<p>我们可以使用与 C 中相同的原始类型：数字（和字符）和数组。</p>
</div>
<div class="sect3">
<h4 id="_numbers_和_chars">64.3.1. Numbers 和 chars</h4>
<div class="paragraph">
<p>Rust:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">#[no_mangle]
pub extern fn addition(a: u32, b:32) -&gt; u32 {
        a + b
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;
sub addition(uint32, uint32) returns uint32 is native(&#39;foo&#39;) { * }</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>#[no_mangle]</code>，这会使函数的名称在最终库文件中保持不变。 尽管 Rust 具有标准化的名称修饰功能（与 <code>C++</code> 相反，名称修饰依赖于平台），但仍然可以使用原始名称来调用函数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_数组和字符串">64.3.2. 数组和字符串</h4>
<div class="paragraph">
<p>Rust:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">use std::ffi::CStr;
use std::os::raw::c_char;

#[no_mangle]
pub unsafe extern fn count_chars(s: *const c_char) -&gt; u32 {
        CStr::from_ptr(s).to_str().unwrap().chars().count() as u32
}

#[no_mangle]
pub extern fn lunch() -&gt; *mut c_char {
        let c_string = CString::new(&#34;🌮🍚&#34;).expect(&#34;CString::new failed&#34;);
        c_string.into_raw()
}

#[no_mangle]
pub unsafe extern fn free_lunch(ptr: *mut c_char) {
        let _ = CString::from_raw(ptr);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub count_chars(Str is encoded(&#39;utf8&#39;)) returns uint32 is native (&#39;foo&#39;) { * }
sub lunch() returns CArray[uint8] is native(&#39;foo&#39;) { * }
sub free_lunch(CArray[uint8]) is native(&#39;foo&#39;) { * }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rust 对 UTF-8 具有一流的支持，使其非常适合 Raku。 使用 CString 还可以保证在字符串的末尾添加一个空字节，因此您可以通过循环获取有效字节，直到 AT-POS（）值等于 0…如果，也就是说，您选择返回一个数组而不是填充 它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_结构体">64.3.3. 结构体</h4>
<div class="paragraph">
<p>Rust:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">use std::mem::swap;

#[repr(C)]
pub struct Point {
    x: f32,
    y: f32,
}

impl Point {
        fn print(&amp;self) {
                println!(&#34;x: {}, y: {}&#34;, self.x, self.y);
        }
}

#[no_mangle]
pub unsafe extern &#34;C&#34; fn flip(p: *mut Point) {
    swap(&amp;mut (*p).x, &amp;mut (*p).y);
        (*p).print();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Point is repr(&#39;CStruct&#39;) {
    has num32 $.x;
    has num32 $.y;
}

sub flip(Pointer[Point]) is native(&#39;./librnr.so&#39;) { * }

sub flipper {
    my Point $p .= new(x =&gt; 3.Num, y =&gt; 4.Num);
    say &#34;x: &#34;, $p.x, &#34;, y: &#34;, $p.y;
    flip(nativecast(Pointer[Point], $p));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rust 将对象分为结构（我们都熟悉）和特质，它们在 Raku 中就像角色一样。</p>
</div>
</div>
<div class="sect3">
<h4 id="_concurrency">64.3.4. Concurrency</h4>
<div class="paragraph">
<p>Rust:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rust" data-lang="rust">#[no_mangle]
pub extern &#34;C&#34; fn multithread(count: i32) {
    let threads: Vec&lt;_&gt; = (1..8)
        .map(|id| {
            thread::spawn(move || {
                println!(&#34;Starting thread {}&#34;, id);
                let mut x = 0;
                for y in 0..count {
                    x += y;
                    println!(&#34;Thread {}, {}/{}: {}&#34;, id, y, count, x);
                }
            })
        })
        .collect();

    for t in threads {
        t.join().expect(&#34;Could not join a thread!&#34;);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub multithread(int32) is native(&#39;./librnr.so&#39;) { * }

sub multi-multithread {
    my @numbers = (3_000..50_000).pick(10);

    my @promises;

    for @numbers -&gt; $n {
        push @promises, start {
            multithread($n);
            True;
        };
    }

    await Promise.allof(@promises);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rust 和 Raku 都具有一流的并发支持。 这使您可以轻松地调整程序以获得最佳性能。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_结语_2">64.4. 结语</h3>
<div class="paragraph">
<p>这些是在展望未来时最有前途的两种语言 Rust 和 Raku 之间交互的一些示例。 如果您觉得这很有趣，请务必阅读 Andrew Shitov 的“每日一门语言”文章。 感谢您的阅读和节日快乐。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十四天_超越类型之外之_rakudo_mop">65. 第十四天 超越类型之外之 Rakudo MOP</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rakuadventcalendar.wordpress.com/2019/12/14/thinking-beyond-types-an-introduction-to-rakudos-mop/" class="bare">https://rakuadventcalendar.wordpress.com/2019/12/14/thinking-beyond-types-an-introduction-to-rakudos-mop/</a></p>
</div>
<div class="paragraph">
<p>圣诞节到了！如果没有庆祝活动这部分，圣诞节就不会是圣诞节。因此，让我们唱歌吧。</p>
</div>
<div class="paragraph">
<p>我们可以简单地将颂歌制作成一个大字符串，但这还不够。颂歌是一首歌，通常在每节经文之间都有合唱。如果我们将其存储为一个字符串，那么我们将重复自己。最重要的是，人们并不完美。他们可能会忘记颂歌的诗句，甚至只是一行诗句。我们需要一种代表颂歌的类型。这可能是一首歌，但由于我们只关心颂歌，因此将其抽象出来还为时过早。</p>
</div>
<div class="paragraph">
<p>现在，为了使它变得更有趣，让我们在不制作任何类型的实例的情况下进行处理。所有圣诞节颂歌的所有行为都将由类型对象处理。这将使用 <a href="https://docs.raku.org/language/traits#index-entry-Uninstantiable_representation_trait">Unrestantiable REPR</a> 强制执行。</p>
</div>
<div class="paragraph">
<p>一开始，我们可能会有一个 Christmas::Carol 角色：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Christmas::Carol is repr&lt;Uninstantiable&gt; {
    proto method name(::?CLASS:U: --&gt; Str:D)        {*}
    proto method verse(::?CLASS:U: Int:D --&gt; Seq:D) {*}
    proto method chorus(::?CLASS:U: --&gt; Seq:D)      {*}
    proto method lyrics(::?CLASS:U: --&gt; Seq:D)      {*}

    method sing(::?CLASS:U: --&gt; ::?CLASS:U) {
        .say for @.lyrics;
        self
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，由代表特定颂歌的类完成此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Christmas::Carol::JingleBells does Christmas::Carol {
    multi method name(::?CLASS:U: --&gt; &#39;Jingle Bells&#39;) { }

    multi method verse(::?CLASS:U: 1 --&gt; Seq:D) {
        lines q:to/VERSE/
        Dashing through the snow
        In a one-horse open sleigh
        O&#39;er the fields we go
        Laughing all the way
        Bells on bobtails ring
        Making spirits bright
        What fun it is to ride and sing
        A sleighing song tonight
        VERSE
    }
    multi method verse(::?CLASS:U: 2 --&gt; Seq:D) {
        lines q:to/VERSE/
        A day or two ago
        I thought I&#39;d take a ride
        And soon, Miss Fanny Bright
        Was seated by my side
        The horse was lean and lank
        Misfortune seemed his lot
        He got into a drifted bank
        And then we got upset
        VERSE
    }
    multi method verse(::?CLASS:U: 3 --&gt; Seq:D) {
        lines q:to/VERSE/
        A day or two ago
        The story I must tell
        I went out on the snow
        And on my back I fell
        A gent was riding by
        In a one-horse open sleigh
        He laughed as there I sprawling lie
        But quickly drove away
        VERSE
    }
    multi method verse(::?CLASS:U: 4 --&gt; Seq:D) {
        lines q:to/VERSE/
        Now the ground is white
        Go it while you&#39;re young
        Take the girls tonight
        And sing this sleighing song
        Just get a bobtailed bay
        Two forty as his speed
        Hitch him to an open sleigh
        And crack, you&#39;ll take the lead
        VERSE
    }

    multi method chorus(::?CLASS:U: --&gt; Seq:D) {
        lines q:to/CHORUS/
        Jingle bells, jingle bells
        Jingle all the way
        Oh, what fun it is to ride
        In a one-horse open sleigh, hey
        Jingle bells, jingle bells
        Jingle all the way
        Oh, what fun it is to ride
        In a one-horse open sleigh
        CHORUS
    }

    multi method lyrics(::?CLASS:U: --&gt; Seq:D) {
        gather for 1..4 {
            take $_ for @.verse($_);
            take &#34;&#34;;
            take $_ for @.chorus;
            take &#34;&#34; if $_ != 4;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>不过，这种方法存在问题。如果您想保留一系列圣诞颂歌以邻里颂歌怎么办？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Christmas::Carol::JingleBells;
use Christmas;:Carol::JingleBellRock;
use Christmas::Carol::DeckTheHalls;
use Christmas::Carol::SilentNight;
# And so on...</code></pre>
</div>
</div>
<div class="paragraph">
<p>这不太好! 您无需知道谁写了圣诞节颂歌就可以唱歌。最重要的是，没有人想到符号的圣诞颂歌。他们以他们的名字来思考他们。为了有效地表示它们，我们需要使其能够使用其名称查找圣诞节颂歌，同时还可以引入可以以这种方式同时查找的新颂歌。我们应该怎么做？</p>
</div>
<div class="paragraph">
<p>我们在这里使用的方式需要对 Raku 中的类型如何工作进行一些解释。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_元对象协议">66. 元对象协议</h2>
<div class="sectionbody">
<div class="paragraph">
<p>类可能包含三种不同类型的方法声明。你最常看到的两个是公共方法和私有方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Example {
    method !private-method(|) { ... }
    method public-method(|)   { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以进行方法声明的第三种类型，这是类所独有的（这是一个谎言，但这仅是用 Rakudo 编写 Raku 时就是这种情况），方法名称的前缀是 <code>^.</code> 通常使用 <code>.^</code> 调度运算符来调用这些函数，当您需要自检一个对象（<code>.^name</code>, <code>.^method</code> 等）时，通常会看到它们。但是，这些行为完全不像您期望的方法那样。让我们看一下使用 <code>.^</code> 调度运算符调用此类型的方法时，invocant 和参数是什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Example {
    method ^strange-method(\invocant: |params --&gt; List:D) {
        (invocant, params)
    }
}

say Example.^strange-method;
# OUTPUT:
# (Perl6::Metamodel::ClassHOW+{&lt;anon&gt;}.new \(Example))</code></pre>
</div>
</div>
<div class="paragraph">
<p>哇，哇，WTF？ 为什么在第一个参数中声明此类方法而不是在其调用方中声明类？ 该对象最终成为其发起者，那又是什么呢？它是从哪里来的呢？</p>
</div>
<div class="paragraph">
<p>在对此进行解释之前，首先我们需要对元对象协议（MOP）是什么有所了解。MOP 是 Rakudo 特有的功能，通过它可以实现 Raku 中可能存在的所有对象的行为。这些基于类（类型的类型）（例如类，角色和语法）实现。任何类型的行为都是由称为元对象的高阶工作（HOW）驱动的。这些通常是某种元类的实例。例如，类的 HOW 由 <a href="https://docs.raku.org/type/Metamodel::ClassHOW">Metamodel::ClassHOW</a> 元类创建。</p>
</div>
<div class="paragraph">
<p>可以对任何给定对象的 HOW 进行自省。怎么做？ 你怎么问？ 怎么样？ 怎么样！？ 当然，通过调用 HOW！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Foo { }
say Foo.HOW.^name; # OUTPUT: Metamodel::ParametricRoleGroupHOW</code></pre>
</div>
</div>
<div class="paragraph">
<p>HOW 的方法称为元方法，这些方法用于处理类型可以支持的各种行为。元方法处理的某些类型的行为示例包括类型名称，属性，方法，继承，参数化和类型检查。由于其中大多数不是特定于任何一种的功能，因此通常会通过 metarol 将这些功能混合到 metaclass 中。例如，Metamodel::Naming 元角色可以处理任何可以命名的类型的命名。</p>
</div>
<div class="paragraph">
<p>那么前面提到的第三种方法声明？ 实际上并没有为类声明方法； 相反，它声明了一种混合了该类 HOW 的元方法，类似于使用元醇的方法。<code>.^</code> 调度运算符只是一个糖，用于使用该对象作为其第一个参数来调用该对象的元方法，该元方法在大多数情况下会接受。例如，这两个元方法调用是等效的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Int.^name;         # OUTPUT: Int
say Int.HOW.name(Int); # OUTPUT: Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>元方法是我们将仅用于实现类型的圣诞节颂歌的工具。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spreading_the_joy">67. Spreading the Joy</h2>
<div class="sectionbody">
<div class="paragraph">
<p>首先，不要让圣诞节：: Carol 角色通过圣诞节颂歌班来完成，而是让我们的颂歌角色混合到 Christmas::Carol 类中。在本课程中，我们将像扮演角色一样，对圣诞节颂歌应该具有的方法进行存根，但是除此之外，还将保留圣诞节颂歌的词典，以其名字命名。</p>
</div>
<div class="paragraph">
<p>我们可以使用 add_carol 元方法存储颂歌：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my constant %CAROLS = %();
method ^add_carol(Christmas::Carol:U, Str:D $name, Mu $carol is raw --&gt; Mu) {
    %CAROLS{$name} := $carol;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以将角色标记为颂歌，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Christmas::Carol::JingleBells { ... }
Christmas::Carol.^add_carol: &#39;Jingle Bells&#39;, Christmas::Carol::JingleBells;</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这不是供人们使用的出色 API。特质可以做到，因此可以从角色的声明中进行处理。让我们为此制作一个颂歌特质：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub trait_mod:&lt;is&gt;(Mu \T, Str:D :carol($name)!) {
    Christmas::Carol.^add_carol: $name, T
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以将角色定义为像这样的颂歌：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Christmas::Carol::JingleBells is carol(&#39;Jingle Bells&#39;) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了做到这一点，我们可以按名称提取颂歌，我们只需将 Christmas::Carol 类设置为参数即可。这可以通过给它一个参数化元方法来完成，给定名称，该方法将使用我们知道的任何颂歌创建一个 Christmas::Carol mixin：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method ^parameterize(Christmas::Carol:U $this is raw, Str:D $name --&gt; Christmas::Carol:U) {
    self.mixin: $this, %CAROLS{$name}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们可以使用颂歌名称通过参数 Christmas::Carol 来检索圣诞节颂歌。但是，返回的 mixin 类型的名称是什么？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Christmas::Carol[&#39;Jingle Bells&#39;].^name;
# OUTPUT: Christmas::Carol+{Christmas::Carol::JingleBells}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有点难看。让我们在参数化过程中重置混音的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method ^parameterize(Christmas::Carol:U $this is raw, Str:D $name --&gt; Christmas::Carol:U) {
    my Christmas::Carol:U $carol := self.mixin: $this, %CAROLS{$name};
    $carol.^set_name: &#39;Christmas::Carol[&#39; ~ $name.perl ~ &#39;]&#39;;
    $carol
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这给我们的叮当铃颂歌取了圣诞节的名字：: Carol [“Jingle Bells”]。好多了。</p>
</div>
<div class="paragraph">
<p>让我们添加最后一种方法：颂歌。这将返回圣诞节已知的颂歌的名称列表：: Carol：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method ^carols(Christmas::Carol:U --&gt; List:D) {
    %CAROLS.keys.list
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样，我们的 Christmas::Carol 类就完成了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Christmas::Carol is repr&lt;Uninstantiable&gt; {
    proto method name(::?CLASS:U: --&gt; Str:D)        {*}
    proto method chorus(::?CLASS:U: --&gt; Seq:D)      {*}
    proto method verse(::?CLASS:U: Int:D --&gt; Seq:D) {*}
    proto method lyrics(::?CLASS:U: --&gt; Seq:D)      {*}

    method sing(::?CLASS:U: --&gt; ::?CLASS:U) {
        .say for @.lyrics;
        self
    }

    my constant %CAROLS = %();
    method ^add_carol(Christmas::Carol:U, Str:D $name, Mu $carol is raw --&gt; Mu) {
        %CAROLS{$name} := $carol;
    }
    method ^carols(Christmas::Carol:U --&gt; List:D) {
        %CAROLS.keys.list
    }
    method ^parameterize(Christmas::Carol:U $this is raw, Str:D $name --&gt; Christmas::Carol:U) {
        my Christmas::Carol:U $carol := self.mixin: $this, %CAROLS{$name};
        $carol.^set_name: &#39;Christmas::Carol[&#39; ~ $name.perl ~ &#39;]&#39;;
        $carol
    }
}

multi sub trait_mod:&lt;is&gt;(Mu \T, Str:D :carol($name)!) {
    Christmas::Carol.^add_carol: $name, T
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，这一切都很棒，但是对我们的原始代码有何改进？ 通过以这种方式定义颂歌，我们不再需要知道颂歌的歌唱符号，也不再需要知道哪个模块甚至首先宣布了颂歌。只要我们知道 Christmas::Carol 类存在，我们就知道我们导入的所有模块的所有颂歌碰巧都知道。</p>
</div>
<div class="paragraph">
<p>这意味着可以有一个模块定义颂歌的集合：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Christmas::Carol::JingleBells;
use Christmas::Carol::JingleBellRock;
use Christmas::Carol::DeckTheHalls;
use Christmas::Carol::SilentNight;
unit module Christmas::Carol::Collection;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在另一个模块中，我们可以使用此模块进行另一个收集，并定义更多颂歌：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Christmas::Carol::Collection;
use Christmas::Carol::JingleBells::BatmanSmells;
unit module Christmas::Carol::Collection::Plus;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们可以导入此文件，并轻松唱歌，除了这个新模块添加的名称外，还按名称演唱所有原始模块的颂歌：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Christmas::Carol;
use Christmas::Carol::Collection::Plus;

Christmas::Carol[$_].sing for Christmas::Carol.^carols;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这一点上，您可能会想：“难道您不可以使用实例编写与此功能相同的代码吗？”。你说得对！这表明，尽管使用 Rakudo 时有一种用于处理类型的协议，但任何给定类型的行为并不是特别独特。它主要由可以完全控制的元对象驱动。</p>
</div>
<div class="paragraph">
<p>仅使用类中的元方法声明，您就可以扩大或覆盖支持继承的任何类型的行为。这与 MOP 允许您对类型所做的事情相去甚远！与 MOP 配合使用的更高级的功能将需要更多的解释，最好再待一段时间。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十五天_圣诞老人有太多蛋酒了">68. 第十五天 - 圣诞老人有太多蛋酒了</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们距离圣诞节只有一个多星期了，圣诞老人正在向他的小精灵们发送最后的礼物清单。不幸的是，圣诞老人的蛋酒太多了，所以他发给自己的精灵的清单……不是最大的。看看其中的一些：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Johnny
 - 4 bsaeball gluvs
 - 2 batts
 - 2 ballz
Mary
 - 3 fancee dols
 - 1 dressss
 - 1 bbaskebtall</code></pre>
</div>
</div>
<div class="paragraph">
<p>圣诞老人设法以某种方式保留了我们通常可以使用正则表达式处理的良好格式，因此精灵开始认真研究一种良好的 <a href="https://docs.raku.org/language/grammars">grammar</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Santa&#39;sList {
  rule TOP        {  &lt;kid&#39;s-list&gt;+    }
  rule kid&#39;s-list {  &lt;name&gt; &lt;gift&gt;+ }
  rule gift       { &#39;-&#39; &lt;quantity&gt; &lt;item&gt;  }
  token name      { &lt;-[\n]&gt;   }
  token quantity  { &lt;.digit&gt;+ }
  token item      { &lt;.alpha&gt;+ % \h+ }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管精灵们认为他们可以尝试弄清他在一个动作对象中的含义，但他们认为创建一个不仅可以在 grammar 中，而且可以在任意正则表达式中重用的 token 将更加有趣!</p>
</div>
<div class="paragraph">
<p>他们想制作一个新的叫做 <code>&lt;fuzzy&gt;</code> 的 <a href="https://docs.raku.org/syntax/token">token</a>，可以以某种方式捕获圣诞老人的醉酒涂鸦（我们可以称他的打字列表为涂鸦吗？）。但是正则表达式语法实际上不允许进行任何类型的模糊匹配。但是这里 Raku 的引擎得以救援。因此，首先他们在 token 内部创建了一个代码块。代码块通常仅用 { 🦋 } 来定义，但是由于它们需要定义匹配是否成功，因此选择了条件块而不是 &lt;?{ 🦋 }&gt; <a href="https://docs.raku.org/language/regexes#Regex_boolean_condition_check">条件块</a>，这不仅会运行代码，而且如果条件块也将失败块返回 false-y 值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token fuzzy {
  (&lt;.alpha&gt;+ % \h+)
  &lt;?{
    # «ö» code here
  }&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在开始编写代码之前，他们做了另外两件事。首先，他们将捕获命名以便于维护。其次，他们意识到他们确实需要以某种方式将可能的玩具清单放入 token 中。因此，他们向 token 添加了签名以将其传递。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token fuzzy(**@toys) {
  $&lt;santa&#39;s-text&gt;=(&lt;.alpha&gt;+ % \h+)
  &lt;?{
    # «ö» code here
  }&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在他们可以开始编写代码了。他们会采用圣诞老人的文字，并将其与每个可能的玩具进行比较，然后确定哪个是最接近的玩具：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token fuzzy(**@toys) {
  $&lt;santa&#39;s-text&gt;=(&lt;.alpha&gt;+ % \h+)
  &lt;?{
    my $best = @toys
                 .map({ $^toy, qgram($toy,$&lt;santa&#39;s-text&gt;.Str)})
                 .sort( *.tail )
                 .tail;
    say &#34;Santa meant to write {$best[0]}&#34;;
  }&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>他们使用的 Q-gram 函数为每个单词创建 N-gram，并将它们进行比较以查看它们有多少共同点。通过测试，他们发现 N 的最佳值（每个子串的长度）约为平均长度的一半。Raku 编写 Q-gram 函数的工作方式非常简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| Generate space-padded N-grams of length n for string t.
sub ngrams = -&gt; \t, \n {
  my \s = (&#39; &#39; x n - 1)  ~ t ~  (&#39; &#39; x n - 1);
  do for ^(t.chars + n) { s.substr: $_, n }
}

#| Calculate Q-gram score using bag operations
sub qgram (\a, \b) {
  my \q  = (a.chars + b.chars) div 4;
  my \aₙ = ngrams(a,q).BagHash;
  my \bₙ = ngrams(b,q).BagHash;

  (aₙ ∩ bₙ) / (aₙ ∪ bₙ)      # Coefficient de communauté de Jaccard
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 让精灵只用两行干净的代码就可以计算出 N-gram，然后再用另外四行易于阅读的代码来使用它们来计算两个字符串之间的 <a href="https://en.wikipedia.org/wiki/Jaccard_index">Jaccard-index</a>。</p>
</div>
<div class="paragraph">
<p>将其放回到 grammar 中，他们得出以下结论：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Santa&#39;sList {
  rule TOP        {       &lt;kid&#39;s-list&gt;+    }
  rule kid&#39;s-list {     &lt;name&gt;     &lt;gift&gt;+ }
  rule gift       { &#39;-&#39; &lt;quantity&gt; &lt;item&gt;  }
  token name      { &lt;-[\n]&gt;   }
  token quantity  { &lt;.digit&gt;+ }
  token item      { &lt;fuzzy(@gifts)&gt; }
  token fuzzy     { … }
  sub ngrams      { … }
  sub qgrams      { … }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一种非常方便的格式，但是仍然存在一个重要的问题。他们如何获得最匹配的文本？ 如果他们匹配并要求，例如 <code>$&lt;kid’s-list&gt;[0]&lt;gift&gt;[0]&lt;item&gt;</code>，那么他们只会得到圣诞老人原来难以辨认的混乱。他们可以执行一个动作，但是需要对动作进行解析，这意味着 fuzzy token 与语法解析的繁琐联系在一起。在这里可以正常工作，但是…不可重用。</p>
</div>
<div class="paragraph">
<p>但是精灵擅长包装和包裹。他们决定制作一个包装了 fuzzy token 的包装，以便以 DWIM 方式轻松访问圣诞老人的原始版本和经更正的版本。不过，此&#34;包&#34;不能与<a href="https://docs.raku.org/language/packages">包</a>或<a href="https://docs.raku.org/language/module-packages">模块</a>一起声明，因为打包过程需要使用特殊的 sub <a href="https://docs.raku.org/language/modules#index-entry-sub_EXPORT">EXPORT</a>。它们的基本过程如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub EXPORT {
  # Make the fuzzy token in the elve&#39;s factory
  my token fuzzy (*@words) { … }

  # Wrap it in wrapping paper (apply a role) so it&#39;s prettier (easier to use)
  &amp;fuzzy.wrap( … )

  # Ship out (export) the wrapped version
  %( &#39;&amp;fuzzy&#39; =&gt; &amp;fuzzy )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>精灵需要的任何其他特殊工具都可以包含在 EXPORT 块中，例如 Q-gram 和 N-gram 函数。那么，他们实际上将如何包装？ 首先，他们设计文件，即<a href="https://docs.raku.org/language/objects#index-entry-Parameterized_Roles">参数化角色</a>，它将覆盖 .Str 以提供干净/更正的值，但还提供对 .fuzz 函数的访问以允许访问较旧的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Fuzzy[$clear,$fuzz] {
  method Str  { $clear }
  method fuzz { $fuzz  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，包装后的函数可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&amp;fuzzy.wrap(
  sub (|) {
    my $match = callsame;

    # Failed match evals to false, and is just passed along
    # Successful match gets Fuzzy role mixed in.
    $match
      ?? $match but Fuzzy[$match.??, $match.??]
      !! $match
  }
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>有一个小问题。它们在 token 中进行的计算结果不可用。他们认为涉及向具有特征的 fuzzy token 添加新参数的一种解决方案是原始的，以便可以将值传递回去，但这就像老 <code>C++</code> 精灵会做的那样。不，圣诞老人的 Raku 精灵有一个更好的主意：<a href="https://docs.raku.org/language/variables#Dynamic_variables">动态变量</a>。他们制作了其中的两个，并重构了原始的 fuzzy 方法以分配给他们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my token fuzzy(**@toys) {
  $&lt;santa&#39;s-text&gt;=(&lt;.alpha&gt;+ % \h+)
  &lt;?{
    my $best = @toys
                .map({ $^toy, qgram($toy,$&lt;santa&#39;s-text&gt;.Str)})
                .sort( *.tail )
                .tail;
    $*clear = $best[0];
    $*fuzz  = ~$&lt;santa&#39;s-text&gt;;
  }&gt;
}

&amp;fuzzy.wrap(
  sub (|) {
    my $*fuzz;
    my $*clear;

    my $match = callsame;   # sets $match to result of the original

    $match
      ?? $match but Fuzzy[$*clear, $*fuzz]
      !! $match
  }
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>他们用一些值进行了测试，并且一切顺利，直到没有找到一个项目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&#34;I like the Norht Pole&#34; ~~ /I like the $&lt;dir&gt;=&lt;fuzzy: &lt;North South&gt;&gt; Pole/;
say $&lt;dir&gt;.clear;   # --&gt; &#34;North&#34;
say $&lt;dir&gt;.fuzz;    # --&gt; &#34;Norht&#34;

&#34;I like the East Pole&#34; ~~ /I like the $&lt;dir&gt;=&lt;fuzzy: &lt;North South&gt;&gt; Pole/;
say $&lt;dir&gt;.clear;   # --&gt; &#34;North&#34;
say $&lt;dir&gt;.fuzz;    # --&gt; &#34;East&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>发生了什么？ 精灵们意识到他们的 token 无论如何都匹配。这是因为 <code>&lt;?{ 🦋 }&gt;</code> 块仅在返回假值时才会失败。最后一个语句是字符串的赋值，实际上几乎总是真实的。为了解决这个问题，他们在区块末尾添加了一个简单的条件，如果 Q-gram 得分不够高则失败。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my token fuzzy(**@toys) {
  $&lt;santa&#39;s-text&gt;=(&lt;.alpha&gt;+ % \h+)
  &lt;?{
    my $best = @toys
                 .map({ $^toy, qgram($toy,$&lt;santa&#39;s-text&gt;.Str)})
                 .sort( *.tail )
                 .tail;

    $*clear = $best[0];
    $*fuzz  = ~$&lt;santa&#39;s-text&gt;;

    # Arbitrary but effective score cut off.
    $best[1] &gt; 0.33
  }&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样，他们就完成了，并且能够处理圣诞老人的可怕打字。</p>
</div>
<div class="paragraph">
<p>当然，精灵们仍然可以做出很多改进，以使他们的 fuzzy token 更加有用。在他们使用完之后（将蛋酒从圣诞老人那里拿走了，所以他们不再需要它了），他们对其进行了抛光，以便为所有人带来欢乐。</p>
</div>
<div class="paragraph">
<p>这样，我还可以宣布 <a href="https://github.com/alabamenhu/RegexFuzzyToken">Regex::FuzzyToken</a> 的发布。要使用它，就像精灵一样，并在 grammar 或任何其他代码中进行操作，例如说使用 Regex::FuzzyToken，token fuzzy 将被导入到你当前的作用域中。它具有一些额外的功能，因此请查看其自述文件以获取有关某些选项的信息。</p>
</div>
<div class="paragraph">
<p>尽管不是每个人都会使用或需要 fuzzy token，但我希望这能在创建可以通过编程更好地定义的 token 以及其他酷 Raku 功能（例如 Bag 运算符，动态变量和参数化角色）时展示一些有趣的可能性。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十六天_raku_加持的工作面跳转">69. 第十六天 - Raku 加持的工作面跳转</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rakuadventcalendar.wordpress.com/2019/12/16/raku-powered-jmp-ing-to-the-coalface/" class="bare">https://rakuadventcalendar.wordpress.com/2019/12/16/raku-powered-jmp-ing-to-the-coalface/</a></p>
</div>
<div class="paragraph">
<p>圣诞老人确保他的小精灵可以快速进出工作场所。我希望计算机编程也一样！有时需要花费一些时间才能遍历代码库，以查找真正的工作需要在哪里进行。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/nige123/jmp.nigelhamilton.com">jmp</a> 是 Raku 提供动力的命令行实用程序，我用于搜索和跳转大型代码库和命令输出。它为您最喜欢的 <code>$code-searching</code> 工具（例如，ag，git grep，ack 等）提供了一个终端前端，因此您可以快速跳入您最喜欢的 <code>$EDITOR</code>（例如，vim，代码，emacs 等）。</p>
</div>
<div class="paragraph">
<p>它是这样的：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2019/12/jmp-demo.gif?w=600&amp;zoom=2" alt="jmp demo"/>
</div>
</div>
<div class="paragraph">
<p>跳入大型代码库时，我经常需要访问许多不同的文件和存储库。有时这会打击我的短期记忆缓冲区。为了<a href="https://perl6advent.wordpress.com/2015/12/20/perl-6-christmas-have-an-appropriate-amount-of-fun/">保持流程顺畅</a>，我在整个代码中留下了面包屑式的注释（即“＃COAL”）。稍后，当我需要返回文件位置的界面时，我会进行一次 <strong>jmp</strong> 搜索以查找 “COAL”。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">shell&gt; jmp to COAL</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以，但是这是手动过程，需要先清除所有 COAL 标记。<strong>jmp</strong> 可以在这里提供更多帮助吗？</p>
</div>
<div class="paragraph">
<p>如果 <strong>jmp</strong> 自动记住我在代码库中访问过的地方，这样就很酷了，那么我就不需要留下 COAL 标记了。听起来还需要更多 Raku！</p>
</div>
<div class="paragraph">
<p>为此，<strong>jmp</strong> 需要一个内存：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># keep a file-based record of the searches and jmps
class JMP::Memory {

    has $.max-entries = 100; # keep a record of the last 100 jmps
    has $!file;
    has @!latest-jmps;

    #| get a list of the most recent JMP::File::Hits
    method get-recent-jmps ($last-n-jmps) { ... }

    #| write the memory file
    method save ($jmp-command, $hit) { ... }

    submethod TWEAK { ... }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，让我们填写这个类。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/objects#index-entry-TWEAK">TWEAK</a> 是一种特殊的子方法，用于帮助在创建实例后延迟完成对象的构建。并非所有对 <strong>jmp</strong> 的调用都需要重新调用内存，因此最好避免处理历史记录文件。<code>$!file</code> 和 <code>@!latest-jmps</code> 封装为 <a href="https://docs.raku.org/language/classtut">私有属性</a>，因此将来可以根据需要轻松更改。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">submethod TWEAK {

    $!file = $*HOME.add(&#39;.jmp.hist&#39;).path;
    return unless $!file.IO.e;
    return without my $history = from-json($!file.IO.slurp);
    @!latest-jmps = $history.List;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>方便的全局 <a href="https://docs.raku.org/language/variables#index-entry-$*HOME">$*HOME</a> <a href="https://docs.raku.org/language/io-guide">IO::Path</a> 对象有助于为 <strong>jmp</strong> 历史记录文件（例如 <code>~/.jmp.hist</code>）创建跨平台位置。如果文件存在，我们将文件一口吃掉，然后借助 <a href="https://modules.raku.org/dist/JSON::Tiny:cpan:MORITZ/lib/JSON/Tiny/Actions.pm">JSON::Tiny::from-json</a> 将 json 有效内容解析为 <strong>jmp</strong> 记录列表。</p>
</div>
<div class="paragraph">
<p>每当发生搜索命中时，我们都需要保存 <strong>jmp</strong> 命令和选定的命中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| write the memory file
method save ($jmp-command, $hit) {

    # for each incoming hit - we record two entries - the jmp command
    my %jmp-record = %(
        current-directory =&gt; $*CWD.path,
        jmp-command       =&gt; $jmp-command,
    );

    # and the selected destination
    my %hit-record = %(
        line-number   =&gt; $hit.line-number,
        file-path     =&gt; $hit.file-path,
        full-path     =&gt; $hit.full-path,
        matching-text =&gt; $hit.matching-text,
    );

    @!latest-jmps.unshift(%hit-record);
    @!latest-jmps.unshift(%jmp-record);

    my @hits = @!latest-jmps;

    @!latest-jmps = @hits.head($!max-entries);

    # dump to disk
    $!file.IO.spurt(to-json(@!latest-jmps));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将记录<a href="https://docs.raku.org/routine/unshift#(Array)_routine_unshift">移到</a>列表的开头意味着最近的 jmp 出现在顶部。限制列表的 <a href="https://docs.raku.org/routine/head#(List)_method_head">head()</a> 可以确保列表不会太大，并且 <strong>jmp</strong> 保持快速。</p>
</div>
<div class="paragraph">
<p>当用户不带任何参数调用 <strong>jmp</strong> 时，将显示最近的 jmp 列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method get-recent-jmps ($last-n-jmps) {
    # return a list of JMP::File::Hits
    my @recent-jmps;
    for @!latest-jmps.head($last-n-jmps) -&gt; %hit {
        my $hit = %hit&lt;jmp-command&gt;:exists
                ?? JMP::Memory::Command.new(|%hit)
                !! JMP::Memory::Hit.new(|%hit);
        @recent-jmps.push($hit);
    }
    return @recent-jmps;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>for</strong> 循环遍历先前记录的 <strong>jmp</strong> 命令和选定的搜索命中。这是 <a href="https://github.com/nige123/jmp.nigelhamilton.com/blob/master/lib/JMP/Memory.pm">JMP::Memory</a> 的完整源代码。</p>
</div>
<div class="paragraph">
<p>现在，<strong>jmp</strong> 可以帮助您快速返回编码界面，而不会一团糟。</p>
</div>
<div class="paragraph">
<p>要安装最新版本的 <strong>jmp</strong>，请先 <a href="https://raku.org/downloads/">安装 Raku</a>，然后使用 <a href="https://github.com/ugexe/zef">zef</a> 在 Perl 6 模块管理器中进行安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">shell&gt; zef install jmp
shell&gt; zef upgrade jmp   # if you&#39;ve installed it before</code></pre>
</div>
</div>
<div class="paragraph">
<p>期待在 2020 年使用更多由 Raku 提供动力的公用事业。</p>
</div>
<div class="paragraph">
<p>圣诞快乐！</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十七天_迷宫机">70. 第十七天 - 迷宫机</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rakuadventcalendar.wordpress.com/2019/12/17/maze-maker-for-fun/" class="bare">https://rakuadventcalendar.wordpress.com/2019/12/17/maze-maker-for-fun/</a></p>
</div>
<div class="paragraph">
<p>我记得在学校的时候，我曾经玩过游戏，可以帮助鼠标尽可能快地到达迷宫。甚至当我完成大学学习时，我仍然想知道如何创建一个迷宫。那些制造迷宫的人必须超级聪明。</p>
</div>
<div class="paragraph">
<p>直到最近我才决定解开迷宫创作的奥秘。我问我的朋友谷歌，想知道是什么，给我提供了多种语言的大量解决方案。有些非常难于遵循，而有些则并非如此。深入了解算法后，我决定以我的第一语言（即 Perl）来做。我花了很长时间将算法转换为 Perl 脚本。</p>
</div>
<div class="paragraph">
<p>众所周知，我仍然是 Raku 的新手。值得庆幸的是，在 Raku 查询方面，我有很多支持。我第一次决定成为 Raku Advent Calendar 的一员。多亏了 JJ Merelo，我才有空位。那时，我不知道该怎么办。但是我知道我有很多可以转化为 Raku 的想法。</p>
</div>
<div class="paragraph">
<p>您猜对了，我为 Raku Advent Calendar 选择了我最喜欢的迷宫制作器脚本。在 Twitter 上许多人的帮助下，我在 Raku 准备了我的第一稿。但这并没有按预期创建隧道。我去找朋友 Scimon Proctor 寻求指导。他帮助我完成了 Raku 魔术，现在一切顺利。</p>
</div>
<div class="paragraph">
<p>在我将其交给 JJ Merelo 之前，是时候做一些家务了。花了大约 30 分钟的时间，我准备好了我的最终草案，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6;

my %opposite-of = ( &#39;north&#39; =&gt; &#39;south&#39;, &#39;south&#39; =&gt; &#39;north&#39;,  &#39;west&#39; =&gt; &#39;east&#39;, &#39;east&#39;  =&gt; &#39;west&#39; );
my @directions  = %opposite-of.keys;

sub MAIN(Int :$height = 10, Int :$width = 10) {
    my $maze;
    make-maze( 0, 0, $maze, $height, $width );
    say render-maze( $maze, $height, $width );
}

#
#
# METHODS

sub make-maze( $x, $y, $maze is rw, $height, $width ) {

    for ( @directions.pick(@directions) ) -&gt; $direction {
        my ( $new_x, $new_y ) = ( $x, $y );

        if    ( &#39;east&#39;  eq $direction ) { $new_x += 1; }
        elsif ( &#39;west&#39;  eq $direction ) { $new_x -= 1; }
        elsif ( &#39;south&#39; eq $direction ) { $new_y += 1; }
        else                            { $new_y -= 1; }

        if not-visited( $new_x, $new_y, $maze, $height, $width ) {
            $maze[$y][$x]{$direction} = 1;
            $maze[$new_y][$new_x]{ %opposite-of{$direction} } = 1;
            make-maze( $new_x, $new_y, $maze, $height, $width );
        }
    }
}

sub not-visited( $x, $y, $maze, $height, $width ) {

    # check the boundary
    return if $x &lt; 0 or $y &lt; 0;
    return if $x &gt; $width - 1 or $y &gt; $height - 1;

    # return false if already visited
    return if $maze[$y][$x];

    # return true
    return 1;
}

sub render-maze($maze, $height, $width) {

    my $as_string = &#34; &#34; ~ ( &#34;_ &#34; x $width );
    $as_string ~= &#34;\n&#34;;

    for ( 0 .. $height - 1 ) -&gt; $y {
        $as_string ~= &#34;|&#34;;
        for ( 0 .. $width - 1 ) -&gt; $x {
            my $cell = $maze[$y][$x];
            $as_string ~= $cell&lt;south&gt; ?? &#34; &#34; !! &#34;_&#34;;
            $as_string ~= $cell&lt;east&gt;  ?? &#34; &#34; !! &#34;|&#34;;
        }
        $as_string ~= &#34;\n&#34;;
    }

    return $as_string;
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_what_next">70.1. What next?</h3>
<div class="paragraph">
<p>我正在考虑将其转换为 Raku 库，类似于 <strong>Games::Maze</strong>。 我正在研究它，希望圣诞节前可以准备好它。</p>
</div>
<div class="paragraph">
<p>如果您认为可以以任何方式进行改进，请与我分享。 我很想听听您的意见，并从您的经验中学到东西。 然后，同样喜欢 Raku 的 Perl Fan 来尝试一下。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十八天_我的并发_raku_程序在做什么">71. 第十八天 - 我的并发 raku 程序在做什么?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 使在程序中引入一些并行性变得容易-至少在解决方案适合时。在构建并发应用程序时，其异步编程功能也很出色。在过去的一年中，我喜欢在工作中同时使用这两种方法。</p>
</div>
<div class="paragraph">
<p>但是，我还发现缺少某些东西。在 Raku 中构建想要的并行和并发事物相对简单。但是，一旦它们被构建，我就很难推理它们在做什么。例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于数据并行操作，实现了什么程度的并行性？</p>
</li>
<li>
<p>哪些任务并行执行，又有没有机会进一步并行执行任务？</p>
</li>
<li>
<p>异步工作流的不同阶段花在哪里？例如，如果 HTTP 请求可能触发后台工作，随后又导致通过 WebSocket 发送消息，那么这些步骤之间的时间在哪里？</p>
</li>
<li>
<p>鉴于 Cro Web 应用程序也是异步管道，请求处理时间在哪里？中间件是否令人吃惊地吞噬了很多时间？</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>首先，我开始放入一些时序代码，这些结果将结果写到控制台。当然，如果要保留在代码中，则必须以后再删除它，或者使用环境变量来保护它。即使到那时，它产生的数据也很难解释。所有这些都感觉相当低效。</p>
</div>
<div class="paragraph">
<p>因此，<a href="https://github.com/jnthn/p6-log-timeline">Log::Timeline</a> 诞生了。使用它，我了解了很多有关我的应用程序行为的信息。最棒的是，我不仅得到了我所提问题的答案，而且还得到了一些我什至没有考虑过的问题。在这篇出现的帖子中，我将向您展示如何使用该模块。</p>
</div>
<div class="sect2">
<h3 id="_试一试吧">71.1. 试一试吧</h3>
<div class="paragraph">
<p>我们可能会使用 Log::Timeline 的第一种方法实际上根本不涉及使用模块，而是使用一些已经使用该模块进行记录的库。自从 Cro::HTTP 完成此操作以来（自 0.8.1 开始），我们可以通过构建 <a href="https://cro.services/">Cro</a> HTTP 应用程序来初步了解 Log::Timeline。</p>
</div>
<div class="paragraph">
<p>除了产生日志事件的内容以外，我们还需要某种方式来查看日志。当前，Log::Timeline 输出有两种模式：以 JSONLines 格式写入文件或通过套接字发送它们。其中的第二个由 <a href="https://commaide.com/">Comma</a>（Raku IDE）中的日志查看器使用，这意味着我们可以在应用程序运行时实时查看输出。</p>
</div>
<div class="paragraph">
<p>因此，假设我们已经安装了 Cro，我们可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在逗号中创建一个新的 Cro Web 应用程序项目（工作原理非常类似于在命令行中使用 cro stub）</p>
</li>
<li>
<p>创建“交叉服务”运行配置（在“运行”菜单上选择“编辑配置”）</p>
</li>
<li>
<p>在“运行”菜单上，选择“运行’service.p6”并显示时间轴”</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>该服务将启动，并在控制台中显示它正在运行的 URL（可能是 <a href="http://localhost:20000/">http://localhost:20000</a>）。如果我们向它发出请求，然后转到“时间轴”选项卡，我们将看到该请求已记录（实际上，在浏览器中执行该请求，然后可能会记录两个请求，因为会自动请求一个 favicon.ico）。可以扩展请求以查看如何处理请求中的时间。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://perl6advent.files.wordpress.com/2019/12/cro-app-1.png" alt="cro-app-2"/>
</div>
</div>
<div class="paragraph">
<p>Cro 可以并行处理对 HTTP 应用程序的请求。实际上，它既是并发的（由于使用了异步 I/O）又是并行的（请求处理的所有步骤都在 Raku 线程池上运行）。因此，如果我们使用 Apache Benchmark 程序一次发送 100 个请求，则希望发送 3 个，那么我们希望看到这样的指示，即最多可以并行处理 3 个请求。这是命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">ab -n 100 -c 3 http://localhost:20000/</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们确实看到了并行性：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://perl6advent.files.wordpress.com/2019/12/cro-app-2.png" alt="cro-app-2"/>
</div>
</div>
<div class="paragraph">
<p>同样，如果我们最多处理 10 个并发请求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">ab -n 100 -c 10 http://localhost:20000/</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们将看到以下内容：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://perl6advent.files.wordpress.com/2019/12/cro-app-3.png" alt="cro-app"/>
</div>
</div>
<div class="paragraph">
<p>再仔细一点，我们看到 “Process Request” 任务被记录为 Cro 模块的 HTTP Server 类别的一部分。但是，还不止这些：tasks（一段时间内发生的事情）也可以记录数据。例如，HTTP 请求方法和目标也被记录：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://perl6advent.files.wordpress.com/2019/12/data.png" alt="data"/>
</div>
</div>
<div class="paragraph">
<p>我们可能还会注意到，请求以交替的阴影显示。这是为了使我们能够区分两个任务，如果它们“背靠背”地发生而没有时间间隔（或者至少在我们的缩放级别上不可见）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_向应用程序添加_logtimeline_支持">71.2. 向应用程序添加 Log::Timeline 支持</h3>
<div class="paragraph">
<p>如果我们想将 Log::Timeline 支持添加到我们自己的应用程序中，那么我们可以更多地了解其行为，该怎么办？ 为了说明这一点，我们将其添加到 <a href="https://github.com/oposs/jsonhound">jsonHound</a> 中。这是一个查看 JSON 文件并确保它们符合一组规则的应用程序（它是为检查路由器配置的安全性而构建的，但原则上可以使用更多的规则）。</p>
</div>
<div class="paragraph">
<p>运行 jsonHound 时，有两个步骤：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>加载用 Raku 编写的规则</p>
</li>
<li>
<p>根据规则检查每个指定的 JSON 文件； 如果有多个文件，将并行检查它们</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们将为每个任务创建一个 Log::Timeline 任务。他们进入 JsonHound::LogTimelineSchema 模块。模块中的代码如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module JsonHound::Logging;

use Log::Timeline;

class LoadRules does Log::Timeline::Task[&#34;jsonHound&#34;, &#34;Run&#34;, &#34;Load Rules&#34;] {
}

class CheckFile does Log::Timeline::Task[&#34;jsonHound&#34;, &#34;Run&#34;, &#34;Check File&#34;] {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>首先，我们使用 Log::Timeline 模块。然后，我们为每个执行 Log::Timeline::Task 角色的任务创建一个类（还有一个 <strong>Event</strong> 角色，可用于记录在特定时间发生的事件）。</p>
</div>
<div class="paragraph">
<p>接下来，我们需要修改程序以使用它们。首先，在我们要添加日志记录的代码中，我们需要使用我们的任务模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use JsonHound::LogTimelineSchema;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们可以开始了。加载规则集如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $*JSON-HOUND-RULESET = JsonHound::RuleSet.new;
my $rule-file = $validations.IO;
CompUnit::RepositoryRegistry.use-repository:
        CompUnit::RepositoryRegistry.repository-for-spec(
                $rule-file.parent.absolute);
require &#34;$rule-file.basename()&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将其包装如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">JsonHound::Logging::LoadRules.log: {
    my $rule-file = $validations.IO;
    CompUnit::RepositoryRegistry.use-repository:
            CompUnit::RepositoryRegistry.repository-for-spec(
                    $rule-file.parent.absolute);
    require &#34;$rule-file.basename()&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们没有任何日志输出运行时，该块将照常执行。但是，如果要输出套接字，那么它将在该块的执行开始时和结束时通过套接字发送一条消息。</p>
</div>
<div class="paragraph">
<p>每个文件的分析如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.($reporter-object) for @json-files.race(:1batch).map: -&gt; $file {
    # Analysis code here
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>也就是说，我们获取 JSON 文件，然后并行映射它们。每个产生一个结果，然后我们与报告者调用。确切的细节无关紧要；我们真正需要做的就是将分析包含在我们的任务中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.($reporter-object) for @json-files.race(:1batch).map: -&gt; $file {
    JsonHound::Logging::CheckFile.log: {
        # Analysis code here
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>方便地，log 方法沿该块的返回值传递。</p>
</div>
<div class="paragraph">
<p>到目前为止，我们所做的一切都会奏效，但我们可以迈出更好的一步。如果我们查看日志输出，则可能会看到一个 JSON 输入文件，该文件需要花费很长时间来处理，但我们不知道它是哪个文件。我们可以通过选择命名数据，用我们选择的任何数据注释日志条目。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.($reporter-object) for @json-files.race(:1batch).map: -&gt; $file {
    JsonHound::Logging::CheckFile.log: :$file, {
        # Analysis code here
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>至此，我们已经准备好！ 在逗号中添加运行配置并使用时间线查看器运行它之后，我们得到如下图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://perl6advent.files.wordpress.com/2019/12/jsonhound.png" alt="jsonhound"/>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_未来_2">71.3. 未来</h3>
<div class="paragraph">
<p>尽管 Log::Timeline 已经可以提供一些有趣的见解，但仍有许多其他功能可以使用。当前正在进行的工作使用新的 MoarVM API 订阅 GC 事件并记录它们。这意味着可以可视化 GC 的运行时间以及花费的时间，并将其与正在发生的其他事件相关联。</p>
</div>
<div class="paragraph">
<p>我还想展示各种 Rakudo 级别的事件，这些事件可能会很有趣，可以在时间线上看到。例如，有可能提供有关锁定等待时间或等待时间或供应争用时间的信息。其他想法正在绘制文件或其他资源的打开和关闭时间，这反过来可能有助于发现资源泄漏。</p>
</div>
<div class="paragraph">
<p>当然，仅因为我们可以记录的范围很广，并不意味着它们都有用，并且记录本身也有开销。LogTimelineSchema 命名约定的使用期待进一步的功能：能够自省所有可用的事件和任务集。然后，在逗号中，我们将提供一个 UI 来选择它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="_最后">71.4. 最后…​</h3>
<div class="paragraph">
<p>在解决程序问题上，我们花费了不小的时间来找出程序运行时发生的情况。好的工具可以为了解程序的行为提供一个窗口，并且在某些情况下指出了我们甚至可能没有考虑的事情。Log::Timeline 是一个很小的模块，而可视化工具并没有花很长时间来实现。但是，在有用信息方面的回报使它成为我今年最有价值的东西之一。希望您也觉得它有用。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十九天_raku_中的函数式编程">72. 第十九天 - Raku 中的函数式编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我最近看了一个非常棒的视频，即 <a href="https://www.youtube.com/watch?v=0if71HOyVjY">40 分钟的《函数式编程》</a>，我认为那真的很好。这些年来，我已经完成了一些函数式编程，但是我知道很多人都觉得它背后的想法很混乱。</p>
</div>
<div class="paragraph">
<p>所以我要说的第一件事就是观看该视频，这真的很有帮助。</p>
</div>
<div class="paragraph">
<p>我会等你。</p>
</div>
<div class="paragraph">
<p>好了吗？好的，很酷，所以我确定你已经掌握了核心概念，函数式编程可以分为三大部分。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>纯函数</p>
</li>
<li>
<p>不可变数据结构</p>
</li>
<li>
<p>桥接系统</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>那么将这些想法引入 Raku 代码有多么容易？ 你会惊讶地知道&#34;真的&#34;将是该问题的答案吗？我认为不是，让我们依次浏览每个部分。</p>
</div>
<div class="sect2">
<h3 id="_纯函数">72.1. 纯函数</h3>
<div class="paragraph">
<p>因此，纯函数不会引起任何副作用。对于任何给定的输入，它总是提供相同的输出。Raku 包含一个 <a href="https://docs.raku.org/routine/is%20pure">is pure</a> 的 trait，你可以用它来标记代码块以表示它将返回相同的值，并且编译器可以以此为提示来用常量替换调用。通常，如果你使用标记纯函数，那么你也不会造成任何副作用（因为你的代码只能被调用一次）。</p>
</div>
<div class="paragraph">
<p>Raku 不仅有多种方法可以从命名的 <a href="https://docs.raku.org/syntax/sub">subs</a> <code>sub name($n) {&#34;Hello $n&#34;}</code> 到匿名 <code>sub ($n) {&#34;Hello $n&#34;}</code> 生成代码块，再到尖的代码块 <code>→ $n {&#34;Hello $n&#34;}</code>，最后只是普通块 <a href="https://docs.raku.org/syntax/block">blocks</a> <code>{&#34;Hello $_&#34;};</code> 所有这些都可以调用或分配给变量，并在其他子程序中使用。</p>
</div>
<div class="paragraph">
<p>Raku 还允许你使用一些更复杂的函数创建技术来进行函数组合和计算。虽然这些与视频无关，但它们很酷，所以我要讲题了。忍受我。</p>
</div>
</div>
<div class="sect2">
<h3 id="_函数组合">72.2. 函数组合</h3>
<div class="paragraph">
<p>函数组合使我们可以利用 f(g(x)) 对于 x 的给定值始终返回相同值的想法。因此，我们可以创建一个新的函数 h，其中 h(x) == f(g(x))。<a href="https://docs.raku.org/language/operators#index-entry-function_composition_operator">合成运算符</a>（∘或 o）允许使用定义 h，而不必正式包装函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;h = &amp;f ∘ &amp;g; # or my &amp;h = &amp;f o &amp;g;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在当你调用 h(x) 时，它和调用 f(g(x)) 是一样的。函数组合可以让你创建复杂的函数链，你可以很容易地传递给其他函数。</p>
</div>
</div>
<div class="sect2">
<h3 id="_柯里化">72.3. 柯里化</h3>
<div class="paragraph">
<p>柯里化函数是当你想使用一个函数并生成一个由部分调用原始函数组成的新函数时的…</p>
</div>
<div class="paragraph">
<p>好，让我们解释一下。可以说，我有一个 greeting 函数，它需要像这样的问候和名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub greeting( Str $greeting, Str $name ) {
    return &#34;$greeting $name!&#34;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>好。现在，我们想要一个仅使用名称的函数，问候语将设置为 “Hello”。我们可以做这样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub hello( Str $name ) {
    greeting( &#34;Hello&#34;, $name );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者可能创建一个闭包。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;hello = -&gt; $greeting {
    -&gt; $name {
        greeting($greeting, $name)
    }
}(&#34;Hello&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是 Raku 有一个内置的方法，该函数使用一个函数来 <a href="https://docs.raku.org/routine/assuming">assuming</a> 这一点，从而简化了这一过程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;hello = &amp;greeting.assuming(&#34;Hello&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>很好。但是，如果我们想假设一个更高的值呢？ 这是一个简单的不具名的提问者，我们可以利用像这样的任何星号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;greet-sam = &amp;greeting.assuming(*, &#34;Sam&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们可以调用 <code>greet-sam(&#34;Hi&#34;)</code> 并返回 &#34;Hi Sam!&#34;。</p>
</div>
<div class="paragraph">
<p>通过组合函数组成和柯里化，你可以从简单，易于测试的零件中创建复杂的功能。</p>
</div>
</div>
<div class="sect2">
<h3 id="_不可变数据结构">72.4. 不可变数据结构</h3>
<div class="paragraph">
<p>Raku 为我们提供了获取不可变数据的多种方法，包括 <a href="https://docs.raku.org/type/Map">Map</a>，<a href="https://docs.raku.org/type/List">List</a>，<a href="https://docs.raku.org/type/Set">Set</a>和 <a href="https://docs.raku.org/type/Bag">Bag</a>。你还可以将值绑定到变量或将其创建为未标记的变量或常量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $foo := 10;
my \foobar = 12;
constant bar = 11;</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样默认情况下，当你创建实例的 Point 类实例时，所有 Raku 对象都是不可变的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Point {
	has Num $.x;
	has Num $.y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以创建一个 Point 实例，并在创建时分配 x 和 y 值，但是一旦创建，就无法对其进行修改。当然，你可以使用 <a href="https://docs.raku.org/type/Attribute#index-entry-trait_is_rw_(Attribute)-trait_is_rw">is rw</a> 创建可变对象，但是如果你想进行函数式编程，那么就已经准备就绪。</p>
</div>
<div class="paragraph">
<p>同样，当你将参数传递给函数时，它们也不可变，除非你将它们特别标记为 <a href="https://docs.raku.org/type/Signature#index-entry-trait_is_rw">is rw</a> 或 <a href="https://docs.perl6.org/type/Signature#index-entry-trait_is_copy">is copy</a>。其中的第二个为你提供了一个新副本，你可以在函数内对其进行修改，而不会影响其原始版本。</p>
</div>
<div class="paragraph">
<p>因此，Raku 为我们提供了不可变数据所需的一切。</p>
</div>
</div>
<div class="sect2">
<h3 id="_桥接系统">72.5. 桥接系统</h3>
<div class="paragraph">
<p>因此，如果你想在代码的非功能部分之间来回传递信息，可以使用哪种桥接？有两个明显的答案，即用例 <a href="https://docs.perl6.org/type/Channel">Channels</a> 和 <a href="https://docs.perl6.org/type/Supply">Supplies</a> 略有不同。</p>
</div>
<div class="paragraph">
<p>当我们想对某事做出反应时，可以使用 Supplies。我建议当外部输入时，你希望功能系统对其进行处理。你可以设置一个反应块以获取传入的数据（或函数并将其传递到功能代码的代码中）。然后，在完成代码后，你可以将结果传递到一个 <a href="https://docs.perl6.org/type/Channel">Channel</a>，该 Channel 将数据反馈给外界。</p>
</div>
<div class="paragraph">
<p>通过将所有这些结合在一起，你可以访问纯功能语言的大多数功能，还可以使用强大的对象系统和并发性。世界上最好的。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十天_perl_到_raku_的代码转换">73. 第二十天 - perl 到 raku 的代码转换</h2>
<div class="sectionbody">
<div class="paragraph">
<p>剧透警报！</p>
</div>
<div class="paragraph">
<p>当我开始撰写这篇由两部分组成的文章时，我很高兴地没有意识到 Raku 社区中的类似话题。但是，当我于 12 月 9 日星期一第一次阅读 Elizabeth Mattijsen 的 <a href="https://rakudoweekly.blog/2019/12/09/2019-49-almost-starring/">Raku Weekly Blog</a> 时，我被这一事实惊醒，并看到著名的 Perl 和 Raku 专家 Jeff Goff 写了一个由多个部分组成的<a href="http://www.theperlfisher.com/index.php/2019/12/02/rewriting-legacy-code-for-raku-iii-the-sorceror/">系列</a>，内容涉及移植非常复杂的 Perl 模块，到 Raku。对我而言，唯一可以节省的地方是这些帖子都是技术性的，它的读者对象是认真的 Raku 黑客，他们希望为现有的最复杂的 Perl 模块生成本机 Raku 代码：强烈推荐有经验的程序员，他们喜欢反向编程，工程及其所有苦难！因此，我要向 Jeff 致意，继续在我那古老的 Perl 花园里漫步，那里充满了新手，自学成才的 Perl。</p>
</div>
<div class="paragraph">
<p>还有一点说明：Jeff 正在移植的模块的作者 <a href="https://metacpan.org/author/JMCNAMARA">John McNamara</a> 是我最喜欢的 Perl 模块的作者，他的出色模块使 Perl 用户可以将 Microsoft Excel 切片和切块，这对我来说是我的救星。这些年来，我与 John 进行了多次电子邮件讨论，他是一个善良而又很有才华的人，为 Perl 用户做出了巨大贡献。非常感谢，约翰！</p>
</div>
<div class="sect2">
<h3 id="_介绍_7">73.1. 介绍</h3>
<div class="paragraph">
<p>在本文中，我们将继续将旧的 Perl 代码移植到 Raku。为了遵循第 2 部分，您应该已经阅读了<a href="https://rakuadventcalendar.wordpress.com/2019/12/01/day-1-raku-from-perl/">第 1 部分</a>中的内容。确保从 Github 克隆了练习代码，因此您可以继续进行，因为许多实际的移植问题和解决方案在 N 阶段的每个分支中均以 git commits 的形式显示。</p>
</div>
<div class="paragraph">
<p>我们移植冒险的下一步是开始将 Perl 模块转换为 Raku。从 Perl 到 Raku 的过渡期间，我们将努力将每个 Perl 模块复制（移植）到 Raku。</p>
</div>
<div class="paragraph">
<p>在上一篇文章中，我们继续确保在将其所有 Perl 子例程移至 Perl 模块时，转换后的程序可以运行（不带参数）。现在，当我们移植 Perl 模块时，我们还将检查驱动程序的实际操作。我们希望在继续处理旧代码的过程中会发现更多挑战，所以让我们深入研究吧！</p>
</div>
</div>
<div class="sect2">
<h3 id="_阶段_2我们离开的地方">73.2. 阶段 2：我们离开的地方</h3>
<div class="paragraph">
<p>在第 1 部分的结尾，我说过我将对驱动程序进行另外一件事（manage-web-site.raku）：将 if/else 块替换为 when 块，所以我现在要做。请进入 2019 年的练习存储库目录，并确保您处于第二阶段的分支中，并且未提交任何更改。</p>
</div>
<div class="paragraph">
<p>为了使用 when 块，我们必须使用隐式主题变量($_)而不是 <code>$arg</code> 变量。但是，此刻我们仍然需要它，因此我们将其从循环变量中删除，并在块的顶部临时声明它（请参见注释 1）：<code>my $ arg = $_</code>。现在，让我们再次执行程序，这次使用 <code>-h</code>（帮助）选项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ ./manage-web-site.raku -h
Use of uninitialized value of type Any in numeric context
  in block  at ./manage-web-site.raku line 184
Use of uninitialized value of type Any in numeric context
  in block  at ./manage-web-site.raku line 185
Use of uninitialized value of type Any in numeric context
  in block  at ./manage-web-site.raku line 186
No such method &#39;Int&#39; for invocant of type &#39;Any&#39;
  in block  at ./manage-web-site.raku line 186</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下是违规行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># lines 181-187:
my $arg = $_;                    # &lt;= new decl of $arg, set to topic variable&#39;s value
my $val;
my $idx = index $arg, &#39;=&#39;;       # = 0) {                 # &lt;= this is where the problem first surfaces
    $val = substr $arg, $idx+1;  # &lt;= and then here
    $arg = substr $arg, 0, $idx; # &lt;= and here
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>发生的事情是 Perl 和 Raku 之间的另一种语法变化浮出水面：如果找不到该指针，Perl 中的索引例程将返回 “-1”，但是在 Raku 中它返回未定义，因此我们现有的 Perl 整数测试会引发错误。解决方案是测试返回值的定义性。像在 Perl 中一样，我们不能仅使用 if 来测试零，因为这是一个有效值，但事实并非如此。因此，我们将代码更改为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># lines 184-187:
if $idx.defined {                # &lt;= this is the only change needed
    $val = substr $arg, $idx+1;
    $arg = substr $arg, 0, $idx;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>经过几次清理后，我们准备开始移植模块。确保您的 git repo 在分支 <code>stage-2&gt;</code> 上，并且没有任何未提交的更改就干净了。然后执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ git checkout -b stage-3</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_porting_a_perl_module">73.3. Porting a Perl module</h3>
<div class="paragraph">
<p>首先，让我们看一下我们将遇到的一些常见问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将 Perl 的导出方法转换为 Raku 更简单的语法</p>
</li>
<li>
<p>将 Perl 样式的调用转换为 Raku 的函数签名</p>
</li>
<li>
<p>将 Perl 的 foreach 循环转换为 Raku 的 <code>@arr → {</code> 循环</p>
</li>
<li>
<p>将 Perl 的 <code>for (my $i …​) {…​}</code> 循环转换为 Raku 的 <code>loop (…​) {…​}</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>肯定会有更多问题，而且我敢肯定，我所做的更改可能不是对现代 Perl 更为了解的人可能做出的更改，但请记住，我的许多老 Perl 都早于现代 Perl，而我并不总是 是时候改进代码了，但是只是在可行的解决方案上获得了初步的收获。</p>
</div>
<div class="paragraph">
<p>在介绍旧的 Perl 之前，我们将介绍处理导出和签名的工作示例。以下 Perl 模块（P5.pm）使用 Damian Conway 的 Perl6::Export::Attrs 模块，以简化和类似 Raku 的导出处理。注意参数传递的三种类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">package P5;

use feature &#39;say&#39;;
use strict;
use warnings;

# This module does NOT affect exporting to Raku, it only affects
# exporting to Perl programs. See program `usep5.pl` for examples.
use Perl6::Export::Attrs; # [from CPAN] by Damian Conway

our $VERSION = &#39;1.00&#39;;

# Always exported:
# sub passing all args via @_ array:
sub sayAB :Export(:MANDATORY) {
    my $a = shift;
    my $b = shift;
    $b = 0 if !defined $b;
    say &#34;\$a = &#39;$a&#39;; \$b = &#39;$b&#39;&#34;;
}

# Export sayABC when explicitly requested or when the &#39;:ALL&#39; export is set
# sub passing args via a hash:
sub sayABC :Export(:sayABC) {
    my $href = shift;
    my $a = $href-&gt;{a};
    my $b = $href-&gt;{b};
    my $c = $href-&gt;{c};
    $a = 0 if !defined $a;
    $b = 0 if !defined $b;
    $c = 0 if !defined $c;
    say &#34;\$a = &#39;$a&#39;; \$b = &#39;$b&#39;; \$c = &#39;$c&#39;&#34;;
}

# Always exported:
# sub pass rw args via a ref
sub changeC :Export(:MANDATORY) {
    my $cref = shift;
    my $newc = shift;
    $${cref} = $newc;
}

1; # mandatory true value</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下 Perl 程序（usep5.pl）显示了如何使用三种类型的参数传递。它还显示了如何使用限制导出的 <code>sub (sayABC)</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">use feature &#39;say&#39;;
use strict;
use warnings;

use lib qw(.);
use P5 qw(:sayABC);

sayAB(1);             # using the @_ for passing arguments
sayABC({a=&gt;1, b=&gt;2}); # using a hash for passing arguments

my $c = 1;
say &#34;\$c = $c&#34;;
changeC(\$c, 2); # using a reference to pass a read/write variable
say &#34;\$c = $c&#34;;
We exercise the Perl script:

$ ./usep5.pl
$a = &#39;1&#39;; $b = &#39;0&#39;
$a = &#39;1&#39;; $b = &#39;2&#39;; $c = &#39;0&#39;
$c = 1
$c = 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们看到 Perl 脚本和模块的 Raku 版本演示了获得相同输出结果所需的更改（但请参见注释 2）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module P6;

#| Always exported:
#| ported from a Perl sub passing all args via @_ array:
sub sayAB($a, $b = 0) is export {
    say &#34;\$a = &#39;$a&#39;; \$b = &#39;$b&#39;&#34;;
}

#| Export &amp;sayABC when explicitly requested or when the &#39;:ALL&#39; export is set
#| ported from a Perl sub passing args via a hash:
sub sayABC(:$a, :$b, :$c = 0) is export(:sayABC) {
    say &#34;\$a = &#39;$a&#39;; \$b = &#39;$b&#39;; \$c = &#39;$c&#39;&#34;;
}

#| Always exported:
#| ported from a Perl sub passing a read/write arg:
sub changeC($c is rw, $newc) is export {
    $c = $newc;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use lib ;
use P6 :ALL; #= &lt;= ensures all exportable object are exported

sayAB 1;
sayABC :b, :a;

my $c = 1;
say &#34;\$c = $c&#34;;
changeC $c, 2;
say &#34;\$c = $c&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行 Raku 脚本应该会显示同样的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ ./usep6.raku
$a = &#39;1&#39;; $b = &#39;0&#39;
$a = &#39;1&#39;; $b = &#39;2&#39;; $c = &#39;0&#39;
$c = 1
$c = 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>瞧！希望您可以看到 Raku 模块的版本比 Perl 的更干净，更简单。</p>
</div>
<div class="paragraph">
<p>为了引导我们进入要移植的第一个模块，我们将在驱动程序中执行 main 选项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ ./manage-web-site.raku -gen

Collecting names by CS...
Unable to open file &#39;usafa-template1-letter.ps&#39;: No such file or directory
  in method call-args at /usr/local/rakudo.d/share/perl6/site/sources/ACCE801FB16076DAD1F96BE316DBFEDD148902C8 (Inline::Perl5) line 430
  in sub  at /usr/local/rakudo.d/share/perl6/site/sources/ACCE801FB16076DAD1F96BE316DBFEDD148902C8 (Inline::Perl5) line 935
  in block  at ./manage-web-site.raku line 449</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们看一下显然引起故障的行（449），我们将看到以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">build_montage(%CL::mates, $genS); #=  &lt;= in module ./PicFuncs.pm5</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且我们看到模块 PicFuncs.pm5 是入口点。因此，我们将选择该模块开始并将其复制到 PicFuncs.pm6。我们在最喜欢的编辑器中打开新文件，然后看到我们可以立即进行一些更改（从第一行开始）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将 package 更改为 unit 模块</p>
</li>
<li>
<p>删除下一个文件代码行</p>
</li>
<li>
<p>将所有 sub 行更改为：Export(:DEFAULT) is export</p>
</li>
<li>
<p>将 sub build_montage 移动到模块顶部，以方便一次移植一个 sub</p>
</li>
<li>
<p>删除 Perl 代码以在文件底部获得真正的返回</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在让我们看一下我们注意到的其他一些事情：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>该模块正在使用 Perl 格式的 G.pm，因此我们将不得不下一次转换它，或者更改我们在 PicFuncs.pm6 模块中使用它的方式。我选择将 G.pm 模块转换为 G.pm6</p>
</li>
<li>
<p>为了减轻 port，我们想使用 <code>=finish</code> pod 功能在第一个 sub 之后结束 PicFuncs.pm6 模块</p>
</li>
<li>
<p>我们必须更改在 manage-web-site.raku 文件中使用 PicFuncs 模块的方式</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可能会猜到不久，如果不将其余的 Perl 模块转换为 Raku，我们将无法走得更远。但是，趋向于上面的列表…​</p>
</div>
<div class="paragraph">
<p>为了检查进度，我们再次执行驱动程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ ./manage-web-site.raku -gen
SORRY!=== Error while compiling PicFuncs.pm (PicFuncs)
This appears to be Perl 5 code. If you intended it to be Perl 6 code, please use a Perl 6 style declaration like &#34;unit package Foo;&#34; or &#34;unit module Foo;&#34;, or use the block form instead of the semicolon form.
at PicFuncs.pm (PicFuncs):1
------&gt; package PicFuncs;⏏</code></pre>
</div>
</div>
<div class="paragraph">
<p>哇，看起来我们需要尝试将两种类型的模块分开，因为名称使 Raku 感到困惑。我将首先尝试在驱动程序中重新排列一些代码。</p>
</div>
<div class="sect3">
<h4 id="_use_语句和模块搜索">73.3.1. use 语句和模块搜索</h4>
<div class="paragraph">
<p>请注意，Perl 和 Raku 处理 usestatement 的方式有所不同。在 Perl 中，按照以下顺序在模块中搜索模块：在 <code>use lib</code> 语句中定义的路径，在环境变量 PERL5LIB 和 PERLLIB 中定义的路径（按该顺序），最后在 <code>@INC</code> 数组中定义的路径中。在任何路径列表中，单个路径都用冒号（&#39;:&#39;）分隔，这与操作系统路径分隔符一致。</p>
</div>
<div class="paragraph">
<p>Raku 与众不同。首先，我们不能在模块中使用 use 语句，因为它将在使用前进行预编译，并且无法对 use 语句进行预编译。其次，Raku 使用按以下顺序搜索的路径：在 use lib 语句中定义的路径，在环境变量 PERL6LIB 中定义的路径以及在 Raku 安装期间定义的路径。在任何路径列表中，单个路径都用逗号分隔，与 Raku 中的列表一致。这是此测试环境在我的计算机上的搜索路径（PERL6LIB = foo,bar）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ perl6 -e &#39;use lib ; use MyModule&#39;
===SORRY!===
Could not find MyModule at line 1 in:
    file#/home/tbrowde/raku-advent/raku-advent-2019
    file#/home/tbrowde/raku-advent/raku-advent-2019/foo
    file#/home/tbrowde/raku-advent/raku-advent-2019/bar
    inst#/home/tbrowde/.perl6
    inst#/usr/local/rakudo.d/share/perl6/site
    inst#/usr/local/rakudo.d/share/perl6/vendor
    inst#/usr/local/rakudo.d/share/perl6
    ap#
    nqp#
    perl5#</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_resume_porting">73.3.2. Resume porting…</h4>
<div class="paragraph">
<p>现在再试一次:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ ./manage-web-site.raku -gen
===SORRY!===
Unsupported use of &#39;foreach&#39;; in Perl 6 please use &#39;for&#39;
at PicFuncs.pm6 (PicFuncs):48
  foreach⏏ my $cs (@cs) {
Other potential difficulties:
    To pass an array, hash or sub to a function in Perl 6, just pass it as is.
    For other uses of Perl 5&#39;s ref operator consider binding with +++::=+++ instead.
    Parenthesize as \(...) if you intended a capture of a single variable.
    at PicFuncs.pm6 (PicFuncs):23
    U65::get_keys_by_sqdn(\⏏%sqdn, $mref);</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，我们首先看到 Perl 和 Raku 之间的某些循环差异。我将从更改循环开始。关于 Perl 的警告，原因是 <code>for (my $i = 0; $i &lt; $max; $i) {...}`。直接翻译为 Raku 的方法是：`loop (my $i = 0; $i &lt; $max; $i) {…​}</code>，但其中有一个惊喜。循环索引变量（在 Perl 中的循环范围内）在 Raku 中的循环括号的外部范围内！因此，我养成了重写 Perl 循环的习惯，以强调索引变量的适当范围以及更好的指针来指示重复声明的可能问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $i;
loop (my $i = 0; $i &lt; $max; ++$i) {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们再次从执行测试开始……哎呀，另一个语法问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ ./manage-web-site.raku -gen
===SORRY!===
Unsupported use of @{$sqdn{$cs}; in Perl 6 please use @($sqdn{$cs) for hard ref or @::($sqdn{$cs) for symbolic ref
at PicFuncs.pm6 (PicFuncs):55
my @n = @{$sqdn{$cs}⏏};
Other potential difficulties:
    To pass an array, hash or sub to a function in Perl 6, just pass it as is.
    For other uses of Perl 5&#39;s ref operator consider binding with ::= instead.
    Parenthesize as \(...) if you intended a capture of a single variable.
    at PicFuncs.pm6 (PicFuncs):23
    U65::get_keys_by_sqdn(\⏏%sqdn, $mref);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Perl 数组和散列与 Raku 的散列之间存在巨大差异。我也倾向于这些……另一个问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ ./manage-web-site.raku -gen
===SORRY!=== Error while compiling PicFuncs.pm6 (PicFuncs)
Unsupported use of -&gt;(), -&gt;{} or -&gt;[] as postfix dereferencer; in Perl 6 please use .(), .[] or .{} to deref, or whitespace to delimit a pointy block
at PicFuncs.pm6 (PicFuncs):137
------&gt; 	        my $fname = $mref-&gt;{⏏$c}{file};</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个问题来自于签名和将参数传递给调用方的子对象的差异，如前面在简单示例中所讨论的。我将仔细研究签名，看看我们是否可以帮忙。我首先要看一下之前看过的驱动程序中的调用路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">build_montage(%CL::mates, $genS);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们看到两个参数：哈希和表观标量。我们使用参考将第 1 部分中的内容从其原始 Perl 语法更改为 Raku。因此，我们目前在主叫方很好。返回到被叫子，其中前几行如下所示（注释被删除）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub build_montage is export {
    my $mref  = shift @_; # \%CL::mates
    my $cs    = shift @_;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将其更改为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub build_montage(%mates, $cs) is export {</code></pre>
</div>
</div>
<div class="paragraph">
<p>并进行其他必要的更改…​经过大量更改之后，我们开始遇到缺少的例程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ ./manage-web-site.raku -gen
===SORRY!=== Error while compiling PicFuncs.pm6 (PicFuncs)
Undeclared routines:
    convert_single_pic_to_eps used at line 159
    insert_logo used at lines 287, 297
    insert_pictures used at line 279</code></pre>
</div>
</div>
<div class="paragraph">
<p>这看起来像是个不错的停留地点。就像我之前说的，我们可能需要转换几乎整个项目，或者至少转换驱动脚本使用的那些模块以及它们使用的所有其他模块。我检查了第 4 阶段的分支，并做了更多的内务处理和整理工作，但我又将移植的工作留给了另一天。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_6">73.4. 总结</h3>
<div class="paragraph">
<p>在这两篇文章中，您已经看到了一种简化将 Perl 代码移植到 Raku 的方法，并且我希望它们可以帮助那些考虑迁移到 Raku 的人看到可以以较小的步骤迭代地完成它，而不用花费大量的时间。对我而言，结果包括以下代码：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>更具视觉吸引力（更清洁，更整洁）</p>
</li>
<li>
<p>易于维护</p>
</li>
<li>
<p>更容易看到需要改进的地方</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您有兴趣查看其余的转换，请在 IRC 频道 #raku 上执行.ask tbrowder，然后我将继续插入我们一直在使用的存储库（它也将对我有所帮助！）。快乐乐天</p>
</div>
<div class="paragraph">
<p>我❤️❤️Raku！ 😊</p>
</div>
<div class="paragraph">
<p>Christmas 圣诞快乐🎅和🎅新年快乐🎉所有人，并可能✝“上帝保佑我们，每一个人！”✝[Ref。1]</p>
</div>
</div>
<div class="sect2">
<h3 id="_附录_3">73.5. 附录</h3>
<div class="sect3">
<h4 id="_笔记_2">73.5.1. 笔记</h4>
<div class="ulist">
<ul>
<li>
<p>我不确定在循环中更改 topic 变量的值是否会使 when 块继续按预期工作。幸运的是。</p>
</li>
<li>
<p>在 Raku 中使用各种模块导出选项时，存在一些细微的（对我而言）问题。此处文档中的当前讨论（请参阅五个 Notes 的有序列表）并未详尽地描述导出选项的所有可能组合，因此，当我（使用这些注释的人）写信时，我看到一条错误消息我认为这些新的条件组合具有误导性。因此，我首先怀疑是 Rakudo 错误，但现在怀疑它是 LTA（少于真棒）错误消息。请密切关注 Rakudo 问题＃3341，以寻求解决方案。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_参考文献_2">73.5.2. 参考文献</h4>
<div class="paragraph">
<p>圣诞颂歌，查尔斯·狄更斯（1812-1870）的短篇小说，查尔斯·狄更斯（Charles Dickens）（1812-1870 年），维多利亚州著名作家，作品很多，包括 Pickwick Papers，Oliver Twist，David Copperfield，Bleak House，Great Expectations 和两个城市的故事。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十一天_搜索红色礼物">74. 第二十一天 - 搜索红色礼物</h2>
<div class="sectionbody">
<div class="paragraph">
<p>精灵雪花石膏雪花球正在寻找礼物，招募给他在北极的秘密圣诞老人上绘制的人。 他很荣幸能画圣诞老人！ 给每个人都送礼物的人该怎么办？ 因此，他在互联网上搜索一些他知道圣诞老人想要的关键字：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>自动信件阅读器</p>
</li>
<li>
<p>耐穿靴子</p>
</li>
<li>
<p>红色雪橇配件</p>
</li>
<li>
<p>不会在风中飞扬的红色帽子</p>
</li>
<li>
<p>红色外套</p>
</li>
<li>
<p>红色</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>等一下！<a href="https://github.com/FCO/Red">Red</a> 会有：api&lt;2&gt; 吗？雪花石膏雪球已经阅读了有关 Raku 的 ORM。 但是，似乎新的：api&lt;2&gt; 版本将其带入了一个新的高度。</p>
</div>
<div class="paragraph">
<p>而已！ 我将给圣诞老人一个 <a href="https://github.com/FCO/Red">Red</a>:api&lt;2&gt; PoC 作为礼物！ 我知道他一直在与 Raku 一起玩，并且我认为将 NiceList 模型上所有 SQL 字符串集合更改为一组精心制作的 ORM 类会很棒。</p>
</div>
<div class="paragraph">
<p>在阅读<a href="https://fco.github.io/Red/">文档</a>时，Snowball 得知创建第一个模型非常容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Red:api&lt;2&gt;;

unit model Child;

has UInt $!id              is id;
has Str  $.name            is column;
has Str  $.country         is column;</code></pre>
</div>
</div>
<div class="paragraph">
<p>他开始使用 <a href="https://github.com/FCO/Red">Red</a>:api&lt;2&gt; 并创建一个新模型，该模型代表具有 3 列（ID，名称和国家/地区）的表子级。 就这么简单。</p>
</div>
<div class="paragraph">
<p>Alabaster 现在可以仅连接到数据库，创建表，然后开始插入子代：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Red:api&lt;2&gt;;
red-defaults default =&gt; database &#34;SQLite&#34;;

Child.^create-table: :unless-exists;

Child.^create: :name&lt;Fernanda&gt;, :country&lt;England&gt; ;
Child.^create: :name&lt;Sophia&gt;,   :country&lt;England&gt; ;
Child.^create: :name&lt;Dudu&gt;,     :country&lt;Scotland&gt;;
Child.^create: :name&lt;Rafinha&gt;,  :country&lt;Scotland&gt;;
Child.^create: :name&lt;Maricota&gt;, :country&lt;Brazil&gt;  ;
Child.^create: :name&lt;Lulu&gt;,     :country&lt;Brazil&gt;  ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>并列出所有创建的孩子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for Child.^all.sort: *.name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样就可以运行这个查询:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT
   child.id, child.name, child.country
FROM
   child
ORDER BY
   child.name</code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Child.new(name =&gt; &#34;Dudu&#34;, country =&gt; &#34;Scotland&#34;)
Child.new(name =&gt; &#34;Fernanda&#34;, country =&gt; &#34;England&#34;)
Child.new(name =&gt; &#34;Lulu&#34;, country =&gt; &#34;Brazil&#34;)
Child.new(name =&gt; &#34;Maricota&#34;, country =&gt; &#34;Brazil&#34;)
Child.new(name =&gt; &#34;Rafinha&#34;, country =&gt; &#34;Scotland&#34;)
Child.new(name =&gt; &#34;Sophia&#34;, country =&gt; &#34;England&#34;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要的话，圣诞老人可以按国家对孩子进行分类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %by-country := Child.^all.classify: *.country;</code></pre>
</div>
</div>
<div class="paragraph">
<p>并发现哪些国家有儿童登记。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %by-country.keys;</code></pre>
</div>
</div>
<div class="paragraph">
<p>那会运行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT
   DISTINCT(child.country) as &#34;data_1&#34;
FROM
   child
And that would return:

(England Scotland Brazil)
If he needs to get all children from England:

.say for %by-country&lt;England&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会运行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT
   child.id, child.name, child.country
FROM
   child
WHERE
   child.country = ?

-- BIND: [&#34;England&#34;]</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会返回:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Child.new(name =&gt; &#34;Fernanda&#34;, country =&gt; &#34;England&#34;)
Child.new(name =&gt; &#34;Sophia&#34;, country =&gt; &#34;England&#34;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>很好用! 那如何存储礼物呢？有没有办法把孩子要求的东西按年份储存起来？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Gift.pm6
use Red:api&lt;2&gt;;

unit model Gift;

has UInt $!id            is serial;
has Str  $.name          is column{ :unique };

has      @.asked-by-year is relationship( *.gift-id, :model&lt;ChildAskedOnYear&gt; );

method child-asked-on-year(UInt $year = Date.today.year) {
    @!asked-by-year.grep(*.year == $year)
}

method asked-by(UInt $year) {
    self.child-asked-on-year(|($_ with $year)).map: *.child
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Child.pm6
use Red:api&lt;2&gt;;

unit model Child;

has UInt $!id              is id;
has Str  $.name            is column;
has Str  $.country         is column;

has      @.asked-by-year   is relationship( *.child-id, :model&lt;ChildAskedOnYear&gt; );

method asked(UInt $year = Date.today.year) {
    @!asked-by-year.grep: *.year == $year
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># ChildAskedOnYear.pm6
use Red:api&lt;2&gt;;

unit model ChildAskedOnYear;

has UInt $!id       is serial;
has UInt $.year     is column = Date.today.year;
has UInt $!child-id is referencing(*.id, :model&lt;Child&gt;);
has UInt $!gift-id  is referencing(*.id, :model&lt;Gift&gt;);

has      $.child    is relationship( *.child-id, :model&lt;Child&gt; );
has      $.gift     is relationship( *.gift-id,  :model&lt;Gift&gt;  );</code></pre>
</div>
</div>
<div class="paragraph">
<p>雪花石膏雪花球认为，他可以获得所需的所有信息。 创建新礼物很容易！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;doll ball car pokemon&gt; -&gt; $name {
    Gift.^create: :$name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>搜索怎么样？ 雪花石膏雪球写道：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for Gift.^all</code></pre>
</div>
</div>
<div class="paragraph">
<p>并返回所有礼物。 但是，如果我们只想要以“ll”结尾的礼物怎么办？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for Gift.^all.grep: *.name.ends-with: &#34;ll&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将运行如下查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT
   gift.id, gift.name
FROM
   gift
WHERE
   gift.name like &#39;%ll&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Snowball 想知道是否有可能找到孩子的要求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for Child.^find(:name&lt;Fernanda&gt;).asked.map: *.gift</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT
   child_asked_on_year_gift.id, child_asked_on_year_gift.name
FROM
   child_asked_on_year
    LEFT JOIN gift as child_asked_on_year_gift ON child_asked_on_year.gift_id = child_asked_on_year_gift.id
WHERE
   child_asked_on_year.child_id = ? AND child_asked_on_year.year = 2019</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们想知道去年的礼物怎么办？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for Child.^find(:name&lt;Fernanda&gt;).asked(2018).map: *.gift</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT
   child_asked_on_year_gift.id, child_asked_on_year_gift.name
FROM
   child_asked_on_year
    LEFT JOIN gift as child_asked_on_year_gift ON child_asked_on_year.gift_id = child_asked_on_year_gift.id
WHERE
   child_asked_on_year.child_id = ? AND child_asked_on_year.year = &#39;2018&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们如何知道每个礼物应制作多少？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ChildAskedOnYear.^all.map(*.gift.name).Bag</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">SELECT
   child_asked_on_year_gift.name as &#34;data_1&#34;, COUNT(&#39;*&#39;) as &#34;data_2&#34;
FROM
   child_asked_on_year
    LEFT JOIN gift as child_asked_on_year_gift ON child_asked_on_year.gift_id = child_asked_on_year_gift.id
GROUP BY
   child_asked_on_year_gift.name</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/FCO/Red">Red</a> 的文档位于 <a href="https://fco.github.io/Red/">https://fco.github.io/Red/</a> 上，此处使用的一些示例可以在 <a href="https://github.com/FCO/Red/blob/join/examples/xmas/index.p6">https://github.com/FCO/Red/blob/join/examples/xmas/index.p6</a> 上找到。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十二天_当然是课程">75. 第二十二天 - 当然是课程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您可能没有听说过我的 Perl 6 课程，也不会怪我。</p>
</div>
<div class="paragraph">
<p>这是一段漫长的旅程。</p>
</div>
<div class="paragraph">
<p>它始于 2018 年 9 月，我在<a href="https://oslo.pm/npw2018/">奥斯陆的北欧 Perl 研讨会</a>上以 <a href="https://npw2018.perl6.eu/">45 + 45 分钟的时间介绍了 Perl 6</a>。第一次在会议上进行演讲…</p>
</div>
<div class="paragraph">
<p>我得到了积极的反馈，并且想知道是否可以在此基础上发展。全面课程的想法已经成熟，我首先开始编写随附的教科书。</p>
</div>
<div class="paragraph">
<p>这本书和课程旨在作为 Raku 的入门指南，供已经熟悉编程的人使用。</p>
</div>
<div class="paragraph">
<p>我向里加的 <a href="https://perlcon.eu/">PerlCon 2019</a> 推荐了课程，他们接受了。组织者要求我推广它，结果是我的 Perl 6 博客 <a href="https://perl6.eu/">Perl 6 Musings</a>（在绝对完美的地址 &#34;perl6.eu&#34; 上）。</p>
</div>
<div class="paragraph">
<p>不幸的是，这没有解决，并且由于参加人数太少而取消了该课程。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://camo.githubusercontent.com/416a56495fb3cec0f47df55849de9bff04aab08a/68747470733a2f2f72616b752d6d7573696e67732e636f6d2f696d672f426567696e6e696e672d736d616c6c2e706e67" alt="raku"/>
</div>
</div>
<div class="paragraph">
<p>Beginning Raku, 1. Edition (December 2019)
Pages: 370
File size: ~ 11 Mbyte (pdf)</p>
</div>
<div class="paragraph">
<p><a href="https://arnesom.github.io/Beginning-v1.00.pdf">arnesom.github.io/Beginning-v1.00.pdf</a></p>
</div>
<div class="paragraph">
<p>我免费赠送这本书的第一版。我保留印刷和出售书籍的权利。您可以自由分发 pdf 文件或进行打印。您也可以自由分发印刷版，但可能不会因此获得报酬。</p>
</div>
<div class="paragraph">
<p>随意使用代码示例，无论它们是您自己的作品，还是您自己工作的灵感。可以很好地添加属性，但这不是必需的。</p>
</div>
<div class="paragraph">
<p>我会很感激您的反馈，请在<a href="https://github.com/arnesom/arnesom.github.io">此书的 Github 页面</a>上发送，或通过电子邮件发送至该书中显示的地址。如果收到需要更新的反馈，我打算出版该书的修订版。</p>
</div>
<div class="sect2">
<h3 id="_未完待续">75.1. 未完待续</h3>
<div class="paragraph">
<p>下一门课程《高级 Raku》继续到此结束。由于本书仅供参考，我选择为这两个课程制作一本名为《 Raku Explained》的组合书。下半部分（&#34;高级 Raku&#34; 部分）尚未完成，但是我已经发布了初步的目录和索引，以便您可以看到整本书的内容。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://camo.githubusercontent.com/c46ee0b138289d9fe1f04e734cc87809383f68ca/68747470733a2f2f72616b752d6d7573696e67732e636f6d2f696d672f4578706c61696e65642d736d616c6c2e706e67" alt="Raku Explained"/>
</div>
</div>
<div class="paragraph">
<p>Raku Explained, v0.01 (December 2019)
Pages: 30 (Table of Contents &amp; Index only)
File size: ~ 5 Mbyte (pdf)</p>
</div>
<div class="paragraph">
<p><a href="https://arnesom.github.io/Explained-v0.01.pdf">arnesom.github.io/Explained-v0.01.pdf</a></p>
</div>
<div class="paragraph">
<p>我也对第二部分中的主题反馈感兴趣（第 18 – 32 章）。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第二十三天_a_raku_advent_helper">76. 第二十三天 – A Raku Advent Helper</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_介紹">76.1. 介紹</h3>
<div class="paragraph">
<p>从 2016 年开始，我每年都会写 Raku Advent 的文章，要想把源文件可靠地转化到 Raku Advent WordPress (WP) 网站上，不被 WP 改掉一些东西，对我来说一直是个难题。然后，菜单很糟糕，编辑也很麻烦。在这篇文章中，我希望展示如何改善这种情况。</p>
</div>
</div>
<div class="sect2">
<h3 id="_背景介绍">76.2. 背景介绍</h3>
<div class="paragraph">
<p>不幸的是，今年 Raku 的大改名发生在年底，没有太多的时间来准备一个新的 Raku Advent 网站。因此，主题的选择和调整，对实际 Raku Advent 网站链接的混乱，以及不幸的文章取消，都是通常比较顺利的过程中的皱纹。然而，我们计划在 2020 年降临季之前改进网站，也会更早地得到承诺，更早地得到具体的草案。同时，在这篇匆匆准备的替身文章中，我会详细介绍一下我们希望提供的一些帮助。</p>
</div>
</div>
<div class="sect2">
<h3 id="_文章创作">76.3. 文章创作</h3>
<div class="paragraph">
<p>从第一次使用 WordPress 开始，我就发现了这些让我在使用 WP 时很尴尬的地方。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>编辑窗口太小</p>
</li>
<li>
<p>编辑时明显的滞后时间，增加了手指的失误。</p>
</li>
<li>
<p>在网站时区(TZ)中输入所需的时间表时间，但看到它显示在你的本地 TZ 中(很少或没有提示你看到的是什么)[见注 1]。</p>
</li>
<li>
<p>混乱的编辑上下文和小组件的位置</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我相信我对 WP 的大部分问题都是自己造成的，但我确实更喜欢更像 TeX 的文档制作工作流程。</p>
</div>
</div>
<div class="sect2">
<h3 id="_前几年">76.4. 前几年</h3>
<div class="paragraph">
<p>往年我都是用 Gihub 风格的 markdown 创建文章，手动（在我的 Emacs 编辑器的协助下）将每段文字转换为单行、长行，然后发布在 Github 的 gist 中。之后，我使用由 @zoffix[注 2]开发并由 @SimonProctor 修改的工具 <a href="https://github.com/Raku/advent/blob/master/tools/p6advent-md2html.p6">p6advent-md2html.p6</a>，从 Github 的 markdown 表示中提取 html，从而得到一个很好的代码块高亮。最后，将该 html 复制并粘贴到 WP 中，并设置好发布计划。这个原始过程在这里有概述。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用 Github 喜欢的 Markdown 文本写文章</p>
</li>
<li>
<p>将每个段落折叠成一个长行</p>
</li>
<li>
<p>将源码粘贴到 Github 的 gist 中。</p>
</li>
<li>
<p>使用现有的 Advent 工具将生成的 html 表示提取到自己的本地计算机上。</p>
</li>
<li>
<p>复制 html 并粘贴到所选 WP 编辑器的空白 html 视图中。</p>
</li>
<li>
<p>查看成品并检查错误</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果发现错误:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 WP 编辑器中改正错误</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>或</p>
</div>
<div class="ulist">
<ul>
<li>
<p>纠正源头的错误</p>
</li>
<li>
<p>再次重复步骤 2 至 6</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个过程在第一次通过的时候还算不错，但是当不可避免的发现错误的时候，就只能选择在 WP 上手动编辑，或者修改源码，再走一遍整个过程! 这两种选择都不是很好。</p>
</div>
</div>
<div class="sect2">
<h3 id="_2019_年的降临目标减少_wp_的痛苦">76.5. 2019 年的降临目标：减少 WP 的痛苦</h3>
<div class="paragraph">
<p>今年我决定帮助我的文章创作情况，所以我创建了一个 Raku 工具来消除一些问题。从今天起，它就可以对外开放了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ zef install RakuAdvent::WordPress</code></pre>
</div>
</div>
<div class="paragraph">
<p>该模块提供了 <code>make-wp-input</code> 这个工具。所以我今年的新步骤:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用原始 html 写文章</p>
</li>
<li>
<p>运行我的新 Advent 工具(<code>make-wp-input</code>)，将源码格式化为可接受的 html。</p>
</li>
<li>
<p>复制 html 并粘贴到所选 WP 编辑器的空白 html 视图中。</p>
</li>
<li>
<p>查看成品并检查和纠正错误。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果发现错误:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 WP 编辑器中改正错误</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>或者，最好是:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>纠正源头的错误</p>
</li>
<li>
<p>再次重复步骤 2 至 4</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，在我的新流程中，我已经省去了几个步骤，但我仍然必须将我干净的 WP 源码复制/粘贴到 WordPress 编辑器中-但这是因为我没有利用 WordPress 和 Github 的可用 API 来做这些繁琐的工作。</p>
</div>
<div class="paragraph">
<p>然而，尽管有其他的限制，这个新的工具在简化文章中使用实时代码示例方面起到了巨大的帮助。在我写文章的沙盒中，我在自己的文件中创建代码示例，然后在文章中加入</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;!-- insert file-name lang --&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>行在需要的位置。这样一来，我就可以编辑实战代码，并进行测试，以确保它的工作，但不必使用该代码更改源码。</p>
</div>
</div>
<div class="sect2">
<h3 id="_给_raku_作者的提示">76.6. 给 Raku 作者的提示</h3>
<div class="paragraph">
<p>以下是我在为 Raku Advent 开发文章时发现的一些有用的想法。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>请看这个 <a href="https://youtu.be/_tpcHN6ZtKM">视频</a>中对 WP 日程安排的帮助。</p>
</li>
<li>
<p>利用您默认的个人 WP 网站进行实验。</p>
</li>
<li>
<p>查看打印出来的 PDF 成品，并检查和纠正错误（这对我来说是一个非常好的方式，让我在闲暇时与男朋友&#34;在火炉旁&#34;喝着蛋奶酒，看我的文章😊；关于优秀的 <code>html-to-pdf</code> 转换器，见参考文献 1）。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_愿望清单">76.7. 愿望清单</h3>
<div class="paragraph">
<p>以下是我希望在新的一年里用 <code>make-wp-input</code> 做的一些事情。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将 html 源码转换为 Github 风格的 markdown</p>
</li>
<li>
<p>处理 html 表格</p>
</li>
<li>
<p>允许在源 html 中的段落通过文本上下的空行或在文本之前的行上加上一个结束标签或在文本之后的行上加上一个开始标签来识别。</p>
</li>
<li>
<p>使用 Github 的 API[参考文献 2]来操作 markdown 源到 Github gist，并从中获取 html 结果。</p>
</li>
<li>
<p>使用 WordPress 的 API[参考文献 3]来操作自己在 WordPress 上的文章（包括设置或更新发布日程）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>而以下是我希望社区能够为乐降临网站做的一些事情（或者至少是一致的）。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>改进主题和代码风格。</p>
</li>
<li>
<p>使用旧的 Perl 6 Advent 主题？</p>
</li>
<li>
<p>在年初注册文章时段，并在 Raku Advent 网站上以预定的形式开始文章（至少是骨架形式）。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_总结_7">76.8. 总结</h3>
<div class="paragraph">
<p>今年 Raku 社区的变化很大，尤其是改名之后，还没有全部完成。一个仍需努力的领域是改进新的 Raku Advent 网站。我们也希望能更方便地创建和发布 Raku Advent 的文章，以及获得更多的参与。请注意，2020 年的日程表已经<a href="https://github.com/Raku/advent/blob/master/raku-advent-2020/schedule">开放</a>，所以你可以提前拿到你的档期，避免最后一分钟的购物，呃，Raku Advent!</p>
</div>
<div class="paragraph">
<p>我❤️Raku！😊</p>
</div>
<div class="paragraph">
<p>祝大家圣诞快乐，新年快乐，祝福大家!</p>
</div>
</div>
<div class="sect2">
<h3 id="_附录_4">76.9. 附录</h3>
<div class="sect3">
<h4 id="_笔记_3">76.9.1. 笔记</h4>
<div class="ulist">
<ul>
<li>
<p>我已经向 WordPress 提交了一个问题，以帮助在日程表中识别时区。</p>
</li>
<li>
<p>前面带@的名字是 IRC 或 Github 的别名。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_参考文献_3">76.9.2. 参考文献</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://wkhtml2pdf.org/">wkhtmltopdf</a> (作为 Debian 软件包提供)</p>
</li>
<li>
<p><a href="https://developer.github.com/v3/">Github API</a></p>
</li>
<li>
<p><a href="https://developer.wordpress.org/rest-api/">WordPress 的 API</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_使用的_raku_模块">76.9.3. 使用的 Raku 模块</h4>
<div class="paragraph">
<p>RakuAdvent::WordPress (v.0.0.2)</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第_24_天raku_之鬼灵精第二部稳住阵脚">77. 第 24 天：《Raku 之鬼灵精》第二部：稳住阵脚</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 2017 年，<a href="https://perl6advent.wordpress.com/2017/12/01">鬼灵精</a>毁了圣诞节，展示了一些顽皮的事情，你可以用 Raku 的功能。不幸的是，虽然他的心脏在那一年增长了三个尺寸，但不止一个鬼灵精! 这个鬼灵精今年会做一些额外的淘气事，从 JavaScript 社区中获得一些灵感。</p>
</div>
<div class="paragraph">
<p>你可能听说过 <a href="https://jsfuck.com/">JSFuck</a>，它是一个允许你只使用 <code>[</code>, <code>]</code>, <code>(</code>, <code>)</code>, <code>+</code>, 和 <code>!</code> 等字符编写任何 JavaScript 代码的工具。这是只有在 JavaScript 这样的语言中才能实现的事情，对吧？这并不完全正确! 为了证明这一点，让我们把它移植到 Raku 中。由于不能使用完全相同的字符集来实现，我们的限制是在翻译的代码中只能使用非字母数字的 ASCII 字符，并且不能使用字符串的字元。</p>
</div>
<div class="sect2">
<h3 id="_生成元语">77.1. 生成元语</h3>
<div class="paragraph">
<p>我们需要做的第一件事是找到一种方法来生成一些元语。我们感兴趣的来自 JavaScript 的是布尔函数、数字和字符串；任何其他类型的元语都可以通过其他方式来表示。这些主要是通过对空数组的类型转换来生成的，这在 Raku 中也恰好可以做到。</p>
</div>
<div class="paragraph">
<p>True 和 False 可以在 Raku 中使用 &#34;!&#34; 前缀操作符生成，类似于在 JavaScript 中的生成方式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ![];  # OUTPUT: True
say !![]: # OUTPUT: False</code></pre>
</div>
</div>
<div class="paragraph">
<p>结合 <code>+</code> 前缀操作符，我们可以生成任何整数，这在 JavaScript 中也是如此。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say +[];         # OUTPUT: 0
say +![];        # OUTPUT: 1
say +![] + +![]; # OUTPUT: 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 JavaScript 中，<code>+</code> 也恰好用于串联字符串。当与两个空数组一起使用时，<code>+</code> 会将两个数组胁迫为字符串，并将它们连接起来，从而得到一个空字符串。在 Raku 中，<code>+</code> 并没有这样的行为，所以我们需要使用 <code>~</code> 操作符来代替。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (~[]).perl; # OUTPUT: &#34;&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不过不为空的字符串怎么办？在 JavaScript 中，字符串是可迭代的，它允许在字符串化空数组以外的值时使用某些字符。但在 Raku 中却不是这样的。是时候开始发挥创意了。</p>
</div>
<div class="paragraph">
<p>字符串位元运算符允许您在字符串中的代码点上执行与数字相同的位元运算。使用 <code>~^</code> infix 操作符，我们可以生成一个给定 0 和 0 的空字符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ord +[] ~^ +[]; # OUTPUT: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>不过我们不能仅用 <code>~+</code>, <code>~|</code>, 和 <code>~^</code> 运算符很容易地生成我们需要的字符。有一种方法可以利用那个空字符来实现，但是我们首先需要一个小写的字母。如果我们使用一个 regex，我们可以从 &#34;True&#34; 中抓取字母 &#34;e&#34;。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ~(![] ~~ /...(.)/)[+[]]; # OUTPUT: e</code></pre>
</div>
</div>
<div class="paragraph">
<p>利用这两个字符的无限序列，我们可以生成 ASCII 中的大部分字符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Str:D @chars = (+[] ~^ +[]...~(![] ~~ /...(.)/)[+[]]...*);
say @chars[65..90];  # OUTPUT: (A B C D E F G H I J K L M N O P Q R S T U V W X Y Z)
say @chars[97..122]; # OUTPUT: (a b c d e f g h i j k l m n o p q r s t u v w x y z)</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们可以生成字符串 &#34;&amp;chr&#34; 中的字符，下一步之后我们就可以生成任何 Unicode 字符串。</p>
</div>
</div>
<div class="sect2">
<h3 id="_计算代码">77.2. 计算代码</h3>
<div class="paragraph">
<p>大多数可以生成的 JavaScript 代码都依赖于 Function 构造函数才能工作。使用它，你可以在运行时任意生成一个函数。据我所知，在 Raku 中不使用 <code>&amp;EVAL</code> 是不可能生成这样的代码的。不过，如果要使用它，我们需要解决一个问题。</p>
</div>
<div class="paragraph">
<p>我们可以用 <code>&amp;EVAL</code> 来使用字符串字面值就可以了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say EVAL &#34;&#39;Hello, world!&#39;&#34;; # OUTPUT: Hello, world!</code></pre>
</div>
</div>
<div class="paragraph">
<p>但如果我们试图用它来使用一个在编译时未知的值，我们就会得到一个关于我们正在做的事情的安全影响的异常警告，告诉我们使用 <strong>MONKEY-SEE-NO-EVAL</strong> 指令。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say EVAL my $ = &#34;&#39;Hello, world!&#39;&#34;; # Throws X::SecurityPolicy::Eval</code></pre>
</div>
</div>
<div class="paragraph">
<p>在我们的情况下，这不是很好！我们不能在没有字母数字字符的情况下设置这个指令。是时候调皮一下了。如果我们尝试使用间接符号查找的 <code>&amp;EVAL</code> 会发生什么？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ::(&#39;&amp;EVAL&#39;)(my $ = &#34;&#39;Hello world!&#39;&#34;); # OUTPUT: Hello, world!</code></pre>
</div>
</div>
<div class="paragraph">
<p>很好！我们可以使用间接的符号查找来生成任何 Unicode 码点的字符串。除此以外，使用间接符号查找，我们还可以调用 <code>&amp;chr</code> 例程为任何 Unicode 码点生成一个字符串。结合起来，这允许我们翻译任何有效的 Raku 代码。</p>
</div>
</div>
<div class="sect2">
<h3 id="_稳住阵脚">77.3. 稳住阵脚</h3>
<div class="paragraph">
<p>我们已经准备好开始为 JSFuck 的移植写代码了。这将是一个简单的脚本，它将一些 Raku 代码作为输入并输出其翻译。所有使用的子程序（除了 <code>&amp;MAIN</code>）都是 <a href="https://en.wikipedia.org/wiki/Pure_function">纯的</a>。现在， 让我们给这个移植起个好听点的名字， 而不是显而易见的选择， 叫它 Hold Your Horses。</p>
</div>
<div class="paragraph">
<p>我们的第一个子程序将是 <code>&amp;from-uint</code>， 它将翻译数字。我们可以直接将 1 加到 0 中， 直到得到我们要找的数字， 但这将为较大的代码点产生大量的代码。我们可以缩短产生的代码的一个方法是，如果我们将数字表示为质数的乘积。这可以通过将大于 5 的质数表示为质数乘积的和来进一步缩短。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Prime::Factor;

sub from-uint(UInt:D $x, Int:D $remainder = 0 --&gt; Str:D) is pure {
    proto sub translate(UInt:D --&gt; Str:D) is pure {*}
    multi sub translate(0 --&gt; &#39;+[]&#39;) { }
    multi sub translate(1 --&gt; &#39;+![]&#39;) { }
    multi sub translate(UInt:D $x --&gt; Str:D) {
        join &#39; + &#39;, &#39;+![]&#39; xx $x
    }

    if $x &lt;= 5 {
        my Str:D $translation = $x.&amp;translate;
        $translation ~= &#39; + &#39; ~ $remainder.&amp;from-uint if $remainder;
        $translation
    } elsif $x.is-prime {
        from-uint $x - 1, $remainder + 1
    } else {
        my Str:D $translation = $x.&amp;prime-factors».&amp;from-uint.fmt: &#39;(%s)&#39;, &#39; * &#39;;
        $translation ~= &#39; + &#39; ~ $remainder.&amp;from-uint if $remainder;
        $translation
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们可以实现 <code>&amp;from-str</code>，它将解析用户输入的代码。这需要将给定代码中的每一个代码点映射到一个 Hold Your Horses 编号，如果在其范围内，可以通过查找前面字符序列中的一个字符来完成，否则可以调用 <code>&amp;chr</code>。由于我们每次看到被它包含的字符时都会用到这个序列，所以会被我们的下一个子程序存储在 $_ 中。由于翻译一个代码点可能是相当密集的，所以让我们使用实验性的 <a href="https://docs.raku.org/language/experimental#cached">is cached</a> 特性与我们的帮助子程序一起处理这个问题，以避免对任何给定的代码点进行一次以上的翻译。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use experimental :cached;

sub from-str(Str:D $code --&gt; Str:D) is pure {
    my Int:D constant LIMIT = &#39;z&#39;.ord.succ;

    proto sub translate(UInt:D --&gt; Str:D) is pure is cached {*}
    multi sub translate(UInt:D $codepoint where 0..^LIMIT --&gt; Str:D) {
        sprintf &#39;.[%s]&#39;, $codepoint.&amp;from-uint
    }
    multi sub translate(UInt:D $codepoint where LIMIT..* --&gt; Str:D) {
        sprintf &#39;::(%s)(%s)&#39;,
                &#39;&amp;chr&#39;.ords».&amp;translate.join(&#39; ~ &#39;),
                $codepoint.&amp;from-uint
    }

    sprintf &#39;::(%s)(%s)&#39;,
            &#39;&amp;EVAL&#39;.ords».&amp;translate.join(&#39; ~ &#39;),
            $code.ords».&amp;translate.join(&#39; ~ &#39;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们可以实现 <code>&amp;hold-your-horses</code>，它将处理用户输入的全部代码翻译。这需要做的就是在调用 <code>&amp;from-str</code> 之前将前面的序列存储在 $_ 中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub hold-your-horses(Str:D $code --&gt; Str:D) is pure {
    Qc:to/TRANSLATION/.chomp
    $_ := (+[] ~^ +[]...~(![] ~~ /...(.)/)[+[]]...*);
    {$code.&amp;from-str};
    TRANSLATION
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>加入 <code>&amp;MAIN</code> 后，我们的脚本就完成了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.d;
use experimental :cached;
use Prime::Factor;
unit sub MAIN(Str:D $code) {
    say hold-your-horses $code
}

sub from-uint(UInt:D $x, Int:D $remainder = 0 --&gt; Str:D) is pure {
    proto sub translate(UInt:D --&gt; Str:D) is pure {*}
    multi sub translate(0 --&gt; &#39;+[]&#39;) { }
    multi sub translate(1 --&gt; &#39;+![]&#39;) { }
    multi sub translate(UInt:D $x --&gt; Str:D) {
        join &#39; + &#39;, &#39;+![]&#39; xx $x
    }

    if $x &lt;= 5 {
        my Str:D $translation = $x.&amp;translate;
        $translation ~= &#39; + &#39; ~ $remainder.&amp;from-uint if $remainder;
        $translation
    } elsif $x.is-prime {
        from-uint $x - 1, $remainder + 1
    } else {
        my Str:D $translation = $x.&amp;prime-factors».&amp;from-uint.fmt: &#39;(%s)&#39;, &#39; * &#39;;
        $translation ~= &#39; + &#39; ~ $remainder.&amp;from-uint if $remainder;
        $translation
    }
}

sub from-str(Str:D $code --&gt; Str:D) is pure {
    my Int:D constant LIMIT = &#39;z&#39;.ord.succ;

    proto sub translate(UInt:D --&gt; Str:D) is pure is cached {*}
    multi sub translate(UInt:D $codepoint where 0..^LIMIT --&gt; Str:D) {
        sprintf &#39;.[%s]&#39;, $codepoint.&amp;from-uint
    }
    multi sub translate(UInt:D $codepoint where LIMIT..* --&gt; Str:D) {
        sprintf &#39;::(%s)(%s)&#39;,
                &#39;&amp;chr&#39;.ords».&amp;translate.join(&#39; ~ &#39;),
                $codepoint.&amp;from-uint
    }

    sprintf &#39;::(%s)(%s)&#39;,
            &#39;&amp;EVAL&#39;.ords».&amp;translate.join(&#39; ~ &#39;),
            $code.ords».&amp;translate.join(&#39; ~ &#39;)
}

sub hold-your-horses(Str:D $code --&gt; Str:D) is pure {
    Qc:to/TRANSLATION/.chomp
    $_ := (+[] ~^ +[]...~(![] ~~ /...(.)/)[+[]]...*);
    {$code.&amp;from-str};
    TRANSLATION
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，这真的有用吗？为了简明扼要，我们可以说，如果说 &#34;Hello, world! 👋&#34;可以翻译并运行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">bastille% raku hold-your-horses.raku &#39;say &#34;Hello, world! 👋&#34;&#39; &gt; hello-world.raku
bastille% raku hello-world.raku
Hello, world! 👋</code></pre>
</div>
</div>
<div class="paragraph">
<p>完美！这是脚本的输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ := (+[] ~^ +[]...~(![] ~~ /...(.)/)[+[]]...*);
::(.[(+![] + +![]) * ((+![] + +![]) * (+![] + +![] + +![]) * (+![] + +![] + +![]) + +![])] ~ .[(+![] + +![] + +![]) * ((+![] + +![]) * ((+![] + +![]) * (+![] + +![] + +![] + +![] + +![]) + +![]) + +![])] ~ .[(+![] + +![]) * ((+![] + +![]) * (+![] + +![] + +![]) * ((+![] + +![]) * (+![] + +![] + +![]) + +![]) + +![])] ~ .[(+![] + +![] + +![] + +![] + +![]) * ((+![] + +![]) * (+![] + +![]) * (+![] + +![] + +![]) + +![])] ~ .[(+![] + +![]) * (+![] + +![]) * ((+![] + +![]) * (+![] + +![] + +![]) * (+![] + +![] + +![]) + +![])])(.[(+![] + +![] + +![] + +![] + +![]) * ((+![] + +![]) * ((+![] + +![]) * (+![] + +![] + +![] + +![] + +![]) + +![]) + +![])] ~ .[(+![] + +![]) * (+![] + +![]) * (+![] + +![]) * (+![] + +![]) * (+![] + +![]) * (+![] + +![] + +![]) + +![]] ~ .[((+![] + +![]) * (+![] + +![] + +![] + +![] + +![]) + +![]) * ((+![] + +![]) * (+![] + +![] + +![] + +![] + +![]) + +![])] ~ .[(+![] + +![]) * (+![] + +![]) * (+![] + +![]) * (+![] + +![]) * (+![] + +![])] ~ .[(+![] + +![]) * ((+![] + +![]) * (+![] + +![]) * (+![] + +![]) * (+![] + +![]) + +![])] ~ .[(+![] + +![]) * (+![] + +![]) * (+![] + +![]) * (+![] + +![] + +![]) * (+![] + +![] + +![])] ~ .[(+![] + +![]) * (+![] + +![]) * (+![] + +![] + +![] + +![] + +![]) * (+![] + +![] + +![] + +![] + +![]) + +![]] ~ .[(+![] + +![]) * (+![] + +![]) * (+![] + +![] + +![]) * (+![] + +![] + +![]) * (+![] + +![] + +![])] ~ .[(+![] + +![]) * (+![] + +![]) * (+![] + +![] + +![]) * (+![] + +![] + +![]) * (+![] + +![] + +![])] ~ .[(+![] + +![] + +![]) * ((+![] + +![]) * (+![] + +![]) * (+![] + +![] + +![]) * (+![] + +![] + +![]) + +![])] ~ .[(+![] + +![]) * (+![] + +![]) * ((+![] + +![]) * (+![] + +![] + +![] + +![] + +![]) + +![])] ~ .[(+![] + +![]) * (+![] + +![]) * (+![] + +![]) * (+![] + +![]) * (+![] + +![])] ~ .[((+![] + +![]) * (+![] + +![] + +![]) + +![]) * ((+![] + +![]) * (+![] + +![]) * (+![] + +![]) * (+![] + +![]) + +![])] ~ .[(+![] + +![] + +![]) * ((+![] + +![]) * (+![] + +![]) * (+![] + +![] + +![]) * (+![] + +![] + +![]) + +![])] ~ .[(+![] + +![]) * (+![] + +![] + +![]) * ((+![] + +![]) * (+![] + +![] + +![]) * (+![] + +![] + +![]) + +![])] ~ .[(+![] + +![]) * (+![] + +![]) * (+![] + +![] + +![]) * (+![] + +![] + +![]) * (+![] + +![] + +![])] ~ .[(+![] + +![]) * (+![] + +![]) * (+![] + +![] + +![] + +![] + +![]) * (+![] + +![] + +![] + +![] + +![])] ~ .[(+![] + +![] + +![]) * ((+![] + +![]) * (+![] + +![] + +![] + +![] + +![]) + +![])] ~ .[(+![] + +![]) * (+![] + +![]) * (+![] + +![]) * (+![] + +![]) * (+![] + +![])] ~ ::(.[(+![] + +![]) * ((+![] + +![]) * (+![] + +![] + +![]) * (+![] + +![] + +![]) + +![])] ~ .[(+![] + +![] + +![]) * (+![] + +![] + +![]) * ((+![] + +![]) * (+![] + +![] + +![] + +![] + +![]) + +![])] ~ .[(+![] + +![]) * (+![] + +![]) * (+![] + +![]) * ((+![] + +![]) * (+![] + +![]) * (+![] + +![] + +![]) + +![])] ~ .[(+![] + +![]) * (+![] + +![] + +![]) * ((+![] + +![]) * (+![] + +![] + +![]) * (+![] + +![] + +![]) + +![])])((+![] + +![] + +![] + +![] + +![]) * (+![] + +![] + +![] + +![] + +![]) * ((+![] + +![]) * ((+![] + +![]) * ((+![] + +![]) * (+![] + +![] + +![] + +![] + +![]) + +![]) + +![]) + +![]) * ((+![] + +![]) * (+![] + +![]) * (+![] + +![] + +![]) * (+![] + +![] + +![]) * (+![] + +![] + +![]) + +![])) ~ .[(+![] + +![]) * ((+![] + +![]) * (+![] + +![]) * (+![] + +![]) * (+![] + +![]) + +![])]);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_收尾工作">77.4. 收尾工作</h3>
<div class="paragraph">
<p>Raku 是一门相当大的语言，它有广泛的功能。这些功能可以用一些非常有趣的方式结合起来。在这里，利用类型强制、字符串位运算符、正则表达式、序列、间接符号查找和 <code>&amp;EVAL</code> 的漏洞的组合，我们今年又可以做一个淘气的精灵，从 JavaScript 中移植 JSFuck。如果你很想说有些东西是不可能用 Raku 写的，别急，只要有合适的工具，很有可能做到。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第一天_为什么_raku_是_advent_code_的理想语言">78. <a href="https://raku-advent.blog/2020/12/01/day-1-why-raku-is-ideal-for-advent-of-code/">第一天 - 为什么 Raku 是 Advent Code 的理想语言？</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>现在是12月, 到了我最喜欢的两个科技界传统的时候了：<a href="https://raku-advent.blog/">Raku Advent Calendar</a> 和 <a href="https://adventofcode.com/2020/about">Advent of Code</a>。这两个节日传统有相当多的共同点 - 它们都从12月1日一直持续到圣诞节, 并且每天都会在活动期间发布新的东西。具体来说, Raku Advent Calendar 会发布一篇关于 <a href="https://www.raku.org/">Raku 编程语言</a>的新博文, 而 Advent of Code 则会发布一个新的编程挑战 - 可以用任何语言解决。</p>
</div>
<div class="paragraph">
<p>(在这篇文章中, 我将把&#34;代码降临&#34;称为 &#34;AoC&#34; - 不要与美国政治家 <a href="https://en.wikipedia.org/wiki/Alexandria_Ocasio-Cortez">AOC</a> 混淆, 据我所知, 他并没有用 Raku 编程)。</p>
</div>
<div class="paragraph">
<p>对我来说, Raku 和 AoC 是科技降临季的巧克力和花生酱：每一个都是单独的好东西, 但它们结合起来会更好。如果你的唯一目标是解决 AoC 挑战, 那么 Raku 是一种很好的语言；另一方面, 如果你的唯一目标是学习 Raku, 那么解决 AoC 挑战是一种很好的方式。这篇文章将解释 Raku 和 AoC 是如何如此契合的, 然后提供一些资源来帮助我们大家开始解决 AoC 挑战。</p>
</div>
<div class="sect2">
<h3 id="_什么是_raku你为什么要关心">78.1. 什么是 Raku？(你为什么要关心？)</h3>
<div class="paragraph">
<p>由于 Raku 是一种相对较新的编程语言, 至少你们中的一些人可能对它不熟悉, 也不知道为什么它值得学习。Raku 是<a href="https://www.reddit.com/r/rakulang/comments/ixo408/how_would_you_describe_raku_in_one_sentence/">众所周知的很难</a>用一句话来描述的, 但这是我的观点。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Raku 是一种简洁的, 富有表现力的, 积极的多范式语言, 具有强推断类型, 内置的并发性, 丰富的元编程, 以及一流的字符串处理和模式匹配。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>这在实践中意味着, 我发现自己越来越多地接触到 Raku。当遇到几乎所有的问题时, 我一直认为 Raku 是一种能让我以最清晰、最快速、最优雅的方式解决它的语言。(唯一的例外是, 如果解决我的问题需要编译语言的原始速度或低资源使用。但即使在这种相对罕见的情况下, 我可能会用 Rust 编写代码中性能关键的部分, 而用 Raku 编写其他部分, 以利用<a href="https://raku-advent.blog/2019/12/13/day-4-a-little-rr/">这两种语言的良好配合</a>。)</p>
</div>
<div class="paragraph">
<p>这并不是说 Raku 是一种试图对所有人都适用的语言。事实上, Raku 难得的、像激光一样关注个人的生产力, 并且愿意牺牲一些标准的企业/大型团体功能来实现这个目标, 正如我之前详细讨论过的那样（<a href="https://www.codesections.com/blog/raku-manifesto/">第一部分</a>, <a href="https://www.codesections.com/blog/raku-manifesto-2/">第二部分</a>, <a href="https://www.codesections.com/blog/raku-manifesto-3/">第三部分</a>）。但是, 即使抛开这些大局观的想法, Raku 也是一种充满了有趣想法的语言。如果这些想法有我相信的一半那么好, 那么 Raku 就是你在工具箱中想要的一门语言。</p>
</div>
</div>
<div class="sect2">
<h3 id="_为什么_raku_非常适合解决_aoc_挑战">78.2. 为什么 Raku 非常适合解决 AoC 挑战？</h3>
<div class="paragraph">
<p>我相信, Raku 很适合解决许多不同的问题, 但它绝对是代码降临挑战的绝佳选择。为了解释原因, 我将介绍一下我们希望从理想的 AoC 语言中得到什么。然后, 我会介绍一个去年第一个 AoC 挑战的 Raku 解决方案, 并将其与我们的理想进行比较。(Spoiler: they’re really similar!)</p>
</div>
<div class="paragraph">
<p>当思考理想的 AoC 语言时, 我想到的 AoC 的第一个特点是, 它是一系列小的, 基本上自成一体的谜题, 而不是一个大型项目。这说明理想的语言应该是简明扼要、低样板的。当建立一个大型项目时, 处理许多行的样本是很烦人的, 但可以忍受, 但如果在 AoC 的每一天都重复这样做, 那就糟糕多了。而且, 由于我们将分享我们的代码, 保持简洁将有助于其他人看到我们的逻辑, 而不会被内务细节所干扰。</p>
</div>
<div class="paragraph">
<p>我们可以说得更具体一些：AoC 挑战赛通常会提供文本输入, 并寻找文本输出；它们通常也会提供几个测试用例, 有助于制作一个可行的解决方案。因此, 除了在一般情况下简明扼要之外, 我们理想的语言还应该为脚本和测试提供低样板的解决方案。</p>
</div>
<div class="paragraph">
<p>也许 AoC 最显著（当然也是最有趣的!）的特点是它的社区驱动和教育性：数以千计的程序员都在或多或少地解决相同的难题, 然后将他们的解决方案发布到 <a href="https://www.reddit.com/r/adventofcode/">Advent of Code 子 reddit 上</a>。从阅读其他解决方案 - 包括不同语言的解决方案 - 中学到的东西和你自己解决难题一样多, 甚至更多, 这是非常常见的。这意味着我们理想中的语言应该是可读的、优雅的, 即使对于没有太多语言经验的人来说也是如此。</p>
</div>
<div class="paragraph">
<p>当然, 虽然能够写出让不熟悉语言的人也能欣赏的代码是件好事, 但我们的大部分教学和学习将来自于将我们的解决方案与同一种语言的其他解决方案进行比较。毕竟, 同一语言中的不同解决方案往往会显示出做出不同权衡的方法, 并能帮助我们扩展编程工具集。或者至少在我们的语言中不同的解决方案是, 嗯, 不同的情况下会发生这种情况：如果我们的语言将每个人都推向一个单一的, 明显的解决方案, 那么这种学习的空间就会少很多。所以我们理想的语言应该提供不止一种解决任何特定挑战的方法。</p>
</div>
<div class="paragraph">
<p>我相信我还可以继续说下去, 但似乎我们已经有了一个很好的清单。总而言之, 我们正在寻找一种语言, 这种语言要简洁、低模板, 特别是对于脚本和测试来说, 并且允许为每个挑战提供多种不同的可读性和优雅的解决方案。(请注意, 这个列表是关于寻找最好的语言来学习和享受 AoC。如果你的目标是在 AoC 排行榜上名列前茅, 那么 Raku 出色的字符串处理功能仍然会让它成为一个<a href="https://blog.vero.site/post/advent-leaderboard#get-comfortable-with-your-language-standard-library-and-editor">很好的选择</a>。但是, 从现实的角度来看, 如果这是你的目标, 你应该选择任何你最熟悉的语言。)</p>
</div>
<div class="paragraph">
<p>现在我们知道了在理想的语言中我们会想要什么, 让我们来看看去年第一个挑战的 Raku 解决方案。</p>
</div>
</div>
<div class="sect2">
<h3 id="_aoc_2019_raku_第1天">78.3. AoC 2019 Raku 第1天</h3>
<div class="paragraph">
<p>你可以阅读<a href="https://adventofcode.com/2019/day/1">完整的问题描述</a>来了解所有的细节, 但简短的版本是, 这个挑战要求我们根据飞船的质量, 对发射飞船所需的燃料进行一些不同的计算。具体来说, 在第一部分中, 我们被告知:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>要找出一个模块所需的燃料, 取其质量, 除以3, 四舍五入, 再减去2。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>因为 Raku 有<a href="https://docs.raku.org/language/operators#index-entry-Integer_division_operator">整数除法运算符</a>, 所以这几乎是小菜一碟。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub fuel($mass) { +$mass div 3 - 2 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二部分要求我们进行类似的计算, 但这次要考虑到我们要添加的燃料所增加的额外质量。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>就像取模一样, 燃料本身也需要燃料 - 取它的质量, 除以3, 四舍五入, 再减去2。然而, 该燃料也需要燃料, 该燃料也需要燃料, 以此类推。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>为了解决这部分问题, 我们可以使用第一部分的 fuel 函数来计算我们需要多少燃料, 然后将我们的初始结果加到我们需要的新质量的燃料量上。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi total-fuel($mass) { fuel($mass).&amp;{$_ + .&amp;total-fuel} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二部分还告诉我们:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>任何需要负燃料的质量都应该被视为需要零燃料。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>同样, Raku 提供了一个强大的功能, 使这个问题变得简单：在这种情况下, 强大的功能是 Raku 针对<a href="https://docs.raku.org/type/Signature#index-entry-where_clause">函数签名</a>中的运行时值进行模式匹配的能力。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi total-fuel($mass where fuel($mass) ≤ 0) { 0 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这三行代码, 我们基本上就解决了这个挑战。当然, 我们希望不仅能够对单个数字进行计算, 而且能够对我们的整个输入进行计算（在这个挑战中, 输入的形式是一个文本文件, 每行有不同的数字）。我们还希望我们的脚本是可执行的, 并能公开一个带有用户友好描述和—​帮助文本的 CLI。这个 CLI 应该允许用户选择我们的脚本是解决挑战的第一部分还是第二部分。</p>
</div>
<div class="paragraph">
<p>幸运的是, Raku 让我们只需要三行额外的代码和一个 shebang 注释就可以添加所有这些细节。到目前为止, 我们的完整解决方案如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit sub MAIN( #=  Solve the 2019 AoC day 01 puzzle
    Bool :$p2  #={ Solve p2 instead of p1 (the default)} );
sub fuel($mass) { +$mass div 3 - 2 }
multi total-fuel($mass) { fuel($mass).&amp;{$_ + .&amp;total-fuel} }
multi total-fuel($mass where fuel($mass) ≤ 0) { 0 }

say lines.map($p2 ?? &amp;total-fuel !! &amp;fuel).sum;</code></pre>
</div>
</div>
<div class="paragraph">
<p>(第2行和第3行中的注释产生了 - 帮助文档。)</p>
</div>
<div class="paragraph">
<p>这个挑战还提供了7个测试用例, 我们也许应该把它们包括进去。当在一个较大的 Raku 项目中工作时, <a href="https://docs.raku.org/language/testing">标准的方法</a>是将我们的测试分成一个单独的文件。但我们要<a href="https://www.perl.com/pub/2007/12/06/soto-11.html/">使用脚本</a>, 如果放弃单文件的简单性, 那就太可惜了。所以, 我们不使用单独的文件, 而是使用我<a href="https://www.codesections.com/blog/raku-unit-testing-with-conditional-compilation/">之前在博客中介绍过</a>的一种技术, 使用 Raku 的条件编译将我们的测试包含在一个文件中, 而不需要在每次运行脚本时执行它们。</p>
</div>
<div class="paragraph">
<p>使用这种技术, 我们得到的最终代码（包括测试）是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit sub MAIN( #=  Solve the 2019 AoC day 01 puzzle
    Bool :$p2  #={ Solve p2 instead of p1 (the default)} );
sub fuel($mass) { +$mass div 3 - 2 }
multi total-fuel($mass) { fuel($mass).&amp;{$_ + .&amp;total-fuel} }
multi total-fuel($mass where fuel($mass) ≤ 0) { 0 }

say lines.map($p2 ?? &amp;total-fuel !! &amp;fuel).sum;

# Tests (run with `raku --doc -c $FILE`)
DOC CHECK { use Test;
    subtest &#39;Part 1&#39;, { fuel(12).&amp;is:            2;
                        fuel(14).&amp;is:            2;
                        fuel(1_969).&amp;is:         654;
                        fuel(100_756).&amp;is:       33_583; }
    subtest &#39;Part 2&#39;, { total-fuel(14).&amp;is:      2;
                        total-fuel(1_969).&amp;is:   966;
                        total-fuel(100_756).&amp;is: 50_346; }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_将_raku_与理想的_aoc_语言进行比较">78.4. 将 Raku 与理想的 AoC 语言进行比较</h3>
<div class="paragraph">
<p>那么, Raku 在我们之前提出的指标上表现如何呢？好吧, 就简洁和低模板而言, 这段代码似乎做得还不错。的确, 它远没有达到最大程度的简洁；它比我去年在 <a href="https://en.wikipedia.org/wiki/APL_(programming_language">Dyalog APL</a>#Dyalog_APL 中解决这个挑战时<a href="https://fosstodon.org/@codesections/103233204678110012">想出的方案</a>要长7倍左右。) 不过, 程序的代码只有6行, 7个测试用例的代码只有9行, 我还是会给它打分, 认为它是高度简洁的。作为对比, 一个<a href="https://github.com/thorstel/Advent-of-Code-2019/blob/master/day01/src/main.rs">强势的 Rust 解法</a>在方案上用了27行代码, 测试上用了17行代码。</p>
</div>
<div class="paragraph">
<p>而在支持脚本和测试的同时, 又消除了样板代码, Raku 的代码就非常理想了。开头的 shebang 一行是样板代码, 但对于用任何语言创建一个独立的脚本都是必不可少的。除了这一行, 唯一可以说是模板的部分是使用测试行和 unit sub MAIN 行。这些行给我们提供了一个经过测试的脚本和一个完整的文档化的 CLI - 这是 Rust 和上面链接的 APL 例子都没有提供的。考虑到我们得到的回报, 我准备给这个解决方案打满分, 因为它支持脚本和测试而不依赖模板。</p>
</div>
<div class="paragraph">
<p>判断 Raku 解决方案的可读性和优雅程度当然涉及到更多的主观性。而且, 可以说, 懂 Raku 的人最没有资格判断代码对于不懂 Raku 语言的程序员的可读性。也就是说, 在我看来, 这个解决方案的可读性足够强, 一个非 Raku 程序员也可以遵循它—​同时仍然利用了足够多的 Raku 的聪明特性, 使其变得优雅。一个非 Raku 程序员可能不知道 <code>div</code> 操作符, 但可以从上下文和合理的假设中找出它, 它必须做一些不同于/操作符的事情。<code>fuel($mass).&amp;{ $_ + total-fuel($_) }</code> 这一行也可能会让一个非 Raku 程序员慢下来—​特别是如果他们没有遇到 Perl 中的 $_ 主题变量的话。但是, 我相信他们也能很快地从上下文中找出答案。而且, 一旦他们明白了, 我打赌他们会很欣赏重用（而不是重新计算）<code>fuel($mass)</code> 值的优雅, 而不需要创建和命名一个临时值。</p>
</div>
<div class="paragraph">
<p>最后一个对非 Raku 程序员来说可能会很陌生的片段是 <code>$mass where fuel($mass) ≤ 0</code> 部分。但是, 在我看来（诚然有失偏颇！）, 这个片段既清晰又立即优雅 - 它如此完美地抓住了&#34;只有当 $mass 小于或等于0时才调用这个函数&#34;的意图, 这是大多数其他编程语言无法用函数签名表达的。我知道优雅是看人下菜碟, 但这个片段和整个脚本都非常符合我的定义。</p>
</div>
<div class="paragraph">
<p>我们的最后一个标准 - Raku 是否提供了不止一种解决这个挑战的方法—​从单一的解决方案中本质上是无法判断的。但在 Raku 中, 不管它指的是什么, 总是有不止一种方法。一个相对较小的改变就是向 Raku 的类型系统靠拢。因为 Raku 有如此强大的类型推断能力, 所以可以像写动态类型语言一样来写。但是 Raku 有一个强大的类型系统, 允许你约束你的函数接受的类型。</p>
</div>
<div class="paragraph">
<p>例如, 在当前的代码中, 我们有函数 <code>sub fuel($mass) { +$mass div 3 - 2 }</code>。这个函数可以接受任何类型的增量 (随后用 <code>+</code> 操作符将其转换为数字类型), 但不保证其返回类型。这种灵活性是很好的 - 当我们从  stdin 传递输入时, 它可以让我们用 Str 来调用 fuel, 而当我们递归调用它时, 则用 Int 来调用。如果我们想要更多的类型安全（在一个较长的程序中, 我们很可能会这样做）, 我们可以像这样确定参数和返回类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub fuel(Int $mass --&gt; Int) { $mass div 3 - 2 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于这个函数只接受 Int, 所以我们不需要在函数体里面加上 <code>+</code>, 但是我们需要在调用 <code>fuel</code> 之前对输入进行解析。我们可以用很多方法来实现；我可能会在我们的 <code>lines</code> 管道中添加一个 <code>.map(+*)</code> 方法调用。</p>
</div>
<div class="paragraph">
<p>另一种选择是使用<a href="https://docs.raku.org/type/Signature#Coercion_type">强制类型约束</a>, 在安全性和灵活性之间取得一些平衡。这将导致 <code>sub fuel(Int() $mass -→ Int)</code> 的签名。<code>Int()</code> 部分约束函数接受一个可以被转换为 Int 的类型, 并自动执行转换。使用这个签名, 我们可以避免使用 <code>+$mass</code> 或 <code>.map(+*)</code>。</p>
</div>
<div class="paragraph">
<p>添加类型安全只是我们可以用不同的方式来解决这个问题的一种方法。我们也可以使用一个带有计算终点的<a href="https://docs.raku.org/language/operators#index-entry-sequence_operator">序列</a> (例如, $_, total-fuel($_) ...^ * ≤ 0) 来替代我们目前使用的 where 块。或者我们可以使用 reduce(无论是作为方法调用还是使用 <a href="https://docs.raku.org/language/operators#index-entry-">+</a>_(reduction_metaoperators[reduce 元操作符])来代替单独的 <code>map</code> 和 <code>sum</code> 步骤。或者我们可以通过使用 <a href="https://docs.raku.org/syntax/gather%20take">gather 和 take</a> 来进一步远离 <code>map</code>。简而言之, 即使是像这样简单的问题, 我们也有大量的方法可以使用 Raku - 这还没有提到我们可以使用 Raku 强大的、内置的并发支持来并行化我们的解决方案的方法, 如果出于某种原因, 我们想要提升性能的话。无论你个人如何解决 AoC 挑战, 我敢打赌, 你可以通过看看人们在 Raku 中提出的各种其他解决方案来学习一些东西。</p>
</div>
<div class="paragraph">
<p>我知道, 我们能从一个 AoC 挑战中得出多少结论是有限的 - 尤其是到12月, 挑战的难度一般都会增加, 这意味着第一天的挑战并不那么有代表性。我知道, 并不是每个人都会认同我关于什么是适合 AoC 的语言的定义。尽管如此, 我希望我们对 AoC 挑战赛的详细研究已经足以说服你, Raku 是一种很有前途的语言, 可以用于 AoC。如果你至少已经了解一些 Raku 语言, 我希望你会同意, 通过 AoC 挑战赛来学习是一个很好的选择（既可以提高 Raku 语言的水平, 也可以分享你的知识）。如果你还不了解 Raku, 我希望你至少能把 AoC 作为一个学习的机会。</p>
</div>
<div class="paragraph">
<p>如果是这样, 我有一些好消息。AoC 是学习 Raku 的绝佳途径。</p>
</div>
</div>
<div class="sect2">
<h3 id="_为什么_aoc_是学习_raku_的好方法">78.5. 为什么 AoC 是学习 Raku 的好方法？</h3>
<div class="paragraph">
<p>要想知道为什么 AoC 是学习 Raku 的好方法, 我想从另一个问题开始：学习 Raku 有多难？</p>
</div>
<div class="paragraph">
<p>对于这个问题, 有两种不同的观点。从一个角度来看, Raku 非常难学 - 几乎和 <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language">Scheme</a> 容易学的方式完全一样。著名的 Scheme 几乎没有语法；你可以很容易地坐下来, 一次就能学会 Scheme 的全部语法。(当然, 掌握这门语言需要的时间要长得多)。</p>
</div>
<div class="paragraph">
<p>Raku 几乎占据了相反的极端：它大量使用语法。我不认为有什么特别原则性的方法来衡量不同编程语言的&#34;大小&#34;, 但<a href="https://learnxinyminutes.com/">《Y分钟内学会X》</a>系列指南可能会提供一个大致的近似值。对比<a href="https://learnxinyminutes.com/docs/CHICKEN/">《Learn X in Y minutes》（其中X=CHICKEN Scheme）</a>指南和<a href="https://learnxinyminutes.com/docs/raku/">《Learn X in Y minutes》（其中X=Raku）</a>指南, 我看到 Raku 的指南大约有7倍的行数；我可以理解为什么有人会得出Y的值在这两个公式中很不一样的结论。</p>
</div>
<div class="paragraph">
<p>而且语法并不是 Raku 是一种大型语言的唯一方式。我之前形容 Raku 是&#34;积极的多范式&#34;；一个<a href="https://www.evanmiller.org/a-review-of-perl-6.html">有影响力的评论</a>称 Raku 是&#34;多范式, 也许是全范式&#34;。不管你怎么说, 很明显, 你可以用很多不同的方式来写 Raku。你可以<a href="https://docs.raku.org/language/101-basics">用程序化的方式来写</a>, 如果你愿意的话, 可以用显式 <code>for</code> 循环来完成。它还对<a href="https://docs.raku.org/language/101-basics">函数式编程</a>提供了<a href="https://wimvanderbauwhede.github.io/articles/decluttering-with-functional-programming/">一流的支持</a>（包括对<a href="https://wimvanderbauwhede.github.io/articles/function-types/">函数类型</a>、<a href="https://wimvanderbauwhede.github.io/articles/roles-as-adts-in-raku/">抽象数据类型</a>以及<a href="https://wimvanderbauwhede.github.io/articles/universal-interpreter-part-1/">其他高级函数式特性</a>的支持, 而这些特性是多范式语言经常从其函数式工具箱中省略的）。你也可以编写纯<a href="https://docs.raku.org/language/objects">面向对象的 Raku</a>, 事实上, 该语言本身就是从 OO 的角度构建的。Raku 还从<a href="https://docs.raku.org/language/list#index-entry-Shaped_arrays">数组编程</a>、<a href="https://docs.raku.org/type/Signature#Type_constraints">约束编程</a>和<a href="https://docs.raku.org/routine/==%3E">数据流编程</a>中借鉴了许多思想, 它支持并发编程、通用编程和极强的<a href="https://docs.raku.org/language/mop#index-entry-Introspection">自省</a>和<a href="https://docs.raku.org/language/mop">元编程</a>。</p>
</div>
<div class="paragraph">
<p>真正掌握 Raku 并不仅仅意味着了解它的所有广泛的语法, 它甚至不意味着熟悉 Raku 支持的许多不同的范式。要想完全精通 Raku, 需要有判断力来<a href="https://www.oreilly.com/radar/multi-paradigm-languages/">决定哪种范式最适合今天的问题</a>, 并能自如地正确应用该范式。从这个角度来看, Raku 是一门极难学的语言 - 虽然这样做的回报让它值得。</p>
</div>
<div class="paragraph">
<p>但还有另一种观点说, Raku 其实很容易学。</p>
</div>
<div class="paragraph">
<p>诚然, 如果你试图在没有上下文的情况下一次性学会所有 Raku 的语法是很难的。但你不应该这样做, 就像一个说英语的人试图通过坐下来用德语词典来学习德语一样。学习一门语言的所有语法似乎是一件合理的事情, 唯一的原因是有些编程语言是如此的微不足道, 以至于一次全部学习的方法不会立即造成灾难性的后果。但这并不意味着这种方法就是一个好主意。</p>
</div>
<div class="paragraph">
<p>相反, 学习 Raku 的方法是学习足够的知识, 然后开始使用它, 并在你走的时候学习更多的知识。从这个角度来看, Raku 的大量语法与语言的难易程度无关 - 你并不是想一次性学会它, 所以你开始学习的那点语法是一半还是只有 20% 都无所谓。而 Raku 的多范式特性实际上使 Raku 更容易倾斜而不是更难：因为 Raku 支持这么多不同的范式, 你可以从你最初最舒服的任何 Raku 子集开始, 然后从那里扩展出来。</p>
</div>
<div class="paragraph">
<p>现在, 你可能已经明白了为什么我们花了这么长的时间来讨论学习 Raku 是容易还是困难：如果你试图以学习 Scheme 的方式来学习 Raku, 你将会陷入艰难的困境。但是, 如果你采取更零碎的方法, 学习 Raku 就容易多了。而这种零敲碎打的方法也完美地映射到了通过《代码降临》学习 Raku 上。</p>
</div>
<div class="paragraph">
<p>具体来说, 要想用零敲碎打的方法取得成功, 你需要在一系列小项目上下功夫, 即使你只知道语言的一角, 每个项目也是可以管理的。它们需要是风险相对较低的项目 - 因为你还不知道解决一个问题的所有不同方法, 所以有时候你很有可能会实现一个次优的解决方案。而且, 最重要的是, 你需要在一个能让你看到其他方法的上下文中完成它们。从面向对象的 Raku 子集开始, 并从你的舒适区之外逐渐添加技术, 是学习 Raku 的好方法, 但只有当你真正做到 &#34;逐渐添加技术&#34;的部分, 它才会有效。如果你陷入了困境, 你就学不到那么多东西, 而看到其他人使用不同的技术来更优雅地解决同样的问题是避免那种困境的最好方法。</p>
</div>
<div class="paragraph">
<p>简而言之, 如果你想在 Raku 中取得更好的成绩, 最好的方法莫过于通过尽可能多的&#34;代码降临&#34;挑战, 将你的解决方案与其他 AoC 解决方案（在 Raku 和其他语言中）进行比较和对比, 并批判性地思考各种方法的优缺点。</p>
</div>
</div>
<div class="sect2">
<h3 id="_让我们一起努力吧">78.6. 让我们一起努力吧</h3>
<div class="paragraph">
<p>为了让我们更容易找到彼此的&#34; Raku 代码降临&#34;解决方案, 我创建了一个可以容纳所有解决方案的 GitHub 仓库：<a href="https://github.com/codesections/advent-of-raku-2020">codeections/advent-of-raku-2020</a>。我将有意保持这个仓库的最小化 - 如果 Raku 不是那么善于避免模板, 我会添加一个设置 AoC 解决方案的模板。但是, 考虑到 Raku 所需要的模板很少, 我计划将 Repo 简单地作为我们解决方案的主机和相关资源的链接。</p>
</div>
<div class="paragraph">
<p>如果你希望你的解决方案被包含在内, 请提交一个 PR, 添加一个 <code>$your-name</code> 文件夹, 其中包含你的解决方案（细节在 README 中）。当然, 将你的解决方案发布到 Advent of Raku repo 并不妨碍你将其发布到其他你想发布的地方, 无论是你自己的网站、<a href="https://www.reddit.com/r/rakulang/">Raku 子 reddit</a> 还是主 <a href="https://www.reddit.com/r/adventofcode/">AoC 子 reddit</a>。</p>
</div>
<div class="paragraph">
<p>请随时将你的解决方案添加到回帖中, 甚至 - 特别是！如果你不确定你的解决方案是否符合你的要求, 也可以将其添加到回帖中。- 如果你不确定你是否有时间完成所有的 AoC 挑战, 或者你是 Raku 的新手, 不确定你是否会在第一天就坚持使用这门语言, 请将你的解决方案添加到仓库中。毕竟, 所有这一切的目的都是为了共同学习, 我们可以通过将具有尽可能广泛的观点和背景的人聚集在一起来达到最好的目的。</p>
</div>
<div class="paragraph">
<p>我还注册了一个 Raku 社区的<a href="https://adventofcode.com/2020/leaderboard/private">私人排行榜</a>, 你可以通过登录, 按照这个链接, 然后输入代码 407451-52d64a27 进入（如果有必要, 我可以修改这个代码, 更安全地分发, 但我预计不会有任何问题）。尽管有&#34;排行榜&#34;这个名字, 但我认为这并不是一个竞争性的排名, 更多的是一种跟踪谁在参与的方式 - 就我个人而言, 我并不打算急于完成挑战, 也不打算在任何基于时间的指标上提高我的分数（事实上, 考虑到我的时区和我通常的日程安排, 我怀疑我是否会在大多数谜题发布几个小时后才开始）。</p>
</div>
<div class="paragraph">
<p>我很期待看到你的解决方案；我相信我们可以从彼此身上学到很多东西。我也期待着讨论我们所采取的不同方法, 不管是在 GitHub 问题上, 还是在 Raku 或 AoC 子 reddits上, 或是在 <a href="https://raku.org/community/irc">#raku</a> IRC 频道上（我会尽量关注所有这些频道）。祝大家好运, 愿我们都有一个 -Ofun Advent。
== <a href="https://raku-advent.blog/2020/12/02/day-1-perl-is-dead-long-live-perl-and-raku/">第二天 - Perl 已死, Perl 和 Raku 长存</a></p>
</div>
<div class="paragraph">
<p><a href="https://perl.org/">Perl</a>已死, 是一个完全错误的备忘录。<a href="https://www.perl.org/about.html">Perl 并没有死</a>, 只是对一些程序员来说, 它已经死了。复杂的 regexes？Sigils？有不止一种方法（<a href="https://docs.raku.org/language/glossary#TMTOWTDI">TMTOWTDI</a>）？有时候, 当程序员在野外遇到 Perl 时, 他们的反应是恐惧。他们喊道：&#34;WTF！？&#34;。但恐惧不一定是 Perl 的杀手。如果你花时间去看透 Perl 的不完美, <a href="https://www.perl.org/learn.html">走过学习曲线</a>, 就会有丰富的回报。Perl 是一种不完美的语言, 但它的实用性和表现力, 30多年来, 它帮助程序员完成了工作。</p>
</div>
<div class="paragraph">
<p>当 <a href="https://en.wikipedia.org/wiki/Larry_Wall">Larry Wall</a> <a href="https://github.com/Raku/mu/blob/master/AUTHORS">在 Perl 社区的帮助下</a><a href="https://design.raku.org/">设计</a><a href="https://raku.org/">Raku</a> 时, 他修正了 Perl 的大部分不完美, 并将 Perl 的 DNA 加倍发扬光大。Perl 重视实用主义、表现力和鞭策, Raku 也是如此。当你可以用 <a href="https://docs.raku.org/language/variables#Twigils">twigils</a>($!, %!, @!等)获得双倍的乐趣时, 为什么要停留在 sigils($@%)上呢？</p>
</div>
<div class="paragraph">
<p>然而, 对于一些程序员来说, 仅仅是看到 twigil 就会产生恐惧。就像 Perl 一样, Raku 的表达能力是一把双刃剑 - 有可能让其他程序员止步不前。Raku 程序员的 &#34;DWIM&#34;（do what I mean）可能会成为另一个程序员的 &#34;WAT！？&#34;</p>
</div>
</div>
<div class="sect2">
<h3 id="_流畅的无畏代码">78.7. 流畅的无畏代码</h3>
<div class="paragraph">
<p>我们为两个受众编写程序：人类和计算机。应该首先考虑的是人类。如果我不能在一周内理解自己的代码, 我的同事们还有什么希望？幸运的是, 我们可以帮助自己, 也可以帮助对方, 在 Raku 学习曲线上有一个平稳的旅程。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://camo.githubusercontent.com/adae2c7bc72f3b2b7480d1769cd89dddab1eb4302e4cafd7930760a584477dfb/68747470733a2f2f7065726c36616476656e742e66696c65732e776f726470726573732e636f6d2f323031352f31322f63616d656c69612d666c6f77696e672e676966" alt="68747470733a2f2f7065726c36616476656e742e66696c65732e776f726470726573732e636f6d2f323031352f31322f63616d656c69612d666c6f77696e672e676966"/></span></p>
</div>
<div class="paragraph">
<p>学习 Raku 永远不会枯燥无味, 但你上一次在学习 Raku 时遇到坎坷是什么时候？这是你帮助自己和他人的机会。你可以在你的代码中留下一条感同身受的评论, 贡献一些文档, 写一篇博文, 做一次演讲, 在 StackOverflow 上提问和回答问题等等。</p>
</div>
<div class="paragraph">
<p>编程的乐趣就是在完成事情的同时, 为自己和对方<a href="https://perl6advent.wordpress.com/2015/12/20/perl-6-christmas-have-an-appropriate-amount-of-fun/">找到流</a>。不需要 Raku 摇滚明星。</p>
</div>
</div>
<div class="sect2">
<h3 id="_在学习曲线上冲浪">78.8. 在学习曲线上冲浪</h3>
<div class="paragraph">
<p>也许你还没有开始学习 Raku？现在是将 Raku 添加到你的工具箱的最佳时机。以下是我发现的一些有用的学习资源, 我希望你也能做到。</p>
</div>
<div class="paragraph">
<p>首先, 有一个精辟简洁的 <a href="https://raku.guide/">Raku</a> 介绍, 其中包括如何安装 Raku 的说明。Raku 解释器本身也非常有用。如果你的 Raku 程序包含错误, <a href="https://perl6advent.wordpress.com/2016/12/19/fixing-flow/">Raku 通常会建议修复它们的方法</a>。</p>
</div>
<div class="paragraph">
<p>对于来自其他语言的程序员, <a href="http://www.rosettacode.org/wiki/Category:Raku">RosettaCode</a> 展示了不同语言的编码解决方案。准备好被 Raku 运算符的表现力所惊喜吧。Raku 的表现力通常会导致<a href="http://www.rosettacode.org/wiki/Last_Friday_of_each_month#Raku">更少的代码行数</a>（LLOC）。</p>
</div>
<div class="paragraph">
<p>你的第一个 Raku 程序的一个想法是翻译一个你熟悉的不同语言的程序。这里有一些从其他语言翻译到 Raku 的有用指南。<a href="https://docs.raku.org/language/5to6-nutshell">Perl</a>、<a href="https://docs.raku.org/language/py-nutshell">Python</a>、<a href="https://docs.raku.org/language/rb-nutshell">Ruby</a>、<a href="https://docs.raku.org/language/haskell-to-p6">Haskell</a> 和 <a href="https://docs.raku.org/language/js-nutshell">Javascript</a>。</p>
</div>
<div class="paragraph">
<p>关于 Raku 的书籍清单越来越多, 还有一个<a href="https://perl6book.com/">选择流程图</a>。这里是一个选择:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.learningraku.com/">Learning Raku</a></p>
</li>
<li>
<p><a href="https://www.apress.com/gp/book/9781484261088">Raku Fundamentals</a></p>
</li>
<li>
<p><a href="https://www.apress.com/gp/book/9781484262573">Raku Recipes</a></p>
</li>
<li>
<p><a href="https://www.apress.com/gp/book/9781484232279">Parsing with Perl 6 Regexes and Grammars</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>搜索与 Raku 相关的问题通常会指向 <a href="https://docs.raku.org/">docs.raku.org</a> 的官方文档或 <a href="https://stackoverflow.com/questions/tagged/raku">StackOverflow 上的 Raku 答案</a>。</p>
</div>
<div class="paragraph">
<p>当你想了解更多关于特定子主题的信息, 或者深入了解 Raku 更深层次的设计理念时, 请查看 <a href="https://www.jnthn.net/slides.html">Jonathan Worthington 的清晰演示和解释</a>。</p>
</div>
<div class="paragraph">
<p>最后, 如果你在某些事情上被卡住了, 或者只是想分享学习 Raku 的<a href="https://www.raku.org/fun/">乐趣</a>, <a href="https://www.raku.org/community/irc">freenode 上的 #raku IRC 频道</a>是友好和欢迎的。</p>
</div>
<div class="paragraph">
<p>Perl 和 Raku 都是任何程序员工具箱中的有用工具：不需要害怕, 只要记得帮助代码流动就可以了。</p>
</div>
<div class="paragraph">
<p>Perl 和 Raku 万岁。</p>
</div>
<div class="paragraph">
<p>圣诞快乐!
== <a href="https://raku-advent.blog/2020/12/03/day-3-literate-programming-with-raku/">使用 Raku 进行文化编程</a></p>
</div>
<div class="paragraph">
<p>不同的编程语言社区有不同的文化。有些更务实, 有些更理想化。有的非常强调让代码对于任何加入现有项目的人来说都是彻底可读可懂的, 有的则更喜欢写出清晰而深入的文档。</p>
</div>
<div class="paragraph">
<p>Raku, 继承了 Perl 最好的部分之一, 有一个写出很棒文档的社区。</p>
</div>
</div>
<div class="sect2">
<h3 id="_什么是文化编程">78.9. 什么是文化编程？</h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Literate_programming">文化编程</a>是对文档的另一种看法。在 Literate Programming 中, 我们不以代码为核心元素, 而是围绕它来编写文档, 我们编写的文档包含了我们程序的基本部分。通过这种方式, 我们将代码融入到我们的自然语言中, 使设计的基本思想变得清晰。通过这种方式, 我们也自然而然地开始明确思考我们的程序需要执行哪些操作来完成我们设定的任务。</p>
</div>
<div class="paragraph">
<p>文化编程不能和文档生成混为一谈, 它不仅仅是拥有一个文档齐全的程序, 文档华丽地围绕着代码, 并嵌入到代码中, 而是拥有一个关于程序的文档, 而程序本身也被嵌入其中。正如 Lewis Carroll 在《爱丽丝梦游仙境》中让疯帽子说的那样。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>你可以说&#34;我看到了吃的东西&#34;和&#34;我看到什么我就吃什么&#34;是一回事！</p>
</div>
</blockquote>
</div>
</div>
<div class="sect2">
<h3 id="_什么是_org_mode">78.10. 什么是 Org-mode？</h3>
<div class="paragraph">
<p><a href="https://orgmode.org/">Org-mode</a> 是 Emacs Lisp 解释器（可以说是文本编辑器）中的一种文本编辑模式。当启用 Org 模式时, 人们可以使用一种特殊的标记类型编辑文本, 称为 Org。与 Markdown 类似, 它支持基本的文本功能, 如标题, 基本的文本属性, 如粗体或斜体文本, 嵌入式超链接, 嵌入式代码块等。</p>
</div>
<div class="paragraph">
<p>然而, 由于 Emacs 平台的通用性, Org 模式已经扩展了一个被称为 &#34;Babel&#34; 的设施, 它允许作者执行源代码块。各种语言都是开箱即用的, 不幸的是, 尽管 Raku 已经很老了, 但仍然是一种相当年轻的语言, 不在其中。为了解决这个问题, 我写了一个名为 <a href="https://github.com/tmtvl/ob-raku">ob-raku</a> 的软件包, 它扩展了 Babel 的功能, 将 Raku 添加到支持的语言中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_ob_raku">78.11. 使用 Ob-Raku</h3>
<div class="paragraph">
<p>要在 Emacs 中使用 ob-raku, 你需要下载这个软件包（简单的从 GitHub 上克隆或者下载其中一个发布的 tar 包）, 并将其添加到 Emacs 的加载路径中。这可以通过环境变量来完成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">export EMACSLOADPATH=&#34;/path/to/ob-raku:$EMACSLOADPATH&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者你可以更改你配置文件中的路径 (可能是 ~/.emacs 或 ~/.emacs.d/init.el):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-lisp" data-lang="lisp">(add-to-list &#39;load-path &#34;/path/to/ob-raku&#34;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>添加路径后, 您可以将 Raku 添加到 Babel 可以使用的语言列表中, 就像这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-lisp" data-lang="lisp">(org-babel-do-load-languages
 &#39;org-babel-load-languages
 &#39;((c . t)
   (emacs-lisp . t)
   ; ...
   (raku . t)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>随着 Raku 加入到列表中, 你可以像这样创建一个 Raku 代码块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-lisp" data-lang="lisp">#+BEGIN_SRC raku
&#34;!dlroW ,olleH&#34;.flip
#+END_SRC</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过将光标放在代码块中或代码块的末尾, 使用菜单栏或输入 C-c C-c（这是 Emacs 的 Ctrl+c Ctrl+c 的符号）来运算代码块。运算的结果将被添加到代码块之后。</p>
</div>
</div>
<div class="sect2">
<h3 id="_连接代码块">78.12. 连接代码块</h3>
<div class="paragraph">
<p>不幸的是, 由于缺乏对 ob-raku 的会话支持, 这意味着在一个代码块中声明的函数不能在其他代码块中使用。尽管如此, 运算一个代码块的结果可以作为另一个代码块的参数, 将它们串联起来。因此, 当编辑一个 <code>.org</code> 文件时, 我们可以写以下内容。</p>
</div>
<div class="paragraph">
<p>让我们用 Raku 做一个列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-lisp" data-lang="lisp">#+NAME: nested-list
#+BEGIN_SRC raku
my @a = ((&#34;A&#34;, &#34;B&#34;), (&#34;C&#34;, &#34;D&#34;))
#+END_SRC</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们也可以包括其他语言的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-lisp" data-lang="lisp">#+NAME: elisp-list
#+BEGIN_SRC emacs-lisp :results vector
&#39;(1 2)
#+END_SRC</code></pre>
</div>
</div>
<div class="paragraph">
<p>而现在我们将使用我们刚才定义的列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-lisp" data-lang="lisp">#+NAME: crosser
#+HEADER: :var a=nested-list() b=elisp-list()
#+BEGIN_SRC raku
my @crossed = @a X @b
#+END_SRC</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你运算 crosser 块时, Babel 将运算嵌套列表和 elisp-list 块, 这两个块都返回列表, 并将它们分配给 @a 和 @b 变量。由此产生的交叉列表将在 crosser 块的下方返回。</p>
</div>
</div>
<div class="sect2">
<h3 id="_编辑说明">78.13. 编辑说明</h3>
<div class="paragraph">
<p>这篇文章是在2020年2月底起草的, 在 Daniel Sockwell 写出关于用 Pod6 进行扫盲编程的优秀<a href="https://www.codesections.com/blog/weaving-raku/">文章</a>之前。这篇文章不会提到用 Pod6 来做 Literate Programming, 而是谈谈我写的一个 Emacs 包, 在 Emacs <a href="https://orgmode.org/">Org-mode</a> 中使用 Raku。</p>
</div>
<div class="paragraph">
<p>写这篇文章的时候, Emacs 中的 Raku REPL 交互还在进行中, 多亏了 Matías Linares, 它后来得到了巩固。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论和感谢">78.14. 结论和感谢</h3>
<div class="paragraph">
<p>虽然 ob-raku 的功能仍然有限, 但任何已经使用它来编写文档的人现在都可以实现 Raku 代码, 从而显示出用我们可爱的通用语言表达的可重复的数据, 一旦会话支持落地, Org-mode 内置的纠缠设施应该会给社区带来真正的 Literate Programming。</p>
</div>
<div class="paragraph">
<p>如果没有 raku-mode 的努力, ob-raku 的创建是不可能的, 所以我想感谢每一个参与该项目的人的辛勤工作。虽然我们的社区规模不大, 但有一些充满激情的人在努力改进我们每天使用的工具, 这让我们的工作更加愉快, 从而帮助我们继续前进, 使我们的小天堂变得最好。
== <a href="https://raku-advent.blog/2020/12/04/day-4-parsing-clojure-namespaces-with-grammars/">第四天 - 使用 Raku grammar 解析 Clojure 命名空间形式</a></p>
</div>
<div class="paragraph">
<p>有一天, 我开始想, 是否有可能解析 <a href="https://clojure.org/reference/namespaces">Clojure 命名空间</a>形式, 并生成现实世界中 Clojure 项目中使用的各种命名空间的依赖关系图。虽然这是最初的动机, 但我最终还是掉进了 <a href="https://docs.raku.org/language/grammars">Raku grammar</a> 的兔子洞, 并且在学习如何使用它们的过程中度过了一段愉快的时光。我很高兴你能和我一起重温那段旅程。</p>
</div>
</div>
<div class="sect2">
<h3 id="_背景介绍_2">78.15. 背景介绍</h3>
<div class="sect3">
<h4 id="_grammar_3">78.15.1. Grammar</h4>
<div class="paragraph">
<p>非正式地说, grammar 可以被认为是一套描述语言的规则。有了这些规则, 人们就可以有意义地解析（理解或解构成语法成分）一段文字。事实证明, 这在计算机中是一项常见的任务。我们需要经常将程序从一种语言翻译成另一种语言。这就是编译器的工作。在能够翻译之前, 编译器需要知道根据语言的 grammar, 原始程序是否甚至是有效的。</p>
</div>
<div class="paragraph">
<p>虽然我们已经在理论上解释了什么是 grammar, 但 Raku grammar 帮助我们将抽象的 grammar 建模为一个编程结构（<code>grammar</code> 关键字及其相邻的助手）, 我们可以使用它来执行解析任务。理解这种区别是很重要的。</p>
</div>
<div class="paragraph">
<p>一级 <a href="https://docs.raku.org/language/grammars">grammar</a> 被认为是 Raku 的革命性功能之一。通常情况下, 你会发现 grammar 是作为一个库或一个独立的工具, 但 Raku 已经全盘接受了它, 并拥有一个强大的 grammar 实现, 使大多数解析任务变得轻而易举。</p>
</div>
</div>
<div class="sect3">
<h4 id="_clojure">78.15.2. Clojure</h4>
<div class="paragraph">
<p><a href="https://clojure.org/">Clojure</a> 是一种现代 lisp, 恰好是我在 <code>$DAYJOB</code> 中使用的语言。在大多数 Clojure 文件的顶部, 都有一个导入各种内部和外部命名空间的形式。这样我们就可以把我们的项目整齐地组织成许多独立的文件, 而不必把它们都放到一个大文件中。我们很快就会设计一个能够解析这些命名空间形式的 grammar。</p>
</div>
</div>
<div class="sect3">
<h4 id="_grammartracer">78.15.3. Grammar::Tracer</h4>
<div class="paragraph">
<p><a href="https://github.com/jnthn/grammar-debugger">Grammar::Tracer</a> 有助于找出你的 grammar 不匹配的地方, 对于调试来说是非常宝贵的。在运行这些代码示例之前, 请确保你安装了 Grammar::Tracer。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_让我们开始做饭吧">78.16. 让我们开始做饭吧</h3>
<div class="sect3">
<h4 id="_一个微不足道的例子">78.16.1. 一个微不足道的例子</h4>
<div class="paragraph">
<p>Clojure 命名空间是一个 Lisp 形式, 正如预期的那样, 它以开括号开始, 以闭括号结束。让我们为一个最简单的 Clojure 形式 - 空列表写一个 grammar。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">()</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar EmptyLispForm {
    token TOP { &lt;lparen&gt; &lt;rparen&gt; }

    token lparen { &#39;(&#39; }
    token rparen { &#39;)&#39; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是我们能写的最简单的 grammar 之一。解析总是从 TOP 标记开始, 并从那里递归到各个组件标记。我们只有两个这样的标记 <code>lparen</code> 和 <code>rparen</code>, 用来表示左圆括号和右圆括号。玩玩 <a href="https://gist.github.com/samebchase/e988e1ed9609daffaf1849c2527af51d">trivial.raku</a>, 看看我们如何解析这个。</p>
</div>
</div>
<div class="sect3">
<h4 id="_热身_用_raku_grammar_来回答一个老生常谈的面试问题">78.16.2. 热身: 用 Raku grammar 来回答一个老生常谈的面试问题</h4>
<div class="paragraph">
<p>问题：写一个检查小括号是否平衡的程序。</p>
</div>
<div class="paragraph">
<p>比如说:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">() ;; balanced
(()) ;; balanced
(()(())) ;; balanced
(()(((()))) ;; unbalanced</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar BalancedParens {
    token TOP { &lt;balanced-paren&gt; }

    token balanced-paren { &lt;lparen&gt; &lt;balanced-paren&gt;* &lt;rparen&gt; }

    token lparen { &#39;(&#39; }
    token rparen { &#39;)&#39; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>很有可能我把这段话写得太啰嗦了, 但还是只有六行相当易读的文字。</p>
</div>
<div class="paragraph">
<p>现在, 在时间压力下, 哪种可能性更大？编码堆栈并处理边缘情况, 还是使用 grammar 与 Grammar::Tracer 的威力来快速破解一个声明式解决方案。</p>
</div>
<div class="paragraph">
<p>事实证明, 我们刚刚解决了编写现实世界 grammar 中最棘手的一个方面, 那就是处理嵌套结构。作为程序员, 我们知道当我们看到嵌套结构时, 我们知道我们将不得不以某种形式处理递归。</p>
</div>
<div class="paragraph">
<p>你可以在控制台上玩玩 <a href="https://gist.github.com/samebchase/fad8108cb6daeaf8043d92a40eb29276">balanced-parens.raku</a> 程序, 观察一下 grammar 是如何解析的。</p>
</div>
<div class="paragraph">
<p>注意：事实证明, 还有<a href="https://docs.raku.org/language/regexes#Tilde_for_nesting_structures">更好的</a>方法来解析嵌套结构, 但现在这样就可以了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解析我们的第一个命名空间形式">78.16.3. 解析我们的第一个命名空间形式</h4>
<div class="paragraph">
<p>让我们试着解析一下这个简单的命名空间声明。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">;; 1   3
   |   |
;; (ns my-own.fancy.namespace)
    |                        |
;;  2                        4</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然这很简单, 但在处理更复杂的命名空间形式时, 它将是一个重要的构件。让我们把它分解成四个组件<a href="https://en.wikipedia.org/wiki/Lexical_analysis#Lexeme">词条</a>。我们可以看到 open 和 close parens, 我们看到 ns, 命名空间 my-own.fancy.namespace, 最后是 close paren。就是这样! 让我们用一个 grammar 来处理这些单独的部分。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar SimpleNs {
    token TOP { &lt;simple-ns&gt; }

    #                  1        2            3         4
    #                  |        |            |         |
    token simple-ns { &lt;lparen&gt; &lt;ns-keyword&gt; &lt;ns-name&gt; &lt;rparen&gt; }

    token ns-keyword { &#39;ns&#39; }
    token ns-name { &lt;.ns-name-component&gt;+ % &#39;.&#39; }
    token ns-name-component { ( &lt;.alnum&gt; | &#39;-&#39; )+ }

    token lparen { &#39;(&#39; }
    token rparen { &#39;)&#39; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这边我们可以看到, 我们已经将其翻译成了简单的 Raku grammar。你可以说定义 simple-ns 根本不需要, 我们可以直接把它放在 top 中, 但不管怎样。</p>
</div>
<div class="paragraph">
<p>我们需要在这里处理一下 <a href="https://en.wikipedia.org/wiki/Regular_expression">regexes</a> 的问题。在各种风味的 regexes 中, <code>+</code> 通常意味着一个或多个。<code>|</code> 的含义与你所期望的略有不同, 但你可以查看 regex <a href="https://docs.raku.org/language/regexes">文档</a>来了解 <code>|</code> 和 <code>||</code> 之间的所有细节区别。通俗地说, 我们是说一个命名空间组件, 即两个点之间的东西, 是由一个或多个字母字符或连字符组成的。现在, 如果有一个规则说一个命名空间必须以字母字符开始, 而不是以数字开始, 那么 grammar 会变得更复杂一些, 但这是一个教育学的例子, 所以我们不会太迂腐。</p>
</div>
<div class="paragraph">
<p>我希望眼尖的读者能指出一些问题。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;.alnum&gt; 是在哪里定义的, 为什么前面有一个点？</pre>
</div>
</div>
<div class="paragraph">
<p>alnum 是预定义的。它前面有一个 <code>.</code> 的原因是, 我们对捕捉每个字母不感兴趣, 因为它的层次太低。我们感兴趣的是捕获一个顶层的标记, 比如 ns-name, 而不是每个单独的字符。通过在不同的标记中添加和删除一个点来玩玩代码示例, 看看 Grammar::Tracer 的输出有什么不同。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% 是什么意思？</pre>
</div>
</div>
<div class="paragraph">
<p>这是一个非常有用的方便方法, 用来描述在一堆其他事物之间穿插的模式。例如, 我们可以有一个像 foo.bar.baz 这样的命名空间, 或者我们可以有一个 192.168.0.1 的 IPv4 地址, 其中整数用点来分隔。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token ns-name { &lt;.ns-name-component&gt;+ % &#39;.&#39; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着 ns-name 是由至少一个 ns-name-component’s（用 <code>+</code> 表示）和 <code>.</code>（用 % 表示）分开。</p>
</div>
<div class="paragraph">
<p>好了, 我想这应该可以了吧？让我们看看当我们运行这段代码的时候会发生什么吧</p>
</div>
<div class="paragraph">
<p>不, 这并不奏效。正如 Grammar::Tracer 告诉我们的那样, 我们没有考虑到 <code>ns</code> 后面的空间。在传统的编译器理论中, 有一个标记化的过程, 在这个过程中, 一些轻量级的 regexes 被用来将程序分离成它的组件词素, 并在解析器接管之前丢弃所有无关的空间。然而, 在这里我们不会这样做, 我们将在 grammar 本身中处理这个问题。现在, 可以争论这是否是一个好的决定, 但这是另一个讨论。让我们增加一些留白的空间, 看看会发生什么。在构建完整的 Clojure NS 语法时, 我让自己陷入了这样的境地：在我认为我们应该允许可选择的空白字符的地方, 我自由地使用 <code>&lt;.ws&gt;*</code> 表示零或更多的空白字符, 就像你在现实世界的程序中所期望的那样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token simple-ns { &lt;lparen&gt; &lt;ns-keyword&gt; &lt;.ws&gt; &lt;ns-name&gt; &lt;rparen&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这个小小的补充, 我们现在就可以解析简单的命名空间形式了。你可以玩玩 <a href="https://gist.github.com/samebchase/0820b9ecfdb011a9b73aedfb4ba349d1">simple-ns.raku</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_让我们让生活变得更加困难吧">78.16.4. 让我们让生活变得更加困难吧</h4>
<div class="paragraph">
<p>好了, 现在我们已经掌握了诀窍, 那么我们来看一个更<a href="https://gist.github.com/samebchase/3debbe6190eb1c8f5325ae2640840db4">现实</a>一点的命名空间形式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(ns my-amazing.module.core
  (:require [another-library.json.module :as json]
            [yet-another.http.library :as http]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个现实的命名空间形式, 我们将通过增加对 <code>:require</code> 形式的支持来解析, 在这个形式下, 其他库被导入并被赋予一个简短的昵称。</p>
</div>
<div class="paragraph">
<p>这能做到吗？当然可以。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar RealisticNs {
    token TOP { &lt;realistic-ns&gt; }

    token realistic-ns { &lt;lparen&gt;
                           &lt;ns-keyword&gt; &lt;.ws&gt; &lt;ns-name&gt; &lt;.ws&gt;
                           &lt;require-form&gt;
                         &lt;rparen&gt; }

    token ns-keyword { &#39;ns&#39; }

    token ns-name { &lt;.ns-name-component&gt;+ % &#39;.&#39; }
    token ns-name-component { ( &lt;.alnum&gt; | &#39;-&#39; )+ }

    token require-form { &lt;lparen&gt;
                           &lt;require-keyword&gt; &lt;ws&gt;? &lt;ns-imports&gt;
                         &lt;rparen&gt; }

    token require-keyword { &#39;:require&#39; }

    token ns-imports { &lt;ns-import&gt;+ % &lt;.ws&gt; }

    token ns-import { &lt;lsquare&gt;
                        &lt;ns-name&gt; &lt;.ws&gt; &#39;:as&#39; &lt;.ws&gt; &lt;ns-nickname&gt;
                      &lt;rsquare&gt; }

    token ns-nickname { &lt;.alnum&gt;+ }

    token lsquare { &#39;[&#39; }
    token rsquare { &#39;]&#39; }

    token lparen { &#39;(&#39; }
    token rparen { &#39;)&#39; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>目前还没有太可怕的东西。我们可以看看 grammar 是如何发展的。在顶层, 在 realistic-ns 中, 我们增加了一个额外的 token, 叫做 <code>&lt;require-form&gt;</code>, 我们稍后将细节具体化。我们可以通过这种方式来管理复杂性, 这样我们就有能力根据需要放大和缩小细节。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用解析后的数据">78.16.5. 使用解析后的数据</h4>
<div class="paragraph">
<p>现在我们已经能够解析数据了, 我们需要利用我们解析的数据。这就是 Actions 的作用。</p>
</div>
<div class="paragraph">
<p>当我们进行 RealisticNs.parse(…​) 时, 会返回一个与 RealisticNs grammar 对应的 Match 对象。虽然我们可以通过查询该对象来获取我们所需要的数据片段, 但使用 Action 来建立我们真正感兴趣的数据就不那么麻烦了。</p>
</div>
<div class="paragraph">
<p>给定, 一个命名空间, 我们要提取出来。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Namespace name
Imported namespaces
Imported namespace nicknames</pre>
</div>
</div>
<div class="paragraph">
<p>简单的原则是, 对于我们感兴趣的 token, 我们创建一个同名的 Action 方法。当 Match 对象正在建立时, 当 token 被匹配时, token 的 Action 方法就会运行。Grammar 是自上而下解析的, 但数据是由 Action 方法以自下而上的方式建立起来的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class RealisticNsActions {
    has $!ns-name;
    has $!imported-namespaces = SetHash.new;
    has $!ns-nicknames = SetHash.new;

    method TOP($/) {
        make {
            ns-name =&gt; $!ns-name,
            ns-imports =&gt; $!imported-namespaces,
            ns-nicknames =&gt; $!ns-nicknames
        }
    }

    method ns-name($/) {
        $!ns-name = $/.Str;
    }

    method imported-ns-name($/) {
        $!imported-namespaces{$/.Str}++;
    }

    method ns-nickname($/) {
        $!ns-nicknames{$/.Str}++;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, 我们创建了一个 RealisticNsActions 类, 并创建了一些方法, 在这些方法中, 我们想对与之相关的数据做一些事情。我们根本不需要触及语法定义（这让它保持了干净）。我们需要做的唯一额外的事情, 就是在解析时, 我们需要像这样传递 Actions 对象, 它指示 Raku 在看到这些标记时运行这些标记 Action 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN() {
    my $s = RealisticNs.parse(slurp(&#34;realistic.clj&#34;), actions =&gt; RealisticNsActions.new);
    say $s.made;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在一个 Actions 类中, TOP 方法可以用来生成最终的 payload, 我们可以通过调用 make 方法来访问。关于 make 和 made 的更多信息, 官方的 Raku grammar 教程已经说得很清楚了。简而言之, 使用 make 创建的任意有效载荷可以通过使用 made 来访问。</p>
</div>
<div class="paragraph">
<p>当我们运行这个程序时, 我们看到的是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{ns-imports =&gt; SetHash(another-library.json.module
                       yet-another.http.library),
 ns-name =&gt; my-amazing.module.core,
 ns-nicknames =&gt; SetHash(http json)}</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如预期的那样, 我们可以看到解析后的数据被创建在一个漂亮的 HashMap 中, 但是如果知道 yet-another.http.library 在命名空间中的昵称是 http, 那不是更好吗？这就是我们在刚写的 Actions 类中遇到的一个设计问题。我们在一个较低的层次上构建了有效载荷。</p>
</div>
<div class="paragraph">
<p>我们需要更多的结构来获得我们想要的 namespace → namespace-nickname 映射。快速浏览一下语法告诉我们, 我们可以在 ns-import 级别找到它, 因为它的子标记是 import-ns-name 和 ns-nickname, 而这两个是我们想要的数据片段。</p>
</div>
<div class="paragraph">
<p>我们为 ns-import 写一个 Action 方法吧!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class RealisticNsActions {
    has $!ns-name;
    has $!imported-namespaces = SetHash.new;
    has %!ns-nicknames;

    method TOP($/) {
        make {
            ns-name =&gt; $!ns-name,
            ns-imports =&gt; $!imported-namespaces,
            ns-nicknames =&gt; %!ns-nicknames
        }
    }

    method ns-name($/) {
        $!ns-name = $/.Str;
    }

    method ns-import($match) {
        #say $match;

        my $imported-ns-name = $match&lt;imported-ns-name&gt;.Str;
        my $ns-nickname = $match&lt;ns-nickname&gt;.Str;

        $!imported-namespaces{$imported-ns-name}++;
        %!ns-nicknames{$imported-ns-name} = $ns-nickname;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就导致了输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{ns-imports =&gt; SetHash(another-library.json.module
                       yet-another.http.library),
 ns-name =&gt; my-amazing.module.core,
 ns-nicknames =&gt; {another-library.json.module =&gt; json,
                  yet-another.http.library =&gt; http}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们已经掌握了所有我们需要的信息。你可以玩玩 <a href="https://gist.github.com/samebchase/82df3d17341898e054828ea1f7728f87">realistic-ns-with-actions.raku</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_在_action_类中匹配对象">78.16.6. 在 Action 类中匹配对象</h4>
<div class="paragraph">
<p>成功解析的结果是一个 <a href="https://docs.raku.org/type/Match">Match</a> 对象。这包含了整个层级化的解析结构。</p>
</div>
<div class="paragraph">
<p>无论我们在 ns-import 方法中做了什么, 我们都可以在更高的层次上做, 但该层次的 Match 对象需要更多的查询。这是因为该方法会将其&#34;视图&#34;接收到完整的 Match 对象中, 即 TOP 方法会有整个 Match 对象, 而 ns-import 方法会有一个更受限制的视图, 利用这个视图我们可以很容易地提取出 import-ns-name 和 ns-nickname。这可能不会马上有意义, 但在与 Match 打交道一段时间后, 你会发现在尽可能低的层次上提取出有用的信息是多么的有意义, 这样可以更容易地进行查询。在最上层, 为了提取出 ns-nickname, 我们不得不查询 realistic-ns → require-form → ns-imports → ns-import → ns-nickname, 这至少可以说是很麻烦的, 而且因为有多个这样的情况, 所以会有一个 ns-import 的数组。</p>
</div>
<div class="paragraph">
<p>为了直观的看到每个 Action 方法中发生了什么, 可以适当的添加一个 <code>say $match</code> 或者 <code>say $/</code>, 看看那个层次的结构是什么。</p>
</div>
</div>
<div class="sect3">
<h4 id="_开发风格">78.16.7. 开发风格</h4>
<div class="paragraph">
<p>Raku 目前还没有 Lisp 程序员习惯的全功能 REPL 环境。这只是一些需要解决的问题。</p>
</div>
<div class="paragraph">
<p>Raku REPL 可以用来快速测试简短的单行代码片段, 主要是作为最简单的安全检查, 但对于任何比这更复杂的东西, 它都会变得笨重。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题, 我使用了一种 TDD 方法, 我将一个真实世界的 Clojure 项目, 并在所有的 Clojure 文件上运行（快速发展的）语法。每一个&#34;正确&#34;的变化, 解析的文件数量就会增加, 而每一个&#34;错误&#34;的变化, 解析的文件数量就会减少。</p>
</div>
</div>
<div class="sect3">
<h4 id="_接下来的步骤">78.16.8. 接下来的步骤</h4>
<div class="paragraph">
<p>有了我们目前已经解决的问题, 要解析现实世界中的 Clojure 命名空间声明也不是什么难事。例如, 我们已经添加了对使用 :require 形式导入 Clojure 命名空间的支持。同样, 我们也可以添加对 :import 形式的支持, 我们使用该形式导入 Java 库。同样的迭代方法可以用来解析越来越复杂的代码。</p>
</div>
<div class="paragraph">
<p>最后的 <a href="https://gist.github.com/samebchase/f6fbb81a2273fe86dbc129488ed5f842">Clojure NS grammar</a>, 我已经能够用它来解析数百个 Clojure 文件。使用这个 grammar 来生成依赖图是一个留待日后再谈的故事。你可能会注意到, 我必须处理大量的 grammar 变化和可选的空白。我相信我们已经将实现的核心提取到了我们已经详细讨论过的易于理解的 grammar 中。</p>
</div>
</div>
<div class="sect3">
<h4 id="_注意事项还有几个大的">78.16.9. 注意事项（还有几个大的）</h4>
<div class="paragraph">
<p>有可能当一个语法被不恰当地指定时, 程序就会挂掉。发生的情况类似于<a href="https://www.regular-expressions.info/catastrophic.html">病态的回溯</a>。这并不是只有 Raku grammar, 或者一般的 grammar 才会出现这种情况。一个写得不好的 regex 也会有同样的效果, 所以在把一个 regex/grammar 放到一个高危应用的热路径上之前, 必须意识到这种偶然性。有一些高调的死后案例讨论了写得不好的 regex 是如何让网络应用瘫痪的。</p>
</div>
<div class="paragraph">
<p>在处理 regex 时, 通常的建议是避免使用 .*（任何字符的任何数字）, 而在与之匹配的内容上要有更多的限制, 这个建议对于 grammar 也是适用的。尽可能的限制性, 在不可避免的时候放松某些东西。在最终的代码中, 我能够解析上百个真实的 Clojure 命名空间声明, 但在每隔一段时间演化 grammar 的过程中, 我确实遇到了几次这种行为, 通过按照所述调整 grammar 来补救。能够可靠地修复它, 是很难的, 但时间久了, 你就能直观地做到这一点。</p>
</div>
<div class="paragraph">
<p>在生产系统中, 另一个需要警惕的是, 即使语法规范得很好, 一个恶意用户会不会制作一个触发这种病态行为的输入？只要有足够的动机, 任何事情都有可能发生, 所以所有的赌注都是不存在的。</p>
</div>
<div class="paragraph">
<p>Grammar 比正则表达式更强大（https://en.wikipedia.org/wiki/Chomsky_hierarchy）。传统的警告, 不要用 regexes 来<a href="https://stackoverflow.com/a/1732454">解析它不够强大的东西</a>, 在这里并不适用, 假设 grammar 写得很好, 但一个写得很好的 grammar 就像一个无 bug 的程序一样难以捉摸。我指的不是语言原始设计中的 grammar, 而是你为了解析某件事情而写的 grammar。如果不能正确处理角句, 不能充分处理错误, 你最终会得到一个脆弱的、令人沮丧的、难以调试的程序。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_结束语_2">78.17. 结束语</h3>
<div class="paragraph">
<p>现在我们已经到了尾声, 我希望这又是一篇漂浮在互联网上的文章, 它能帮助初出茅庐的 Rakoons(Rakoons 能飞吗?思考)了解 Raku grammar 如何成为一个强大的工具, 来解决任何可能遇到的解析任务。</p>
</div>
</div>
<div class="sect2">
<h3 id="_参考文献_4">78.18. 参考文献</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.raku.org/language/grammars">Grammar 教程</a>在帮助我掌握 Raku grammar 方面是非常宝贵的。这篇文章也可以看作是同样风格的另类教程。</p>
</li>
<li>
<p><a href="https://jeffreykegler.github.io/personal/timeline_v3">Parsing: a timeline</a> 是一篇很长的文章, 但完全值得一读。</p>
</li>
<li>
<p><a href="https://perl6advent.wordpress.com/2011/12/02/grammartracer-and-grammardebugger/">Grammar::Tracer</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_片尾字幕">78.19. 片尾字幕</h3>
<div class="ulist">
<ul>
<li>
<p>多年来所有的 Raku 设计者和贡献者。</p>
</li>
<li>
<p>Jonathan Worthington, 感谢他创建了 Grammar::Tracer。</p>
</li>
<li>
<p>所有友好的 Rakoons (@JJ), 他们帮助审核了本文。
== <a href="https://raku-advent.blog/2020/12/05/raku-pakku/">第五天 - Raku 和 Pakku</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_兴趣爱好">78.20. 兴趣爱好</h3>
<div class="paragraph">
<p>有一天, 我一觉醒来, 决定要把学习编程作为一种爱好。对于一个除了写过几个 Bash 脚本之外并不了解的人来说, 像函数式编程、面向对象编程甚至是类这个词本身就很神秘。</p>
</div>
</div>
<div class="sect2">
<h3 id="_迷茫">78.21. 迷茫</h3>
<div class="paragraph">
<p>当开始做研究以寻找从哪里开始着手时, 很快我就迷失在网上大量的信息中, 但我还是想开始学习, 是时候选择一门编程语言了。</p>
</div>
<div class="paragraph">
<p>编程语言那么多, 决定学哪种语言对我来说是个难题, 主要是根据技术知识来比较语言是不可能的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_一个天真的计划_但是成功了">78.22. 一个天真的计划, 但是成功了!</h3>
<div class="paragraph">
<p>我决定尽可能多地阅读不同语言的代码, 试图解决同一个问题, 并记录下哪些代码容易推理, 我喜欢什么, 不喜欢什么。<a href="http://rosettacode.org/">罗塞塔代码</a>让我很容易比较不同语言对同一问题的解决方案。</p>
</div>
<div class="paragraph">
<p>我开始看那里的代码, 顺着列表阅读不同语言的代码, 不关注语言名称, 只关注代码。所有的代码看起来都很好, 大多数代码在我看来都是这样或那样的相似。</p>
</div>
<div class="paragraph">
<p>在列表深处, 我注意到了一些乍一看很奇怪的代码。&#34;那是什么！&#34; 我问自己。盯着看了几秒钟, 再看第二眼, 代码看起来不奇怪了, 但现在看起来很奇怪! &#34;这些冒号和箭头是干什么的！&#34; 我又问自己。第三次看代码, 不知道为什么, 代码看起来很熟悉, 然后很漂亮, 很容易上手（即使不知道冒号和箭头是干什么的）。我很想知道那个语言的名字, 是 Raku! (其实<a href="https://github.com/Raku/problem-solving/issues/81">当时是 Perl6</a> :-))</p>
</div>
<div class="paragraph">
<p>这种模式重复着不同问题的解决方法, 大多数语言在某一方面看起来都很相似, 只有 Raku 代码在我看来是很好很吸引人的。于是, 我决定学习 Raku, 并着手阅读<a href="https://learnxinyminutes.com/docs/raku/">《Y 分钟学会 Raku》</a>和<a href="https://docs.raku.org/">文档</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_pakku">78.23. Pakku</h3>
<div class="sect3">
<h4 id="_ofun">78.23.1. Ofun</h4>
<div class="paragraph">
<p>享受着目前在 Raku 中学到的东西, 我想写一个包管理器, 既好玩又好学。对于像我这样的编程新手来说, 编写一个包管理器是很有挑战性的, 但我还是开始了, 因为我知道这会很有趣。在一天结束的时候, Raku 是 - 好玩的。</p>
</div>
<div class="paragraph">
<p>我研究了 <a href="https://github.com/tadzik/panda">Panda</a> 和 <a href="https://github.com/ugexe/zef">Zef</a> 包管理器, 以了解 Raku 的包管理器需要什么。Panda 简单易懂, 但也被淘汰了（panda 已经被认为过时了一段时间）。Zef 看起来更新了, 功能也很完整, 但对我来说并不容易理解。检查 Panda 和 Zef 让我知道了我需要做什么。</p>
</div>
</div>
<div class="sect3">
<h4 id="_了解_pakku">78.23.2. 了解 Pakku</h4>
<div class="paragraph">
<p>Raku 的软件包管理器, 设计时考虑到了简单性。</p>
</div>
<div class="sect4">
<h5 id="_camelia">Camelia</h5>
<div class="paragraph">
<p>我希望 Pakku 能像 Raku 的吉祥物 <a href="https://raw.githubusercontent.com/Raku/mu/master/misc/camelia.txt">Camelia</a> 一样, 简单、快速、轻盈、多彩。</p>
</div>
</div>
<div class="sect4">
<h5 id="_连字符">连字符</h5>
<div class="paragraph">
<p>对我来说, 运行命令就像和程序交流一样, 所以我希望发给程序的命令尽可能地接近人们用来互相交流的句子, 没有连字符, 没有双连字符…​…​</p>
</div>
<div class="paragraph">
<p>例如, 与其这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">program delete --from=somewhere --recurse dirname</code></pre>
</div>
</div>
<div class="paragraph">
<p>我不如这样写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">program delete from somewhere recurse dirname</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且程序应该负责识别命令、子命令、子命令的选项；还有 DWIM, 比如上面的 <code>dirname</code> 换成 <code>recurse</code>, 程序应该把第一个 <code>recurse</code> 解析为选项, 最后一个解析为要删除的目录, 并覆盖其他边缘情况。</p>
</div>
<div class="paragraph">
<p>使用 Raku 的 <a href="https://docs.raku.org/routine/MAIN">MAIN</a> 命令行参数我是无法实现的, 幸好 Raku 的 <a href="https://docs.raku.org/language/grammar_tutorial">Grammar</a> 让这一点变得简单。</p>
</div>
<div class="paragraph">
<p>这些是 Pakku 命令的例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">pakku add to site MyModule
pakku list repo site details
pakku pretty please dont remove from home MyModule</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_pipeline">Pipeline</h5>
<div class="paragraph">
<p>Pakku 命令的处理方式简单易懂, 就像流水线中的各个阶段。</p>
</div>
<div class="paragraph">
<p>让我们来看看 Pakku 是如何安装一个模块的。</p>
</div>
<div class="paragraph">
<p><strong>阶段1</strong></p>
</div>
<div class="paragraph">
<p>1- Pakku 收到要安装的模块规格（模块名称或本地路径）
2- 检查指定模块是否已经安装（满足）或需要强制安装
3- 尽量满足规范, 这意味着获取模块的元信息, 如果需要的话, 按照正确的顺序进行安装</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@spec
  ==&gt; map( -&gt; $spec { Spec.new: $spec } )
  ==&gt; grep( -&gt; $spec { $force or not self.satisfied: :$spec } )
  ==&gt; map( -&gt; $spec { self.satisfy: :$spec } )
  ==&gt; map( -&gt; $dep {
    my @dep = self.get-deps( $dep, :$deps );
    @dep.append: $dep unless $deps ~~ &lt;only&gt;;
    @dep;
  } )
  ...
  ...
  ==&gt; my @meta;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>阶段2</strong></p>
</div>
<div class="paragraph">
<p>1- 下载分发档案并解压
2- 准备好取回的分发目录, 由 <a href="https://docs.raku.org/type/CompUnit::Repository::Installation">CompUnit::Repository::Installation</a> 进行安装</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@meta
    ==&gt; map( -&gt; $meta {
      my $prefix = $!fetcher.fetch: $meta.recman-src;
      $meta.to-dist: :$prefix;
    } )
    ==&gt; my @dist;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>阶段3</strong></p>
</div>
<div class="paragraph">
<p>1- 如果需要的话, 建立分发
2- 测试分发, 如果需要
3- 添加分发</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">  @dist
    ==&gt; map( -&gt; $dist {
      $!builder.build: :$dist if $build;
      $!tester.test:   :$dist if $test;
      $*repo.add: :$dist, :$force     unless $!dont;
      🦋 &#34;ADD: ｢$dist｣&#34; unless $!dont;
    } );</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可能已经注意到, 我多次使用了 <a href="https://docs.raku.org/routine/==%3E">=⇒</a> feed 操作符（将左边的结果作为最后一个参数传递给下一个（右边）例程）。我使用它的原因是它很适合这个管道类比。</p>
</div>
</div>
<div class="sect4">
<h5 id="_pakku_输出">Pakku 输出</h5>
<div class="paragraph">
<p>Pakku 日志有7层</p>
</div>
<div class="ulist">
<ul>
<li>
<p>0（silent）--没有任何输出。</p>
</li>
<li>
<p>1 (trace) 🤓 - 如果你想看所有的东西。</p>
</li>
<li>
<p>2 (debug) 🐞 - 调试一些问题。</p>
</li>
<li>
<p>3 (info ) 🦋 – Camelia delivers important things</p>
</li>
<li>
<p>4（warn）🔔 - 只有当一些警告发生时才会出现。</p>
</li>
<li>
<p>5 (error) ❌ - 当错误是你所关心的!</p>
</li>
<li>
<p>6 (fatal) 💀  - 你可能不喜欢在运行 Pakku 时看到这个, 我也不喜欢。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>日志符号和信息的颜色可以在 <code>pakku.cnf</code> 文件中进行修改和自定义。</p>
</div>
<div class="paragraph">
<p>你可能会看到的日志信息示例及其意义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">🦋 PRC: ｢ ... ｣ → Start processing...
🐞 SPC: ｢ ... ｣ → Processing spec
🐞 MTA: ｢ ... ｣ → Processing meta
🤓 FTC: ｢ ... ｣ → Fetch URL
🐞 BLD: ｢ ... ｣ → Start building dist
🦋 BLT: ｢ ... ｣ → Built dist successfully
🐞 TST: ｢ ... ｣ → Start testing dist
🦋 TST: ｢ ... ｣ → Tested dist successfully
🦋 ADD: ｢ ... ｣ → Added dist successfully
💀 MTA: ｢ ... ｣ → No valid meta obtained for spec
💀 BLD: ｢ ... ｣ → Bulding dist failed
💀 TST: ｢ ... ｣ → Testing dist failed
💀 CNF: ｢ ... ｣ → Config file error
💀 CMD: ｢ ... ｣ → Could not understand command</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_时间机器wip">78.23.3. 时间机器（WIP）</h4>
<div class="paragraph">
<p>Pakku timemachine 不仅可以穿越时空到未来, 还可以穿越到过去。</p>
</div>
<div class="paragraph">
<p>Pakku timemachine 可以保存乐库的当前状态, 存储每个 Raku 安装的发行版列表, 并且可以在需要的时候随时回到这个状态（例如在重新安装 Raku 之后）。</p>
</div>
<div class="paragraph">
<p>这项工作仍在进行中, 不过当你读到这里时, 这项功能可能已经准备就绪。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># list available events
pakku timemachine

# save the current repos state to event name &#34;xmas&#34;
pakku timemachine event xmas

# restore the repo state (by removing or adding distributions)
pakku timemachine travel yesterday
pakku timemachine travel 12012020</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_截图">78.23.4. 截图</h4>
<div class="paragraph">
<p>列表中详细介绍了分发的情况</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://user-images.githubusercontent.com/28023796/99514129-13432c00-2994-11eb-9c88-618e6448fdec.png" alt="99514129 13432c00 2994 11eb 9c88 618e6448fdec"/>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_试试_pakku">78.23.5. 试试 Pakku</h4>
<div class="paragraph">
<p>Pakku 目前运行在 Linux 系统上（未来将支持更多的操作系统）, 试试吧, 你可能会喜欢它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_谢谢你">78.23.6. 谢谢你</h4>
<div class="paragraph">
<p>感谢您的阅读。祝您使用 Raku 愉快!
== <a href="https://raku-advent.blog/2020/12/06/day-6-declarative-apis-easy-peasy-with-raku/">第六天 - 声明式 API, 用 Raku 轻松搞定</a></p>
</div>
<div class="paragraph">
<p><a href="https://raku.org/">Raku</a> 的 API 往往很容易阅读, 例如, 命名的参数减轻了对方法调用中参数顺序的记忆。</p>
</div>
<div class="paragraph">
<p>但有时一个库的作者会在此基础上制作出特别漂亮的声明式 API。其中一个例子是 <a href="https://cro.services/">Cro</a>, 一个用于编写基于 HTTP 的服务的框架, 它允许你写一些东西, 如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $application = route {
    get -&gt; &#39;greet&#39;, $name {
        content &#39;text/plain&#39;, &#34;Hello, $name!&#34;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>来声明你的路由, 也就是 Cro 为你调用的回调, 当用户请求符合路由引入的模式的 URL 时, Cro 会为你调用哪些回调, 在这个例子中, /greet/fido 等等。</p>
</div>
<div class="paragraph">
<p>今天, 我们将探讨使这种声明式 API 工作的机制, 也就是自然读取的 API 和尽可能少使用样板代码的 API。</p>
</div>
<div class="paragraph">
<p>我们将探讨如何为你编写的库启用类似的接口。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_声明式_api_基础">78.24. 声明式 API 基础</h3>
<div class="paragraph">
<p>上面的例子依赖于几个主要的想法。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>像 <code>route</code>、<code>get</code> 和 <code>content</code> 这样的裸词只是名称相同的函数, 你可以简单地用它们的名称和空格来调用它们。语句的其他部分被解释为这些函数的参数。</p>
</li>
<li>
<p>在 <code>route { …​ }</code> 中, <code>{ …​ }</code> 是一个 Block, 也就是像函数一样的一段代码。</p>
</li>
<li>
<p>同样, <code>→ &#39;greet&#39;, $name { …​ }</code> 是一个块, 这个块有一个显式<a href="https://docs.raku.org/type/Signature">签名</a>(&#39;greet&#39;, $name) 部分。库代码可以反省这个签名, 也就是找到参数的名称 ($name) 和常量字符串 &#39;greet&#39; 的值。</p>
</li>
<li>
<p>还有一种无形的机制, 将 get 与外面的 <code>route { …​ }</code> 块绑定。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最后一点需要再解释一下。在 Cro 中, 你可以有多个独立的 <code>route { }</code> 块, 像这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $app1 = route {
    get -&gt; &#39;meet&#39; { content &#39;text/plain&#39;, &#39;Nice to see you&#39; }
}
my $app2 = route {
    get -&gt; &#39;greet&#39; { content &#39;text/plain&#39;, &#39;Oh hai&#39; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cro 如何知道 <code>meet</code> 回调属于 <code>$app1</code>, <code>greet</code> 属于 <code>$app2</code>？<code>route</code> 子程序需要调用传递给它的块来找出它声明的回调, 所以它需要向块中注入某种上下文。做到这一点的方法是通过<a href="https://docs.raku.org/language/variables#index-entry-Dynamically_scoped_variables">动态作用域变量</a>。</p>
</div>
<div class="paragraph">
<p>在 Raku 中, 你可以通过在 <a href="https://docs.raku.org/language/glossary#index-entry-Sigil">sigil</a> 后面声明一个带 * 的变量来实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub outer(&amp;callback) {
    my @*DYNAMIC;
    callback();
    return @*DYNAMIC.list;
}
sub inner() {
    @*DYNAMIC.push(42);
}
say outer(&amp;inner);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 sub outer 声明了一个动态变量 @*DYNAMIC。在 outer 完成之前, 所有被调用的都可以看到这个变量, 包括 inner 的内部, 它被绑定到参数 <code>&amp;callback</code> 上。因此, 代码打印 <code>[42]</code>。</p>
</div>
<div class="paragraph">
<p>如果你看看 <a href="https://github.com/croservices/cro-http/blob/5e636321ef16a3abae2927eb3948b19eb4de3d02/lib/Cro/HTTP/Router.pm6#L606">Cro::HTTP 对 sub route 的定义</a>, 你可以看到它使用的技巧基本相同, 只是用一个空的 RouteSet 而不是一个空的数组来初始化动态变量。</p>
</div>
</div>
<div class="sect2">
<h3 id="_实用化">78.25. 实用化</h3>
<div class="paragraph">
<p>假设你正在写一个观察目录树的库, 你可以配置它将飞翔同步到另一个当地, 或者根据某些属性自动删除它们, 或者当某些文件改变时调用你的代码。</p>
</div>
<div class="paragraph">
<p>你想提供一个额外的厉害的, 像这样的声明式 API。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $syncer = directory &#39;Documents&#39;, {
    watch name =&gt; /.*/, -&gt; $file { say &#34;File $file changed&#34; }
    delete name =&gt; /\.swp/;
    delete name =&gt; /\.swo/;
    delete age_days =&gt; * &gt; 5;
    sync extension =&gt; &#39;txt&#39;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要让这个例子编译, 你只需要用适当的签名声明 directory, delete, sync 和 watch 这四个函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub delete(*%conditions) {}
sub sync(*%conditions) {}
sub watch(&amp;callback, *%conditions) {}

sub directory(Str $path, &amp;callback) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然, 你还需要在一个数据结构中捕获条件和回调, 这样你的假设库就可以用它做一些事情。</p>
</div>
<div class="paragraph">
<p>这可以是一个用于存储动作类型的枚举, 以及一个用于条件和可选回调的类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Sync::Action &lt;Delete Sync Watch&gt;;
class ConditionalRule {
    has Sync::Action $.action is required;
    has %.conditions;
    has &amp;.callback;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>加上一个存储目录和 ConditionalRule 对象列表的类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Sync::Spec {
    has Str $.path;
    has ConditionalRule @.rules;
    method add(ConditionalRule $r) { @.rules.append: $r }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后, 我们需要将开始的四个函数具体化。directory 创建一个 Sync::Spec 对象, 然后调用它的回调。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub directory(Str $path, &amp;callback) {
    my $*SYNC = Sync::Spec.new(:$path);
    callback;
    return $*SYNC;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其他三个需要创建新的 ConditionalRule 对象, 并将其添加到 $*SYNC 中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub delete(*%conditions) {
    $*SYNC.add: ConditionalRule.new:
        :action(Sync::Action::Delete),
        :%conditions,
}
sub sync(*%conditions) {
    $*SYNC.add: ConditionalRule.new:
        :action(Sync::Action::Sync),
        :%conditions,
}
sub watch(&amp;callback, *%conditions) {
    $*SYNC.add: ConditionalRule.new:
        :action(Sync::Action::Sync),
        :%conditions,
        :&amp;callback,
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个恼人的模板, 但它允许漂亮界面的用户放弃所有的模板。</p>
</div>
<div class="paragraph">
<p>一旦你把所有这些拼凑在一起, directory 就会返回一个 Sync::Spec 对象, 这个对象包含了所有必要的知识, 为假设的 syncer 库提供燃料。</p>
</div>
<div class="paragraph">
<p>剩下的就是真正实现它了。这个任务远远超出了本文的范围 - 留给读者去做, 如果你选择了这些的话。</p>
</div>
<div class="paragraph">
<p>但是, 等等, 我们还没有完全完成, 因为当有人滥用我们整洁的小 API 时。如果你只是在目录块之外调用 delete, 你就会得到 Dynamic variable $*SYNC not found 的错误信息, 这并不值得我们向往的精彩。</p>
</div>
<div class="paragraph">
<p>幸运的是, 我们可以很容易地改进这一点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub delete(*%conditions) {
    die &#39;delete outside a directory { } block&#39;
        unless defined $*SYNC;
    $*SYNC.add: ConditionalRule.new:
        :action(Sync::Action::Delete),
        :%conditions,
}</code></pre>
</div>
</div>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>并类推其他三个动作。同样是更多的模板, 符合 Raku 代表用户折磨实现者的座右铭。
== <a href="https://raku-advent.blog/2020/12/07/mixing-bash-and-raku-using-sparrow/">第七天 - 使用 Sparrow 混合 Bash 和 Raku</a></p>
</li>
</ol>
</div>
<div class="paragraph">
<p><a href="https://github.com/melezhik/Sparrow6">Sparrow</a> 是一个 <a href="http://raku.org/">Raku</a> 自动化框架, 它可以很容易地与许多编程语言集成。所以, 如果你来自没有 Raku 语言 - 欢迎你。</p>
</div>
<div class="paragraph">
<p>在这篇文章中, 我将向你展示一个可以有效地混合 <a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">Bash</a> 脚本和 Raku 语言使用 Sparrow。</p>
</div>
<div class="paragraph">
<p>Sparrow 的理念是 - 选择最适合你的领域的语言, 让 Raku 在高层次上协调你的代码。</p>
</div>
<div class="paragraph">
<p>让我们开始吧。</p>
</div>
</div>
<div class="sect2">
<h3 id="_安装_sparrow">78.26. 安装 Sparrow</h3>
<div class="paragraph">
<p>Sparrow 作为一个 Raku 模块, 所以必须使用 <a href="https://github.com/ugexe/zef">zef</a> 包管理器来安装它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">zef install --/test Sparrow6</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦安装了 Sparrow, 你会在 PATH 中得到一个 s6 实用程序, 这样你就可以执行与 Sparrow 相关的任务。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">s6 --help</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_创建一个_bash_任务">78.27. 创建一个 Bash 任务</h3>
<div class="paragraph">
<p>你先用一个 Bash 脚本做一些有用的工作。要求是把脚本命名为 task.bash。</p>
</div>
<div class="paragraph">
<p>让我们从一个简单的例子开始。</p>
</div>
<div class="paragraph">
<p><strong>task.bash</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">echo &#34;hello from Bash&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在让我们用 Sparrow 运行这个脚本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">s6 --task-run .
[sparrowtask] :: run sparrow task .
[sparrowtask] :: run thing .
[.] :: hello from Bash</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以脚本执行后, 我们可以看到一个输出。</p>
</div>
<div class="paragraph">
<p>如果就此打住就太傻了, 有什么理由只通过 Sparrow 来运行 Bash 脚本呢？</p>
</div>
<div class="paragraph">
<p>最 exiting 的部分来了。继续看下去。</p>
</div>
</div>
<div class="sect2">
<h3 id="_处理输入参数">78.28. 处理输入参数</h3>
<div class="paragraph">
<p>比如说, 我们想把一些输入参数传递给一个 Bash 脚本。用 Bash 处理输入参数可能会很麻烦, 但用 Sparrow 就不会。让我们更新一下我们的脚本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">echo &#34;hello from $(config language)&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们可以带着参数运行这个脚本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">s6 --task-run .@language=Bash</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">[sparrowtask] :: run sparrow task .@language=Bash
[sparrowtask] :: run thing .
[.] :: hello from Bash</code></pre>
</div>
</div>
<div class="paragraph">
<p>简单吗？我们不需要在 Bash 中创建参数解析器。它默认是由 Sparrow 来完成的！我们甚至可以为输入参数设置默认值（如果没有明确地传递任何参数, 则应用默认值）。</p>
</div>
<div class="paragraph">
<p>我们甚至可以为输入参数设置默认值（如果没有明确地传递任何参数, 就会被应用）。</p>
</div>
<div class="paragraph">
<p>让我们创建一个名为 config.yaml 的 <a href="https://yaml.org/">YAML</a> 格式文件, 它将包含所有的默认参数。</p>
</div>
<div class="paragraph">
<p><strong>config.yaml</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">language: Shell</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后再运行这个脚本, 不需要参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">s6 --task-run .</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">[sparrowtask] :: run sparrow task .
[sparrowtask] :: run thing .
[.] :: hello from Shell</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以默认参数 Shell 是从 config.yaml 文件中应用的。</p>
</div>
<div class="paragraph">
<p>要通过命令行传递多个参数, 请使用逗号分隔符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">s6 --task-run .@language=Raku,version=2020.11</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_将_bash_脚本作为_raku_函数运行">78.29. 将 Bash 脚本作为 Raku 函数运行</h3>
<div class="paragraph">
<p>Sparrow 的使用方法非常有趣, 它可以将同一个 Bash 脚本作为一个 Raku 函数来运行。</p>
</div>
<div class="paragraph">
<p>让我们创建一个名为 run.raku 的 Raku 场景, 它相当于上面的命令行。</p>
</div>
<div class="paragraph">
<p><strong>run.raku</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">use Sparrow6::DSL;

task-run &#34;.&#34;, %(
  language =&gt; &#34;Raku&#34;
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们使用 Raku 来运行 run.raku 脚本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku run.raku</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">[.] :: hello from Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们有同样的输出。</p>
</div>
<div class="paragraph">
<p>因此, Sparrow 允许把脚本当作函数来运行, 这非常有趣。根据不同的上下文, 我们可以将相同的代码作为命令行或 Raku 上的函数来运行。</p>
</div>
</div>
<div class="sect2">
<h3 id="_检查_stdout">78.30. 检查 STDOUT</h3>
<div class="paragraph">
<p>有时候, 当我为命令行工具编写测试时, 我想验证一些脚本的输出是否包含某些行。</p>
</div>
<div class="paragraph">
<p>就像 Linux 的人会使用 <code>| grep</code> 结构来检查一个命令是否产生给定的输出一样。</p>
</div>
<div class="paragraph">
<p>Sparrow 为这种操作提供了一个等效的方法, 叫做任务检查。</p>
</div>
<div class="paragraph">
<p>让我们在同一个目录下用 Bash 脚本创建一个名为 task.check 的文件。</p>
</div>
<div class="paragraph">
<p><strong>task.check</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">regexp: Bash || Shell || Perl || Python || Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>该文件包含以纯字符串或 Raku <a href="https://docs.raku.org/language/regexes">正则表达式</a>格式定义的规则。这个语法是 Sparrow 任务检查 DSL, 在 Sparrow <a href="https://github.com/melezhik/Sparrow6/blob/master/documentation/taskchecks.md">文档</a>里有解释。</p>
</div>
<div class="paragraph">
<p>让我们通过运行 run.raku 脚本来应用任务检查。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku run.raku</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">[.] :: hello from Raku
[task check] stdout match  True</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如大家所看到的, Sparrow 已经验证了该脚本输出至少有五个词中的一个。</p>
</div>
<div class="paragraph">
<p>Bash, Shell, Perl, Python 或 Raku.</p>
</div>
<div class="paragraph">
<p>如果任务检查失败, Sparrow 会通过抛出一个适当的异常来通知用户。</p>
</div>
<div class="paragraph">
<p>让我们通过传递一个 Basic 语言参数（对不起, Basic 用户 🙂）来了解一下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">s6 --task-run .@language=Basic</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">[.] :: hello from Basic
[task check] stdout match  False
=================
TASK CHECK FAIL</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">echo $?</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">2</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此, 如果一个任务检查失败, 会导致无零执行代码, 通知整个脚本以失败告终。</p>
</div>
</div>
<div class="sect2">
<h3 id="_脚本钩子">78.31. 脚本钩子</h3>
<div class="paragraph">
<p>熟悉 <a href="https://git-scm.com/">git</a> 源码控制系统的人都知道, 它允许定义脚本钩子—​在数据被发送到远程服务器之前, 小任务会被执行。这些任务可以包括, 例如, 单元测试或 <a href="https://en.wikipedia.org/wiki/Lint_(software)">linters</a>。如果你想在发送实际数据到服务器之前确保代码的更改是有效的和正确的, 这是很方便的。</p>
</div>
<div class="paragraph">
<p>同样的方式, Sparrow 允许为用户脚本定义钩子。这些钩子—​也是在主脚本之前被执行的 Sparrow 任务。</p>
</div>
<div class="paragraph">
<p>让我们来看看这个例子, 我们有主脚本 - task.bash 和触发额外任务的钩子, 名为 task/triggers/http/task.bash。</p>
</div>
<div class="paragraph">
<p>为了实现这一点, Sparrow 需要一个专门的 dir tasks/, 所有的钩子脚本都存在其中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">mkdir tasks/triggers/http</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>tasks/triggers/http/task.bash</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">curl 127.0.0.1:3000 -o /dev/null -s &amp;&amp; echo &#34;I am triggered&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有一个名为 hook.bash 的专门的 bash 文件, 运行一个 hook 脚本, 使用 run_task 函数。</p>
</div>
<div class="paragraph">
<p><strong>hook.bash</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">run_task triggers/http</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在让我们来运行它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">s6 --task-run .</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">[sparrowtask] :: run sparrow task .
[sparrowtask] :: run thing .
[.] :: I am triggered
[.] :: hello from Shell
[task check] stdout match  True</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下, 我们在运行主脚本(只是打印出 &#34;hello from Shell&#34;)之前, 先打一个 URL(curl 127.0.0.1:3000)。</p>
</div>
<div class="paragraph">
<p>总的来说, hooks 提供了一种将大的 Bash 脚本分割成小的独立脚本的方法。</p>
</div>
<div class="paragraph">
<p>它甚至可以在主脚本和附加脚本之间传递参数。让我们把一个名为 param 的参数传递给 tasks/triggers/http/task.bash 脚本。</p>
</div>
<div class="paragraph">
<p><strong>nano hook.bash</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">run_task triggers/http param value</code></pre>
</div>
</div>
<div class="paragraph">
<p>钩子脚本读取传递给它的参数作为 $param 变量。</p>
</div>
<div class="paragraph">
<p><strong>tasks/triggers/http/task.bash</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">curl 127.0.0.1:3000 -o /dev/null -s &amp;&amp; echo &#34;I am triggered. You passed me param: $param&#34;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ s6 --task-run .</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">[sparrowtask] :: run sparrow task .
[sparrowtask] :: run thing .
[.] :: I am triggered. You passed me param: value
[.] :: hello from Shell
[task check] stdout match  True</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_包装好东西">78.32. 包装好东西</h3>
<div class="paragraph">
<p>最后, 最后但并非最不重要的 Sparrow 的功能是打包。</p>
</div>
<div class="paragraph">
<p>打包允许用户通过使用 Sparrow <a href="https://github.com/melezhik/Sparrow6/blob/master/documentation/plugins.md">插件</a>机制来发布他们的脚本。</p>
</div>
<div class="paragraph">
<p>一个脚本可以被打包并上传到 Sparrow <a href="https://github.com/melezhik/Sparrow6/blob/master/documentation/repository.md">仓库</a> - 远程服务器, 由它向用户分发脚本。</p>
</div>
<div class="paragraph">
<p>让我来演示一下我们如何一步步做到这一点。</p>
</div>
</div>
<div class="sect2">
<h3 id="_初始化_sparrow_仓库">78.33. 初始化 Sparrow 仓库</h3>
<div class="paragraph">
<p>首先, 我们需要为我们的 Sparrow 仓库创建一个内部文件结构, 所有的插件都将被存储在这里。</p>
</div>
<div class="paragraph">
<p>这可以通过简单的 Sparrow cli 命令来完成。这个命令只有一个参数 - 仓库文件系统根目录的路径。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">s6 --repo-init ~/repo</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">[repository] :: repo initialization
[repository] :: initialize Sparrow6 repository for /home/melezhik/repo</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_创建一个插件">78.34. 创建一个插件</h3>
<div class="paragraph">
<p>一旦 Sparrow 仓库被初始化, 让我们将 Bash 脚本转换成一个 Sparrow 插件。要做到这一点, 我们需要创建一个名为 sparrow.json 的插件元文件, 其中包含了所有包的详细信息。</p>
</div>
<div class="paragraph">
<p>这个文件应该以 <a href="https://www.json.org/json-en.html">JSON</a> 格式编写, 并放在我们有 Bash 脚本的同一个目录下。</p>
</div>
<div class="paragraph">
<p><strong>sparrow.json</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  &#34;name&#34; : &#34;hello-language&#34;,
  &#34;version&#34; : &#34;0.0.1&#34;,
  &#34;description&#34; : &#34;hello language plugin&#34;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>元文件<a href="https://github.com/melezhik/Sparrow6/blob/master/documentation/plugins.md#plugin-meta-file">结构</a>非常简单, 不言自明. 最起码的参数是插件名称、插件版本和简短的描述。</p>
</div>
<div class="paragraph">
<p>现在让我们使用 s6 cli 将插件上传到 Sparrow 仓库。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">s6 --upload</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">[repository] :: upload plugin
[repository] :: upload hello-language@0.0.1</code></pre>
</div>
</div>
<div class="paragraph">
<p>该命令将所有插件文件归档并复制到仓库文件系统中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_运行网络服务器">78.35. 运行网络服务器</h3>
<div class="paragraph">
<p>为了让一个插件能够为终端用户提供服务, 我们需要旋转一个web服务器来为仓库文件提供服务, 它可以是任何一个web服务器, 唯一的要求是它必须有一个仓库根目录的文件根。它可以是任何一个web服务器, 唯一的要求是它必须有一个版本库根目录的文件根。下面是一个 <a href="https://caddyserver.com/">caddy</a> http 服务器的例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">caddy --root ~/repo --listen=192.168.0.1</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_安装插件">78.36. 安装插件</h3>
<div class="paragraph">
<p>现在, 用户可以通过使用 Sparrow 命令行来安装和运行一个插件。</p>
</div>
<div class="paragraph">
<p>首先, 让我们设置一个远程 Sparrow 仓库, 并获取仓库索引文件。这个操作类似于 Linux 用户使用标准 Linux 包管理器时的操作（例如 Debian：apt-get update）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">export SP6_REPO=http://192.168.0.1
s6 --index-update</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">[repository] :: update local index
[repository] :: index updated from file://home/melezhik/repo/api/v1/index</code></pre>
</div>
</div>
<div class="paragraph">
<p>仓库设置好后, 使用 s6 安装并运行插件。用户可以选择命令行方式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">s6 --plg-run hello-language@language=Python</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">[repository] :: install plugin hello-language
[repository] :: installing hello-language, version 0.000001
[task] :: run plg hello-language@language=Python
[task] :: run thing hello-language
[hello-language] :: I am triggered. You passed me param: value
[hello-language] :: hello from Python
[task check] stdout match  True</code></pre>
</div>
</div>
<div class="paragraph">
<p>或 Raku API:</p>
</div>
<div class="paragraph">
<p><strong>run.raku</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Sparrow6::DSL;

task-run &#34;hello language&#34;, &#34;hello-language&#34;, %(
  language =&gt; &#34;Raku&#34;
)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku run.raku</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">[hello language] :: I am triggered. You passed me param: value
[hello language] :: hello from Raku
[task check] stdout match  True</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_不同的分发协议">78.37. 不同的分发协议</h3>
<div class="paragraph">
<p>Sparrow 资源库支持各种协议的脚本发布, 包括 http、https、rsync 和 ftp。</p>
</div>
<div class="sect3">
<h4 id="_公共的_sparrow_资源库_sparrowhub_io">78.37.1. 公共的 Sparrow 资源库 - Sparrowhub.io</h4>
<div class="paragraph">
<p>Sparrow 官方资源库是 <a href="https://sparrowhub.io/">sparrowhub.io</a> - 包含了很多真实插件的例子, 可以方便地解决日常开发者的任务。快来看看吧！它也是一个很好的方法来解决日常开发任务。这也是熟悉 Sparrow 的一个好方法。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_结束语_3">78.38. 结束语</h3>
<div class="paragraph">
<p>正如大家所看到的, Sparrow 为使用普通 Bash 脚本的人提供了很多功能。</p>
</div>
<div class="paragraph">
<p>通过合理的Raku代码量, 我们可以有效地开发、管理和发布Bash脚本。</p>
</div>
<div class="paragraph">
<p>因此, Sparrow 允许用 Bash 风格来做 Bash 更合适的事情, 同时又有 Raku 作为伟大的粘合剂和协调工具。如果你觉得 Sparrow 有趣, 请访问 <a href="https://github.com/melezhik/Sparrow6">Sparrow GH</a> 页面, 作为文档、示例和依赖项目链接的来源。</p>
</div>
<div class="paragraph">
<p>圣诞快乐
== <a href="https://raku-advent.blog/2020/12/08/raku-web-templating-engines-boost-up-the-parsing-performance/">第八天 - Raku 网页模板引擎: 提升解析性能</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_现代_raku_网页模板引擎">78.39. 现代 Raku 网页模板引擎</h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Template_processor">模板引擎</a>基本上提供了在静态文件（模板）中进行有效元数据插值的工具。在网络应用程序运行时, 引擎解析并将变量替换为实际内容值。最后, 客户端得到一个由模板生成的HTML页面, 其中所有的元数据（变量、语句、表达式）已经被处理。</p>
</div>
<div class="paragraph">
<p>Raku <a href="https://modules.raku.org/t/TEMPLATE">生态系统</a>有几个现代模板引擎。<a href="https://github.com/tadzik/Template-Mojo">Template::Mojo</a>（最后一次提交于2017年6月12日）, <a href="https://github.com/softmoth/raku-Template-Mustache">Template::Mustache</a>（最后一次提交于2020年7月25日—​它还活着！）, <a href="https://github.com/raku-community-modules/Template6">Template6</a>（最后一次提交于2020年11月20日—​积极维护）, <a href="https://github.com/chloekek/Template-Classic">Template::Classic</a>（最后一次提交于2020年4月11日）, <a href="https://github.com/drforr/perl6-Template-Toolkit">Template::Toolkit</a>（由 @DrForr 编写, 不幸的是它现在闲置了）和 <a href="https://github.com/masak/html-template">HTML::Template</a>（最后一次提交于2016年10月28日）。</p>
</div>
<div class="paragraph">
<p>另外还有方便的多模块适配器 <a href="https://github.com/raku-community-modules/Web-Template">Web::Template</a> - 一个简单的抽象层, 为不同的模板引擎提供一致的 API。</p>
</div>
<div class="paragraph">
<p>你应该选择什么引擎呢？我的标准是：项目应该是活着的, 并且是 <a href="https://github.com/rakudo/star/blob/master/etc/modules.txt">Rakudo Star Bundle</a> 发行版的一部分。好吧, <code>Template::Mustache</code> 就是无辜被选中的那个。</p>
</div>
</div>
<div class="sect2">
<h3 id="_什么是网页模板">78.40. 什么是网页模板？</h3>
<div class="paragraph">
<p>网页模板是带有附加元数据（标记）的 HTML 文档, 将由模板引擎处理—​在简单的模板中, 元数据是通过变量来呈现的(例如, Template6 模板引擎将变量插值为 <code>[% varname %]</code>, Template::Mustache 插值为 <code>{{ varname }}</code>)。在网页模板处理后, 所有的元数据变量都被替换为实际的内容值。</p>
</div>
<div class="paragraph">
<p>Сomposite web 模板包括与其他模板的链接(绑定)。例如, 规范的 Mustache 模板可以用 <code>{{&gt; template_name }}</code> 执行导入。(参见 <a href="https://mustache.github.io/mustache.5.html#Partials">partials</a>)。顺便说一下, 可以在导入的模板中使用链接, 所以可以接受递归 partials。</p>
</div>
<div class="paragraph">
<p>带有逻辑的网页模板（内联程序）使用扩展的元标记。我们可以在模板中编写简单的布局管理程序。Template6 引擎成功地&#34;执行&#34;了像 <code>[% for item in list %][% item %]\n[% end %]</code> 或 <code>[% if flag %]foo[% else %]bar[% end %]</code> 这样的结构。</p>
</div>
<div class="paragraph">
<p>大多数 web 应用程序的常规做法—​使用简单的复合模板进行模板化。我们只使用变量和导入依赖关系（页眉、页脚、注释块、反馈表单等）。所有的扩展逻辑（可以用内联程序实现的）应该尽量排除, 或者放到 web 应用层。</p>
</div>
<div class="paragraph">
<p>在本文中, 我们将考虑最简单的情况 - 带变量的 web 模板（没有导入, 没有内联逻辑）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_性能方面">78.41. 性能方面</h3>
<div class="paragraph">
<p>如上所述, 我选择模板引擎的标准是项目支持和可访问性。但在现实生活中, 重要的标准是性能。不管项目是非常活跃的, 还是包含在所有已知的发行版中—​如果客户等待几秒钟的页面渲染, 我们就必须寻找另一个模块或解决方案。</p>
</div>
<div class="paragraph">
<p>所以, 为了测试性能, 我使用了 <a href="https://pheix.org/">Pheix</a> CMS 的嵌入式模板作为一个最简单的模板。在我看来—​如果模板引擎能够轻松处理, 我们就可以进入下一步的测试 - 比如内联程序。</p>
</div>
<div class="paragraph">
<p>注：模板有14个变量, 其中有2个变量使用了扩展的 Mustache 语法 <code>{{{ varname }}}</code>。三个大括号是告诉引擎跳过我们要替换成的内容块里面的<a href="https://mustache.github.io/mustache.5.html#Variables">转义</a>。</p>
</div>
<div class="paragraph">
<p>测试套件基于<a href="https://gitlab.com/pheix-research/templates/-/blob/master/reg-expr/tmpl-mustache.raku">处理脚本</a>, 其中使用了<a href="https://gitlab.com/pheix-research/templates/-/blob/master/reg-expr/lib/Pheix/View/TemplateM.rakumod">帮助模块</a>  Pheix::View::TemplateM 的 render() 方法。源代码非常简单, 并尽可能地接近文档指南。我们对 <code>render()</code> 方法进行了分析, 并测量了执行时间（不考虑编译、加载、对象初始化等时间）。此外, 我们使用自动 bash 助手循环运行 tmpl-mustache.raku 100 次, 并计算平均运行时间。</p>
</div>
<div class="paragraph">
<p>测试是在 MacBook Unibody Core2Duo 2.6 GHz, 8Gb 内存平台上进行的（就像中性能的VPS一样）。</p>
</div>
<div class="paragraph">
<p>mustache 渲染时间：1.8555348秒</p>
</div>
<div class="paragraph">
<p>换句话说, 如果 web 应用像经典的 <a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface#Example">CGI</a> 实例一样工作（没有缓存, 没有可用的worker, 没有代理 - 每次运行都是从头开始）, 请求至少会在2秒内呈现（网络延迟+占空比+模板化[+服务器资源节流]）。实际上这个时间可能会超过10秒（几个并行客户端的情况）- 绝对不好。</p>
</div>
<div class="paragraph">
<p>对 Template6 进行同样的测试。</p>
</div>
<div class="paragraph">
<p>template6 render time: 0.5481035 sec</p>
</div>
<div class="paragraph">
<p>该模块速度快3倍。来源：<a href="https://gitlab.com/pheix-research/templates/-/blob/master/tmpl6/tmpl/layout_1.html">模板</a>和<a href="https://gitlab.com/pheix-research/templates/-/blob/master/tmpl6/tmpl-6.raku">脚本</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_第一次优化">78.42. 第一次优化</h3>
<div class="paragraph">
<p>关于优化的第一个想法是&#34;好吧, 看来考虑过的模块对于这个任务来说是很沉重的 - 让我们写一些简单的东西&#34;。而我基于通用正则表达式, 实现了自己的 <code>render()</code> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method fast_render(Str :$template is copy, :%vars) returns Str {
    for %vars.keys -&gt; $key {
        if $key ~~ /tmpl_timestamp/ {
            $template ~~ s:g/ \{\{\{?: &lt;$key&gt;: \}\}\}?: /%vars{$key}/;
        }
        else {
            $template ~~ s/ \{\{\{?: &lt;$key&gt;: \}\}\}?: /%vars{$key}/;
        }
    }

    $template;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>来源：<a href="https://gitlab.com/pheix-research/templates/-/blob/master/reg-expr/tmpl-regexpr.raku">脚本</a>, <a href="https://gitlab.com/pheix-research/templates/-/blob/master/reg-expr/lib/Pheix/View/Template.rakumod">帮助模块</a>。</p>
</div>
<div class="paragraph">
<p>结果:</p>
</div>
<div class="paragraph">
<p>regexpr render time: 0.2721529</p>
</div>
<div class="paragraph">
<p>与 Template6 相比, 性能提升了2倍, 与 Template::Mustache 相比提升了6倍。</p>
</div>
</div>
<div class="sect2">
<h3 id="_第二次优化">78.43. 第二次优化</h3>
<div class="paragraph">
<p>接下来的想法是：&#34;好吧, 让我们把 HTML 模板解析成树状, 然后替换/替代所需的块&#34;。我已经使用 XML <a href="https://github.com/raku-community-modules/XML">模块</a>来完成这个任务。</p>
</div>
<div class="paragraph">
<p>这种方法需要一个有点棘手的<a href="https://gitlab.com/pheix-research/templates/-/blob/master/xml-tmpl/tmpl/layout_1.html">模板</a>：由于模板被解析到树上, 我们需要解决块的插值。在Template6或Template::Mustache的情况下, 我们使用元标记, 但它在XML验证上失败了。</p>
</div>
<div class="paragraph">
<p>好吧, 我把 XML 标记添加到基本模板中, 而不是元标记。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>specific tags: &lt;pheixtemplate variable=&#34;tmpl_pagetitle&#34;&gt;&lt;/pheixtemplate&gt;;</p>
</li>
<li>
<p>specific attributes:</p>
</li>
<li>
<p>&lt;link href=&#34;resources/skins/akin/css/pheix.css&#34; pheix-timestamp-to=&#34;href&#34; rel=&#34;stylesheet&#34; /&gt; — this means the timestamp value will be concatenated to string from href attribute;</p>
</li>
<li>
<p>&lt;meta name=&#34;keywords&#34; content=&#34;&#34; pheix-variable-to=&#34;content&#34; pheix-variable=&#34;tmpl_metakeys&#34; /&gt; — this means the tmpl_metakeys value will be inserted to content attribute.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外, 特定的标签应该有预建的 HTML 代码和与现有树节点的绑定, 特定的属性只需要定义—​这在初始化步骤中就可以直接完成。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %tparams =
    title   =&gt; {
        name    =&gt; &#39;tmpl_pagetitle&#39;,
        new     =&gt; make-xml(&#39;title&#39;, &#34;This is the page title&#34;),
        existed =&gt; Nil,
        value   =&gt; q{}
    },
    mkeys   =&gt; {
        name    =&gt; &#39;tmpl_metakeys&#39;,
        new     =&gt; Nil,
        existed =&gt; Nil,
        value   =&gt; &#39;This is meta.keywords data&#39;
    },
    ...
;

for %tparams.keys -&gt; $k {
    %tparams{$k}&lt;existed&gt; =
        $xml.root.elements(:TAG&lt;pheixtemplate&gt;, :variable(%tparams{$k}&lt;name&gt;), :RECURSE, :SINGLE);

    if !%tparams{$k}&lt;existed&gt; {
        %tparams{$k}&lt;existed&gt; = $xml.root.elements(:pheix-variable(%tparams{$k}&lt;name&gt;), :RECURSE, :SINGLE);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>时间戳块的收集：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @timestampto = $xml.root.elements(:pheix-timestamp-to(* ~~ /&lt;[a..z]&gt;+/), :RECURSE);</code></pre>
</div>
</div>
<div class="paragraph">
<p>并由（尽量琐碎的）处理:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (@timestampto) {
    my Str $attr = $_.attribs&lt;pheix-timestamp-to&gt;;

    if $attr {
        $_.set($attr, ($_.attribs{$attr} ~ q{?} ~ now.Rat));

        %report&lt;timestamps&gt;++;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可变标签的处理方法是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for %tparams.keys -&gt; $k {
    if %tparams{$k}&lt;new&gt; {
        %tparams{$k}&lt;existed&gt;.parent.replace(%tparams{$k}&lt;existed&gt;, %tparams{$k}&lt;new&gt;);

        %report&lt;variables&gt;++;
    }
    else {
        my Str $attr = %tparams{$k}&lt;existed&gt;.attribs&lt;pheix-variable-to&gt;;

        if $attr {
            %tparams{$k}&lt;existed&gt;.set($attr, %tparams{$k}&lt;value&gt;);

            %report&lt;variables&gt;++;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>爽！让我们运行<a href="https://gitlab.com/pheix-research/templates/-/blob/master/xml-tmpl/html-2-xml.raku">脚本</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku html-2-xml.raku

# processing time: 0.15519139
# added 6 timestamps
# replaced 8 variables</code></pre>
</div>
</div>
<div class="paragraph">
<p>100次迭代的平均结果。</p>
</div>
<div class="paragraph">
<p>xml render time: 0.1550534 sec</p>
</div>
<div class="paragraph">
<p>这与自定义 RegExpr 相比, 性能提高了2倍, 与 Template6 相比提高了x4, 与 Template::Mustache exploding_head 相比提高了12倍。</p>
</div>
</div>
<div class="sect2">
<h3 id="_htmltemplate">78.44. HTML::Template</h3>
<div class="paragraph">
<p>规范用法（遵循准则）</p>
</div>
<div class="paragraph">
<p>为了好玩, 我测量了<a href="https://github.com/masak/html-template">被遗忘的老</a> HTML::Template 模块的性能。测试源：<a href="https://gitlab.com/pheix-research/templates/-/blob/master/reg-expr/tmpl/layout_2.html">模板</a>、<a href="https://gitlab.com/pheix-research/templates/-/blob/master/reg-expr/tmpl-htmlt.raku">脚本</a>（将注释 Pheix::View::TemplateH 切换为 Pheix::View::TemplateH2）、<a href="https://gitlab.com/pheix-research/templates/-/blob/master/reg-expr/lib/Pheix/View/TemplateH2.rakumod">辅助模块</a>。</p>
</div>
<div class="paragraph">
<p>100 次迭代的平均结果。</p>
</div>
<div class="paragraph">
<p>htmltmpl 渲染时间：0.1911648秒</p>
</div>
<div class="paragraph">
<p>嗯, 这是相当快的开箱。</p>
</div>
</div>
<div class="sect2">
<h3 id="_让它_x100快">78.45. 让它 ~x100快</h3>
<div class="paragraph">
<p>HTML::Template 模块提供了简单的语法, 所以第三个想法是&#34;对, 我们在初始化阶段将HTML模板<a href="https://github.com/masak/html-template/blob/fa19261aa85b4e7dc50fe56de1e953fc821e6456/lib/HTML/Template.pm#L87">解析</a>成变量（根据给定的语法）, 在运行时进行<a href="https://github.com/masak/html-template/blob/fa19261aa85b4e7dc50fe56de1e953fc821e6456/lib/HTML/Template.pm#L100">替换</a>&#34;。</p>
</div>
<div class="paragraph">
<p>测试来源：<a href="https://gitlab.com/pheix-research/templates/-/blob/master/reg-expr/tmpl/layout_2.html">模板</a>、<a href="https://gitlab.com/pheix-research/templates/-/blob/master/reg-expr/tmpl-htmlt.raku">脚本</a>（将注释 Pheix::View::TemplateH2 切换为Pheix::View::TemplateH）、<a href="https://gitlab.com/pheix-research/templates/-/blob/master/reg-expr/lib/Pheix/View/TemplateH.rakumod">帮助模块</a>。</p>
</div>
<div class="paragraph">
<p>100次迭代的平均结果。</p>
</div>
<div class="paragraph">
<p>htmltmpl 渲染时间：0.0021661秒</p>
</div>
<div class="paragraph">
<p>这与典籍使用相比, 性能提升了100倍嗒嗒嗒。</p>
</div>
</div>
<div class="sect2">
<h3 id="_还需要更多的提升吗">78.46. 还需要更多的提升吗?</h3>
<div class="paragraph">
<p>现代Web开发技术涉及到后台模板引擎的负载均衡。</p>
</div>
<div class="paragraph">
<p>常见的技术是基于在服务器和客户端之间分配模板渲染任务的思想：根据服务器的负载情况, 由后台完全渲染模板, 或者后台只做快速生成。它拉出模板文件, 并将其内容与要替换的数据（用JSON表示）连接起来。通常这些数据会作为 <code>&lt;script&gt;&lt;/script&gt;</code> 标签内的 JavaScript 代码添加到模板的末尾。</p>
</div>
<div class="paragraph">
<p>下一步, JavaScript 模板引擎（例如 <a href="https://riot.js.org/">RIOT.js</a>）将在客户端的浏览器中完成<a href="https://plnkr.co/edit/bh3mGY1oXbm9h6VU?preview">整个页面的渲染</a>。</p>
</div>
<div class="paragraph">
<p>这种方法在我们使用 Template::Mustache 作为后端主要模板引擎的情况下可以有效。服务器端渲染的模板变量标记为 <code>{{ varname }}</code> 或 <code>{{ varname }}}</code>, 客户端渲染的变量标记为 <code>{ props.varname }</code>。所以, 这就是我们获得模板源码的一致性和基本语义完整性的方式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结束语_4">78.47. 结束语</h3>
<div class="sect3">
<h4 id="_为什么延迟很重要">78.47.1. 为什么延迟很重要？</h4>
<div class="paragraph">
<p>客户的观点：没有人喜欢缓慢的网站。</p>
</div>
<div class="paragraph">
<p>开发者的观点：如果我们将常规任务的延迟和瓶颈降到最低 - 模板渲染就是这样的, - 我们将为资源密集型或慢速技术释放空间。</p>
</div>
<div class="paragraph">
<p>例如, 区块链。这个卑微的研究灵感来自于 Pheix 网络内容管理系统的开发, 数据存储在 <a href="https://ethereum.org/en/">Ethereum</a> 区块链上。这里概述的一些想法被放入<a href="https://narkhov.pro/pheix-public-beta-release-suggestions.html">公共 β 版本</a>的代码中 - 它将在今年年底发布。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结_8">78.48. 总结</h3>
<div class="paragraph">
<p>本帖考虑的所有资料来源均可在 <a href="https://gitlab.com/pheix-research/templates">https://gitlab.com/pheix-research/templates</a>。最后的成绩是（以秒为单位）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">1. htmltmpl pre-parse render time: 0.0021661
2. xml render time:                0.1550534
3. htmltmpl native render time:    0.1911648
4. regexpr render time:            0.2721529
5. template6 render time:          0.5481035
6. mustache render time:           1.8555348</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_raku_驱动的网络应用">78.49. Raku 驱动的网络应用</h3>
<div class="paragraph">
<p>我相信, 我们可以使用 Raku 作为网络编程语言。我们可以创建快速、反应灵敏、可扩展的 Raku 驱动的后端。另一方面, 它需要更多的实践和时间：结合不同的技术和方法, 我们可以获得更多的性能改进。可悲的是 - 生态系统仍然是原始的, 当我们想在我们的项目中使用一些模块时, 我们应该对它进行配置, 与类似的模块进行比较, 也许可以进行分叉和调整。乐观的事情—​我们可以让我们的 Raku 驱动的 web 应用快速工作, 这样就可以发布到生产中。
== <a href="https://raku-advent.blog/2020/12/09/day-11-getting-windows-memory-usage-with-nativecall/">第九天 - 使用 NativeCall 获取 Windows 的内存</a></p>
</div>
<div class="paragraph">
<p>Raku <a href="https://docs.raku.org/language/nativecall">NativeCalls</a> 提供了一种与遵循 C 调用惯例的动态库进行交互的方式, 对于从操作系统中获取内存使用情况等信息非常有用。</p>
</div>
<div class="paragraph">
<p>在本文中, 我们将看到如何从 Windows 系统中获取内存使用情况。</p>
</div>
</div>
<div class="sect2">
<h3 id="_memorystatusex_c_结构">78.50. MEMORYSTATUSEX C++ 结构</h3>
<div class="paragraph">
<p>Win32 API 提供了 <a href="https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/ns-sysinfoapi-memorystatusex">MEMORYSTATUSEX</a> 结构。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">typedef struct _MEMORYSTATUSEX {
  DWORD     dwLength;
  DWORD     dwMemoryLoad;
  DWORDLONG ullTotalPhys;
  DWORDLONG ullAvailPhys;
  DWORDLONG ullTotalPageFile;
  DWORDLONG ullAvailPageFile;
  DWORDLONG ullTotalVirtual;
  DWORDLONG ullAvailVirtual;
  DWORDLONG ullAvailExtendedVirtual;
} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;</code></pre>
</div>
</div>
<div class="paragraph">
<p>包含了当前内存的信息, 以字节为单位, 包括:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>总物理内存：ullTotalPhys</p>
</li>
<li>
<p>可用的物理内存：ullAvailPhys</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这两个成员将允许我们通过从 ullTotalPhys 中减去 ullAvailPhys 来计算内存使用量。</p>
</div>
<div class="paragraph">
<p>MEMORYSTATUSEX 结构有 <code>dwLength</code> 成员, 在调用填充 <code>MEMORYSTATUSEX</code> 结构的<a href="https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex">函数 GlobalMemoryStatusEx</a> 之前, 需要设置这个成员。</p>
</div>
</div>
<div class="sect2">
<h3 id="_用_nativecall_声明_memorystatusex_类">78.51. 用 NativeCall 声明 MEMORYSTATUSEX 类</h3>
<div class="paragraph">
<p>Raku Nativecalls 使用 <code>repr(&#39;CStruct&#39;)</code> trait 成一个声明类来与 C 结构交互。我们可以声明这个类来使用 C++ MEMORYSTATUSEX 结构, 如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">class MEMORYSTATUSEX is repr(&#39;CStruct&#39;) {
  has uint32 $.dwLength is rw;
  has uint32 $.dwMemoryLoad;
  has uint64 $.ullTotalPhys;
  has uint64 $.ullAvailPhys;
  has uint64 $.ullTotalPageFile;
  has uint64 $.ullAvailPageFile;
  has uint64 $.ullTotalVirtual;
  has uint64 $.ullAvailVirtual;
  has uint64 $.ullAvailExtendedVirtual;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>C++ 和 Raku 之间的成员类型映射很重要。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku 类型 uint32 相当于 C++ Win32 的 DWORD 类型。</p>
</li>
<li>
<p>Raku 类型 uint64 相当于 C++ Win32 的 DWORDLONG 类型。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>$.dwLength</code> 成员是 <code>is rw</code>(读写), 用于以后设置结构的大小。</p>
</div>
</div>
<div class="sect2">
<h3 id="_globalmemorystatusex_的_c_函数">78.52. GlobalMemoryStatusEx 的 C++ 函数</h3>
<div class="paragraph">
<p>这个 C++ 函数使用 LPMEMORYSTATUSEX 指针类型作为参数填充 MEMORYSTATUSEX 结构。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">BOOL GlobalMemoryStatusEx( LPMEMORYSTATUSEX lpBuffer )</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 不使用指针来执行对这个函数的 Native Call, 而是使用一个具有 native 特性的 Raku 函数, 我们将在下面看到。</p>
</div>
</div>
<div class="sect2">
<h3 id="_构建本地函数">78.53. 构建本地函数</h3>
<div class="paragraph">
<p>Raku Native Calls 允许使用 C++ GlobalMemoryStatusEx 函数, 具体如下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;

sub GlobalMemoryStatusEx(MEMORYSTATUSEX) is native(&#39;Kernel32&#39;) returns int32 { * };</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>use NativeCall 加载 Raku NativeCall 上下文。</p>
</li>
<li>
<p>GlobalMemoryStatusEx 是函数名, 必须与 <code>C++</code> 中的原始名称相同。</p>
</li>
<li>
<p>MEMORYSTATUSEX 是我们之前声明的类的名称, 用于与 `C++` 结构交互, 该结构将包含我们需要的成员(<code>$.ullTotalPhys</code> 和 <code>$.ullAvailPhys</code>)。实际上, 这个类作为指针, 进入 <code>C++</code> GlobalMemoryStatusEx 函数的参数。</p>
</li>
<li>
<p>trait <code>is native(&#39;Kernel32&#39;)</code> 公开了包含 GlobalMemoryStatusEx 函数的 Win32 库。</p>
</li>
<li>
<p>这个函数返回一个由 int32 类型表示的 bool 值。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_获取结果">78.54. 获取结果</h3>
<div class="paragraph">
<p>要使用 MEMORYSTATUSEX 类与 GlobalMemoryStatusEx Native 函数, 我们需要将它实例化在一个对象中, 例如 <code>$data</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my MEMORYSTATUSEX $data .=new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外, 别忘了传递结构体（或 <code>$data</code> 对象）的大小, 设置 <code>$data.dwLength</code> 成员的当前大小。结构的大小就是 <code>$data</code> 对象的大小, 我们可以通过函数 nativesizeof 来获取。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$data.dwLength = nativesizeof($data);</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们准备好填充 MEMORYSTATUSEX 结构(<code>$data</code> 对象), 以 <code>$data</code> 对象为参数调用 GlobalMemoryStatusEx Native 函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">GlobalMemoryStatusEx($data);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$data</code> 对象的作用就像 C++ LPMEMORYSTATUSEX 指针一样。</p>
</div>
<div class="paragraph">
<p>最后, 我们需要的结果在 <code>$data</code> 对象的成员值中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $memoryUsage = $data.ullTotalPhys - $data.ullAvailPhys;

say &#34;Current Memory Usage: $memoryUsage Bytes.&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/ramiroencinas/System-Stats-MEMUsage">在这里</a>, 你可以看到这个应用在 Raku 模块中的例子。</p>
</div>
<div class="paragraph">
<p>正如我们在这个例子中所看到的, Raku Native Calls 的使用允许通过它的动态库将 Raku 的功能扩展到操作系统的世界。此外, 通过对不同的操作系统进行适当的调用, 我们可以创建可以在任何操作系统上工作的应用程序。</p>
</div>
<div class="paragraph">
<p>更多关于 Raku Native 调用接口的信息请参见 <a href="https://docs.raku.org/language/nativecall">Raku 文档</a>。
== <a href="https://raku-advent.blog/2020/12/10/day-10-my-10-commandments-for-raku-performances/">第十天 - 我的10条 Raku 性能戒律</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_1_您将使用的剖析器">78.55. 1. 您将使用的剖析器</h3>
<div class="paragraph">
<p><a href="https://www.raku.org/">Raku</a> 有一个不错的可视化<a href="https://docs.raku.org/language/performance#Profile_locally">剖析器</a>。</p>
</div>
<div class="paragraph">
<p>没有借口忽视它, 它的使用非常简单。</p>
</div>
<div class="paragraph">
<p>只要用 <code>raku --profile=myprofile.html foo.raku</code> 运行剖析器, 然后在你最喜欢的浏览器中打开生成的 HTML 文件（例如 <code>firefox myprofile.html &amp;</code>）。</p>
</div>
<div class="paragraph">
<p>这是一个概述, 你可以在剖析报告中拥有什么。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2020/11/profiler.png?w=780" alt="profiler"/>
</div>
</div>
<div class="paragraph">
<p>甚至更好的是, 你可以使用 <a href="https://github.com/timo/moarperf">Moarperf</a> 与 SQL 配置文件：使用 <code>raku --profile=myprofile.sql foo.raku</code> 和后 <code>raku -I .services.p6 myprofile.sql</code>。</p>
</div>
<div class="paragraph">
<p>&#34;SQL 配置文件&#34;是一种与 moarperf 兼容的配置文件的输出格式。</p>
</div>
<div class="paragraph">
<p>下面是 MoarPerf 的一个面板的概述。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2020/11/moarperf.png?w=1024" alt="moarperf"/>
</div>
</div>
<div class="paragraph">
<p>&#34;GC&#34; 指的是 Garbage Collection, 这是虚拟机在清理/拆分内存时的一种内部机制。</p>
</div>
<div class="paragraph">
<p>你可以检查一些运行时间是否很长, 运行是否过于频繁, 最后还可以检查&#34;单元&#34;的管理方式（项目有一个&#34;生命期&#34;, 称为&#34;代际垃圾收集&#34;, 项目从一个空间移动到另一个空间并改变其&#34;状态&#34;</p>
</div>
<div class="paragraph">
<p>如果你想在调用图中得到更多的信息, 不要使用命名循环（MYLOOP: 无济于事）, 而是使用 subs !</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub myloop() {
    ...
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>比如这个工作实例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result = 42;

sub mybody($i) {
    if $i % 2 {
        $result += 2;
    }
}

sub myloop() {
    USELESS: for (0..1000) -&gt; $i {
        mybody($i);
    }
}

myloop();
say $result;</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#34;sub 技巧&#34;会产生一些开销（调用栈）, 但可以帮助你调查。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2020/11/subs.png?w=1024" alt="subs"/>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_崇尚的原生型">78.56. 2. 崇尚的原生型</h3>
<div class="paragraph">
<p>它到处都写着, 用大写字母写着, 使用原生类型来执行！ 😀。</p>
</div>
<div class="paragraph">
<p>这是真的, 它给你提供了极快的  Raku 脚本! (但你必须严格要求自己)</p>
</div>
<div class="paragraph">
<p>为了让你信服, 从隐式类型开始 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = ();
for (1..10_000_000) -&gt; $item {
    @a.push($item);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这很慢:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># real 0m11.073s
# user 0m10.614s
# sys  0m0.520s</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后改成我们要 push 的项目的原生类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = ();
for (1..10_000_000) -&gt; int $item {
    @a.push($item);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>稍微好一点, 但还是不好, 因为只有项目被声明为原生 int。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># real 0m9.007s
# user 0m8.469s
# sys  0m0.600s</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后是&#34;完整&#34;的原生 int 版本（容器+项）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my int @a = ();
for (1..10_000_000) -&gt; int $item {
    @a.push($item);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这表现非常非常好 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># real 0m0.489s
# user 0m0.454s
# sys  0m0.105s</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2020/11/native.png?w=1024" alt="native"/>
</div>
</div>
<div class="paragraph">
<p>(y轴是取自时间报告的秒数, 我用 <a href="https://live.amcharts.com/new/edit/">amcharts</a> 画图)</p>
</div>
<div class="paragraph">
<p>在分配方面, 这是发生了什么。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2020/11/loop-push-allocs.png?w=1024" alt="loop push allocs"/>
</div>
</div>
<div class="paragraph">
<p>如果你想知道什么是 BOOTHash, 它是一个低级的哈希类, 在一些内部结构中, 比如说用来给方法传递参数。</p>
</div>
<div class="paragraph">
<p>要知道是什么产生了 BOOTHash 分配（SPOILER: <code>@a.push($item)</code>), 你可以点击查看 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2020/11/inspectboothash.png?w=1024" alt="inspectboothash"/>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_在spesh和jit的力量下_你会相信">78.57. 3. 在spesh（和JIT）的力量下, 你会相信</h3>
<div class="paragraph">
<p>Spesh 和 JIT 是 MoarVM 的优化。</p>
</div>
<div class="paragraph">
<p>Spesh 更像是试图将方法/属性翻译成便宜的版本。</p>
</div>
<div class="paragraph">
<p>JIT 的意思是 <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">Just-In-Time 编译</a>。它被 MoarVM 用来将&#34;热&#34;代码编译成二进制（而不是字节码）。</p>
</div>
<div class="paragraph">
<p>看似简单的循环:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (1..1_000_000_000) -&gt; $item {</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用默认的选项快速运行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># real 0m6.818s
# user 0m6.843s
# sys  0m0.024s</code></pre>
</div>
</div>
<div class="paragraph">
<p>在没有 JIT 的情况下, 运行速度会慢一些(MVM_JIT_DISABLE=1)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># real 0m22.555s
# user 0m22.562s
# sys  0m0.028s</code></pre>
</div>
</div>
<div class="paragraph">
<p>在没有 JIT 也没有 spesh 的情况下, 运行速度慢了很多(MVM_JIT_DISABLE=1, MVM_SPESH_DISABLE=1, MVM_SPESH_INLINE_DISABLE=1, MVM_SPESH_OSR_DISABLE=1)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># real 5m21.953s
# user 5m21.434s
# sys  0m0.164s</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2020/11/optims.png?w=1024" alt="optims"/>
</div>
</div>
<div class="paragraph">
<p>原理是什么？</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2020/12/moaroptsvert-3.png?w=777" alt="moaroptsvert 3"/>
</div>
</div>
<div class="paragraph">
<p>注意, 调用框架每次都移动到不同的优化类别。</p>
</div>
</div>
<div class="sect2">
<h3 id="_4_在优化中_你会相信再次">78.58. 4. 在优化中, 你会相信（再次）</h3>
<div class="paragraph">
<p>这次我们玩的是空循环, 这个要注意。</p>
</div>
<div class="paragraph">
<p>看一下这3种不同类型的循环迭代器声明。</p>
</div>
<div class="paragraph">
<p>完全没有类型</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (1..1_000_000_000) -&gt; $item { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有声明迭代器或 Int</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (1..1_000_000_000) { }
# Or
for (1..1_000_000_000) -&gt; Int $item { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>原生类型迭代器</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (1..1_000_000_000) -&gt; int $item { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个人都在分配不同的对象（有时是 Int, 甚至有时什么都没有）。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2020/11/iteratorallocs.png?w=1005" alt="iteratorallocs"/>
</div>
</div>
<div class="paragraph">
<p>如你所见, 分配数并不是实际的循环迭代次数, 优化器已经做得很好了。</p>
</div>
<div class="paragraph">
<p>记住这是一个空循环, 如果你在正文中使用 <code>$item</code>, 那么分配数会增加很多 !</p>
</div>
<div class="paragraph">
<p>这就是为什么(空循环+优化器), 在启用优化后, 它们的表现竟然都是一样的。</p>
</div>
<div class="paragraph">
<p>但是当优化被关闭时, 就会是另一个故事了。</p>
</div>
<div class="paragraph">
<p>非显式类型 (<code>for (1..1_000_000_000) → $item { }</code>) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># real 5m1.962s
# user 5m1.592s
# sys  0m0.152s</code></pre>
</div>
</div>
<div class="paragraph">
<p>显式的 Int 对象类型 (<code>for (1..1_000_000_000) → Int $item { }</code>) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># real 3m32.763s
# user 3m32.647s
# sys  0m0.076s</code></pre>
</div>
</div>
<div class="paragraph">
<p>原生的 int (<code>for (1..1_000_000_000) → int $item { }</code>) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># real 2m18.874s
# user 2m18.787s
# sys  0m0.037s</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2020/11/noopts-allocs.png?w=1024" alt="noopts allocs"/>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_5_各种各样的循环_你都会倍加珍惜一样">78.59. 5. 各种各样的循环, 你都会倍加珍惜一样。</h3>
<div class="paragraph">
<p><code>*</code> 或仇恨, 这取决于</p>
</div>
<div class="paragraph">
<p>基本 loop?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop (my int $i = 0; $i &lt; 1000; $i++) { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>或 <code>foreach</code> 与一个 range(这里也许有一些 allocs?) ?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (1..1000) -&gt; int $item { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>选择你喜欢的, 他们做的不一样, 但似乎执行几乎相同的！😀。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2020/12/loopsallocs.png?w=799" alt="loopsallocs"/>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_6_从一些不好的内置中你会隐藏">78.60. 6. 从一些不好的内置中你会隐藏</h3>
<div class="paragraph">
<p>对于原生类型, raku 的表现非常好, 甚至比几个竞争对手还要好。</p>
</div>
<div class="paragraph">
<p>但另一方面, 有些内置类型的表现就是比其他类型差。unshift 就是这种情况。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my int @a = ();
for (1..16_000_000) -&gt; int $item {
    @a.unshift($item);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>unshift 相对来说很快就会有不好的表现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">#    500 000
# real 0m0.197s
# user 0m0.218s
# sys  0m0.037s

#  1 000 000
# real 0m0.209s
# user 0m0.223s
# sys  0m0.040s

#  2 000 000
# real 0m0.400s
# user 0m0.436s
# sys  0m0.036s

#  4 000 000
# real 0m1.076s
# user 0m1.087s
# sys  0m0.053s

#  8 000 000
# real 0m3.712s
# user 0m3.697s
# sys  0m0.072s

# 16 000 000
# real 0m14.544s
# user 0m14.430s
# sys  0m0.192s</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们比较一下 push…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my int @a = ();
for (1..4_000_000) -&gt; int $item {
    @a.push($item);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">#   500 000
# real 0m0.216s
# user 0m0.258s
# sys  0m0.021s

#  1 000 000
# real 0m0.209s
# user 0m0.231s
# sys  0m0.032s

#  2 000 000
# real 0m0.224s
# user 0m0.223s
# sys  0m0.057s

#  4 000 000
# real 0m0.249s
# user 0m0.259s
# sys  0m0.045s

#  8 000 000
# real 0m0.410s
# user 0m0.360s
# sys  0m0.108s

# 16 000 000
# real 0m0.616s
# user 0m0.596s
# sys  0m0.108s</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2020/12/us.png?w=780" alt="us"/>
</div>
</div>
<div class="paragraph">
<p>总体思路是&#34;优选性能好的内建&#34;。</p>
</div>
<div class="paragraph">
<p>unshift perfs 甚至更糟, 直到最近, 但它不是很公平地提到它, 因为这些可怕的性能不是&#34;正常&#34;的东西, 而是 MoarVM 的一个bug, 我<a href="https://github.com/MoarVM/MoarVM/issues/1382">报告</a>了, 并很快<a href="https://github.com/MoarVM/MoarVM/pull/1392">修复</a>了（谢谢你！）。</p>
</div>
<div class="paragraph">
<p>另一个例子是所有与 regex 相关的代码。</p>
</div>
<div class="paragraph">
<p>第一段代码非常慢, 因为 <code>~~</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = 123;
my $count = 0;

for (1..10_000_000) {
    if $^item ~~ /^$n/ {
        $count++;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># real 1m12.583s
# user 1m12.189s
# sys  0m0.064s</code></pre>
</div>
</div>
<div class="paragraph">
<p>只需将每个 <code>~~</code> 替换为 starts-with 以大幅提高性能 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = 123;
my $count = 0;
for (1..10_000_000) {
    if $^item.starts-with($n) {
        $count++;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># real 0m3.440s
# user 0m3.470s
# sys  0m0.044s</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一个想法是从这个<a href="http://jnthn.net/papers/2019-perlcon-performance.pdf">很酷的演讲</a>中偷来的 🙂</p>
</div>
</div>
<div class="sect2">
<h3 id="_7_比起_jvm_你会更喜欢_moarvm">78.61. 7. 比起 JVM, 你会更喜欢 MoarVM</h3>
<div class="paragraph">
<p>参考编码</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (1..10000000) -&gt; Int $item { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Rakudo + MoarVM 中运行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># real 0m0.388s
# user 0m0.287s
# sys  0m0.047s</code></pre>
</div>
</div>
<div class="paragraph">
<p>对比 Rakudo + JVM :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># real 0m21.290s
# user 0m32.255s
# sys  0m0.588s</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://rakuadventcalendar.files.wordpress.com/2020/11/vm.png?w=1024" alt="vm"/>
</div>
</div>
<div class="paragraph">
<p>不使用 JVM 的额外好理由。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JVM 的支持是不完整的 (来自 <a href="https://rakudo.org/news">rakudo 新闻</a>)</p>
</li>
<li>
<p>JVM 的启动时间要长得多</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_8_对于大整数_你不会处理">78.62. 8. 对于大整数, 你不会处理</h3>
<div class="paragraph">
<p>我们有性能处罚的大数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (1..2147483646) { }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># real 0m15.421s
# user 0m15.429s
# sys  0m0.040s</code></pre>
</div>
</div>
<div class="paragraph">
<p>相比之下</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (1..2147483647) { }
#                ^</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell"># real 17m1.909s
# user 16m59.627s
# sys  0m0.396s</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一点在这个代码示例中表现得尤为突出（对于非常小的跃迁, 会有巨大的惩罚） :/。</p>
</div>
<div class="paragraph">
<p>同样, 这个特殊的例子是不公平的（我报告了一个关于它的<a href="https://github.com/MoarVM/MoarVM/issues/1383">问题</a>）, 但你得到的想法是, 处理大 int（甚至是本地类型）不会比处理小 int 的成本相同…​…​</p>
</div>
</div>
<div class="sect2">
<h3 id="_9_更好的算法_你会一直搜索">78.63. 9. 更好的算法, 你会一直搜索</h3>
<div class="paragraph">
<p>虚拟机、编译器、优化…​…​对于糟糕的代码逻辑来说, 没有什么能帮得上忙 !</p>
</div>
<div class="paragraph">
<p>远离昂贵的内建或贪婪的分配算法, 认为循环内的一切都要优化。</p>
</div>
</div>
<div class="sect2">
<h3 id="_10_你永远不应该忘记的海森堡效应">78.64. 10. 你永远不应该忘记的海森堡效应</h3>
<div class="paragraph">
<p>可悲的是, 剖析可以使改变.的执行行为。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>你的执行行为</p>
</li>
<li>
<p>你的执行时间（有时会慢10倍…​)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>拥有线程也会让剖析器感到困惑（报告高达 90% 的时间都花在了垃圾收集上…​）。这是一种典型的问题, 例如, 如果你试图安装和使用 <a href="https://en.wikipedia.org/wiki/Signal_(IPC)">Unix 信号</a>来中断正在运行的剖析会话, 你可能会遇到这种问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结束语_5">78.65. 结束语</h3>
<div class="paragraph">
<p>Raku 与它的剖析器是一个非常酷的性能优化的游乐场 🙂。</p>
</div>
<div class="paragraph">
<p>根据我的看法, 在2020年, 还有一些地方需要改进(optims), 但原生类型已经可以让你获得往往比竞争对手好很多的性能, 这是非常好的。
== <a href="https://raku-advent.blog/2020/12/11/day-11-santa-claus-tweaks-with-a-class/">第十一天 - 圣诞老人用类进行微调</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_序幕">78.66. 序幕</h3>
<div class="paragraph">
<p>一天早上, 圣诞老人在 iPad 上浏览电子贸易杂志时, 看到最新的《O’Reilly 编程通讯》中提到的一篇<a href="https://www.wealthsimple.com/en-ca/magazine/cobol-controls-your-money?utm_medium=email&amp;utm_source=topic+optin&amp;utm_campaign=awareness&amp;utm_content=20201121+prog+nl&amp;mkt_tok=eyJpIjoiTmpWa1pEWTJNRE13WldZNSIsInQiOiJJXC9PQ1JRQWRvdjNhMWhHS0NmdHFnVE9kNGQ0Z3h5RXpMWm0wN0VlVHFYb1pvNTRrbUdlSVE0a09CSTAxKzVuVVltbzBtUjdKb3RzYVp5Z240Q2x1WUhhQlByWmRQNUJyNFBcL0d6c0Y1NGRXbU0yWUtHQ2xtN0luR0RIV3JtWjFjIn0%3D">文章</a>, 说到 COBOL 是多么古老的编程语言, 至今仍被世界上大部分商业软件所使用。</p>
</div>
<div class="paragraph">
<p>他已经意识到了这一点, 因为他的业务在几百年来一直走在大企业实践的最前沿, 他对自己的最大限度自动化的玩具工厂的尖端效率非常自豪。</p>
</div>
<div class="paragraph">
<p>自从 2015 年圣诞节正式发布拉里-沃尔的新 <a href="https://raku.org/">Raku</a> 以来, 他一直在密切关注（充满了闪烁）Raku, 并决定是时候将 Raku 的使用纳入他的新五年计划中了。(毕竟, 他思索着, 它应该是&#34;百年语言&#34;。)他很快就召集了他的 IT 员工领导开会, 让他们开始行动。</p>
</div>
<div class="paragraph">
<p>在会议上, 他分发了胡安-梅洛博士的新书<a href="https://www.apress.com/gp/book/9781484262573">《Raku 食谱》</a>, 以激励人群中的编码牛仔。&#34;现在各位, 让我们从头开始, 把 <a href="https://raku.org/">Raku</a> 作为北极 IT 专业学生最初的编程语言来教。同时, 确保所有现有的 IT 编码人员都有一本 JJ 的书, 我期望他们能在业余时间开始学习使用 Raku。&#34;他笑着说。&#34;并让他们都加入 #raku IRC 频道 &#34;他补充道。</p>
</div>
</div>
<div class="sect2">
<h3 id="_一堂关于类的课">78.67. 一堂关于类的课</h3>
<div class="paragraph">
<p>而 Raku 有一个简单易用但功能强大的类构造语法。例如, 看看这个简单的例子, 一个 Circle 类具有以下特点。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>构造后不可改变</p>
</li>
<li>
<p>用户在施工中输入半径或直径。</p>
</li>
<li>
<p>施工期间计算面积</p>
</li>
<li>
<p>施工时计算周长</p>
</li>
<li>
<p>如果不输入半径和直径, 就会产生错误。</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>$ cat circle-default</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">class Circle {
    has $.radius;
    has $.diam;
    has $.area = $!radius.defined
        ?? ( $!diam = $!radius * 2; pi * $!radius ** 2 )
        !! $!diam.defined
            ?? ( $!radius = $!diam * 0.5; pi * $!radius ** 2 )
            !! die &#34;FATAL: neither radius nor diam are defined&#34;;
    has $.circum = $!radius.defined
        ?? ( $!diam = $!radius * 2; pi * $!radius * 2 )
        !! $!diam.defined
            ?? ( $!radius = $!diam * 0.5; pi * $!radius * 2 )
            !! die &#34;FATAL: neither radius nor diam are defined&#34;;
}
say &#34;== enter radius&#34;;
my $radius = 3;
my $c = Circle.new: :$radius;
say &#34;radius: {$c.radius}&#34;;
say &#34;diam: {$c.diam}&#34;;
say &#34;area: {$c.area}&#34;;
say &#34;circum: {$c.circum}&#34;;

say &#34;== enter diam&#34;;
my $diam = 6;
$c = Circle.new: :$diam;
say &#34;radius: {$c.radius}&#34;;
say &#34;diam: {$c.diam}&#34;;
say &#34;area: {$c.area}&#34;;
say &#34;circum: {$c.circum}&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你注意到了什么构造？复杂的默认生成处理？</p>
</div>
<div class="paragraph">
<p>更复杂的几何图形会怎样？会变得更糟吧？</p>
</div>
<div class="paragraph">
<p>如何处理它们？是的, 有一些子方法可以帮助你。BUILD 和 TWEAK</p>
</div>
<div class="paragraph">
<p>我不会让你厌烦这些血淋淋的细节, 但你可以在&#34;文档&#34;中阅读所有关于它们的内容, 我稍后会向你介绍。</p>
</div>
<div class="paragraph">
<p>相反, 我建议直接跳到使用 TWEAK。它是在圣诞节发布后不久加入的, 因为它减轻了创建不可改变的实用类的负担。</p>
</div>
<div class="paragraph">
<p>看看使用 TWEAK 重写的 Circle 类。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>$ cat circle-tweak</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">class Circle {
    has $.radius;
    has $.diam;
    has $.area;
    has $.circum;

    submethod TWEAK {
        # Here we have access to all attributes and their values entered
        # in the new method!
        if $!radius.defined  {
            $!diam = $!radius * 2
        }
        elsif $!diam.defined {
            $!radius = $!diam * 0.5
        }
        else {
            die &#34;FATAL: neither radius nor diam are defined&#34;
        }
        $!area   =  pi * $!radius ** 2;
        $!circum =  pi * $!radius * 2;
    }
}
say &#34;== enter radius&#34;;
my $radius = 3;
my $c = Circle.new: :$radius;
say &#34;radius: {$c.radius}&#34;;
say &#34;diam: {$c.diam}&#34;;
say &#34;area: {$c.area}&#34;;
say &#34;circum: {$c.circum}&#34;;

say &#34;== enter diam&#34;;
my $diam = 6;
$c = Circle.new: :$diam;
say &#34;radius: {$c.radius}&#34;;
say &#34;diam: {$c.diam}&#34;;
say &#34;area: {$c.area}&#34;;
say &#34;circum: {$c.circum}&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两个简短的例子中, 通过 &#34;wc&#34; 比较类定义代码, 得到。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ wc circle-default-class-only circle-tweak-class-only
 14  90 541 circle-default-class-only
 19  59 430 circle-tweak-class-only
 33 149 971 total</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认类版本的行数确实少了, 但比 TWEAK 版本的字数和字符多了。TWEAK 版本不仅字数少了点, 我觉得维护和扩展起来也方便多了。为什么要优化, 因为清晰度更重要？还记得世界著名的计算机科学家和数学家 Donald Knuth 博士的名言：&#34;过早的优化是万恶之源&#34;。</p>
</div>
<div class="paragraph">
<p>现在我们来看一个类子方法的实际案例。我们正在为出版部门重写我们的页面排版软件。大家可能知道, 我们现在已经开始使用 David Warring 的精美的 <a href="https://pdf-raku.github.io/">Raku PDF 模块</a>直接编写 PDF, 但我们也用 PostScript 做了很多自动化的文档制作。在这两种情况下, 我们都使用约定的方式将页面对象（文本、图像等）的位置描述为 x,y 坐标的二维参考, 默认原点在页面的左下角, 正 x 轴和 y 轴分别指向右边和上方。</p>
</div>
<div class="paragraph">
<p>今天的课堂练习, 你们分成两个小精灵小组, 想出一个乐类来描述页面上的矩形区域, 将包含文字或图片。你们在高中时都学过几何学, 但也许需要复习一下。</p>
</div>
<div class="paragraph">
<p>长方形是一个对边平行的四边形（一种四边形的平面图形）, 相邻的边互成直角。相邻的边可以有不同的长度。注意我们不会认为边长为零的矩形有效。</p>
</div>
<div class="paragraph">
<p>一个自由浮动的矩形可以由它的宽度和长度精确定义。在正交 x,y 平面上的固定矩形, 它的一条对角线必须由它的两个端点的坐标或一个端点和对角线与正 x 轴之一的角度来定义。</p>
</div>
<div class="paragraph">
<p>我们类的要求如下。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过默认的新方法实现一致性后的不变性。</p>
</li>
<li>
<p>由左下角和(1)右上角或(2)它的宽度和高度定义。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在我们的练习中, 观察以下约束条件。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>矩形的边缘总是平行于 x 或 y 轴的</p>
</li>
<li>
<p>矩形的边长有限</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你的作品至少应该有必要的属性来定义和定位你的类。你还应该有代码来显示你的类的实例的创建。</p>
</div>
<div class="paragraph">
<p>请注意, 当我设计我的 Box 类的版本时, 我同时为它写了一个测试。然后我在继续的过程中对每一个都进行了完善, 直到我对这两个类都满意为止。这个测试实际上是指定了我的设计, 就像 Raku 语言一样, 它是由其广泛的测试套件定义的, 被称为 <a href="https://github.com/Raku/roast#the-official-raku-test-suite">roast</a>。我将用该测试检查你的工作。</p>
</div>
<div class="paragraph">
<p>你可以开始, 将有几分钟的时间来完成任务。完成后请举手—​第一个完成的小组将获得一根糖果棒棒糖。</p>
</div>
<div class="paragraph">
<p>…​</p>
</div>
<div class="paragraph">
<p>好了, A 组展示你们的类：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>$ cat BoxA.rakumod</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">class Box is export {

                        ;
                       ;;;
                        ;
                       ;;;
                      ;;;;;
                     ;;;;;;;
                    ;;has$.h;
                   ;;;;;;;;;;;
                  ;;;has$.urx;;
                 ;;;;;;;;;;;;;;;
                ;;;has$.ury;;;;;;
               ;;;;;;;;;;;;;;;;;;;
              ;;;;;;;;;;;;has$.w;;;
             ;;;has$.llx;;;;;;;;;;;;
            ;;;;;;;;;;;;;;;;;;;;;;;;;
           ;;;;;;;;;;;;;;has$.lly;;;;;
          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                       ;;;
                     ;;;;;;;

    method width {
        $!urx - $!llx
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>嗬, 嗬, 嗬！真是个小 ASCII 艺人, 不是吗？让我们看看 Python 能不能超越它! 现在让我们试试…​</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>$ cat testA.raku</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">use lib &#39;.&#39;;
use BoxA;
my ($llx, $lly, $urx, $ury) = 0, 0, 2, 3;
my $o = Box.new: :$llx, :$lly, :$urx, :$ury;
say $o.width;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku testA.raku
2</code></pre>
</div>
</div>
<div class="paragraph">
<p>嗯, 我至少看到一个问题。你已经添加了所有的属性, 但宽度方法依赖于可能尚未初始化的属性。如果用户这样做了呢。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>$ cat testA2.raku</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-Raku" data-lang="Raku">use lib &#39;.&#39;;
use BoxA;
my ($llx, $lly, $w, $h) = 0, 0, 2, 3;
my $o = Box.new: :$llx, :$lly, :$w, :$h;
say $o.width;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku testA2.raku
Use of uninitialized value of type Any in numeric context
  in method width at BoxA.rakumod (BoxA) line 24
0</code></pre>
</div>
</div>
<div class="paragraph">
<p>轰！我们得到了一个无效的答案加上一个错误信息! 如何修改你的代码来正确处理宽度和长度？ 避免出现异常？另一组请将该代码进行相应修改。</p>
</div>
<div class="paragraph">
<p>还有把 ASCII 艺术去掉, 不然驯鹿会以为是什么好吃的东西, 吼吼吼!</p>
</div>
<div class="paragraph">
<p>有谁知道？是的, C 组, 请展示你的解决方案。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>$ cat BoxC.rakumod</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module BoxC;
class Box is export {
    has$.llx;
    has$.lly;
    has$.urx;
    has$.ury;
    has$.w;
    has$.h;
    method width {
        if $!urx.defined {
            $!urx - $!llx
        }
        elsif $!w.defined {
            $!w
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>还是同样的测试:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>$ cat testC.raku</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use lib &#39;.&#39;;
use BoxC;
my ($llx, $lly, $w, $h) = 0, 0, 2, 3;
my $o = Box.new: :$llx, :$lly, :$w, :$h;
say $o.width;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku testA2.raku
2</code></pre>
</div>
</div>
<div class="paragraph">
<p>好的, 很好。但为什么我们不利用 Raku 的默认方法来显示公共属性的值呢？我们不应该添加我们自己的宽度方法, 或者任何其他方法。有什么想法吗？</p>
</div>
<div class="paragraph">
<p>好了, 圣诞节的朋友们, 圣诞老人的时间快到了, 我必须马上离开你们。另外, 我知道的并不比你们多, 你们要想知道血淋淋的细节, 就得去挖关于类构造的&#34;文档&#34;。<a href="https://docs.raku.org/language/classtut#index-entry-BUILD">这里</a>和<a href="https://docs.raku.org/language/objects#Object_construction">这里</a>有两个地方特别提到了 BUILD 和 TWEAK 以及它们的区别。</p>
</div>
<div class="paragraph">
<p>也可以在 IRC 频道 #raku 上寻求更有经验的 Rakoons（Raku 用户的友好社区）的帮助。</p>
</div>
<div class="paragraph">
<p>大家做得很好! 我也不会给你们留下未完成的任务。</p>
</div>
<div class="paragraph">
<p>我是一个务实的程序员和生意人, &#34;实际类建设的底线是&#34;切入正题&#34;, 使用 TWEAK 子方法, &#34;处理好生意&#34;。</p>
</div>
<div class="paragraph">
<p>请看下面 APPENDIX 中我的最终解决方案。这是我对一个实用的、健壮的、不可改变的类的想法, 借助 TWEAK 子方法。正如他们在 IRC 上所说的, &#34;YMMV&#34;（你的里程可能会有所不同）。</p>
</div>
<div class="paragraph">
<p>现在我要给班上的每个人发糖果棒和糖李子了, 嗬, 嗬, 嗬!</p>
</div>
<div class="paragraph">
<p>祝大家圣诞快乐, 也祝你们和家人新年快乐! 乐在其中, 乐在其中, 乐在其中!</p>
</div>
</div>
<div class="sect2">
<h3 id="_注意事项">78.68. 注意事项</h3>
<div class="paragraph">
<p>对于本文的灵感, 我感谢我的朋友 JJ Merelo 和他的新书 Raku Recipes（上面提到）。</p>
</div>
<div class="paragraph">
<p>圣诞老人的灵感来自于观看 1994 年蒂姆-艾伦主演的精彩电影《圣诞老人》的重播。(请注意, 还有续集《圣诞老人 2》, 于 2002 年上映, 《圣诞老人 3：逃亡的圣诞老人》, 于 2006 年上映)。如果你从来没有听说过圣诞老人的北极人口被估计在 100 万以上的精灵, 我指给你看今年的电影<a href="https://www.imdb.com/title/tt11057644/?ref_=fn_al_tt_1">《圣诞编年史 2》</a>, 并提出一个问题：如果没有一个比亚马逊、联邦快递、UPS 和美国邮政加起来还要大的资源运作, 你认为数百万儿童如何能在圣诞节被圣诞老人留下礼物？
附录</p>
</div>
<div class="paragraph">
<p>下图所示的最终解决方案也可以在 Github 的<a href="https://github.com/tbrowder/advent2020/solution">这个 repo</a> 中找到。在该目录下运行 &#39;make&#39;, 运行 verbose 测试的结果是。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">RAKULIB=lib prove -v --exec=raku t/*.t
t/test-box.t ..
ok 1 - begin testing incomplete new args, all tests die-ok
ok 2 -
ok 3 -
ok 4 -
ok 5 -
ok 6 -
ok 7 -
ok 8 - end testing incomplete new args
ok 9 - builds ok
ok 10 - builds ok
ok 11 - given w,h calculate urx,ury
ok 12 -
ok 13 - given urx,ury calculate w,h
ok 14 -
ok 15 - given urx,ury and w,h use w,h
ok 16 -
ok 17 -
ok 18 -
ok 19 - invalid: llx &gt; urx (this and all following tests die-ok)
ok 20 - invalid: lly &gt; ury
ok 21 - invalid: w &lt;= zero
ok 22 - invalid: h &lt;= zero
1..22
ok
All tests successful.
Files=1, Tests=22,  0 wallclock secs ( 0.01 usr  0.01 sys +  0.34 cusr  0.03 csys =  0.39 CPU)
Result: PASS</code></pre>
</div>
</div>
<div class="paragraph">
<p>模块文件 Box.rakumod:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit class Box;

# must define all two:
has $.llx;
has $.lly;

# must define one of the two:
has $.urx;
has $.w;

# must define one of the two:
has $.ury;
has $.h;

submethod TWEAK {
    # check mandatory attrs
    my $err = 0;
    my $msg = &#34;FATAL: class Box undefined attr(s):\n&#34;;
    if not $!llx.defined {
        ++$err;
        $msg ~= &#34;\$llx\n&#34;;
    }
    if not $!lly.defined {
        ++$err;
        $msg ~= &#34;\$lly\n&#34;;
    }
    if not $!urx.defined and not $!w.defined {
        ++$err;
        $msg ~= &#34;\$urx and \$w\n&#34;;
    }
    if not $!ury.defined and not $!h.defined {
        ++$err;
        $msg ~= &#34;\$ury and \$h\n&#34;;
    }
    die $msg if $err;

    # h vs ury
    # h has precedence over ury
    if $!h.defined {
        $!ury = $!lly + $!h;
    }
    elsif $!ury.defined {
        $!h   = $!ury - $!lly;
    }
    # w vs urx
    # w has precedence over urx
    if $!w.defined {
       $!urx = $!llx + $!w;
    }
    elsif $!urx.defined {
       $!w   = $!urx - $!llx;
    }

    $msg = &#34;FATAL: class Box has invalid attr(s):\n&#34;;
    # ensure urx &gt; llx
    if $!urx &lt; $!llx {
        ++$err;
        $msg ~= &#34;\$llx &gt; \$urx\n&#34;;
    }
    # ensure ury &gt; lly
    if $!ury &lt; $!lly {
        ++$err;
        $msg ~= &#34;\$lly &gt; \$ury\n&#34;;
    }
    # ensure w &gt; 0
    if $!w &lt;= 0 {
        ++$err;
        $msg ~= &#34;\$w &lt;= zero\n&#34;;
    }
    # ensure h &gt; 0
    if $!h &lt;= 0 {
        ++$err;
        $msg ~= &#34;\$h &lt;= zero\n&#34;;
    }
    die $msg if $err;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>测试文件的内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Test;
use Box;

my $o;
# assign values to be used for all class attrs
my $llx = 0;
my $lly = 0;
my $urx = 1;
my $ury = 2;
my $w   = 3;
my $h   = 4;

# object should die during construction if required attrs aren&#39;t provided
dies-ok {$o = Box.new: :$llx, :$lly, :$urx}, &#34;begin testing incomplete new args, all tests die-ok&#34;;
dies-ok {$o = Box.new: :$llx, :$lly, :$ury};
dies-ok {$o = Box.new: :$lly, :$urx, :$ury};
dies-ok {$o = Box.new: :$llx, :$urx, :$ury};
dies-ok {$o = Box.new: :$llx, :$lly, :$w};
dies-ok {$o = Box.new: :$llx, :$lly, :$h};
dies-ok {$o = Box.new: :$lly, :$w, :$h};
dies-ok {$o = Box.new: :$llx, :$w, :$h}, &#34;end testing incomplete new args&#34;;
# builds ok with expected args
lives-ok {$o = Box.new: :$llx, :$lly, :$urx, :$ury}, &#34;builds ok&#34;;
lives-ok {$o = Box.new: :$llx, :$lly, :$w, :$h}, &#34;builds ok&#34;;

$o = Box.new: :$llx, :$lly, :$w, :$h;
is $o.urx, 3, &#34;given w,h calculate urx,ury&#34;;
is $o.ury, 4;

$urx = 1;
$ury = 2;
$o = Box.new: :$llx, :$lly, :$urx, :$ury;
is $o.w, 1, &#34;given urx,ury calculate w,h&#34;;
is $o.h, 2;

# test precedence of h,w over ury,urx
$llx = 1;
$lly = 2;
$urx = 2;
$ury = 3;
$w   = 4;
$h   = 5;
$o = Box.new: :$llx, :$lly, :$urx, :$ury, :$w, :$h;
is $o.w, 4, &#34;given urx,ury and w,h use w,h&#34;;
is $o.urx, 5;
is $o.h, 5;
is $o.ury, 7;

# ensure urx &gt; llx
$llx = 3;
$urx = 2;
$lly = 2;
$ury = 3;
dies-ok {$o = Box.new: :$llx, :$lly, :$urx, :$ury;}, &#34;invalid: llx &gt; urx (this and all following tests die-ok)&#34;;

# ensure ury &gt; lly
$llx = 1;
$urx = 2;
$lly = 2;
$ury = 1;
dies-ok {$o = Box.new: :$llx, :$lly, :$urx, :$ury;}, &#34;invalid: lly &gt; ury&#34;;

# ensure w &gt; zero
$llx = 1;
$urx = 1;
$lly = 2;
$ury = 1;
dies-ok {$o = Box.new: :$llx, :$lly, :$urx, :$ury;}, &#34;invalid: w &lt;= zero&#34;;

# ensure h &gt; zero
$llx = 1;
$urx = 2;
$lly = 1;
$ury = 1;
dies-ok {$o = Box.new: :$llx, :$lly, :$urx, :$ury;}, &#34;invalid: h &lt;= zero&#34;;

done-testing;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_第十二天_那种快乐的感觉">79. <a href="https://raku-advent.blog/2020/12/12/day-12-that-raku-feeling/">第十二天 - 那种快乐的感觉</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>当我们谈论测量时间时, 我们可能会想到许多不同的方法来测量许多不同的东西。但从原则上讲, 我想我们可以把它们分为两大类。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们可以测量与之前的事件相关的时间, 例如, 看看自那时以来已经过去了多少时间(比如你数到100需要多长时间);或</p>
</li>
<li>
<p>我们可以测量时间到某个未来的事件, 例如看看在这之前是否发生了一些事情（比如是否该把蛋糕从烤箱里拿出来了）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些场景已经很常见了, <a href="https://raku.org">Raku</a> 把这些场景都涵盖了也就不足为奇了。</p>
</div>
<div class="sect2">
<h3 id="_从过去算起">79.1. 从过去算起</h3>
<div class="paragraph">
<p>例如, 我们可以这样测量一件事花了多长时间。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $start = now;
my $prime = (^∞).grep(*.is-prime)[999]; # Do something slow...
say &#34;Took { now - $start } seconds to find the 1000th prime: $prime&#34;;
# OUTPUT:
# Took 0.9206044 seconds to find the 1000th prime: 7919</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以做到这一点, 因为 Raku 有类来帮助我们正确地处理这个问题。<a href="https://docs.raku.org/routine/now"><code>now</code></a> 例程返回一个 <a href="https://docs.raku.org/type/Instant">Instant</a>, 它代表了一个特定的时间时刻。当我们对这些对象进行运算时（就像我们执行 <code>now - $start</code> 时一样）, 我们会得到一个 <a href="https://docs.raku.org/type/Duration">Duration</a> 对象, 它代表一个时间长度。</p>
</div>
<div class="paragraph">
<p>这些时间类（以及其他 <a href="https://docs.raku.org/type/DateTime">相关</a><a href="https://docs.raku.org/type/Date">的</a>）很好地支持了许多常见的时间操作, 它们的文档是一个很好的地方, 可以寻找关于它们的能力以及如何使用它们的想法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_数到未来">79.2. 数到未来</h3>
<div class="paragraph">
<p>要对未来的事件进行&#34;倒计时&#34;, 我们需要能够代表一个事件, Raku 也有这个功能。它叫做 <a href="https://docs.raku.org/type/Promise">Promise</a>, 它代表的是一个尚未结束的过程的结果。从某种意义上说, <a href="https://docs.raku.org/type/Promise">Promise</a> 是一个占位值, 是运行时的一个承诺, 当某个待处理的进程结束后, 我们就可以找到它的结果。</p>
</div>
<div class="paragraph">
<p>这可能听起来很抽象, 这是因为…​它确实是抽象的。不像 <a href="https://docs.raku.org/type/Instant">Instant</a>或 <a href="https://docs.raku.org/type/Duration">Duration</a>, 它们代表了时间的特定方面, <a href="https://docs.raku.org/type/Promise">Promise</a> 可以代表该过程的任何结果, 不管是什么过程。这个结果可以是时间的某一瞬间, 但也可以是网页的文字, 或者是一些复杂的数学运算的结果, 或者任何东西, 真的。</p>
</div>
<div class="paragraph">
<p>为了说明这一点, 我们可以使用其中一个 <a href="https://docs.raku.org/type/Promise">Promise</a> 对象来测量我们在时间耗尽之前可以找到的质数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $one-second-passed = Promise.in: 1;
my @primes = gather for (^∞).grep: *.is-prime {
    .take;
    last if $one-second-passed;
}
await $one-second;
say &#34;Found { @primes.elems } primes in 1 second&#34;;
# OUTPUT:
# Found 1057 primes in 1 second</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们创建一个 <a href="https://docs.raku.org/type/Promise">Promise</a>, 它将在一秒钟内被保留, 作为我们的超时, 我们使用 <a href="https://docs.raku.org/language/control#gather/take"><code>gather</code> 和 <code>take</code></a> 在循环中填充我们的质数列表。</p>
</div>
<div class="paragraph">
<p>在向列表中添加一个新的质数后, 我们检查 <a href="https://docs.raku.org/type/Promise">Promise</a> 是否被保留, 如果是, 我们就停止。</p>
</div>
<div class="paragraph">
<p>我们可以用目前所提到的东西覆盖很多简单的案例, 很多时候像这些解决方案可能就足够了。但有些情况下, 这些基本工具就显得不够用了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_移动的门柱">79.3. 移动的门柱</h3>
<div class="paragraph">
<p>比方说, 现在的任务不是测量你数到100所需的时间, 而是要数出你能在规定的时间内数到100的次数。</p>
</div>
<div class="paragraph">
<p>或者, 如果你想要一个更现实的例子, 比如想一想每30秒发送一次心跳的服务器的连接。如果过了这个时间还没有收到心跳, 我们就想关闭这个连接。</p>
</div>
<div class="paragraph">
<p>或者是一个需要向外部服务批量发送请求的进程。我们希望在每个请求产生后, 最多等待一秒钟, 然后再发射一个批次, 并继续等待下一个请求。</p>
</div>
<div class="paragraph">
<p>这些方案是我们上面讨论的两种情况的组合。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它们从过去的一个点开始测量：你开始一个新的计数, 或收到一个心跳, 或生成一个请求的点。</p>
</li>
<li>
<p>它们朝向未来的一个点进行测量：当你没有时间完成计数时, 或当我们决定没有心跳时, 或当我们决定是时候发送新的请求批时。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这里的关键区别在于, 这些情况下的&#34;最后期限&#34;并不是固定的：如果我们确实在规定时间内收到了新的心跳, 那么倒计时就会被重置, 我们会从头开始计算。</p>
</div>
</div>
<div class="sect2">
<h3 id="_承诺和馅饼皮">79.4. 承诺和馅饼皮</h3>
<div class="paragraph">
<p>事实证明, 目前 <a href="https://docs.raku.org/type/Promise">Promise</a> 的设计使得这种表示方式有点尴尬, 因为它们表示的是一个待定过程的结果的占位符。这意味着它们对该进程没有直接控制权。而如果我们希望它们适用于最多的场景, 就应该是这样的。</p>
</div>
<div class="paragraph">
<p>考虑一下上面这段天真的代码版本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @primes;
await Promise.anyof(
    Promise.in(1),
    start { # See below for why this is a bad idea
        @primes.push: $_ for (^∞).grep: *.is-prime;
    },
);
say &#34;Found { @primes.elems } primes in 1 second&#34;;
# OUTPUT:
# Found 1057 primes in 1 second</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码将产生与上面那段相同的输出, 但它的行为并不相同。关键的区别（和问题）是, 这段代码永远不会停止向 <code>@primes</code> 推送元素。<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup> 这是因为由 <a href="https://docs.raku.org/language/control#start"><code>start</code></a> 关键字启动的进程将继续运行, 只要它能运行, 即使我们不再关注。</p>
</div>
<div class="paragraph">
<p>幸运的是, Raku 是一门为扩展而生的语言, 而恰好 <a href="https://modules.raku.org/dist/Timer::Breakable:cpan:SCIMON">Timer::Breakable</a> 的形式就存在这个问题的解决方案。</p>
</div>
<div class="paragraph">
<p><a href="https://modules.raku.org/dist/Timer::Breakable:cpan:SCIMON">Timer::Breakable</a> 可以理解为一种 <a href="https://docs.raku.org/type/Promise">Promise</a>, 就像馅饼皮一样, 是用来打破的<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>, 有了它, 我们就可以解决这个移动门柱的问题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Timer::Breakable;

my $disconnect = Promise.new;
my $heartbeat  = Supply.interval(0.5).grep: { Bool.pick }

my Timer::Breakable $timeout;
react {
    whenever $disconnect { done }
    whenever $heartbeat {
        say &#39;-- THUMP --&#39;;
        .stop with $timeout;
        $timeout = Timer::Breakable.start: 0.75, {
            say &#39;No heartbeat! Disconnecting...&#39;;
            $disconnect.keep;
        }
    }
}
# OUTPUT:
# -- THUMP --
# -- THUMP --
# -- THUMP --
# -- THUMP --
# -- THUMP --
# No heartbeat! Disconnecting...</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用 <a href="https://docs.raku.org/type/Supply">Supply</a> 生成一个不规则的心跳流（我们稍后会再谈这个, 我保证）, 并在 <a href="https://docs.raku.org/language/concurrency#react"><code>react</code></a> 块中监听它们。
我们还创建了一个新的 <a href="https://docs.raku.org/type/Promise">Promise</a>, 它将代表连接：一旦它被保留, 我们就可以认为它是安全的, 可以断开连接。</p>
</div>
<div class="paragraph">
<p>每当我们收到一个新的心跳时, <code>.stop with $timeout</code> 检查我们是否已经定义了一个定时器, 如果是, 就停止是（如果我们没有, 即使新的心跳已经按时到达, 我们也会中断连接）。然后, 我们创建一个新的定时器, 它将在保持我们的 <a href="https://docs.raku.org/type/Promise">Promise</a> 之前等待一个设定的时间量（本例中为0.75秒）。由于我们正在等待该 link:<a href="https://docs.raku.org/type/Promise">Promise</a>（与第一个 <a href="https://docs.raku.org/language/concurrency#whenever">whenever</a>）, 这将允许我们检测何时可以关闭&#34;连接&#34;。</p>
</div>
</div>
<div class="sect2">
<h3 id="_一人之下万人之上">79.5. 一人之下万人之上</h3>
<div class="paragraph">
<p>还有一种情况是我们上面提到的例子, 我们还没有完全讲到的：批处理的情况。</p>
</div>
<div class="paragraph">
<p>从根本上来说, 这和我们刚才看的那个并没有什么不同, 不同的是, 我们并不是完全断开连接, 而是在时间耗尽的时候, 我们要做的是处理这批物品, 然后继续等待, 这次是下一批物品。</p>
</div>
<div class="paragraph">
<p>这就涉及到 <a href="https://docs.raku.org/type/Promise">Promise</a> 的另一个局限性：它们代表的是一个待处理的结果。或者说, 换句话说, 它们可以被遵守或被打破, 但只能是一次。</p>
</div>
<div class="paragraph">
<p>就像我们上面提到的限制一样, 这样做是有充分的理由的：因为 Raku 允许我们使用高度异步的代码, 让一个 <a href="https://docs.raku.org/type/Promise">Promise</a> 只从&#34;计划&#34;变为其他状态一次, 限制了一系列我们不需要担心的问题。<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup></p>
</div>
<div class="paragraph">
<p>然而, 在这种特殊情况下, 这给我们带来了一个问题。事实上, 我们已经在上面的片段中解决了这个问题：每当我们收到一个新的心跳, 我们就必须创建一个新的 <code>$timer</code>。我们不能重置它。</p>
</div>
<div class="paragraph">
<p>由于 <a href="https://modules.raku.org/dist/Timer::Breakable:cpan:SCIMON">Timer::Breakable</a> 包裹着 <a href="https://docs.raku.org/type/Promise">Promise</a>, 所以它继承这个特性也就不足为奇了。</p>
</div>
<div class="paragraph">
<p>所以在这种情况下, <a href="https://docs.raku.org/type/Promise">Promise</a> 并不是合适的工具。相反, 我们可以最终遵守我们在上面做出的承诺, 并达到 <a href="https://docs.raku.org/type/Supply">Supply</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_每种需求都有供应">79.6. 每种需求都有供应</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Supply">Supply</a> 是一个异步数据流, 可以被我们程序中的多个观察者使用。我们已经用了一个来表示我们的不规则心跳系列, 这次我们将添加一个来表示准备处理的批次流。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Timer::Breakable;

my $batcher = Supplier.new;
my $batch   = $batcher.Supply;
my $stream  = Supply.interval(0.5).grep: { Bool.pick }

my Timer::Breakable $timeout;
my @batch;
react {
    whenever $batch {
        say &#34;Received a batch: { @batch.join: &#39; &#39; }&#34;;
        @batch = ();
    }
    whenever $stream {
        say &#34;Queuing $_&#34;;
        @batch.push: $_;

        .stop with $timeout;
        $timeout = Timer::Breakable.start: 0.75, {
            $batcher.emit: True
        }
    }
}
# OUTPUT:
# Queuing 0
# Received a batch: 0
# Queuing 2
# Received a batch: 2
# Queuing 8
# Queuing 9
# Queuing 10
# Received a batch: 8 9 10
# ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的代码与前面的例子类似, 不同的是, 我们没有保留一个 <a href="https://docs.raku.org/type/Promise">Promise</a> 来断开连接, 而是在计时器耗尽, 我们准备好处理该批次时, 我们 <a href="https://docs.raku.org/type/Supplier#method_emit"><code>emit</code></a> 一个信号给 <a href="https://docs.raku.org/type/Supplier">Supplier</a>。</p>
</div>
<div class="paragraph">
<p>这将触发该批次的处理, 得到重置, 我们可以等待下一批。</p>
</div>
<div class="paragraph">
<p>我们需要添加代码来管理 <a href="https://docs.raku.org/type/Supply">Supply</a>, 因为 [Timer::Breakable] 是 <a href="https://docs.raku.org/type/Promise">Promise</a> 的一种扩展版本, 而我们已经确定 <a href="https://docs.raku.org/type/Promise">Promise</a> 是不足以直接表示我们想要的东西。</p>
</div>
<div class="paragraph">
<p>为此, 我们需要一个表示定时事件流的东西（像 <a href="https://docs.raku.org/type/Supply">Supply</a>）, 每个事件都可以被取消（像 <a href="https://modules.raku.org/dist/Timer::Breakable:cpan:SCIMON">Timer::Breakable</a>）。</p>
</div>
<div class="paragraph">
<p>像 <a href="https://modules.raku.org/dist/Timer::Stopwatch:cpan:JJATRIA">Timer::Stopwatch</a> 这样的东西。</p>
</div>
</div>
<div class="sect2">
<h3 id="_今天晚上绕着走">79.7. 今天晚上绕着走</h3>
<div class="paragraph">
<p>上面的例子可以用 <a href="https://modules.raku.org/dist/Timer::Stopwatch:cpan:JJATRIA">Timer::Stopwatch</a> 重新编写, 避免了很多信号管理的模板。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Timer::Stopwatch;

my $stream = Supply.interval(0.5).grep: { Bool.pick }

my Timer::Stopwatch $timer .= new;
my @batch;
react {
    whenever $timer { # This implictly listens to $timer.Supply
        say &#34;Received a batch: { @batch.join: &#39; &#39; }&#34;;
        @batch = ();
    }
    whenever $stream {
        say &#34;Queuing $_&#34;;
        @batch.push: $_;
        $timer.reset: 0.75;
    }
}
# OUTPUT:
# Queuing 1
# Queuing 2
# Received a batch: 1 2
# Queuing 6
# Received a batch: 6
# Queuing 8
# Queuing 9
# Queuing 10
# Received a batch: 8 9 10
# ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的区别是, 我们有一个 <a href="https://docs.raku.org/language/concurrency#whenever"><code>whenever</code></a> 直接监听定时器（它隐含地调用 <code>.Supply</code> 在它身上等待它的内部 <a href="https://docs.raku.org/type/Supply">Supply</a>）, 还有一个单独的监听流中的事件。当一个新的事件通过流到达时, 我们将其添加到出 <code>@batch</code> 并重置定时器。</p>
</div>
<div class="paragraph">
<p>这应该会让这样的情况表示得更简单, 对于更复杂的情况, 它还包括了确定重置一个定时器是否中断了正在运行的定时器的方法。它可以像这个例子一样, 作为一个倒计时器使用, 也可以作为一个开放式定时器使用。就像它环绕着一个 <a href="https://docs.raku.org/type/Supply">Supply</a> 来代表经过它的事件流一样, 它也环绕着一个 <a href="https://docs.raku.org/type/Promise">Promise</a> 来代表定时器的寿命, 它可以不可逆地停止。</p>
</div>
<div class="paragraph">
<p>以前使用过 <a href="https://golang.org/">Go</a> 的开发者可能会发现它的接口很熟悉, 因为 <a href="https://modules.raku.org/dist/Timer::Stopwatch:cpan:JJATRIA">Timer::Stopwatch</a> 是为了模仿 Go 的 <a href="https://golang.org/pkg/time/#Timer"><code>time.Timer</code></a> 的大部分接口而设计的。事实上, 它已经被证明是非常有效的<a href="https://pinguinorodriguez.cl/blog/porting-from-go">将在 Go 中编写的行为移植到更简单的 Raku 代码中</a>, 合理地利用我们一直在讨论的 Raku 类所提供的能力。</p>
</div>
</div>
<div class="sect2">
<h3 id="_对_raku_的感觉">79.8. 对 Raku 的感觉</h3>
<div class="paragraph">
<p>在我开始认真编写 Raku 之前, 我经常会花一些时间在这里和那里浏览文档, 对似乎无穷无尽的类型和类的景观感到惊奇, 这些类型和类代表了一系列在我看来非常微妙的差异。我不知道自己是否有足够的知识来自信地决定 <a href="https://docs.raku.org/type/Map">Map</a>、<a href="https://docs.raku.org/type/Bag">Bag</a> 或 <a href="https://docs.raku.org/type/Hash">Hash</a> 是否是正确的工具（更不用说 <a href="https://docs.raku.org/type/SetHash">SetHash</a> 或 <a href="https://docs.raku.org/type/BagHash">BagHash</a>了）。</p>
</div>
<div class="paragraph">
<p>事实证明, 在写 <a href="https://modules.raku.org/dist/Timer::Stopwatch:cpan:JJATRIA">Timer::Stopwatch</a> 时, 我学到的最有启发性的东西之一就是, 虽然 Raku 很庞大, 但并不是难以管理的。而且它的多功能性意味着你可以使用你熟悉的工具, 如果你愿意的话, 还可以花时间去探索新事物。这毕竟是<a href="https://docs.raku.org/language/glossary#TMTOWTDI">有不止一种方法</a>的本质。</p>
</div>
<div class="paragraph">
<p>当你这样做的时候, 你也会感觉到不同的类型是为了代表什么, 更重要的是, 他们不是什么。也就有了对 Raku 本身的感觉。我慢慢的觉得我开始明白什么是 Raku 的感觉。</p>
</div>
<div class="paragraph">
<p>如果你刚开始接触 Raku, 我在本文中提到的概念可能会显得很混乱。它有时可能看起来像有太多的选择, 太多的可能性, 这可能是吓人的。我知道对我来说是这样的。</p>
</div>
<div class="paragraph">
<p>但我敢保证, 乐乐从外面看感觉更大, 而一旦进入, 它的大小感觉就不像威胁, 而更像是一种邀请。</p>
</div>
<div class="paragraph">
<p>谁知道在下一次点击鼠标之后, 还有什么在等着呢？</p>
</div>
<div class="paragraph">
<p>只有时间会告诉我们。
== <a href="https://raku-advent.blog/2020/12/13/day-13-helping-the-github-action-elves/">帮助 Github Action 的小精灵们</a></p>
</div>
<div class="paragraph">
<p>作为一个 <a href="https://raku.org/">Raku 编程语言</a>模块的开发者, 你有时会对你所使用的工具感到惊讶。在这种情况下, 你真的被 Shoichi Kaji 的优秀的 <a href="https://modules.raku.org/dist/App::Mi6:cpan:SKAJI">App::Mi6</a> 工具最近的一次更新所惊讶。在升级之后, 它开始在新的发行版中添加一个 <code>.github/workflows/test.yml</code> 文件。而这又导致 Github 在每次提交后使用 <a href="https://github.com/features/actions">Github Actions</a> 测试发行版。这很好, 尤其是当它发现问题的时候!</p>
</div>
<div class="paragraph">
<p>那么这个文件是由什么组成的呢？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">    name: test

    on:
      push:
        branches:
          - &#39;*&#39;
        tags-ignore:
          - &#39;*&#39;
      pull_request:

    jobs:
      raku:
        strategy:
          matrix:
            os:
              - ubuntu-latest
              - macOS-latest
              - windows-latest
            raku-version:
              - &#39;latest&#39;
        runs-on: ${{ matrix.os }}
        steps:
          - uses: actions/checkout@v2
          - uses: Raku/setup-raku@v1
            with:
              raku-version: ${{ matrix.raku-version }}
          - name: Install Dependencies
            run: zef install --/test --test-depends --deps-only .
          - name: Install App::Prove6
            run: zef install --/test App::Prove6
          - name: Run Tests
            run: prove6 -l t</code></pre>
</div>
</div>
<div class="paragraph">
<p>里面有相当多的 <a href="https://en.wikipedia.org/wiki/YAML">YAML</a>! 但要点基本明确：在最新的 <a href="https://en.wikipedia.org/wiki/Ubuntu">Ubuntu</a>/<a href="https://en.wikipedia.org/wiki/MacOS">MacOS</a>/<a href="https://en.wikipedia.org/wiki/Microsoft_Windows">Windows</a> 操作系统上运行该模块的测试, 并使用最新的 Raku 版本。看到你的模块自动获得<a href="https://en.wikipedia.org/wiki/Continuous_integration">持续集成</a>支持是多么的容易, 真的是太好了。</p>
</div>
<div class="paragraph">
<p>当然, 作为模块开发者, 如果一个模块的测试失败了, 你会收到一个通知（在这种情况下是一封电子邮件）。我就是这样发现, 很多依靠 <a href="https://docs.raku.org/language/nativecall">NativeCall 调用</a> <a href="https://en.wikipedia.org/wiki/C_standard_library">C 库</a>函数的模块, 如果依靠 <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> 语义, 在 Windows 上根本就会失败。</p>
</div>
</div>
<div class="sect2">
<h3 id="_喜欢绿灯">79.9. 喜欢绿灯</h3>
<div class="paragraph">
<p>看到绿色总是好的, 比如 <a href="https://github.com/lizmat/Hash-LRU/actions/runs/337667222">Hash::LRU</a> 的测试结果。但有件事让你们印象深刻：测试时间超过5分钟？从<a href="https://github.com/lizmat/Hash-LRU/runs/1331938416?check_suite_focus=true">每一步的时间</a>来看, &#34;安装 <a href="https://modules.raku.org/dist/App::Prove6">App::Prove6</a>&#34;这一步用了3分多钟! 而模块的实际测试只运行了2秒。看起来有很多的开销, 特别是当一个模块没有任何外部依赖的时候。</p>
</div>
<div class="paragraph">
<p>现在, 当我在本地测试模块时, 我通常是这样做的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku -Ilib t/01-basic.t
# or whatever test-file that shows a problem</code></pre>
</div>
</div>
<div class="paragraph">
<p>为什么要这样做呢？嗯, 其实是因为这样可以在测试文件中直接添加任何调试代码, 在出现故障的情况下, 更容易追踪到错误。而如果有执行错误, <code>--ll-exception</code> 通常也会被添加到调用中, 以获得更显而易见的回溯, 比如这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku -Ilib --ll-exception t/01-basic.t
# make sure we get a *full* backtrace</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而, 如果持续集成测试出现执行错误, 那么你通常不会得到完整的回溯, 这往往无助于追踪问题。尤其是当你无法在本地重现问题的时候。</p>
</div>
</div>
<div class="sect2">
<h3 id="_让事情变得更快更好更经济">79.10. 让事情变得更快、更好、更经济</h3>
<div class="paragraph">
<p>那么, 为什么不把这个手动工作流程嵌入一个漂亮的脚本, 并将其添加到发行版中呢？并确保只有那个脚本才会被运行？这似乎是一个很容易实现的想法。而事实也的确如此。这个脚本(称为 <a href="https://github.com/lizmat/Hash-LRU/blob/master/run-tests">run-test</a>)基本上变成了(为了这篇博文而略微缩短了)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    my @failed;
    my $done = 0;

    for &#34;t&#34;.IO.dir(:test(*.ends-with: &#39;.t&#39; | &#39;.rakutest&#39;)).map(*.Str).sort {
        say &#34;=== $_&#34;;
        my $proc = run &#34;raku&#34;, &#34;--ll-exception&#34;, &#34;-Ilib&#34;, $_, :out, :merge;
        if $proc {
            $proc.out.slurp;
        }
        else {
            @failed.push($_);
            if $proc.out.slurp -&gt; $output {
                say $output;
            }
            else {
                say &#34;No output received, exit-code $proc.exitcode()&#34;;
            }
        }
        $done++;
    }

    if @failed {
        say &#34;FAILED: {+@failed} of $done:&#34;;
        say &#34;  $_&#34; for @failed;
        exit +@failed;
    }

    say &#34;\nALL {&#34;$done &#34; if $done &gt; 1}OK&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>而 YAML 文件的最后6行被改成。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">- name: Run Tests
  run: raku run-tests</code></pre>
</div>
</div>
<div class="paragraph">
<p>测试 <a href="https://github.com/lizmat/Hash-LRU">Hash::LRU</a> 模块的总时间通常<a href="https://github.com/lizmat/Hash-LRU/actions/runs/375191322">降到一分钟以下</a>。这节省了大量的时间和 CPU 周期! 当然, 如果有需要安装的依赖关系, 节省的时间会更少。但更短的周转时间, 以及在出错时看到完整的回溯, 对你们的帮助是绝对的。而且作为奖励, 现在在本地的测试也变得更加简单和干净, 尤其是在一切顺利的情况下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">Welcome to Rakudo(tm) v2020.11.
Implementing the Raku(tm) programming language v6.d.
Built on MoarVM version 2020.11.

Testing Hash-LRU
=== t/01-basic.t

ALL OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么你是否应该把这个测试文件复制到你的发行版中, 并相应地调整 Github Actions YAML 呢？也许是这样的。但也许最好是找出最适合你作为模块开发者的方法。并在这个想法的基础上进行改进。也许从复制运行 run-tests 开始, 然后根据自己的喜好进行调整。无论什么对您来说都是最好的!</p>
</div>
</div>
<div class="sect2">
<h3 id="_raku_新手">79.11. Raku 新手？</h3>
<div class="paragraph">
<p>如果您是 Raku 的新手, 您可能会喜欢一些关于 <code>run-tests</code> 脚本实际作用的解释。所以, 这里就开始了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @failed;
my $done = 0;</code></pre>
</div>
</div>
<div class="paragraph">
<p>设置一个 <code>@failed</code> 数组, 用于保存因某种原因而失败的测试文件的名称, 以及一个 <code>$done</code> 计数器, 用于记录已完成的测试文件的数量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &#34;t&#34;.IO.dir(:test(*.ends-with: &#39;.t&#39; | &#39;.rakutest&#39;)).map(*.Str).sort {</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你是 Raku 的新手, 这可能是最难理解的。它所做的, 基本上是寻找 &#34;t&#34; 目录下的 &#34;t&#34;.IO, 然后开始寻找扩展名为 &#34;.t&#34; 或 &#34;.rakutest&#34; 的文件 .dir(:test(*.ends-with: &#39;.t&#39; | &#39;.rakutest&#39;)), 将产生的 <code>IO::Path</code> 对象改为 <code>string.map(*.Str)</code>, 然后对这些文件进行排序, 并在它们之间循环 <code>for …​ {</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;=== $_&#34;;
my $proc = run &#34;raku&#34;, &#34;--ll-exception&#34;, &#34;-Ilib&#34;, $_, :out, :merge;</code></pre>
</div>
</div>
<div class="paragraph">
<p>显示正在测试哪个测试文件 <code>say &#34;===$_&#34;;</code> 并运行实际的实际测试文件运行 &#34;raku&#34;, &#34;--ll-exception&#34;, &#34;-Ilib&#34;, $_, 并确保它的 STDOUT 和 STDERR 输出成为一个单一的流 <code>:out</code>, <code>:merge</code>; 并把产生的 Proc 对象放到 <code>my $proc</code> 中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $proc {
    $proc.out.slurp;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果测试文件的运行成功, <code>if $proc</code>, 那么只需要吃掉所有的输出, 不要对它做任何事情 <code>$proc.out.slurp</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">        else {
            @failed.push($_);
            if $proc.out.slurp -&gt; $output {
                say $output;
            }
            else {
                say &#34;No output received, exit-code $proc.exitcode()&#34;;
            }
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果不成功否则, 那么将失败的测试文件的名字添加到失败的测试列表中 @failed.push($_)。如果有任何输出, if $proc.out.slurp, 将其存储在一个变量  -&gt; $output 中, 并将其显示给世界 say $output。如果没有其他输出, 用 exitcode 让世界知道没有输出, +++say &#34;No output received, exit-code $proc.exitcode()&#34;。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    $done++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>记住我们已经做了一个测试文件, 不管成功与否 <code>$done++</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if @failed {
    say &#34;FAILED: {+@failed} of $done:&#34;;
    say &#34;  $_&#34; for @failed;
    exit +@failed;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果有任何测试文件失败, <code>if @failed</code>, 告诉世界有多少失败的 say &#34;FAILED: {+@failed} of $done:&#34;, 并显示失败的测试文件的名称 <code>say &#34; $_&#34; for @failed</code>, 然后退出脚本表示错误状态 <code>exit +@failed</code> 与 <a href="https://en.wikipedia.org/wiki/Test_Anything_Protocol">TAP 协议</a>一致。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &#34;\nALL {&#34;$done &#34; if $done &gt; 1}OK&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们做到了这里, 已经全部 OK 了, 所以用文件的数量来显示, 但只有当它是一个以上的 <code>&#34;$done &#34; if $done &gt; 1</code>。</p>
</div>
<div class="paragraph">
<p>关于这个程序中使用的 Raku 功能的一些更多信息：<a href="https://docs.raku.org/routine/IO#(Cool)_method_IO">.IO</a>、<a href="https://docs.raku.org/type/IO::Path#routine_dir">.dir</a>、<a href="https://docs.raku.org/type/Any#routine_map">.map</a>、<a href="https://docs.raku.org/type/Whatever">*.Str</a>、<a href="https://docs.raku.org/type/Any#method_sort">.sort</a>、<a href="https://docs.raku.org/language/independent-routines#sub_run">run</a>、<a href="https://docs.raku.org/type/Proc">Proc</a>、<a href="https://docs.raku.org/language/independent-routines#sub_exit">exit</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结束语_6">79.12. 结束语</h3>
<div class="paragraph">
<p>只要你稍加努力, 就能让自己和 Github Action 的精灵们更轻松。而且也要多考虑环境, 因为太多精灵太辛苦了, 对环境不好!
== <a href="https://raku-advent.blog/2020/12/14/day-15-writing-faster-raku-code-part-i/">第十四天 - 编写更快的 Raku 代码, 第一部分</a></p>
</div>
<div class="paragraph">
<p>去年, 在 <a href="https://www.perl.org/">Perl</a> 的土地上, <a href="https://wimvanderbauwhede.github.io/articles/writing-faster-perl/">我讨论了</a>我试图优化表达式解析器性能的结果, 它是我的基于 Perl 的 <a href="https://github.com/wimvanderbauwhede/RefactorF4Acc">Fortran 源到源编译器</a>的一部分。表达式解析器将代表编程语言（在我的例子中是 Fortran）中表达式的字符串转化为称为解析树的数据结构, 编译器使用它来进一步分析和生成代码。</p>
</div>
<div class="paragraph">
<p>最近我写了不少 <a href="https://raku.org/">Raku</a> 代码, 但到目前为止我还没有研究过它的性能。出于好奇, 我决定在 Raku 中重写并优化这个 Fortran 表达式解析器。</p>
</div>
</div>
<div class="sect2">
<h3 id="_表达式解析">79.13. 表达式解析</h3>
<div class="paragraph">
<p>我通俗地称之为表达式解析器, 其实就是一个<a href="https://en.wikipedia.org/wiki/Lexical_analysis">词法器</a>和<a href="https://en.wikipedia.org/wiki/Parsing#Parser">解析器</a>的结合体：它把一串源码变成一个树状的数据结构, 这个结构表达了表达式的结构和其组成成分的目的。例如如果表达式是 <code>2*v+1</code>, 那么表达式解析器的结果将是一个数据结构, 它将顶层表达式识别为与整数常数 1 的乘法和整数常数 2 与变量 v 的乘法。</p>
</div>
<div class="paragraph">
<p>那么我们如何在 Raku 中构建一个快速的表达式解析器呢？在文章的第一部分, 我将探讨一些需要考虑的选择和权衡。在后续的文章中, 我将讨论表达式解析器的实际实现。</p>
</div>
</div>
<div class="sect2">
<h3 id="_raku_性能测试">79.14. Raku 性能测试</h3>
<div class="paragraph">
<p>Raku 文档中有一个<a href="https://docs.raku.org/language/performance">关于性能的页面</a>, 提供了很好的一般性建议。但是对于我的需求来说, 我没有找到关于我可能必须做出的具体权衡的答案。所以我创建了一些简单的测试案例来了解更多。我使用了建立在 MoarVM 2020.09 版本上的 Raku 版本, 也就是我运行测试时的最新版本, 但对于稍早和稍晚的版本, 结果应该是相当相似的, 至少在新的 <a href="https://news.perlfoundation.org/post/gp_rakuast">RakuAST</a> 模型完成之前是这样, 因为这可能会对性能产生很大的影响。</p>
</div>
<div class="paragraph">
<p>我使用一系列不同情况的小测试台测试性能, 由命令行参数控制, 使用时间命令获得墙钟时间, 并取 5 次运行的平均值。比如说</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$time raku test_hash_vs_regex.raku 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>办法不止一种, 但只有一种才是最快的办法</p>
</div>
<div class="paragraph">
<p>解析涉及到将字符串转化为其他数据结构, 所以要对数据结构以及将字符串转化为数据结构并对其进行操作的方法做出很多决定。下面是一些影响编译器设计决策的性能比较结果。我很想知道它们在 Raku 中是否会有不同的结果。</p>
</div>
<div class="sect3">
<h4 id="_哈希键测试比_regexp_匹配更快">79.14.1. 哈希键测试比 regexp 匹配更快</h4>
<div class="paragraph">
<p>Fortran 代码基本上是由一个语句列表组成的, 其中可以包含表达式, 在我的编译器中, 语句解析器用一个 hashmap 给每个语句都贴上一次标签。每一行解析后的代码都会以原始字符串 <code>$src_line</code> 与这个哈希图的对子形式存储, 称为 <code>$info</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $parsed_line = [ $src_line, $info ];</code></pre>
</div>
</div>
<div class="paragraph">
<p>存储在 <code>$info</code> 中的标签和值取决于语句的类型。先验地不清楚使用 regex 匹配 <code>$src_line</code> 中的模式是比查找 <code>$info</code> 中的相应标签快还是慢。所以我测试了哈希键测试与 regexp 匹配的性能, 使用了一些真正的 FORTRAN 77 代码, 一个 READ I/O 调用, 在 <code>$info</code> 中标记为 ReadCall。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = lc(&#39;READ( 1, 2, ERR=8, END=9, IOSTAT=N ) X&#39;);
my $info = {};
if ($str~~/read/) {
    $info&lt;ReadCall&gt; = 1;
}
my $count=0;

constant NITERS = 10_000_000;
if CASE==1 {
    for 1..NITERS -&gt; $i {
# regexp
        if ($str~~/read/) {
            $count+=$i;
        }
    }
} elsif CASE==2 {
    for 1..NITERS -&gt; $i {
# hash lookup
            if ($info&lt;ReadCall&gt;:exists) {
                $count+=$i;
            }
    }
} elsif CASE==3 {
    for 1..NITERS -&gt; $i {
# overhead
                $count+=$i;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有 if 条件(CASE==3), for 1..NITERS 循环在我的笔记本上需要 3 秒。所以实际的条件运算中, 哈希键存在性检查需要 2 秒, regexp 匹配需要 50 秒。</p>
</div>
<div class="paragraph">
<p>结果是：测试哈希键比简单的 regexp 匹配快 25 倍。所以我们用一些内存来换取计算：我们用一个 regexp 识别一次语句, 并将识别标签存储在 <code>$info</code> 中以备后续传递。</p>
</div>
</div>
<div class="sect3">
<h4 id="_解析树的快速数据结构整数与字符串的比较">79.14.2. 解析树的快速数据结构：整数与字符串的比较</h4>
<div class="paragraph">
<p>解析表达式的数据结构的选择很重要。由于我们需要一个树状的有序数据结构, 所以必须是一个对象或者一个列表状的数据结构。但是对象在很慢, 所以我使用了嵌套数组。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[&#39;+&#39;,
    [&#39;*&#39;,
        2,
        [&#39;$&#39;,&#39;v&#39;]
    ],
    1
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你不需要在上面做很多工作的话, 这种数据结构是可以的。然而, 由于每个节点都用字符串标记, 所以针对节点类型的测试是一个字符串比较。仅仅针对一个常量字符串或整数进行测试是不够好的, 因为编译器可能会把这个优化掉。所以我进行了如下测试, 以确保 <code>$str</code> 和 <code>$c</code> 在每次迭代时都能得到一个新的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if CASE==1 { # 7.3 - 5.3 = 2 s net
    for 1 .. NITERS -&gt; $i {
# string equality
        my $str = chr($i % 43);
        if $str eq &#39;*&#39; {
            $count+=$i;
        }
    }
}
elsif CASE==2 { # 3.3 - 3.1 = 0.3
    for 1..NITERS -&gt; $i {
# int equality
        my $c = $i % 43;
        if $c == 42 {
            $count+=$i;
        }
    }
} elsif CASE==3 { # 5.3
    for 1..NITERS -&gt; $i {
# string equality overhead
        my $str = chr($i % 43);
    }
} elsif CASE==4 { # 3.1
    for 1..NITERS -&gt; $i {
# int equality overhead
        my $c = $i % 43;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我根据循环迭代器填充字符串或整数, 然后与一个常量字符串或整数进行比较。通过减去赋值所花费的时间（情况 3 和 4）, 我得到了比较的实际时间。</p>
</div>
<div class="paragraph">
<p>在我的笔记本上, 有字符串比较的版本净耗时 2s, 整数比较耗时 0.3s, 所以做字符串比较比做整数比较至少要慢 5 倍。因此我的数据结构使用的是整数标签。另外, 我给常量贴上标签, 这样我可以给字符串、整数和实数常量贴上不同的标签, 也是因为这样一来, 所有的节点都是数组。这样就避免了要测试一个节点是数组还是标量, 这是个很慢的操作。</p>
</div>
<div class="paragraph">
<p>所以, 这个例子就变成了 .NET。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[ 3,
  [ 5,
    [ 29, &#39;2&#39; ],
    [ 2, &#39;v&#39; ]
  ],
  [ 29, &#39;1&#39; ]
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>可读性较差, 但速度较快, 易于扩展。在下面的内容中, 我所说的解析树就是这个数据结构。</p>
</div>
<div class="paragraph">
<p>结果是：字符串比较比做整数比较至少慢 5 倍。</p>
</div>
</div>
<div class="sect3">
<h4 id="_自定义树遍历更快">79.14.3. 自定义树遍历更快</h4>
<div class="paragraph">
<p>我测试了使用高阶函数进行解析树遍历（递归下降）的成本。基本上, 这是使用高阶函数的通用遍历之间的选择, 高阶函数采取对解析树节点进行操作的任意函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub _traverse_ast_with_action($ast_, $acc_, &amp;f) {
    my $ast=$ast_; my $acc=$acc_;
    if &lt;cond&gt; {
        $acc=&amp;f($ast,$acc);
    } else {
        $acc=&amp;f($ast,$acc);
        for  1 .. $ast.elems - 1  -&gt; $idx {
            (my $entry, $acc) =
                _traverse_ast_with_action($ast[$idx],$acc, &amp;f);
            $ast[$idx] = $entry;
        }
    }
    return ($ast, $acc);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或自定义遍历。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub _traverse_ast_custom($ast_, $acc_) {
    my $ast=$ast_; my $acc=$acc_;
    if &lt;cond&gt; {
        $acc=&lt; custom code acting on $ast and $acc&gt;;
    } else {
    $acc=&lt; custom code acting on $ast and $acc&gt;;
        for 1 .. $ast.elems - 1  -&gt; $idx {
            (my $entry, $acc) =
                _traverse_ast_custom($ast[$idx],$acc);
            $ast[$idx] = $entry;
        }
    }
    return ($ast, $acc);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于我的编译器中解析树数据结构的情况, 高阶实现的时间是自定义遍历的两倍多, 所以为了性能, 这不是一个好的选择。因此我在解析器中不使用高阶函数, 但在后面的重构通证中会使用。</p>
</div>
<div class="paragraph">
<p>结果是：高阶递归的实现所花费的时间是自定义遍历的两倍以上。</p>
</div>
</div>
<div class="sect3">
<h4 id="_处理列表的最快方法">79.14.4. 处理列表的最快方法</h4>
<div class="paragraph">
<p>在我的编译器中, Fortran 程序的内部表示是一个 <code>[ $src_line, $info ]</code> 对的列表, 而 <code>$info</code> 哈希则以嵌套数组的形式存储解析树。所以在列表和数组中迭代是影响性能的一个主要因素。</p>
</div>
<div class="paragraph">
<p>Raku 有几种方法来迭代一个类似列表的数据结构。我测试了其中的六种方法, 如下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant NITERS = 2_000_000;
if CASE==0 { # 6.2 s
# map
    my @src = map {$_}, 1 .. NITERS;
    my @res = map {2*$_+1}, @src;
} elsif CASE==1 { # 7.9 s
# for each elt in list
    my @res=();
    my @src=();
    for 1..NITERS -&gt; $elt {
        push @src, $elt;
    }
    for @src -&gt; $elt {
        push @res, 2*$elt+1;
    }
} elsif CASE==2 { # 6.2 s
# for with index
    my @res=();
    my @src=();
    for 0..NITERS-1 -&gt; $idx {
        my $elt=$idx+1;
        @src[$idx] = $elt;
    }
    for 0..NITERS-1 -&gt; $idx {
        my $elt=@src[$idx];
        @res[$idx] = 2*$elt+1;
    }
} elsif CASE==3 { # 11.0
# loop (C-style)
    my @res=();
    my @src=();
    loop (my $idx=0;$idx &lt; NITERS;++$idx) {
        my $elt=$idx+1;
        @src[$idx] = $elt;
    }
    loop (my $idx2=0;$idx2 &lt; NITERS;++$idx2) {
        my $elt=@src[$idx2];
        @res[$idx2] = 2*$elt+1;
    }
} elsif CASE==4 { # 3.7 s
# postfix for with push
    my @src = ();
    my @res=();
    push @src, $_ for 1 .. NITERS;
    push @res, 2*$_+1 for @src;
} elsif CASE==5 { # 3.5 s
# comprehension
    my @src = ($_ for 1 .. NITERS);
    my @res= (2*$_+1 for @src);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最快的方法是使用列表理解（情况 5, 3.5 秒）, 紧随其后的是后缀式 for（情况 4, 3.7 秒）。C 式循环构造（情况 3）是最慢的（11 秒）。映射版本与基于索引的 for 循环的表现相同（都是 6.2 s）。有点奇怪的是, 基于列表的 for 循环, 可能是最常见的循环构造, 却比这两种构造慢（7.9 秒）。</p>
</div>
<div class="paragraph">
<p>结果是：列表理解最快, 几乎是 for 循环或地图的两倍。C 式循环非常慢。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_到目前为止的结论">79.15. 到目前为止的结论</h3>
<div class="paragraph">
<p>通过这组比较多样的实验, 我们了解到以下几点。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>测试哈希键的速度是 regexp 匹配的 25 倍 所以匹配一次并存储到哈希中去.</p>
</li>
<li>
<p>字符串比较比做整数比较至少慢 5 倍, 所以如果你在乎速度, 请优先选择整数比较。</p>
</li>
<li>
<p>高阶实现递归下降的时间是自定义遍历的两倍以上。所以复制粘贴比抽象出来的快。</p>
</li>
<li>
<p>列表理解最快, 几乎是 for-loop 或 map 的两倍。C 式循环非常慢。所以要想最快的列表迭代, 就用理解式。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>除了最后一条, 这些结论和 Perl 的结论是一样的。在后续的文章中, 我们会看解析字符串的性能和表达式解析器的最终设计。</p>
</div>
<div class="paragraph">
<p>所有测试的代码都可以在我的 <a href="https://github.com/wimvanderbauwhede/raku-examples/tree/master/Performance-analysis">GitHub repo</a> 中找到。
== <a href="https://raku-advent.blog/2020/12/15/day-14-rudolph-on-raku/">第十五天 - 用 Physics::Navigation 找到回家的路</a></p>
</div>
<div class="paragraph">
<p>所以, 鲁道夫一直在担心, 在经过疲惫不堪的飞行后, 如何把圣诞老人和其他驯鹿送回北极, 去看望地球上所有（乖巧的）孩子。</p>
</div>
<div class="paragraph">
<p>他听过一个传言, 说由于地心熔铁的预演, 北极点一直在移动, 每年它都会绕着位于真正北极点的圣诞老人的工作间蠕动一下。</p>
</div>
<div class="paragraph">
<p>幸好他参加过导航技能课程, 了解了如何利用经纬度组合来指定地球仪上的位置。然而, 这些似乎都是糊弄人的, 因为它们很像, 却又不同。鲁迪需要的是一种组织导航的方法, 以确保他不会把它们混为一谈。更好的是, 他与拉里是好朋友, 他知道他可以信任 Raku 的<a href="https://docs.raku.org/language/typesystem">类型系统</a>, 让他回家。事实上, Raku 有很多方法可以让驯鹿|开发者的生活变得更好, 在 <a href="https://www.raku.org">https://www.raku.org</a>, 了解更多。</p>
</div>
<div class="paragraph">
<p>让我们看看他是怎么做的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">use Physics::Unit;
use Physics::Measure;

class NavAngle is Angle {
  has Unit $.units is rw where *.name eq &#39;°&#39;;

  multi method new( Str:D $s ) {
    my ($decimal, $compass) = NavAngle.defn-extract( $s );
    my $type;
    given $compass {
      when &lt;N S&gt;.any   { $type = &#39;Latitude&#39; }
      when &lt;E W&gt;.any   { $type = &#39;Longitude&#39; }
      when &lt;M T H&gt;.any { $type = &#39;Bearing&#39; }
      default          { nextsame }
    }
    ::($type).new( value =&gt; $nominal, compass =&gt; $compass );
  }

  method defn-extract( NavAngle:U: Str:D $s ) {
    # handle degrees-minutes-seconds &lt;°&gt; is U+00B0 &lt;′&gt; is U+2032 &lt;″&gt; is U+2033
    unless $s ~~ /(\d*)\°(\d*)\′?(\d*)\″?\w*(&lt;[NSEWMTH]&gt;)/ { return 0 };
    my $deg where 0 &lt;= * &lt; 360 = $0 % 360;
    my $min where 0 &lt;= * &lt;  60 = $1 // 0;
    my $sec where 0 &lt;= * &lt;  60 = $2 // 0;
    my $decimal = ( ($deg * 3600) + ($min * 60) + $sec ) / 3600;
    my $compass = ~$3;

    say &#34;NA extracting «$s»: value is $deg°$min′$sec″, compass is $compass&#34; if $db;
    return($decimal, $compass)
  }

  method Str {
    my ( $deg, $min ) = self.dms( :no-secs );
    $deg = sprintf( &#34;%03d&#34;, $deg );
    qq{$deg° $.compass}
  }
}
# real code at https://github.com/p6steve/raku-Physics-Navigation (work in progress)</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以 Rudi 创建了一个 NavAngle 类, 通过编写 &#39;NavAngle is Angle&#39; 来继承 <a href="https://github.com/p6steve/raku-Physics-Unit">Physics::Unit</a> 提供的 Angle 类, 并创建了一些通用方法, &#39;知道&#39; &lt;N S&gt; 是纬度, &lt;E W&gt; 是经度。还有 &lt;M T H&gt; 的概念, 代表 Bearing（稍后再谈）。在这里你还可以看到, Raku 有一个非常灵活的<a href="https://docs.raku.org/language/control#index-entry-switch_(given)">开关</a>, 使用 &#39;given-when-default&#39; 关键字来指定控制流。</p>
</div>
<div class="paragraph">
<p>这个新类&#34;有&#34;一个属性定义 - <code>$.units</code>。Raku 的 $.<a href="https://docs.raku.org/language/classtut#index-entry-twigils_accessors">twigil</a> 表示这是一个公共属性, 并自动提供访问器 get 和 set 方法, 不需要额外的代码。所以当你要设置值时, &#39;where&#39; <a href="https://docs.raku.org/type/Signature#index-entry-Constraint">约束</a>会检查 <code>$.units.name</code> 是否等于 &#39;°&#39;。这样我们就可以强制执行我们的 NavAngle 对象是以度 &#39;°&#39; 来指定的, 并防止使用其他可用的角度单位, 如弧度或克。</p>
</div>
<div class="paragraph">
<p>他在格陵兰语法学校学习过, 知道 Raku <a href="https://docs.raku.org/language/regexes">regex</a> 功能和 <a href="https://docs.raku.org/language/unicode">unicode</a> 支持可以使度、分、秒的工作变得很短。值的限制会阻止他在 451 度时飞走。</p>
</div>
<div class="paragraph">
<p>这里展示了其他几个不错的 Raku 功能：(i) &#39;::($type)&#39; <a href="https://docs.raku.org/language/packages#index-entry-::($c).m">名称插值</a>允许将类型作为变量处理, 并以编程的方式进行操作；(ii) <a href="https://docs.raku.org/type/Capture">参数捕获</a>&#39;( Str:D $s )&#39; 检查函数参数的类型和<a href="https://docs.raku.org/routine/$SOLIDUS$SOLIDUS">定义性</a>；(iii) &#39;= $1 // 0&#39; 组合测试定义性, 从而分配一个默认值。Rudolph 很高兴地看到所有这些工具都能很好地融合在一个可理解的语言语法中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_纬度和经度">79.16. 纬度和经度</h3>
<div class="paragraph">
<p>现在基础知识已经到位, Rudolph 可以轻松地使用<a href="https://docs.raku.org/language/classtut#index-entry-classes__inheritance">继承</a>来定义 Latitude 和 Longitude 子类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">class Latitude is NavAngle {
    has Real  $.value is rw where 0 &lt;= * &lt;= 90;
    has Str   $.compass is rw where &lt;N S&gt;.any;
}
class Longitude is NavAngle {
    has Real  $.value is rw where 0 &lt;= * &lt;= 180;
    has Str   $.compass is rw where &lt;E W&gt;.any;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>约束条件已经调整 - 现在子类有自己的 <code>$.value</code> 和 <code>$.compass</code> 属性 - 以反映每个子类的不同值限制。方括号相当于 (&#39;N&#39;, &#39;S&#39;) - 它们的键入速度更快, 因为你不需要在每个单词周围使用<a href="https://docs.raku.org/routine/%3C%20%3E">引号</a>。</p>
</div>
<div class="paragraph">
<p>Rudolph 可以通过使用标准的 Raku 构造函数创建一个新的 Latitude 类实例来设置他的纬度位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">my $lat = Latitude.new( value =&gt; 45, compass =&gt; &lt;N&gt; );
say ~$lat; #OUTPUT 43° N`</code></pre>
</div>
</div>
<div class="paragraph">
<p>但这是相当长篇大论, 他不耐烦回家了。好消息是, 他可以创建一个 Raku <a href="https://docs.raku.org/language/optut">自定义运算符</a>, 让他轻松地从引号字符串中指定和初始化新实例。在这种情况下, 他决定使用 unicode 双鱼座’表情&#39; - ♓️ …​。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">multi infix:&lt;♓️&gt; ( Any:U $left is rw, Str:D $right ) {
    $left = NavAngle.new( $right );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 他可以迅速地马不停蹄地输入自己的坐标。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">my $lat ♓️ &lt;55°30′30″S&gt;; say ~$lat;   # OUTPUT 55°30.5 S
my $long &lt;♓️&gt; &lt;45°W&gt;;    say ~$long;  # OUTPUT 45° W</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_magnetic_vs_true_north">79.17. Magnetic vs. True North</h3>
<div class="paragraph">
<p>现在他知道自己在哪里了, 鲁道夫可以设定一个航向, 驶向北极的家。但是, 等等, 他如何调整他的指南针上的磁北和真北, 他的目的地之间的差异？</p>
</div>
<div class="paragraph">
<p>鲁道夫有另一个技巧在他（鹿角）的袖子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">class CompassAdjustment { ... }         # predeclare since we want to refer to this class before we write it

# keyword &#39;our&#39; used to declare package-wide variables
our $variation = 0;         # optional variation (Compass-Adjustment)
our $deviation = 0;         # optional deviation (Compass-Adjustment)

#| Bearing embodies the identity &#39;M = T + Vw&#39;, so...
#| Magnetic = True + Variation-West [+ Deviation-West]
class Bearing is NavAngle {
    has Real  $.value is rw where 0 &lt;= * &lt;= 360;  # must be between 0 and 360 degrees
    has Str   $.compass where &lt;M T&gt;.any;          # either Magnetic or True

    method M {          # output method always returns the Magnetic Bearing
        if $.compass eq &lt;M&gt; { return( self ) }
        else { return( self + ( $variation + $deviation ) ) }
    }
    method T {          # output method always returns the True Bearing
        if $.compass eq &lt;T&gt; { return( self ) }
        else { return( self - ( $variation + $deviation ) ) }
    }

   sub check-same( $l, $r ) {       # can only add/subtract where both are Magnetic or both are True
    if $r ~~ CompassAdjustment {
        return
    }
        if ! $l.compass eq $r.compass {
            die &#34;Cannot combine Bearings of different Types!&#34;
        }
    }

    # these math methods override the ones provided by Physics::Measure::Angle
    # they handle the custom +/- infix operators defined in Physics::Measure
    # they extend the (grand)parent methods with logic to handle the $.compass attributes
    method add( $r is rw ) {
        my $l = self;
        check-same( $l, $r );
        $l.value += $r.value;
        $l.compass( $r.compass );
        return $l
    }
    method subtract( $r is rw ) {
        my $l = self;
        check-same( $l, $r );
        $l.value -= $r.value;
        $l.compass( $r.compass );
        return $l
    }
}

# now we can finally write our CompassAdjustment class
# we had to wait until now since is also is a child of Bearing

class CompassAdjustment is Bearing {
    has Real  $.value is rw where -180 &lt;= * &lt;= 180; # the adjustment is up to 180 degrees either way

    # we override the parent compass accessors since we want to provide extra logic for &lt;W E&gt;
    # we want add/subtract to add W variations and subtract E variations
    # we do this by storing the value as a signed Real and negating the return value when its &lt;E&gt;

    multi method compass {                 # get compass
        given $.value {
            when * &gt;= 0 { return &lt;W&gt;, 0 }
            when * &lt; 0  { return &lt;E&gt;, 1 }
        }
    }
    multi method compass( Str $compass ) { # set compass
        given $compass {
            when &lt;W&gt;   { }        #no-op
            when &lt;E&gt;   { $.value = -$.value }
            default    { die &#34;Compass-Adjustment must be &lt;W E&gt;.any&#34; }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 设置好罗盘变化后, 鲁道夫就可以输入他们的磁力罗盘读数, 并取回 Bearing to True North。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">$Physics::Navigation::variation = CompassAdjustment.new( value =&gt; 7, compass =&gt; &lt;W&gt; );
my $bear &lt;♓️&gt; &lt;43°30′30″M&gt;;
say ~$bear;   # OUTPUT 43°30.5 M
say ~$bear.T; # OUTPUT 43°37.5 T</code></pre>
</div>
</div>
<div class="paragraph">
<p>圣诞老人甚至可以通过做加法或减法改变航向的方位来转向右舷或左舷。根据对象类型的不同, <code>+/-</code> 的非标准行为可能会令人惊讶 - 这是 ♓️ unicode 运算符的一个好处…​它们作为一个警告, 警告语言突变潜伏在这些代码区域。</p>
</div>
<div class="paragraph">
<p>如果圣诞老人带了满满一雪橇不需要的铁质圣诞礼物（自行车、攀岩架、Meccano 套装等等）回家, 那么可以用 <code>$Physics::Navigation::deviation</code> 设置来解决这个问题。</p>
</div>
<div class="paragraph">
<p>最后, 圣诞老人、鲁道夫和其他驯鹿们可以在工作了一整夜之后, 在家里的火堆旁休息一下他们疲惫的骨头。</p>
</div>
<div class="paragraph">
<p>祝所有人（以及任何）p6steve 圣诞快乐。(p6 的发音是&#34;物理学&#34;)
== <a href="https://raku-advent.blog/2020/12/16/day-16-writing-faster-raku-code-part-ii/">第十六天 - 编写更快的 Raku 代码, 第二部分</a></p>
</div>
<div class="paragraph">
<p>这是关于在 Raku 中编写表达式解析器的后续文章。在<a href="https://gist.github.com/wimvanderbauwhede/58fb069de423cd766e9bdd0bbe1c6dec">上一篇文章</a>中, 我解释了背景, 看了一些与解析的数据结构和处理它们的方式有关的基本性能比较：列表、解析树、递归下降和迭代。</p>
</div>
<div class="paragraph">
<p>在这篇文章中, 我们将看看各种处理字符串的方式的性能, 然后看看它是如何在表达式解析器中结合起来的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_字符串处理正则表达式字符串比较还是列表操作">79.18. 字符串处理：正则表达式、字符串比较还是列表操作？</h3>
<div class="paragraph">
<p>我们应该如何解析乐乐中的表达式字符串？传统的构建表达式解析器的方法是使用有限状态机, 每次消耗一个字符（如果需要的话, 可以用一个或多个字符 look-ahead）, 并跟踪字符串的识别部分。这在 C 等语言中是非常快的, 但在 Raku 中, 我不太确定, 因为在 Raku 中, 一个字符实际上是一个长度为 1 的字符串, 所以每一次针对字符的测试都是一次字符串比较。另一方面, Raku 有一个成熟的正则表达式引擎。然而另一种方法是把字符串变成一个数组, 然后用列表操作进行解析。很多可能性有待测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant NITERS = 100_000;
my $str=&#39;This means we need a stack per type of operation and run until the end of the expression&#39;;
my @chrs =  $str.comb;
if (CASE==0) { # 5.8 s
    for 1 .. NITERS -&gt; $ct {
# map on an array of characters
        my @words=();
        my $word=&#39;&#39;;
        map(-&gt; \c {
            if (c ne &#39; &#39;) {
                $word ~= c;
            } else {
                push @words, $word;
                $word=&#39;&#39;;
            }
        }, @chrs);
        push @words, $word;
    }
} elsif CASE==1 { # 2.7 s
     for 1 .. NITERS -&gt; $ct {
# while with index through a string
        my @words=();
        my $str=&#39;This means we need a stack per type of operation and run until the end of the expression&#39;;
        while my $idx=$str.index( &#39; &#39; ) {
            push @words, $str.substr(0,$idx);
            $str .= substr($idx+1);
        }
        push @words, $str;
    }
} elsif CASE==2 {  # 11.7 s
    for 1 .. NITERS -&gt; $ct {
# while on an array of characters
        my @words=();
        my @chrs_ = @chrs;
        my $word=&#39;&#39;;
        while @chrs_ {
            my $chr = shift @chrs_;
            if ($chr ne &#39; &#39;) {
                $word~=$chr;
            } else {
                push @words, $word;
                $word=&#39;&#39;;
            }
        }
        push @words, $word;
    }
} elsif CASE==3 { # 101 s
    for 1 .. NITERS -&gt; $ct {
# while on a string using a regexp
        my @words=();
        my $str=&#39;This means we need a stack per type of operation and run until the end of the expression&#39;;
        while $str.Bool {
            $str ~~ s/^$&lt;w&gt; = [ \w+ ]//;
            if ($&lt;w&gt;.Bool) {
                push @words, $&lt;w&gt;.Str;
            }
            else {
                $str ~~ s/^\s+//;
            }
        }
    }
} elsif CASE==4 { # 64 s
    for 1 .. NITERS -&gt; $ct {
# reduce on an array of characters
        my \res = reduce(
        -&gt; \acc, \c {
            if (c ne &#39; &#39;) {
                acc[0],acc[1] ~ c;
            } else {
                ( |acc[0], acc[1] ),&#39;&#39;;
            }
        }, ((),&#39;&#39;), |@chrs);
        my @words = |res[0],res[1];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于基于列表的版本, 开销是 1.6s；对于基于字符串的版本, 开销是 0.8s。</p>
</div>
<div class="paragraph">
<p>结果是相当惊人的。显然, 到目前为止, regexp 版本是最慢的。这是一个惊喜, 因为在我的 Perl 实现中, regexp 版本的速度是次佳选择的两倍。从其他的实现来看, 基于字符串的 FSM 使用 index 和 substr 方法是目前最快的, 在没有开销的情况下, 它需要 1.9s s, 比 regexp 版本快了 50 多倍。基于地图的版本排在第二位, 但速度几乎是其两倍。令人惊讶的是, 实际上有点失望的是基于 reduce 的版本, 它的工作原理和基于 map 的版本一样, 但工作在不可变的数据上, 也非常慢, 64 s。</p>
</div>
<div class="paragraph">
<p>在任何情况下, 选择是很明确的。通过不减少字符串, 而是在字符串中移动索引, 可以使最快的版本稍微快一些（1.6 s 而不是 1.9 s）。然而, 对于完整的解析器, 我希望拥有 trim-leading 和 start-with 方法的便利性, 所以我选择消耗字符串。</p>
</div>
</div>
<div class="sect2">
<h3 id="_一个更快的表达式解析器">79.19. 一个更快的表达式解析器</h3>
<div class="paragraph">
<p>字符串解析和数据结构（带整数标识符的嵌套数组, 见<a href="https://gist.github.com/wimvanderbauwhede/58fb069de423cd766e9bdd0bbe1c6dec">第一篇文章</a>）的选择做好了, 我们来关注一下整个算法的结构。理论上的细节就不多说了, 我们使用的是<a href="https://en.wikipedia.org/wiki/LR_parser">有限状态机</a>, 所以基本的方法是循环通过一些状态, 并在每个状态下执行一个特定的动作。在 Perl 版本中, 这很简单, 因为我们使用正则表达式来识别标记, 所以大部分的状态转换都是隐式的。我想保持这种结构, 所以我用比较、索引和子串操作来模拟 regexp s/// 操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $prev_lev=0;
my $lev=0;
my @ast=();
my $op;
my $state=0;
while (length($str)&gt;0) {
     # Match unary prefix operations
     # Match terms
     # Add prefix operations if matched
     # Match binary operators
     # Append to the AST
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>匹配规则和操作非常简单（我使用 <code>&lt;pattern&gt;</code> 和 <code>&lt;integer&gt;</code> 作为实际值的占位符）。以下是 Perl 版本, 供参考。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>prefix operations:</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if ( $str=~s/^&lt;pattern&gt;// ) { $state=&lt;integer&gt;; }

    terms:

if ( $str=~s/^(&lt;pattern&gt;)// ) { $expr_ast=[&lt;integer&gt;,$1]; }

    operators:

$prev_lev=$lev;
if ( $str=~s/^&lt;pattern&gt;// ) { $lev=&lt;integer&gt;; $op=&lt;integer&gt;; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 版本中, 我使用了 given/when 结构, 它和 if 语句一样快, 但更整洁一些。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>prefix operations:</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given $str {
    when .starts-with(&lt;token&gt;) {
        .=substr(&lt;length of token&gt;);
        $state&lt;integer&gt;; }

    terms:

given $str
    when .starts-with(&lt;token start&gt;) {
        $expr_ast=[&lt;integer&gt;,$term]; }

    operators:

given $str {
    when .starts-with(&lt;token&gt;) {
        .=substr(&lt;length of token&gt;);
        $lev=&lt;integer&gt;;
        $op=&lt;integer&gt;;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>需要匹配的一个比较复杂的模式是标识符后跟一个开头的小括号, 并带有可选的空格。使用正则表达式, 这种模式是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if  $str ~~ s:i/^ $&lt;token&gt; = [ [a .. z] \w*] \s* \( // {
    my $var=$&lt;token&gt;.Str;
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在没有正则表达式的情况下, 我们首先使用 <code>&#39;a&#39; le .substr(0,1).lc le &#39;z&#39;</code> 检查 &#39;a&#39; 和 &#39;z&#39; 之间的字符。如果匹配, 我们将其从 <code>$str</code> 中删除, 并将其添加到 <code>$var</code> 中。然后我们进入一个 while 循环, 只要有字母数字或 &#39;_&#39; 字符就可以。然后我们去掉所有的空格, 并测试 &#39;(&#39;。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">when &#39;a&#39; le (my $var = .substr(0,1)).lc le &#39;z&#39; {
    my $idx=1;
    my $c = .substr($idx,1);
    while &#39;a&#39; le $c.lc le &#39;z&#39; or $c eq &#39;_&#39;
        or &#39;0&#39; le $c le &#39;9&#39; {
        $var~=$c;
        $c = .substr(++$idx,1);
    }
    .=substr($idx);
    .=trim-leading;
    if .starts-with(&#39;(&#39;) {
        ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种复杂的模式是浮点数的模式。在 Fortran 中, 这种模式更加复杂, 因为子模式 <code>.e</code> 可以是浮点常量的一部分, 也可以是等价运算符 <code>.eq.</code> 的一部分。此外, mantissa 和指数之间的分隔符不仅可以是 e, 还可以是 d 或 q, 所以正则表达式相当复杂。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if (
    (
        !($str~~rx:i/^\d+\.eq/) and
        $str~~s:i/^([\d*\.\d*][[e|d|q][\-|\+]?\d+]?)//
    )
    or
    $str~~s:i/^(\d*[e|d|q][\-|\+]?\d+)//
) {
    $real_const_str=$/.Str;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在没有正则表达式的情况下, 实现方法如下。我们首先检测 0 到 9 之间的字符或点。然后我们尝试匹配尾数、分隔符、符号和指数。后面三个是可选的；如果它们不存在, 并且尾数不包含点, 我们就匹配了一个整数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">when &#39;0&#39; le .substr(0,1) le &#39;9&#39; or .substr(0,1) eq &#39;.&#39; {
    my $sep=&#39;&#39;;
    my $sgn=&#39;&#39;;
    my $exp=&#39;&#39;;
    my $real_const_str=&#39;&#39;;

    # first char of mantissa
    my $mant = .substr(0,1);
    # try and match more chars of mantissa
    my $idx=1;
    $h = .substr($idx,1);
    while &#39;0&#39; le $h le &#39;9&#39; or $h eq &#39;.&#39; {
        $mant ~=$h;
        $h = .substr(++$idx,1);
    }
    $str .= substr($idx);

    # reject .eq.
    if not ($mant.ends-with(&#39;.&#39;) and .starts-with(&#39;eq&#39;,:i)) {
        if $h.lc eq &#39;e&#39; | &#39;d&#39; | &#39;q&#39; {
            # we found a valid separator
            $sep = $h;
            my $idx=1;
            $h =.substr(1,1);
            # now check if there is a sign
            if $h eq &#39;-&#39; or $h eq &#39;+&#39; {
                ++$idx;
                $sgn = $h;
                $h =.substr($idx,1);
            }
            # now check if there is an exponent
            while &#39;0&#39; le $h le &#39;9&#39; {
                ++$idx;
                $exp~=$h;
                $h =.substr($idx,1);
            }
            $str .= substr($idx);
            if $exp ne &#39;&#39; {
            $real_const_str=&#34;$mant$sep$sgn$exp&#34;;
            $expr_ast=[30,$real_const_str];
            } else {
                # parse error
            }
        } elsif index($mant,&#39;.&#39;).Bool {
            # a mantissa-only real number
            $real_const_str=$mant;
            $expr_ast=[30,$real_const_str];
        }
        else { # no dot and no sep, so an integer
            $expr_ast=[29,$mant];
        }
    } else { # .eq., backtrack and carry on
        $str =&#34;$mant$str&#34;;
        proceed;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一个关于如何处理模式的例子是比较和逻辑运算符中的空白。Fortran 有 <code>&lt;dot word dot&gt;</code> 形式的运算符, 例如 <code>.lt.</code> 和 <code>.xor.</code>。但恼人的是, 它允许在点和字之间留白, 例如 <code>.lt.</code> 和 <code>.xor.</code> 使用正则表达式, 这当然很容易处理, 例如。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $str~~s/^\.\s*ge\s*\.//) {
    $lev=6;
    $op=20;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我检查一个以点开始的模式, 并且在下一个点之前包含一个空格。然后, 我使用 <code>trans</code> 删除该子串中的所有空格, 并用这个修剪后的版本替换原始字符串。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">when .starts-with(&#39;.&#39;) and  .index( &#39; &#39; )
    and (.index( &#39; &#39; ) &lt; (my $eidx = .index(&#39;.&#39;,2 ))) {

    # Find the keyword with spaces
    my $match = .substr(0, $eidx+1);
    # remove the spaces
    $match .= trans( &#39; &#39; =&gt; &#39;&#39; );
    # update the string
    $str = $match ~ .substr( $eidx+1);
    proceed;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_结论_7">79.20. 结论</h3>
<div class="paragraph">
<p>总的来说, Raku 中优化后的表达式解析器与 Perl 版本还是非常接近的。关键的区别在于 Raku 版本没有使用正则表达式。通过上面的例子, 我想说明如何使用 Raku 内置的一些字符串操作来编写与正则表达式 s/// 操作功能相同的代码。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>substr : substring</p>
</li>
<li>
<p>index：字符串中的一个子串的位置。</p>
</li>
<li>
<p>trim-leading : 条形前导空格。</p>
</li>
<li>
<p>starts-with</p>
</li>
<li>
<p>ends-with</p>
</li>
<li>
<p>trans : 用于使用 &#39; &#39; ⇒ &#39;&#39; 模式删除空白。</p>
</li>
<li>
<p>lc：用于范围测试, 而不是同时测试大写和小写。</p>
</li>
<li>
<p>le, lt, ge, gt: 用于非常方便的范围比较, 例如 &#39;a&#39; le $str le &#39;z&#39; 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当然, 由此产生的代码要长得多, 但可以说比正则表达式更易读, 目前速度快了四倍。</p>
</div>
<div class="paragraph">
<p>所有测试的代码都可以在我的 <a href="https://github.com/wimvanderbauwhede/raku-examples/tree/master/Performance-analysis">GitHub repo</a> 中找到。
== <a href="https://raku-advent.blog/2020/12/17/day-17-becoming-a-time-lord-in-raku/">第十七天 - 成为 Raku 中的时间领主</a></p>
</div>
<div class="paragraph">
<p>我大半辈子都住在一个时区边界的几分钟之内。我们区分时间的方式并不是用&#34;东部&#34;和&#34;中部&#34;时间的官方名称。不, 我们用的是更亲切（然而, 也更酷）的术语&#34;快时&#34;和&#34;慢时&#34;。知道你说的是哪个区域是非常重要的, 因为很多人像我母亲一样住在一个区域, 而在另一个区域工作。</p>
</div>
<div class="paragraph">
<p>当我开始研究在 Raku 中使用来自<a href="http://cldr.unicode.org/">通用语言数据仓库</a>（或 CLDR）的数据来实现国际化的 <a href="https://docs.raku.org/type/DateTime">DateTime</a> 格式化时, 我得出了一个相当令人惊讶的认识。Raku 并不理解时区。当然, DateTime 对象有 <a href="https://docs.raku.org/type/DateTime#method_timezone">.timezone</a> 方法, 但它只是 <a href="https://docs.raku.org/type/DateTime#method_offset">.offset</a> 的别名, 用来计算与 GMT 的偏移。</p>
</div>
<div class="paragraph">
<p>我曾在一年中不同时间实行夏令时的国家生活过, 我的家人也在我自己的区域内不实行夏令时的地方生活过, 并且知道有些奇怪的地方与 GMT 有 30 分钟甚至 45 分钟的偏移, 我知道时区可能很复杂。</p>
</div>
</div>
<div class="sect2">
<h3 id="_宇宙之大_浩浩荡荡_错综复杂_荒诞不经">79.21. 宇宙之大, 浩浩荡荡, 错综复杂, 荒诞不经</h3>
<div class="paragraph">
<p>有一个巨大的数据库, 简称 <a href="https://www.iana.org/time-zones">tz</a>, 是一个巨大的时区数据库, 从什么时候发生过渡, 什么时候夏令时什么时候进退, 偏移, 一切。不像 Unicode 代码图, Raku 不包括这个作为其核心的一部分, 因为它的频繁更新和固有的不稳定性（yay政治家）。OTOH, 可能部分原因是它起源于<a href="https://xkcd.com/2347/">现实生活中的 XKCD 漫画</a>, 它确实包含了一些非常酷的老式程序员的思考, 我完全主张我们把它带回来（你最后一次看到一个代码库在他们的标题中引用文献是什么时候？Knuth？)</p>
</div>
<div class="paragraph">
<p>除了数据库之外, 还有一个标准的代码库 - 如果你使用的是 <code>*nix</code> 机器, 你的电脑上很可能就有一个 - 用来转换各种不同表示方式的时间, 同时考虑到时区。它是用 C 语言编写的, 所以它的可移植性很强。</p>
</div>
<div class="paragraph">
<p>我们可以采取简单的方式, 使用 <a href="https://docs.raku.org/language/nativecall">NativeCall</a>（一种在 Raku 中直接调用编译后的 C 代码的方式）来传递数据。但那有什么意思呢？相反, 我<a href="https://github.com/alabamenhu/DateTimeTimezones/blob/master/lib/DateTime/Timezones/Routines.pm6">移植了代码</a>。毕竟, 这个算法相当简单, 由大量的常量和一些基本的数学, 一些二进制搜索和一对条件组成, 但没有什么是在任何语言中不能完成的。很简单。</p>
</div>
<div class="paragraph">
<p>但是一旦完成了这些, 还是有一个问题。我们如何让 DateTime 理解时区？</p>
</div>
</div>
<div class="sect2">
<h3 id="_掌握时间">79.22. 掌握时间</h3>
<div class="paragraph">
<p>如上所述, Raku 的 DateTime 除了知道 GMT 偏移量是什么之外, 并不真正理解时区。我也许可以做一个新的 DateTimeTZ 类, 让人们在需要理解时区的模块中使用, 比如日期/时间格式化器, 但那样的话, 我就需要花很多时间来确保我的代码在两者之间的强转, 不接受/返回错误的, 而且…​是的, 那会很烦人。另外, 即使我把它做成 DateTime 的一个子类, 因为大多数 DateTime 方法都会返回新的 DateTime 对象, 我需要覆盖几乎每一个方法, 即使这样, 如果有其他模块手动创建一个 DateTime, 时区信息也会丢失。</p>
</div>
<div class="paragraph">
<p>另一个选择是 <strong>augment</strong> DateTime, 给它一个新的 <code>.timezone-id</code> 和 <code>.is-dst</code> 方法。Augmenting 是在类的原始声明之外为其添加方法或属性的过程。但是看一个时间是不可能知道它的时区 ID 是什么的。虽然北美和南美通过偏移共享时区, 但它们的名称不同（夏令时的调整方式也不同）。我可以尝试推断, 就像 <a href="https://github.com/alabamenhu/UserTimezone">Intl::UserTimezone</a> 所做的那样, 但那最多只能适用于用户当前地区的时区, 而且最终还是需要用户以某种方式来指定。另外, 当你增强一些东西时, 你会破坏预编译。Raku 预编译模块是为了减少启动时间, 这意味着使用时区与任何大型模块都会破坏你的启动时间, 特别是当你使用几个非常大的模块时。</p>
</div>
<div class="paragraph">
<p>必须有一个更好的解决方案。这个解决方案涉及到两个解决方案：一个是非常常见的, 一个是比较罕见的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_添加一抹晃晃悠悠的_timey_wiminess">79.23. 添加一抹晃晃悠悠的 timey wiminess</h3>
<div class="paragraph">
<p>首先需要做的是创建一个可以混入的<a href="https://docs.raku.org/language/objects#index-entry-declarator_role-Roles">角色</a>, 也就是应用于一个类。角色传统上是用来描述或修改行为的（它们类似于 Java 的接口）, 但它们也可以为现有的类添加额外的信息。角色还可以很好地允许类型检查, 就像基类一样, 所以通过在每个 DateTime 中混入一个角色, 应该不会有任何兼容性问题。一个简单的 Timezone 角色可能是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">role TimezoneAware {
    has $.olson-id;
    has $.is-dst;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我的意思是, 这可以工作。我需要能够设置这些, 而且我宁愿不要用公共实例化方法来污染东西, 因为角色不能像类那样传递属性, 但它们可以被<a href="https://docs.raku.org/syntax/role#Parameterized_roles">参数化</a>。这可能是一种滥用, 但我们最终可以用这样的方法来实现…</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">role TimezoneAware[$tz-id,$dst] {
    method olson-id { $tz-id }
    method is-dst   { $dst   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们有办法让 DateTime 知道它的时区, 但是…​我们如何应用它？要求用户手动说明 <code>DateTime.new(…) does TimezoneAware[…]</code> 会变得非常乏味, 尤其是他们无法控制可能从这些对象中创建的 DateTime 对象(因为 DateTime 是不可改变的, 任何调整, 比如 <code>.later</code> 会创建一个新的 DateTime 对象, 而这个对象不会有 mixin)。</p>
</div>
</div>
<div class="sect2">
<h3 id="_永远不要丢弃任何东西_harry">79.24. 永远不要丢弃任何东西, Harry</h3>
<div class="paragraph">
<p>我们可以通过使用 <code>wrap</code> 例程来实现这个功能(而且不需要放弃预编译!)。封装允许我们在调用时捕捉它, 并在必要时进行干预。</p>
</div>
<div class="paragraph">
<p>一个简单的封装程序, 只是让我们知道有东西被调用了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">Foo.^find_method(&#39;bar&#39;).wrap(
    method (|c) {
        say &#34;Called &#39;bar&#39; with arguments &#34;, c;
        my $result = callsame;
        say &#34;  --&gt; &#34;, $result;
        $result;
    }
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要有人在 Foo 对象上调用 <code>.bar</code>, Raku 就会输出参数是什么, 以及新做的对象, 而且还是返回, 这样就不会干扰程序流程。因为我们可以获得原始的结果, 然后对它做一些事情, 所以我们有机会混入我们的角色, 让它影响每一个被创建的 DateTime, 只要说 <code>$result does TimezoneAware[…​]</code>。</p>
</div>
<div class="paragraph">
<p>在使用这种技术时, 我发现了一个小问题, 这是由于 DateTime 的 <code>.new</code> 是一个多方法。使用 <a href="https://docs.raku.org/routine/callsame">callsame</a>（会把我们传给原始的 DateTime）会使用所有原始的参数, 这使得我们不可能添加新的参数, 比如 <code>:daylight</code> 或 <code>:dst</code> 或任何我们想调用的参数, 因为原始方法会拒绝它们。</p>
</div>
<div class="paragraph">
<p>不过如果我们使用 <a href="https://docs.raku.org/routine/callwith">callwith</a>, 我们可以删除这些额外的参数, 甚至可以在我们的时区处理要求的情况下进行修改（最终确实如此）。但是由于 <code>wrap</code> 与多方法的交互方式, 我们最终还是会再次调用被包装的方法！这也是我们的一个问题。当我在测试时, 我偶尔会得到一个应用了两三次作用的 DateTime。这可不好。</p>
</div>
<div class="paragraph">
<p>解决方法出奇的简单。当再次调用封装的方法时, 我只需要使用 callsame 来获得原始版本。但是, 我怎么知道我是否在第一次调用它呢？回想一下, 我们不能在添加参数的同时仍然使用 callsame！）Raku 的动态变量来救场了。在封装方法的开始, 我们做一个快速检查, 看看我们是要原始的还是封装的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">DateTime.^find_method(&#39;new&#39;).wrap(
    method (|c) {
        return (callsame) if $*USE-ORIGINAL;
        ...
    }
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>不幸的是, 乐道编译的方式意味着我们实际上不能设置这个变量, 因为 <code>my $*USE-ORIGINAL</code> 必然会在后面出现。但是, 如果你还没有猜到, Raku 有一个解决方案, 我们知道这个变量会在调用链的某个地方。通过使用 psuedo-package CALLERS, 我们可以在调用链的上游找到这个变量, 而不会导致编译器在我们的作用域中安装它的符号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">DateTime.^find_method(&#39;new&#39;).wrap(
    method (|c) {
        return (callsame) if CALLERS::&lt;$*USE-ORIGINAL&gt;;
        ...
    }
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>的确, 如果有人使用这个相同的名字, 可能会有问题, 因为 CALLERS 一直在调用链的上游。也许可以只用 <code>CALLER::CALLER::&lt;$*USE-ORIGINAL&gt;</code>, 但使用 <code>CALLER::</code> 的次数可能并不太一致。对于实际的模块, 我选择了一个更不可能的名字 <code>$*USE-ORIGINAL-DATETIME-NEW</code>。魔法变量不好, 我知道, 但晦涩难懂应该绰绰有余。</p>
</div>
</div>
<div class="sect2">
<h3 id="_维度超越论是荒谬的但它是有效的">79.25. 维度超越论是荒谬的（但它是有效的）</h3>
<div class="paragraph">
<p>callsame、callwith 等的一个问题是, 它们是在当前方法上工作的, 这就更难把事情做出来。有一些方法可以解决这个问题, 但我最终发现把所有逻辑都包含在一个方法中是最简单的。</p>
</div>
<div class="paragraph">
<p>为了完全模仿多方法, 而不调用我自己的子方法, 我使用了捕获和签名符。注意封装方法的签名为 <code>|c</code>, 它将所有的参数收集到 <code>c</code> 中, 并允许对其进行检查。由于有两种方法可以有效地创建一个 DateTime, 让我们先解决最简单的一种：从一个数字中创建。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">        ...
        if c ~~ :(Instant:D $, *%)
        || c ~~ :(Int:D     $, *%) {
            my $posix = c.list.head;
            $posix = $posix.to-posix if $posix ~~ Instant;

            my $tz-id = c.hash&lt;tz-id&gt; // &#39;Etc/GMT&#39;;
            my $time = localtime get-timezone-data($tz-id), $posix;

            my $*CALL-ORIGINAL = True;
            return callwith(self, $posix, :timezone($time.gmt-offset))
                but TimezoneAware[$tz-id, $time.is-dst];
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>localtime 的结果是(目前)一个 Raku 等同于几乎所有 <code>*nix</code> 系统和时间库中使用的老的和无处不在的 <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/time.h.html#tag_13_76">tm 结构</a>。因为我们已经有了  POSIX 时间, 所以我们只需要传入新的&#34;时区&#34;和混合角色就可以了。</p>
</div>
<div class="paragraph">
<p>不过有一个小麻烦。现在考虑一下下面的问题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">say DateTime.new(now).WHAT; # DateTime+{TimeZoneAware[…]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>呃…​ 这是一个名副其实的口水。有什么办法可以改变吗？事实证明, 有。我不会说你有必要应该这样做, 但是我们要尽可能的在后台。在返回之前, 我们要这样存储变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">            my $result = callwith( … ) but TimezoneAware[…];
            $result.^name = &#39;DateTime&#39;;
            return $result</code></pre>
</div>
</div>
<div class="paragraph">
<p>Et violà, 它看起来完全正常, 除了它有那些额外的方法。我们的新 DateTime 将通过一个旧的方法, 即使有人进行基于名称的比较（当然, 他们应该使用可能使用 <code>.isa</code> 或 smartmatching, 这将不改变名称）。</p>
</div>
<div class="paragraph">
<p>现在我们解决第二种方法, 这是从被赋予离散时间单位。有一个 gmt-from-local 例程, 它将上述 tm 结构和一个时区一起接收, 并试图将两者协调起来, 以得到一个 POSIX 时间（如果你要求我在某一天的 2:30 前进…​…​我们会有问题）。一旦我们有了 POSIX 时间, 那么我们就可以像以前一样创建东西。我不会告诉你所有这种类型的创建方式, 但是很容易想象（或者你可以在代码中查看）。</p>
</div>
<div class="paragraph">
<p>对于 new 之外的方法, 并没有太多的工作需要做。像 <code>.day</code>, <code>.month</code> 等, 应该都是一样的, 因为原来的 DateTime 能理解GMT偏移。</p>
</div>
<div class="paragraph">
<p>重要的是 to-timezone, 我们需要做的, 其实就是把它包起来, 然后调用 <code>.new(self, :$timezone)</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_生活依赖于变化和更新">79.26. 生活依赖于变化和更新</h3>
<div class="paragraph">
<p>包裹实际上是一件非常普遍的事情：你无法在词法上对它进行范围化处理, 所以如果我们在 INIT（脚本启动时发射的 <a href="https://docs.raku.org/language/phasers">phaser</a>）处进行包裹, 它的效果从一开始就会在全球范围内显现。除了…​…​有两个 phaser 会在 INIT 之前发射, 它们是 BEGIN 和 CHECKER。它们是 BEGIN 和 CHECK, 它们在编译阶段发射, 我们无法触及它们。如果有人在这些区块中创建一个 DateTime, 它仍然是一个普通的 DateTime, 没有我们的 mixin。请考虑以下内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">my $compile-time = BEGIN DateTime.new: now;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们应该如何处理这个问题？如果以后用上了, 就不会有用户可能依赖的属性了。我们该如何帮助解决这个问题呢？</p>
</div>
<div class="paragraph">
<p>首先, 如果用户调用 <code>.day</code>, 不会有区别, 所以没有问题。但是如果用户调用, 比如说, olson-id, 我们就麻烦了。没有这样的方法。或者有吗？</p>
</div>
<div class="paragraph">
<p>Raku 对象有一个特殊的(psuedo)方法, 叫做 FALLBACK, 当一个未知的方法被调用时, 它就会被调用。如果还没有添加回落, 我们就不能把它包起来(例如 <code>.^find_method(&#39;FALLBACK&#39;).wrap(…)</code>)。尽管如此, 同样的 <a href="https://docs.raku.org/type/Metamodel::ClassHOW">HOW</a> 给了我们 <code>^find_method</code>, 也给了我们 <code>^add_fallback</code>, 尽管它的语法有点棘手。</p>
</div>
<div class="paragraph">
<p>例如, 对于 Olson ID 方法, 我们可以做如下操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">INIT DateTime.^add_fallback:
    anon sub condition  ($invocant, $method-name --&gt; Bool    ) { $method-name eq &#39;olson-id&#39; }
    anon sub calculator ($invocant, $method-name --&gt; Callable) { method { … }               };</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果条件子返回 True, 那么计算器中返回的方法就会被运行。现在, 即使这些老式的 DateTime 对象中的一个设法坚持下来, 我们也可以做一些事情。但我们能做什么呢？事实证明, 有很多…​取决于。</p>
</div>
<div class="paragraph">
<p>我们可以尝试运行一组新的计算。如果同样老式的 DateTime 让我们定期调用它的方法, 那么我们就会浪费大量的 CPU 周期。相反, 我们实际上可以替换（或者…​再生）这个对象! 虽然 <code>rw</code> 这个特质是相当著名的, 但鲜为人知的是, 它可以存在于调用者身上！唯一的问题是, 我们需要在调用者身上有一个新的特质。唯一的问题是, 我们需要为调用者提供一个标量容器, 这可以通过给它一个 sigil 来实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">method ($self is rw: |c) {
    $self = …
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>不过有一个小问题。如果 DateTime 不在一个容器中（例如, 它是一个常量）, 我们不仅卡住了, 而且上面的方法会出错, 因为 <code>is rw</code> 需要一个可写的容器。在这种情况下, 我们需要回退到每次重新计算。代价不大。但是我们怎么能知道呢？或者让它工作, 因为上面的方法在不可写的容器下会出错？简单的答案：<code>multi</code> 方法。神奇的是, 如果你有两个相同的方法, 但对于 trait <code>is rw</code>, 那么 dispatch 会优先选择 <code>is rw</code> 用于可写容器, 而另一个用于不可写。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">multi method foo ($self is rw: |c) {
    self = …  # upgrade for faster calls later
}
multi method foo ($self: |c) {
    calculate-with($self)  # slower style here
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>问题是你不能传递一个 <code>multi</code> 方法。事实上, <code>multi</code> 方法只能在类声明里面正确声明和引用。解决方法是在 <code>wrap</code>  的括号外做一个 multi <strong>sub</strong>, 然后在 <code>wrap</code> 时用它的 sigiled self 来引用它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">proto sub foo (|) { * }
multi sub foo ($self is rw, |c) {
   self = …             # ^ notice the comma, subs don&#39;t have invocants,
}                       #   but they&#39;re passed as the first argument
multi sub foo ($self, |c) {
   calculate-with($self)
}
….wrap(&amp;foo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>包裹、多重调度、一级函数, 太多的东西都在发生, 但我们避免了破坏预编译, 并设法不使用任何一个 <a href="https://docs.raku.org/language/pragmas#index-entry-MONKEY-TYPING&lt;em&gt;pragma">MONKEY-TYPING</a>(<a href="https://docs.raku.org/language/pragmas#index-entry-MONKEY-TYPING" class="bare">https://docs.raku.org/language/pragmas#index-entry-MONKEY-TYPING</a>pragma) 🙂。</p>
</div>
</div>
<div class="sect2">
<h3 id="_蝴蝶结很酷">79.27. 蝴蝶结很酷</h3>
<div class="paragraph">
<p>还有很多其他的小细节可以给用户。其中一个主要的问题是方法和参数的名称。在上面的写法中, 我已经使用了一些名字, 但还可以使用其他名字。例如, 使用 <code>.is-dst</code> 与 <code>.dst</code> 来确定给定的时间是否在夏令时, 是否有什么本质上的好处？而在 <code>is-</code> 问题之外, 我们应该使用 dst、daylight, 还是像世界上大部分地区一样, 使用 summer-time？</p>
</div>
<div class="paragraph">
<p>抓取时区名称也会出现类似的问题。虽然 stock DateTime 有一个 <code>.offset</code> 方法来获取 GMT 偏移量, 但它也从 <code>.timezone</code> 提供了完全相同的信息。替代品可以是, 我上面用的, tz-id, timezone-id, 或者 olson-id（Olson 发明了做数据库时使用的 ID）。其实, 在这个问题上, 我已经作弊了, 略微作弊了。通过使用异构的 <a href="https://docs.raku.org/type/IntStr">IntStr</a>, 我们可以让一些东西在数字和字符串的上下文中发挥不同的功能。所以我们可以重写 timezone 返回 self.offset 但 self.timezone-id, 可能会给大家带来不错的 DWIM 功能。</p>
</div>
<div class="paragraph">
<p>一个看起来相当明显的是 <code>.tz-abbr</code>, 它给出了 EST 或 PDT 这样的信息, 用于格式化。没有什么比让方法名来体现它所提供的东西更合适的了 🙂。</p>
</div>
<div class="paragraph">
<p>当创建一个 DateTime 时, 也可以指定一个格式。默认的格式遵循 ISO 标准, 但很多人发现, 例如 &#34;CEST&#34; 比 &#34;+02:00&#34; 更容易识别为欧洲标准。是否应该改变默认的格式？这是我还没有得出结论的一个问题。默认格式提供了一个标准的格式, 但是由于它可以改变, 所以没有理由让人期望（或者更重要的是, 依赖）它总是产生相同的字符串。</p>
</div>
<div class="paragraph">
<p>这些问题看似微不足道, 但 Raku 引以为豪的是, 核心和模块开发人员的文化是真正的打磨, 让事情变得简单。从代码的可读性、与其他模块和核心语言的集成、功能等一切都会得到考虑, Raku 尤其适合让开发者有能力去做对他们和用户都最好的事情。</p>
</div>
</div>
<div class="sect2">
<h3 id="_不要眨眼眨都不眨一下">79.28. 不要眨眼。眨都不眨一下</h3>
<div class="paragraph">
<p>虽然我之前简单地提到过, 但值得重复的是, 为什么 Raku 本身不包含支持时区的开箱。时区不是固定的。政府和政治是对时区的定时的摇摆不定。我在美国, 就因为今天我预计夏令时从3月14日开始, 并不意味着国会或美国交通部长(!)明天不能改变事情。或者我的州, 独立于它周围的州, 可能会在那之前完全选择退出夏令时。世界上所有其他国家都会重复这样的做法。</p>
</div>
<div class="paragraph">
<p>任何有内置支持的东西都需要非常稳定（<a href="https://unicode.org/ucd/">Unicode 字符数据库</a>）, 或者提前提供变化的提示(<a href="https://en.wikipedia.org/wiki/Leap_second">闰秒</a>)。这是因为大多数人不会使用最先进的发行版。哼, 苹果还在发布2013年的 Perl 5.18.4 呢! 仅在2013年就有八次数据库更新, 从那时起到今天又有四十五次更新。即使是得到苹果更多更新爱的Python, 从苹果分发的最新版本(2.7.16)开始, 也有十二次更新。</p>
</div>
<div class="paragraph">
<p>这就是模块的闪光点：只要有更新, 就使用 zef 或其他模块管理器升级 DateTime::Timezones, 用户就可以随时保持更新。在维护方面, 我已经创建了一个<a href="https://github.com/alabamenhu/DateTimeTimezones/blob/master/resources/update-tz-database.raku">脚本</a>, 使整个更新过程自动化, 我只需要手动更改模块的版本号和更新文档。这也意味着, 如果我因为某些原因没有更新模块, 本地用户可以轻松地在本地自行更新数据库, 而对数据库变幻莫测的工作原理一无所知。</p>
</div>
</div>
<div class="sect2">
<h3 id="_事件二">79.29. 事件二</h3>
<div class="paragraph">
<p>如前所述, 我之所以参与这个项目, 是因为我的工作是将 CLDR 数据引入 Raku, 特别是格式化日期/时间。它所考虑的一件事是支持非格里高利历, 其中一些历法在计算方式上与格里高利历有很大不同。有一些像 <a href="https://github.com/jforget">Jean Forget</a> 这样的人正在为 Raku 做这些工作, 但是他们目前作为他们自己的独立类存在, 不能与内置的 Date 和 DateTime 类互换。没有什么可以阻止任何人进一步扩展 DateTime 与上述方法, 以添加一个新的属性日历, 可以设置为 gregorian 或 hebrew 或 persian。这比我们这里的工作要复杂一些, 因为一些时间计算是硬编码到 DateTime 中的, 这将需要相当多的额外工作, 但这是在可能性的范围内。</p>
</div>
<div class="paragraph">
<p>我们的 Perl 兄弟<a href="https://metacpan.org/pod/DateTime#THE-DATETIME-PROJECT-ECOSYSTEM">想象了不同的模块</a>, 这些模块共享共同的属性, 但是通过工作, 应该可以让一个 DateTime 在 Raku 中统治所有的模块（等等, 我正在改变文化参考点, 哎呀）。只有…​嗯, 时间, 呃, 会告诉我们。
== <a href="https://raku-advent.blog/2020/12/18/day-18-typed-raku-part-1-taming-state/">第十八天 - 带类型的 Raku, 第二部分: 驯化状态</a></p>
</div>
<div class="paragraph">
<p>当我几年前开始学习 <a href="https://www.raku.org/">Raku</a> 的时候, 第一个让我印象深刻的功能之一就是它的类型系统。这是一个我觉得被忽视的时候。一开始我发现这一点相当难以理解, 但我发现依靠严格的类型可以使代码更简单、更健壮, 随着时间的推移可以更好地应对变化。我将用国际象棋来演示这一点, 但首先要介绍一些基础知识。</p>
</div>
</div>
<div class="sect2">
<h3 id="_介绍类型和种类">79.30. 介绍类型和种类</h3>
<div class="paragraph">
<p>在 Raku 中, 任何对象的类型都可以用 <strong>WHAT</strong> 来反省。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">say 42.WHAT;      # OUTPUT: (Int)
say WHAT 42 | 24; # OUTPUT: (Junction)</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然我们想做这个事情的时候, 往往对它的类型<a href="https://docs.raku.org/type/Metamodel::Naming#method_name">名称</a>比类型对象本身更感兴趣。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">say 42.^name; # OUTPUT: Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>类型检查是对象的 <strong>HOW</strong> 所定义的行为之一。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">say 42.HOW.^name; # OUTPUT: Perl6::Metamodel::ClassHOW</code></pre>
</div>
</div>
<div class="paragraph">
<p>在类型理论的行话中, 这将是一种<a href="https://en.wikipedia.org/wiki/Kind_(type_theory)">类型</a>, 或类型的一种。</p>
</div>
</div>
<div class="sect2">
<h3 id="_运行时类型检查">79.31. 运行时类型检查</h3>
<div class="paragraph">
<p>偶尔会有需要手动进行类型检查的时候, 比如调试时。对类型对象进行智能匹配时, 默认情况下会执行类型检查。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">say 42 | 24 ~~ Junction; # OUTPUT: True
say 42 | 24 ~~ Int;      # OUTPUT: True</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而, 我们正在进行智能匹配；<code>~~</code> 可以有任何行为, 这取决于 RHS 的 <a href="https://docs.raku.org/routine/ACCEPTS">ACCEPTS</a> 方法是如何表现的。虽然这可以允许智能匹配对象与类型对象的连接, 但有时需要进行更多的类型检查。在这些情况下, Metamodel::Primitives.is_type 将会发挥作用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">say Metamodel::Primitives.is_type: 42 | 24, Junction; # OUTPUT: True
say Metamodel::Primitives.is_type: 42 | 24, Int;      # OUTPUT: False</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类型化变量">79.32. 类型化变量</h3>
<div class="paragraph">
<p>任何变量、参数或属性都可以选择提供类型, 通常作为变量名称的前缀。对于 $-sigilled 变量, 表示其值的类型；对于 @-sigilled 变量, 表示列表值的类型；对于 %-sigilled 变量, 表示哈希值的类型；对于 &amp;-sigilled 变量, 表示例程返回值的类型。特别是对于%-sigilled 变量, 可以在变量名后用大括号给出一个额外的键类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">my Int  $x       = 0;
my Str  @ss      = &lt;sup lmao&gt;;
my Num  %ns{Str} = :pi(π);
my True &amp;is-cool = sub is-cool(Cool $x --&gt; True) { };</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外, 值类型也可以使用 <code>of</code> trait 来指定。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">my $x       of Int  = 0;
my @ss      of Str  = &lt;sup lmao&gt;;
my %ns{Str} of Num  = :pi(π);
my &amp;is-cool of True = sub is-cool(Cool $x --&gt; True) { };</code></pre>
</div>
</div>
<div class="paragraph">
<p>等等, True 怎么会是一个有效的类型？True 是一个 Bool 枚举值, 它是一个 <a href="https://docs.raku.org/type/Cool">Cool</a> 常量, 可以像类型一样使用, 具有 ACCEPTS 语义。字符串和数字字符也属于这一类。我们在这里给出一个作为返回值, 所以我们不需要从例程中显式返回任何东西, 因为它总是会返回 True。</p>
</div>
</div>
<div class="sect2">
<h3 id="_带定义的类型变量">79.33. 带定义的类型变量</h3>
<div class="paragraph">
<p>Raku 提供了一种使用类型笑脸来限制类型值的方法, 这种类型笑脸被放在一个变量的类型之后。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">my Int:U $type;    # Contains an Int type object by default.
my Int:D $value    = 42;
my Int:_ $nullish;
$nullish = $value;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>:U</strong> 笑脸表示未定义的类型对象； <strong>:D</strong> 笑脸表示定义的值（或实例）； <strong>:_</strong> 笑脸表示非此即彼。</p>
</div>
<div class="paragraph">
<p>当一个类型没有给出类型笑脸时, 它们将默认使用 <strong>:_</strong> 语义。这可以使用变量和属性实用名词（参数是 NYI）来定制。例如, 没有笑脸的类型可以被定义, 以使变量类型化的行为更类似于 Haskell 的类型, 比如这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">use variables  :D;
use attributes :D;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当涉及到 <strong>:U</strong> 和 <strong>:_</strong> 变量的类型检查时, Nil 是一个例外。它不能被绑定到一个用这些笑脸符号类型化的变量上, 但是当用这些笑脸符号赋值或从例程中返回时, 你会得到它的类型对象而不是 Nil 本身。失败也是一个空类型, 失败可以从其他 <strong>:U</strong>/<strong>:_</strong> 类型的例程中返回。</p>
</div>
<div class="paragraph">
<p>确定类型可以帮助防止常见的、恼人的运行时错误, 这些错误与把类型对象当作实例处理有关, 或者反之亦然。例如, 你可能已经看到过这样的警告。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">put my $warning; # OUTPUT:
# Use of uninitialized value $message of type Any in string context.
# Methods .^name, .raku, .gist, or .say can be used to stringify it to something meaningful.
#   in block &lt;unit&gt; at -e line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>发出这个警告是 <a href="https://docs.raku.org/type/Mu">Mu</a> 对类型对象的 <strong>Str</strong> 强转的默认行为。给变量一个 <strong>:D</strong> 类型可以帮助防止它的出现。</p>
</div>
</div>
<div class="sect2">
<h3 id="_用类对数据进行分组">79.34. 用类对数据进行分组</h3>
<div class="paragraph">
<p>如果我们要把一个棋子作为数据来表示, 我们可能会有一个颜色和一个棋子的类型。问题是我们如何键入这个类型？我们可能有一个 <strong>Str:D</strong> 的 <strong>Array:D</strong> 开始。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">my Str:D @piece  = &#39;white&#39;, &#39;pawn&#39;;
my Str:D $colour = @piece[0];
my Str:D $type   = @piece[1];</code></pre>
</div>
</div>
<div class="paragraph">
<p>不过 0 和 1 并不是颜色和类型的好名字。如果我们要把混合类型的数据分组, 我们就会陷入用一个比我们打算让它们有的更不具体的类型来打字。我们要的是类型! 我们可以把我们的数据捆绑在一起, 用一个<a href="https://docs.raku.org/language/objects#Classes">类</a>来对所有这些数据进行类型化。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">class Chess::Piece {
    has Str:D $.colour is required;
    has Str:D $.type   is required;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>$.color 和 $.type 是 Chess::Piece 类的公共属性。属性是在 has 作用域内声明的, 公共属性有 <strong>.</strong> twigil, 私有属性有 <strong>!</strong> twigil。因为我们对这些有 <strong>:D</strong> 类型化, 所以它们要么是必须的, 要么有一个默认值。此时我们不能对它们的值进行任何假设, 所以我们将这些标记为必填。</p>
</div>
<div class="paragraph">
<p>就像在传统的面向对象语言中一样, 可以用数据来构造一个类来产生一个值。新方法是我们可以用来做这件事的默认方法, 它接受与类的公共属性相对应的命名参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">my Chess::Piece:D $pawn = Chess::Piece.new: :colour&lt;white&gt;, :type&lt;pawn&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我的棋子是棋子…​…​因为我们有 Chess::Piece 作为 $pawn 的类型, 所以有基于方法调用的赋值语法糖, 我们可以用它来减少这个冗余。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">my Chess::Piece:D $pawn   .= new: :colour&lt;white&gt;, :type&lt;pawn&gt;;
my Str:D          $colour  = $pawn.colour;
my Str:D          $type    = $pawn.type;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以用类似于方法调用的语法来访问 $pawn 的公共属性。事实上, 这些都是方法调用。Raku 在涉及到类的时候, 并不区分公共数据、私有数据和保护数据, 它总是私有的。我们所说的公有属性, 其实是带有自动生成 getter 方法的私有属性。</p>
</div>
<div class="paragraph">
<p>棋子可以存在于棋盘上的一个方块内, 方块带有颜色。这可能也是一个类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">class Chess::Square {
    has Str:D          $.colour is required;
    has Chess::Piece:_ $.piece  is rw;
}

my Chess::Square:D $a1 .= new: :colour(Black);
$square.piece .= new: :colour(White), :type(Rook);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们给 Chess::Square 一个 rw $.piece 属性。<code>is rw</code> 是一个特性, 它使公共属性的 getter 更像是 getter 和 setter 的组合, 允许从 Chess::Square 外部对属性进行赋值。</p>
</div>
<div class="paragraph">
<p>我们将需要另一个类来处理棋盘本身。这将跟踪一格格的方块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">class Chess::Board {
    has Chess::Square:D @.squares[8;8];

    submethod BUILD(::?CLASS:D: --&gt; Nil) { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这封装了一个 @.squares 多维数组, 有 8 个文件（列）的 8 个行列（行）。我们支点了一个 BUILD 子方法, 它将在板子构造完成后初始化 @!squares。作为一个子方法, 它不会被任何潜在的子类继承。作为一个 <code>…​</code> 存根, 当调用时将会失败（我们还没有准备好实现这个）。</p>
</div>
<div class="paragraph">
<p>通常我们需要的是方法, 而不是子方法。公共方法可以使用方法例程声明器来声明, 而不是子方法；私有方法的声明方式与公共方法相同, 但名称前缀为 <code>!</code>；Raku 中没有保护方法。</p>
</div>
<div class="paragraph">
<p>在一个类的作用域内, 我们总会有 $?CLASS 和::?CLASS 符号作为它的别名, ::?CLASS 可以作为一种类型化, 而 $?CLASS 在其他情况下会比较好。在 BUILD 的签名中, <code>:</code> 前面的类型是一个调用类型。这是一个像其他参数一样的参数, 但我们没有给它起名字, 因为已经有一个默认的符号, 通常已经足够好了：<strong>self</strong>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_用_enums_关闭集合">79.35. 用 Enums 关闭集合</h3>
<div class="paragraph">
<p>目前我们用字符串来表示棋子的颜色和类型。字符串是用来表示文字的。在用这种方式表示时, 任何文本都可以被赋予颜色或类型, 但我们只能将黑色或白色作为棋子的有效颜色, 而只能将卒、车、主教、马、皇后和王作为类型。换句话说, 我们得到的值是人类可以理解的, 但计算机在这里并不能像我们希望的那样解释它们。我们可以用<a href="https://docs.raku.org/language/typesystem#enum">枚举</a>来更好地表示这些。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">enum Chess::Colour &lt;White Black&gt;;
enum Chess::Type   &lt;Pawn Rook Bishop Knight Queen King&gt;;

class Chess::Piece {
    has Chess::Colour:D $.colour is required;
    has Chess::Type:D   $.type   is required;
}

class Chess::Square {
    has Chess::Colour:D $.colour is required;
    has Chess::Piece:_  $.piece  is rw;
}

my Chess::Square:D $a1 .= new: :colour(Black);
$ai.piece .= new: :colour(White), :type(Bishop);</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在只能使用我们打算的棋子的颜色和类型。</p>
</div>
<div class="paragraph">
<p>默认情况下, 一个枚举的值列表中的索引将作为它的值, 同时还有一个键与枚举值的名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">say White;       # OUTPUT: White
say White.key;   # OUTPUT: White
say White.value; # OUTPUT: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>至于枚举值本身, 它们将是其枚举类型的实例, 并将始终等同于它们的值, 然而它们也将带有枚举类型化。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">say White == 0;             # OUTPUT: True
say White ~~ Enumeration:D; # OUTPUT: True</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Enumeration</strong> 类型是导致 White 被 &amp;say 输出为 White 而不是 0 的原因, 例如。</p>
</div>
<div class="paragraph">
<p>默认的索引值在棋子颜色和类型的情况下工作得很好, 但不是所有的情况。枚举可以有任何类型的值, 不过它的值在编写时只能是实例。这是默认情况下从枚举的值中推断出来的, 但当给出一个作用域声明符（my、our、unit 等）时, 可以明确地表示出来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">my Int enum Chess::Colour &lt;White Black&gt;;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_用_subset_约束类型和值">79.36. 用 subset 约束类型和值</h3>
<div class="paragraph">
<p>当移动一个棋子时, 我们需要把它的文件和等级的元组（在 Chess::Board 的 @.squares 中的索引）作为程序的参数。我们可以在 Chess::Position 类中用 Int:D 来表示这些参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">class Chess::Position {
    has Int:D $.file;
    has Int:D $.rank;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但就像颜色和类型一样, 这太宽泛了；我们只想允许 0-7 的整数。我们也许可以用一个 a-h 的 Int 枚举来表示文件, 但我们没有任何符号来给出等级。我们可以使用 <a href="https://docs.raku.org/language/typesystem#subset">subset</a> 来将其中一个的有效值限制在我们想要的范围内。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">subset Chess::Index of Int:D where ^8;

class Chess::Position {
    has Chess::Index $.file is required;
    has Chess::Index $.rank is required;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就通过运行时类型检查将 Int 限制在 0-7 的范围内。这里, <strong>Int:D</strong> 是我们子集的 refinee, <code>^8</code> 是它的 refinement。对 Chess::Index 的智能匹配将首先对 LHS 和它的 refinee 进行类型检查, 如果成功的话, 再对 LHS 和 refinement 进行智能匹配。虽然我通常会在类型中包含一个类型笑脸, 但当 refinee 已经包含 :D 时, 写 Chess::Index:D 是多余的。</p>
</div>
<div class="paragraph">
<p>我们可以使用 where 子句以更特别的方式来写这个子集。这个变量声明大致相当于一个 Chess::Index 类型的变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">my Int:D $file where ^8 = 0;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而, 当用裸露的 where 子句代替像这样的显式子集时, 如果类型检查失败, 我们会得到一个不太可读的异常。</p>
</div>
</div>
<div class="sect2">
<h3 id="_总结_9">79.37. 总结</h3>
<div class="paragraph">
<p>到目前为止, 我们有少量的国际象棋类型。虽然我们有与它们相关联的状态的类型安全表示, 但我们没有什么行为实现方式。在这一点上我们没有实现任何行为, 因为我们的类型是有缺陷的；我们对类的依赖会使我们最终得到的代码复杂化。我们首先关注 Raku 类型系统中限制性较强的方面, 这样我们就可以充分地利用更自由的方面, 这将是下一部分的重点。
== <a href="https://raku-advent.blog/2020/12/19/day-19-typed-raku-part-2-taming-behaviour/">第十九天 - 带类型的 Raku, 第二部分: 驯化行为</a></p>
</div>
<div class="paragraph">
<p>在上一部分中, 我声称类型可以允许更流畅、更健壮的代码, 然后为国际象棋写了一堆限制性的类型, 不允许出现这种情况:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">subset Chess::Index of Int:D where ^8;

class Chess::Position {
    has Chess::Index $.file is required;
    has Chess::Index $.rank is required;
}

enum Chess::Colour &lt;White Black&gt;;
enum Chess::Type   &lt;Pawn Bishop Rook Knight Queen King&gt;;

class Chess::Piece {
    has Chess::Colour:D $.colour is required;
    has Chess::Type:D   $.type   is required;
}

class Chess::Square {
    has Chess::Colour:D $.colour is required;
    has Chess::Piece:_  $.piece  is rw;
}

class Chess::Board {
    has Chess::Square:D @.squares[8;8];

    submethod BUILD(::?CLASS:D: --&gt; Nil) { ... }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_多重分派的分支">79.38. 多重分派的分支</h3>
<div class="paragraph">
<p>在修正我们写的类型之前, 我们需要理解一个关键的概念, 但是我们不能在不先修正类型的情况下用国际象棋作为例子。相反, 我们将使用我的   <a href="https://github.com/Kaiepi/ra-Trait-Traced">Trait::Traced</a> 模块中的一个小助手例程作为例子。</p>
</div>
<div class="paragraph">
<p>当渲染预强化的跟踪输出时, 可以在跟踪中出现的对象可以以几种不同的方式渲染：异常将被渲染为红色的异常名称, 失败将被渲染为黄色的异常名称, 而其他任何东西将被渲染为其 <a href="https://docs.raku.org/type/Mu#routine_gist">gist</a>。我们可以写一个 <code>&amp;prettify</code> 例程, 其条件是围绕值参数的类型, 我们假设它是 <code>Any:_</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">sub prettify(Any:_ $value --&gt; Str:D) {
    if $value ~~ Exception:D {
        &#34;\e[31m$value.^name()\e[m&#34;
    } elsif $value ~~ Failure:D {
        &#34;\e[33m$value.exception.^name()\e[m&#34;
    } else {
        $value.gist
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们有基于智能匹配语义的条件, 会影响我们最终得到的值, 所以也许我们有很多 when, 而不是很多 if。我们将用 given/when 模式重写这个。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">sub prettify(Any:_ $value --&gt; Str:D) {
    given $value {
        when Exception:D { &#34;\e[31m$value.^name()\e[m&#34; }
        when Failure:D   { &#34;\e[33m$value.exception.^name()\e[m&#34; }
        default          { $value.gist }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们正在编写一个例程, 这个例程有可能为程序持续时间内发生的每一个跟踪事件而被调用；那个给定的块引入了一个我们不需要的额外作用域, 这带来的开销在这种情况下是不可接受的。因为我们已经有了一个块来工作( <code>&amp;prettify</code> 本身), 如果我们把 <code>$value</code> 重命名为 $_, 我们就可以摆脱这个问题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">sub prettify(Any:_ $_ --&gt; Str:D) {
    when Exception:D { &#34;\e[31m$_.^name()\e[m&#34; }
    when Failure:D   { &#34;\e[33m$_.exception.^name()\e[m&#34; }
    default          { $_.gist }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但这读起来不是很好。当我们围绕着例程的参数类型来设置条件时, 将例程表示为不是一个例程, 而是<a href="https://docs.raku.org/language/functions#Multi-dispatch">多个</a>具有不同签名的例程就成为一种可能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">multi sub prettify(Any:_ $value --&gt; Str:D)           { $value.gist }
multi sub prettify(Exception:D $exception --&gt; Str:D) { &#34;\e[31m$exception.^name()\e[m&#34; }
multi sub prettify(Failure:D $failure --&gt; Str:D)     { &#34;\e[33m$failure.exception.^name()\e[m&#34; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的每个 <strong>multi</strong> 都是 <strong>&amp;prettify</strong> 例程的 dispatchee。当这个例程被调用时, 将选择具有给定参数类型检查的最特定签名的 dispatchee 并被调用, 如果没有匹配的, 将抛出一个类型检查异常。因为我们没有自己定义一个, 所以将为我们生成处理这个问题的 <strong>proto</strong> 例程。当我们想要更具体一点的东西时, 这个例程会用 <strong>:(|)</strong> 作为签名。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">proto sub prettify(Any:_ --&gt; Str:D) {*}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就约束了 <strong>&amp;prettify</strong> 的第一个参数的类型, 对其所有的 dispatchees 都是 <strong>Any:_</strong>。写 <code>{*}</code> 的地方在于当这个被调用时, 将得到的多调用；因为在这种情况下我们要做的就是这个, 所以我们可以把这个写在例程体的地方。</p>
</div>
<div class="paragraph">
<p>在 subset 的帮助下, 多重分派可以在程序中以一种更可扩展和可测试的方式来表示更简单的 <strong>if</strong>、<strong>when</strong> 或 <strong>with</strong> 分支。不过, 在某些情况下, 我们有办法避免让这些分支在运行时发生。</p>
</div>
</div>
<div class="sect2">
<h3 id="_共享角色">79.39. 共享角色</h3>
<div class="paragraph">
<p>回到国际象棋, 我们的 Chess::Piece 和 Chess::Square 类型并不尽如人意, 因为我们将它们的 $.color 和 $.type 定义为属性, 所以我们会对每一步棋的相关条件进行评估。因为我们将它们的 $.color 和 $.type 定义为属性, 我们会在每一步棋中评估与之相关的条件。当我们确切地知道特定颜色和类型的棋子如何移动, 以及棋盘上每个方块的颜色是什么时, 这是不必要的。</p>
</div>
<div class="paragraph">
<p>从 Chess::Piece 开始, 我们或许可以取消定义与这些相关行为的 $.color 和 $.type 属性, 但这样做, 我们就失去了对 Chess::Piece 属性的直接访问。在这里用类创建一个层次化的类型系统是矫枉过正的。当我们想要共享而不是扩展行为时, <a href="https://docs.raku.org/language/objects#Roles">角色</a>会是一个更合适的类型, 或者在本例中, 几个类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">role Chess::Piece { }
role Chess::Piece[White, Pawn] {
    method colour(::?CLASS:_: --&gt; White) { }

    method type(::?CLASS:_: --&gt; Pawn) { }
}
role Chess::Piece[Black, Pawn] {
    method colour(::?CLASS:_: --&gt; Black) { }

    method type(::?CLASS:_: --&gt; Pawn) { }
}
role Chess::Piece[Chess::Colour:D $colour, Bishop] {
    method colour(::?CLASS:_: --&gt; Chess::Colour:D) { $colour }

    method type(::?CLASS:_: --&gt; Bishop) { }
}
role Chess::Piece[Chess::Colour:D $colour, Rook] {
    method colour(::?CLASS:_: --&gt; Chess::Colour:D) { $colour }

    method type(::?CLASS:_: --&gt; Rook) { }
}
role Chess::Piece[Chess::Colour:D $colour, Knight] {
    method colour(::?CLASS:_: --&gt; Chess::Colour:D) { $colour }

    method type(::?CLASS:_: --&gt; Knight) { }
}
role Chess::Piece[Chess::Colour:D $colour, Queen] {
    method colour(::?CLASS:_: --&gt; Chess::Colour:D) { $colour }

    method type(::?CLASS:_: --&gt; Queen) { }
}
role Chess::Piece[Chess::Colour:D $colour, King] {
    method colour(::?CLASS:_: --&gt; Chess::Colour:D) { $colour }

    method type(::?CLASS:_: --&gt; King) { }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>角色是混合类型。我们可以声明任意数量的同名角色来组成一个角色组, 只要它们的类型参数不同且不重叠即可。有了两个类型参数, 我们就可以建立颜色和棋子类型之间的行为关系。第一个角色是一个例外, 它将包含有关 Chess::Square 中没有棋子的行为。我们在这里的类型类似于一个多重分派例程。事实上, 我们确实有多重分派, 只是发生在类型级别。</p>
</div>
<div class="paragraph">
<p>类似于类的 <strong>$?CLASS</strong> 和 <strong>::?CLASS</strong> 符号, 我们有 <strong>$?ROLLE</strong> 和 <strong>::?ROLLE</strong> 符号, 我们可以用来引用外部角色类型。角色除了参数化之外, 如果没有类在某个地方的帮助, 就不能做太多的事情, 所以我们最后还是会得到 <strong>$?CLASS</strong> 和 <strong>::?CLASS</strong> 符号。在角色的上下文中, 这些都是通用类型, 可以由任何一个类来填充, 它最终会被混入其中。</p>
</div>
<div class="paragraph">
<p>作为混入类型, 角色的方法和属性并不真正属于角色本身, 而是属于它最终被混入的类。然而, Chess::Piece 是一个比较少见的情况, 我们实际上没有任何类可以将类型混入其中。这没关系, 因为角色是可以被惩罚的。默认情况下, 当我们试图在角色上调用 <strong>new</strong> 这样的方法时, 并不是对角色本身进行调用, 而是通过将角色混入一个空类而产生的双关。这种行为使得角色在大多数情况下可以像类一样使用。</p>
</div>
<div class="paragraph">
<p>和 Chess::Piece 一样, Chess::Square 的行为将以可预测的方式取决于它的颜色, 所以我们也有一个类型参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">role Chess::Square[White] {
    has Chess::Piece:_ $.piece is rw = Chess::Piece.^pun;

    method colour(::?CLASS:_: --&gt; White) { }
}
role Chess::Square[Black] {
    has Chess::Piece:_ $.piece is rw = Chess::Piece.^pun;

    method colour(::?CLASS:_: --&gt; Black) { }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将方块的默认棋子改为 Chess::Piece 的双关语, 因为 Chess::Piece 指的是整个角色组, 而不是我们这里所说的单个双关语。</p>
</div>
</div>
<div class="sect2">
<h3 id="_再来一次总结">79.40. 再来一次总结</h3>
<div class="paragraph">
<p>我们的类型已经整理好了, 现在我们可以从 Chess::Board.BUILD 设置一个棋盘了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">class Chess::Board {
    # ...

    submethod BUILD(::?CLASS:D: --&gt; Nil) {
        @!squares = |(
            (flat (Chess::Square[Black].new, Chess::Square[White].new) xx 4),
            (flat (Chess::Square[White].new, Chess::Square[Black].new) xx 4),
        ) xx 4;

        @!squares[0;0].piece  = Chess::Piece[White, Rook].new;
        @!squares[0;1].piece  = Chess::Piece[White, Knight].new;
        @!squares[0;2].piece  = Chess::Piece[White, Bishop].new;
        @!squares[0;3].piece  = Chess::Piece[White, Queen].new;
        @!squares[0;4].piece  = Chess::Piece[White, King].new;
        @!squares[0;5].piece  = Chess::Piece[White, Bishop].new;
        @!squares[0;6].piece  = Chess::Piece[White, Knight].new;
        @!squares[0;7].piece  = Chess::Piece[White, Rook].new;
        @!squares[1;$_].piece = Chess::Piece[White, Pawn].new for ^8;

        @!squares[6;$_].piece = Chess::Piece[Black, Pawn].new for ^8;
        @!squares[7;0].piece  = Chess::Piece[Black, Rook].new;
        @!squares[7;1].piece  = Chess::Piece[Black, Knight].new;
        @!squares[7;2].piece  = Chess::Piece[Black, Bishop].new;
        @!squares[7;3].piece  = Chess::Piece[Black, King].new;
        @!squares[7;4].piece  = Chess::Piece[Black, Queen].new;
        @!squares[7;5].piece  = Chess::Piece[Black, Bishop].new;
        @!squares[7;6].piece  = Chess::Piece[Black, Knight].new;
        @!squares[7;7].piece  = Chess::Piece[Black, Rook].new;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这时, 如果我们能看到我们在做什么就好了。我们将在相关类型中为 <strong>gist</strong> 方法定义 dispatchees, 从 Chess::Piece 开始。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">role Chess::Piece {
    multi method gist(::?CLASS:U: --&gt; &#39; &#39;) { }
}
role Chess::Piece[White, Pawn] {
    # ...

    multi method gist(::?CLASS:D: --&gt; &#39;♙&#39;) { }
}
role Chess::Piece[Black, Pawn] {
    # ...

    multi method gist(::?CLASS:D: --&gt; &#39;♟︎&#39;) { }
}
role Chess::Piece[Chess::Colour:D $colour, Bishop] {
    # ...

    multi method gist(::?CLASS:D: --&gt; Str:D) {
        my constant %BISHOPS = :{ (White) =&gt; &#39;♗&#39;, (Black) =&gt; &#39;♝&#39; };
        %BISHOPS{$colour}
    }
}
role Chess::Piece[Chess::Colour:D $colour, Rook] {
    # ...

    multi method gist(::?CLASS:D: --&gt; Str:D) {
        my constant %ROOKS = :{ (White) =&gt; &#39;♖&#39;, (Black) =&gt; &#39;♜&#39; };
        %ROOKS{$colour}
    }
}
role Chess::Piece[Chess::Colour:D $colour, Knight] {
    # ...

    multi method gist(::?CLASS:D: --&gt; Str:D) {
        my constant %KNIGHTS = :{ (White) =&gt; &#39;♘&#39;, (Black) =&gt; &#39;♞&#39; };
        %KNIGHTS{$colour}
    }
}
role Chess::Piece[Chess::Colour:D $colour, Queen] {
    # ...

    multi method gist(::?CLASS:D: --&gt; Str:D) {
        my constant %QUEENS = :{ (White) =&gt; &#39;♕&#39;, (Black) =&gt; &#39;♛&#39; };
        %QUEENS{$colour}
    }
}
role Chess::Piece[Chess::Colour:D $colour, King] {
    # ...

    multi method gist(::?CLASS:D: --&gt; Str:D) {
        my constant %KINGS = :{ (White) =&gt; &#39;♔&#39;, (Black) =&gt; &#39;♚&#39; };
        %KINGS{$colour}
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Chess::Square 可以用彩色的括号将其棋子的 gist 包裹起来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">role Chess::Square[White] {
    # ...

    multi method gist(::?CLASS:D: --&gt; Str:D) {
        &#34;\e[37m[\e[m$!piece.gist()\e[37m]\e[m&#34;
    }
}
role Chess::Square[Black] {
    # ...

    multi method gist(::?CLASS:D: --&gt; Str:D) {
        &#34;\e[30m[\e[m$!piece.gist()\e[30m]\e[m&#34;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而 Chess::Board 可以把这些粘合在一起:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">class Chess::Board {
    # ...

    multi method gist(::?CLASS:D: --&gt; Str:D) {
        @!squares.rotor(8).reverse.map(*».gist.join).join($?NL)
    }
}

my Chess::Board:D $board .= new;
say $board;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们可以看到一些结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">bastille% raku chess.raku
[♜][♞][♝][♚][♛][♝][♞][♜]
[♟︎][♟︎][♟︎][♟︎][♟︎][♟︎][♟︎][♟︎]
[ ][ ][ ][ ][ ][ ][ ][ ]
[ ][ ][ ][ ][ ][ ][ ][ ]
[ ][ ][ ][ ][ ][ ][ ][ ]
[ ][ ][ ][ ][ ][ ][ ][ ]
[♙][♙][♙][♙][♙][♙][♙][♙]
[♖][♘][♗][♕][♔][♗][♘][♖]</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在让我们来使用 Chess::Position。我们将给它一个显式的 <strong>new</strong> 方法, 让它更容易使用, 并给它一个 <strong>gist</strong> 候选, 以棋手能读懂的方式表达它的输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">class Chess::Position {
    # ...

    method new(::?CLASS:_: Int:D $rank, Int:D $file --&gt; ::?CLASS:D) {
        self.bless: :$rank, :$file
    }

    multi method gist(::?CLASS:D: --&gt; Str:D) {
        my constant @RANKS = &lt;a b c d e f g h&gt;;
        @RANKS[$!rank] ~ $!file + 1
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们返回一个选手所有可能的移动的偏移列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">role Chess::Piece[Chess::Colour:D $colour, Knight] {
    # ...

    method moves(::?CLASS:D: --&gt; Seq:D) {
        gather {
            take slip (-2, 2) X (-1, 1);
            take slip (-1, 1) X (-2, 2);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们可以在 Chess::Board 中借助 <a href="https://docs.raku.org/language/operators#index-entry-feed">feed 运算符</a>和 v6.e 的 <code>||</code> 前缀运算符来 grep 这些有效的棋步。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">use v6.e.PREVIEW;

class Chess::Board {
    # ...

    method moves(::?CLASS:D: Chess::Index $rank, Chess::Index $file --&gt; Seq:D) {
        gather with @!squares[$rank;$file].piece -&gt; Chess::Piece:D $piece {
            $piece.moves
        ==&gt; map({ $rank + .[0], $file + .[1] })
        ==&gt; grep((Chess::Index, Chess::Index))
        ==&gt; grep({ not .?colour ~~ $piece.colour given @!squares[||$_].piece })
        ==&gt; map({ Chess::Position.new: |$_ })
        ==&gt; slip()
        ==&gt; take()
        }
    }
}

my Chess::Board:D $board .= new;
say $board.moves: 0, 1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们可以看看在 a2 的白马在第一回合可以做出什么动作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">bastille% raku chess.raku
(c1 c3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>结合多重分派, Raku 的<a href="https://docs.raku.org/language/typesystem">类型系统</a>让我们可以把一个问题像棋局一样, 分割成更小、更容易管理的组件, 从而更容易进行测试。运行时异常通常可以用类型检查异常来表示, 如果明确地表示, 类型可以使我们更容易提前发现 bug。虽然它们不会在棋牌中发挥作用, 但在这一点上, 你应该对 Raku 中的类型如何工作有足够的了解, 从而能够利用<a href="https://docs.raku.org/type/Signature#Type_captures">泛型</a>和<a href="https://vrurg.github.io/2020/11/16/Report-On-New-Coercions">类型强制转换</a>。
== <a href="https://raku-advent.blog/2020/12/20/day-20-a-raku-in-the-wild/">第二十天 - 野外的 Raku</a></p>
</div>
<div class="paragraph">
<p>很久以前, 圣诞老人收到了一个名为 <a href="https://www.agrammon.ch/en">AGRAMMON</a> 的网络应用程序的功能请求, 这个程序是由他的一个分包商 <a href="https://www.oetiker.ch/">Oetiker+Partner AG</a> 的精灵们用当时的 Perl 5 开发的。当圣诞老人要求<a href="https://www.oetiker.ch/en/company/team/fz">负责这个应用程序的小精灵</a>开始工作时, 小精灵建议进行一些重构, 因为这个应用程序已经有近10年的历史了, 并且经常被扩展。</p>
</div>
<div class="paragraph">
<p>由于前一年的圣诞奇迹, 即 <a href="https://perl6advent.wordpress.com/2015/12/">Perl 6c</a> 的发布, 小精灵建议, 与其在网页应用的 Perl 后台添加另一个功能, 不如用 Perl 6 重写是一个大胆而恰当的举措。原因是, 这个应用程序使用了一种特别开发的格式来描述它的功能, 而非程序员。小精灵认为, 还有什么比 Perl 6 的 grammar 更好的重写解析器的选择呢？果然, 新的 AGRAMMON 将会是第 6 版。</p>
</div>
<div class="paragraph">
<p>当圣诞老人问什么时候能完成重写工作时, 小精灵的回答是&#34;圣诞节前&#34;。而在 Perl 6 的土地上, 当重写终于要投入生产时, 后台已经用 Raku 实现了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_agrammon">79.41. AGRAMMON</h3>
<div class="paragraph">
<p>如今, 大多数人都知道农业对气候的负面影响, 即甲烷和一氧化二氮(强温室气体)的排放和森林砍伐。鲜为人知但也是重要的环境问题是氨（NH3）和一氧化二氮（NOx）的排放。对于农业生产来说, NH3 是主要的气态污染物, 而 NOx 则是次要的。</p>
</div>
<div class="paragraph">
<p>这些排放物的主要来源是农场动物的排泄物, 主要来自牛、猪和家禽。液态和固态粪便都含有氮化合物, 如尿素。当这些排泄物沉积在农场表面, 随后储存在粪便仓库, 以及作为肥料施用于田间时, 这些化合物会发生分解。</p>
</div>
<div class="paragraph">
<p>除了对环境造成负面影响外, 这些排放物还会造成粪便中氮(N)的大量损失, 要么导致农场生产力下降, 要么必须用矿物质肥料来补偿损失, 而这对农民来说是额外的成本。仅在瑞士, 每年就损失了约4万吨氮, 约占粪便中氮含量的30%。</p>
</div>
<div class="paragraph">
<p>为了解决这些问题, 人们研究了氨挥发的过程, 制定了减排方案, 并尽可能在受控条件下测量效果。然而, 由于控制条件难以在农场规模实施, 减排措施的效果以及排放总量可以通过模型计算进行模拟。AGRAMMON 是一个工具, 可以促进单个农场规模的模拟。这种计算也可以通过模拟&#34;典型农场类型&#34;, 使用平均工艺类型和累积的动物数量、储存设施和施肥量, 在区域范围内进行。下图为模型模拟的过程。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/zaucker/agrammon/raw/Advent/Advent2020/N-model.jpg" class="bare">https://github.com/zaucker/agrammon/raw/Advent/Advent2020/N-model.jpg</a></p>
</div>
<div class="paragraph">
<p>Agrammon 模型根据 N-flux（质量流模型）计算氨损失。对于住房/堆场、粪库、施肥和其他来源的阶段, 损失是通过使用排放率作为系统中总氨氮（TAN）的比例来计算的。对于浆料库, 采用每平方米浆料库表面积的排放率。重要的生产变量, 如饲料、外壳系统、浆料库的覆盖物或减排应用系统, 作为修正系数被考虑到排放率中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_应用程序">79.42. 应用程序</h3>
<div class="paragraph">
<p>AGRAMMON 是一个典型的网络应用, 数据存储在 PostgreSQL 数据库中, 网络前端使用 <a href="https://qooxdoo.org/">Qooxdoo</a> 框架的 JavaScript 实现, 后端使用 Raku。物理和化学过程不是直接在后台实现的, 而是如前所述用一种非程序员友好的自定义&#34;语言&#34;, 描述（用户）输入、模型参数、计算和输出（结果）。</p>
</div>
<div class="paragraph">
<p>每个过程被分解成更小的子过程, 每个子过程都在自己的文件中描述, 包括文档和对适当科学来源的引用。下面是这样一个文件的小例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">*** general ***

author   = Agrammon Group
date     = 2008-03-30
taxonomy = Livestock::DairyCow::Excretion

+short

Computes the annual N excretion of a number of dairy cows as a function of the
milk yield and the feed ration.

+description</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个过程计算了一些奶牛的年N排泄量（总氮和 Nsol（尿素加上测得的总氨氮））, 作为牛奶产量和供应的饲料日粮的函数。氮吸收量增加所产生的氮盈余主要以 Nsol 的形式在尿液中排出。因此, 增加的氮排泄量的80%被添加到 Nsol 部分。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">*** input parameters ***

+dairy_cows
  type        = integer
  validator = ge(0)
  ++labels
       en = Number of animals
       de = Anzahl Tiere
       fr   = Nombre d&#39;animaux
  ++units
      en = -
  ++description
       Number of dairy cows in barn.
  ++help
      +++en
          &lt;p&gt;Actual number of animals
                in the barn.&lt;/p&gt;
        +++de  ...
        +++fr    ...

*** technical parameters ***

+standard_N_excretion
   value = 115
  ++units
      en = kg N/year
      de = kg N/Jahr
      fr   = kg N/an
  ++description
    Annual standard N excretion for a
    dairy cow according to
    Flisch et al. (2009).

*** external ***

+Excretion::CMilk
+Excretion::CFeed

*** output ***
+n_excretion
  print = 7

  ++units
      en = kg N/year
      de = kg N/Jahr
      fr   = kg N/an

  ++formula
        Tech(standard_N_excretion)
      * Val(cmilk_yield,    Excretion::CMilk)
      * Val(c_feed_ration,Excretion::CFeed)
      * In(dairy_cows);

  ++description
      Annual total N excreted by a specified
      number of animals.</code></pre>
</div>
</div>
<div class="paragraph">
<p>在当前版本的 AGRAMMON 模型中, 有133个这样的模型文件, 31,014 行。从这些文件中, 后端可以生成</p>
</div>
<div class="ulist">
<ul>
<li>
<p>模型的PDF文档（允许在文件中使用 <a href="https://www.latex-project.org/">LaTeX</a> 格式）。</p>
</li>
<li>
<p>使用用户的输入数据进行实际的模型模拟。</p>
</li>
<li>
<p>前端可以渲染的 Web GUI 的描述。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>结果以表格形式在网络GUI中显示（显示数据的各种子集, 这些子集也可以在模型文件中定义）。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/zaucker/agrammon/raw/Advent/Advent2020/inputs.png" class="bare">https://github.com/zaucker/agrammon/raw/Advent/Advent2020/inputs.png</a></p>
</div>
<div class="paragraph">
<p>并可将用户提供的实际输入数据导出为 <a href="https://github.com/zaucker/agrammon/blob/Advent/Advent2020/TestSingle6.pdf">PDF 报告</a>或 <a href="https://github.com/zaucker/agrammon/blob/Advent/Advent2020/TestSingle6.xlsx">Excel 文件</a>。</p>
</div>
<div class="paragraph">
<p>AGRAMMON 的一个特殊实例被一个<a href="https://lawa.lu.ch/">地区政府机构</a>用于评估当地农场改造对环境的影响和批准各自的建筑申请。为此, 计划中的改造前后的氨气排放必须由申请人模拟, 并且可以直接提交到该机构的 AGRAMMON 账户, 包括通过电子邮件通知该机构并附上 PDF 报告。</p>
</div>
</div>
<div class="sect2">
<h3 id="_raku_后端">79.43. Raku 后端</h3>
<div class="paragraph">
<p>到目前为止, 重构后的后台由59个 .pm6 <a href="https://docs.raku.org/language/modules">模块/包</a>组成, 共6,942行, 并由38个.t文件中的5,854行测试所覆盖。它使用了 <a href="https://docs.raku.org/language/modules#index-entry-META6.json-META6.json">META6.json</a> 文件下面摘录的13个Raku模块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">&#34;depends&#34;: [
  &#34;Cro::HTTP&#34;,
  &#34;Cro::HTTP::Session::Pg&#34;,
  &#34;Cro::OpenAPI::RoutesFromDefinition&#34;,
  &#34;Cro::WebApp::Template&#34;,
  &#34;DB::Pg&#34;,
  &#34;Digest::SHA1::Native&#34;,
  &#34;Email::MIME&#34;,
  &#34;LibXML:ver&lt;0.5.10&gt;&#34;,
  &#34;Net::SMTP::Client::Async&#34;,
  &#34;OO::Monitors&#34;,
  &#34;Spreadsheet::XLSX:ver&lt;0.2.1+&gt;&#34;,
  &#34;Text::CSV&#34;,
  &#34;YAMLish&#34;
],
&#34;build-depends&#34;: [],
&#34;test-depends&#34;: [
  &#34;App::Prove6&#34;,
  &#34;Cro::HTTP::Test&#34;,
  &#34;Test::Mock&#34;,
  &#34;Test::NoTabs&#34;
],</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些模块可以在 <a href="https://modules.raku.org/">Raku 模块目录</a>中找到。请注意, <a href="https://github.com/jnthn/spreadsheet-xlsx">Spreadsheet::XLSX</a> 是专门为这个项目实现的。作为一个副作用, 就在昨天, 我们的专家小精灵（见下图）提交了一个关于 Spreadsheet::XLSX 中使用的 <a href="https://github.com/libxml-raku/LibXML-raku">LibXML</a> 的 <a href="https://github.com/libxml-raku/LibXML-raku/pull/49">pull 请求</a>, 导致了2倍的性能提升。</p>
</div>
<div class="paragraph">
<p>说到实际的实现, 虽然我们勇敢的小精灵在 grammar、解析器、甚至 Perl 6 / Raku方面都没有太多经验, 但他还是很聪明地请了一个真正的<a href="https://www.edument.se/en/page/jonathan-worthington-eng">专家小精灵</a>来做这件事。这个小精灵完成了后台实现的大部分重任, 并帮助我们的小精灵提供建议, 并对他自己实现的部分进行代码审查。</p>
</div>
<div class="paragraph">
<p>请注意, 这次重写的目标是将模型实现的大部分语法和前台保持原样, 所以所有次优的设计决定的责任完全在我们的主要小精灵身上, 同时也要为不完美的实现细节负责。</p>
</div>
</div>
<div class="sect2">
<h3 id="_agrammon_中使用的一些_raku_功能">79.44. AGRAMMON 中使用的一些 Raku 功能</h3>
<div class="paragraph">
<p>在本节中, 我们将介绍 AGRAMMON 中使用的一些 Raku 特性。这并不是为了给专家们提供一个硬核的技术解释, 而是作为一种手段来给对 Raku 感兴趣的人提供一种体验。</p>
</div>
<div class="paragraph">
<p>大多数的代码例子都是直接从当前的实现中提取的, 有时例子会略微缩短, 留下与概念无关的代码。GitHub 上有许多原始模块的链接。由于 AGRAMMON 仍在开发中, 这些链接可能指向模块的最新版本。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/oposs/agrammon/blob/master/bin/agrammon.pl6">bin/agrammon.pl6</a></p>
</div>
<div class="paragraph">
<p>实际 AGRAMMON 的&#34;可执行文件&#34;只有三行字（其中只有两行是 Raku）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">#!/usr/bin/env raku
use lib &#34;lib&#34;
use Agrammon::UI::CommandLine;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就利用了 Rakudo(这里使用的 Raku 实现)有一个非常好的<a href="https://docs.raku.org/language/faq#index-entry-Precompile_(FAQ)">预编译</a>功能, 它对于在程序第一次运行后最大限度地减少(仍然不可忽视的)启动时间非常有用。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/oposs/agrammon/blob/master/lib/Agrammon/UI/CommandLine.pm6">Agrammon::UI::CommandLine</a></p>
</div>
<div class="paragraph">
<p>这个模块包含了 AGRAMMON 应用程序的主要功能, 可以在命令行中使用。</p>
</div>
<div class="paragraph">
<p><strong>使用方法</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">Running ./bin/agrammon.pl6 gives the following output:

Usage:
  ./bin/agrammon.pl6 web &lt;cfg-filename&gt; &lt;model-filename&gt; [&lt;technical-file&gt;] -- Start the web interface
  ./bin/agrammon.pl6 [--language=&lt;SupportedLanguage&gt;] [--prints=&lt;Str&gt;] [--variants=&lt;Str&gt;] [--include-filters] [--include-all-filters] [--batch=&lt;Int&gt;] [--degree=&lt;Int&gt;] [--max-runs=&lt;Int&gt;] [--format=&lt;OutputFormat&gt;] run &lt;filename&gt; &lt;input&gt; [&lt;technical-file&gt;] -- Run the model
  ./bin/agrammon.pl6 [--variants=&lt;Str&gt;] [--sort=&lt;SortOrder&gt;] dump &lt;filename&gt; -- Dump model
  ./bin/agrammon.pl6 [--variants=&lt;Str&gt;] [--sort=&lt;SortOrder&gt;] latex &lt;filename&gt; [&lt;technical-file&gt;]
  ./bin/agrammon.pl6 create-user &lt;username&gt; &lt;firstname&gt; &lt;lastname&gt; -- Create Agrammon user

    &lt;cfg-filename&gt;        configuration file
    &lt;model-filename&gt;      top-level model file
    [&lt;technical-file&gt;]    optionally override model parameters from this file

See https://www.agrammon.ch for more information about Agrammon.</code></pre>
</div>
</div>
<div class="paragraph">
<p>该使用信息是由 <a href="https://docs.raku.org/language/functions#Multi-dispatch">multi</a> 子程序 <a href="https://docs.raku.org/routine/MAIN">MAIN</a> 实例的实现自动创建的, 如第一行所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">subset ExistingFile of Str where { .IO.e or note(&#34;No such file $_&#34;) &amp;&amp; exit 1 }

#| Start the web interface
multi sub MAIN(
        &#39;web&#39;,
        ExistingFile $cfg-filename,   #= configuration file
        ExistingFile $model-filename, #= top-level model file
        ExistingFile $technical-file? #= override model parameters from this file
    ) is export {
    my $http = web($cfg-filename, $model-filename, $technical-file);
    react {
        whenever signal(SIGINT) {
            say &#34;Shutting down...&#34;;
            $http.stop;
            done;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, 参数 $technical-file 被尾部的 ? 标记为可选, 因此使用信息也用 [ ] 括起来将该参数标记为可选。</p>
</div>
<div class="paragraph">
<p>上述代码示例中的第一行定义了一个数据<a href="https://docs.raku.org/language/typesystem">类型</a>为 Str 的 <a href="https://docs.raku.org/language/typesystem#index-entry-subset-subset">subset</a> ExistingFile, 即那些引用本地现有文件的字符串。如果用非存在文件的文件名 foo.cfg 调用, 程序会以 No such file foo.cfg 的消息中止。</p>
</div>
<div class="paragraph">
<p>使用信息中还显示了命令行中对:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从命令行（运行）以批处理模式运行模型。</p>
</li>
<li>
<p>通过转储模型结构来显示模拟流程。</p>
</li>
<li>
<p>生成模型文档（latex）；</p>
</li>
<li>
<p>和为网络应用创建用户账户（create-user）。</p>
</li>
<li>
<p>并在最后列出那些在上面所示的 sub MAIN 源中有注释&#34;附加&#34;的参数。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>sub web()</strong></p>
</div>
<div class="paragraph">
<p>这个<a href="https://docs.raku.org/language/functions">子例程</a>被调用来启动 Web 服务, 如上面使用消息的第一行所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">sub web(Str $cfg-filename, Str $model-filename, Str $technical-file?) is export {

    # initialization
    # ...

    my $model = timed &#34;Load model from $module-path/$module.nhd&#34;, {
        load-model-using-cache($*HOME.add(&#39;.agrammon&#39;), $module-path, $module, preprocessor-options($variants));
    }

    my $db = DB::Pg.new(conninfo =&gt; $cfg.db-conninfo);
    PROCESS::&lt;$AGRAMMON-DB-CONNECTION&gt; = $db;

    my $ws = Agrammon::Web::Service.new(:$cfg, :$model, :%technical-parameters);

    # setup and start web server
    my $host = %*ENV&lt;AGRAMMON_HOST&gt; || &#39;0.0.0.0&#39;;
    my $port = %*ENV&lt;AGRAMMON_PORT&gt; || 20000;
    my Cro::Service $http = Cro::HTTP::Server.new(
        :$host, :$port,
        application =&gt; routes($ws),
        after =&gt; [
            Cro::HTTP::Log::File.new(logs =&gt; $*OUT, errors =&gt; $*ERR)
        ],
        before =&gt; [
            Agrammon::Web::SessionStore.new(:$db)
        ]
    );
    $http.start;
    say &#34;Listening at http://$host:$port&#34;;
    return $http;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该<a href="https://docs.raku.org/language/functions">子程序</a>使用一个<a href="https://docs.raku.org/type/Signature">签名</a>来描述它的参数（所有的参数都是 <a href="https://docs.raku.org/type/Str">Str 类型</a>, 第三个参数又被后面的 ? 标记为可选的。</p>
</div>
<div class="paragraph">
<p><strong>sub run()</strong></p>
</div>
<div class="paragraph">
<p>AGRAMMON 应用程序也可以通过从 <a href="https://tools.ietf.org/html/rfc4180">CSV</a> 文件中提供输入数据直接从命令行使用。这种模式被科学家用来自动运行大量的区域和国家预测的模拟。计划在将来通过 <a href="https://tools.ietf.org/html/rfc6690">REST</a> API 调用来提供这种模式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">sub run (IO::Path $path, IO::Path $input-path, $technical-file, $variants, $format, $language, $prints,
         Bool $include-filters, $batch, $degree, $max-runs, :$all-filters) is export {

    # initialization
    # ...

    my $rc = Agrammon::ResultCollector.new;
    my atomicint $n = 0;
    my class X::EarlyFinish is Exception {}
    race for $ds.read($fh).race(:$batch, :$degree) -&gt; $dataset {
        my $my-n = ++⚛$n;

        my $outputs = timed &#34;$my-n: Run $filename&#34;, {
            $model.run(
                input     =&gt; $dataset,
                technical =&gt; %technical-parameters,
            );
        }
        # create output
        # ...
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, 我们使用 Raku 的各种<a href="https://docs.raku.org/language/concurrency">并发特性</a>之一 - <a href="https://docs.raku.org/routine/race">race</a>, 使用多个线程并行运行实际模型仿真, 以加快执行速度。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/functions">函数</a>的<a href="https://docs.raku.org/type/Signature">签名</a>再次指定了一些参数的类型。除了（太多）位置参数外, :$all-filterers 是一个默认的可选<a href="https://docs.raku.org/language/functions#Arguments">命名参数</a>。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/oposs/agrammon/blob/master/lib/Agrammon/Web/Routes.pm6">Agrammon::Web::Routes</a></p>
</div>
<div class="paragraph">
<p>虽然上面已经展示了 web 服务的启动, 但这里我们看到了一个使用 <a href="https://www.edument.se/en">Edument</a> 的 <a href="https://cro.services/">Cro 服务</a>中的 <a href="https://cro.services/docs/reference/cro-http-router">Cro::HTTP::Router</a> 设置 AGRAMMON 的 REST 接口路由的例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">use Cro::HTTP::Router;
use Cro::OpenAPI::RoutesFromDefinition;
use Agrammon::Web::Service;
use Agrammon::Web::SessionUser;

subset LoggedIn of Agrammon::Web::SessionUser where .logged-in;

sub routes(Agrammon::Web::Service $ws) is export {
    my $schema = &#39;share/agrammon.openapi&#39;;
    my $root = &#39;&#39;;
    route {
        include static-content($root);
        include api-routes($schema, $ws);

        ...

        after {
            forbidden if .status == 401 &amp;&amp; request.auth.logged-in;
            .status = 401 if .status == 418;
        }
    }
}

sub static-content($root) {
    route {
        get -&gt; {
            static $root ~ &#39;public/index.html&#39;
        }

        ...
    }
}

sub api-routes (Str $schema, $ws) {
    openapi $schema.IO, {
        # working
        operation &#39;createAccount&#39;, -&gt; LoggedIn $user {
            request-body -&gt; (:$email!, :$password!, :$key, :$firstname, :$lastname, :$org, :$role) {
                my $username = $ws.create-account($user, $email, $password, $key, $firstname, $lastname, $org, $role);
                content &#39;application/json&#39;, { :$username };
                CATCH {
                    note &#34;$_&#34;;
                    when X::Agrammon::DB::User::CreateFailed  {
                        not-found &#39;application/json&#39;, %( error =&gt; .message );
                    }
                    when X::Agrammon::DB::User::AlreadyExists
                       | X::Agrammon::DB::User::CreateFailed  {
                        conflict &#39;application/json&#39;, %( error =&gt; .message );
                    }
                }
            }
        }

    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>后者使用的是（简略的）<a href="https://swagger.io/specification/">OpenAPI</a> 定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">openapi: 3.0.0
info:
    version: 1.0.0,
    title: OpenApi Agrammon,
paths:
    /create_account:
        post:
            summary: Create new user account
            operationId: createAccount
            requestBody:
                required: true
                content:
                    application/json:
                        schema:
                            type: object
                            required:
                                - email
                                - password
                            properties:
                                email:
                                    description: User&#39;s email used as username
                                    type: string
                                firstname:
                                    description: Firstname
                                    type: string
                                lastname:
                                    description: Lastname
                                    type: string
              responses:
                &#39;200&#39;:
                    description: Account created.
                    content:
                        application/json:
                            schema:
                                type: object
                                required:
                                    - username
                                properties:
                                    username:
                                        type: string
                &#39;404&#39;:
                    description: Couldn&#39;t create account
                    content:
                        application/json:
                            schema:
                                $ref: &#34;#/components/schemas/CreationFailed&#34;
                &#39;409&#39;:
                    description: User already exists
                    content:
                        application/json:
                            schema:
                                $ref: &#34;#/components/schemas/Error&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>由 <a href="https://modules.raku.org/dist/Cro::OpenAPI::RoutesFromDefinition">Cro::OpenAPI::RoutesFromDefinition</a> 处理。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/oposs/agrammon/blob/master/lib/Agrammon/OutputFormatter/PDF.pm6">Agrammon::OutputFormatter::PDF</a></p>
</div>
<div class="paragraph">
<p>为了记录 AGRAMMON 的计算结果, 可以通过使用 <a href="https://github.com/croservices/cro-webapp">Cro::WebApp::Template</a> 模块首先创建一个 LaTeX 文件来创建模型输入和模拟结果的 PDF 报告。虽然是为生成 HTML 页面而量身定做的, 但对于我们的目的来说, 它的效果相当好。该模块确实对适合 HTML 的输入数据进行了转义, 但是, 在模块外实现了对 LaTeX 中具有特殊意义的字符进行简单的转义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">sub latex-escape(Str $in) is export {
    my $out = $in // &#39;&#39;;
    $out ~~ s:g/&lt;[\\]&gt;/\\backslash/;
    $out ~~ s:g/(&lt;[%#{}&amp;$|]&gt;)/\\$0/;
    $out ~~ s:g/(&lt;[~^]&gt;)/\\$0\{\}/;
    # this is a special case for Agrammon as we use __ in
    # the frontend at the moment for indentation in the table
    $out ~~ s:g/__/\\hspace\{2em\}/;
    $out ~~ s:g/_/\\_/;
    return $out;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个额外的功能是用来美化化学分子式的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">sub latex-chemify(Str $in) is export {
    my $out = $in // &#39;&#39;;
    $out ~~ s:g/NOx/\\ce\{NO_\{\(x\)\}\}/;
    $out ~~ s:g/(N2O|NH3|N2|NO2)/\\ce\{$0\}/;
    return $out;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些函数使用简单的<a href="https://docs.raku.org/language/regexes">正则表达式</a>替换。更通用的 LaTeX 特殊字符的处理需要将类似 <a href="https://metacpan.org/pod/LaTeX::Encode">LaTeX::Encode</a> Perl 模块的东西移植到 Raku。另外, <a href="https://github.com/niner/Inline-Perl5">Inline::Perl5</a> 也可以用来利用 Perl 模块。</p>
</div>
<div class="paragraph">
<p>这个代码片段显示了 <a href="https://www.latex-project.org/">LaTeX</a> 文件是如何创建的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">%data&lt;titles&gt;    = %titles;
%data&lt;dataset&gt;   = $dataset-name // &#39;NO DATASET&#39;;
%data&lt;username&gt;  = $user.username // &#39;NO USER&#39;;
%data&lt;model&gt;     = $cfg.gui-variant // &#39;NO MODEL&#39;;
%data&lt;timestamp&gt; = ~DateTime.now( formatter =&gt; sub ($_) {
    sprintf &#39;%02d.%02d.%04d %02d:%02d:%02d&#39;,
        .day, .month, .year,.hour, .minute, .second,
});
%data&lt;version&gt;    = latex-escape($cfg.gui-title{$language} // &#39;NO  VERSION&#39;);
%data&lt;outputs&gt;    = @output-formatted;
%data&lt;inputs&gt;     = @input-formatted;
%data&lt;submission&gt; = %submission;

template-location $*PROGRAM.parent.add(&#39;../share/templates&#39;);
my $temp-dir    = $*TMPDIR.add($temp-dir-name);
my $source-file = &#34;$temp-dir/$filename.tex&#34;.IO;

my $latex-source = render-template(&#39;pdfexport.crotmp&#39;, %data);

$source-file.spurt($latex-source, %data);</code></pre>
</div>
</div>
<div class="paragraph">
<p>用 %data hash 和 pdfexport.crotmp 这样的模板文件调用 render-template。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-latex" data-lang="latex">\nonstopmode
\documentclass[10pt,a4paper]{article}

\begin{document}

\section*{&lt;.titles.report&gt;}
\section{&lt;.titles.data.section&gt;}
\begin{tabular}[t]{@{}l@{\hspace{2em}}p{7cm}}
    \textbf{&lt;.titles.data.dataset&gt;:} &amp; &lt;.dataset&gt;\\
    \textbf{&lt;.titles.data.user&gt;:} &amp; &lt;.username&gt;\\
    \textbf{Version:} &amp; &lt;.model&gt;\\
\end{tabular}

\section{&lt;.titles.outputs&gt;}
&lt;@outputs&gt;
&lt;?.section&gt;
&lt;!.first&gt;
\bottomrule
\end{tabular}
&lt;/!&gt;
\subsection{&lt;.section&gt;}
\noindent
\rowcolors{1}{LightGrey}{White}
\begin{tabular}[t]{lllrl}
\toprule
&lt;/?&gt;
&lt;!.section&gt;
&amp;  &amp; &lt;.label&gt; &amp; &lt;.value&gt; &amp; &lt;.unit&gt;\\
&lt;/!&gt;
&lt;/@&gt;
\bottomrule
\end{tabular}
\end{document}</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为参数。然后使用 <a href="https://docs.raku.org/routine/spurt">spurt</a> 函数将生成的 LaTeX 源代码写入文件。</p>
</div>
<div class="paragraph">
<p>如果您不熟悉 LaTeX, 上述模板可能看起来有点神秘, 但相关的部分是类似于 HTML 的标签, 如 &lt;.title.report&gt; 访问传递给 render-template 的哈希数据结构的值, &lt;@output&gt; …​ &lt;/@&gt; 是这个数据结构中被迭代的数组, 或者是条件 &lt;?.section&gt;…​&lt;/?&gt; 或 &lt;!.section&gt;…​ &lt;/!&gt;. 详情请参考 <a href="https://github.com/croservices/cro-webapp">Cro::WebApp::Template</a> 模块的文档。</p>
</div>
<div class="paragraph">
<p>然后使用外部程序 lualatex 和内置的 <a href="https://docs.raku.org/type/Proc::Async">Proc::Async</a> 类将 LaTeX 文件渲染成 PDF 文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6"># setup temp dir and files
my $temp-dir = $*TMPDIR.add($temp-dir-name);
my $source-file = &#34;$temp-dir/$filename.tex&#34;.IO;
my $pdf-file    = &#34;$temp-dir/$filename.pdf&#34;.IO;
my $log-file    = &#34;$temp-dir/$filename.log&#34;.IO;

# create PDF, discard STDOUT and STDERR (see .log file if necessary)
my $exit-code;
my $signal;
my $reason = &#39;Unknown&#39;;

my $proc = Proc::Async.new: :w, &#39;/usr/bin/lualatex&#39;,
        &#34;--output-directory=$temp-dir&#34;,  &#39;--no-shell-escape&#39;, &#39;--&#39;, $source-file, ‘-’;

react {
    # discard any output of the external program
    whenever $proc.stdout.lines {
    }
    whenever $proc.stderr {
    }
    # save exit code and signal if program was terminated
    whenever $proc.start {
        $exit-code = .exitcode;
        $signal    = .signal;
        done; # gracefully jump from the react block
    }
    # make sure we don&#39;t end up with a hung-up lualatex process
    whenever Promise.in(5) {
        $reason = &#39;Timeout&#39;;
        note ‘Timeout. Asking the process to stop’;
        $proc.kill; # sends SIGHUP, change appropriately
        whenever Promise.in(2) {
            note ‘Timeout. Forcing the process to stop’;
            $proc.kill: SIGKILL
        }
    }
}

# write appropriate error messages if program didn&#39;t terminate sucessfully
if $exit-code {
    note &#34;$pdf-prog failed for $source-file, exit-code=$exit-code&#34;;
    die X::Agrammon::OutputFormatter::PDF::Failed.new: :$exit-code;
}
if $signal {
    note &#34;$pdf-prog killed for $source-file, signal=$signal, reason=$reason&#34;;
    die X::Agrammon::OutputFormatter::PDF::Killed.new: :$reason;
}

# read content of PDF file created in binary format for further use
my $pdf = $pdf-file.slurp(:bin);
# remove created files if successful, otherwise keep for debugging
unlink $source-file, $pdf-file, $aux-file, $log-file unless %*ENV&lt;AGRAMMON_KEEP_FILES&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个带有多个 <strong>whenever</strong> 块的 <strong>react</strong> 块用于处理来自异步运行的外部程序的事件, 以避免阻塞原本已经异步的后端。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/exceptions#Typed_exceptions">带类型的异常</a>用于处理外部进程中发生的错误。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/oposs/agrammon/blob/master/lib/Agrammon/OutputFormatter/Excel.pm6">Agrammon::OutputFormatter::Excel</a></p>
</div>
<div class="paragraph">
<p>在这里, 我们使用 <a href="https://github.com/jnthn/spreadsheet-xlsx">Spreadsheet::XLSX</a> 创建模拟结果和用户输入的 Excel 导出。这个模块允许从 Raku 读取和写入 XLSX 文件。目前的功能并不完整, 但实现了 AGRAMMON 所需要的功能。请随时提供拉动请求或资金来实现额外的功能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6"># get data to be shown
my %data = collect-data();
# ...

my $workbook = Spreadsheet::XLSX.new;

# prepare sheets
my $output-sheet = $workbook.create-worksheet(&#39;Results&#39;);
my $input-sheet = $workbook.create-worksheet(&#39;Inputs&#39;);
my $timestamp = ~DateTime.now( formatter =&gt; sub ($_) {
    sprintf &#39;%02d.%02d.%04d %02d:%02d:%02d&#39;,
            .day, .month, .year, .hour, .minute, .second,
});
# add some meta data to the sheets
for ($output-sheet, $input-sheet) -&gt; $sheet {
    $sheet.set(0, 0, $dataset-name, :bold);
    $sheet.set(1, 0, $user.username);
    $sheet.set(2, 0, $model-version);
    $sheet.set(3, 0, $timestamp);
}

# set column width
for ($output-sheet, $input-sheet) -&gt; $sheet {
    $sheet.columns[0] = Spreadsheet::XLSX::Worksheet::Column.new:
            :custom-width, :width(20);
    $sheet.columns[1] = Spreadsheet::XLSX::Worksheet::Column.new:
            :custom-width, :width(32);
    $sheet.columns[2] = Spreadsheet::XLSX::Worksheet::Column.new:
            :custom-width, :width(20);
    $sheet.columns[3] = Spreadsheet::XLSX::Worksheet::Column.new:
            :custom-width, :width(10);
}

# add input data to sheets
my $row = 0;
my $col = 0;
my @records := %data&lt;inputs&gt;;
for @records -&gt; %rec {
    $input-sheet.set($row, $col+2, %rec&lt;input&gt;);
    $input-sheet.set($row, $col+3, %rec&lt;value&gt;, :number-format(&#39;#,#&#39;), :horizontal-align(RightAlign));
    $input-sheet.set($row, $col+4, %rec&lt;unit&gt;);
    $row++;
}

# add output data to sheets
# ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个例子展示了各种 <a href="https://docs.raku.org/language/101-basics">Raku 基础知识</a>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>%data, %rec 是<a href="https://docs.raku.org/language/101-basics#Hashes">哈希</a><a href="https://docs.raku.org/language/variables">变量</a>。与 Perl 相反, 在 Raku 中, 当访问变量的元素时, <a href="https://docs.raku.org/language/101-basics#Sigils_and_identifiers">sigils</a> 不会改变。</p>
</li>
<li>
<p>for ($output-sheet, $input-sheet) → $sheet { …​. } 和 for @records → %rec { …​ } 是对<a href="https://docs.raku.org/language/list">列表</a>的<a href="https://docs.raku.org/language/101-basics#for_and_blocks">循环</a>, 每个循环都使用<a href="https://docs.raku.org/language/functions#Blocks_and_lambdas">尖号块</a>语法将当前元素分配给循环<a href="https://docs.raku.org/language/variables#Variable_declarators_and_scope">作用域</a>内的一个变量。</p>
</li>
<li>
<p>my $timestamp = ~DateTime.now( formatter =&gt; sub ($_) { .... } ...) 使用内置的 <a href="https://docs.raku.org/routine/DateTime">DateTime</a> 方法创建一个时间戳, 使用 <a href="https://docs.raku.org/routine/&lt;sub&gt;">操作符</a>将其强制成一个字符串。这个字符串由未命名的<a href="https://docs.raku.org/language/functions#Defining/Creating/Using_functions">匿名子例程</a> sub ($_) { ... } 进行格式化。使用<a href="https://docs.raku.org/language/101-basics#Topic_variable">主题变量 $<em></em></a><em> 作为参数, 在这个变量上调用 DateTime <a href="https://docs.raku.org/language/classtut">类</a>的各种方法, 只需在前面加上一个 <code>.</code>。例如, <code>.year</code> 只是 <code>$</code></em><code>.year</code> 的快捷方式。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/oposs/agrammon/blob/master/lib/Agrammon/Email.pm6">Agrammon::Email</a></p>
</div>
<div class="paragraph">
<p>如上所述, 模拟的 PDF 报告可以直接从网络应用中邮寄给某些 AGRAMMON 用户。首先, 使用 <a href="https://modules.raku.org/dist/Email::MIME">Email::MIME</a> 模块创建一个<a href="https://tools.ietf.org/html/rfc1521">multi-parrt 的 MIME</a> 信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6"># create PDF attachment
my $attachment = Email::MIME.create(
    attributes =&gt; {
        &#39;content-type&#39; =&gt; &#34;application/pdf; name=$filename&#34;,
        &#39;charset&#39;      =&gt; &#39;utf-8&#39;,
        &#39;encoding&#39;     =&gt; &#39;base64&#39;,
    },
    body =&gt; $pdf,
);
# create main body part
my $msg = Email::MIME.create(
    attributes =&gt; {
        &#39;content-type&#39; =&gt; &#39;text/plain&#39;,
        &#39;charset&#39;      =&gt; &#39;utf-8&#39;,
        &#39;encoding&#39;     =&gt; &#39;quoted-printable&#39;
    },
    body-str =&gt; &#39;Attached please find a PDF report from a AGRAMMON simulation,
);
# build multi-part Email
my $from = &#39;support@agrammon.ch&#39;;
my $to   = &#39;foo@bar.com&#39;;
my $mail = Email::MIME.create(
    header-str =&gt; [
        &#39;to&#39;      =&gt; $to,
        &#39;from&#39;    =&gt; $from,
        &#39;subject&#39; =&gt; &#39;Mail from AGRAMMON&#39;
    ],
    parts =&gt; [
        $msg,
        $attachment,
    ]
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后使用基于 <a href="https://docs.raku.org/type/Promise">Promise</a> 的 <a href="https://modules.raku.org/dist/Net::SMTP::Client::Async">Net::SMTP::Client::Async</a> 模块将此消息发送给邮件的收件人。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6"># asynchronously send Email via AGRAMMON&#39;s SMTP server
with await Net::SMTP::Client::Async.connect(:host&lt;mail.agrammon.ch&gt;, :port(25), :!secure) {
    # wait for SMTP server&#39;s welcome response
    await .hello;
    # send message
    await .send-message(
        :$from,
        :to([ $to ]),
        :message(~$mail),
    );
    # terminate connection on exit
    LEAVE .quit;
    # catch exceptions and emit user friendly error message
    CATCH {
        when X::Net::SMTP::Client::Async {
            note &#34;Unable to send email message: $_&#34;;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Promise#sub_await">await</a> 函数用于处理与 <a href="https://tools.ietf.org/html/rfc5321">SMPT</a> 服务器的异步通信。<a href="https://docs.raku.org/language/phasers#index-entry-Phasers__LEAVE-LEAVE">LEAVE</a> 在退出 with await { …​ } 块来关闭与服务器的连接。</p>
</div>
<div class="paragraph">
<p><strong>Unicode 运算符</strong></p>
</div>
<div class="paragraph">
<p>我最喜欢在 AGRAMMON 中使用的代码片段展示了<a href="https://docs.raku.org/language/unicode_ascii">在 Raku 源代码中使用 Unicode 代码码点</a>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>my $my-n = ++⚛$n; 是递增一个 <a href="https://docs.raku.org/type/atomicint">atomicint</a> 类型的变量。</p>
</li>
<li>
<p>$var-print.split(&#39;,&#39;) ∩ @print-set 给出了两个集合的交集。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>虽然 Unicode 也可以用于其他目的, 例如用于数值, 如 ⅓、𝑒、π 或 τ, 或者用于变量名 my $Δ = 1;, 但它们作为运算符的使用肯定会使代码更易读（比较 ∩ 与 (&amp;) ）。</p>
</div>
<div class="paragraph">
<p>除了使用适当的数学符号外, 这种强大的<a href="https://docs.raku.org/language/operators">运算符</a>的存在本身就是 Raku 的一大特点, 并且比在其他编程语言中实现这种运算的代码要短得多。</p>
</div>
</div>
<div class="sect2">
<h3 id="_解析器和编译器">79.45. 解析器和编译器</h3>
<div class="paragraph">
<p>最后, 说一下用于处理上图所示 AGRAMMON 模型文件的解析器和编译器。<a href="https://github.com/oposs/agrammon/blob/master/lib/Agrammon/ModuleParser.pm6">Agrammon::ModuleParser</a> 是解析模型文件的顶层元素。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">use v6;
use Agrammon::CommonParser;

grammar Agrammon::ModuleParser does Agrammon::CommonParser {
    token TOP {
        :my $*TAXONOMY = &#39;&#39;;
        :my $*CUR-SECTION = &#39;&#39;;
        &lt;.blank-line&gt;*
        &lt;section&gt;+
        [
        || $
        || &lt;.panic(&#39;Confused&#39;)&gt;
        ]
    }

    proto token section { * }

    token section:sym&lt;general&gt; {
        &lt;.section-heading(&#39;general&#39;)&gt;
        [
        | &lt;option=.single-line-option&gt;
        | &lt;option=.multi-line-str-option(&#39;+&#39;)&gt;
        | &lt;.blank-line&gt;
        ]*
    }

    token section:sym&lt;external&gt; {
        &lt;.section-heading(&#39;external&#39;)&gt;
        [
        | &lt;.blank-line&gt;
        | &lt;external=.option-section&gt;
        ]*
    }

    token section:sym&lt;input&gt; {
        &lt;.section-heading(&#39;input&#39;)&gt;
        [
        | &lt;.blank-line&gt;
        | &lt;input=.option-section&gt;
        ]*
    }

    token section:sym&lt;technical&gt; {
        &lt;.section-heading(&#39;technical&#39;)&gt;
        [
        | &lt;.blank-line&gt;
        | &lt;technical=.option-section&gt;
        ]*
    }

    token section:sym&lt;output&gt; {
        &lt;.section-heading(&#39;output&#39;)&gt;
        [
        | &lt;.blank-line&gt;
        | &lt;output=.option-section&gt;
        ]*
    }

    token section:sym&lt;results&gt; {
        &lt;.section-heading(&#39;results&#39;)&gt;
        [
        | &lt;.blank-line&gt;
        | &lt;results=.option-section&gt;
        ]*
    }

    token section:sym&lt;tests&gt; {
        &lt;.section-heading(&#39;tests&#39;)&gt;
        [
        | &lt;.blank-line&gt;
        | &lt;tests=.option-section&gt;
        ]*
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它处理模型文件各部分章节的解析, 使用 <a href="https://github.com/oposs/agrammon/blob/master/lib/Agrammon/CommonParser.pm6">Agrammon::CommonParser</a> 模块的各种元素, 如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">token section-heading($title) {
    \h* &#39;***&#39; \h* $title \h* &#39;***&#39; \h* \n
    { $*CUR-SECTION = $title }
}

token option-section {
    \h* &#39;+&#39; \h* &lt;name&gt; \h* \n
    [
    | &lt;.blank-line&gt;
    | &lt;option=.single-line-option&gt;
    | &lt;option=.subsection-map&gt;
    | &lt;option=.multi-line-str-option(&#39;++&#39;)&gt;
    ]*
}

token single-line-option {
    \h* &lt;key&gt; \h* &#39;=&#39; \h*
    $&lt;value&gt;=[[&lt;!before \h*&#39;#&#39;&gt;\N]*]
    \h* [&#39;#&#39;\N*]?
    [\n || $]
}

token blank-line {
    | \h* \n
    | \h* &#39;#&#39; \N* \n
    | \h+ $
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku <a href="https://docs.raku.org/type/Grammar">grammar</a> 基本上是由<a href="https://docs.raku.org/language/regexes">正则表达式</a>自上而下构建的。这种 grammar 可以通过<a href="https://docs.raku.org/language/grammar_tutorial#Grammar_actions">动作类</a>进行扩展, 动作类可以进一步处理在解析输入 grammar 的数据时生成的<a href="https://docs.raku.org/type/Match">匹配对象</a>。</p>
</div>
<div class="paragraph">
<p>请参考<a href="https://docs.raku.org/language/grammar_tutorial">本教程</a>或其他资源来了解这些概念的更多信息。</p>
</div>
<div class="paragraph">
<p>如果你想了解更多关于（真实世界的）AGRAMMON 解析器/编译器, 你可以看看 <a href="https://github.com/oposs/agrammon/blob/master/lib/Agrammon/Formula/Parser.pm6">Agrammon::Formula::Parser</a>、<a href="https://github.com/oposs/agrammon/blob/master/lib/Agrammon/Formula/Builder.pm6">Agrammon::Formula::Builder</a>、<a href="https://github.com/oposs/agrammon/blob/master/lib/Agrammon/ModuleBuilder.pm6">Agrammon::ModuleBuilder</a>、<a href="https://github.com/oposs/agrammon/blob/master/lib/Agrammon/TechnicalParser.pm6">Agrammon::TechnicalParser</a>、<a href="https://github.com/oposs/agrammon/blob/master/lib/Agrammon/TechnicalBuilder.pm6">Agrammon::TechnicalBuilder</a> 和 <a href="https://github.com/oposs/agrammon/blob/master/lib/Agrammon/LanguageParser.pm6">Agrammon::LanguageParser</a> 模块中的其他解析器元素, 后者是一个简单的基于非 grammar 的函数。</p>
</div>
<div class="paragraph">
<p>编译器由 <a href="https://github.com/oposs/agrammon/blob/master/lib/Agrammon/Formula/Compiler.pm6">Agrammon::Formula::Compiler</a> 和 <a href="https://github.com/oposs/agrammon/blob/master/lib/Agrammon/Formula/Builtins.pm6">Agrammon::Formula::Builtins</a> 组成。</p>
</div>
<div class="paragraph">
<p>最后, 作为最近的新增功能, AGRAMMON 还在 <a href="https://github.com/oposs/agrammon/blob/master/lib/Agrammon/Preprocessor.pm6">Agrammon::Preprocessor</a> 中得到了一个 C 风格的预处理器, 用于有条件地包含或排除模型的部分, 使用的语法如下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">?if FOO
...
?elsif BAR
...
?else
...
?endif</code></pre>
</div>
</div>
<div class="paragraph">
<p>和可选的 <code>?elsif</code> 和 <code>?else</code> 部分。关键字也可以被否定, 比如 <code>?if !FOO</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_那么_哪个圣诞节">79.46. 那么, 哪个圣诞节？</h3>
<div class="paragraph">
<p>好吧, 正如你在 <a href="https://act.perl-workshop.ch/spw2018/">2018 年瑞士Perl研讨会</a>上的这个<a href="https://github.com/zaucker/agrammon/blob/Advent/Advent2020/swp2018.pdf">演讲</a>中所看到的那样, 最初的计划并没有完全实现, 主要是因为另一个项目被赋予了更高的优先级（这是一个非常糟糕的决定, 但这是另一个很长的故事）。</p>
</div>
<div class="paragraph">
<p>我们曾希望在本文出现之前, AGRAMMON 6 就能部署并投入生产, 并且几乎成功了。所有的关键功能都已经到位, 还需要一点点的打磨。对于我们勇敢的小精灵来说, 最大的欣慰之一是, 用 Perl 和 Raku 后端使用相同的模型和输入值进行的测试计算得到了相同的结果。由于这些实现不仅是用两种不同的语言完成的, 而且是由不同的程序员用完全不同的架构完成的, 这让我们对它们的正确性产生了很大的信任。</p>
</div>
<div class="paragraph">
<p>此外, 客户已经对模型文件进行了相当广泛的重构, 目前正在验证模型计算和基于 Raku 的网络应用的功能。</p>
</div>
<div class="paragraph">
<p>目前的设置已经作为<a href="https://model.agrammon.ch/single/test">演示/测试版本</a>上线, 欢迎大家试用。我们预计 Raku 的实现将在 2021 年初最终投入生产, 并取代目前的 <a href="https://model.agrammon.ch/single">Perl 实现</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结束语_7">79.47. 结束语</h3>
<div class="paragraph">
<p>Raku 可以用于生产吗？绝对是的！在 Raku 中已经交付了一些较小的客户项目。</p>
</div>
<div class="paragraph">
<p>虽然我们已经交付了一些在 Raku 中实施的较小的客户项目, 但 AGRAMMON 6 将是 <a href="https://www.oetiker.ch/">Oetiker+Partner AG</a> 的第一个使用 Raku 后台的公开访问的网络应用, 我们希望未来有更多的项目。在这个项目上与我们的<a href="https://www.edument.se/en/page/jonathan-worthington-eng">同事</a>合作是一件非常愉快的事情, 我们也要感谢我们的<a href="https://www.agrammon.ch/en/development-of-the-model/">客户和合作伙伴</a>给我们这个机会。</p>
</div>
<div class="paragraph">
<p>而最重要的成果。圣诞老人现在又多了一个能在未来的 Raku 项目中工作的小精灵。Raku 是一门非常丰富的语言, 毫无疑问, 对于&#34;它&#34;的任何定义, <a href="https://en.wikipedia.org/wiki/There%27s_more_than_one_way_to_do_it">&#34;有不止一种方法可以做&#34;</a>。虽然没有必要一下子就学会所有的东西, 但在附近有一些专家知识, 提出问题并了解更优雅的、通常是非常简洁的可用选项肯定是有帮助的。Raku 社区对新人非常友好和欢迎（甚至对偶尔出现的巨魔也是如此）。</p>
</div>
<div class="paragraph">
<p>Raku 本身也非常努力地帮助程序员不把自己射到脚下。错误信息往往是非常有帮助的, Comma IDE 所提供的问题报告或建议也是如此（而且随着每一个版本的发布, 它们变得越来越多）。所以, 请继续潜心研究吧!
== <a href="https://raku-advent.blog/2020/12/21/the-story-of-elfs-and-roles-and-santas-enterprise/">第二十一天 - 精灵的故事、角色以及圣诞老人的企业</a></p>
</div>
<div class="paragraph">
<p>让我们认真点吧。毕竟, 我们是成年人, 知道圣诞老人的全部真相：他是一个表演者, 他是圣诞老人家族企业的最高管理者。没有人知道他的具体职位, 因为我们不能忘记圣诞老人夫人, 她在管理公司的份额至少是相等的。反正这个职位与我们的故事无关。但重要的是, 经营这样一个庞大的企业需要很多技能。更何况这个企业本身也是一场巨大的表演, 从过去几十年人类历史上拍摄的<a href="https://www.imdb.com/title/tt0111070/?ref_=nv_sr_srsg_0">《圣诞老人》</a>等纪录片中可以发现。</p>
</div>
<div class="paragraph">
<p>经营&#34;北极公司&#34;最难的部分是什么？物流？是的, 但是有了雪橇的魔力, 有了驯鹿, 有了圣诞夜, 这个任务就不难完成了。制造？这个任务已经委托给了小型的外包公司, 比如乐高、任天堂, 以及全球其他几十家公司。</p>
</div>
<div class="paragraph">
<p>还剩下什么？就是员工。精灵们。而且, 天哪！, 你试过组织他们吗？不要想尝试, 除非你有一个备份的形式, 由礼貌的人员服务的软垫房间, 有可靠的药丸供应, 你会在那里度过你稀缺的假期。这是个不人道的任务, 因为当一个人把成千上万, <a href="https://raku-advent.blog/2020/12/11/day-11-santa-claus-tweaks-with-a-class/">甚至</a>上百万的雄心勃勃的舞台明星（没有精灵会认为自己是二线演员！）聚集在一起时, 每个人的能量相当于一个小型核反应堆…​你知道…​。</p>
</div>
<div class="paragraph">
<p>圣诞老人是如何管理的？当然, 他们的心胸开阔, 宽容度超出了一般人的理解。但是, 要想建立一个成功的企业, 这肯定是不够的! 所以, 一定是有秘诀的, 是商业结构和节目共同的东西。而我认为是做好了角色分配, 把精灵个性的布朗运动变成了自组织结构。</p>
</div>
<div class="paragraph">
<p>在这篇文章中, 我不会讲述 <a href="https://raku.org/">Raku</a> 是如何帮助圣诞老人梳理事情或者缓解某些任务的。相反, 我将尝试描述在北极公司内部发生的一些事件, 借助于 Raku 语言, 特别是它的 <a href="https://docs.raku.org/language/classtut">OO 功能</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_精灵">79.48. 精灵</h3>
<div class="paragraph">
<p>基本上, 精灵就是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">class Elf is FairyCreature {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>不知道为什么, 很多人都不喜欢这个定义, 但只要, 很多人类还不认为自己是猿类的一种, 我们又有什么资格去评价他们呢？同样, 有些精灵认为仙女是古板过时的, 和他们这些现代生物没有关系。</p>
</div>
<div class="paragraph">
<p>不过, 我说的是题外话…​</p>
</div>
<div class="paragraph">
<p>上述定义是高度简化的。因为如果我们开始遍历 <strong>FairyCreature</strong> 类的子树, 我们会发现其中有很多不同的物种, 比如独角兽、妖精、小精灵等等等等。显然, 一定有其他的东西, 定义了这种差异。一些能够为每一种特殊生物提供足够具体的属性的东西。如果我们扩展 <strong>Elf</strong> 类的定义, 我们会看到这样的行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">class Elf is FairyCreature {
    also does OneHead;
	  also does UpperLimbs[2];
    also does LowerLimbs[2];
    also does Magic;
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我必须在这里忏悔。我没有被允许看完整的来源。当我要求进入仙女库时, 得到的回答是：&#34;嘿, 如果我们把所有的东西都透露出来, 那就不像魔法了！&#34; 所以, 这里有些代码是真实的, 有些已经被猜出来了。我不会告诉你哪个是哪个, 毕竟, 让我们保持它的魔力吧!</p>
</div>
<div class="paragraph">
<p>每一行都是一个 <strong>role</strong>, 定义了一个属性, 或者是一个特性, 或者是一个通用精灵的固有行为（别把它和<a href="https://en.wikipedia.org/wiki/Spherical_cow">球形牛</a>搞混了）。所以, 当我们看到这样一行代码的时候, 我们就会说: <strong>Elf</strong> does <strong>Magic</strong>; 或者, 换句话说：类 <strong>Elf</strong> 会消耗<a href="https://docs.raku.org/language/objects#Roles">角色</a> <strong>Magic</strong>。</p>
</div>
<div class="paragraph">
<p>很抱歉没有给 Raku 新人详细解释什么是<a href="https://docs.raku.org/syntax/role">角色</a>, 希望这里的链接能对大家有所帮助。对于懂 Java 的人来说（我是恐龙, 我不懂）, 角色有点类似于接口, 但更好。它可以定义属性和方法, 注入到消耗类中；可以要求定义某些方法；还可以指定该类将消耗哪些其他角色, 以及其他类的继承。</p>
</div>
<div class="paragraph">
<p>事实上, 由于精灵物种的复杂性, 它们所做的角色数量太多, 这里就不一一列举了。一般情况下, 当一个类只消耗其中的几个角色时, 换一种方式写代码就可以了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">class DisgustingCreature is FairyCreature does Slimy does Tentacles[13] { .... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>但角色太多的话最好还是用前缀 <code>also</code> 把角色放进类体中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_当圣诞老人雇用一个精灵">79.49. 当圣诞老人雇用一个精灵</h3>
<div class="paragraph">
<p>如果说精灵是由圣诞老人雇佣的, 这可能是不正确的。事实上, 我们知道, 他们都是专门为北极公司工作的。然而, 我的想法是这样的, 在历史上的某个时刻, 确实发生了雇佣。让我们试着想象一下, 它是如何发生的。</p>
</div>
<div class="paragraph">
<p>不管是这样还是那样, 都有一个特殊的角色。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">role Employee {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而且还有一个问题：我们的类 Elf 已经是组成的, 而且是不可改变的。而且, 每个精灵都是该类的一个对象! 或者, 用 Raku 语言说同样的话：<code>$pepper-minstix.defined &amp;&amp; $pepper-minstix ~~ Elf</code>。好吧, 问题出在哪里呢？如果我们尝试 <code>$pepper-minstix.hire(:position(&#34;security officer&#34;), :company(&#34;The North Pole Inc.&#34;), …​)</code>, 会发生一个很大的 boom！, 因为对类型为 &#39;Elf&#39; 的调用者没有这样的方法 &#39;hire&#39;。当然, boom！是意料之中的, 因为很久很久以前, 精灵和工作就像圣诞节和夏天一样兼容！但后来有了圣诞老人。但后来有了圣诞老人。而他们所做的事情叫做<a href="https://docs.raku.org/language/objects#Mixins_of_roles">把角色混入一个对象</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">$pepper-minstix does Employee;</code></pre>
</div>
</div>
<div class="paragraph">
<p>从外部来看, 该操作将 <strong>Employee</strong> 角色的内容添加到对象的左手边, 使所有角色的属性和方法在该对象上可用。在内部, 它创建了一个新的类, 原来的 <code>$pepper-minstix.WHAT</code> 是唯一的父类；并且消耗了 <strong>Employee</strong> 这个角色。最终, 在 <strong>does</strong> 操作符之后, 比如说 <code>$pepper-minstix.WHAT</code> 将输出类似于 (Elf+{Employee}) 的东西。这就是现在 <code>$pepper-minstix</code> 变量所持有的对象的新类。</p>
</div>
<div class="paragraph">
<p>这样一个生活上的重大变化让精灵们开心了许多! 作为一个快乐的生物, 他们现在有了一个很好的机会与所有的孩子们分享他们的快乐, 有时不仅仅是孩子们。不过唯一让他们担心的是。要知道, 要找到两个一模一样的人真的不可能, 更何况没有两个一模一样的精灵。但是工作？岂不是在某种程度上把他们都拉平了？圣诞老人如果不和新朋友分享这些烦恼, 他们就不是圣诞老人了。为了了解他们的解决方案, 我们来看看 <strong>Employee</strong> 角色对我们有什么作用。其中我们最感兴趣的是以下几行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">has $.productivity;
has $.creativity;
has $.laziness;
has $.position;
has $.speciality;
has $.department;
has $.company;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了简单起见, 我在代码段中没有使用类型化的属性, 虽然它们在真正的原始代码中是有的。例如, <code>$.lazyyness</code> 属性是一个系数, 其中用于计算咖啡或蛋奶酒休息时间的公式。这个公式的核心是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">method todays-cofee-breaks-length {
    $.company.work-hours * $.laziness * (1 + 0.2.rand)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为感觉到自己对孩子们的责任, 精灵们同意限制自己的最大懒惰程度。因此这个属性的完整定义是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">has Num:D $.laziness where * &lt; 0.3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果有人认为最高限额太高, 那么他们心里就没有圣诞精神! 圣诞老人都很高兴, 我们为什么不高兴呢？我个人肯定他的满意是很好理解的, 因为他自己的最大值是在接近 0.5 的地方, 但是 - 嘘！- 我们还是保密吧。</p>
</div>
<div class="paragraph">
<p>有了所有这些特征, 圣诞老人想找到一种方法, 将它们设置为尽可能多样化的组合, 尽可能。而这就是他们想出的类似于这样的东西。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">role Employee {
    ...
    method my-productivity {...}
    method my-creativity {...}
    method my-laziness {...}
    submethod TWEAK {
        $!productivity //= self.my-productivity;
        $!creativity //= self.my-creativity;
        $!laziness //= self.my-laziness;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在要由精灵自己定义方法来设置相应的特性。不过他们中的大多数人都可以接受为此而提出的特殊角色。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">role RandomizedEmployee {
    method my-productivity { 1 - 0.3.rand }
    method my-creativity { 1 - 0.5.rand }
    method my-laziness { 1 - 0.3.rand }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在的招聘过程采取了以下形式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">$pepper-minstix does Employee, RandomizedEmployee;</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是, 等等！我们还有三个属性没有填完! 是的, 因为这些都是留给圣诞老人来填补的。他们知道什么样的工人, 哪里最需要。因此, 最终版本的雇佣代码更像是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">$pepper-minstix does Employee(
        :company($santas-company),
        :department($santas-company.department(&#34;Security&#34;)),
        :position(HeadOfDepartment),
        :speciality(GuardianOfTheSecrets),
        ...
    ),
    RandomizedEmployee;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这一行, Raku 的 mixin 协议做了以下工作。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建一个新的 mixin</p>
</li>
<li>
<p>设置用命名参数定义的属性</p>
</li>
<li>
<p>调用角色的构造函数 <strong>TWEAK</strong></p>
</li>
<li>
<p>返回一个新的 employee 对象</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因为大家都知道这件事将是一次性的冒险, 因为精灵们绝不会放过自己的新老板, 所以代码是一种效率和编码速度的权衡。不过, 还是用了一些有趣的技巧, 但讨论这些技巧已经超出了这个故事主线。对于这里提到的问题, 我想很多读者都能找到自己的解决方案。</p>
</div>
<div class="paragraph">
<p>我则继续说说发生在不久前的一个故事…​</p>
</div>
</div>
<div class="sect2">
<h3 id="_当时间太少的时候">79.50. 当时间太少的时候</h3>
<div class="paragraph">
<p>那是 12 月最疯狂的一天, 圣诞老人夫人紧急出差。已经忙于邮件和电话的圣诞老人先生, 在物流和包装部门有了额外的工作, 这些工作通常是由他的妻子处理的。他不可能跳过这些工作, 否则在圣诞之夜出问题的风险就太高了。要想按时到达各地, 唯一的办法就是减少打电话的次数。它的意思是叫精灵接待员用 &#34;Santa is not available&#34; 的信息来回答。</p>
</div>
<div class="paragraph">
<p>圣诞老人叹了口气。他几乎可以看到和听到小精灵带着深深的遗憾盯着他问道。&#34;尼古拉斯, 你是在让我撒谎吗？&#34; 哦, 不！他当然不会问, 但是…​</p>
</div>
<div class="paragraph">
<p>但是?, <a href="https://docs.raku.org/language/operators#infix_but">but</a>! 毕竟, 即使圣诞的时空魔法在一年中的其他日子里无法使用, 圣诞老人还是可以做其他种类的把戏的! 所以, 他的做法是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">role FirewallishReceptionist {
    has Bool $.santa-is-in-the-office;
    has Str $.not-available-message;
    method answer-a-call {
        if $.santa-is-in-the-office {
            self.transfer-call: $.santas-number;
        }
        else {
            self.reply-call: $.not-available-message,
                                :record-reply,
                                :with-marry-christmas;
        }
    }
}

my $strict-receptionist =
    $receptionist but FirewallishReceptionist(
        :!santa-is-in-the-office,
        :not-available-message(
            &#34;Unfortunately, Santa is not available at the moment.&#34;
            ~ ... #`{ the actual message is longer than this }
        )
    );

$company.give-a-day-off: $receptionist;
$company.santa-office-frontdesk.assign: :receptionist($strict-receptionist);</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/operators#infix_but">操作符 but</a> 与 <a href="https://docs.raku.org/language/operators#infix_does">does</a> 类似, 但不是改变其左手边的操作符, 而是创建其克隆, 然后将右手边的角色混入克隆中。</p>
</div>
<div class="paragraph">
<p>想象一下, 当前台接待员看到自己的副本在他的办公桌上占据了一席之地时, 他是多么的惊讶啊! 不过休息一天是一天, 他并不怎么反对将自己的懒惰系数应用到当天的其他工作中去…​…​</p>
</div>
<div class="paragraph">
<p>至于圣诞老人本人, 他从来没有真正为自己那天的行为感到骄傲。即使是以拯救圣诞节的名义需要这样做。此外, 克隆人的存在也造成了后来一些尴尬的局面, 尤其是当两个精灵都想做同样的工作, 同时还共享一些数据结构的时候。不过这就另当别论了…​。</p>
</div>
</div>
<div class="sect2">
<h3 id="_当新魔法有帮助时">79.51. 当新魔法有帮助时</h3>
<div class="paragraph">
<p>这个季节, 你看到精灵们的身影了吗？他们总是很严谨地坚持着圣诞时尚的最新趋势：丰富的色彩, 穗子, 都是有趣的, 快乐的! 然而今年真的很特别!</p>
</div>
<div class="paragraph">
<p>这一切都要从春天的末尾说起。圣诞老人坐在他的椅子上, 享受着他服务的最后一个圣诞节应有的休息。生意不像通常在秋末那样需要那么多的关注。所以, 他坐在壁炉旁, 喝着巧克力, 读着新闻。虽然新闻远不是圣诞老人休养生息的最好部分（没有关于 2020 年的消息！）。最终, 圣诞老人收起平板电脑, 从巨大的杯子里深深地抿了一口, 大声说道。&#34;是时候把他们的帽子换掉了！&#34; 不知道是什么原因促使他得出这个结论, 但从这一刻起, 精灵们知道, 一种新的时尚即将到来!</p>
</div>
<div class="paragraph">
<p>圣诞老人想实现的想法是在精灵帽上加装 WiFi 连接和 LED 灯, 并让 LED 灯闪烁着从北极公司的本地服务器上获得的图案。以下是他的出发点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">role WiFiConnect {
    has $.wifi-name is required;
    has $.wifi-user is required;
    has $.wifi-password is required;
    submethod TWEAK {
        self.connect-wifi( $!wifi-name, $!wifi-user, $!wifi-password );
    }
}

role ShinyLEDs {
    submethod TWEAK {
        if self.test-cirquits {
            self.LED( :on );
        }
        if self ~~ WiFiConnect {
            self.set-LED-pattern: self.fetch( :config-key&lt;LED-pattern&gt; );
        }
    }
}

class ElfCap2020 is ElfCap does WiFiConnect does ShinyLEDs {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, 我在这里不包括类的主体, 因为它太大, 不适合本文。</p>
</div>
<div class="paragraph">
<p>但尝试编译代码的结果是。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Method &#39;TWEAK&#39; must be resolved by class ElfCap2020 because it exists in multiple roles (ShinyLEDs, WiFiConnect)</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#34;哦, 果然如此！&#34; - 圣诞老人自言自语地抱怨道。并在类中添加了一个 <strong>TWEAK</strong> 子方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">submethod TWEAK {
    self.R1::TWEAK;
    self.R2::TWEAK;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这让编译器很是高兴。于是 <strong>ElfCap2020.new</strong> 就出现了一个新的、令人惊讶的有趣的帽子实例! &#34;嗬嗬嗬！&#34; - 圣诞老人忍不住开心的笑了起来。开始为公司所有员工生产新帽子的时候了；而这时才发现, 新帽子的量产需要众多第三方供应商和制造商的协调努力, 没有办法在圣诞节到来之前为所有人配备新玩具。</p>
</div>
<div class="paragraph">
<p>圣诞老人会放弃吗? 不, 他从来不会! 如果我们尝试将老式的盖子现代化呢？只需要那么多的 LED 和控制器, 按时处理应该是可行的!</p>
</div>
<div class="paragraph">
<p>适应这个世界的行动! 只要设计得好, 应该不难。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">$old-cap does (WiFiConnect(:$wifi-name, :$wifi-user, :$wifi-password), ShinyLEDs);</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后…​Boom! 方法 &#39;TWEAK&#39; 必须由类 ElfCap+{WiFiConnect,ShinyLEDs} 解析, 因为它存在于多个角色中(ShinyLEDs,WiFiConnect)。</p>
</div>
<div class="paragraph">
<p>圣诞老人叹了口气。毫无疑问, 这是预料之中的。因为 does 创建了一个隐式的空类, 当编译器试图将两个角色的子方法安装到类中时, 这两个子方法会发生冲突。一个死胡同？不可能! 圣诞老人喜欢快乐的结局! 而且他知道该怎么做。他知道有一个新版本的 Raku 语言正在开发中。它还没有发布, 但可以用 Rakudo 编译器进行测试, 如果在编译单元的最开始使用 v6.e.PREVIEW, 这通常是一个文件。</p>
</div>
<div class="paragraph">
<p>另外, 圣诞老人知道, 新语言版本带来的一个变化是, 无论如何, 它都会将子方法保留在它们被声明的地方。这意味着, 以前一个子方法从一个角色复制到消耗它的类中, 现在它将保持是角色的唯一属性。而且, 现在语言本身会处理类继承层次中的所有元素, 包括角色, 并调用它们的构造函数和/或析构子方法（如果有的话）。</p>
</div>
<div class="paragraph">
<p>不知道这意味着什么？请看下面的例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">use v6.e.PREVIEW;

role R1 {
    submethod TWEAK { say ::?ROLE.^name, &#34;::TWEAK&#34; }
}

role R2 {
    submethod TWEAK { say ::?ROLE.^name, &#34;::TWEAK&#34; }
}

class C { };

my $obj = C.new;
$obj does (R1, R2);
# R1::TWEAK
# R2::TWEAK</code></pre>
</div>
</div>
<div class="paragraph">
<p>显然, 在现代化脚本的开头添加使用 v6.e.PREVIEW, 使得 <code>$old-cap does (WiFiConnection, ShinyLEDs);</code> 行可以如期工作！</p>
</div>
<div class="paragraph">
<p>此外, 切换到 Raku 6.e 也使得 <strong>ElfCap2020</strong> 类也不需要子方法 <strong>TWEAK</strong>, 如果它的唯一功能是分派到角色 TWEAK 的话。虽然说实话, 圣诞老人还是保留了下来, 因为他需要在建造的时候做一些调整。但好在他不需要那么担心所有类组件组合在一起的小细节。</p>
</div>
<div class="paragraph">
<p>于是任务就这样解决了。在第一阶段, 所有的旧帽子都进行了现代化改造, 并在本季开始前做好准备, 圣诞节的准备工作占用了北极公司所有剩余的业余时间。现在, 新的帽子将在没有额外的麻烦的情况下生产, 并在 2021 年的季节准备好。节约的时间圣诞老人用来改装 WiFiConnection 和 ShinyLEDs, 让他们也能用在他的雪橇上。当被安全部门告知, 额外的照明让雪橇的伪装变得更加困难, 如果有可能的话, 圣诞老人只是耸了耸肩, 回答道。&#34;你们会成功的, 我相信你们！&#34; 他们确实做到了, 但那是另外一个故事…​</p>
</div>
</div>
<div class="sect2">
<h3 id="_幸福终点">79.52. 幸福终点</h3>
<div class="paragraph">
<p>说到北极, 总是很难分辨真假, 也很难把魔法和科学分开。但毕竟, 自然法则告诉它, <a href="https://en.wikipedia.org/wiki/Clarke%27s_three_laws">任何足够先进的技术都与魔法无异</a>。通过 Raku, 我们试图把一点好的魔法带入这个生活。要知道, 支持 Raku 的不是别人, 正是圣诞老人一家自己！真是太让人惊讶了。</p>
</div>
<div class="paragraph">
<p>圣诞快乐, 新年快乐!
== <a href="https://raku-advent.blog/2020/12/22/draft-whats-the-point-of-point-free-programming/">第二十二天 - 无点编程的意义何在？</a></p>
</div>
<div class="quoteblock">
<blockquote>
他取了一个新的名字, 大部分是出于通常的原因, 也有一些不寻常的原因, 其中最重要的是名字对他很重要。
- 帕特里克-罗斯福斯, 《风之名》。
</blockquote>
</div>
<div class="paragraph">
<p>如果你是一个程序员, 很有可能名字对你也很重要。赋予变量和函数是<a href="https://dzone.com/articles/naming-conventions-from-uncle-bobs-clean-code-phil">写好代码的基本原则</a>之一, 提高名字的质量是<a href="https://thoughtbot.com/upcase/videos/refactoring-extraction-naming">重构低质量代码</a>的第一步。而如果你们都是程序员, 并且对 Raku（2019 年由 &#34;Perl 6&#34; 改名而来）一点都不陌生, 那么你们就更能体会到名字的力量和重要性。</p>
</div>
<div class="paragraph">
<p>这使得<a href="http://xahlee.info/comp/point-free_programing.html">无点编程</a>的吸引力 - 它主张删除你代码中的许多名字 - 有点神秘。考虑到好的名字是多么有用, 你很难理解为什么要消除它们。</p>
</div>
<div class="paragraph">
<p>无点编程（有时也被称为隐性编程）的倡导者提出的一些论点也不一定能帮助我们理解。例如, 一位无点编程的支持者<a href="https://spin.atomicobject.com/2017/09/29/point-free-notation/#.Wc5PtNDfhoc.hackernews">说</a>。</p>
</div>
<div class="quoteblock">
<blockquote>
有时, 特别是在涉及高阶函数的抽象情况下, 为切线参数提供名称会使你正在做的事情所依据的数学概念变得模糊不清。在这些情况下, 无点符号可以帮助消除你代码中的这些干扰。
</blockquote>
</div>
<div class="paragraph">
<p>这并没有错, 但也并不完全有用；当读到这句话时, 我发现自己在想&#34;有时候；好吧, 什么时候；在抽象的情况下；好吧, 什么样的情况下？&#34; 而且好像不止我一个人有类似的问题, 正如<a href="https://news.ycombinator.com/item?id=15365214">黑客新闻的置顶评论</a>所示。鉴于这样的论点, 我一点也不奇怪, 许多程序员对无点编程的否定, 基本上和<a href="https://en.wikipedia.org/wiki/Tacit_programming">维基百科的做法</a>一样：根据维基百科的说法, 无点编程&#34;具有理论意义&#34;, 但会使代码&#34;不必要地晦涩难懂&#34;。</p>
</div>
<div class="paragraph">
<p>这种观点 - 虽然是可以理解的 - 既是错误的, 我相信也是非常不幸的。以无点风格编程可以使代码的可读性大大提高；正确地进行编程, 它可以使代码不那么晦涩, 而不是更加晦涩。在这篇文章的剩余部分, 我将尽可能具体地解释用较少的名字编码的好处。为了让自己保持诚实, 我还会将一个简短的程序重构为无点风格（代码将使用 Raku, 但之前和之后的版本对非 Raku 程序员来说都应该是容易理解的）。最后, 我将通过指出 Raku 的&#34;有不止一种方法&#34;的理念使你更容易写出清晰、简洁、无点的代码（如果你想的话）的一些方法来结束。</p>
</div>
</div>
<div class="sect2">
<h3 id="_无指向性的基本点">79.53. 无指向性的基本点</h3>
<div class="paragraph">
<p>我以前说过, 名字很重要, 我是认真的。我的主张是 G.K.切斯特顿（或他的狗）如果关心写好代码的话<a href="https://slatestarcodex.com/2014/12/25/book-review-whats-wrong-with-the-world/">可能会提出的主张</a>：我们应该减少使用名字, 不是因为名字不重要, 而是恰恰因为名字是多么重要。</p>
</div>
<div class="paragraph">
<p>让我们退后一分钟。为什么名字首先有助于写出清晰的代码？sub f($a, $b) 可能会告诉你, 你有一个接受两个参数的函数 - 但它让你完全不知道这个函数是做什么的, 也不知道这些参数起什么作用。但只要我们添加名字, 一切都会变得更加清晰：sub days-to-birthday($person, $starting-date)。突然间, 我们对函数的作用有了更好的认识。当然, 这并不是一个完美的想法；特别是, 我们可能会有一些问题, 这些问题可以通过在代码中添加类型来回答（<a href="https://raku.guide/#_types">Raku 支持的</a>东西）。但不可否认的是, 名字给我们的代码增加了信息。</p>
</div>
<div class="paragraph">
<p>所以, 如果添加名称增加了信息, 就会让你的代码更清晰, 更容易理解, 对吗？嗯, 当然…​在一定程度上是这样。但这是同样的思路, 导致了一页又一页的贷款&#34;披露&#34;, 每一个都是为了给你提供更多关于贷款的信息。尽管有这些意图, 但凡是面对过一叠和埃菲尔铁塔差不多大小的文件的人都可以证明, 这些额外信息的累积效果是<a href="https://www.law.upenn.edu/journals/lawreview/articles/volume159/issue3/BenShaharSchneider159U.Pa.L.Rev.647(2011).pdf">让读者感到困惑, 并掩盖了重要的细节</a>。代码中过多的名称也会落入同样的陷阱：即使每个名称在技术上增加了信息, 但过多的名称的累积效应是混淆而不是清晰。</p>
</div>
<div class="paragraph">
<p>这里用不同的语言表达了同样的想法：名字给你的代码增加的不仅仅是额外的信息, 还有额外的强调。而关于强调的事情 - 无论是来自于粗体、全大写还是命名 - 当它被过度使用时, 就会失去其力量。给所有的东西都起个名字和用 ALL-CAPS 写作是同一种错误。基本上, 不要成为这个家伙。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">&lt;Khassaki&gt;:      HI EVERYBODY!!!!!!!!!!
&lt;Judge-Mental&gt;:  try pressing the Caps Lock key
&lt;Khassaki&gt;:      O THANKS!!! ITS SO MUCH EASIER TO WRITE NOW!!!!!!!
&lt;Judge-Mental&gt;:  f**k me</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://bash.org/?835030">source</a> (加上了 expurgation, 主要是为了有借口使用 <a href="https://www.merriam-webster.com/dictionary/expurgate">expurgation</a> 这个词)。</p>
</div>
<div class="paragraph">
<p>我相信, 使用无点编程技术写出名字较少的代码的根本好处是, 它可以让剩下的名字更加突出 - 这让它们传达的信息比海量的名字更多。</p>
</div>
</div>
<div class="sect2">
<h3 id="_什么叫理解一行代码">79.54. 什么叫&#34;理解&#34;一行代码？</h3>
<div class="paragraph">
<p>你理解这行 Raku 代码吗？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">$fuel += $mass</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们想象一下, 一个非常文字化的程序员 - 我们称他们为 Literal Larry - 会如何回应。当然, Literal Larry 并不是指 Raku 的创始人 <a href="https://en.wikipedia.org/wiki/Larry_Wall">Larry Wall</a>。多年来, Larry 可能会被指责为各种风格上的缺陷, 但从未被指责为过度文字化）。)</p>
</div>
<div class="paragraph">
<p>字面意思的 Larry 可能会说：&#34;我当然明白这行是干什么的！有一个 $fuel 变量, 它是由 $mass 变量的值递增的。还有比这更明显的吗？&#34;。但是我对 Larry 的回答是：&#34;你只是告诉了我这一行说了什么, 但没有告诉我它做了什么。如果不了解更多围绕那句话的上下文, 事实上, 我们无法知道那句话的作用。要理解那一行 - 诚然是简单的! - 这一行的理解需要我们在脑海中保持其他行的上下文。更糟糕的是, 因为它是根据另一个变量的值来改变一个变量的值, 所以理解它需要我们跟踪可突变状态 - 这是增加一段代码复杂性的最快方法之一。&#34;</p>
</div>
<div class="paragraph">
<p>这就奠定了我关于无点式编码的第二个主张。它通常会减少你脑海中理解任何一行代码所需要的上下文/状态的数量。无点式代码在两个方面减少了对上下文/状态的依赖：首先, 在我们完全消除一些命名变量的程度上, 那么我们显然不再需要在头脑中跟踪这些变量的状态。不太明显（但可以说更重要）的是, 无指向性的风格自然会促使你限制变量的范围, 并减少任何时候需要跟踪的变量数量。(在下面的例子中, 你会看到这一点。)</p>
</div>
</div>
<div class="sect2">
<h3 id="_一个无指向性的例子">79.55. 一个无指向性的例子</h3>
<div class="paragraph">
<p>尽管我们的讨论尽可能地实用, 但我担心它已经有点偏离了具体的领域。让我们通过编写一些实际的代码来弥补这个问题吧! 我将以标准的程序风格来介绍一些代码, 将它重构成一种更无点的风格, 并讨论我们从变化中得到了什么。</p>
</div>
<div class="paragraph">
<p>但是, 我们应该从哪里得到我们的之前的代码呢？它需要写得像模像样 - 我和 Literal Larry 的交流可能已经足够一篇文章的草拟了, 我不希望你认为重构后的版本只是因为原版太糟糕而有所改进。同时, 它不应该是伟大的惯用 Raku 代码, 因为那意味着使用了足够多的 Raku 的超能力, 降低了代码的可访问性（我想解释后面的代码是怎么回事, 但不想陷入对前面的教学）。它的长度也应该恰到好处 - 太短了, 我们就看不到减少上下文的优势；太长了, 我们就没有空间去详细讲解了。</p>
</div>
<div class="paragraph">
<p>幸运的是, Raku 文档中提供了完美的前文代码：<a href="https://docs.raku.org/language/101-basics">Raku 代码 101</a>。这个简单的脚本并不是惯用法的 Raku, 它是一个只使用 Raku 语法的最基本的程序, 可以完成真正的（虽然是最小的）工作。下面是该页面如何描述脚本的任务。</p>
</div>
<div class="paragraph">
<p>假设你举办了一场乒乓球比赛。裁判会以 Player1 Player2 | 3:2 的格式告诉你每场比赛的结果, 这意味着 Player1 以 3 比 2 的比分战胜了 Player2。你需要一个脚本来总结每个选手赢了多少场比赛和多少局, 以确定总冠军。</p>
</div>
<div class="paragraph">
<p>输入的数据（存储在一个叫 scores.txt 的文件中）是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Beth Ana Charlie Dave
Ana Dave | 3:0
Charlie Beth | 3:1
Ana Beth | 2:3
Dave Charlie | 3:0
Ana Charlie | 3:1
Beth Dave | 0:3</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一行是选手名单。随后的每一行都记录了一场比赛的结果。</p>
</div>
<div class="paragraph">
<p>我相信这段代码应该是清晰易懂的, 即使是没有看过任何 Raku 的程序员。我要为那些真正没有看过 Raku（或者 Perl）的人提供一个提示, 那就是 <code>@</code> 表示一个变量是类似数组的, <code>%</code> 表示它是类似 hashmap 的, 而 <code>$</code> 则表示所有其他变量。如果其他语法给你带来麻烦, 请查看<a href="https://docs.raku.org/language/101-basics">文档中的完整演练</a>。</p>
</div>
<div class="paragraph">
<p>这里是 101 版本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">use v6.d;
# start by printing out the header.
say &#34;Tournament Results:\n&#34;;

my $file  = open &#39;scores.txt&#39;; # get filehandle and...
my @names = $file.get.words;   # ... get players.

my %matches;
my %sets;

for $file.lines -&gt; $line {
    next unless $line; # ignore any empty lines

    my ($pairing, $result) = $line.split(&#39; | &#39;);
    my ($p1, $p2)          = $pairing.words;
    my ($r1, $r2)          = $result.split(&#39;:&#39;);

    %sets{$p1} += $r1;
    %sets{$p2} += $r2;

    if $r1 &gt; $r2 {
        %matches{$p1}++;
    } else {
        %matches{$p2}++;
    }
}

my @sorted = @names.sort({ %sets{$_} }).sort({ %matches{$_} }).reverse;

for @sorted -&gt; $n {
    my $match-noun = %matches{$n} == 1 ?? &#39;match&#39; !! &#39;matches&#39;;
    my $set-noun   = %sets{$n} == 1 ?? &#39;set&#39; !! &#39;sets&#39;;
    say &#34;$n has won %matches{$n} $match-noun and %sets{$n} $set-noun&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>好吧, 那是相当快的。它使用我的来声明 13 个不同的变量；让我们看看如果我们声明 0 会是什么样子。 不过在我开始之前, 有一点要注意：我说过上面的代码不是习惯性的 Raku, 下面的代码也不会是。我会在让代码更默契的地方大量引入 Raku 的语法, 但我还是会避开一些我平时会使用的形式, 这些形式与以更无点的风格重构代码无关。我也不会做一些我平时会包含的不相关的改动（比如删除可突变状态）。最后, 这段代码也不同于典型的 Raku（至少我的写法）, 它非常狭窄。我通常的目标是将行长控制在 100 个字符以下, 但因为我希望这段代码在任何屏幕上都能读懂, 所以这些行从未超过 45 个字符。</p>
</div>
<div class="paragraph">
<p>清了清嗓子, 我们就开始吧。我们的第一步和 101 代码差不多；我们打开文件, 然后遍历这些行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">open(&#39;scores.txt&#39;)
  ==&gt; lines()</code></pre>
</div>
</div>
<div class="paragraph">
<p>你已经可以看到我们将使用的关键语法之一来采用无点样式：==&gt;, 即 <a href="https://docs.raku.org/language/operators#infix_==%3E">feed 操作符</a>。这个操作符从 open(&#39;score.txt&#39;) 中获取结果, 并将其作为最终参数传递给 lines()。(这与在 open(&#39;scores&#39;) 上调用 .lines() 方法类似, 但不完全相同。最重要的是, ==&gt; 将一个值作为最后一个参数传递给下面的函数；调用一个方法更接近于将一个值作为第一个参数传递）。)</p>
</div>
<div class="paragraph">
<p>现在我们要处理的是输入文件中所有行的列表 - 但实际上我们并不需要所有的行, 因为有些行是无用的（对我们来说）头行。我们将用与命令行相同的方式来解决这个问题：使用 grep 来限制我们关心的行。在本例中, 这意味着只限制那些有 &#34; | &#34; (空格-管道-空格) 分隔符的行, 这种分隔符在所有有效的输入行中都会出现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">==&gt; grep(/\s &#39;|&#39; \s/)</code></pre>
</div>
</div>
<div class="paragraph">
<p>顺带说几句语法说明：首先, Raku 显然对正则表达式有一流的支持。其次, 也许更令人惊讶的是, 请注意, Raku regexes 默认对空白敏感；/&#39;foo&#39; &#39;bar&#39;/ 匹配的是 &#39;foobar&#39;, 而不是 &#39;foo bar&#39;。最后, Raku regexes 要求非字母字符在匹配之前必须用 &#39; 括起来。</p>
</div>
<div class="paragraph">
<p>在使用 grep 来限制我们所关心的行之后, 我们要处理的是一个类似 Ana Dave | 3:0 的行的序列。我们的下一个任务是将这些行转换成更容易被机器读取的东西。由于我们刚刚学习了 regex 语法, 所以我们继续使用这种方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">  ==&gt; map({
      m/ $&lt;players&gt;=( (\w+)  \s (\w+) )
                       \s    &#39;|&#39;  \s
         $&lt;sets-won&gt;=((\d+) &#39;:&#39; (\d+) )/;
      [$&lt;players&gt;[0], $&lt;sets-won&gt;[0]],
      [$&lt;players&gt;[1], $&lt;sets-won&gt;[1]]
  })</code></pre>
</div>
</div>
<div class="paragraph">
<p>这使用了我们上面介绍的 Regex 语法, 并在上面增加了一些内容。最重要的是, 我们现在对我们的捕获组进行了命名：我们有一个名为玩家的捕获组, 它捕获的是 <code>|</code> 字符前的两个空格分隔的玩家名字。显然我们的比赛只识别单字名的玩家, 这个限制在 101 代码中也是存在的）。而 <code>set-won</code> 命名的捕捉组则提取出 <code>:</code> 限定的集合结果。</p>
</div>
<div class="paragraph">
<p>一旦我们捕获了该场比赛的名字和分数, 我们就将正确的分数与正确的名字关联起来, 并将结果创建一个 2×2 矩阵/嵌套数组。</p>
</div>
<div class="paragraph">
<p>但实际上, 我们还没有完全完成我们在这个地图里面想要做的所有事情 - 我们已经赋予了每行内元素的顺序意义, 但行本身的顺序目前是没有意义的。让我们通过对我们返回的数组进行排序来解决这个问题, 让赢家总是在前面。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">[$&lt;players&gt;[0], $&lt;sets-won&gt;[0]],
[$&lt;players&gt;[1], $&lt;sets-won&gt;[1]]
==&gt; sort({-.tail})</code></pre>
</div>
</div>
<div class="paragraph">
<p>加上这个, 我们的代码到目前为止是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">open(&#39;scores.txt&#39;)
  ==&gt; lines()
  ==&gt; grep(/\s &#39;|&#39; \s/)
  ==&gt; map({
      m/ $&lt;players&gt;=( (\w+)  \s (\w+) )
                       \s    &#39;|&#39;  \s
         $&lt;sets-won&gt;=((\d+) &#39;:&#39; (\d+) )/;
      [$&lt;players&gt;[0], $&lt;sets-won&gt;[0]],
      [$&lt;players&gt;[1], $&lt;sets-won&gt;[1]]
      ==&gt; sort({-.tail})
  })</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这一点上, 我们已经将我们的输入行处理成数组；我们已经从像 Ana Dave | 3:0 这样的东西变成了像以下这样的东西</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">[ [Ana,  3],
  [Dave, 0] ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在是时候开始将我们的独立数组组合成一个代表整个比赛结果的数据结构了。就像现在的大多数语言一样, Raku 用 reduce 来实现这个功能（有些语言也叫同样的操作 fold）。我们将使用 reduce 从我们的嵌套数组列表中构建一个单一的 hashmap。然而, 在我们这样做之前, 我们需要添加一个适当的初始值来减少到（这里, 一个空的 Hash）。</p>
</div>
<div class="paragraph">
<p>Raku 为我们提供了六种方法 - 包括在调用 reduce 时指定一个初始值, 就像在现代 JavaScript 中一样。我将以不同的方式来完成同样的事情, 一方面是因为它更有趣, 另一方面是因为它可以让我在短短的 10 个字符中向你介绍 5 种有用的语法, 这可能是某种记录。下面是这一行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">==&gt; {%, |$_}()</code></pre>
</div>
</div>
<div class="paragraph">
<p>好了, 这里面装了很多东西! 让我们一步步来。{…​} 是 Raku 的匿名<a href="https://docs.raku.org/type/Block">块</a>（即 lambda）语法。所以 <code>{…​}()</code> 通常会创建一个匿名块, 然后在没有任何参数的情况下调用它。然而, 正如我们上面所说, ==&gt; 会自动将其左手边的返回值作为最终参数传递给右手边。所以, ==&gt; {...}() 用输入到 ==&gt; 中的值来调用这个块。</p>
</div>
<div class="paragraph">
<p>由于这个代码块没有指定签名（稍后会有更多的说明）, 所以它根本没有任何命名的参数；相反, 代码块被调用的任何值都被放置在<a href="https://docs.raku.org/language/variables#index-entry-topic_variable">主题变量</a>中 - 用 $_ 来访问。将我们目前所拥有的东西放在一起, 我们可以展示一个复杂的（但简洁的！）无为的方式：==&gt; {$_}()。该表达式将一个值送入块中, 将该值加载到主题变量中, 然后什么也不做就返回。</p>
</div>
<div class="paragraph">
<p>然而, 我们的行做了一些事情—​毕竟, 我们的行中还剩下 4 个字符和 2 个新概念! 从左边开始, 我们有 % 字符, 你可能认识它, 它是表示一个变量是类似哈希的符号（如果我们是技术性的）。<a href="https://docs.raku.org/language/variables#The_%_variable">就像这样</a>, 它可以有效地创建一个空的哈希值 - 我们也可以用 Hash.new、{} 或 %() 来实现, 但我最喜欢这里的 %。而我们已经使用过的 <code>,</code> 操作符, 无需赘述, 它可以将其参数合并成一个列表。</p>
</div>
<div class="paragraph">
<p>下面是一个使用我们目前所学语法的例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">[1, 2, 3] ==&gt; {0, $_}()</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将从 0 和 [1, 2, 3] 中建立一个列表。具体来说, 它将建立一个两元素的列表；第二个元素是数组 [1, 2, 3]。这并不是我们想要的, 因为我们想要在现有列表的前面添加 %, 而不是创建一个新的更多的嵌套列表。</p>
</div>
<div class="paragraph">
<p>你可能已经猜到了, 我们剩下的最后一个字符 - <code>|</code> - 为我们解决了这个问题。这个 <a href="https://docs.raku.org/type/Slip">Slip</a> 操作符是我最喜欢的 Raku 的聪明之处。(好吧, 反正是前 20 名 - 有很多竞争者!) <code>|</code> 操作符将一个列表转换为一个 Slip, 正如文档中所说的那样, 它是&#34;一种自动扁平化的列表&#34;。在实践中, 这意味着 Slip 会合并到列表中, 而不是成为其中的单个元素。回到我们之前的例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">[1, 2, 3] ==&gt; {0, |$_}()</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生了四元素列表 (0, 1, 2, 3), 而不是我们不加 <code>|</code> 的两元素列表 (0, [1, 2, 3])。</p>
</div>
<div class="paragraph">
<p>把所有这些放在一起, 我们现在就可以很容易地理解我们一直在谈论的那行大约 15 个字符(!)的代码了。回想一下, 我们刚刚使用 map 将我们的行列表转换为一个 2×2 矩阵的列表。如果我们把它们打印出来, 我们会看到类似的东西。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">( [ [Ana,  3],
    [Dave, 0] ],
  ...
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们把这个数组输入到 {%, |$_}() 块中时, 我们把它和空的哈希值一起放入一个列表中, 最后得到的是这样的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">( {},
  [ [Ana,  3],
    [Dave, 0] ],
  ...
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这一行简短而密集的代码, 我们可以继续调用 reduce。就像在许多其他语言中一样, 我们将传入一个函数, 让 reduce 将我们的值合并成一个单一的结果值。我们将使用我们刚刚介绍的块语法来完成这项工作 (看, 我们在这一行上花费的时间已经开始得到回报了！)。因此, 它将看起来像这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">==&gt; reduce( {
    # Block body goes here
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>在填写这个正文之前, 我们先说一下签名（我告诉过你它很快就会出现）。正如我们讨论过的, 当你没有为一个代码块指定签名时, 所有传递给代码块的参数都会被加载到主题变量 $_ 中。我们可以通过对主题变量的操作/索引来做任何我们需要做的事情, 但这可能会变得非常啰嗦。幸运的是, 我们可以通过将参数名放在 -&gt; 和开头的 <code>{</code> 之间来指定一个块的签名。因此, -&gt; $a, $b { $a + $b } 是一个正好接受两个参数并返回其参数之和的块。</p>
</div>
<div class="paragraph">
<p>在我们的例子中, 我们知道要减少的第一个参数将是我们正在建立的哈希值, 以跟踪比赛中的总胜利, 第二个将是代表下一场比赛结果的 2×2 数组。这就给了我们一个签名, 即</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">==&gt; reduce(-&gt; %wins, @match-results {
    # Block body goes here
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么, 我们如何填写正文呢？好吧, 由于我们之前对数组进行了排序, 我们现在调用 @match-results, 我们知道第一行包含赢得最多局数的人（因此也是比赛）。更具体地说, 第一行的第一个元素包含了那个人的名字。所以我们想要第一行的第一个元素—​也就是说, 如果我们的数组是 2D 布局的话, 这个元素会在(0, 0)处。幸运的是, Raku 支持直接<a href="https://docs.raku.org/language/subscripts#Multiple_dimensions">索引到多维数组</a>, 所以访问这个名字就像 @match-results[0;0] 一样简单。这就意味着我们可以更新我们的哈希值来计算比赛的获胜者。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">%wins{@match-results[0;0]}&lt;matches&gt;++;</code></pre>
</div>
</div>
<div class="paragraph">
<p>处理集合的方法非常相似—​最大的区别是我们在 @match-results 的两行中都进行迭代, 而不是索引到第一行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">for @match-results -&gt; [$name, $sets] {
    %wins{$name}&lt;sets&gt; += $sets;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意上面的 -&gt; [$name, $sets] 签名。这显示了 Raku 对<a href="https://docs.raku.org/language/variables#index-entry-destructuring_assignment">解构赋值</a>的强大支持, 这是避免显式赋值语句的另一个关键工具。-&gt; [$a, $b] 告诉 Raku, 该块接受一个有两个元素的单数组, 并为每个元素赋名。它相当于写 -&gt; @array { my $a = @array[0]; my $b = @array[1]; ... }。</p>
</div>
<div class="paragraph">
<p>(如果使用解构赋值来避免赋值的想法在无点风格方面感觉像是作弊, 那么请保持这种想法, 因为当我们到了这个例子的结尾时, 我们会回到这个问题上。)</p>
</div>
<div class="paragraph">
<p>在我们的 reduce 块的最后, 我们需要返回我们一直在构建的%wins 哈希。把所有的东西放在一起, 我们就得到了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">  ==&gt; reduce(-&gt; %wins, @match-results {
      %wins{@match-results[0;0]}&lt;matches&gt;++;
      for @match-results -&gt; [$name, $sets] {
          %wins{$name}&lt;sets&gt; += $sets;
      }
      %wins
  })</code></pre>
</div>
</div>
<div class="paragraph">
<p>此时, 我们已经建立了一个包含所有我们需要的信息的哈希值, 我们已经完成了对输入的处理。具体来说, 我们的哈希包含了比赛中每个选手名字的键；每个键的值都是一个哈希, 显示了该选手的总比赛和局数胜利。它看起来有点像这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">{ Ana  =&gt; { matches =&gt; 2,
            sets    =&gt; 8 }
  Dave =&gt; ...,
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这包含了我们所需要的所有信息, 但不一定是生成输出的最简单的形式。具体来说, 我们希望按照特定的顺序打印结果（获胜者优先）, 但我们的数据是以哈希形式存在的, 而哈希本身是无序的。因此 - 就像经常发生的那样—​我们需要将我们的数据从最适合处理输入数据的形状重塑为最适合生成输出的形状。</p>
</div>
<div class="paragraph">
<p>在这里, 这意味着要从哈希的哈希值变成哈希值的列表。我们的做法是, 首先将我们的哈希转化为一个键值对的列表, 然后将这个列表映射成一个哈希列表。在该映射中, 我们需要将球员的名字（之前存储在外哈希键中的信息）添加到内哈希中—​如果跳过这一步, 我们就不知道哪些分数和哪些球员在一起。</p>
</div>
<div class="paragraph">
<p>下面是这一步骤的样子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">  ==&gt; kv()
  ==&gt; map(-&gt; $name, %_ { %{:$name, |%_} })</code></pre>
</div>
</div>
<div class="paragraph">
<p>我要顺便指出, 我们的 map 使用了解构赋值和 <code>|</code> slip 操作符来构建我们的新哈希。这一步之后, 我们的数据看起来就像：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">( { name    =&gt; &#34;Ana&#34;,
    matches =&gt; 2,
    sets    =&gt; 8 }
  ...
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个列表本身并不像哈希那样无序, 但我们还没有给它安排任何有意义的顺序。现在我们就这样做。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">  ==&gt; sort({.&lt;matches&gt;, .&lt;sets&gt;, .&lt;name&gt;})
  ==&gt; reverse()</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, 这保留了原始代码中有点古怪的排序顺序：按比赛胜负排序, 从高到低；按比赛胜负分出平局；按反向字母顺序分出平局胜负。</p>
</div>
<div class="paragraph">
<p>至此, 我们已经将所有的输出数据组织好了, 剩下的就是格式化打印了。当打印我们的输出时, 我们需要使用正确的单数/复数词缀 - 也就是说, 我们不想说某人赢了 &#34;1 局&#34;或 &#34;5 局&#34;。</p>
</div>
<div class="paragraph">
<p>让我们写一个简单的辅助函数来为我们处理这个问题。很明显, 我们可以写一个函数来测试我们是否需要单数或复数的词缀, 但相反, 让我们利用这个机会来看看另外一个让我们更容易编写无点代码的 Raku 特性：根据调用方式执行不同操作的<a href="https://docs.raku.org/language/functions#index-entry-declarator_multi-Multi-dispatch">多重函数</a>。</p>
</div>
<div class="paragraph">
<p>我们想要的函数应该接受一个键值对, 并在相关的值为 1 时返回键的单数版本；否则, 它应该返回键的复数版本。让我们先用 proto 语句说明我们函数的所有版本有什么共同点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">proto kv-affix((Str, Int $v) --&gt; Str) {{*}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于那个 proto 语句有几件事要知道。这是我们第一次在代码中加入类型约束, 它们的工作原理和你所期望的一样. kv-affix 只能用字符串作为它的第一个参数和一个整数作为它的第二个参数来调用(这可以防止我们用错误的顺序调用它的键和值, 例如). 它还保证返回一个字符串。此外, 请注意我们可以使用一个类型（这里是 Str）来重构, 而不需要声明一个变量 - 这对于我们想在一个类型上进行匹配而不需要使用值的情况来说非常方便。</p>
</div>
<div class="paragraph">
<p>最后, 请注意, proto 是完全可选的；事实上, 我认为我不一定会在这里使用 proto。但是, 如果我们不讨论 Raku 对类型约束的支持, 我会觉得很失职, 一般来说, 它对编写无点代码相当有帮助（即使我们今天还没有真正需要它）。</p>
</div>
<div class="paragraph">
<p>接下来, 让我们处理一下我们需要返回键的单数版本的情况。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">multi kv-affix(($_, 1)) { S/e?s$// }</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你所看到的, Raku 让我们可以用字面值来重构/模式匹配 - 这个版本的 multi 只会在调用 kv-affix 时以 1 作为第二个参数时才会被调用。另外, 请注意我们正在将第一个参数重构为 $_, 即特殊的主题变量。设置 topic 变量不仅可以让我们在不给它命名的情况下使用这个变量, 而且还可以启用 Raku 为当前主题保留的所有工具。如果我们想要这些工具而不需要解构到 topic 变量中, 我们也可以用 <a href="https://docs.raku.org/language/control#index-entry-control_flow_with">with</a> 或 <a href="https://docs.raku.org/language/control#index-entry-control_flow__given-given">given</a> 来设置 topic）。</p>
</div>
<div class="paragraph">
<p>将主题设置为我们正在修改的键在这里很有帮助, 因为它让我们可以使用 S/// <a href="https://docs.raku.org/language/regexes#S///_non-destructive_substitution">非破坏性替换操作符</a>。这个操作符将一个 regex 与主题进行匹配, 然后返回替换匹配部分的字符串的结果。在这里, 我们匹配 0 或 1 个 e’s(e?), 后面是一个 &#39;s&#39;, 然后是字符串的结尾($)。然后, 我们将 &#39;s&#39; 或 &#39;es&#39; s替换为无, 有效地修剪了字符串中的复数词缀。</p>
</div>
<div class="paragraph">
<p>最后的 multi 候选者是微不足道的。它只是说当前一个多候选者不匹配时（也就是值不是 1 时）, 返回未修改的复数键。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">multi kv-affix(($k, $)) { $k }</code></pre>
</div>
</div>
<div class="paragraph">
<p>(当我们不需要关心参数的类型或值时, 我们使用 <code>$</code> 作为参数的占位符。)</p>
</div>
<div class="paragraph">
<p>有了这三行代码, 我们现在有了一个小助手函数, 它将为我们提供键的正确单数/复数版本。老实说, 我不确定这里是否真的值得使用 multi。这可能是一个简单的三元条件—​类似 sub kv-affix(($_, $v)) { $v ≠ 1 ?？ $_ !! S/e?s$// } - 可能会做得更简洁, 更清楚。但这样一来, 我们就没有理由再去讨论 multis 了, 因为那些东西实在是太有趣了。</p>
</div>
<div class="paragraph">
<p>无论如何, 现在我们有了我们的辅助函数, 格式化我们输出的每一行是相当琐碎的。在下面, 我将使用老式的 C 风格的 <a href="https://docs.raku.org/language/independent-routines#routine_sprintf">sprintf</a> 来做, 但是如果你喜欢其他的东西, Raku 提供了<a href="https://docs.raku.org/language/quoting">许多其他的格式化文本输出的选项</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">  ==&gt; map({
      &#34;%s has won %d %s and %d %s&#34;.sprintf(
          .&lt;name&gt;,
          .&lt;matches&gt;, kv-affix(.&lt;matches&gt;:kv),
          .&lt;sets&gt;,    kv-affix(.&lt;sets&gt;:kv   )
      )})</code></pre>
</div>
</div>
<div class="paragraph">
<p>而当我们将每一行输出的格式化后, 最后一步就是添加相应的头, 连接我们的输出行, 并打印出全部内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">  ==&gt; join(&#34;\n&#34;, &#34;Tournament Results:\n&#34;)
  ==&gt; say();</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们就完成了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_运算我们的无点重构">79.56. 运算我们的无点重构</h3>
<div class="paragraph">
<p>让我们来看看整个代码, 谈谈它是如何进行的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">use v6.d;
open(&#39;scores.txt&#39;)
  ==&gt; lines()
  ==&gt; grep(/\s &#39;|&#39; \s/)
  ==&gt; map({
      m/ $&lt;players&gt;=( (\w+)  \s (\w+) )
                       \s    &#39;|&#39;  \s
         $&lt;sets-won&gt;=((\d+) &#39;:&#39; (\d+) )/;
      [$&lt;players&gt;[0], $&lt;sets-won&gt;[0]],
      [$&lt;players&gt;[1], $&lt;sets-won&gt;[1]]
      ==&gt; sort({-.tail}) })
  ==&gt; {%, |$_}()
  ==&gt; reduce(-&gt; %wins, @match-results {
      %wins{@match-results[0;0]}&lt;matches&gt;++;
      for @match-results -&gt; [$name, $sets] {
          %wins{$name}&lt;sets&gt; += $sets;
      }
      %wins })
  ==&gt; kv()
  ==&gt; map(-&gt; $name, %_ { %{:$name, |%_} })
  ==&gt; sort({.&lt;matches&gt;, .&lt;sets&gt;, .&lt;name&gt;})
  ==&gt; reverse()
  ==&gt; map({
      &#34;%s has won %d %s and %d %s&#34;.sprintf(
          .&lt;name&gt;,
          .&lt;matches&gt;, kv-affix(.&lt;matches&gt;:kv),
          .&lt;sets&gt;,    kv-affix(.&lt;sets&gt;:kv) )})
  ==&gt; join(&#34;\n&#34;, &#34;Tournament Results:\n&#34;)
  ==&gt; say();

proto kv-affix((Str, Int) --&gt; Str) {{*}}
multi kv-affix(($_, 1)) { S/e?s$// }
multi kv-affix(($k, $)) { $k }</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么, 我们可以对这段代码说些什么呢？好吧, 32 行代码, 它比 101 版本要长（而且, 尽管这些行很短, 但按字符数计算, 它也更长）。所以这个版本并没有因为简洁而赢得任何奖项。但这从来不是我们的目标。</p>
</div>
<div class="paragraph">
<p>那么, 它在我们最初的目标 - 减少赋值上的表现如何呢？好吧, 如果我们和 Literal Larry 沟通, 我们可以说它的赋值语句为零；它从不使用 my $name = &#39;value&#39; 或类似的语法给变量赋值。相比之下, 101 代码使用 my 给变量赋值的次数超过十次。所以, 从字面上看, 我们成功了。</p>
</div>
<div class="paragraph">
<p>但是, 正如我们已经指出的那样, 忽略解构赋值感觉非常像作弊。同样, 在 regex 中使用命名的捕获, 本质上也是一种赋值/命名的形式。所以, 如果我们采用包容的赋值观点, 101 代码有 15 个赋值, 而我们重构后的代码有 6 个, 所以有很大的下降, 但完全不是数量级的差异。</p>
</div>
<div class="paragraph">
<p>但试图通过计算赋值语句来评估我们的重构, 可能一开始就是一个愚蠢的错误。我真正关心的是 - 我想你也关心的是 - 我们的代码是否清晰。在某种程度上, 这本质上是主观的, 取决于你个人的熟悉程度和喜好 - 在我看来, ==&gt; {%, |$_}() 是非常清晰的。也许, 在我们花了 3 个段落来讨论这一行之后, 你可能会同意；也可能不同意 - 我怀疑我说的任何进一步的话都不会改变你的想法。所以, 从我的角度来看, 重构后的代码看起来更清晰了。</p>
</div>
<div class="paragraph">
<p>但清晰不完全是一个主观的问题。我认为重构后的代码在客观上更加清晰 - 而且正是无指向性风格应该提倡的方式。早在这篇文章的开头, 我就声称编写默写代码有两个主要的好处：它在你的代码中提供了更好的强调, 它减少了你需要在脑海中持有的上下文量, 以理解代码的任何特定部分。让我们逐一来看一下这些。</p>
</div>
<div class="paragraph">
<p>在强调方面, 有一个问题我喜欢问：在全局程序（或模块）作用域有哪些标识符？这些标识符得到了最多的强调；在一个理想的世界里, 它们将是最重要的。在重构后的代码中, 全局范围内根本没有变量, 只有一个项目：kv-affix 函数。这个函数在全局范围内是合适的, 因为它是全球适用的（事实上, 如果这个程序成长起来, 它甚至可以成为一个单独模块的候选对象）。</p>
</div>
<div class="paragraph">
<p>相反, 在 101 代码中, 全局范围的变量是 $file、@names、%matches、%sets 和 @sorted。至少其中大部分都是纯粹的实现细节, 不值得如此重视。而有些（虽然这渗入了下文讨论的&#34;上下文&#34;点）在全局范围内简直令人困惑。全球范围内, @names 指的是什么？那 %matches 呢？(如果我告诉你 <a href="https://docs.raku.org/type/Match">Match</a> 是一个 Raku 类型, 你的答案会改变吗？) %sets 呢？(也是一种 <a href="https://docs.raku.org/type/Set">Raku 类型</a>)。当然, 你可以说这些名字选得不好, 我也不一定不同意。但是想出好的变量名是<a href="https://martinfowler.com/bliki/TwoHardThings.html">出了名的难</a>, 而在全局范围内想出清晰的名字就更难了 - 概念冲突的机会更多。</p>
</div>
<div class="paragraph">
<p>为了真正强调最后一点, 请看一下重构后的最后一行代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">multi kv-affix(($k, $)) { $k }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 $k 这个名字发生在全局上下文中, 那它将是彻头彻尾的不可捉摸。它可能是一个迭代变量 (老派程序员倾向于从 i 开始, 然后转向 j 和 k)。它可能代表<a href="https://en.wikipedia.org/wiki/Kelvin">开尔文度</a>, 或者奇怪的是, 代表<a href="https://en.wikipedia.org/wiki/Coulomb_constant">库仑常数</a>。或者它可以是任何东西, 真的。</p>
</div>
<div class="paragraph">
<p>但因为它的范围比较有限, 所以意思很清楚。这个函数接收一个键值对（通常在 Raku 中用 .kv 方法或 :kv 副词生成）, 并命名为 kv-affix。考虑到这些环境, $k 代表 &#34;key&#34; 一点都不神秘。将项目保留在全局范围之外, 既能提供更好的强调, 又能提供一个不那么混乱的上下文来评估不同名称的含义。</p>
</div>
<div class="paragraph">
<p>我声称无点代码的第二个大的好处是, 它减少了你需要在脑海中持有的上下文/状态的数量, 以理解任何给定的代码。比较这两个脚本也支持这一点。看看 101 代码的最后一行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">say &#34;$n has won %matches{$n} $match-noun and %sets{$n} $set-noun&#34;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在头脑中评估这一行需要你知道 $n（上面 3 行定义）、$match-noun（上面 2 行）、$set-noun（1 行）、%sets（24 行）和 %matches（25 行）的值。考虑到这个脚本是多么的简单, 这是一个需要跟踪的大量状态!</p>
</div>
<div class="paragraph">
<p>相比之下, 重构后的代码的等价部分为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">&#34;%s has won %d %s and %d %s&#34;.sprintf(
    .&lt;name&gt;,
    .&lt;matches&gt;, kv-affix(.&lt;matches&gt;:kv),
    .&lt;sets&gt;,    kv-affix(.&lt;sets&gt;:kv) )</code></pre>
</div>
</div>
<div class="paragraph">
<p>评估这个表达式的值只需要你知道主题变量的值（定义在上面一行）和纯函数 kv-affix（定义在下面 3-5 行）。这并不异常：重构后的代码中每个变量的定义都不超过最后使用它的地方的 5 行。</p>
</div>
<div class="paragraph">
<p>(当然, 以无点风格编写代码既不足以也没有必要限制变量的范围。但正如这个例子所说明的那样—​我的其他经验也证明了这一点—​它肯定有帮助。)</p>
</div>
</div>
<div class="sect2">
<h3 id="_raku_支持实用的而不是纯粹的无点编程">79.57. Raku 支持实用的（而不是纯粹的）无点编程</h3>
<div class="paragraph">
<p>一个真正的无点编程爱好者可能会反对重构后的代码, 理由是它不够默契。尽管避免了明确的赋值语句, 但它还是相当广泛地使用了命名的函数参数和反结构赋值；它并不纯粹。</p>
</div>
<div class="paragraph">
<p>尽管如此, 重构后的代码位于一个实用主义的中间地带, 我发现这个中间地带非常有成效：它是无指向性的, 足以获得这种风格的许多清晰、上下文和强调的好处, 而不害怕使用一两个名字来增加清晰度。</p>
</div>
<div class="paragraph">
<p>而这个中间地带正是乐乐的闪光点（至少在我看来是这样的！）。完全可以把乐写成各种不同的风格, 而且很多风格丝毫不失分寸）。)</p>
</div>
<div class="paragraph">
<p>下面是一些支持实用型无点编程的 Raku 特性（大部分, 但不是全部, 我们在上面看到了）。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.raku.org/language/variables#index-entry-topic_variable">主题变量</a></p>
</li>
<li>
<p><a href="https://docs.raku.org/language/variables#The_%5E_twigil_">形式位置参数</a></p>
</li>
<li>
<p><a href="https://docs.raku.org/type/Block">匿名块</a></p>
</li>
<li>
<p><a href="https://docs.raku.org/language/operators#methodop_.&amp;">调用子例程作为方法</a></p>
</li>
<li>
<p><a href="https://docs.raku.org/language/objects#index-entry-indirect_invocant_syntax">调用方法作为子例程</a></p>
</li>
<li>
<p><a href="https://docs.raku.org/language/operators#infix_%3C==">左 feed</a>和<a href="https://docs.raku.org/language/operators#infix_%3C==">右 feed</a>运算符</p>
</li>
<li>
<p><a href="https://docs.raku.org/type/Signature#index-entry-destructuring_arguments">广泛支持解构</a></p>
</li>
<li>
<p>对 <a href="https://docs.raku.org/language/regexes">regexen</a> 的一流支持</p>
</li>
<li>
<p><a href="https://docs.raku.org/language/functions#Multi-dispatch">multis</a></p>
</li>
<li>
<p><a href="https://docs.raku.org/language/list#Slice_indexing_context">多维数组索引</a></p>
</li>
<li>
<p><a href="https://docs.raku.org/type/Whatever">whatever</a> 和 <a href="https://docs.raku.org/type/WhateverCode">whatever code</a></p>
</li>
<li>
<p><a href="https://docs.raku.org/routine/reduce">reduce</a>(和 <a href="https://docs.raku.org/language/operators#index-entry-%5B%5D_(reduction_metaoperators)_">reduce 元操作符</a>)</p>
</li>
<li>
<p><a href="https://docs.raku.org/routine/zip">zip</a>(和 <a href="https://docs.raku.org/language/operators#index-entry-Z_(zip_metaoperator)">zip 元操作符</a>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你已经是一个 Raku 专家, 我希望这个列表和这篇文章能给你一些其他方法的想法。如果你是 Raku 的新手, 我希望这篇文章能让你兴奋地探索一些 Raku 可以扩展你编程的方式。如果你对写 Raku 代码完全不感兴趣 - 好吧, 我希望你会重新考虑, 但即使你不感兴趣, 我也希望这篇文章给你一些思考, 并给你留下一些想法, 让你在你选择的语言中尝试。
== <a href="https://raku-advent.blog/2020/12/22/day-23-christmas-oriented-design-and-implementation/">第二十三天 - 面向圣诞的设计和实现, 第一部分</a></p>
</div>
<div class="paragraph">
<p>每年到了1月8日北极开学的时候, 在每一个版本的圣诞送礼精神都巡视过后, 圣诞老人需要坐下来安排北极社区学院的课程。这些精灵们需要持续的教育, 他们需要真正学习那些新奇的玩具, 除了行业工具和技能之外。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>另外, 让这些精灵们在这一年里都忙于一些实际有用的事情, 也是一件好事, 以免他们开始发明一些实用的笑话, 然后互相玩弄。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>既然有一百多万的精灵, 那么全国政协就很庞大了。但是分配课程到教室也是个大问题。报名开课后, 他们就互相讨论什么是终极吹风课, 哪门课打雪仗赢了就给你加分。所以, 你不能随便充值报名：每年都要查看可用教室, 然后匹配到最够用的教室。</p>
</div>
<div class="paragraph">
<p>下面是可用教室。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Kris, 33
Kringle, 150
Santa, 120
Claus, 120
Niklaas, 110
Reyes Magos, 60
Olentzero, 50
Papa Noël, 30</code></pre>
</div>
</div>
<div class="paragraph">
<p>他们以世界各地的送礼神灵命名, 其中最大的班级显然叫 Kringle。在任何一年, 这可能是报名期结束后的报名情况。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Woodworking 101, 130
Toymaking 101, 120
Wrapping 210, 40
Reindeer speed driving 130, 30
ToyOps 310, 45
Ha-ha-haing 401, 33</code></pre>
</div>
</div>
<div class="paragraph">
<p>他们喜欢《木工 101》, 因为它是入门级的, 而且他们可以保留一年中做的任何任务。另外, 你还可以得到所有的木头刨花, 用于在你的炉子里燃烧, 这在一个常年寒冷的地方是非常有用的。</p>
</div>
<div class="paragraph">
<p>于是圣诞老人就制作了这个脚本来处理, 用了一点<a href="https://raku-advent.blog/2020/12/22/draft-whats-the-point-of-point-free-programming/">无点编程</a>, <a href="https://raku-advent.blog/2020/08/20/rfc-28-by-simon-cozens/">Perl 就是 Perl</a>, 是 Perl 和 Raku 这两种姐妹语言的鞭策和刁难。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">sub read-and-sort( $file where .IO.e ) {
    $file.IO.lines
      ==&gt; map( *.split( /&#34;,&#34;\s+/) )
      ==&gt; sort( { -$_[1].Int } )
      ==&gt; map( { Pair.new( |@_ ) } )
}

say (read-and-sort( &#34;classes.csv&#34;) Z read-and-sort( &#34;courses.csv&#34;))
    .map( {  $_.map( { .key } ).join( &#34;\t→\t&#34;) }  )
    .join( &#34;\n&#34; )</code></pre>
</div>
</div>
<div class="paragraph">
<p>该子程序读取给定名称的文件, 检查之前是否存在, 用逗号将其分割, 按数量递减排序, 然后从其中创建一个 Pair。另一个命令使用 <a href="https://docs.raku.org/routine/Z">Z 操作符</a>将两个列表按照精灵数量递减的顺序压缩在一起, 并生成一个和这个列表一样的列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Kringle →   Woodworking 101
Santa   →   Toymaking 101
Claus   →   ToyOps 310
Niklaas →   Wrapping 210
Reyes Magos →   Ha-ha-haing 401
Olentzero   →   Reindeer speed driving 130</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以克林格讲堂得到了木工, 从那里开始往下走。Kris 和 Papa Noël 教室什么都没有得到, 已经被淘汰了, 但却被保留在那里用于课外活动, 比如唱颂歌和折纸。</p>
</div>
<div class="paragraph">
<p>所有这一切都很好, 而它：只要你还记得哪里是文件, 脚本做了什么, 没有什么改变名称或容量, 文件不会丢失。但这些都是很多的如果, 而且圣诞老人也不再年轻了。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>事实上, 也不会变老。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>所以圣诞老人和它的 ToyOps 团队将需要一个更系统的方法来处理这个调度, 从需求中创建一个面向对象的应用程序。在学习了 <a href="https://raku-advent.blog/2020/12/11/day-11-santa-claus-tweaks-with-a-class/#fn-3">TWEAKS</a>和<a href="https://raku-advent.blog/2020/12/21/the-story-of-elfs-and-roles-and-santas-enterprise/">角色</a>的所有知识后, 现在是时候站在后面, 从一开始就把它用到工作上了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_敏捷调度">79.58. 敏捷调度</h3>
<div class="paragraph">
<p>弥漫在北极的寒冷让一切都变得不那么敏捷。不过不用担心, 当我们在那里为 IT 运营创造一些东西的时候, 我们仍然可以做到敏捷。首先我们需要的是<a href="https://www.atlassian.com/agile/project-management/user-stories">用户故事</a>。谁想创建一个时间表, 它是什么？所以我们坐下来把它们写下来。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[US1] 作为 NPCC 的院长, 鉴于我有一个教室的列表（以及它们的容量）和课程的列表（以及它们的注册人数）, 我想以最好的方式将教室分配给课程。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>好的, 我们在这里得到了一些工作, 所以我们可以应用<a href="https://en.wikipedia.org/wiki/Domain-driven_design">一点领域驱动设计</a>。我们有几个实体, 教室和课程, 还有几个值对象：单教室和单课程。让我们去写它们。当然, 使用 Comma。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/JJ/raku-aulas/blob/master/docs/classes.png" alt="classes"/>
</div>
</div>
<div class="paragraph">
<p>用类来定义类是很自然的事情。但看着这两个定义好的类, 圣诞老人也说不出哪个是哪个。说到底, 有名字有容量的东西就是有名字有容量的东西。这就要求我们按照 DRY（不要重复）原则, 将常用代码进行保理。</p>
</div>
<div class="paragraph">
<p>另外, 我们上面有一个原型, 几乎可以说, 不管我们用什么教室和课程, 如果能用同样的方式来排序, 我们的生活会更轻松。所以, 我们最好的办法可能是用常见的行为分拆出一个角色。我们做一个问题出来。和美国差不多, 但是主角要做程序员。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>作为一个程序员, 我需要用同样的方法, 按容量对教室和课程进行分类。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>就叫 Capped 吧, 就像有一定的容量一样。因为这两个对象会有自带的方法 - capacity, 所以我们可以调用它来进行排序。我们上面的例子表明, 我们需要用几个元素创建一个对象, 所以这又是一个问题。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>作为一个程序员, 我需要使用位置参数建立一个对象, 这些参数是字符串。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所以最后我们的角色会有这些东西。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">unit role Cap;

has Str $!name is required;
has Int $!capacity is required;

submethod new( Str $name, Int $capacity ) {
    self.bless( :$name, :$capacity )
}

submethod BUILD( :$!name, :$!capacity ) {};

method name() { $!name }
method capacity() { $!capacity }</code></pre>
</div>
</div>
<div class="paragraph">
<p>再加上方便的 <strong>name</strong> 和 <strong>capacity</strong> 的访问器, 在保持这些私有物的同时, 也意味着它们是不可改变的。值对象是简单地得到一个值的东西, 没有太多的业务逻辑。</p>
</div>
<div class="paragraph">
<p>我们已经可以创建一个函数来完成教室/课程列表的排序, 也就是 Caps, 但在 OO 设计中, 我们应该尽量把原来问题中的实体放到类中（从中衍生出对象）。这些实体将是真正做重活的实体。</p>
</div>
<div class="paragraph">
<p>如果我们能创造出还算相同的东西, 那就太好了, 因为我们将能统一地处理它们。但是有一个难题：其中一个将包含一个课程列表, 另一个将包含一个教室列表。它们都是做 Cap 的, 所以原则上我们可以创建一个类来承载 Cap 的列表。但是这个控制器类会有一些业务逻辑：它将创建该类的对象；我们不能简单地使用 Roles 来创建组成它们的类。所以我们将使用一个 <a href="https://docs.raku.org/type/Metamodel::CurriedRoleHOW">curried Role</a>, 一个参数化的角色, 使用我们将实例化的角色作为参数。这将是 Cap-List。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">unit role Cap-List[::T];

has T @!list;

submethod new( $file where .IO.e ) {
    $file.IO.lines
            ==&gt; map( *.split( /&#34;,&#34;\s+/) )
            ==&gt; map( { T.new( @_[0], +@_[1] ) } )
            ==&gt; sort( { -$_.capacity } )
            ==&gt; my @list;
    self.bless( :@list );
}
submethod BUILD( :@!list ) {}

method list() { @!list }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码很熟悉, 和我们上面所做的类似, 只是我们把创建对象和排序列表换了一下, 我们用 <strong>.capacity</strong> 对列表进行排序。我们创建一个列表并将其祝福(<strong>bless</strong>)到对象中。从中, 我们创建了几个类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">unit class Classroom-List does Cap-List[Classroom];
unit class Course-List does Cap-List[Course];</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们不需要更多的逻辑, 这就是全部。基本上是同样的事情, 同样的业务逻辑, 但我们以类型安全的方式工作。我们也已经<a href="https://github.com/JJ/raku-aulas">测试了整个事情</a>, 所以我们已经冻结了 API, 并保护它免受未来的进化。圣诞老人也会同意的。</p>
</div>
<div class="paragraph">
<p>所以我们就快完成了。让我们用这个来写赋值函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">my $courses = Course-List.new( &#34;docs/courses.csv&#34;);
my $classes = Classroom-List.new( &#34;docs/classes.csv&#34;);
say ($classes.list Z $courses.list )
        .map( {  $_.map( { .name } ).join( &#34;\t→\t&#34;) }  )
        .join( &#34;\n&#34; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将返回和我们之前一样的东西。但我们已经把所有的业务逻辑（排序, 以及其他任何我们可能想要的东西）都隐藏在对象囊中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_但是_我们有吗">79.59. 但是, 我们有吗？</h3>
<div class="paragraph">
<p>其实不然。赋值也应该被封装在某个类中, 并进行彻底的测试。不过, 这要留待下次再谈。
== <a href="https://raku-advent.blog/2020/12/24/bonus-article-christmas-oriented-programming-part-deux/">第二十四天 - 面向圣诞的设计和实现, 第二部分</a></p>
</div>
<div class="paragraph">
<p>在<a href="https://raku-advent.blog/2020/12/22/day-23-christmas-oriented-design-and-implementation/">上一期的系列文章</a>中, 我们从一个简单的脚本开始, 我们希望用 <a href="https://raku.org/">Raku</a> 来得出一个合理的面向对象的设计。</p>
</div>
<div class="paragraph">
<p>我们（重新）的出发点是这个用户故事。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>[US1] 作为一个 NPCC 院长, 我有一个教室列表（及其容量）和课程列表（及其注册人数）, 我想以最好的方式将教室分配给课程。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>于是我们就得出了这个脚本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">my $courses = Course-List.new( &#34;docs/courses.csv&#34;);
my $classes = Classroom-List.new( &#34;docs/classes.csv&#34;);
say ($classes.list Z $courses.list )
        .map( {  $_.map( { .name } ).join( &#34;\t→\t&#34;) }  )
        .join( &#34;\n&#34; );</code></pre>
</div>
</div>
<div class="paragraph">
<p>但这并不能真正解决这个问题。每一个用户故事都必须通过一套测试来解决。但是, 好吧, 用户故事一开始就挺模糊的。&#34;以最好的方式&#34;可以是任何东西。所以可以说, 我们所做的方式, 确实是最好的方式, 但是没有测试, 我们真的不能说。所以我们重新表述一下 US。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>[US1] 作为 NPCC 的院长, 既然我有一份教室的清单（及其容量）和课程的清单（及其招生人数）, 我就想把教室分配给课程, 让所有的课程都没有教室, 所有的课程都适合在一个教室里上课。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>这是我们可以坚持的。但当然, 脚本是不能测试的（好吧, <a href="https://github.com/JJ/perl6-test-script-output">可以</a>, 但这是另一个故事）。所以, 让我们给这个脚本上点课吧。</p>
</div>
</div>
<div class="sect2">
<h3 id="_躲开它与列表">79.60. 躲开它与列表</h3>
<div class="paragraph">
<p>其实, 在上面的脚本中, 有一些东西并没有真正的切入。在原脚本中, 你把几个列表压缩在一起。在这里, 你需要调用 .list 方法来实现同样的目的。但是对象还是一样的, 对吗？把两个对象压缩在一起不应该是可以的, 也是简单的吗？另外, 这就要求类的客户端要知道实际的实现。一个对象应该尽可能的隐藏它的内部结构。让我们把这个问题作为一个问题来解决</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>作为一个程序员, 我希望持有课程和教室的对象在 &#34;zipping&#34; 的上下文中表现得像一个列表一样。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>圣诞老人揉着自己的胡子, 想着如何把这个事情做出来。Course-List 对象, 嗯, 就是那种精确的对象。它们包含了一个列表, 但是, 它们怎么能表现为一个列表呢？而且, &#34;在 zipping 上下文中&#34;, 什么才是精确的列表。</p>
</div>
<div class="paragraph">
<p>长话短说, 他想明白了, 一个 &#34;zipping context&#34; 其实是迭代两个列表中的每一个成员, 依次把它们放在一起。所以我们需要把对象做成 <a href="https://docs.raku.org/type/Iterable">Iterable</a>。幸运的是, 这一点你在 Raku 中绝对可以做到。通过混合角色, 你可以让对象以某种其他方式表现出来, 只要你有这样的机制。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">unit role Cap-List[::T] does Iterable;

has T @!list;

submethod new( $file where .IO.e ) {
    $file.IO.lines
            ==&gt; map( *.split( /&#34;,&#34;\s+/) )
            ==&gt; map( { T.new( @_[0], +@_[1] ) } )
            ==&gt; sort( { -$_.capacity } )
            ==&gt; my @list;
    self.bless( :@list );
}
submethod BUILD( :@!list ) {}

method list() { @!list }

method iterator() {@!list.iterator}</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于原来的版本, 我们只是混入了 Iterable 的角色, 实现了一个迭代器方法, 在 @!list 属性上返回迭代器。然而, 这并不是我们在 &#34;zipping 上下文&#34;中唯一需要的东西。这就引出了一个关于 Raku 容器和绑定的小题材。</p>
</div>
</div>
<div class="sect2">
<h3 id="_容器和_containees">79.61. 容器和 containees</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>El cielo esta entablicuadrillado, ¿quién lo desentablicuadrillará? El que lo entablicuadrille, buen entablicuadrillador será. — 西班牙语绕口令, 通俗地翻译为 “The sky is tablesquarebricked, who will de-trablesquarebrick it? The tablesquarebrickalyer that tablesquaresbricks it, good tablesquarebrickalyer will be.</p>
</div>
</blockquote>
</div>
<div class="imageblock">
<div class="content">
<img src="https://camo.githubusercontent.com/0c710725348991283e250f3de0896cbd288b6775c8eaa953341ddea50ef825c3/68747470733a2f2f6c6976652e737461746963666c69636b722e636f6d2f353630372f33313734313735353638365f376537666432623838335f6b5f642e6a7067" alt="container"/>
</div>
</div>
<div class="paragraph">
<p>值得一看的是 <a href="https://perl6advent.wordpress.com/2017/12/02/perl-6-sigils-variables-and-containers/">Zoffix Znet 的这篇 Advent 旧文</a>, 关于什么是绑定, 什么是赋值, 在 Raku 世界里。绑定本质上是用另一个名字来调用一个对象。如果你把一个对象绑定到一个变量上, 那么这个变量的行为就会和这个对象完全一样。反之亦然。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">my $courses := Course-List.new( &#34;docs/courses.csv&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们只是用另一个名字来调用这个绑定的右侧, 这样更短, 更方便。我们可以调用任何方法, 也可以通过在其上调用 for 来把这个&#34;放在 zipping 上下文中&#34;。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">.name.say for $courses;</code></pre>
</div>
</div>
<div class="paragraph">
<p>会返回:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">Woodworking 101
Toymaking 101
ToyOps 310
Wrapping 210
Ha-ha-haing 401
Reindeer speed driving 130</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你所看到的, &#34;zipping 上下文&#34;与（尚未被记录的）<a href="https://github.com/Raku/doc/issues/1225">可迭代上下文</a> 完全相同, 当与 for 一起使用时, 它也会被调用（或胁迫对象进入, 不管你喜欢什么）。for $courses 实际上会调用 $courses.iterator, 返回它包含的列表的迭代器。</p>
</div>
<div class="paragraph">
<p>这其实并不是离题, 这完全是题外话。然而, 我不得不离题, 以解释在我们使用正常赋值的情况下会发生什么, 如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">my $boxed-courses = Course-List.new( &#34;docs/courses.csv&#34;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>赋值是 Raku 中一个很好很奇特的东西。就像<a href="https://perl6advent.wordpress.com/2017/12/02/perl-6-sigils-variables-and-containers/">上面提到的文章所说的那样</a>, 它把一个对象框进一个容器里。你不能轻易地把任何一种东西框进 Scalar 容器里, 所以, <a href="https://es.wikipedia.org/wiki/Procusto">Procusto 风格</a>的它需要以某种方式把它装进容器里。但无论你怎么想, 事实上, 与之前不同的是, $boxes-courses 并不是一个 Course-List 对象, 它是一个 Scalar 对象, 它将一个 Course-List 对象进行了标量化, 或者说项目化。你需要什么来去掉它的标量化呢？简单的调用它的 <a href="https://docs.raku.org/routine/%3C%3E">de-cont 操作符</a>, $boxed-courses&lt;&gt;, 它可以解开容器并给你里面的东西。</p>
</div>
</div>
<div class="sect2">
<h3 id="_调度器类">79.62. 调度器类</h3>
<div class="imageblock">
<div class="content">
<img src="https://camo.githubusercontent.com/f451869a787e3c44443ab77248bbec93ca428491021a9be451b9970137fb31a3/68747470733a2f2f6c6976652e737461746963666c69636b722e636f6d2f39322f3234343030383935345f636566663032363563375f6b5f642e6a7067" alt="68747470733a2f2f6c6976652e737461746963666c69636b722e636f6d2f39322f3234343030383935345f636566663032363563375f6b5f642e6a7067"/>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>好了, 回到我们的常规日程…​…​r。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>再次强调, 不要让我们只想按部就班地做事。我们需要创造一个问题来解决</p>
</div>
<div class="ulist">
<ul>
<li>
<p>作为一个程序员, 我需要一个类来创建时间表, 给定几个带有课程和类的文件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>圣诞老人很乐意证明这样的事情。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">use Course-List;
use Classroom-List;

unit class Schedule;

has @!schedule;

submethod new( $courses-file where .IO.e,
               $classes-file where .IO.e) {

    my $courses := Course-List.new($courses-file);
    my $classes := Classroom-List.new($classes-file);
    my @schedule = ($classes Z $courses).map({ $_.map({ .name }) });
    self.bless(:@schedule);
}

submethod BUILD( :@!schedule ) {}

method schedule() { @!schedule }

method gist {
    @!schedule.map( { .join( &#34;\t⇒\t&#34; ) } ).join(&#34;\t&#34;);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它不仅可以安排课程, 你只要说出来就可以使用。它还经过了测试, 所以你知道无论如何它都会工作。就这样, 我们可以结束用户故事了。</p>
</div>
<div class="paragraph">
<p>但是, 我们可以吗？</p>
</div>
</div>
<div class="sect2">
<h3 id="_用脚本收尾">79.63. 用脚本收尾</h3>
<div class="paragraph">
<p>圣诞老人对这个新应用真的很满意。他只需要写这个小的主脚本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl6" data-lang="perl6">use Schedule;

sub MAIN( $courses-file where .IO.e = &#34;docs/courses.csv&#34;,
          $classes-file where .IO.e = &#34;docs/classes.csv&#34;) {
    say Schedule.new( $courses-file, $classes-file)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是直奔主题的：这里是文件, 这里是时间表。但是, 除此之外, 它是经过测试的, 为突发事件做了准备, 实际上还可以进行扩展, 以考虑到突发事件（如果你无法将精灵装入某个类目会怎样？如果你需要考虑到其他限制条件, 比如不先装最大的, 而是先装smuggest怎么办？你可以直接改变算法, 甚至不用改变这个主脚本。你其实并不需要。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku -Ilib -MSchedule -e &#34;say Schedule.new( | @*ARGS )&#34; docs/courses.csv docs/classes.csv</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用库搜索路径的命令行开关（-I）和加载模块（-M）, 你可以只写一个语句, 将参数和扁平化, 使它们成为方法的签名。</p>
</div>
<div class="paragraph">
<p>做完这些, 圣诞老人坐在他最喜欢的扶手椅上, 享受着一杯桶装蛋酒, 看着每一部正在流传的圣诞老人主题电影, 直到下一个 NPCC 学期开始。
== Raku 中的异步和并发入门</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/01/introducing-async-concurrency-in-raku/cover-dmitrii-vaccinium-Q47eNv_UvfM-unsplash_huc21c1d46fd3ec96fb42a3a0ab1e6a4ce_1773515_280x280_fill_q75_box_smart1.jpg" alt="Introducing Async &amp; Concurrency in Raku"/>
</div>
</div>
<div class="paragraph">
<p>从今天之后的23天里, 在我们进入这个降临日历之前, 我想确保介绍一下我将要涉及的基本概念。我把它称为 &#34;Raku Async &amp; Concurrency Advent Calendar&#34;, 但这些术语是什么意思呢, 它们又是如何应用于 Raku 的呢？</p>
</div>
<div class="paragraph">
<p>这个 Advent Calendar 的前提是你对 Raku 有基本的了解。如果你不了解 Raku, 但你熟悉另一种语言, 我相信你可能会跟得上。然而, 这是针对中高级开发者的, 所以我推荐你先从这些资源中学习 Raku。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://shop.oreilly.com/product/0636920062776.do">Perl 6 入门</a>(Raku 是以前称为 Perl 6 的语言)</p>
</li>
<li>
<p><a href="https://learnxinyminutes.com/docs/perl6/">用 Y 分钟学习 Raku</a></p>
</li>
<li>
<p><a href="https://raku.guide/">Raku 指南</a></p>
</li>
<li>
<p><a href="https://docs.raku.org/language.html">Raku 文档</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_异步编程">79.64. 异步编程</h3>
<div class="paragraph">
<p>Async 是异步编程的简称, 因为异步(asynchronous)的输入很麻烦。异步编程是一种编程风格, 对函数的调用与其返回是脱节的。通常, 我们会写一个这样的函数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub double($x) { $x * 2 }
my $val = double(21);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们想把这段代码变成异步的, 我们可以尝试这样做:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub double($x) { sub () { $x * 2 } }
my $promise = double($x);
# more code
# ...
# more code
my $val = $promise.();</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个愚蠢的人为的例子, 但重点是我们实际上要到后来才会收到值。这种编程风格主要是在你知道你需要完成一些工作, 但不需要立即得到结果的时候有用。当你可能需要在此期间做其他工作时, 这种方式尤其有用。</p>
</div>
<div class="sect3">
<h4 id="_什么时候才有意义">79.64.1. 什么时候才有意义？</h4>
<div class="paragraph">
<p>举几个例子说明异步可能会有帮助的情况。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>所有基于套接字的客户端/服务器应用程序都必须是异步的。对于 TCP 来说, 在服务器上, 你建立一个监听套接字, 然后当客户端连接时, 你会收到一个连接的套接字, 你可以在这个套接字上使用读写操作交换数据。而 TCP 客户端则是请求一个连接, 然后等待服务器接受连接。在等待的过程中, 客户端可以继续进行工作。</p>
</li>
<li>
<p>一个实时处理日志数据的程序通常有几个处理步骤, 每一行都要经过。它等待数据的到达。它解析每一行数据, 从中获取有趣的信息。它对数据进行过滤, 以决定它是否对当前任务有用。它对数据进行计算。这些操作中的每一项都可以在异步编程链中执行, 其中每一步只要有一定量的数据准备好了, 就会执行这些操作。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>异步只是一种编程风格, 它适合于你, 软件开发者, 决定它适合的地方。有些问题比其他问题更具有内在的异步性, 但你也可以同步地构建它们。当它适合你的时候就使用异步(async)。</p>
</div>
</div>
<div class="sect3">
<h4 id="_工具有哪些">79.64.2. 工具有哪些？</h4>
<div class="paragraph">
<p>在 Raku 中, 异步编程主要是通过高级的、&#34;可组合&#34;的接口来进行的, 比如 <a href="https://docs.raku.org/type/Promise">Promise</a>, <a href="https://docs.raku.org/type/Supply">Supply</a> 和 <a href="https://docs.raku.org/type/Channel">Channel</a>。这些都是高级的, 因为它们提供了一个针对某人的接口, 而不需要严格证明这些工具如何使用的安全性。你仍然要小心, 这是肯定的, 但陷阱减少了很多, 从它们的接口上看应该更明显。它们是可组合的, 因为它们的设计是为了让你把使用这些接口的不同库, 以可预测的方式一起使用。</p>
</div>
<div class="paragraph">
<p>另一方面, 像 <a href="https://docs.raku.org/type/Lock">Lock</a> 和 <a href="https://docs.raku.org/type/Semaphore">Semaphore</a> 这样的低级工具, 当使用这些工具的不同库组合在一起时, 会导致不可预测的行为。这些在 Raku 中也是可用的, 因为有时你需要用它们来构建, 但它们不是 Raku 的异步编程的万金油。</p>
</div>
</div>
<div class="sect3">
<h4 id="_它是什么样子的呢">79.64.3. 它是什么样子的呢？</h4>
<div class="paragraph">
<p>那么 Raku 中的异步编程是什么样的呢？这里有一个基本的计数程序, 但我们不使用循环, 而是每秒钟输出一个数字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    whenever Supply.interval(1) -&gt; $n {
        say $n;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这在功能上等同于运行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 1...* -&gt; $n {
    say $n;
    sleep 1;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见, 语法非常简单, 希望容易上手。你甚至可以认为它算是同步的, 而不会遇到太多麻烦。Raku 中的异步编程的一个目标是让那些不完全理解它的人至少能理解发生了什么。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_并发编程">79.65. 并发编程</h3>
<div class="paragraph">
<p>我在大学里上过一门关于并发编程的课。恐怕我没有很好地掌握这个主题就通过了这门课。然而, 我认为部分原因是因为它是一个很难真正理解的概念, 通过掀开引擎盖, 看看所有的运动部件。不过, 也有一部分原因是因为这门课用数学术语来教授并发性, 而我发现实用术语更容易理解。</p>
</div>
<div class="paragraph">
<p>并发编程仅仅是同时运行程序的各个部分的行为。程序中可以同时运行的部分称为线程。你可以把线程视为程序可以在其中运行其代码的通道。例如, 每个线程可能使用不同的起始数据运行同一个程序代码。或者, 一个程序可以有一个线程用于更新图形界面, 一个线程用于与网络上的其他程序对话, 一个线程用于对接收到的数据进行本地处理。</p>
</div>
<div class="sect3">
<h4 id="_裸机线程">79.65.1. 裸机线程</h4>
<div class="paragraph">
<p>分道运行可以通过多种方式实现, 包括:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在单 CPU/单核计算机上, CPU 会将需要同时进行的代码交错执行。代码实际上并不是同时运行, 而是每个程序的每个线程都有时间在 CPU 上运行一些指令, 然后进行上下文切换, 运行另一个线程。</p>
</li>
<li>
<p>在多 CP​​U/多核计算机上, 这既意味着在每个 CPU 核心上交错运行代码, 也意味着在每个核心上同时在不同的硬件上运行各种程序和线程。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>无论如何, 你都会遇到一个问题, 即任何给定线程中的代码可能只完成了任务的一小部分, 因此你需要确保线程之间安全地交互。这就是所谓的&#34;线程安全代码&#34;。</p>
</div>
</div>
<div class="sect3">
<h4 id="_线程安全">79.65.2. 线程安全</h4>
<div class="paragraph">
<p>构建线程安全代码有几种基本的编程风格。我在这里从最喜欢到最不喜欢的风格来介绍它们:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>任何无状态的代码或者只有自身内部状态变化的代码本质上都是线程安全的。只有当代码需要访问其他代码可能使用的数据时, 它才会变得不安全。</p>
</li>
<li>
<p>通常情况下, 可以将代码写成内部是无状态的, 但在完成执行时执行状态更改。只要某些内容以安全的方式同步状态更新, 这种数据转换就是线程安全的。执行转换的代码本身不必对安全性做出任何特殊规定。</p>
</li>
<li>
<p>对于必须在执行线程之间共享某些可变状态的情况, 每次读取和写入数据时都必须格外小心, 以确保这些更改不会破坏状态。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Raku 提供了专门的工具来处理这些情况。每当编写并发程序时, 都应该尽可能地瞄准前两种编码风格。这些是最容易理解和维护的。然而, 第三种选择有时是最好的</p>
</div>
</div>
<div class="sect3">
<h4 id="_raku_之道">79.65.3. Raku 之道</h4>
<div class="paragraph">
<p>在 Raku 中, 我们不倾向于直接使用线程。取而代之的是, 我们调度代码块异步运行。代码的实际运行方式取决于所使用的调度程序。Rakudo 上的默认调度程序会将代码块调度到主线程之外的单独线程上运行。<sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup></p>
</div>
<div class="paragraph">
<p>调度要运行的块的主要方法是使用 <code>start</code> 块, 类似于下面的示例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">start {
    # Subtask 1
}
start {
    # Subtask 2
}
# Main task</code></pre>
</div>
</div>
<div class="paragraph">
<p>我个人将根据这种方式或通过其他方式安排的工作称为&#34;任务&#34;(task)或&#34;子任务&#34;(subtask), 这取决于上下文。不过这不是 Raku 主义, 所以要注意其他人的术语可能会有所不同。</p>
</div>
<div class="paragraph">
<p>总之, 主要的一点是, 并发是指同时运行你的代码的两个不同部分。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_并行编程">79.66. 并行编程</h3>
<div class="paragraph">
<p>我们在本日历中经常使用的第三个术语是并行编程。并行编程与并发性非常相似, 但主要面向并行处理数据。例如, 如果你有大量的整数, 你想通过一个函数来运行, 你可以为对这些整数中的每一个整数都并发地执行该操作。这是并行编程。</p>
</div>
<div class="paragraph">
<p>它是与异步(async)或并发是一个独立的术语, 原因有二。其一, 并行程序不一定是并发或异步的, 其二, 有一些与并行编程相关的特殊优化, 它们不一定是通用并发或异步的一部分。</p>
</div>
<div class="paragraph">
<p>例如, 这是 Raku 中的一个小型并行程序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @doubles = (1...10_000_000).hyper.map(* * 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>当这个程序运行时, Raku 会安排任务在多个线程中运行, 对范围内的所有值进行迭代, 并将所有1000万个值全部分批翻倍。把工作分为几批, 然后选择如何调度, 这就是并行编程本身的特殊主题。这个程序可能是并发的, 但它不是异步的。我们也可以异步地进行并行编程, 但在这个例子中我们并没有。</p>
</div>
</div>
<div class="sect2">
<h3 id="_编程编程">79.67. 编程编程</h3>
<div class="paragraph">
<p>所以, 当我们把这些术语放在一起的时候, 我们会发现一个程序可能具有所描述的三种属性中的任何一种。它可能是并发的, 异步的和并行的。它可能不具备这些特性。它可能只是其中的一个或两个, 任意组合。这些都是不同的编程风格。</p>
</div>
<div class="paragraph">
<p>Raku 提供的工具旨在使你的代码在异步、并发和并行地编写时更容易阅读。它还旨在鼓励你以一种固有的线程安全的方式编写你的代码, 允许你在多个线程中同时操作时安全地转换状态。</p>
</div>
<div class="paragraph">
<p>我希望在接下来的23天里, 我将更好地让你决定何时拥抱Raku的每一个特性, 以及如何以一种让你的代码更快, 同时又易于人类解析和理解的方式进行。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/archive/2019/12/01/introducing-async-concurrency-in-raku.html" class="bare">https://zostay.com/archive/2019/12/01/introducing-async-concurrency-in-raku.html</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_promise">80. Promise</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 中, <a href="https://zostay.com/archive/2019/12/02/promises.html">Promise</a> 代表了异步任务之间通信的最简单的高级语言功能。它们很像人与人之间的承诺。例如, 我可能会答应我的儿子, 我会帮助他完成学业。当我帮助他的时候, 我就会遵守这个承诺。或者, 如果由于某种原因, 我未能帮助他, 我就会违背这个承诺。Raku 中 的 Promise 也是如此。当一个值到达的时候, 返回一个值的承诺(Promise)就会被遵守。如果发生了错误, 阻止了值的到达, 那么返回值的承诺(Promise)就会被打破。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/02/promises/cover-korie-cull-f3gcUmrR4eQ-unsplash_hu4feb791eb4e6207b9aa233eb6f7c17b5_2502682_280x280_fill_q75_box_smart1.jpg" alt="Promise"/>
</div>
</div>
<div class="paragraph">
<p>所以, 让我们来看看 Raku 中的基本承诺:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = start {
    my $nth = 0;
    my $nth-prime;
    for 1..* -&gt; $number {
        $nth++ if $number.is-prime;
        if $nth == 10_000 {
            $nth-prime = $number;
            last;
        }
    }
    $nth-prime;
}
await $promise.then({ say .result });</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码使用 <a href="https://docs.raku.org/language/control#index-entry-control_flow_start-start">start</a> 块开始查找第 10000 个素数。这个块返回一个  <a href="https://docs.raku.org/type/Promise">Promise</a> 对象。这个对象以三种状态之一存在(你可以用 <code>.status</code> 方法检查）。初始状态为 <strong>Planned</strong> 状态, 然后它进入两种最终状态中的一种。如果无法得到一个结果(通常是因为发生了异常), 则进入 <strong>Broken</strong> 状态, 而当结果可用时, 则进入 <strong>Kept</strong> 状态。一旦处于 <strong>Kept</strong> 状态, <code>.result</code> 方法将立即返回被保存的 <code>Promise</code> 的值。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>.then</code> 方法将 Promise 链在一起。这是通过添加另一个块来实现的, 该块在第一个块保留后立即开始。新的块将被赋予前一个 Promise 对象作为参数, 该方法返回一个新的 Promise, 该 Promise 将包含下一个块的结果。</p>
</div>
<div class="paragraph">
<p>上面代码中的 <code>start</code> 块将计算安排在默认线程池中的下一个未使用的线程上运行, 并返回一个 Promise 对象。<sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup> 我们使用 <code>.then()</code> 来输出计算的 <code>.result</code>, 只要它可用。</p>
</div>
<div class="paragraph">
<p>最后, 我们有一个 <a href="https://docs.raku.org/type/Promise#sub_await">await</a> 语句, 该语句使主线程暂停, 直到值变得可用。如果没有这条语句, 我们的程序会在计算完成之前结束。</p>
</div>
<div class="paragraph">
<p><code>await</code> 语句还允许一个被破坏的 Promise 传递异常。考虑一下这段代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = start { die &#39;bad stuff&#39; }
sleep 1;
say &#39;something&#39;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码会休眠 1 秒钟, 并打印 &#34;something&#34; 到标准输出。然而, 异常永远不会被接收到。这是因为尽管异常会导致 Promise 被破坏, 但我们根本没有看到 Promise 的结果。我们可以在 Promise 上添加一个 <code>await</code>, 准备好接收该值, 任何抛出的导致 Promise 被破坏的异常都会被接收。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = start { die &#39;bad stuff&#39; }
sleep 1;
say &#39;something&#39;;
await $promise;
CATCH {
    default {
        say &#34;ERROR: $_.message()&#34;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码和之前做的事情完全一样, 但是在 &#34;something&#34; 后面也会输出 &#34;ERROR: bad stuff&#34;。一定要确保在 <code>start</code> 块内部或者在另一个以这种方式接收 Promise 的块中处理你的异常, 否则你可能最终会遇到奇怪的意外问题。</p>
</div>
<div class="paragraph">
<p>这些都是 Raku Promise 的基本要素。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/02/promises/" class="bare">https://zostay.com/posts/2019/12/02/promises/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_supply_块">81. Supply 块</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/03/supply-blocks/cover-alexander-schimmeck-vKyp17kj31w-unsplash_huafe518bf6a9b466ef820c1441343f08e_5154826_280x280_fill_q75_box_smart1.jpg" alt="Supply Blocks"/>
</div>
</div>
<div class="paragraph">
<p>当你的 Raku 应用程序中流过需要在线程间安全地访问的数据流时, 你需要 <a href="https://docs.raku.org/type/Supply">Supply</a>。今天, 我们将讨论一种特殊的使用供应的方式, 即 <a href="https://docs.raku.org/syntax/supply%20emit">supply</a> 块。如果你熟悉序列, 也就是 <a href="https://docs.raku.org/type/Seq">Seq</a> 对象, <code>supply</code> 块的工作方式与之非常相似, 但是允许你在数据到来时拉动它, 并在这期间轻松地做其他事情。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi a(1) { 1 }
multi a(2) { 2 }
multi a($n where $n &gt; 2) { a($n - a($n-1)) + a($n - a($n-2)) }

my $hofstadter-generator = supply {
    for (1 ... *).map(-&gt; $n { a($n) }) -&gt; $v {
        emit $v;
    }
}

react {
    whenever $hofstadter-generator -&gt; $v {
        note $v;
    }
    whenever Supply.interval(1) {
        say &#34;Waiting...&#34;;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以我们这里有三段代码:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>函数 <code>a()</code> 生成 Hofstadter Q 序列<sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup>的值(以一种特别低效的方式)。</p>
</li>
<li>
<p>有一个使用 <code>supply</code> 块生成的 Supply 对象, 它使用我们定义的函数输出 Hofstadter Q 序列的值, 从头开始, 一直到程序退出。</p>
</li>
<li>
<p>然后是一个 <a href="https://docs.raku.org/language/concurrency#index-entry-react">react</a> 块, 只要有值就输出, 在值之间每隔一秒输出一条等待消息。关于 <code>react</code> 块, 我将在改天再详细介绍。现在, 只需要知道 <code>react</code> 块允许我们通过将结果拉回到单个线程中来同步异步工作。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>至于我们的中心主题, <code>supply</code> 块, 它返回一个可以被&#34;分接&#34;(tapped)的 <code>Supply</code> 对象。通过调用 <code>.tap</code> 或 <code>.act</code> 方法, 或者在 <code>whenever</code> 块中作为 <code>react</code> 或另一个 <code>supply</code> 块的一部分使用。</p>
</div>
<div class="paragraph">
<p>在 <code>supply</code> 块的情况下, 我们得到的这种 <code>Supply</code> 对象被称为&#34;按需供应&#34;(on demand Supply)。这意味着每当 <code>Supply</code> 被分接(tap)时, 与该块相关的代码都会被运行。每当遇到 <code>emit</code> 时, 传递给 <code>.tap</code> 或 <code>whenever</code> 语句的块都会被运行, 并给出作为参数发出的值(在上面的示例代码中命名为 <code>$v</code>)。执行一直持续到给 supply 的块退出或到达 <code>done</code> 语句, 这将导致 <code>supply</code> 块退出(这个操作与 <code>last</code> for 循环非常相似)。</p>
</div>
<div class="paragraph">
<p>例如, 如果我们希望我们的序列在迭代 100 次后自动结束, 我们可以这样重写我们的 <code>supply</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $stopping-hofstadter-generator = supply {
        for (1 ... *).map(-&gt; $n { a($n) }) -&gt; $v {
            emit $v;
            done if $v &gt; 100;
        }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在使用 <code>supply</code> 块时, 要记住一个非常重要的因素, 即 <code>emit</code> 命令会在每个分接(<code>tap</code>)完成工作之前进行阻塞。<sup class="footnote">[<a id="_footnoteref_7" class="footnote" href="#_footnotedef_7" title="View footnote.">7</a>]</sup>这意味着该 <code>supply</code> 块&#34;支付&#34;其分接的计算时间。这种延迟提供了一种反压形式, 防止生成的 <code>Supply</code> 运行速度超过分接(tap)的处理速度。因此,如果你想让你的事件流以光速运行, 并且不在乎工具处理是否能跟上, 你需要确保分接(tap)立即启动(<code>start</code>)新的任务来运行, 以避免阻塞, 或者你想要一个不同于普通 <code>Supply</code> 的机制来处理工作负载。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/03/supply-blocks/" class="bare">https://zostay.com/posts/2019/12/03/supply-blocks/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_channel">82. Channel</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 中, <a href="https://docs.raku.org/type/Channel">Channel</a> 是一个异步的数据队列。你可以将数据送入队列的一端, 并在另一端安全地接收数据, 即使是在多个线程参与的情况下。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/04/channels/cover-tania-miron-EKX3Lx-t5CM-unsplash_hu42ee8b5b2f8086eb01445008d13dff6b_2041273_280x280_fill_q75_box_smart1.jpg" alt="Channel"/>
</div>
</div>
<div class="paragraph">
<p>让我们考虑一下<a href="https://en.wikipedia.org/wiki/Dining_philosophers_problem">哲学家用餐问题</a>的一个变体:我们有五个哲学家在桌子上喝汤。他们不互相交谈, 因为他们太忙于思考哲学问题。然而, 只有 2 个汤勺。每当一位哲学家想喝一口汤时, 她都需要获得一把汤勺。幸运的是, 每位哲学家都愿意分享汤勺, 并在每次舀完后将勺子放在桌子的中央。</p>
</div>
<div class="paragraph">
<p>我们可以这样来模拟这个问题:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $table = Channel.new;
my @philosophers = (^5).map: -&gt; $p {
    start {
        my $sips-left = 100;
        while $sips-left &gt; 0 {
            my $spoon = $table.receive;
            say &#34;Philosopher $p takes a sip with the $spoon.&#34;;
            $sips-left--;
            sleep rand;
            $table.send($spoon);
            sleep rand;
        }
    }
}
$table.send: &#39;wooden spoon&#39;;
$table.send: &#39;bamboo spoon&#39;;
await Promise.allof(@philosophers);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, 我们有五个任务运行在五个线程中, 每个任务都在争夺两个汤勺资源中的一个。他们每人将各喝 100 口汤。运行这个程序会得到 500 行类似于这样的输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">...
Philosopher 0 takes a sip with the wooden spoon.
Philosopher 2 takes a sip with the bamboo spoon.
Philosopher 3 takes a sip with the wooden spoon.
Philosopher 1 takes a sip with the bamboo spoon.
Philosopher 4 takes a sip with the bamboo spoon.
Philosopher 2 takes a sip with the bamboo spoon.
Philosopher 0 takes a sip with the wooden spoon.
Philosopher 1 takes a sip with the wooden spoon.
Philosopher 0 takes a sip with the wooden spoon.
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>代码本身非常简单。我们启动了(<code>start</code>)五个线程, 每个线程代表一个哲学家。每个哲学家都调用 <code>.receive</code> 接收下一个可用的勺子。该方法将一直阻塞, 直到有汤勺可用为止。哲学家喝一口汤, 然后使用 <code>.send</code> 将勺子放回到桌子上供其他人使用。最终, 哲学家喝完了 100 口, 并且由 <code>start</code> 返回的 Promise 会被保留下来。</p>
</div>
<div class="paragraph">
<p>主线程通过使用 <code>.send</code> 将两个汤勺放在桌子上来启动这个过程。然后, 它使用 <code>await</code> 来保持程序运行, 直到所有的哲学家完成任务。</p>
</div>
<div class="paragraph">
<p>就 CPU 而言, 通道的开销非常低。发送者将不会等待接收者。接收者可以使用 <code>.receive</code> 来阻塞, 直到队列中有可用的内容, 也可以使用 <code>.poll</code> 来检查条目而不阻塞。成本转移到内存中。通道必须在内部存储所有已发送的项, 直到它们被接收, 并且队列将继续增长, 直到程序用完内存。</p>
</div>
<div class="paragraph">
<p>因此, 当你有资源或消息要分发, 但不在任务之间共享时, 通道是很有用的。或者当你只需要进行点对点的通信时。作业队列、资源池和点对点任务通信是通道非常适合解决的那种问题的好例子。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/04/channels/" class="bare">https://zostay.com/posts/2019/12/04/channels/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_线程">83. 线程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>警告！ 我们现在正在深入了解 Raku 的内部深度。线程是一种低级的 API, 几乎所有的应用程序都应避免使用线程(Thread)。然而, 如果你的特定应用程序需要直接访问线程(<a href="https://docs.raku.org/type/Thread">Thread</a>), 那么它就是为你准备的。<sup class="footnote">[<a id="_footnoteref_8" class="footnote" href="#_footnotedef_8" title="View footnote.">8</a>]</sup></p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/05/threads/cover-boris-dunand-FLzsXmNpNY8-unsplash_hubbf65d3913ba2b5d11e1378d1ae20adb_3385815_280x280_fill_q75_box_smart1.jpg" alt="Threads"/>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中, <code>Thread</code> 类的使用是直截了当的, 并且看起来与你熟悉其他语言中的线程工具的预期非常相似:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t = Thread.start:
    name =&gt; &#39;Background task&#39;,
    :app_lifetime,
    sub {
        if rand &gt; 0.5 { say &#39;weeble&#39; }
        else { say &#39;wobble&#39; }
    },
    ;

say &#34;Starting $t.id(): $t.name()&#34;;
say &#34;Main App Thread is $*THREAD.id(): $*THREAD.name()&#34;;

$t.finish; # wait for the thread to stop</code></pre>
</div>
</div>
<div class="paragraph">
<p>给 <code>Thread.start</code> 方法一些代码来运行, 然后你就离开了。<code>name</code> 和 <code>app_lifetime</code> 选项是可选的。如果 <code>app_lifetime</code> 为 <code>False</code>（这是默认值）, 当主应用程序线程终止时, 该线程将被终止。如果设置为 <code>True</code>, 只要这个线程在运行, 应用程序就会继续运行。正常情况下, 只有应用程序的主线程才有这个权限。</p>
</div>
<div class="paragraph">
<p>所有代码, 都在一个线程内运行。你的代码可以使用名为 <code>$*THREAD</code> 的动态变量访问它正在运行的线程。这对于调试时拉出 <code>.id</code>, 帮助了解一个任务此时正在哪个线程中运行是很有帮助的。</p>
</div>
<div class="paragraph">
<p>当你想暂停当前线程以等待另一个线程完成时, 你可以使用 <code>.finish</code> 方法（或者你可以使用 <code>.join</code>, 它是 <code>.finish</code> 的同义词）。</p>
</div>
<div class="paragraph">
<p>另一种运行线程的方法是使用 <code>.new</code> 和 <code>.run</code> 的组合。这与 <code>.start</code> 类似, 但代码必须作为命名参数传递给 <code>.new</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t2 = Thread.new:
    name =&gt; &#39;Another task&#39;,
    code =&gt; sub {
        loop {
            say &#39;stuff&#39;;
            sleep 1;
        }
    },
    ;

# The thread does not start until we...
$t2.run;

# And then we&#39;d better wait for it or we&#39;ll exit immediately
$t2.finish;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在大多数情况下, 我都会在降临日历中提到线程, 以此来描述代码在其中运行的“通道”。然而, 我会不时地使用 <code>$*THREAD.id</code> 来帮助说明代码确实在不同的线程中运行。否则, 我一般会直接忽略 Thread 对象。</p>
</div>
<div class="paragraph">
<p>几乎所有的 Raku 程序都应该坚持使用 <code>start</code> 块或 <code>Promise.start</code> 来启动在另一个线程上运行的任务。只有在真正需要的时候, 你才应该直接利用 <code>Thread</code>, 对于大多数 Raku 开发人员来说, 可能永远不会使用或接近 Thread。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/05/threads/" class="bare">https://zostay.com/posts/2019/12/05/threads/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_raku_调度器">84. Raku 调度器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 中, 大量的面向并发的编码都依赖于 <a href="https://docs.raku.org/type/Scheduler">Scheduler</a> 的使用。许多异步操作依赖于虚拟机在运行时创建的默认调度程序。你可以通过名为 <a href="https://docs.raku.org/language/variables#index-entry-$*SCHEDULER">$*SCHEDULER</a> 的动态变量来访问它。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/06/raku-schedulers/cover-curtis-macnewton-vVIwtmqsIuk-unsplash_hu802150c44c239c3f53b4fc234a8323d6_2735965_280x280_fill_q75_box_smart1.jpg" alt="Schedulers"/>
</div>
</div>
<div class="paragraph">
<p>调度程序(Scheduler)的最重要功能是 <code>.cue</code> 方法。使用代码引用调用该方法将安排工作(work)的执行。调度程序的类型将决定其具体含义。</p>
</div>
<div class="paragraph">
<p>也就是说，这是一个低级接口，你可能不应该在大多数代码中调用 <code>.cue</code>。最好的做法是依靠高级工具, 比如 <code>start</code>，并构造一个 Promise 供你监视工作(work)。</p>
</div>
<div class="paragraph">
<p>每个调度程序都提供了三种方法：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>.uncaught_handler</code> 是一个访问器，它返回一个例程，或者可以将其设置为例程，只要调度程序抛出异常, 而任务代码本身不对其进行处理，就会调用该例程。如果未提供处理程序，而提示任务抛出了异常，则应用程序将在这个异常上退出。如果你使用高级并发工具, 如 <code>start</code> 块，则将永远不会使用 <code>.uncaught_handler</code>，因为它们各自提供了自己的异常处理。</p>
</li>
<li>
<p><code>.cue</code> 方法用于将任务添加到调度中。调度程序将在资源允许的情况下执行该任务（取决于调度程序的操作方式）。</p>
</li>
<li>
<p><code>.loads</code> 方法返回一个整数，该整数表示调度程序当前的负载。这是对当前作业队列大小的指示。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>所以，你可以建立一个非常简单的调度程序，就像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class MyScheduler does Scheduler {
    method cue(&amp;code, Instant :$at, :$in, :$every, :$times = 1; :&amp;catch) {
        sleep $at - now if $at &amp;&amp; $at &gt; now;
        sleep $in if $in;

        for ^$times {
            code();
            CATCH {
                default {
                    if &amp;catch {
                        catch($_);
                    }
                    elsif self.uncaught_handler {
                        self.uncaught_handler.($_);
                    }
                    else {
                        .throw;
                    }
                }
            }
            sleep $every if $every;
        }

        class { method cancel() { } }
    }

    # We don&#39;t really queue jobs, so always return 0 for the load
    method loads(--&gt; 0) { }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这和 <code>CurrentThreadScheduler</code> 的功能有些类似。</p>
</div>
<div class="paragraph">
<p>Rakudo 内置了两个调度程序：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.raku.org/type/ThreadPoolScheduler">ThreadPoolScheduler</a> 就是通常默认的 <code>$*SCHEDULER</code>。当它被构造时，你可以设置它允许同时使用的线程数量。然后，它管理一个线程池，并将在这些线程上调度提示任务。随着任务的完成, 释放线程，下一个任务将被调度运行。任务可以和这个调度程序同时运行。当 <code>.cue</code> 返回时，任务可能尚未开始。返回对象的 <code>.cancel</code> 方法可用来请求取消某个任务的工作(work)。</p>
</li>
<li>
<p><a href="https://docs.raku.org/type/CurrentThreadScheduler">CurrentThreadScheduler</a> 是一个备用的调度程序。它基本上只是立即执行任务，并在任务完成后返回。返回的取消对象有一个 <code>.cancel</code> 方法，但是它是一个空操作，因为在调度程序返回时, 工作总是已经完成。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>许多异步方法，比如 <a href="https://docs.raku.org/type/Promise">Promise</a> 上的 <a href="https://docs.raku.org/type/Promise#method_start"><code>.start</code></a> 方法，会接收一个名为 <code>:scheduler</code> 的参数，你可以在其中传递一个自定义的调度程序。一般来说，你可以坚持使用默认的调度程序。对调度程序最常见的调整可能是改变线程池中的线程数，或者在某些情况下切换到使用当前的线程调度程序。你有可能不需要做这两件事。而且，而如果你需要一些奇特的东西，那么定义自己的调度程序也是合理的。需要考虑的事情。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/06/raku-schedulers/" class="bare">https://zostay.com/posts/2019/12/06/raku-schedulers/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_react_块">85. React 块</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 中的 <a href="https://docs.raku.org/language/concurrency#index-entry-react">react</a> 块是重新同步异步编码活动的主要手段。使用它,你可以轻松地将 <a href="https://docs.raku.org/type/Promise">promises</a>、<a href="https://docs.raku.org/type/Supply">supplies</a>和 <a href="https://docs.raku.org/type/Channel">channels</a> 组合在一起, 使你的程序或子系统成为一个连贯的整体。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/07/react-blocks/cover-alexander-schimmeck-X-RFSg_4EL4-unsplash_hu33a2585040fa0e46f598379fa8d3b2df_2559998_280x280_fill_q75_box_smart1.jpg" alt="react"/>
</div>
</div>
<div class="paragraph">
<p><code>react</code> 块本身可以运行任何你想要的代码, 再加上一个或多个 <code>whenever</code> 块。块中的代码会运行一次, 当 <code>done</code> 子例程被调用时, 或者当所有与 <code>whenever</code> 块相关联的对象完成时（即所有的承诺都被保留或破坏, 所有的供应已退出或关闭, 所有的通道已失败或关闭）, 块将退出。</p>
</div>
<div class="paragraph">
<p>除了语法之外, 关于 <code>react</code> 块, 需要注意的关键一点是, 块内的所有代码总是会像单线程一样运行(即, 可能会使用多线程, 但绝不会让这个块内的任何代码并发运行)。</p>
</div>
<div class="paragraph">
<p>我们来看一个 <code>react</code> 块的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $commands = Channel.new;
my $input = Supplier.new;
my $output = Supplier.new;
my $quit = Promise.new;
react {
    print &#39;&gt; &#39;;

    start loop { $input.emit: $*IN.getc }

    whenever $input.Supply.lines.map({ .trim }) {
        when /^add \s+ (\d+) \s+ (\d+)$/ { $commands.send: (&#39;add&#39;, +$0, +$1) }
        when /^sub \s+ (\d+) \s+ (\d+)$/ { $commands.send: (&#39;sub&#39;, +$0, +$1) }
        when &#39;quit&#39; | &#39;exit&#39; { $quit.keep }
        default { $output.emit: &#39;syntax error&#39; }
    }

    whenever $commands -&gt; @command {
        multi doit(&#39;add&#39;, Int $a, Int $b) { $a + $b }
        multi doit(&#39;sub&#39;, Int $a, Int $b) { $a - $b }

        $output.emit: doit(|@command);
    }

    whenever $output.Supply { .say; print &#39;&gt; &#39; }

    whenever $quit {
        say &#39;Quitting.&#39;;
        done;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个程序提供了一个小型的交互式 shell, 可以执行加法和减法运算。运行时, 你可以按以下方式使用它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">&gt; add 4 5
9
&gt; sub 10 7
3
&gt; exit
Quitting.</code></pre>
</div>
</div>
<div class="paragraph">
<p>如你所见, 这段代码使用了几个 <code>Supply</code> 对象, 一个 <code>Channel</code> 和一个 <code>Promise</code> 来操作的。他们中的每一个都以预期的方式与 <code>whenever</code> 工作。<code>run</code> 块内的所有代码都像在单线程中运行一样（尽管并没有特别保证只使用单线程, 只是没有代码会并发运行）。</p>
</div>
<div class="paragraph">
<p>然而, 在这种情况下, 从单任务中运行而不并发确实存在一个问题。即使你使用 <code>.Supply</code> 方法来异步获取数据, <code>$*IN</code> 文件句柄也只执行阻塞读取。因此, 我们必须在后台线程中运行的任务中拉取输入, 这就是为什么我们在读取字符输入的循环之前放了一个 <code>start</code>。如果没有这个并发任务, 我们就必须多敲几次 Return 键, 以便其他 <code>whenever</code> 子句也有机会运行。</p>
</div>
<div class="paragraph">
<p>也就是说, 我们可以把其它的 <code>whenever</code> 块的工作移到单独的并发任务中, 然后把每个任务都拉到这个 <code>react</code> 块中, 这样就能很好地工作了。<code>react</code> 块的目标是用一种简单明了的语法来同步异步工作。我认为它的工作做得很好。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/07/react-blocks/" class="bare">https://zostay.com/posts/2019/12/07/react-blocks/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lock_类">86. Lock 类</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 中编写并发代码时, 我们要避免任务之间共享数据。这是因为不共享数据的代码是自动安全的, 并且不必担心与其他代码的相互依赖性。所以, 在可能的情况下, 你应该通过 <code>Supply</code>、<code>Promise</code> 和 <code>Channel</code> 对象来完成你的工作, 然后通过中央线程将它们同步在一起。这样, 所有状态变化都是安全的。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/08/the-lock-class/cover-maxim-zhgulev-5tmItJfHkIc-unsplash_hu604da152536f26176df092a26a53d8d0_371005_280x280_fill_q75_box_smart1.jpg" alt="Lock Class"/>
</div>
</div>
<div class="paragraph">
<p>不过, 这并不总是实用的。有时候, 在不同线程上运行的任务之间共享可以变化的数据确实更有效率。然而, 这样的共享本质上是不安全的。</p>
</div>
<div class="paragraph">
<p>例如, 这里有一个在 Raku 中非常简单的多线程应用程序, 它不是线程安全的, 会导致错误的结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 0;
my @p = (
    start for ^100 { $x++; sleep rand/10; },
    start for ^100 { $x++; sleep rand/10; },
);
await Promise.allof(@p);
say $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可能期望 <code>$x</code> 的值是 200, 但它不太可能是 200。它几乎可以肯定会更低。这是因为简单的 <code>$x++</code> 操作需要:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>读取 <code>$x</code> 的值。</p>
</li>
<li>
<p>在 <code>$x</code> 读取的值上加一。</p>
</li>
<li>
<p>将计算出的值存储回 <code>int $x</code>。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果碰巧第一个任务执行了步骤1和2, 然后第二个任务在第一个任务完成步骤3之前执行了步骤1到3, 那么至少有一个增量操作会丢失。在每个任务的 100 次迭代过程中, 我预计会有5到10次写入丢失, 并且每次运行都有可能给出稍微不同的答案。这就是在并发性方面不安全的含义。</p>
</div>
<div class="paragraph">
<p>对于这个特殊的程序, 上面的三个步骤构成了一个关键部分。关键部分是一段必须依次执行的代码, 如果它要完全正常工作的话。在 Raku 代码本身中, 关键部分只是每个循环中的 <code>$x++</code> 语句。</p>
</div>
<div class="paragraph">
<p>确保代码中的关键部分以线程安全的方式处理的一种机制是使用互斥锁。Raku 提供 <a href="https://docs.raku.org/type/Lock">Lock</a> 类, 可以用于这个目的。</p>
</div>
<div class="paragraph">
<p>当你创建一个 Lock 对象时, 你可以 <code>.lock</code> 或 <code>.unlock</code> 代码中的锁。如果任何其他代码在没有调用 <code>.unlock</code> 的情况下, 在同一个对象上调用了 <code>.lock</code>, 那么调用 <code>.lock</code> 方法将阻止你的代码继续运行。一旦持有锁的线程调用 <code>.unlock</code>, 另一个等待锁释放的线程将被允许继续运行。</p>
</div>
<div class="paragraph">
<p>在上面的示例中, 我们可以将其修改如下, 使之成为线程安全的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 0;
my $lock = Lock.new;
my @p = (
    start for ^100 { $lock.lock; $x++; $lock.unlock; sleep rand/10; },
    start for ^100 { $lock.protect: { $x++ }; sleep rand/10; }
);
await Promise.allof(@p);
say $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我没有提到 <code>.protect</code>, 但它的作用和调用 <code>.lock</code>, 运行给定的块, 然后运行 <code>.unlock</code> 相同。不过这样做的好处是, 如果块里面出现了问题, 它可以彻底的让 <code>.unlock</code> 调用发生。在上面我们使用 <code>.lock</code> 和 <code>.unlock</code> 的第一个循环中, 有可能因为抛出异常而导致锁被永久锁定。使用 <code>.protect</code> 可以自动避免这种风险, 所以它是使用 <code>Lock</code> 的首选方式。</p>
</div>
<div class="paragraph">
<p>在结束之前, 我想提一下锁的几个负面因素。首先, 锁的性能不是很好。它们易于实现且易于使用, 但是互斥会带来较高的性能成本。你可能希望确保少量使用锁, 并且仅将其用于保护关键部分。</p>
</div>
<div class="paragraph">
<p>另一个主要缺点是, 当使用锁时, 你可以获得线程安全, 但可能会增加死锁的风险。我已经提到了一个死锁风险:一个任务导致错误, 使一个锁无法被解锁。这个锁现在是死锁, 没有任务可以接管它。当涉及到多个锁时, 死锁的风险可能会更加微妙, 并且非常难以发现。与供应(Supply)或承诺(Promise)不同, 锁(Lock)是不能安全地组合的。这意味着两个使用锁来保护自身安全的库在一起使用时, 如果不小心, 可能会出现死锁。</p>
</div>
<div class="paragraph">
<p>尽管有这些缺点, 锁对于使代码线程安全是很有用的东西。在这个降临日历的后面, 我们将使用锁来演示如何创建线程安全的数据结构。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/08/the-lock-class/" class="bare">https://zostay.com/posts/2019/12/08/the-lock-class/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_atomic_integer">87. Atomic Integer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>什么比锁更快？比较和交换(CAS)。现代 CPU 有多个核心。因此, 所有的现代 CPU 都必须拥有执行绝对原子操作的工具, 以便让这些多核一起工作。这些操作的其中之一就是比较与交换(compare-and-swap) 或 <code>cas</code> 操作。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/09/atomic-integers/cover-heather-gill-Ub2JHFkIXWc-unsplash_hu361675a22350da2201213fc332ace117_4173099_280x280_fill_q75_box_smart1.jpg" alt="Atomic Integers"/>
</div>
</div>
<div class="paragraph">
<p>抽象地讲, cas 操作需要三个参数, 一个要修改的变量、一个给定的值和一个新的值。只有当变量所持有的当前值等于给定值时, 变量才会被设置为被修改后的新值。而这是以单次操作的方式进行的, 保证不受任何其他并发操作的干扰。在这一过程中, 系统会设置一个标志来标记操作的成功或失败。如果该变量的值与预期值不同, 则该变量保持不变, 操作失败。为了完成一个原子变化, 你重复运行一个计算, 并以 <code>cas</code> 操作结束, 直到操作成功为止。这听起来可能不是很有效率, 但事实证明, 在大多数情况下, 它比锁更快。</p>
</div>
<div class="paragraph">
<p>Raku 通过 <a href="https://docs.raku.org/type/atomicint">atomicint</a> 类型上的 <a href="https://docs.raku.org/type/atomicint#sub_cas">cas</a> 函数以及一些帮助你执行这些原子变化的操作符, 提供了对这种操作的直接访问。</p>
</div>
<div class="paragraph">
<p>为了演示 <code>atomicint</code> 的一个可能的用法, 让我们首先考虑一下 ATM 问题。有两个人有一个银行账户。假设在一天开始的时候, 这个账户里有 1000 美元。其中一个人在市中心的 ATM 机上取款 100 元, 另一个人在机场的 ATM 机上存款 250 元。在一天结束时, 我们显然希望新的余额是 1150 美元。但是, 如果这两笔交易同时发生, 那就不能保证了, 除非我们采取一些谨慎的措施来保证这一点。</p>
</div>
<div class="paragraph">
<p>让我们先用天真的方法写出我们的代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int $balance = 1000;
start { $balance = $balance - 100 } # one
start { $balance = $balance + 250 } # two
say $balance;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不幸的是, 现在可能会出现余额与 1150 美元不同的情况。这是因为如果这两个任务实际上同时运行, 它们执行的操作可能会像这样交错进行。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>块一读取 1000 美元的余额。</p>
</li>
<li>
<p>块二读取 1000 美元的余额。</p>
</li>
<li>
<p>块一从 1000 中减去 100, 得到 900。</p>
</li>
<li>
<p>块二从 1000 中加上 250, 得到 1250。</p>
</li>
<li>
<p>块一将余额设置为 900。</p>
</li>
<li>
<p>块二将余额设置为 1250。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>读和写操作必须按顺序执行, 这样代码才能正常工作。我们可以使用 <a href="https://docs.raku.org/type/Lock">lock</a> 或 <a href="https://docs.raku.org/type/Semaphore">semaphore</a> 或其他传统的构造来形成一个围绕着修改变量的关键部分, 但这些操作通常都很慢。</p>
</div>
<div class="paragraph">
<p>相反, 我们可以使用 <code>cas</code> 操作来依次执行操作。所以, 如果我们使用 <code>atomicint</code> 重写上面的代码, 我们最终会得到这样的结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my atomicint $balance = 1000;
start { $balance ⚛️= ⚛️$balance - 100 } # one
start { $balance ⚛️= ⚛️$balance + 250 } # two
say $balance;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的结果将始终是预期的 1150。让我们假设这两个任务和之前一样同时运行, 但最后的分配是一个比较和交换操作, 而不是一个常规的集。其结果会是这样的。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>块一读取 1000 美元的余额。</p>
</li>
<li>
<p>块二读取 1000 美元的余额。</p>
</li>
<li>
<p>块一从 1000 中减去 100, 得到 900。</p>
</li>
<li>
<p>块二在 1000 的基础上加 250, 得到 1250。</p>
</li>
<li>
<p>块一执行比较和交换 <code>$balance</code> 从 1000到900, 成功了。</p>
</li>
<li>
<p>块二执行比较和交换 <code>$balance</code> 从1000到1250, 失败了。</p>
</li>
<li>
<p>块二读取的 <code>$balance</code> 为900。</p>
</li>
<li>
<p>块二在 900 的基础上加上 250, 得到 1150。</p>
</li>
<li>
<p>块二执行比较和交换 <code>$balance</code> 从900到1150, 成功了。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>出现额外的步骤 7-9 是因为在 <code>cas</code> 操作中, 解决失败需要重复操作直到成功。除非对单个变量的写入争夺程度是极端的, 否则这不应该导致任何任务无限期地失败。</p>
</div>
<div class="paragraph">
<p>如果你不喜欢代码中的表情符号, 那也没关系。有一个 Texas 函数用于执行原子表情符操作符提供的每一个操作。<code>atomicint</code> 提供了以下操作:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>atomic-assign 或 ⚛️=</p>
</li>
<li>
<p>atomic-fetch 或 ⚛️ 前缀, 用于执行原子读取值</p>
</li>
<li>
<p>atomic-fetch-inc 或 ⚛️++ 后缀</p>
</li>
<li>
<p>atomic-fetch-dec 或 ⚛️– 后缀</p>
</li>
<li>
<p>atomic-fetch-add 或 ⚛️+=</p>
</li>
<li>
<p>atomic-fetch-sub 或 ⚛️-=</p>
</li>
<li>
<p>atomic-inc-fetch 或 ++⚛️ 前缀</p>
</li>
<li>
<p>atomic-dec-fetch 或 –⚛️ 前缀</p>
</li>
<li>
<p>cas</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们快速考虑一下 <code>cas</code> 函数本身, 它是实现其他运算符的基础。这个操作允许你实现任何涉及 <code>atomicint</code> 比较和交换的操作。它有两种基本形式, 为了演示它们是如何工作的, 我们可以使用这两种形式重新实现上面的 ATM 问题。</p>
</div>
<div class="paragraph">
<p>首先, 考虑一下这个使用 <code>cas</code> 函数的程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my atomicinc $balance = 1000;
sub update-balance($change-by) {
    my $new-balance;
    loop {
        my $old-balance = $balance;
        $new-balance = $balance + $change-by;
        if cas($balance, $old-balance, $new-balance) == $old-balence {
            last;
        }
    }
    return $new-balance;
}
start update-balance(-100); # one
start update-balance(250);  # two
say $balance;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这在功能上是相同的, 虽然比上面的操作更啰嗦。这基本上是让你直接访问 <code>cas</code> 操作本身, 并让你控制重试的次数和执行的具体操作。这个功能的工作原理是这样的, 不过整个操作是原子式的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub cas(atomicint $target is rw, int $expected-value, int $new-value --&gt; int) {
    my int $seen = $target;
    if $seen == $expected-value {
        $target = $new-value;
    }
    return $seen;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这意味着它将在每个情况下都返回它所看到的值, 但当它看到的值与你所预期的值一致时, 它将改变存储在目标中的值。</p>
</div>
<div class="paragraph">
<p>这个方法还有第二个版本, 它可以帮助简化你的代码, 为你执行循环。如果要再写一次 ATM 问题, 我们也可以这样写。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my atomicint $balance = 1000;
sub update-balance($change-by) {
    cas $balance, -&gt; $seen-value { $seen-value + $change-by }
}
start update-balance(-100); # one
start update-balance(250);  # two
say $balance;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这大大缩短了实现这个操作所需的代码。它通过在循环中反复执行给定的操作, 直到 <code>cas</code> 操作成功。在这种情况下, <code>cas</code> 函数是这样定义的, 但同样是在适当的地方使用原子操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub cas(atomicint $target is rw, &amp;operation) {
    loop {
        my int $seen = $target;
        my $new-value = operation($seen);
        if $seen == $target { # still equal?
            $target = $new-value;
        }
        return $new-value;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, <code>cas</code> 子程序的另一种选择是接受一个函数, 返回被设置的新值, 而接受两个整数的 <code>cas</code> 则返回被看到的值。也就是说, 这种第二种且紧凑的形式将返回值像赋值操作一样处理, 但另一种形式的工作方式不允许这样处理。</p>
</div>
<div class="paragraph">
<p>我真的很想和大家分享如何在 Raku 中的任何标量值上使用 <code>cas</code>, 但这篇文章已经很长了。我将在这个降临节稍后介绍。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/09/atomic-integers/" class="bare">https://zostay.com/posts/2019/12/09/atomic-integers/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_分而治之模式">88. 分而治之模式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>现在我们来考虑一下如何解决并发性的一个大问题。如果你有一个需要处理大量数据的算法问题, 你想最大限度地提高可用 CPU 核心的负载, 以尽快处理这些数据。为了演示我们如何在 Raku 中实现这一点, 我们将考虑康威的《生命游戏》, 在一个有效的无限棋盘上进行。<sup class="footnote">[<a id="_footnoteref_9" class="footnote" href="#_footnotedef_9" title="View footnote.">9</a>]</sup></p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/10/the-divide-and-conquer-pattern/cover-seth-cottle-eeoXwem688U-unsplash_hu578561e015dcc2299a521a0877cc4e7f_3472343_280x280_fill_q75_box_smart1.jpg" alt="The Divide and Conquer Pattern"/>
</div>
</div>
<div class="paragraph">
<p>让我们从定义康威的《生命游戏》开始, 以防你之前没有接触过它。生命游戏是英国数学家约翰-康威发明的一种模拟游戏。它是在一个简单的网格上进行的, 每个方格被称为一个细胞。在一个给定的回合中, 每个细胞可能要么是活的, 要么是死的。每个细胞有 8 个邻居, 分别是上、下、左、右和 4 条对角线上的细胞。为了确定一个细胞在下一个回合的状态, 你使用当前细胞的状态和它的邻居从当前回合使用这些规则执行以下检查。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>任何有少于两个邻居的活细胞都会死亡。</p>
</li>
<li>
<p>任何有两个或三个邻居的活细胞继续生存。</p>
</li>
<li>
<p>任何有三个以上邻居的活细胞都会死亡。</p>
</li>
<li>
<p>任何有三个邻居的死细胞复活。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果你想了解更多的细节, 你应该看看维基百科上关于<a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">康威的《生命的游戏》</a>的文章。</p>
</div>
<div class="paragraph">
<p>我已经在一个漂亮的长程序中实现了康威的《生命游戏》, 并有图形（或文本）输出和所有的内容。然而, 它大约有 400 行代码, 所以我不打算在这里包含所有的代码。你可以在我的 <a href="https://github.com/zostay/raku-Game-Life">github</a> 上查看这个项目的持续发展。</p>
</div>
<div class="paragraph">
<p>模拟器有一个名为 <code>Game::Life::Player</code> 的角色, 它定义了对玩家对象的要求。这个对象负责执行游戏规则。具体来说, <code>.next-turn-for</code> 方法被赋予了一个当前棋盘的不可变的副本, 一组边界, 和一个可改变的下一个棋盘的副本来写入。它负责根据刚才提到的规则将当前棋盘变成下一回合的棋盘。</p>
</div>
<div class="paragraph">
<p>下面是 <code>Game::Life::Player::Basic</code> 实现中的一个副本, 这基本上是最简单的方法了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Game::Life::Player {
    ...
    method next-turn-for-cell(
        Int:D $x,
        Int:D $y,
        Board:D $current,
        Board:D $next,
    ) {
        # Is the cell currently live?
        my $live      = $current.cell($x, $y);

        # How many live neighbors does it currently have?
        my $neighbors = [+] $current.neighbors($x, $y);

        # If alive and has too many or too few neighbors, die.
        if $live &amp;&amp; !(2 &lt;= $neighbors &lt;= 3) {
            return $next.kill($x, $y);
        }

        # if dead and has the right number of neighbors, come to life.
        elsif !$live &amp;&amp; $neighbors == 3 {
            return $next.raise($x, $y);
        }

        else {
            return Nil;
        }
    }
}

class Game::Life::Player::Basic does Game::Life::Player {
    ...
    method next-turn-for(
        Int:D $l,
        Int:D $t,
        Int:D $r,
        Int:D $b,
        Board:D $current,
        Board:D $next,
    ) {
        for $l..$r -&gt; $x {
            for $t..$b -&gt; $y {
                self.next-turn-for-cell($x, $y, $current, $next);
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>实现方法是简单地迭代边界内的每个细胞, 并在其上运行 <code>.next-turn-for-cell</code>。这个方法是在 <code>.role</code> 中实现的, 只是实现了适用于单个细胞的规则。很简单。<sup class="footnote">[<a id="_footnoteref_10" class="footnote" href="#_footnotedef_10" title="View footnote.">10</a>]</sup></p>
</div>
<div class="paragraph">
<p>即使是对于相对较小的游戏场, 单块迭代也会花费很长的时间。为了改善这种情况, 我们可以将工作划分成合理大小的块, 并在一个单独的任务中处理每个块。在多线程的情况下, 我们应该可以将做工作所需的时间缩短到 N 的倍数, 其中 N 是可用于计算的核心数。在现实中, 你得到的时间会比这少一些, 但我们应该绝对能够通过这种方式提高速度。</p>
</div>
<div class="paragraph">
<p>我们可能怎么做呢？这里有一个可能的解决方案, 确保我们永远不会处理大于 20 乘 20 的块, 使得连续进行大约 400 次计算。获得最大的效率需要一些调整, 所以一个给定的系统可能会用不同的数字做得更好, 但你懂的。</p>
</div>
<div class="paragraph">
<p>这里有一个 <code>parallel-next-turn-for</code> 的实现, 是 <code>Game::Life::Player::DivideAndConquer</code> 玩家类的一部分。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Game::Life::Player::DivideAndConquer is Game::Life::Player::Basic {
    ...
    method parallel-next-turn-for(
        Int:D $l,
        Int:D $t,
        Int:D $r,
        Int:D $b,
        Board:D $current,
        Board:D $next,
    ) {
        my @jobs = gather {
            if $r - $l &gt; 20 {
                my $m = ceiling($l + ($r - $l)/2);
                #dd $l, $m, $r;

                take start self.parallel-next-turn-for($l, $t, $m - 1, $b, $current, $next);
                take start self.parallel-next-turn-for($m, $t, $r, $b, $current, $next);
            }

            elsif $b - $t &gt; 20 {
                my $m = ceiling($t + ($b - $t)/2);
                #dd $t, $m, $b;

                take start self.parallel-next-turn-for($l, $t, $r, $m - 1, $current, $next);
                take start self.parallel-next-turn-for($l, $m, $r, $b, $current, $next);
            }

            else {
                take start self.next-turn-for($l, $t, $r, $b, $current, $next);
            }
        }

        await Promise.allof(@jobs);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这与之前的输入相同, 但如果列数太多, 无法处理, 我们就按列数将工作减半。如果列是合理的, 但行数太多, 我们就把工作按行数减半。如果大小刚刚好, 我们就使用我们从 <code>Game::Life::Player::Basic</code> 继承的 <code>next-turn-for</code>。</p>
</div>
<div class="paragraph">
<p>无论我们是分成两个任务, 还是只做某一部分细胞的工作, 我们都会使用 <code>start</code> 块来调度工作, 然后等待结果。这样方式的细分意味着我们创建了一个任务的层次结构, 可以再细分, 再细分。然后, Raku 调度器会在线程可用时调度任务运行。</p>
</div>
<div class="paragraph">
<p>在我的 2015 年的 Macbook Pro 上, 游戏在顺序运行时, 使用 100% 的 CPU, 在 35 秒左右的时间内跑完 200 个回合的 Gosper 滑翔机枪。同样的程序在并行运行时, 使用接近 300% 的 CPU 运行约 20-25 秒。如果不是我的渲染任务偶尔也要用 CPU 重绘图形窗口, 可能会更高。但那又有什么乐趣呢？</p>
</div>
<div class="paragraph">
<p>所以, 这就是当你有多个核心可用时可以采用的并发模式, 而且算法适合被拆分成几个部分。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/10/the-divide-and-conquer-pattern/" class="bare">https://zostay.com/posts/2019/12/10/the-divide-and-conquer-pattern/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_并行的_map_reduce_模式">89. 并行的 Map-Reduce 模式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在函数式编程中, Map-reduce 是一种常见的解决问题的方法。你有一个列表项,你要对这些项进行迭代处理,然后你把这个集合进行汇总。我们之所以称之为map-reduce,是因为迭代步骤是将值映射成新的值,而汇总步骤是减少值的数量。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/11/parallel-map-reduce-pattern/cover-sebastien-le-derout-xc4C8j4Bnqc-unsplash_hu098ba572eac2d273a9acf7b37e313970_2405230_280x280_fill_q75_box_smart1.jpg" alt="map-reduce"/>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中,map-reduce 是一种常见的编程模式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fibonacci = (1, 1, * + * ... *);
my $double-sum = $fibonacci[^100].grep(*.is-prime).map(* * 2).reduce(* + *);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就用序列运算符创建了一个 <a href="https://docs.raku.org/type/Seq">Seq</a>。这就是经典的斐波那契序列。然后我们取 Fibonacci 的前 100 个元素,过滤掉任何非质数,将质数加倍,然后将数值相加。</p>
</div>
<div class="paragraph">
<p>这是一个奇怪的操作,但展示了你会用 map-reduce 模式执行的任务。我们取一个数据序列(本例中是斐波那契序列的前 100 个元素), 我们对数据进行过滤,只保留质数,将其值加倍,然后将其相加,得到最终的和。</p>
</div>
<div class="paragraph">
<p>在这种情况下,答案并不难计算,而且可能是瞬时的,但如果我们需要对前 4000 个数字进行这种操作呢？在今天的典型系统中,这很可能需要几秒钟的时间。由于 <code>.grep</code> 和 <code>.map</code> 必须对每个值进行迭代过滤和转换,所以我们没有特别的理由必须对每个值依次进行这些操作。<sup class="footnote">[<a id="_footnoteref_11" class="footnote" href="#_footnotedef_11" title="View footnote.">11</a>]</sup></p>
</div>
<div class="paragraph">
<p>Raku 提供的工具可以让你以不同的方式并行化这个任务,只需做一点小小的改变。考虑一下这个变化。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fibonacci = (1, 1, * + * ... *);
my $double-sum = $fibonacci[^100].race.grep(*.is-prime).map(* * 2).reduce(* + *);</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过在开头插入 <code>.race</code>,我们告诉 Raku 以并行方式执行操作。它将把任务分成几个部分,在不同的任务中运行这些部分,这些任务将被调度到不同的线程上。在我的系统中,该操作的运行速度比第一个快2到3倍。</p>
</div>
<div class="paragraph">
<p>Raku 提供了几种不同的策略来并行化 map-reduce 任务。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.raku.org/type/Iterable#method_race">.race</a> 方法将操作打散, 以并发处理的批次来执行工作。但它并不能保证原始项的顺序得到保留。这些项只是在线程完成后返回。</p>
</li>
<li>
<p><a href="https://docs.raku.org/type/Iterable#method_hyper">.hyper</a> 方法与 <code>.race</code> 方法非常相似,但它能保证原始列表中的项的顺序得到保留。这意味着,如果列表中较早的部分耗时较长,那么对列表后面部分的处理将被耽搁。它的效率不高,但如果你需要保留顺序,<code>.hyper</code> 会保证保留顺序。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些操作中的每一个都会接收一个 <code>:batch</code> 和 <code>:degree</code> 参数,以备你想自定义工作的分解和执行方式。Raku 试图选择合理的默认值,但是当你需要获得更好的性能时,为你的特定设置调整这些参数可能会带来一些改进。</p>
</div>
<div class="paragraph">
<p><code>:degree</code> 选项选择要启动多少个 worker。对于 CPU 绑定的工作,一般来说,最好选择一个与可用的 CPU 核数相等的数字。没有理由选择更高的数值,因为在这种情况下,你永远不会同时运行超过那么多的工作。但是,如果工作涉及到在磁盘或网络上的等待,你的代码很可能会暂停几毫秒或更长时间等待 IO。在这些情况下,明智的做法是将 <code>:degree</code> 增加到数倍于 CPU 的数量,以考虑到等待时间。</p>
</div>
<div class="paragraph">
<p><code>:batch</code> 选项决定如何分解工作。当要做的工作速度很快时,一个大数字是有用的。这将使你的吞吐量保持在较高的水平。当工作时间较长或你想尽快得到每个结果时,一个小的数字,甚至是1,都是合理的。</p>
</div>
<div class="paragraph">
<p>所以,考虑到这一点,我们可以这样进一步调整上面的工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fibonacci = (1, 1, * + * ... *);
my $double-sum = $fibonacci[^4000].race(:batch(1000), :4degree).grep(*.is-prime).map(* * 2).reduce(* + *);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,调优在我的 4 核笔记本上并没有太大的区别,但是当你的系统上有超过 4 个核心的时候,调优很可能会有一些帮助。</p>
</div>
<div class="paragraph">
<p>所以,任何时候,当你有一个任务需要对项进行迭代和操作的时候,如果你有足够的 CPU 时间来加快它们的速度,可以考虑在你的代码中使用 <code>.hyper</code> 或 <code>.race</code>。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/11/parallel-map-reduce-pattern/" class="bare">https://zostay.com/posts/2019/12/11/parallel-map-reduce-pattern/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_保留你的线程或不保留">90. 保留你的线程或不保留</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 中, 有不同的方法来暂停你的代码。最简单也是最明显的方法是使用 <a href="https://docs.raku.org/type/Date#sub_sleep">sleep</a>:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/12/keep-your-thread-or-dont/cover-artem-beliaikin-49mCO5ZRQDk-unsplash_hu727ba057d1e2b0b7df933b7d62380299_4093734_280x280_fill_q75_box_smart1.jpg" alt="Thread"/>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $before = now;
sleep 1;
my $after = now - $before;
say $after;</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设你的系统目前没有被拖累, <code>$after</code> 的输出应该是一个非常接近 1 的数字。不是很刺激:你这一秒钟什么都没做。呜呜。呜呜。</p>
</div>
<div class="paragraph">
<p>然而, 在实际代码中, 你有时确实需要暂停一下。比如说, 你可能正试图发送一封邮件, 结果失败了。在发送邮件时, 如果它能快速到达是很好的, 但最终还是要达。因此, 在排队发送邮件的时候, 你要观察是否有错误。当它们发生时, 你要在放弃之前继续尝试很长时间。然而, 你不希望不断地尝试。你需要在重试之间暂停一下。</p>
</div>
<div class="paragraph">
<p>如果我在内存中构建一个天真的实现（而不是一个更合理的磁盘队列）, 我可以这样做。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">start {
    my $retries = 10;
    my $success;
    for ^10 -&gt; $retry {
        $success = sendmail();

        last if $success;

        sleep 60 * 2 ** $retry;
    }

    die &#34;Never could send that email.&#34; unless $success;

    $success;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这段代码中, 你有一个 <code>sendmail</code> 函数, 你认为它可以正确地发送一封邮件。你将尝试发送 10 次。你检查是否成功, 然后你使用一个指数级延长的时间间隔休眠, 在接下来的 18 个小时里, 你会把重试的时间分散开来。在这之后, 你会放弃。为了避免在长达 18 小时内阻断正常工作的进程, 你在 <code>start</code> 块中运行了整个过程。每当发送邮件时, 返回的 <a href="https://docs.raku.org/type/Promise">Promise</a> 都会被保留, 如果邮件失败, 则会被破坏(broken)。</p>
</div>
<div class="paragraph">
<p>不过, 有一个问题。这段代码将一个线程阻塞长达 18 小时。而线程是一种非常有限的资源。默认的线程池里最多有 64 个线程。这可不是什么好事。这意味着我们的进程仍然可以工作, 但这个线程被锁住了, 做了一大堆的事情。线程是昂贵的资源, 这样一来, 线程的使用成本会很高。如果你每 15 分钟要发一次以上的邮件, 你就会用完线程。</p>
</div>
<div class="paragraph">
<p>如何解决这个问题呢？你可以重新配置 Raku, 使用资源池中的线程更多的调度器, 但线程的目标是做事情。你为什么要浪费一个线程什么都不做, 除非你真的没有工作让他们做。</p>
</div>
<div class="paragraph">
<p>你可以用一种方式来解决这个问题, 释放你的线程继续工作, 并暂停任务。<code>await</code> 语句是让你的代码告诉 Raku, &#34;如果你需要的话, 你可以把我的线程收回来。&#34; 所以我们把上面的代码改成这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">start {
    my $retries = 10;
    my $success;
    for ^10 -&gt; $retry {
        $success = sendmail();

        last if $success;

        await Promise.in(60 * 2 ** $retry);
    }

    die &#34;Never could send that email.&#34; unless $success;

    $success;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在代码会在规定的时间内进入休眠状态, 但线程被释放出来供 Raku 重用, 这意味着你的应用程序不会在下一次需要同时给 65 个人发垃圾邮件的时候, 在邮件服务器瘫痪的情况下等待 18 个小时。</p>
</div>
<div class="paragraph">
<p>这在一般情况下都是正确的, 而不仅仅是为了暂停休眠。任何时候, 只要你使用了 <code>await</code>（只要你的 Raku 的版本支持规格 6.d 或更高的版本）, 你的 Raku 将能够重用该线程, 如果被等待的东西还没有准备好。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/12/keep-your-thread-or-dont/" class="bare">https://zostay.com/posts/2019/12/12/keep-your-thread-or-dont/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_监控模式">91. 监控模式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>今天我想讨论一下使用锁来使对象线程安全。也就是说, 通过采用一个简单的模式来锁定对对象的访问, 可以有效地保证每次只有一个线程可以访问对象的任何部分。因此, 这就保证了对象的状态永远不会被破坏, 即使是在多个线程试图并发访问对象的的时候。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/13/the-monitor-pattern/cover-akshay-chauhan-vQObm74PB_c-unsplash_hua5cbd351e325c4223f7a0bc7ff5ed716_1567586_280x280_fill_q75_box_smart1.jpg" alt="The Monitor Pattern"/>
</div>
</div>
<div class="sect2">
<h3 id="_面向对象设计">91.1. 面向对象设计</h3>
<div class="paragraph">
<p>在讨论共享的、可变对象的并发性之前, 我们先来考虑一下是什么才是设计良好的一般对象。在面向对象设计中, 一个新手的错误是把对象看作是信息的容器。当这样设计时, 对象会根据它们所包含的数据进行映射, 并且通过一系列的 getter 和 setter 来暴露这些数据是很有诱惑力的。然而, 一个设计良好的对象将包含状态作为封装功能的一种手段, 而这些功能需要该状态来操作。它通过允许其他对象通过方法向它发送消息来执行那些可能更新内部状态的操作来实现这一点。</p>
</div>
<div class="paragraph">
<p>举个拗口的例子, 如果我们要构建一个只有 <code>push</code> 操作的链表, 我们可以构建一个这样的简单列表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class LinkedListRaw {
    has $.data;
    has $.next is rw;
}

my $list = LinkedListRaw.new(data =&gt; 1);
$list.next = LinkedListRaw.new(data =&gt; 2);
$list.next.next = LinedListRaw.new(data =&gt; 3);</code></pre>
</div>
</div>
<div class="paragraph">
<p>而一个更好的设计应该是这样的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class LinkedList {
    has $.data;
    has $!next;

    method !tail() {
        my $here = self;
        loop { return $here without $here.next; $here = $here.next }
    }

    method push($data) {
        self!tail.next = LinkedList.new(:$data);
    }
}

my $list = LinkedList.new(data =&gt; 1);
$list.push: 2;
$list.push: 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 我之所以花点时间提到良好的面向对象设计实践, 是因为我们现在要考虑的监控器模式依赖于设计良好的对象才有效。(我之所以提到这一点, 也是因为不良的面向对象设计实践甚至在原本优秀的工程师中也很普遍)。</p>
</div>
</div>
<div class="sect2">
<h3 id="_监控monitors">91.2. 监控(Monitors)</h3>
<div class="paragraph">
<p>当你有一个无状态的系统, 或者是一个系统的状态是基于转换不可变对象的系统时, 并发是最容易的。例如, 如果你只需要将计算结果从一个线程传递到另一个线程, 那么每个阶段都很容易地保留当前值的副本, 转换该值, 并将新的副本传递给下一个阶段。</p>
</div>
<div class="paragraph">
<p>然而, 有状态对象可能会带来挑战, 因为当另一个线程开始对对象进行新的操作时, 对对象状态的改变可能只在一个线程中被部分应用。如果我们不保护我们的对象一次执行多个状态变化, 或者在状态变化只完成一部分时, 不保护我们的对象被读取, 那么我们的代码就不会是线程安全的。你不应该从多个线程同时使用这样的对象。(大多数内置的 Raku 对象就是这样的对象！)</p>
</div>
<div class="paragraph">
<p>如果你处于复制对象状态不切实际的情况下, 你需要在线程之间共享状态, 一个非常简单的解决方案是使用监控模式(monitor pattern)。下面是我们在使用监控模式之前的一个线程安全版本的只推链表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class LinkedListSafe {
    has $.data;
    has $!next;
    has Lock $!lock .= new;

    method !tail() {
        my $here = self;
        loop { return $here without $here.next; $here = $here.next }
    }

    method push($data) {
        $!lock.protect: {
            self!tail.next = LinkiedListSafe.new(:$data);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>就是这样。这就是整个监控模式, 只是使用一个 Lock 来保护每个公共方法的所有c代码, 这些方法从对象的可变状态中读取或写入。虽然这很简单, 但采用这种模式也有几个缺点。</p>
</div>
<div class="paragraph">
<p>如果对状态变化的争夺很大, 这通常是一个低性能的解决方案。例如, 如果很多线程会频繁地对这个链表进行多次 <code>push</code>, 那么性能就不会很好。</p>
</div>
<div class="paragraph">
<p>在每个部分的周围添加 <code>$!lock.protect.protect: { …​ }</code>, 做起来很繁琐, 而且在开发过程中容易忘记。</p>
</div>
<div class="paragraph">
<p>为了改善第一种情况, 请确保你的监控器只包含与封装对象状态相关的代码。创建非监控器的次要对象, 这些对象不是任何计算和动作的监控器, 也不是任何其他无状态工作的监控器。</p>
</div>
<div class="paragraph">
<p>对于第二种情况, 我推荐使用 Jonathan Worthington 的一个模块。他写了一个工具来自动实现监控器模式。如果你安装了 <a href="https://github.com/jnthn/oo-monitors">OO::Monitors</a>, 你可以把上面的链表改写成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use OO::Monitors;

monitor LinkedListMonitor {
    has $.data;
    has $!next;

    method !tail() {
        my $here = self;
        loop { return $here without $here.next; $here = $here.next }
    }

    method push($data) {
        self!tail.next = LinkiedListSafe.new(:$data);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>monitor</code> 是一个实现监控模式的类(<code>class</code>)。每个方法都会自动为你加锁保护。</p>
</div>
<div class="paragraph">
<p>如果你需要使一个有状态的对象线程安全, 并且你希望有一个简单的机制来实现, 那么这是一个合理的模式。不过如果性能是首要考虑的问题, 那么监控对象可能不适合你。最后, 要知道, 这种模式完全依赖于深思熟虑的 <strong>OO</strong> 设计来工作。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/13/the-monitor-pattern/">https://zostay.com/posts/2019/12/13/the-monitor-pattern/</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_比较并交换标量">92. 比较并交换标量</h2>
<div class="sectionbody">
<div class="paragraph">
<p>之前, 我讨论了比较和交换操作, 作为对 <a href="https://docs.raku.org/type/atomicint">atomicint</a> 变量进行的操作。这只是冰山一角。虽然大多数原子表情符号 ⚛️ 运算符只适用于 <code>atomicints</code>, 但 <code>cas</code> 函数、<code>atomic-fetch</code>(或前缀 ⚛️ 运算符)和 <code>atomic-assign</code>(或 ⚛️= 运算符)都可以用于任何一种 <a href="https://docs.raku.org/type/Scalar">Scalar</a> 变量。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/14/compare-and-swap-your-scalars/cover-ryan-hafey-i5n6WHtvQ4c-unsplash_hu99555bcdeb04e0e215e55c02c705a2b4_2576715_280x280_fill_q75_box_smart1.jpg" alt="Compare-and-swap Your Scalars"/>
</div>
</div>
<div class="paragraph">
<p>首先, 我们需要确定我们知道什么是 Scalar。在 Raku 中, 每个变量名都与一个容器相关联。如果你想知道它是如何工作的, 我推荐你阅读关于<a href="https://docs.raku.org/language/containers">容器</a>的语言文档。对于我们的目的来说, 只要说几乎所有以 <code>$</code> 魔符开头的常规变量都被一个  Scalar 所包含就足够了。如果你做了一些特殊的事情来初始化这样的变量, 那么它可能没有 Scalar 容器。</p>
</div>
<div class="paragraph">
<p>这里有一个快速的例子, 应该足够说明我们的目的了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Any typical $ sigil variable represents a Scalar container
my $value = 42;

# Each index of an array is normally a Scalar container
my @array;
@array[0] = 10;

# Binding directly to Int, so this is NOT a Scalar.
my $constant := 100; # NOT Scalar

# Binding direclty on an array index is also NOT a Scalar.
@array[1] := 20; # NOT Scalar

# Proxy containers are NOT Scalar containers
my $special := Proxy.new(
    FETCH =&gt; method () { 10 }
    STORE =&gt; method ($v) { 10 }
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你试图在非 Scalar 容器上使用 <a href="https://docs.raku.org/type/Scalar#sub_cas">cas</a>, Raku 会抛出一个类似于&#34;Proxy 容器不知道如何进行原子比较和交换&#34;的异常, 所以在大多数情况下, 出错的位置应该很明显。</p>
</div>
<div class="paragraph">
<p>够了。如何使用它呢？让我们试着举个例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $atomic-string = &#39;&#39;;
start {
    loop {
        cas $atomic-string, -&gt; $v {
            if $v.ends-with(&#39;A&#39;) { &#34;$vB&#34; }
            else { $v }
        }
        sleep rand;
    }
}
start {
    loop {
        cas $atomic-string, -&gt; $v {
            if $v eq &#39;&#39; || $v.ends-with(&#39;B&#39;) { &#34;$vA&#34; }
            else { $v }
        }
        sleep rand;
    }
}
start {
    loop {
        given ⚛️$atomic-string {
            if .ends-with(&#39;B&#39;) &amp;&amp; .chars %% 10 { .say }
        }
        sleep rand;
    }
}

sleep 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是个没什么用的程序, 但它展示了你可以做的事情。我们只有一个常规变量, 存储一个空字符串来开始。然后我们有三个任务同时运行。第一个任务使用 <code>cas</code> 操作查看字符串是否以 &#34;A&#34; 结尾, 如果是, 则添加一个 &#34;B&#34;。第二个任务使用 <code>cas</code> 操作查看字符串是否为空或以 &#34;B&#34; 结尾, 如果是, 则添加 &#34;A&#34;。第三种操作只有在字符串以 &#34;B&#34; 结尾并且长度是 10 的倍数时才会输出。它运行 10 秒后退出。这是一个效率很低的程序, 在我的笔记本上运行一次, 输出的结果是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">ABABABABAB
ABABABABAB
ABABABABAB
ABABABABABABABABABAB
ABABABABABABABABABABABABABABAB</code></pre>
</div>
</div>
<div class="paragraph">
<p>本质上, 每个 Scalar 内部都可以访问一个 atomicint, 它是用来在改变时锁定标量的。这些可以比使用 Lock 对象更有效率。当对某些数据的访问竞争很激烈时, <code>cas</code> 很可能会输, 因为每个试图处理数据的线程都会忙于等待。然而, 当对该项的争夺较低, 而且你不需要高效地阻塞和恢复线程时, <code>cas</code> 操作可以更高效。这可能需要对每种方法进行一些 AB 测试, 以确定哪种方法对你的特定情况最有效。</p>
</div>
<div class="paragraph">
<p>这个月晚些时候, 我计划更详细地演示一下如何使用这种 <code>cas</code> 操作来实现无锁的数据结构。所以我们很快就会再次回到这个话题。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/14/compare-and-swap-your-scalars/" class="bare">https://zostay.com/posts/2019/12/14/compare-and-swap-your-scalars/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_拆解异步问题">93. 拆解异步问题</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在编写异步代码时, 我经常面临的一个挑战就是想办法把问题合理的分解。我应该把代码分解到什么程度？我到底要走多少步？我如何处理分支或分叉的任务？我如何处理我所创建的相互依赖关系？我在这篇文章中希望给出一些我所学到的准则和一些工具来回答这些问题。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/15/breaking-down-async-problems/cover-kazuky-akayashi-uZS1IHEqfxU-unsplash_hu3077ccc5ff33dca4029a7fecb4c6b155_4432907_280x280_fill_q75_box_smart1.jpg" alt="Breaking Down Async Problems"/>
</div>
</div>
<div class="paragraph">
<p>这篇降临日历的文章将集中在异步问题上。在日历的后面, 我再来考虑同样的问题, 重点是并发问题。</p>
</div>
<div class="sect2">
<h3 id="_异步问题的特殊性">93.1. 异步问题的特殊性</h3>
<div class="paragraph">
<p>这个问题与更多传统的编程问题相比, 性质不同, 但实际实质并无不同。就像你在编写软件时, 需要用函数、方法和子程序将软件分解成几块一样, 你在处理异步问题时也大体如此。</p>
</div>
<div class="paragraph">
<p>那么, 是什么特殊的&#34;特征&#34;让这些异步问题与众不同。那么, 是什么让异步程序成为异步的呢？就是调用和结果之间的分离。你发起工作, 只要有两个因素为真, 你处理结果的代码就会工作。</p>
</div>
<div class="paragraph">
<p>你准备好了处理工作, 并且结果是可用的。因此, 异步问题的特殊性在于, 你要以这样的方式来工作, 以确保这两个条件尽可能多地为真, 从而使你的代码在结果准备好处理的那一刻, 就可以处理处理结果的工作。</p>
</div>
<div class="paragraph">
<p>这是你在看分解异步问题时唯一需要特别考虑的地方。否则, 你的编程问题都是典型的编程问题。说到这里, 现在让我们考虑一下 Raku 中各种类型的异步编码方法的一些实际考虑。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_react_块">93.2. 使用 react 块</h3>
<div class="paragraph">
<p>我的第一条实用建议是, 每当你需要将你的工作聚集在一起时, 总是使用 <a href="https://docs.raku.org/language/concurrency#index-entry-react">react</a> 块。<code>react</code> 块是协调多个异步进程一起工作的完美场所。</p>
</div>
<div class="paragraph">
<p>举个例子, 我使用 Raku 程序来静态地渲染这个网站。我为此开发的工具有一个名为 <code>build-loop</code> 的模式, 它监视文件的变化, 并在这些变化发生时重建网站。在生产中, 它监控一个套接字, 每当同步工具检测到主 <code>git repo</code> 有变化时, 它就会被 ping。在开发中, 它使用 <a href="https://docs.raku.org/type/IO::Notification">IO::Notification</a> 来监视磁盘上的变化, 并且还运行一个微型 Web 服务器, 这样我就可以以模拟部署系统的方式来服务这些文件。</p>
</div>
<div class="paragraph">
<p>它有一个主 <code>react</code> 块, 看起来是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    my $needs-rebuild = True;
    with $notify-port {
        whenever IO::Socket::Async.listen(&#39;127.0.0.1&#39;, $notify-port) -&gt; $conn {
            # manage a connection to set $needs-rebuild on ping
        }
    }

    with $server-port {
        whenever IO::Socket::Async.listen(&#39;127.0.0.1&#39;, $server-port) -&gt; $conn {
            # micro-web server for developer mode here
        }
    }

    whenever Supply.interval($interval, :$delay) {
        if $needs-rebuild {
            $needs-trigger--;
            build-site();
        }

        once {
            # configure IO::Notification to set $needs-rebuild on change
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我省略了很多细节, 但这应该能让你有个感觉。我能够协调不同的手段, 通过这些手段, 我可以发现导致网站重建的变化。我有一个工具, 可以把重建的次数控制在只有 <code>$interval</code> 秒的频率, 这样就一组变化就不会无休止地重新触发构建。我可以同时运行一个小型的 Web 服务器, 在开发者模式下为内容提供服务。而且我是在同一个事件循环中使用单线程来完成这一切的。</p>
</div>
<div class="paragraph">
<p>好的地方在于, 对于一个 <code>react</code> 内的每一个 <code>whenever</code>, 我们可以共享变量和状态, 而不必担心线程安全问题。这些块可能在同一个线程上运行, 也可能不在同一个线程上运行, 但无论如何, Raku 保证它们不会并发运行。</p>
</div>
<div class="paragraph">
<p>因此, react 块非常适合将各种任务协调在一起。几乎我写的每一个异步程序都会在某个地方有一个这样的主循环。如果任务具有很强的独立性, 我可以为每组任务设置一个事件循环, 而 <code>react</code> 块则在 <a href="https://docs.raku.org/language/control#index-entry-control_flow_start-start">start</a> 中运行。例如, 我可以用事件循环来处理图形更新, 用另一个事件循环来运行网络后端。</p>
</div>
<div class="sect3">
<h4 id="_首选管道">93.2.1. 首选管道</h4>
<div class="paragraph">
<p>每当你分解问题时, 你往往会选择创建一个 <a href="https://docs.raku.org/type/Supplier">Supplier</a> 对象, 并将数据输入其中, 或者是管道化。如果你可以管道化, 那么你就应该管道化。最简单的管道的例子是 <a href="https://docs.raku.org/type/Supply">Supply</a> 上的 <a href="https://docs.raku.org/type/Supply#method_map">.map</a> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $original = Supply.interval(1);
my Supply $plus-one = $original.map(* + 1);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样做大大简化了你的处理过程。它清楚地展示了一个任务对前一个任务的依赖性。它很容易阅读和遵循。它将为你省去许多麻烦。</p>
</div>
<div class="paragraph">
<p>关于其他类似的内置映射函数, 请参阅 Supply 的文档。我最喜欢的一个是 <a href="https://docs.raku.org/type/Supply#method_lines">.lines</a>, 它可以把一个发出字符串的 Supply 变成一个由换行符分解的字符串列表。</p>
</div>
<div class="paragraph">
<p><a href="https://cro.services/">Cro</a> 服务平台将这种平台的概念正式化为转换。几乎整个系统都是一个从请求到响应的管道, 其中每一步都将输入转化为接近最终输出的一步。这是一种非常强大的处理异步处理(async processing)的手段。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_让任何事情都成为供应">93.3. 让任何事情都成为供应</h3>
<div class="paragraph">
<p>如果你正在构建一个列表, 你可以使用 <a href="https://docs.raku.org/language/concurrency#index-entry-supply_%28on-demand%29">supply</a> 块来制作这个列表。这对于非琐碎的流程或者需要经常重复使用 <code>Supply</code> 的时候, 效果最好。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $primes = supply {
    for 1...* -&gt; $n {
        emit $n if $n.is-prime;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在像上面的 <code>supply</code> 块这样的琐碎处理中, 在只需要分接(tap)一次的情况下, 更简单的方法可能是通过在序列上调用 <a href="https://docs.raku.org/routine/Supply#class_Any">.Supply</a> 将 <a href="https://docs.raku.org/type/Seq">Seq</a> 变成 <code>Supply</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $primes = (1...*).grep(*.is-prime).Supply;</code></pre>
</div>
</div>
<div class="paragraph">
<p>后一个例子在功能上等同于第一个例子, 在我看来, 更容易阅读和理解。然而, 当你需要生成一个可重用的 <code>Supply</code> 或基于非琐碎逻辑的 <code>Supply</code> 时, 请准备好 <code>supply</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用_supplier_进行拆分和连接">93.4. 使用 Supplier 进行拆分和连接</h3>
<div class="paragraph">
<p>当你有一组对象进来需要不同的处理时, 你可以在这里插入一个 <code>if</code> 语句来处理每一种情况, 或者你也可以将这些项重新发射到不同的流中进行处理。如果处理的情况不复杂, 可以考虑为每种类型的处理使用一个单独的 <code>Supplier</code> 对象。然后, 如果有必要的话, 再使用一个 <code>Supplier</code> 将这些流重新连接起来。</p>
</div>
<div class="paragraph">
<p>这类似于决定是否对一个有多种解决方案的问题使用单独的子程序。不使用单独的子程序(<code>sub</code>), 可以使用单独的 <code>whenever</code> 来代替。</p>
</div>
<div class="paragraph">
<p>考虑一下这个问题, 我们有一个合并的日志, 我们想把错误对象和访问对象区别对待。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    my Supplier $emitter .= new;
    my Supplier $error .= new;
    my Supplier $access .= new;

    whenever $emitter.Supply { .say }
    whenever $error.Supply -&gt; %e {
        $emitted.emit: &#34;%e&lt;timestamp&gt; Error %e&lt;code&gt;: %e&lt;message&gt;&#34;;
    }
    whenever $access.Supply -&gt; %a {
        $emitted.emit: &#34;%a&lt;timestamp&gt; Access: %a&lt;url&gt;&#34;;
    }
    whenever $log.Supply.lines -&gt; $line {
        given $line.&amp;from-json {
            when so .&lt;type&gt; eq &#39;error&#39; { $error.emit: $_ }
            when so .&lt;type&gt; eq &#39;access&#39; { $access.emit: $_ }
            default { die &#34;invalid log type&#34; }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>拆分和连接可以更好的原因是, 它可以更容易阅读和理解, 因为每个 <code>whenever</code> 都集中在一个任务上。在一个分支涉及较长的进程, 而另一个分支涉及较短的进程的情况下, 它还可以让你考虑如何最好地分别优化每个任务。</p>
</div>
</div>
<div class="sect2">
<h3 id="_按需供应与现场供应">93.5. 按需供应与现场供应</h3>
<div class="paragraph">
<p>你应该知道各种供应(supply)之间的区别。它们之间的区别有些微妙, 可以在一定程度上互换使用。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用 <code>Supplier</code> 类创建一个实时供应(live supply)。有一个单一的事件流, 这些事件是由关联的 <code>Supply</code> 对象上的当前分接器(tap)接收的。如果没有分接器(tap), 则不处理这些事件。如果有 N 个分接器(tap), <code>Supplier</code> 对象的 <a href="https://docs.raku.org/type/Supplier#method_emit">.emit</a> 方法会阻塞, 直到每个分接器(tap)处理完该事件。</p>
</li>
<li>
<p>使用 <code>supply</code> 块或通过调用列表上的 <code>.Supply</code> 方法来创建按需供应(on-demand supply)。<code>Supply</code> 的每个分接器(tap)实际上是一个独立的进程, 从头到尾接收由该供应对象生成的所有项。生成供应中每个项的代码都会被运行, 再次在 <code>supply</code> 块中<a href="https://docs.raku.org/language/control#supply/emit">发射</a>, 直到单次分接(tap)完成。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>从本质上说, 实时供应(live supply)使用的是扇出式(fan-out)架构, 而按需供应(on-demand supply)在行为上其实只是 <code>Seq</code> 的一个变种。我认为按需供应只是一个适配器(adapter), 使返回序列的函数与 <code>whenever</code> 块一起工作。</p>
</div>
</div>
<div class="sect2">
<h3 id="_避免_supplierpreserving">93.6. 避免 Supplier::Preserving</h3>
<div class="paragraph">
<p>还有就是 <a href="https://docs.raku.org/type/Supplier::Preserving">Supplier::Preserving</a>。有人认为这是两种类型之间的中间地带。然而, 这个对象的语义与现场供应(live supply)的语义完全相同, 但有一个例外:当没有分接器(tap)时, 这个对象会缓冲发出的事件, 并立即将这些对象转储到第一个出现的分接器(tap)中。</p>
</div>
<div class="paragraph">
<p>因此, 它主要是在开始发射前很难初始化分接器(tap)的情况下的一种便利。比如说:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Supplier::Preserving $msg .= new;
$msg.emit($_) for ^10;
$msg.Supply.tap: { .say };</code></pre>
</div>
</div>
<div class="paragraph">
<p>即使在向 <code>$msg</code> 发射后发生了分接(tap), 程序也会打印出从1到10的数字。</p>
</div>
<div class="paragraph">
<p>问题是 <code>Supplier::Preserving</code> 有相关的风险, 比如第一次分接(tap)时, 内存膨胀或在旧数据上长时间的迭代。相反, 你应该更倾向于使用 <code>Supplier</code>, 并在发射之前确保所有的分接(tap)都到位。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Supplier $msg .new new;
$msg.Supply.tap: { .say }
$msg.emit($_) for ^10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者只是能够在开始的时候错过一些。有些情况下, 你可能真的想用 <a href="https://docs.raku.org/type/Channel">Channel</a> 来代替。</p>
</div>
<div class="paragraph">
<p>有些情况下, <code>Supplier::Preserving</code> 是很方便的, 所以根据需要利用它。我只是发现当我偷懒的时候, 它是适当的引导的一个简单的拐杖, 但在大多数情况下, 随着时间的推移, 它让我很烦。</p>
</div>
</div>
<div class="sect2">
<h3 id="_拆分长期运行的_whenever_块">93.7. 拆分长期运行的 whenever 块</h3>
<div class="paragraph">
<p>对于你的任务来说, 什么是合理的, 可能会有所不同, 但请记住, 在 <code>react</code> 块内运行的代码, 一个 <code>whenever</code> 块会阻塞所有其他块的运行。<code>react</code> 块实际上只是在老式事件循环的薄薄一层外衣, 在这里任何子任务都会饿死其他任务的处理时间。</p>
</div>
<div class="paragraph">
<p>例如, 考虑一下我在上面提到的 <code>build-loop</code> 工具的 <code>react</code> 块。当 <code>build-site()</code> 例程运行时, 我的 Web 服务器无法刷新。这样可以吗？</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>这是一个开发过程, 所以我可以容忍 Web 服务器运行过程中的一些奇怪现象。</p>
</li>
<li>
<p>我是唯一的开发者。</p>
</li>
<li>
<p>这意味着我的网站要等到网站建设完成后才能刷新。</p>
</li>
<li>
<p>我更愿意等待, 只看到新鲜的内容。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>听起来, 这对我来说是个胜利。</p>
</div>
<div class="paragraph">
<p>在生产中, 我是不会容忍的。在网络内容方面, 如果要花费超过几毫秒的时间来构建, 那么现在的旧内容几乎总是比最新鲜的内容要好。在这种情况下, 我会设置一个单独的 Web 服务器线程。在这种特殊情况下, 根本没有应用服务器, 只有静态内容, 所以没有必要。</p>
</div>
<div class="paragraph">
<p>这就是你在设计 <code>whenever</code> 块时必须要做的那种权衡。如果一个 <code>whenever</code> 块运行时间过长, 其他块就会被推迟。如果这是件坏事, 那就把那个 <code>whenever</code> 块分成一系列较小的 <code>whenever</code> 块, 把它们链在一起。在一些运行时间较长的过程中, 每当你完成一个 <code>whenever</code> 块的时候, 都是一个潜在的饥饿任务轮到它的机会。</p>
</div>
<div class="paragraph">
<p>如果这样的任务仍然是个问题, 你可能需要通过 <code>start</code> 块把它移到另一个线程中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_批量短任务">93.8. 批量短任务</h3>
<div class="paragraph">
<p>另外, 琐碎的任务会涉及到一定的开销, 让 <code>react</code> 块之间进行切换。如果一个任务速度超级快, 你可能会考虑使用 <code>Supply</code> 上的 <a href="https://docs.raku.org/type/Supply#method_batch"><code>.batch</code></a> 方法, 让你在元素组上循环, 以避免频繁切换任务。<a href="https://docs.raku.org/type/Supply#method_batch">.batch</a> 方法之所以方便, 是因为它可以让你把一个问题在时间延迟和元素数量上进行分解。这将让你的程序有更多的时间去做真正的工作, 而不是花更少的时间去做决定下一步安排哪个任务的繁忙工作。</p>
</div>
</div>
<div class="sect2">
<h3 id="_避免休眠">93.9. 避免休眠</h3>
<div class="paragraph">
<p>如果你在一个 <code>react</code> 块中, 你不希望调用 <a href="https://docs.raku.org/type/Date#sub_sleep">sleep</a>, 除非你的目的是阻止当前线程的所有执行。否则, 你最好使用 <a href="https://docs.raku.org/routine/await">await</a> 来暂停你的任务。如果你这样做, 你的 <code>react</code> 块可以继续处理事件, 直到 <code>await</code> 完成。如果你需要在若干秒内添加一个 <code>await</code>, 你可以这样做。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">await Promise.in(10); # sleep 10 seconds</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_谨防死锁">93.10. 谨防死锁</h3>
<div class="paragraph">
<p>尽管 Raku 的接口是可以组合的, 但如果你使用不当, 仍然有可能导致死锁。<code>react</code> 块内的任何东西都保证以顺序的方式运行。这意味着, 如果你期望两个 <code>whenever</code> 块能够同时运行, 那么当代码突然停止时, 你会很失望。我之所以提到这一点, 是因为我时不时会遇到这个问题。即使我知道 <code>react</code> 块执行的是单线程一次的规则, 但我还是会时不时地想象多个 <code>whenever</code> 块可以同时运行。</p>
</div>
<div class="paragraph">
<p>如果你真的需要这样, 这很容易解决。只要在 <code>whenever</code> 块里面放一个 <code>start</code> 块, 就可以让两段代码同时运行。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论_8">93.11. 结论</h3>
<div class="paragraph">
<p>暂时到此为止。几天后, 我们将再来讨论这个话题, 但不是异步, 而是考虑分工并发处理的准则。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/15/breaking-down-async-problems/" class="bare">https://zostay.com/posts/2019/12/15/breaking-down-async-problems/</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_信号量">94. 信号量</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/16/semaphores/_hub7f3ac8d1cb0b33d101673df85949210_1816497_248defd7f26318921ad630d203317a47.jpg" alt="semaphore"/>
</div>
</div>
<div class="paragraph">
<p>信号量(semaphore)是一个使用标志发送消息的系统。哦, 等等, 这就是计算机之外的信号量(semaphore)。在计算机中, 信号量(semaphore)就像一种锁, 被获取 N 次后就会被锁住。这对于你有 N 个项的资源, 当你知道有资源可用的时候, 想要快速分配, 然后立即阻止, 直到资源被释放出来的情况下, 是很有用的。Raku 为此提供了一个内置的 <a href="https://docs.raku.org/type/Semaphore">Semaphore</a> 类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class ConnectionPool {
    has @.connections;
    has Semaphore $!lock;

    submethod BUILD(:@!connections) {
        $!lock .= new(@!connections.elems);
    }

    method use-connection() {
        $!lock.acquire;
        pop @!connections;
    }

    method return-connection($connection) {
        push @!connections, $connection;
        $!lock.release;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, 我们有一个连接池, 在这里我们可以快速、安全地从连接堆栈中拉取条目。但是, 一旦最后一个连接被拉出, <code>.use-connection</code> 方法就会阻塞, 直到使用 <code>.return-connection</code> 返回一个连接。</p>
</div>
<div class="paragraph">
<p>还有一个额外的 <a href="https://docs.raku.org/type/Semaphore#method_try_acquire">.try_acquire</a> 方法可以用来代替 <a href="https://docs.raku.org/type/Semaphore#method_acquire">.acquire</a>, 它返回一个决定成败的 <a href="https://docs.raku.org/type/Bool">Bool</a>。例如, 我们可能会有一个用于按键的缓冲区, 如果缓冲区填满了, 我们希望它失败, 而不是继续存储按键事件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class KeyBuffer {
    has UInt $.size;
    has UInt $!read-cursor = 0;
    has UInt $!write-cursor = 0;
    has byte @!key-buffer;
    has Semaphore $!buffer-space;
    has Semaphore $!lock .= new(1);

    submethod BUILD(UInt :$!size) {
        @!key-buffer = 0 xx $!size;
        $!buffer-free .= new($!size);
    }

    method !increment-cursor($cursor is rw) {
        $cursor++;
        $cursor %= $!size;
    }

    method store(byte $key) {
        $!buffer-space.try_acquire or die &#34;buffer is full!&#34;

        $!lock.acquire;
        LEAVE $!lock.free;

        @!key-buffer[ $!write-cursor ] = $key;
        self!increment-cursor($!write-cursor);
    }

    method getc(--&gt; byte) {
        my $result = 0;

        $!lock.acquire;
        LEAVE $!lock.release;

        if $!read-cursor != $!write-cursor {
            $result = @!key-buffer[ $!read-cursor ];
            self!increment-cursor($!read-cursor);

            $!buffer-space.release;
        }

        $result;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个数据结构使用了两个信号量。其中一个名为 <code>$!lock</code>, 和 <a href="https://docs.raku.org/type/Lock">Lock</a> 的工作方式一样, 用来保护关键部分, 并确保它们是原子的。另一个叫 <code>$!buffer-space</code>, 用于确保当缓冲区填满时, 写操作失败。</p>
</div>
<div class="paragraph">
<p>如你所见, 我们使用 <code>.try_acquire</code> 方法从 <code>Semaphore</code> 中获取资源。如果该方法返回 <code>False</code>, 我们会抛出一个异常, 让调用者知道操作失败。如果该方法返回 <code>True</code>, 那么我们就获得了向缓冲区添加另一个条目的权限。当我们从缓冲区中读取时, 我们仍然使用 <a href="https://docs.raku.org/type/Semaphore#method_release">.release</a> 来再次标记可用的空间。</p>
</div>
<div class="paragraph">
<p>我之所以用 <code>Semaphore</code> 来做互斥锁, 是因为它可以用这种方式, 这就是我们要讨论的问题。然而让, Lock 或者 <a href="https://docs.raku.org/type/Lock::Async">Lock:::Async</a> 的 <code>protect</code> 方法在这里可能是更好的选择, 因为你不需要小心翼翼地确保 <code>.release</code> 被调用, 因为 <code>.protect</code> 块为你处理了这个问题。也就是说, <a href="https://docs.raku.org/language/phasers#LEAVE">LEAVE</a> phaser 是确保 <code>.release</code> 被调用的好方法, 因为无论块如何退出, LEAVE phaser 都会被调用（也就是说, 即使是在异常情况下也会运行）。</p>
</div>
<div class="paragraph">
<p>需要注意的是, 如果在上面的 <code>.getc</code> 方法中, 在 <code>$!read-cursor</code> 被增量后, 但在 <code>$!buffer-space.release</code> 被调用之前, 如果发生了异常, 你可能会让缓冲区处于一个糟糕的状态, 它不再有那么多的空间。因此, 一个可能值得做的改进是确保 <code>if</code> 块中的异常被捕获并处理, 如果这种异常是可能的。</p>
</div>
<div class="paragraph">
<p>一般要记住的是, 每当处理并发性的时候, 看似微不足道的边缘情况很容易变得很重要。有时会以不可预见的方式变得很重要。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/16/semaphores/" class="bare">https://zostay.com/posts/2019/12/16/semaphores/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_比较_react_与_tap">95. 比较 react 与 tap</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 中, 我们有几种基本的方式来获取从 <a href="https://docs.raku.org/type/Supply">Supply</a> 发出的事件, 这就引出了一个问题, 那就是每一种方式之间有什么区别？我想通过创建一个带有几个间隔的 <a href="https://docs.raku.org/language/concurrency#index-entry-react">react</a> 块来回答这个问题, 然后用 <a href="https://docs.raku.org/type/Supply#method_tap">tap</a> 来模拟同样的基本功能。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/17/comparing-react-with-tap/cover-fikri-rasyid-LJnRzbDFdI4-unsplash_hu242dc4845fc5428385ea04be07c767ec_2222285_280x280_fill_q75_box_smart1.jpg" alt="react"/>
</div>
</div>
<div class="paragraph">
<p>让我们从我们的基础 <code>react</code> 块开始:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub seconds { state $base = now; now - $base }
react {
    say &#34;REACT 1: {seconds}&#34;;

    whenever Supply.interval(1) {
        say &#34;INTERVAL 1-$_: {seconds}&#34;;
        done if $_ &gt; 3;
    }

    say &#34;REACT 2: {seconds}&#34;;

    whenever Supply.interval(0.5) {
        say &#34;INTERVAL 2-$_: {seconds}&#34;;
    }

    say &#34;REACT 3: {seconds}&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>seconds</code> 例程只是一个辅助工具, 为我们提供从块开始到工作的时间(以秒为单位)。这个代码块的输出通常会类似于这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">REACT 1: 0.0011569
REACT 2: 0.0068571
REACT 3: 0.008015
INTERVAL 1-0: 0.0092906
INTERVAL 2-0: 0.0101116
INTERVAL 2-1: 0.5103139
INTERVAL 1-1: 1.007995
INTERVAL 2-2: 1.022309
INTERVAL 2-3: 1.5124228
INTERVAL 1-2: 2.0137509
INTERVAL 2-4: 2.014717
INTERVAL 2-5: 2.517795
INTERVAL 1-3: 3.016291
INTERVAL 2-6: 3.0182612
INTERVAL 2-7: 3.521018
INTERVAL 1-4: 4.0182113</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么它是什么意思呢？嗯, 首先要注意的是, <code>react</code> 块本身的所有代码都会先运行。也就是说, 它运行所有的命令, 包括每个 <code>whenever</code> 块来注册每个 <code>Supply</code> 的事件 tap, 但还不运行代码。一旦 <code>react</code> 块完成运行, 它就会进行阻塞, 直到所有的 <code>whenever</code> 块都运行完毕或者是遇到 <code>done</code> 语句。这时, 所有的供应都会被解开(untapped), 继续执行。</p>
</div>
<div class="paragraph">
<p>顺便说一下, 如果你想在一个 <code>react</code> 块完成后让一个块运行(或者说一个供应块), 你可以使用特殊的 <a href="https://docs.raku.org/language/phasers#CLOSE">CLOSE</a> phaser。<a href="https://docs.raku.org/language/phasers#LEAVE">LEAVE</a> phaser 会在 <code>react</code> 块中的代码完成 设置 <code>react</code> 后立即退出。</p>
</div>
<div class="paragraph">
<p>除此以外, 必须注意的是, 与 <code>react</code> 块相关的一切都只会按顺序运行。Raku 并没有承诺在一个线程中运行, 但它承诺一个 <code>react</code> 块里面的两部分代码不会并发运行。这包括第一次运行通过执行 <code>react</code> 块本身, 以及执行 <code>react</code> 向供应发射值的 <code>whenever</code> 块。</p>
</div>
<div class="paragraph">
<p>那么, 我们应该如何使用 <code>.tap</code> 来实现这种行为呢？我们可以这样做。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub seconds { state $base = now; now - $base }
REACT: {
    say &#34;REACT 1: {seconds}&#34;;

    my $ready = Promise.new;
    my $mutex = Lock.new;
    my $finished = my $done = Promise.new;

    my $interval1 = Supply.interval(1).tap: {
        await $ready;
        $mutex.protect: {
            say &#34;INTERVAL 1-$_: {seconds}&#34;;
            $done.keep if $_ &gt; 3;
        }
    }

    $finished .= then: -&gt; $p {
        $interval1.close;
    }

    say &#34;REACT 2: {seconds}&#34;;

    my $interval2 = Supply.interval(0.5).tap: {
        await $ready;
        $mutex.protect: {
            say &#34;INTERVAL 2-$_: {seconds}&#34;;
        }
    }

    $finished .= then: -&gt; $p {
        $interval2.close;
    }

    say &#34;REACT 3: {seconds}&#34;;

    $ready.keep;
    await $finished;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这与 <code>react</code> 块的实际工作类似, 但多了几个手动步骤。首先, 我们必须准备几个承诺(Promise)。<code>$ready</code> <a href="https://docs.raku.org/type/Promise">Promise</a> 是保留在 &#34;react&#34; 块的结尾, 以释放 tap 进行工作。<code>$done</code> Promise 是我们保留主线程的地方, 直到执行完成。</p>
</div>
<div class="paragraph">
<p>我还没有实现如果所有的供给都完成了, 就自动保留 <code>$done</code> 的额外逻辑。这样做可以通过为每个 tap 创建另一个 Promise 来实现, 当 tap done 块被执行时, 这个Promise将被保留。可以为所有这些 <a href="https://docs.raku.org/type/Promise#method_allof">Promise.allof()</a> 承诺附加一个 <a href="https://docs.raku.org/type/Promise#method_then">.then</a> 块。我把解决这个问题作为一个练习留给读者。</p>
</div>
<div class="paragraph">
<p>另一个主要的新增功能是 <code>$mutex</code> <a href="https://docs.raku.org/type/Lock">lock</a> 对象。这可以防止各个 tap 块同时运行。</p>
</div>
<div class="paragraph">
<p>这应该就足够了。这可能不是最有效的解决方案, 但它确实展示了 <code>react</code> 块给你带来的额外帮助。你可能会注意到 tap 版本的速度稍微快了一点。这并不奇怪。这个 <code>tap</code> 版本不像 <code>react</code> 块那样精心组织。因此, 如果多花几毫秒的时间对你的代码很重要, 你可以考虑直接使用 tap 和其他工具来实现你的异步协调代码, 而不是使用 <code>react</code> 块。但是, 要注意的是, <code>react</code> 块很可能通过为你做那些繁琐的小细节, 为你的调试省去了一大堆麻烦。</p>
</div>
<div class="paragraph">
<p>还有最后一点, <a href="https://docs.raku.org/type/Supply#method_act">act</a> 方法的文档中说, 它的工作原理和 tap 一样, 但给定的代码一次只由一个线程执行。我真的不清楚这到底是什么意思, 因为这个基本保证也是 tap 所固有的。这是因为在所有的 tap 运行完毕之前, <code>Supply</code> 无法继续进行另一个发出的消息。在实践中, 分接(tap)也都是同步运行每个消息的。在我所有的工作中, 我还没有发现任何证据表明在一个给定的 <code>Supply</code> 上的 tap 会同时运行。无论如何, 如果有人能继续在 <a href="https://www.reddit.com/r/rakulang/comments/ebpf8j/zostay_advent_day_17_comparing_react_with_tap/">Reddit</a> 上发表这个帖子, 并解释一下 tap 和 act 之间的实际区别是什么, 我将不胜感激。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/17/comparing-react-with-tap/" class="bare">https://zostay.com/posts/2019/12/17/comparing-react-with-tap/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_supply_反压">96. Supply 反压</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 中, <a href="https://docs.raku.org/type/Supply">Supply</a> 是线程之间发送消息的主要工具之一。从 <code>Supply</code> 的结构方式来看, 很明显, 它为一个或多个任务提供了一种向多个接收方任务发送事件的手段。然而, 不那么明显的是, <code>Supply</code> 会给发送者带来一定的成本。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/18/supply-back-pressure/cover-toa-heftiba-a9pFSC8dTlo-unsplash_hu71d190ba122c284277c5e37c86e316cf_716097_280x280_fill_q75_box_smart1.jpg" alt="Supply Back Pressure"/>
</div>
</div>
<div class="paragraph">
<p>考虑一下这个程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $counter = Supplier.new;
start react whenever $counter.Supply {
    say &#34;A pre-whenever $_&#34;;
    sleep rand;
    say &#34;A post-whenever $_&#34;;
}
start react whenever $counter.Supply {
    say &#34;B pre-whenever $_&#34;;
    sleep rand;
    say &#34;B post-whenever $_&#34;;
}
start for 1...* {
    say &#34;pre-emit $_&#34;;
    $counter.emit($_);
    say &#34;post-emit $_&#34;;
}
sleep 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里我们有三个任务在运行, 每个任务都在一个独立的线程中。我们让主程序在10秒后退出。前两个线程接收来自 <code>$counter.Supply</code> 的消息。第三个线程向这个 <code>Supply</code> 提供一连串的整数。你可能会想, 最后的任务会在传递事件的过程中进行竞赛, 但如果是这样, 那你就错了。</p>
</div>
<div class="paragraph">
<p>考虑一下这个程序的输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">pre-emit 1
A pre-whenever 1
A post-whenever 1
B pre-whenever 1
B post-whenever 1
post-emit 1
pre-emit 2
A pre-whenever 2
A post-whenever 2
B pre-whenever 2
B post-whenever 2
post-emit 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意到一个模式了吗？即使前两个线程有一个随机等待, 第三个线程根本没有等待, 但第三个线程会被阻塞, 直到其他两个线程都完成。这种行为都是一样的, 无论 <code>Supply</code> 是如何被 tap 的, 这种行为都是一样的, 也就是说, 无论你是使用 whenever 块还是调用 <code>.tap</code>, 都没有关系。</p>
</div>
<div class="paragraph">
<p>因此, 如果你想让你的发射器尽可能快地爆破事件, 你需要确保尽快写完 tap, 或者考虑不同的解决方案, 比如使用一个 Channel, 它将任务内存中排队任务, 只要监听该 channel 的线程有时间处理它们, 它们就会得到处理。</p>
</div>
<div class="paragraph">
<p>只要在使用 <code>Supply</code> 的时候注意这个背压成本就可以了。发送者总是要付出代价的。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/18/supply-back-pressure/" class="bare">https://zostay.com/posts/2019/12/18/supply-back-pressure/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_无锁的线程安全结构">97. 无锁的线程安全结构</h2>
<div class="sectionbody">
<div class="paragraph">
<p>正如我之前在这个日历中多次说过的, 最好避免在运行的线程之间共享状态。然而, 这里又是另一种共享状态的方法, 当你需要这样做的时候。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/19/thread-safe-structures-without-locking/cover-raissa-de-paula-ZUgVjh7PFhk-unsplash_hu11d8d3af3484057d8b22e647ddbea047_3449561_280x280_fill_q75_box_smart1.jpg" alt="Thread Safe Structures Without Locking"/>
</div>
</div>
<div class="paragraph">
<p><a href="https://zostay.com/archive/2019/12/13/the-monitor-pattern.html">几天前</a>, 我们考虑将监视器作为创建线程安全对象的一种机制。让我们考虑一下下面的监视器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class BankBalanceMonitor {
    has UInt $.balance = 1000;
    has Lock $!lock .= new;

    method deposit(UInt:D $amount) {
        $!lock.protect: { $!balance += $amount };
    }

    method withdraw(UInt:D $amount) {
        $!lock.protect: { $!balance -= $amount };
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://zostay.com/archive/2019/12/14/compare-and-swap-your-scalars.html">后天</a>我们考虑了比较与交换(compare-and-swap)操作, 也就是 <code>cas</code>, 以及如何在 Raku 中与任何标量变量一起使用它。通过使用 <code>cas</code>, 我们实际上可以在完全不使用锁的情况下创建线程安全对象。</p>
</div>
<div class="paragraph">
<p>因此, 我们可以把上面的类重写成这样的无锁数据结构。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class BankBalanceLockFree {
    has UInt $.balance = 1000;

    method deposit(UInt:D $amount) {
        cas $!balance, -&gt; $current { $current + $amount };
    }

    method withdraw(UInt:D $amount) {
        cas $!balance, -&gt; $current { $current - $amount };
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>就是这样。同样的保护措施, 但现在我们用标量 <code>CAS</code> 操作代替了。这可以比锁定更有效率。但为什么呢？</p>
</div>
<div class="paragraph">
<p>因为每次遇到锁的时候, 开始和结束都会有成本。再加上每一个关键的部分都是一个瓶颈, 多线程系统必须暂时变成单线程。而 <code>CAS</code> 没有特别昂贵的操作, 但可能会导致关键部分多次重跑。</p>
</div>
<div class="paragraph">
<p>让我们考虑一下我们系统中两个变量的极端情况: 竞争和运行时间。竞争(contention)是一个通用术语, 描述了一次需要在关键部分工作的线程数量。这里的运行时间描述的是在关键部分内运行操作所需的时间。</p>
</div>
<div class="paragraph">
<p>如果一个操作有较低的竞争性和较短的运行时间, 那么 <code>CAS</code> 几乎可以肯定会有更好的性能。锁在开始和结束时有很高的开销, 而 <code>CAS</code> 几乎不会有开销。在低竞争性的情况下, 我们可能要时不时地重复一个操作, 但操作的速度很快, 所以没有关系。</p>
</div>
<div class="paragraph">
<p>如果一个操作的竞争性很高, 运行时间很短, <code>CAS</code> 还是很有可能胜出。你可能最终会有一两个线程不得不多次重复操作, 但随着线程数量的增多, 一个锁对单线程瓶颈的执行并不能很好的扩展。</p>
</div>
<div class="paragraph">
<p>如果一个操作的竞争性低, 运行时间长, 那么 <code>CAS</code> 可能是个败笔。如果关键部分真的需要几百毫秒甚至更长的时间, 那么重复的成本可能会更高。不过, 可能值得进行 A/B 测试, 看看哪种方法会赢。</p>
</div>
<div class="paragraph">
<p>如果一个操作具有高竞争性和长运行时间, 锁可能会赢。然而, 在这一点上, 你的操作是否真的可以跨多线程扩展就不太清楚了。在许多竞争线程上长时间锁定的瓶颈, 基本上会使你的应用沦为单线程。也许是时候考虑如何加快操作速度, 或者用不涉及共享状态的方式进行操作了。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/19/thread-safe-structures-without-locking/" class="bare">https://zostay.com/posts/2019/12/19/thread-safe-structures-without-locking/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_拆解并发问题">98. 拆解并发问题</h2>
<div class="sectionbody">
<div class="paragraph">
<p>今天这篇文章的目标是考虑什么时候要同时运行你的任务, 以及如何做到这一点。我不打算为此给出任何规则, 因为一次有效的规则可能在下一次就不管用了。相反, 我将专注于分享一些我从个人经验中学到的准则。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/20/breaking-down-concurrency-problems/cover-mick-haupt-QaCltys9eNw-unsplash_hu0f93f0f550d24bfe14ec296c6d9cfdb9_4033112_280x280_fill_q75_box_smart1.jpg" alt="Breaking Down Concurrency Problems"/>
</div>
</div>
<div class="sect2">
<h3 id="_牢记你的承诺">98.1. 牢记你的承诺</h3>
<div class="paragraph">
<p>每当你使用并发的时候, 你要紧紧抓住相关的 <a href="https://docs.raku.org/type/Promise">Promise</a> 对象。它们几乎都是重新合并(rejoin)你的任务, 使主线程等待你的并发任务完成等等的最佳方式。</p>
</div>
<div class="paragraph">
<p>我在代码中看到的一个常见模式是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $gui-task = start { ... }
my $console  = start { ... }
my $jobs     = start { ... }
await Promise.allof($gui-task, $console, $jobs);</code></pre>
</div>
</div>
<div class="paragraph">
<p>就像这样, 我有三个任务在三个不同的线程中运行, 主线程一直保持到三个任务完成。</p>
</div>
<div class="paragraph">
<p>这个 <code>await</code> 也是你要添加 <code>CATCH</code> 块的地方, 因为其他线程的异常会在这个时候重新合并(rejoin)到调用线程中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_主线程是特殊的">98.2. 主线程是特殊的</h3>
<div class="paragraph">
<p>当你编写并发程序时, 要注意主线程是特殊的。它不会被安排运行任务, 只要它在做某事或等待某事, 你的程序就会继续运行。只要主线程一退出, 你的其他任务就会立即被收割并退出。</p>
</div>
</div>
<div class="sect2">
<h3 id="_倾向于用单线程进行输入或输出">98.3. 倾向于用单线程进行输入或输出</h3>
<div class="paragraph">
<p>避免线程之间共享文件句柄或套接字。每次只有一个线程可以读取或写入一个句柄。确保你安全地做到这一点的最简单的方法是将该活动保持在一个线程中。在一个多线程程序中, 任何线程都可能输出到标准输出或标准错误, 我经常调用类似下面的模式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Supplier $out .= new;
my Supplier $err .= new;
start {
    react {
        whenever $out { .say }
        whenever $err { .note }
    }
}
start {
    for ^10_000 { $out.emit: $_ }
}
start {
    for ^10_000 { $out.emit: $_ }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你不采用这样的模式, 你的程序可能仍然可以工作, 但你的输出可能会出现一些奇怪的怪现象。</p>
</div>
</div>
<div class="sect2">
<h3 id="_raku_数据结构本质上并不安全">98.4. Raku 数据结构本质上并不安全</h3>
<div class="paragraph">
<p>与上一节中说的输入和输出类似, 请注意, 大多数 Raku 数据结构都不是线程安全的。如果你想跨线程使用一个数据结构, 你必须使用一些策略来使该访问线程安全。一些可行的策略是。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用一个线程来管理对该数据结构的访问, 就像上面对标准输出和标准错误所做的那样。</p>
</li>
<li>
<p>使用监视器模式(monitor pattern)来保护数据结构的安全。</p>
</li>
<li>
<p>适当地利用 <a href="https://docs.raku.org/routine/cas">cas</a>、<a href="https://docs.raku.org/type/Lock">Lock</a>、<a href="https://docs.raku.org/type/Lock::Async">Lock:::Async</a>、<a href="https://docs.raku.org/type/Semaphore">Semaphore</a>、Promise 或其他可用的锁机制之一来保护对对象的访问。</p>
</li>
<li>
<p>使用 <a href="https://docs.raku.org/type/Channel">Channel</a> 或 <a href="https://docs.raku.org/type/Supply">Supply</a> 管理对对象的修改。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>无论你做什么, 都不要认为对对象的访问是线程安全的, 除非线程安全是对象设计的明确部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="_在每个_gui_事件循环或窗口中使用任务">98.5. 在每个 GUI 事件循环或窗口中使用任务</h3>
<div class="paragraph">
<p>如果你的应用程序有一个 GUI, 你几乎肯定需要一个单独的线程来管理 GUI 的输入和输出。大多数 GUI 库已经有一个内置的事件循环, 你想把它作为一个任务在一个单独的循环中运行。你可能需要为整个 GUI 设置一个任务, 也可能需要为每个窗口设置一个单独的任务。</p>
</div>
</div>
<div class="sect2">
<h3 id="_批量小任务">98.6. 批量小任务</h3>
<div class="paragraph">
<p>你并不总是希望每个动作都有一个任务。有些动作实在是太琐碎了, 而执行时间又太短, 无法管理。什么是合理的任务规模, 其实取决于你和你的执行环境。只是要注意, 当涉及的处理是琐碎的时候, 分批运行你的任务往往是比以微小的片段运行更好的策略。</p>
</div>
<div class="paragraph">
<p>如果你使用 <code>hyper</code> 或 <code>race</code> <a href="https://docs.raku.org/language/statement-prefixes#index-entry-hyper_%28statement_prefix%29-hyper">关键字</a> 或 <a href="https://docs.raku.org/type/Iterable#method_hyper">方法</a> 来并行化工作, 那么批处理是内置的、自动的。你可能想尝试一下参数, 看看调整任务的批处理大小是否能提高速度。</p>
</div>
</div>
<div class="sect2">
<h3 id="_将较大的任务分解成较小的任务">98.7. 将较大的任务分解成较小的任务</h3>
<div class="paragraph">
<p>有些并发任务, 你只想在 CPU 时间可用时连续运行, 或者每当有事件出现时就触发。然而, 单次运行时间较长的任务有时可以从被分解成较小的任务中受益。可以同时运行的任务数量有限, 将它们分解可以帮助确保 CPU 保持忙碌。</p>
</div>
<div class="paragraph">
<p>将任务分解的一个简单方法是在自然位置插入 <code>await</code> 语句。从 Raku v6.d 开始, 你可以有效地将任务转化为协程(coroutine), 通过使用 <code>await</code> 暂停, 直到 socket 准备好了, 更多的数据进来了, 有信号从 Promise 或 Channel 等处到达, 等等。记住, 任何时候 Raku 遇到 <code>await</code>, 都是 Raku 在为当前任务所使用的线程上的另一个任务安排工作的机会。</p>
</div>
</div>
<div class="sect2">
<h3 id="_小心线程的限制">98.8. 小心线程的限制</h3>
<div class="paragraph">
<p>可用的线程数量是有限的。如果你的任务有可能运行大量的任务, 请花点时间考虑如何分解任务。限制任务之间的依赖数量将使你的程序能够有效地扩展, 而不会耗尽资源。</p>
</div>
<div class="paragraph">
<p>任何时候, 你的任务必须暂停输入或出于任何原因, 确保用 <code>await</code> 来做, 将确保最大数量的线程准备好工作。</p>
</div>
</div>
<div class="sect2">
<h3 id="_避免休眠_2">98.9. 避免休眠</h3>
<div class="paragraph">
<p>我认为 <a href="https://docs.raku.org/type/Date#sub_sleep">sleep</a> 是有害的。相反, 最好使用 <a href="https://docs.raku.org/type/Promise#method_in">await Promise.in(…​)</a>], 因为这让 Raku 能够将当前线程重用到另一个任务中。只有当你故意想在暂停期间锁定一个线程时才使用 <code>sleep</code>。我在这个临终日历中使用 sleep 主要是因为它比较熟悉。在实践中, 我一般只在主线程上使用它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_结论_9">98.10. 结论</h3>
<div class="paragraph">
<p>这些建议中的大部分内容与分解异步问题的建议重叠。我希望这能在编写并发程序时提供一些有用的指导。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/20/breaking-down-concurrency-problems/" class="bare">https://zostay.com/posts/2019/12/20/breaking-down-concurrency-problems/</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_并行循环执行">99. 并行循环执行</h2>
<div class="sectionbody">
<div class="paragraph">
<p>迭代很慢。如果在循环中要处理 N 件事, 则循环将需要 N 次迭代来处理。太慢了。不过有时候这是解决问题的唯一方法。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/21/parallel-loop-execution/cover-federico-beccari-ahi73ZN5P0Y-unsplash_huac7d2a5953ab5a36db86404f4aa1157d_2764178_280x280_fill_q75_box_smart1.jpg" alt="Parallel Loop Execution"/>
</div>
</div>
<div class="paragraph">
<p>例如, 让我们考虑这样的情况: 我们有一个 JSON 日志, 并且想要一个命令来读取每一行, 解析该日志的 JSON, 并对其进行汇总以显示时间戳和消息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use JSON::Fast;
my $log-file = &#39;myapp.log&#39;.IO;
for $log-file.lines -&gt; $line {
  my %data = from-json($line);
  say &#34;%data&lt;timestamp&gt; %data&lt;message&gt;&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你的系统上有多个核心(都 2019 年了谁还没有多核呢？), 其实你可以通过一些小小的更改来加快这个速度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use JSON::Fast;
my $log-file = &#39;myapp.log&#39;.IO;
race for $log-file.lines -&gt; $line {
  my %data = from-json($line);
  say &#34;%data&lt;timestamp&gt; %data&lt;message&gt;&#34;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/statement-prefixes#index-entry-race_%28statement_prefix%29-race">race</a> 前缀添加到任何循环中都会导致项在可用核心上尽可能快地被迭代。在我的机器上, 对于一个只有这两个字段的 10000 行的短日志, 其结果是节省了大约 25% 的时间。然而, 这也带来了一个后果：原来的行的顺序不再保留。在某些情况下, 这可能并不重要, 但在另一些情况下却很重要。</p>
</div>
<div class="paragraph">
<p>现在, 我们可以使用另一个保留顺序的前缀, 叫做 <code>hyper</code>。然而, 在这种特殊情况下, 它是行不通的。为什么呢？因为 <code>hyper</code> 只能保证结果按顺序输出, 但这里我们是在代码运行时输出结果。这是每当使用这些关键字时要非常小心的地方。</p>
</div>
<div class="paragraph">
<p>但是, 这很容易解决。你只需要消除副作用, 让你的 <code>for</code> 循环发挥作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use JSON::Fast;
my $log-file = &#39;myapp.log&#39;.IO;
my $output-lines = hyper for $log-file.lines -&gt; $line {
  my %data = from-json($line);
  &#34;%data&lt;timestamp&gt; %data&lt;message&gt;&#34;;
}
.say for @$output-lines;</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 我们从并行解析 JSON 行中获得了大部分的加速, 但是我们可以按照与原始文件相同的顺序输出。这样做的原因是, 带有 <code>hyper</code> 或 <code>race</code> 前缀的 <code>for</code> 循环的输出就像 <code>do</code> 一样：结果是一个我们可以迭代的序列。在这种情况下, 它是一个 <code>HyperSeq</code>, 它确保 Raku 正确处理多线程部分。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/21/parallel-loop-execution/" class="bare">https://zostay.com/posts/2019/12/21/parallel-loop-execution/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_asynchronous_socket">100. Asynchronous Socket</h2>
<div class="sectionbody">
<div class="paragraph">
<p>有什么比套接字通信更异步的？当两个程序需要相互交谈时, 往往是来自世界不同地区不同网络上的不同计算机, 你可以使用套接字进行连接。无论是 HTTP 服务器还是某些自定义协议, 你都可以使用 <a href="https://docs.raku.org/type/IO::Socket::Async">IO::Socket::Async</a> 来实现该通信的两边。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/22/asynchronous-socket/cover-elena-mozhvilo-FBaJVyV_NvU-unsplash_hu955699248d7ee02d3ae96cb021aa0bcc_5441407_280x280_fill_q75_box_smart1.jpg" alt="Asynchronous Socket"/>
</div>
</div>
<div class="paragraph">
<p>让我们考虑一个简单的计算器服务。它侦听 TCP 连接。当连接建立后, 它通过连接接收一行行的输入, 并将每一行解析为一个简单的数学计算, 比如 <code>2+2</code> 或 <code>6*7</code>。</p>
</div>
<div class="paragraph">
<p>我们可以把服务器写成这样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
  whenever IO::Socket::Async.listen(&#39;127.0.0.1&#39;, 3456) -&gt; $conn {
    whenever $conn.Supply.lines -&gt; $line {
      if $line ~~ m:s/$&lt;a&gt; = [ \d+ ] $&lt;op&gt; = [ &#39;+&#39; | &#39;-&#39; | &#39;*&#39; | &#39;/&#39; ] $&lt;b&gt; = [ \d+ ]/ {
        my $a = +$&lt;a&gt;;
        my $b = +$&lt;b&gt;;

        my $r = do given &#34;$&lt;op&gt;&#34;.trim {
          when &#39;+&#39; { $a + $b }
          when &#39;-&#39; { $a + $b }
          when &#39;*&#39; { $a + $b }
          when &#39;/&#39; { $a + $b }
          default { &#34;Unknown Error&#34;; }
        }

        $conn.print(&#34;$r\n&#34;);
      }
      else {
        $conn.print(&#34;Syntax Error\n&#34;);
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 嵌套的 <code>whenever</code> 块可能看起来有些奇怪, 但这很好。你可以随时通过这种方式在 <code>react</code> 内添加更多 <code>whenever</code> 块。</p>
</div>
<div class="paragraph">
<p>外层的 <code>whenever</code> 侦听新的连接对象。它在这里唯一的工作就是将连接注册为服务器的另一个 <code>whenever</code> 块。要知道, 使用这种策略确实意味着你要异步处理所有的连接, 就像从一个线程来的一样。一个更具可扩展性的解决方案可能是为每个到达的连接使用一个 <code>start</code> 块(看起来像这样):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">start react whenever $conn.Supply.lines -&gt; $line { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>继续前进, 内部的 <code>whenever</code> 会在每个连接到达时监视它的输入行。每当客户端发送了一行输入, 它就会接收到一条消息。这段代码会解析这一行, 执行表达式(或发现错误), 并返回结果。</p>
</div>
<div class="paragraph">
<p>很简单。</p>
</div>
<div class="paragraph">
<p>我们调用 <code>listen</code> 在指定的地址和端口号上建立一个侦听的 TCP 套接字。这将返回一个 <a href="https://docs.raku.org/type/Supply">Supply</a>, 它将发出已连接的 IO::Socket::Async 对象。每当从关联的客户端发送时, 就可以使用连接对象上的 <code>Supply</code> 方法来获取文本（或通过 <code>:bin</code> 选项获取字节）。你可以使用 <code>write</code> 和 <code>print</code> 方法来发送字节和文本。</p>
</div>
<div class="paragraph">
<p>客户端也可以使用 <code>IO::Socket::Async</code> 来编写。下面是一个使用我们的表达式服务器来计算斐波那契序列的客户端:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my ($a, $b) = (0, 1);
say &#34;$a&#34;;
say &#34;$b&#34;;
await IO::Socket::Async.connect(&#39;127.0.0.1&#39;, 3456).then: -&gt; $connection {
  given $connection.result -&gt; $conn {
    $conn.print(&#34;$a + $b\n&#34;);

    react {
      whenever $conn.Supply.lines -&gt; $line {
        $a = $b;
        $b = +$line;
        say &#34;$b&#34;;
        $conn.print(&#34;$a + $b\n&#34;);
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>连接客户端时, 我们使用带有 IP 地址或服务器主机名的 <code>connect</code> 方法进行连接。该方法返回一个 <a href="https://docs.raku.org/type/Promise">Promise</a>, 一旦建立连接, 该 Promise 就会被保留。这个 Promise 的结果是一个连接的 <code>IO::Socket::Async</code> 对象, 它的使用方法和服务器完全一样, 其中 <code>Supply</code> 返回文本或字节, 而 <code>write</code> 和 <code>print</code> 用于发送文本或字节。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/archive/2019/12/22/asynchronous-socket.html" class="bare">https://zostay.com/archive/2019/12/22/asynchronous-socket.html</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_异步锁">101. 异步锁</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 实际上提供了两个不同的锁定类。<a href="https://docs.raku.org/type/Lock">Lock</a> 对象提供了一个非常标准的锁机制。当使用了 <code>.lock</code> 和 <code>.unlock</code> 或者调用了 <code>.protect</code> 时, 你会得到一段代码, 这段代码暂停直到锁释放, 在保持锁的同时运行, 然后释放锁, 这样其他可能在锁上等待的代码就可以运行。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/23/asynchronous-locking/cover-rich-smith-Y8gO2d7ByjY-unsplash_hu21d7ace117197dacae725fe40d0f6a55_1897495_280x280_fill_q75_box_smart1.jpg" alt="Asynchronous Locking"/>
</div>
</div>
<div class="paragraph">
<p>然而, <code>Lock</code> 类的工作方式会阻塞当前线程。正如我在前面的降临日历中所指出的那样, 线程的目的是做事情, 所以阻止线程运行就是阻止线程实现自己的目的。幸运的是, 有一个解决方案。</p>
</div>
<div class="paragraph">
<p>如果你想要锁定, 但又不想在等待锁释放的时候烧掉线程, 可以考虑使用 <a href="https://docs.raku.org/type/Lock::Async">Lock::Async</a> 代替 <code>Lock</code>。它的工作原理与 <code>Lock</code> 非常相似, 但 <code>.lock</code> 方法不会阻塞。相反, 它返回一个 Promise, 当锁被释放时, 这个 <a href="https://docs.raku.org/type/Promise">Promise</a> 将被保留。等待该 Promise 的代码将以一种允许 Raku 为另一个任务重用当前线程的方式暂停。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class SafeQueue {
    has @!queue;
    has Lock::Async $!lock .= new;

    method enqueue($value) {
        await $!lock.lock;
        push @!queue, $value;
        $!lock.unlock;
    }

    method dequeue(--&gt; Any) {
        $!lock.protect: { shift @!queue }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码演示了 <code>.lock</code> 和 <code>.unlock</code> 以及 <code>.protect</code> 的使用。你应该总是优先选择 <code>.protect</code>, 因为如果在获取锁后发生异常, 上面 <code>enqueue</code> 中的代码可能会让锁永远保持。从你的程序的角度来看, <code>.protect</code> 的行为介于 <code>Lock</code> 和 <code>Lock::Async</code> 之间, 但在内部会对 <code>.lock</code> 方法执行一个 <code>await</code>。这意味着代码所运行的线程将被释放出来, 以便被另一个正在等待调度的任务使用。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/23/asynchronous-locking/" class="bare">https://zostay.com/posts/2019/12/23/asynchronous-locking/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_异步进程间通信">102. 异步进程间通信</h2>
<div class="sectionbody">
<div class="paragraph">
<p>标题里有很多大词。简单来说, 就是在后台运行一个程序, 并在输入和输出可用时与之交互。Raku 中用于完成这项工作的工具叫做 <a href="https://docs.raku.org/type/Proc::Async">Proc::Async</a>。如果你曾经处理过试图与外部进程安全通信、写入输入和从输出和错误流中读取的痛苦, 并对此感到厌恶, 我想你会喜欢 Raku 内置的工具。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://zostay.com/posts/2019/12/24/asynchronous-inter-process-communication/cover-pavan-trikutam-71CjSSB83Wo-unsplash_hu84979ebdeaf52e08bd584cf870e0475b_4309353_280x280_fill_q75_box_smart1.jpg" alt="Asynchronous Inter-Process Communication"/>
</div>
</div>
<div class="paragraph">
<p>首先, 让我们来构思一个问题。让我们做一个外部程序, 它把字符串作为输入, 并将其反转, 并在标准输出上输出。同时, 它在标准错误上报告给定的字符串是否为回文。我们可以这样写这个程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $*IN.lines -&gt; $line {
    my $rline = $line.flip;
    say $rline;
    note ($rline eq $line);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了让大家明白, 对于这个样本输入。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">spam
slap
tacocat</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将得到这样的输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">maps
False
pals
False
tacocat
True</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>True</code> 和 <code>False</code> 这两行是标准错误, 其他行为标准输出。清楚了吗？很好。</p>
</div>
<div class="paragraph">
<p>接下来, 为了完成我们的构思问题, 我们需要与这个程序进行交互, 只需写出一条消息, 比如 <code>tacocat is a palindrome!</code>。因为每当我们看到一个回文的时候就会很兴奋。否则我们什么都不想输出。让我们使用 <code>Proc:::Async</code> 来与我们的另一个程序进行交互, 我们称之为 <code>palindromer</code>, 以示欢喜。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    my $palindromes = Supplier.new;
    my $p = Proc::Async.new: &#39;./palindromer&#39;, :w;
    my @rlines;
    my @palindrome-checks;

    # Echo our own input
    whenever $*IN.Supply.lines -&gt; $line {
        $p.say: $line;

        # Let palindromer know when we run out of input
        LAST { $p.close-stdin }
    }

    # Watch for the reverse lines on palindromer&#39;s standard output
    whenever $p.stdout.lines -&gt; $rline {
        if @palindrome-checks.shift -&gt; $is-palindrome {
            $palindromes.emit: $rline;
        }
        else {
            push @rlines, $rline
        }
    }

    # Watch for the True/False output from palindromer&#39;s standard error
    whenever $p.stderr.lines -&gt; $is-palindrome {
        if @rlines.shift -&gt; $rline {
            $palindromes.emit: $rline if $is-palindrome eq &#39;True&#39;;
        }
        else {
            push @palindrome-checks, $is-palindrome;
        }
    }

    # PALINDROMES ARE EXCITING!
    whenever $palindromes.Supply -&gt; $palindrome {
        say &#34;$palindrome is a palindrome!&#34;;
    }

    # Quit when palindromer quits
    whenever $p.start { done }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在, 如果我们把和之前一样的输入管道到我们的新程序中, 我们应该得到这样的输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">tacocat is a palindrome!</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的代码处理了标准输出和标准错误不同步的潜在问题, 通过使用队列来积累两边的额外值。我们将发现的 palindromes 送入到一个名为 <code>$palindromes</code> 的中央<a href="https://docs.raku.org/type/Supplier">供应</a>中, 这样我们就可以有一个地方来打印我们发现的 palindromes。</p>
</div>
<div class="paragraph">
<p>在使用 <code>Proc:::Async</code> 时要注意的几个关键点。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>始终要把 <a href="https://docs.raku.org/type/Proc::Async#method_start">.start</a> 调用放在标准输出和标准错误的 tap 之后。否则, 可能会出现漏行的问题(即在你侦听之前发出的行)。顺便说一下, 如果 Raku 检测到你这样做了, 它就会警告你。这个方法会返回一个 <a href="https://docs.raku.org/type/Promise">Promise</a>, 当程序结束时, 这个 Promise 会被保留。</p>
</li>
<li>
<p>确保你在完成输入时使用 <a href="https://docs.raku.org/type/Proc::Async#method_close-stdin">.close-stdin</a> 来确保其他程序知道你已经完成了。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>否则, 还有一些更有趣的功能, 比如 <a href="https://docs.raku.org/type/Proc::Async#method_ready">.ready</a> 等, 你可能想在网上<a href="https://docs.rakue.org/type/Proc::Async">阅读更多</a>关于 Raku 参考文档的内容。</p>
</div>
<div class="paragraph">
<p>干杯。</p>
</div>
<div class="paragraph">
<p>原文链接: <a href="https://zostay.com/posts/2019/12/24/asynchronous-inter-process-communication/" class="bare">https://zostay.com/posts/2019/12/24/asynchronous-inter-process-communication/</a></p>
</div>
</div>
</div>
<div id="footnotes">
<hr/>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. 这是我很遗憾的说, 我从经验中学到的东西。
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. 不幸的是, 对于这个双关语来说, <a href="https://docs.raku.org/type/Promise">Promise</a> 对象已经有了表示它们可以被 <a href="https://docs.raku.org/type/Promise#method_keep">kept</a> 或 <a href="https://docs.raku.org/type/Promise#method_break">break</a> 的方法, 所以在这种情况下, 也许一个更准确的名字应该是 &#34;Timer::Cancellable&#34; 这样的东西。但是我们不希望准确性影响到双关语, 不是吗？
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. 我们甚至可以通过使用 <a href="https://docs.raku.org/type/Promise#method_vow"><code>vow</code></a> 来限制代码的哪些部分被允许遵守或违背 <a href="https://docs.raku.org/type/Promise">Promise</a>。
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. 我将在后面介绍调度器的细节。当我这样做的时候, 你会看到 Raku 使用的确切机制来决定一个任务是否被安排在一个单独的线程中立即运行, 在未来的某个时间在一个单独的线程上运行, 在当前线程停止忙碌时在当前线程上运行等等。不过, 我一般会假设 <code>start</code> 会把任务安排在下一个可用的线程上, 因为在 Raku 中一般都是安全的。
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. 请注意, 这是 MoarVM 下 Rakudo 中运行的默认调度程序的过程。实际发生的事情可能会根据 <a href="https://docs.raku.org/language/variables#index-entry-$*SCHEDULER">$*SCHEDULER</a> 变量中的当前值而有些不同。我将在以后的文章中进一步讨论这个问题
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. 关于以下整数序列的背景，见 <a href="https://oeis.org/A005185">https://oeis.org/A005185</a>
</div>
<div class="footnote" id="_footnotedef_7">
<a href="#_footnoteref_7">7</a>. 这是所有 <code>Supply</code> 对象的特性，而不仅仅是 <code>supply</code> 块或按需供应生成的对象。︎
</div>
<div class="footnote" id="_footnotedef_8">
<a href="#_footnoteref_8">8</a>. 需要说明的是, <code>Thread</code> 对象不一定代表一个特定的操作系统线程, 但它应该能让你尽可能地接近实现。
</div>
<div class="footnote" id="_footnotedef_9">
<a href="#_footnoteref_9">9</a>. 我并不是说这是一种高效的模拟康威的《生命游戏》的方法, 但我只是在演示如何利用一个版本的模拟器, 并利用并发模式使其更高效。
</div>
<div class="footnote" id="_footnotedef_10">
<a href="#_footnoteref_10">10</a>. 这是严重的低效率, 因为大段的棋盘很可能是空白的。正如我已经提到的那样, 我在这里的目的不是为了实现一个高效的棋手, 而是展示我们如何利用并发来提高效率。
</div>
<div class="footnote" id="_footnotedef_11">
<a href="#_footnoteref_11">11</a>. Raku 已经为这个操作做了一些优化。例如,它不会为 <code>.grep</code> 和 <code>.map</code> 执行单独的循环。这些操作将以序列的方式链在一起,所以基本上只执行一次迭代。
</div>
</div>

</article>


    

  </main><section class="site__search">
    <label class="site__form">
        <p class="form__label">Search around the site</p> 
        <input class="site__search-bar form__input" type="text">
    </label>
    <div class="site__search-bar-results"></div>
</section>
  
  <footer class="site__footer">
    
    
    <p class="footer__sign">© 2020 ohmyraku</p></footer>





<script defer type="text/javascript" src="https://ohmyraku.github.io/js/script.14164ab553b19613ce98aadb54b1ed9a89ae5b056c72b99a4c672e37954f33d67bebe1452b0279025ba889964b51bdf8ec69683933cf427ae67c08ac2cdda7b1.js" integrity="sha512-FBZKtVOxlhPOmKrbVLHtmomuWwVscrmaTGcuN5VPM9Z76&#43;FFKwJ5AluoiZZLUb347GloOTPPQnrmfAisLN2nsQ=="></script>



</body>
</html>