<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Raku 官方文档 :: 山川异域, 风月同天</title>

<meta name="author" content="ohmyraku">
<meta name="application-name" content="山川异域, 风月同天">
<meta name="description" content="Table of Contents 1. 简介 2. 通过例子学习 Raku 2.1. v6 2.2. 语句 2.3. 词法和块 2.4. 符号和标识符 2.5. 标量 2.6. 文件句柄和赋值 2.7. 字符串字面量 2.8. 数组、方法和调用 2.9. 散列 2.10. for 和 block 2.11. Any 和 &#43;= 2.12. 后自增和前自增 2.13. 变量, $_ 2.14. 块 2.15. 稳定的排序 2.16. say，print 和 put 2.17. 插值 2.18. 双引号字符串和单引号字符串 2.19. 禅切 2.20. 练习   3. Perl 5 到 Raku 的指南 - 简而言之 3.1. CPAN 3.2. 语法 3.3. 空白 3.">
<meta name="robots" content="noodp"/>
<meta name="generator" content="Hugo 0.63.2" />
<meta name="referrer" content="no-referrer" />
<meta name="format-detection" content="telephone=no">

<link rel="canonical" href="https://ohmyraku.github.io/rakudoc/" />


<link rel="icon" href="https://ohmyraku.github.io/logo.png" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Raku 官方文档" />
<meta name="twitter:description" content="Table of Contents 1. 简介 2. 通过例子学习 Raku 2.1. v6 2.2. 语句 2.3. 词法和块 2.4. 符号和标识符 2.5. 标量 2.6. 文件句柄和赋值 2.7. 字符串字面量 2.8. 数组、方法和调用 2.9. 散列 2.10. for 和 block 2.11. Any 和 &#43;= 2.12. 后自增和前自增 2.13. 变量, $_ 2.14. 块 2.15. 稳定的排序 2.16. say，print 和 put 2.17. 插值 2.18. 双引号字符串和单引号字符串 2.19. 禅切 2.20. 练习   3. Perl 5 到 Raku 的指南 - 简而言之 3.1. CPAN 3.2. 语法 3.3. 空白 3." />
<meta name="twitter:site" content="https://ohmyraku.github.io" />
<meta name="twitter:creator" content="ohmyraku" />
<meta name="twitter:image" content="https://ohmyraku.github.io/logo.png">
<meta property="og:type" content="article" />
<meta property="og:locale" content="en" />
<meta property="og:name" content="ohmyraku" />
<meta property="og:title" content="Raku 官方文档" />
<meta property="og:url" content="https://ohmyraku.github.io" />
<meta property="og:site_name" content="山川异域, 风月同天" />
<meta property="og:description" content="Table of Contents 1. 简介 2. 通过例子学习 Raku 2.1. v6 2.2. 语句 2.3. 词法和块 2.4. 符号和标识符 2.5. 标量 2.6. 文件句柄和赋值 2.7. 字符串字面量 2.8. 数组、方法和调用 2.9. 散列 2.10. for 和 block 2.11. Any 和 &#43;= 2.12. 后自增和前自增 2.13. 变量, $_ 2.14. 块 2.15. 稳定的排序 2.16. say，print 和 put 2.17. 插值 2.18. 双引号字符串和单引号字符串 2.19. 禅切 2.20. 练习   3. Perl 5 到 Raku 的指南 - 简而言之 3.1. CPAN 3.2. 语法 3.3. 空白 3." />
<script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "Article",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https:\/\/ohmyraku.github.io\/rakudoc\/"
      },
      "headline": "Raku 官方文档",
      
      "datePublished": "2020-02-05",
      "dateModified": "2020-02-05 15:26:52 \x2b0800 CST",
      "author": {
        "@type": "Person",
        "name": "ohmyraku"
      },
      "description": "Table of Contents 1. 简介 2. 通过例子学习 Raku 2.1. v6 2.2. 语句 2.3. 词法和块 2.4. 符号和标识符 2.5. 标量 2.6. 文件句柄和赋值 2.7. 字符串字面量 2.8. 数组、方法和调用 2.9. 散列 2.10. for 和 block 2.11. Any 和 \x2b= 2.12. 后自增和前自增 2.13. 变量, $_ 2.14. 块 2.15. 稳定的排序 2.16. say，print 和 put 2.17. 插值 2.18. 双引号字符串和单引号字符串 2.19. 禅切 2.20. 练习   3. Perl 5 到 Raku 的指南 - 简而言之 3.1. CPAN 3.2. 语法 3.3. 空白 3.",
      "publisher": {
        "@type": "Organization",
        "name": "https:\/\/ohmyraku.github.io",
        "logo": {
          "@type": "ImageObject",
          "url": "https:\/\/ohmyraku.github.io\/logo.png"
        }
      }
    }
</script><link rel="stylesheet" href="https://ohmyraku.github.io/scss/main.min.84f71d25d375c522a861bb4719728ce6839cf3635b15ca0c7a1b4d799c2dc3399a1d6cb46058a9d8fdbebe9156a8857279cfdeb70aa3862e629de234b5a41fa1.css" integrity="sha512-hPcdJdN1xSKoYbtHGXKM5oOc82NbFcoMehtNeZwtwzmaHWy0YFip2P2&#43;vpFWqIVyec/etwqjhi5ineI0taQfoQ==">
<script>

const theme = window.localStorage.getItem('theme'); 
if (theme && theme !== "1") {
    document.documentElement.classList.add('theme-' + theme);
}
</script>


</head>
<body>
  <main class="site__content">
    <div class="site__page">
  <nav class="site__breadcrumbs">
    <a class="site__breadcrumb" href="https://ohmyraku.github.io/">山川异域, 风月同天</a><a class="site__breadcrumb--active" href="https://ohmyraku.github.io/rakudoc/">Raku 官方文档</a>
</nav>

<h1 class="page__title">Raku 官方文档</h1>
  <div class="page__meta">
    <p>
    
    <span class="page__date">
    on <time datetime="2020-02-05T15:26:52&#43;08:00">2020-02-05</time>
    
    </span>
    </p>

    

    
    </div>
</div>


</div>

<article class="page__content" ><div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_简介">1. 简介</a></li>
<li><a href="#_通过例子学习_raku">2. 通过例子学习 Raku</a>
<ul class="sectlevel2">
<li><a href="#_v6">2.1. v6</a></li>
<li><a href="#_语句">2.2. 语句</a></li>
<li><a href="#_词法和块">2.3. 词法和块</a></li>
<li><a href="#_符号和标识符">2.4. 符号和标识符</a></li>
<li><a href="#_标量">2.5. 标量</a></li>
<li><a href="#_文件句柄和赋值">2.6. 文件句柄和赋值</a></li>
<li><a href="#_字符串字面量">2.7. 字符串字面量</a></li>
<li><a href="#_数组方法和调用">2.8. 数组、方法和调用</a></li>
<li><a href="#_散列">2.9. 散列</a></li>
<li><a href="#_for_和_block">2.10. for 和 block</a></li>
<li><a href="#_any_和">2.11. Any 和 +=</a></li>
<li><a href="#_后自增和前自增">2.12. 后自增和前自增</a></li>
<li><a href="#_变量">2.13. 变量, $_</a></li>
<li><a href="#_块">2.14. 块</a></li>
<li><a href="#_稳定的排序">2.15. 稳定的排序</a></li>
<li><a href="#_sayprint_和_put">2.16. say，print 和 put</a></li>
<li><a href="#_插值">2.17. 插值</a></li>
<li><a href="#_双引号字符串和单引号字符串">2.18. 双引号字符串和单引号字符串</a></li>
<li><a href="#_禅切">2.19. 禅切</a></li>
<li><a href="#_练习">2.20. 练习</a></li>
</ul>
</li>
<li><a href="#_perl_5_到_raku_的指南_简而言之">3. Perl 5 到 Raku 的指南 - 简而言之</a>
<ul class="sectlevel2">
<li><a href="#_cpan">3.1. CPAN</a></li>
<li><a href="#_语法">3.2. 语法</a></li>
<li><a href="#_空白">3.3. 空白</a></li>
<li><a href="#_符号">3.4. 符号</a></li>
<li><a href="#_数组索引切片">3.5. 数组索引/切片</a></li>
<li><a href="#_散列索引切片">3.6. {} 散列索引/切片</a></li>
<li><a href="#_创建引用并使用它们">3.7. 创建引用并使用它们</a></li>
<li><a href="#_运算符">3.8. 运算符</a></li>
<li><a href="#_逗号_列表分割符">3.9. , (逗号) 列表分割符</a></li>
<li><a href="#_循环">3.10. 循环</a></li>
<li><a href="#_函数">3.11. 函数</a></li>
<li><a href="#_正则表达式_regexregexp">3.12. 正则表达式 (regex/regexp)</a></li>
<li><a href="#_begin_unitcheck_check_init_和_end">3.13. BEGIN, UNITCHECK, CHECK, INIT 和 END</a></li>
<li><a href="#_编译指令">3.14. 编译指令</a></li>
<li><a href="#_命令行标记">3.15. 命令行标记</a></li>
<li><a href="#_文件相关的运算符">3.16. 文件相关的运算符</a></li>
<li><a href="#_环境变量">3.17. 环境变量</a></li>
<li><a href="#_misc">3.18. Misc</a></li>
<li><a href="#_autoload">3.19. AUTOLOAD</a></li>
<li><a href="#_核心模块">3.20. 核心模块</a></li>
<li><a href="#_自动翻译">3.21. 自动翻译</a></li>
</ul>
</li>
<li><a href="#_perl_5_到_raku_的指南_概览">4. Perl 5 到 Raku 的指南 - 概览</a>
<ul class="sectlevel2">
<li><a href="#_果壳中的_raku">4.1. 果壳中的 Raku</a></li>
<li><a href="#_句法差异">4.2. 句法差异</a></li>
<li><a href="#_raku_中的运算符">4.3. Raku 中的运算符</a></li>
<li><a href="#_raku_中的函数">4.4. Raku 中的函数</a></li>
<li><a href="#_raku_中的特殊变量">4.5. Raku 中的特殊变量</a></li>
</ul>
</li>
<li><a href="#_perl_5_到_raku_的指南_函数">5. Perl 5 到 Raku 的指南 - 函数</a></li>
<li><a href="#_perl_5_到_raku_的指南_运算符">6. Perl 5 到 Raku 的指南 - 运算符</a>
<ul class="sectlevel2">
<li><a href="#_描述">6.1. 描述</a></li>
<li><a href="#_注意">6.2. 注意</a></li>
</ul>
</li>
<li><a href="#_raku_语法">7. Raku 语法</a>
<ul class="sectlevel2">
<li><a href="#_描述_2">7.1. 描述</a></li>
<li><a href="#_注意_2">7.2. 注意</a></li>
<li><a href="#_自由形式">7.3. 自由形式</a></li>
</ul>
</li>
<li><a href="#_特殊变量">8. 特殊变量</a>
<ul class="sectlevel2">
<li><a href="#_描述_3">8.1. 描述</a></li>
<li><a href="#_注意_3">8.2. 注意</a></li>
<li><a href="#_特殊变量_2">8.3. 特殊变量</a></li>
</ul>
</li>
<li><a href="#_haskell_到_raku_简而言之">9. Haskell 到 Raku - 简而言之</a>
<ul class="sectlevel2">
<li><a href="#_类型">9.1. 类型</a></li>
</ul>
</li>
<li><a href="#_javascript_到_raku_简而言之">10. Javascript 到 Raku - 简而言之</a>
<ul class="sectlevel2">
<li><a href="#_基础语法">10.1. 基础语法</a></li>
<li><a href="#_面向对象编程">10.2. 面向对象编程</a></li>
<li><a href="#_异步编程">10.3. 异步编程</a></li>
<li><a href="#_网络_api">10.4. 网络 API</a></li>
<li><a href="#_文件系统_api">10.5. 文件系统 API</a></li>
<li><a href="#_模块和包">10.6. 模块和包</a></li>
</ul>
</li>
<li><a href="#_python_到_raku_简而言之">11. Python 到 Raku - 简而言之</a>
<ul class="sectlevel2">
<li><a href="#_基本语法">11.1. 基本语法</a></li>
</ul>
</li>
<li><a href="#_ruby_到_raku">12. Ruby 到 Raku</a>
<ul class="sectlevel2">
<li><a href="#_基本语法_2">12.1. 基本语法</a></li>
<li><a href="#_操作符">12.2. 操作符</a></li>
<li><a href="#_复合语句_3">12.3. 复合语句</a></li>
<li><a href="#_正则表达式regex_regexp">12.4. 正则表达式（Regex / Regexp）</a></li>
<li><a href="#_文件相关操作">12.5. 文件相关操作</a></li>
<li><a href="#_面向对象">12.6. 面向对象</a></li>
<li><a href="#_环境变量_2">12.7. 环境变量</a></li>
<li><a href="#_misc_2">12.8. Misc.</a></li>
<li><a href="#_optionparser解析命令行标志">12.9. OptionParser，解析命令行标志</a></li>
<li><a href="#_rubygems外部库">12.10. RubyGems，外部库</a></li>
</ul>
</li>
<li><a href="#_类和对象_2">13. 类和对象</a>
<ul class="sectlevel2">
<li><a href="#_从类开始">13.1. 从类开始</a></li>
<li><a href="#_状态">13.2. 状态</a></li>
<li><a href="#_静态字段">13.3. 静态字段?</a></li>
<li><a href="#_方法">13.4. 方法</a></li>
<li><a href="#_私有方法_2">13.5. 私有方法</a></li>
<li><a href="#_构造函数">13.6. 构造函数</a></li>
<li><a href="#_消费我们的类">13.7. 消费我们的类</a></li>
<li><a href="#_继承">13.8. 继承</a></li>
<li><a href="#_多重继承">13.9. 多重继承</a></li>
<li><a href="#_also_声明符">13.10. also 声明符</a></li>
<li><a href="#_自省">13.11. 自省</a></li>
<li><a href="#_重写默认的_gist_方法">13.12. 重写默认的 gist 方法</a></li>
</ul>
</li>
<li><a href="#_命令行接口_概述">14. 命令行接口 - 概述</a>
<ul class="sectlevel2">
<li><a href="#_将命令行参数解析为捕获">14.1. 将命令行参数解析为捕获</a></li>
<li><a href="#_使用该捕获调用提供的main子例程">14.2. 使用该捕获调用提供的MAIN子例程</a></li>
<li><a href="#_如果调用_main_失败则创建显示使用信息">14.3. 如果调用 MAIN 失败，则创建/显示使用信息</a></li>
<li><a href="#_sub_main">14.4. sub MAIN</a></li>
<li><a href="#_sub_main_opts">14.5. %*SUB-MAIN-OPTS</a></li>
<li><a href="#_named_anywhere">14.6. named-anywhere</a></li>
<li><a href="#_is_hidden_from_usage">14.7. is hidden-from-USAGE</a></li>
<li><a href="#_main_的单位作用域定义">14.8. MAIN 的单位作用域定义</a></li>
<li><a href="#_sub_usage">14.9. sub USAGE</a></li>
<li><a href="#_拦截_cli_参数解析2018_10_v6_d_and_later">14.10. 拦截 CLI 参数解析(2018.10, v6.d and later)</a></li>
<li><a href="#_sub_args_to_capture">14.11. sub ARGS-TO-CAPTURE</a></li>
<li><a href="#_拦截使用消息生成2018_10v6_d及更高版本">14.12. 拦截使用消息生成（2018.10，v6.d及更高版本）</a></li>
<li><a href="#_sub_generate_usage">14.13. sub GENERATE-USAGE</a></li>
<li><a href="#_拦截_main_调用2018_10之前v6_e">14.14. 拦截 MAIN 调用（2018.10之前，v6.e）</a></li>
</ul>
</li>
<li><a href="#_并发">15. 并发</a>
<ul class="sectlevel2">
<li><a href="#_high_level_apis">15.1. High-level APIs</a></li>
<li><a href="#_low_level_apis">15.2. Low-level APIs</a></li>
<li><a href="#_safety_concerns">15.3. Safety Concerns</a></li>
</ul>
</li>
<li><a href="#_核心模块_2">16. 核心模块</a>
<ul class="sectlevel2">
<li><a href="#_compunit_模块和角色">16.1. <code>CompUnit::*</code> 模块和角色</a></li>
<li><a href="#_nativecall_模块">16.2. <code>NativeCall</code> 模块</a></li>
<li><a href="#_其它模块">16.3. 其它模块</a></li>
</ul>
</li>
<li><a href="#_使用_raku_做数学计算">17. 使用 Raku 做数学计算</a>
<ul class="sectlevel2">
<li><a href="#_sets">17.1. Sets</a></li>
<li><a href="#_算术">17.2. 算术</a></li>
<li><a href="#_序列">17.3. 序列</a></li>
<li><a href="#_数学常数">17.4. 数学常数</a></li>
</ul>
</li>
<li><a href="#_输入_unicode_字符">18. 输入 Unicode 字符</a>
<ul class="sectlevel2">
<li><a href="#_xcompose_linux">18.1. XCompose (Linux)</a></li>
<li><a href="#_wincomposewindows">18.2. WinCompose(Windows)</a></li>
<li><a href="#_raku中有用的_unicode_字符">18.3. Raku中有用的 Unicode 字符</a></li>
</ul>
</li>
<li><a href="#_grammar_指南">19. Grammar 指南</a>
<ul class="sectlevel2">
<li><a href="#_开始之前">19.1. 开始之前</a></li>
<li><a href="#_更多_grammar_技术">19.2. 更多 Grammar 技术</a></li>
<li><a href="#_通过一个例子学习_grammar_rest_设计">19.3. 通过一个例子学习 Grammar - REST 设计</a></li>
<li><a href="#_grammar_actions">19.4. Grammar Actions</a></li>
</ul>
</li>
<li><a href="#_输入和输出">20. 输入和输出</a>
<ul class="sectlevel2">
<li><a href="#_读取文件">20.1. 读取文件</a></li>
<li><a href="#_写文件">20.2. 写文件</a></li>
<li><a href="#_复制和重命名文件">20.3. 复制和重命名文件</a></li>
<li><a href="#_检查文件和目录">20.4. 检查文件和目录</a></li>
<li><a href="#_获取目录列表">20.5. 获取目录列表</a></li>
<li><a href="#_创建和移除目录">20.6. 创建和移除目录</a></li>
</ul>
</li>
<li><a href="#_进程间通信">21. 进程间通信</a>
<ul class="sectlevel2">
<li><a href="#_运行程序">21.1. 运行程序</a></li>
<li><a href="#_proc_对象">21.2. Proc 对象</a></li>
<li><a href="#_procasync_对象">21.3. Proc::Async 对象</a></li>
</ul>
</li>
<li><a href="#_迭代">22. 迭代</a>
<ul class="sectlevel2">
<li><a href="#_iterator_和_iterable_角色">22.1. Iterator 和 Iterable 角色</a></li>
<li><a href="#_如何迭代上下文化和主题变量">22.2. 如何迭代：上下文化和主题变量</a></li>
<li><a href="#_经典循环以及为什么我们不喜欢它们">22.3. 经典循环以及为什么我们不喜欢它们</a></li>
</ul>
</li>
<li><a href="#_模块开发工具">23. 模块开发工具</a>
<ul class="sectlevel2">
<li><a href="#_模块构建器和创作工具">23.1. 模块构建器和创作工具</a></li>
<li><a href="#_测试">23.2. 测试</a></li>
<li><a href="#_nativecall">23.3. NativeCall</a></li>
<li><a href="#_sample_modules">23.4. Sample modules</a></li>
</ul>
</li>
<li><a href="#_模块包">24. 模块包</a>
<ul class="sectlevel2">
<li><a href="#_什么是模块">24.1. 什么是模块?</a></li>
<li><a href="#_磁盘上的模块">24.2. 磁盘上的模块</a></li>
</ul>
</li>
<li><a href="#_模块">25. 模块</a>
<ul class="sectlevel2">
<li><a href="#_导出和选择性导出">25.1. 导出和选择性导出</a></li>
<li><a href="#_发布模块">25.2. 发布模块</a></li>
</ul>
</li>
<li><a href="#_创建操作符">26. 创建操作符</a></li>
<li><a href="#_正则表达式最佳实践和陷阱">27. 正则表达式最佳实践和陷阱</a>
<ul class="sectlevel2">
<li><a href="#_代码布局">27.1. 代码布局</a></li>
<li><a href="#_保持短小">27.2. 保持短小</a></li>
<li><a href="#_要匹配什么">27.3. 要匹配什么</a></li>
<li><a href="#_匹配空白">27.4. 匹配空白</a></li>
</ul>
</li>
<li><a href="#_关于文档">28. 关于文档</a>
<ul class="sectlevel2">
<li><a href="#_结构">28.1. 结构</a></li>
<li><a href="#_从_pod_生成_html">28.2. 从 Pod 生成 HTML</a></li>
<li><a href="#_贡献">28.3. 贡献</a></li>
</ul>
</li>
<li><a href="#_社区">29. 社区</a>
<ul class="sectlevel2">
<li><a href="#_raku_社区">29.1. Raku 社区</a></li>
<li><a href="#_raku_周刊">29.2. Raku 周刊</a></li>
<li><a href="#_raku_降临节日历">29.3. Raku 降临节日历</a></li>
</ul>
</li>
<li><a href="#_faq">30. FAQ</a>
<ul class="sectlevel2">
<li><a href="#_通用">30.1. 通用</a></li>
<li><a href="#_模块_2">30.2. 模块</a></li>
<li><a href="#_语言特性">30.3. 语言特性</a></li>
<li><a href="#_raku_实现">30.4. Raku 实现</a></li>
<li><a href="#_元问题和宣传">30.5. 元问题和宣传</a></li>
</ul>
</li>
<li><a href="#_术语">31. 术语</a>
<ul class="sectlevel2">
<li><a href="#_匿名">31.1. 匿名</a></li>
<li><a href="#_副词">31.2. 副词</a></li>
<li><a href="#_autothreading">31.3. Autothreading</a></li>
<li><a href="#_colon_pair_and_colon_list">31.4. Colon Pair and Colon List</a></li>
<li><a href="#_constraint">31.5. Constraint</a></li>
<li><a href="#_instance">31.6. Instance</a></li>
<li><a href="#_invocant">31.7. Invocant</a></li>
<li><a href="#_literal">31.8. Literal</a></li>
<li><a href="#_lvalue">31.9. lvalue</a></li>
<li><a href="#_mainline">31.10. Mainline</a></li>
<li><a href="#_slurpy">31.11. Slurpy</a></li>
<li><a href="#_type_object">31.12. Type Object</a></li>
</ul>
</li>
<li><a href="#_pod_文档">32. Pod 文档</a>
<ul class="sectlevel2">
<li><a href="#_块结构">32.1. 块结构</a></li>
<li><a href="#_配置信息">32.2. 配置信息</a></li>
<li><a href="#_缩写块">32.3. 缩写块</a></li>
<li><a href="#_声明器块">32.4. 声明器块</a></li>
<li><a href="#_块类型">32.5. 块类型</a></li>
<li><a href="#_代码块">32.6. 代码块</a></li>
<li><a href="#_io_块">32.7. I/O 块</a></li>
<li><a href="#_列表">32.8. 列表</a></li>
<li><a href="#_表">32.9. 表</a></li>
<li><a href="#_pod_注释">32.10. Pod 注释</a></li>
<li><a href="#_语义块">32.11. 语义块</a></li>
<li><a href="#_格式化代码">32.12. 格式化代码</a></li>
<li><a href="#_渲染_pod">32.13. 渲染 Pod</a></li>
<li><a href="#_访问_pod">32.14. 访问 Pod</a></li>
</ul>
</li>
<li><a href="#_pod_6_表格">33. Pod 6 表格</a>
<ul class="sectlevel2">
<li><a href="#_restrictions">33.1. Restrictions</a></li>
<li><a href="#_最佳实践">33.2. 最佳实践</a></li>
<li><a href="#_good_tables">33.3. Good tables</a></li>
<li><a href="#_bad_tables">33.4. Bad tables</a></li>
<li><a href="#_ugly_tables">33.5. Ugly tables</a></li>
</ul>
</li>
<li><a href="#_项">34. 项</a>
<ul class="sectlevel2">
<li><a href="#_literals">34.1. Literals</a></li>
<li><a href="#_identifier_terms">34.2. Identifier terms</a></li>
<li><a href="#_variables">34.3. Variables</a></li>
</ul>
</li>
<li><a href="#_测试_2">35. 测试</a>
<ul class="sectlevel2">
<li><a href="#_写测试">35.1. 写测试</a></li>
<li><a href="#_运行测试">35.2. 运行测试</a></li>
<li><a href="#_测试计划">35.3. 测试计划</a></li>
<li><a href="#_测试返回值">35.4. 测试返回值</a></li>
<li><a href="#_测试模块">35.5. 测试模块</a></li>
<li><a href="#_测试异常">35.6. 测试异常</a></li>
<li><a href="#_grouping_tests">35.7. Grouping tests</a></li>
<li><a href="#_跳过测试">35.8. 跳过测试</a></li>
<li><a href="#_手动控制">35.9. 手动控制</a></li>
</ul>
</li>
<li><a href="#_要避免的陷阱">36. 要避免的陷阱</a>
<ul class="sectlevel2">
<li><a href="#_变量和常量">36.1. 变量和常量</a></li>
<li><a href="#_blocks">36.2. Blocks</a></li>
<li><a href="#_对象">36.3. 对象</a></li>
<li><a href="#_空白_3">36.4. 空白</a></li>
</ul>
</li>
<li><a href="#_容器">37. 容器</a>
<ul class="sectlevel2">
<li><a href="#_变量是什么">37.1. 变量是什么?</a></li>
<li><a href="#_标量容器">37.2. 标量容器</a></li>
<li><a href="#_callable_容器">37.3. Callable 容器</a></li>
<li><a href="#_绑定">37.4. 绑定</a></li>
<li><a href="#_scalar_容器和_listy_things">37.5. Scalar 容器和 listy things</a></li>
<li><a href="#_赋值和绑定给数组变量">37.6. 赋值和绑定给数组变量</a></li>
<li><a href="#_绑定到数组元素">37.7. 绑定到数组元素</a></li>
<li><a href="#_展平_项和容器">37.8. 展平, 项和容器</a></li>
<li><a href="#_自引用数据">37.9. 自引用数据</a></li>
<li><a href="#_类型约束">37.10. 类型约束</a></li>
<li><a href="#_自定义容器">37.11. 自定义容器</a></li>
</ul>
</li>
<li><a href="#_上下文和上下文化">38. 上下文和上下文化</a>
<ul class="sectlevel2">
<li><a href="#_sink_上下文">38.1. Sink 上下文</a></li>
<li><a href="#_number_上下文">38.2. Number 上下文</a></li>
<li><a href="#_string_上下文">38.3. String 上下文</a></li>
</ul>
</li>
<li><a href="#_控制语句">39. 控制语句</a>
<ul class="sectlevel2">
<li><a href="#_语句_2">39.1. 语句</a></li>
<li><a href="#_块儿_2">39.2. 块儿</a></li>
<li><a href="#_phasers">39.3. Phasers</a></li>
<li><a href="#_do_2">39.4. do</a></li>
<li><a href="#_start">39.5. start</a></li>
<li><a href="#_if">39.6. if</a></li>
<li><a href="#_when">39.7. when</a></li>
<li><a href="#_for">39.8. for</a></li>
<li><a href="#_gathertake">39.9. gather/take</a></li>
<li><a href="#_supplyemit">39.10. supply/emit</a></li>
<li><a href="#_given">39.11. given</a></li>
<li><a href="#_loop">39.12. loop</a></li>
<li><a href="#_while_until_3">39.13. while, until</a></li>
<li><a href="#_repeatwhile_repeatuntil">39.14. repeat/while, repeat/until</a></li>
<li><a href="#_return">39.15. return</a></li>
<li><a href="#_return_rw">39.16. return-rw</a></li>
<li><a href="#_fail">39.17. fail</a></li>
<li><a href="#_once">39.18. once</a></li>
<li><a href="#_quietly">39.19. quietly</a></li>
<li><a href="#_labels">39.20. LABELs</a></li>
<li><a href="#_next">39.21. next</a></li>
<li><a href="#_last">39.22. last</a></li>
<li><a href="#_redo">39.23. redo</a></li>
</ul>
</li>
<li><a href="#_数据结构">40. 数据结构</a>
<ul class="sectlevel2">
<li><a href="#_标量结构">40.1. 标量结构</a></li>
<li><a href="#_复杂数据结构">40.2. 复杂数据结构</a></li>
<li><a href="#_函数式结构">40.3. 函数式结构</a></li>
<li><a href="#_定义和约束数据结构">40.4. 定义和约束数据结构</a></li>
<li><a href="#_无限结构和惰性">40.5. 无限结构和惰性</a></li>
<li><a href="#_内省">40.6. 内省</a></li>
</ul>
</li>
<li><a href="#_日期和时间函数">41. 日期和时间函数</a></li>
<li><a href="#_枚举">42. 枚举</a></li>
<li><a href="#_异常">43. 异常</a>
<ul class="sectlevel2">
<li><a href="#_热异常">43.1. 热异常</a></li>
<li><a href="#_类型化的异常">43.2. 类型化的异常</a></li>
<li><a href="#_捕获异常">43.3. 捕获异常</a></li>
<li><a href="#_异常处理程序和闭合块">43.4. 异常处理程序和闭合块</a></li>
<li><a href="#_try_块">43.5. try 块</a></li>
<li><a href="#_抛出异常">43.6. 抛出异常</a></li>
<li><a href="#_异常恢复">43.7. 异常恢复</a></li>
<li><a href="#_未捕获的异常">43.8. 未捕获的异常</a></li>
<li><a href="#_控制异常">43.9. 控制异常</a></li>
</ul>
</li>
<li><a href="#_raku_中的函数_2">44. Raku 中的函数</a>
<ul class="sectlevel2">
<li><a href="#_定义创建使用_函数">44.1. 定义/创建/使用 函数</a></li>
<li><a href="#_约定和惯用法">44.2. 约定和惯用法</a></li>
<li><a href="#_函数是一等对象">44.3. 函数是一等对象</a></li>
<li><a href="#_sub_main_2">44.4. sub MAIN</a></li>
<li><a href="#_sub_usage_2">44.5. sub USAGE</a></li>
</ul>
</li>
<li><a href="#_grammars">45. Grammars</a>
<ul class="sectlevel2">
<li><a href="#_具名正则">45.1. 具名正则</a></li>
<li><a href="#_创建_grammar">45.2. 创建 Grammar</a></li>
<li><a href="#_特殊的_token">45.3. 特殊的 token</a></li>
<li><a href="#_grammar_中的方法">45.4. Grammar 中的方法</a></li>
<li><a href="#_grammar_中的动态变量">45.5. Grammar 中的动态变量</a></li>
<li><a href="#_grammar_中的属性">45.6. Grammar 中的属性</a></li>
<li><a href="#_传递参数到_grammar_中">45.7. 传递参数到 Grammar 中</a></li>
<li><a href="#_action_object">45.8. Action Object</a></li>
</ul>
</li>
<li><a href="#_散列和映射">46. 散列和映射</a>
<ul class="sectlevel2">
<li><a href="#_关联角色和关联类">46.1. 关联角色和关联类</a></li>
<li><a href="#_可变哈希和不可变映射">46.2. 可变哈希和不可变映射</a></li>
<li><a href="#_hash_赋值">46.3. Hash 赋值</a></li>
<li><a href="#_hash_切片">46.4. Hash 切片</a></li>
<li><a href="#_非字符串键对象哈希">46.5. 非字符串键（对象哈希）</a></li>
<li><a href="#_约束值类型">46.6. 约束值类型</a></li>
<li><a href="#_循环哈希键和值">46.7. 循环哈希键和值</a></li>
<li><a href="#_就地编辑值">46.8. 就地编辑值</a></li>
</ul>
</li>
<li><a href="#_输入和输出全解">47. 输入和输出全解</a>
<ul class="sectlevel2">
<li><a href="#_基础知识">47.1. 基础知识</a></li>
<li><a href="#_导航路径">47.2. 导航路径</a></li>
<li><a href="#_working_with_files">47.3. Working with files</a></li>
<li><a href="#_从文件中读取">47.4. 从文件中读取</a></li>
<li><a href="#_错误的做事方法">47.5. 错误的做事方法</a></li>
<li><a href="#_字符串化_iopath">47.6. 字符串化 IO::Path</a></li>
</ul>
</li>
<li><a href="#_列表序列和数组">48. 列表、序列和数组</a>
<ul class="sectlevel2">
<li><a href="#_literal_lists">48.1. Literal Lists</a></li>
<li><a href="#_the_sigil">48.2. The @ sigil</a></li>
<li><a href="#_reset_a_list_container">48.3. Reset a List Container</a></li>
<li><a href="#_iteration">48.4. Iteration</a></li>
<li><a href="#_testing_for_elements">48.5. Testing for Elements</a></li>
<li><a href="#_lazy_lists">48.6. Lazy Lists</a></li>
<li><a href="#_immutability">48.7. Immutability</a></li>
<li><a href="#_list_contexts">48.8. List Contexts</a></li>
<li><a href="#_arrays">48.9. Arrays</a></li>
</ul>
</li>
<li><a href="#_元对象协议">49. 元对象协议</a>
<ul class="sectlevel2">
<li><a href="#_自省和_raku_的对象系统">49.1. 自省和 Raku 的对象系统</a></li>
<li><a href="#_元对象metaobjects">49.2. 元对象(MetaObjects)</a></li>
<li><a href="#_元对象系统的结构">49.3. 元对象系统的结构</a></li>
<li><a href="#_bootstrapping_concerns">49.4. Bootstrapping concerns</a></li>
<li><a href="#_组合和静态推理">49.5. 组合和静态推理</a></li>
<li><a href="#_能力和责任">49.6. 能力和责任</a></li>
<li><a href="#_能力便利和陷阱">49.7. 能力、便利和陷阱</a></li>
</ul>
</li>
<li><a href="#_原生调用接口">50. 原生调用接口</a>
<ul class="sectlevel2">
<li><a href="#_入门指南">50.1. 入门指南</a></li>
<li><a href="#_改变名字">50.2. 改变名字</a></li>
<li><a href="#_传递值和返回值">50.3. 传递值和返回值</a></li>
<li><a href="#_指定原生表示">50.4. 指定原生表示</a></li>
<li><a href="#_指针的基本使用">50.5. 指针的基本使用</a></li>
<li><a href="#_函数指针">50.6. 函数指针</a></li>
<li><a href="#_数组_3">50.7. 数组</a></li>
<li><a href="#_carray_方法">50.8. CArray 方法</a></li>
<li><a href="#_结构体">50.9. 结构体</a></li>
<li><a href="#_cunions">50.10. CUnions</a></li>
<li><a href="#_嵌套的_cstructs_和_cunions">50.11. 嵌套的 CStructs 和 CUnions</a></li>
<li><a href="#_类型指针">50.12. 类型指针</a></li>
<li><a href="#_字符串">50.13. 字符串</a></li>
<li><a href="#_函数参数">50.14. 函数参数</a></li>
<li><a href="#_库路径以及名字">50.15. 库路径以及名字</a></li>
<li><a href="#_导出的变量">50.16. 导出的变量</a></li>
<li><a href="#_对c的支持">50.17. 对C++的支持</a></li>
<li><a href="#_helper_函数">50.18. Helper 函数</a></li>
<li><a href="#_例子">50.19. 例子</a></li>
</ul>
</li>
<li><a href="#_raku_中的换行处理">51. Raku 中的换行处理</a></li>
<li><a href="#_数值">52. 数值</a>
<ul class="sectlevel2">
<li><a href="#_int_2">52.1. Int</a></li>
<li><a href="#_num">52.2. <code>Num</code></a></li>
<li><a href="#_complex">52.3. <code>Complex</code></a></li>
<li><a href="#_rational">52.4. <code>Rational</code></a></li>
<li><a href="#_除零">52.5. 除零</a></li>
<li><a href="#_同质异形">52.6. 同质异形</a></li>
<li><a href="#_原生数字">52.7. 原生数字</a></li>
<li><a href="#_numeric_infectiousness">52.8. Numeric infectiousness</a></li>
</ul>
</li>
<li><a href="#_raku_中的面向对象">53. Raku 中的面向对象</a>
<ul class="sectlevel2">
<li><a href="#_使用对象">53.1. 使用对象</a></li>
<li><a href="#_类型对象">53.2. 类型对象</a></li>
<li><a href="#_类">53.3. 类</a></li>
<li><a href="#_属性">53.4. 属性</a></li>
<li><a href="#_方法_2">53.5. 方法</a></li>
<li><a href="#_self_2">53.6. self</a></li>
<li><a href="#_继承_2">53.7. 继承</a></li>
<li><a href="#_对象构造">53.8. 对象构造</a></li>
<li><a href="#_roles">53.9. Roles</a></li>
<li><a href="#_role_application">53.10. Role Application</a></li>
<li><a href="#_stubs">53.11. Stubs</a></li>
<li><a href="#_元对象编程和自省">53.12. 元对象编程和自省</a></li>
<li><a href="#_内省_2">53.13. 内省</a></li>
</ul>
</li>
<li><a href="#_操作符_2">54. 操作符</a>
<ul class="sectlevel2">
<li><a href="#_操作符优先级">54.1. 操作符优先级</a></li>
<li><a href="#_操作符种类">54.2. 操作符种类</a></li>
<li><a href="#_term_优先级">54.3. Term 优先级</a></li>
<li><a href="#_环缀_4">54.4. 环缀 [ ]</a></li>
<li><a href="#_方法后缀优先级">54.5. 方法后缀优先级</a></li>
<li><a href="#_自增优先级">54.6. 自增优先级</a></li>
<li><a href="#_求幂优先级">54.7. 求幂优先级</a></li>
<li><a href="#_象形一元操作符的优先级">54.8. 象形一元操作符的优先级</a></li>
<li><a href="#_乘法优先级">54.9. 乘法优先级</a></li>
<li><a href="#_加法优先级">54.10. 加法优先级</a></li>
<li><a href="#_重复操作符优先级">54.11. 重复操作符优先级</a></li>
<li><a href="#_连结">54.12. 连结</a></li>
<li><a href="#_junctive_and_all_优先级">54.13. Junctive AND (all) 优先级</a></li>
<li><a href="#_junctive_or_any_precedence">54.14. Junctive OR (any) Precedence</a></li>
<li><a href="#_named_unary_precedence">54.15. Named Unary Precedence</a></li>
<li><a href="#_nonchaining_binary_precedence">54.16. Nonchaining Binary Precedence</a></li>
<li><a href="#_chaining_binary_precedence">54.17. Chaining Binary Precedence</a></li>
<li><a href="#_tight_and_precedence">54.18. Tight AND Precedence</a></li>
<li><a href="#_tight_or_precedence">54.19. Tight OR Precedence</a></li>
<li><a href="#_conditional_operator_precedence">54.20. Conditional Operator Precedence</a></li>
<li><a href="#_item_assignment_precedence">54.21. Item Assignment Precedence</a></li>
<li><a href="#_loose_unary_precedence">54.22. Loose Unary Precedence</a></li>
<li><a href="#_逗号操作符优先级">54.23. 逗号操作符优先级</a></li>
<li><a href="#_list_infix_precedence">54.24. List Infix Precedence</a></li>
<li><a href="#_list_prefix_precedence">54.25. List Prefix Precedence</a></li>
<li><a href="#_loose_and_precedence">54.26. Loose AND precedence</a></li>
<li><a href="#_loose_or_precedence">54.27. Loose OR Precedence</a></li>
</ul>
</li>
<li><a href="#_包">55. 包</a>
<ul class="sectlevel2">
<li><a href="#_names">55.1. Names</a></li>
<li><a href="#_伪包">55.2. 伪包</a></li>
<li><a href="#_查找名字">55.3. 查找名字</a></li>
<li><a href="#_全局">55.4. 全局</a></li>
<li><a href="#_版本">55.5. 版本</a></li>
</ul>
</li>
<li><a href="#_性能">56. 性能</a>
<ul class="sectlevel2">
<li><a href="#_首先剖析你的代码">56.1. 首先,剖析你的代码</a></li>
<li><a href="#_解决问题">56.2. 解决问题</a></li>
<li><a href="#_没有得到你需要想要的结果">56.3. 没有得到你需要/想要的结果?</a></li>
</ul>
</li>
<li><a href="#_raku_原生类型">57. Raku 原生类型</a>
<ul class="sectlevel2">
<li><a href="#_types_with_native_representation">57.1. Types with native representation</a></li>
<li><a href="#_types_with_native_representation_and_size">57.2. Types with native representation and size</a></li>
<li><a href="#_void_类型">57.3. <code>void</code> 类型</a></li>
<li><a href="#_atomic_types">57.4. <strong>Atomic</strong> types</a></li>
<li><a href="#_rakudo_specific_native_types">57.5. Rakudo specific native types</a></li>
</ul>
</li>
<li><a href="#_phasers_2">58. Phasers</a>
<ul class="sectlevel2">
<li><a href="#_phasers_3">58.1. Phasers</a></li>
<li><a href="#_程序执行_phasers">58.2. 程序执行 phasers</a></li>
<li><a href="#_block_phasers">58.3. Block phasers</a></li>
<li><a href="#_loop_phasers">58.4. Loop phasers</a></li>
<li><a href="#_exception_handling_phasers">58.5. Exception handling phasers</a></li>
<li><a href="#_object_phasers">58.6. Object phasers</a></li>
<li><a href="#_asynchronous_phasers">58.7. Asynchronous phasers</a></li>
<li><a href="#_doc_phasers">58.8. DOC phasers</a></li>
</ul>
</li>
<li><a href="#_编译指令_2">59. 编译指令</a>
<ul class="sectlevel2">
<li><a href="#_v6_x">59.1. v6.x</a></li>
<li><a href="#_monkey_guts">59.2. MONKEY-GUTS</a></li>
<li><a href="#_monkey_see_no_eval">59.3. MONKEY-SEE-NO-EVAL</a></li>
<li><a href="#_monkey_typing">59.4. MONKEY-TYPING</a></li>
<li><a href="#_monkey">59.5. MONKEY</a></li>
<li><a href="#_experimental">59.6. experimental</a></li>
<li><a href="#_fatal">59.7. fatal</a></li>
<li><a href="#_internals">59.8. internals</a></li>
<li><a href="#_invocant_2">invocant</a></li>
<li><a href="#_isms">isms</a></li>
<li><a href="#_lib_2">59.9. lib</a></li>
<li><a href="#_newline">59.10. newline</a></li>
<li><a href="#_nqp">59.11. nqp</a></li>
<li><a href="#_parameters">59.12. parameters</a></li>
<li><a href="#_precompilation">precompilation</a></li>
<li><a href="#_soft">59.13. soft</a></li>
<li><a href="#_strict_2">59.14. strict</a></li>
<li><a href="#_trace">59.15. trace</a></li>
<li><a href="#_v6_2">59.16. v6</a></li>
<li><a href="#_variables_2">59.17. variables</a></li>
<li><a href="#_worries">59.18. worries</a></li>
</ul>
</li>
<li><a href="#_引号结构">60. 引号结构</a>
<ul class="sectlevel2">
<li><a href="#_the_q_lang">60.1. The Q Lang</a></li>
<li><a href="#_regexes">60.2. Regexes</a></li>
</ul>
</li>
<li><a href="#_正则表达式">61. 正则表达式</a>
<ul class="sectlevel2">
<li><a href="#_词法约定">61.1. 词法约定</a></li>
<li><a href="#_字面值">61.2. 字面值</a></li>
<li><a href="#_通配符和字符类">61.3. 通配符和字符类</a></li>
<li><a href="#_量词">61.4. 量词</a></li>
<li><a href="#_alternation">61.5. Alternation: ||</a></li>
<li><a href="#_longest_alternation">61.6. Longest Alternation: |</a></li>
<li><a href="#_anchors">61.7. Anchors</a></li>
<li><a href="#_分组和捕获">61.8. 分组和捕获</a></li>
<li><a href="#_替换">61.9. 替换</a></li>
<li><a href="#_tilde_for_nesting_structures">61.10. Tilde for nesting structures</a></li>
<li><a href="#_subrules">61.11. Subrules</a></li>
<li><a href="#_副词_2">61.12. 副词</a></li>
<li><a href="#_look_around_assertions">61.13. Look-around assertions</a></li>
<li><a href="#_best_practices_and_gotchas">61.14. Best practices and gotchas</a></li>
</ul>
</li>
<li><a href="#_控制例程">62. 控制例程</a>
<ul class="sectlevel2">
<li><a href="#_sub_exit">62.1. sub exit</a></li>
<li><a href="#_done">62.2. done</a></li>
<li><a href="#_emit">62.3. emit</a></li>
<li><a href="#_undefine">62.4. undefine</a></li>
</ul>
</li>
<li><a href="#_setsbags_和_mixes">63. Sets、Bags 和 Mixes</a>
<ul class="sectlevel2">
<li><a href="#_setbag_operators">63.1. Set/Bag operators</a></li>
</ul>
</li>
<li><a href="#_下标">64. 下标</a>
<ul class="sectlevel2">
<li><a href="#_subscripts">64.1. Subscripts</a></li>
<li><a href="#_basics">64.2. Basics</a></li>
<li><a href="#_nonexistent_elements">64.3. Nonexistent elements</a></li>
<li><a href="#_from_the_end">64.4. From the end</a></li>
<li><a href="#_slices">64.5. Slices</a></li>
<li><a href="#_multiple_dimensions">64.6. Multiple dimensions</a></li>
<li><a href="#_modifying_elements">64.7. Modifying elements</a></li>
<li><a href="#_autovivification">64.8. Autovivification</a></li>
<li><a href="#_binding_2">64.9. Binding</a></li>
<li><a href="#_adverbs">64.10. Adverbs</a></li>
<li><a href="#_custom_types">64.11. Custom types</a></li>
</ul>
</li>
<li><a href="#_语法_2">65. 语法</a>
<ul class="sectlevel2">
<li><a href="#_词法约定_2">65.1. 词法约定</a></li>
<li><a href="#_语句和表达式">65.2. 语句和表达式</a></li>
<li><a href="#_项_2">65.3. 项</a></li>
</ul>
</li>
<li><a href="#_系统交互">66. 系统交互</a>
<ul class="sectlevel2">
<li><a href="#_通过命令行获取参数">66.1. 通过命令行获取参数</a></li>
<li><a href="#_以交互方式获取参数">66.2. 以交互方式获取参数</a></li>
<li><a href="#_同步和异步运行程序">66.3. 同步和异步运行程序</a></li>
<li><a href="#_通过原生_api_进行操作系统调用">66.4. 通过原生 API 进行操作系统调用</a></li>
</ul>
</li>
<li><a href="#_traits_2">67. Traits</a>
<ul class="sectlevel2">
<li><a href="#_is_trait">67.1. is trait</a></li>
</ul>
</li>
<li><a href="#_类型系统">68. 类型系统</a>
<ul class="sectlevel2">
<li><a href="#_raku类型的定义">68.1. Raku类型的定义</a></li>
<li><a href="#_类型声明符">68.2. 类型声明符</a></li>
</ul>
</li>
<li><a href="#_unicode_2">69. Unicode</a>
<ul class="sectlevel2">
<li><a href="#_文件句柄和输入输出">69.1. 文件句柄和输入输出</a></li>
<li><a href="#_输入_unicode_代码点和代码点序列">69.2. 输入 unicode 代码点和代码点序列</a></li>
</ul>
</li>
<li><a href="#_unicode_和_ascii_符号">70. Unicode 和 ASCII 符号</a>
<ul class="sectlevel2">
<li><a href="#_字母字符">70.1. 字母字符</a></li>
<li><a href="#_数字字符">70.2. 数字字符</a></li>
<li><a href="#_数字值">70.3. 数字值</a></li>
<li><a href="#_空白字符">70.4. 空白字符</a></li>
<li><a href="#_其它可接受的单代码点">70.5. 其它可接受的单代码点</a></li>
<li><a href="#_多代码点">70.6. 多代码点</a></li>
</ul>
</li>
<li><a href="#_变量_5">71. 变量</a>
<ul class="sectlevel2">
<li><a href="#_sigils">71.1. Sigils</a></li>
<li><a href="#_项和列表赋值">71.2. 项和列表赋值</a></li>
<li><a href="#_无符号变量">71.3. 无符号变量</a></li>
<li><a href="#_twigils_2">71.4. Twigils</a></li>
<li><a href="#_twigil">71.5. * Twigil</a></li>
<li><a href="#_twigil_2">71.6. ! Twigil</a></li>
<li><a href="#_twigil_3">71.7. ? Twigil</a></li>
<li><a href="#_twigil_4">71.8. . Twigil</a></li>
<li><a href="#_twigil_5">71.9. &lt; Twigil</a></li>
<li><a href="#_twigil_6">71.10. ^ Twigil</a></li>
<li><a href="#_twigil_7">71.11. : Twigil</a></li>
<li><a href="#_twigil_8">71.12. = Twigil</a></li>
<li><a href="#_twigil_9">71.13. ~ Twigil</a></li>
<li><a href="#_变量声明符和作用域">71.14. 变量声明符和作用域</a></li>
<li><a href="#_类型约束和初始化">71.15. 类型约束和初始化</a></li>
<li><a href="#_默认的有定义的变量指令">71.16. 默认的有定义的变量指令</a></li>
<li><a href="#_特殊变量_3">71.17. 特殊变量</a></li>
<li><a href="#_编译时变量">71.18. 编译时变量</a></li>
<li><a href="#_动态变量">71.19. 动态变量</a></li>
</ul>
</li>
<li><a href="#_实验特性">72. 实验特性</a>
<ul class="sectlevel2">
<li><a href="#_pack">72.1. <strong>pack</strong></a></li>
<li><a href="#_宏">72.2. <strong>宏</strong></a></li>
<li><a href="#_cached">72.3. <strong>cached</strong></a></li>
</ul>
</li>
<li><a href="#_opener_graphemes">73. Opener graphemes</a></li>
<li><a href="#_语句前缀">74. 语句前缀</a>
<ul class="sectlevel2">
<li><a href="#_lazy">74.1. lazy</a></li>
<li><a href="#_eager">74.2. eager</a></li>
<li><a href="#_hyper_race">74.3. hyper, race</a></li>
<li><a href="#_quietly_2">74.4. quietly</a></li>
<li><a href="#_try">74.5. try</a></li>
<li><a href="#_do_3">74.6. do</a></li>
<li><a href="#_sink">74.7. sink</a></li>
<li><a href="#_once_2">74.8. once</a></li>
<li><a href="#_gather">74.9. gather</a></li>
<li><a href="#_start_2">74.10. start</a></li>
<li><a href="#_react">74.11. react</a></li>
<li><a href="#_supply">74.12. supply</a></li>
</ul>
</li>
<li><a href="#_声明符原型">75. 声明符原型</a></li>
</ul>
</div>
<div class="sect1">
<h2 id="_简介">1. 简介</h2>
<div class="sectionbody">
<div class="paragraph">
<p>记录像 Raku 这样的大型语言必须平衡几个相互矛盾的目标，例如简洁而全面，迎合具有丰富经验的专业开发人员，同时也可以迎合接触到该语言的新手。</p>
</div>
<div class="paragraph">
<p>有关快速实践的介绍，有一个简短的<a href="https://docs.raku.org/language/101-basics">注释编程示例</a>。</p>
</div>
<div class="paragraph">
<p>对于具有其他语言经验的程序员，有许多<strong>迁移</strong>指南可以将 Raku 的功能与其他语言进行比较和对比。</p>
</div>
<div class="paragraph">
<p>许多教程涵盖了 Raku 特别具有创新性的几个领域。节标题应该有助于导航剩余的文档。</p>
</div>
<div class="paragraph">
<p>raku.org 网站上的其他地方列出了许多<a href="https://raku.org/resources">有用的资源</a>。这些包括文章，书籍，幻灯片演示和视频。</p>
</div>
<div class="paragraph">
<p>已经发现，Raku 的新手经常会提出问题，这些问题表明了其他编程范例带来的假设。建议首先审查基本主题部分中的以下部分。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.raku.org/type/Signature">签名</a> - 每个例程（包括子例程和方法）都有签名。理解子或方法的签名中给出的信息提供了一种快速掌握例程的操作和效果的方法。</p>
</li>
<li>
<p><a href="https://docs.raku.org/language/containers">容器</a> - 变量，就像计算机语言的名词一样，是存储信息的容器。容器正式名称中的第一个字母，例如 <code>$my-variable</code> 的 <code>'$'</code>，或 <code>@an-array-of-things</code> 的 <code>'@'</code>，或 <code>%the-score-in-the</code> 的 <code>'％'</code> - 携带有关容器的信息。但是，Raku 比其他语言更抽象，可以存储在容器中。因此，例如，$scalar 容器可以包含实际上是数组的对象。</p>
</li>
<li>
<p><a href="https://docs.raku.org/language/classtut">类和角色</a> -  Raku 基本上基于对象，它们根据类和角色进行描述。与某些语言不同，Raku 并没有强制使用面向对象的编程实践，并且可以编写有用的程序，就好像 Raku 纯粹是程序性的。然而，复杂的软件，例如 Raku 的 Rakudo 编译器，通过编写面向对象的惯用法变得更加简单，这就是为什么通过查看类是什么以及角色是什么来更容易理解 Raku 文档。如果不了解类和角色，就很难理解类型，文档的整个部分都是专门用的。</p>
</li>
<li>
<p><a href="https://docs.raku.org/language/traps">要避免的陷阱</a> - 一些常见的假设导致代码无法像程序员想要的那样工作。本节标识了一些。当某些事情没有成功时，值得回顾一下。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_通过例子学习_raku">2. 通过例子学习 Raku</h2>
<div class="sectionbody">
<div class="paragraph">
<p>假设您举办乒乓球锦标赛。裁判员以格式告诉你每场比赛的结果 <code>Player1 Player2 | 3:2</code>，这意味着 Player1 赢 Player2 了3到2局。你需要一个脚本来总结每个玩家赢得的比赛和数量，以确定总冠军。</p>
</div>
<div class="paragraph">
<p>输入数据（存储在一个名为的文件中scores.txt）如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Beth Ana Charlie Dave
Ana Dave | 3:0
Charlie Beth | 3:1
Ana Beth | 2:3
Dave Charlie | 3:0
Ana Charlie | 3:1
Beth Dave | 0:3</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一行是球员名单。每个后续行记录匹配的结果。</p>
</div>
<div class="paragraph">
<p>这是在Raku中解决该问题的一种方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6;

my $file  = open 'scores.txt';
my @names = $file.get.words;

my %matches;
my %sets;

for $file.lines -&gt; $line {
    next unless $line; # ignore any empty lines

    my ($pairing, $result) = $line.split(' | ');
    my ($p1, $p2)          = $pairing.words;
    my ($r1, $r2)          = $result.split(':');

    %sets{$p1} += $r1;
    %sets{$p2} += $r2;

    if $r1 &gt; $r2 {
        %matches{$p1}++;
    } else {
        %matches{$p2}++;
    }
}

my @sorted = @names.sort({ %sets{$_} }).sort({ %matches{$_} }).reverse;

for @sorted -&gt; $n {
    say "$n has won %matches{$n} matches and %sets{$n} sets";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会产生输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Ana has won 2 matches and 8 sets
Dave has won 2 matches and 6 sets
Charlie has won 1 matches and 4 sets
Beth has won 1 matches and 4 sets</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_v6">2.1. v6</h3>
<div class="paragraph">
<p>每个Raku程序都应该以类似于的行开头use v6;。该行告诉编译器程序期望的Perl版本。如果您不小心使用Perl 5运行该文件，您将收到有用的错误消息。6.c是Raku版本的示例。</p>
</div>
</div>
<div class="sect2">
<h3 id="_语句">2.2. 语句</h3>
<div class="paragraph">
<p>Raku程序由零个或多个语句组成。甲语句用分号或在线的端部的大括号结束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $file = open 'scores.txt';</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_词法和块">2.3. 词法和块</h3>
<div class="paragraph">
<p>my声明一个词法变量，它只在从声明点到块结尾的当前块中可见。如果没有封闭块，则在整个文件的剩余部分（它实际上是封闭块）中可见。块是大括号之间的代码的任何部分{ }。</p>
</div>
</div>
<div class="sect2">
<h3 id="_符号和标识符">2.4. 符号和标识符</h3>
<div class="paragraph">
<p>变量名开始于印记，这是因为这样的非字母数字符号$，@，%，或&amp;--or偶尔双冒号::。Sigils指示变量的结构接口，例如它是否应被视为单个值，复合值，子例程等。在sigil之后出现一个标识符，可以由字母，数字和下划线组成。在字母之间你也可以使用破折号-或撇号'，因此isn&#8217;t并且double-click是有效的标识符。</p>
</div>
</div>
<div class="sect2">
<h3 id="_标量">2.5. 标量</h3>
<div class="paragraph">
<p>Sigils指示变量的默认访问方法。带有@印记的变量可以在位置上访问; 带有%sigil的变量由字符串键访问。的$印记，然而，指示可以包含任何单个值和以任何方式进行访问的通用标量容器中。标量甚至可以包含像a Array或a 这样的复合对象Hash; 的$印记表示这应该被视为一个单一的值，即使在期望多个值（如用一个上下文Array或Hash）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_文件句柄和赋值">2.6. 文件句柄和赋值</h3>
<div class="paragraph">
<p>内置函数open打开一个文件，此处命名scores，并返回一个文件句柄 - 表示该文件的对象。等号将该文件句柄= 分配给左侧的变量，这意味着$file现在存储文件句柄。</p>
</div>
</div>
<div class="sect2">
<h3 id="_字符串字面量">2.7. 字符串字面量</h3>
<div class="paragraph">
<p>'scores.txt&#8217;是一个字符串文字。字符串是一段文本，字符串文字是直接出现在程序中的字符串。在这一行中，它是提供给的参数open。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @names = $file.get.words;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_数组方法和调用">2.8. 数组、方法和调用</h3>
<div class="paragraph">
<p>右侧调用一个方法 - 一个命名的行为组 - 以get存储在其中的文件句柄命名$file。该get方法从文件中读取并返回一行，删除行结尾。如果您$file在打电话后打印内容get，您将看到第一行不再在那里。words也是一个方法，在返回的字符串上调用get。words将其调用者 - 它所操作的字符串 - 分解为一个单词列表，这里的意思是由空格分隔的字符串。它将单个字符串&#8217;Beth Ana Charlie Dave&#8217;转换为字符串列表&#8217;Beth', 'Ana', 'Charlie', 'Dave'。</p>
</div>
<div class="paragraph">
<p>最后，此列表存储在<a href="https://docs.raku.org/type/Array">Array</a>中 @names。该@印记标志着声明的变量作为Array。数组存储有序列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %matches;
my %sets;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_散列">2.9. 散列</h3>
<div class="paragraph">
<p>这两行代码声明了两个哈希值。的%印记标记每个变量作为Hash。A Hash是键值对的无序集合。其他编程语言称为哈希表，字典或映射。您可以查询一个哈希表对应于一定的值$key用%hash{$key}。</p>
</div>
<div class="paragraph">
<p>在得分计数程序中，%matches存储每个玩家赢得的比赛数量。%sets存储每个玩家赢得的套数。这两个哈希都是由玩家的名字索引的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $file.lines -&gt; $line {
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_for_和_block">2.10. for 和 block</h3>
<div class="paragraph">
<p>for生成一个循环，该循环运行由花括号分隔的块一次，用于列表的每个项目，将变量设置$line为每次迭代的当前值。$file.lines生成从文件读取的行列表，从文件scores.txt的第二行开始，因为我们已经调用$file.get过一次，然后一直到文件的末尾。</p>
</div>
<div class="paragraph">
<p>在第一次迭代期间，$line将包含字符串Ana Dave | 3:0; 在第二次，Charlie Beth | 3:1等等。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my ($pairing, $result) = $line.split(' | ');</code></pre>
</div>
</div>
<div class="paragraph">
<p>my可以同时声明多个变量。赋值的右侧是对名为的方法的调用split，将该字符串' | '作为参数传递。</p>
</div>
<div class="paragraph">
<p>split将其调用者分解为字符串列表，以便将列表项与分隔符连接将' | '生成原始字符串。</p>
</div>
<div class="paragraph">
<p>$pairing获取返回列表的第一项，$result第二项。</p>
</div>
<div class="paragraph">
<p>处理完第一行后，$pairing将保持字符串Ana Dave和$result 3:0。</p>
</div>
<div class="paragraph">
<p>接下来的两行遵循相同的模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my ($p1, $p2) = $pairing.words;
my ($r1, $r2) = $result.split(':');</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个提取并存储变量$p1和中两个玩家的名字$p2。第二个为每个玩家提取结果并将其存储在$r1和中$r2。</p>
</div>
<div class="paragraph">
<p>处理完文件的第一行后，变量包含值：cell '0'</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Variable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Contents</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$line</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'Ana Dave | 3:0'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$pairing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'Ana Dave'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$result</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'3:0'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$p1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'Ana'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$p2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'Dave'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$r1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'3'</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$r2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'0'</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>然后程序计算每个玩家赢得的次数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">%sets{$p1} += $r1;
%sets{$p2} += $r2;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>+=</code> 赋值运算符是一个快捷方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">%sets{$p1} = %sets{$p1} + $r1;
%sets{$p2} = %sets{$p2} + $r2;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_any_和">2.11. Any 和 +=</h3>
<div class="paragraph">
<p>+= $r1表示将左侧变量中的值增加$ r1。在第一次迭代%sets{$p1}中尚未设置，因此它默认为一个名为的特殊值Any。加法和递增运算符视为Any零的数字; 字符串会自动转换为数字，因为加法是一个数字运算。</p>
</div>
<div class="paragraph">
<p>fat arrow，pair和autovivification
在这两行执行之前，%sets为空。添加到不在散列中的条目将导致该条目即时生成，其值从零开始。（这是autovivification）。在这两行第一次运行后，%sets包含&#8217;Ana' &#8658; 3, 'Dave' &#8658; 0 。（胖箭头&#8658; 分隔键中的键和值Pair。）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $r1 &gt; $r2 {
    %matches{$p1}++;
} else {
    %matches{$p2}++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果$r1在数值上大于$r2，则%matches{$p1}增加1。如果$r1不大于$r2，则%matches{$p2}递增。正如在这种情况下+=，如果之前不存在任何一个哈希值，它将通过增量操作自动生成。</p>
</div>
</div>
<div class="sect2">
<h3 id="_后自增和前自增">2.12. 后自增和前自增</h3>
<div class="paragraph">
<p>`$thing` 是 `$thing += 1` 或 `$thing = $thing + 1` 的缩写，除了表达式的返回值在增量$thing 之前的小异常，而不是递增的值。与许多其他编程语言一样，您可以将其用作前缀。然后它返回递增的值; my $x = 1; say ++$x打印2。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @sorted = @names.sort({ %sets{$_} }).sort({ %matches{$_} }).reverse;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_变量">2.13. 变量, $_</h3>
<div class="paragraph">
<p>该行包含三个单独的简单步骤。数组的sort方法返回数组内容的排序版本。但是，数组上的默认排序按其内容排序。要以获胜者优先顺序打印玩家名称，代码必须按照玩家的分数而不是他们的名字对数组进行排序。该sort方法的参数是一个块，用于将数组元素（播放器的名称）转换为要排序的数据。数组项通过主题变量 传入$_。</p>
</div>
</div>
<div class="sect2">
<h3 id="_块">2.14. 块</h3>
<div class="paragraph">
<p>您之前已经看过块：for循环&#8594; $line { &#8230;&#8203; } 和if语句都在块上运行。块是一个独立的Raku代码片段，带有可选的签名（&#8594; $line 部分）。</p>
</div>
<div class="paragraph">
<p><a href="mailto:按分数对玩家进行排序的最简单方法是@names.sort">按分数对玩家进行排序的最简单方法是@names.sort</a>({ %matches{$_} })，根据赢得的匹配数进行排序。然而Ana和Dave都赢了两场比赛。这种简单的排序并没有考虑赢得的套数，这是决定谁赢得锦标赛的次要标准。</p>
</div>
</div>
<div class="sect2">
<h3 id="_稳定的排序">2.15. 稳定的排序</h3>
<div class="paragraph">
<p>当两个数组项具有相同的值时，sort将它们保留为找到它们的顺序。计算机科学家称之为稳定的。该程序利用Raku的这个属性sort通过两次排序来实现目标：首先是赢得的集合数量（次要标准），然后是赢得的匹配数量。</p>
</div>
<div class="paragraph">
<p>在第一个排序步骤之后，名称在顺序中Beth Charlie Dave Ana。在第二个排序步骤之后，它仍然是相同的，因为没有人比其他人赢得更少的比赛但是更多的比赛。这样的情况是完全可能的，特别是在较大的比赛中。</p>
</div>
<div class="paragraph">
<p>sort从最小到最大按升序排序。这与所需顺序相反。因此，代码.reverse在第二次排序的结果上调用方法，并将最终列表存储在其中@sorted。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @sorted -&gt; $n {
    say "$n has won %matches{$n} matches and %sets{$n} sets";
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sayprint_和_put">2.16. say，print 和 put</h3>
<div class="paragraph">
<p>为了打印出玩家及其分数，代码循环@sorted，$n依次设置每个玩家的名字。将此代码读作“对于已排序的每个元素，设置$n为元素，然后执行以下块的内容”。say将其参数打印到标准输出（通常是屏幕），然后是换行符。（print如果您不想在最后使用换行符，请使用。）</p>
</div>
<div class="paragraph">
<p>请注意，say通过调用.gist方法将截断某些数据结构，因此put如果您想要精确输出则更安全。</p>
</div>
</div>
<div class="sect2">
<h3 id="_插值">2.17. 插值</h3>
<div class="paragraph">
<p>当您运行该程序时，您将看到它say不会逐字打印该字符串的内容。代替$n它打印变量的内容$n- 存储在其中的玩家的名字$n。代码及其内容的自动替换是插值。此插值仅在由双引号分隔的字符串中发生"&#8230;&#8203;"。单引号字符串'&#8230;&#8203;'不进行插值：</p>
</div>
</div>
<div class="sect2">
<h3 id="_双引号字符串和单引号字符串">2.18. 双引号字符串和单引号字符串</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $names = 'things';
say 'Do not call me $names'; # OUTPUT: «Do not call me $names␤»
say "Do not call me $names"; # OUTPUT: «Do not call me things␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku中的双引号字符串可以使用$sigil以及花括号中的代码块来插入变量。由于任何Perl代码都可以出现在花括号中，因此可以通过将它们放在花括号中来插入Arrays和Hashes。</p>
</div>
<div class="paragraph">
<p>花括号内的数组使用每个项目之间的单个空格字符进行插值。花括号内的哈希值被插值为一系列线条。每行包含一个键，后跟一个制表符，然后是与该键相关的值，最后是换行符。</p>
</div>
<div class="paragraph">
<p>我们现在看一个例子吧。</p>
</div>
<div class="paragraph">
<p>在此示例中，您将看到一些特殊语法，可以更轻松地创建字符串列表。这是&lt;&#8230;&#8203;&gt; <a href="https://docs.raku.org/language/operators#index-entry-qw-quote-words-quote-words">引用词</a>构造。当您在&lt;和&gt;之间放置单词时，它们都被假定为字符串，因此您不需要将它们分别用双引号括起来"&#8230;&#8203;" 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "Math: { 1 + 2 }";                  # OUTPUT: «Math: 3␤»
my @people = &lt;Luke Matthew Mark&gt;;
say "The synoptics are: {@people}";     # OUTPUT: «The synoptics are: Luke Matthew Mark␤»

say "{%sets}␤";                         # From the table tennis tournament

# Charlie 4
# Dave    6
# Ana     8
# Beth    4</code></pre>
</div>
</div>
<div class="paragraph">
<p>当数组和散列变量直接出现在双引号字符串中（而不是在大括号内）时，如果它们的名称后跟postcircumfix - 一个跟在语句后面的包围对，它们只会被插值。在变量名和postcircumfix之间进行方法调用也没问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_禅切">2.19. 禅切</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @flavors = &lt;vanilla peach&gt;;

say "we have @flavors";           # OUTPUT: «we have @flavors␤»
say "we have @flavors[0]";        # OUTPUT: «we have vanilla␤»
# so-called "Zen slice"
say "we have @flavors[]";         # OUTPUT: «we have vanilla peach␤»

# method calls ending in postcircumfix
say "we have @flavors.sort()";    # OUTPUT: «we have peach vanilla␤»

# chained method calls:
say "we have @flavors.sort.join(', ')";
                                # OUTPUT: «we have peach, vanilla␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_练习">2.20. 练习</h3>
<div class="paragraph">
<p>1.示例程序的输入格式是多余的：第一行包含所有玩家的名字是不必要的，因为你可以通过查看后续行中的名字来找出参加锦标赛的玩家。</p>
</div>
<div class="paragraph">
<p>如果不使用@names变量，如何使程序运行？提示：%hash.keys返回存储的所有密钥的列表%hash。</p>
</div>
<div class="paragraph">
<p>答：删除该行my @names = $file.get.words;，然后更改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @sorted = @names.sort({ %sets{$_} }).sort({ %matches{$_} }).reverse;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @sorted = %sets.keys.sort({ %sets{$_} }).sort({ %matches{$_} }).reverse;</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了删除冗余@names变量之外，您还可以使用它来警告播放器是否出现在第一行中未提及的情况，例如由于拼写错误。你会如何修改你的程序来实现这一目标？</p>
</div>
<div class="paragraph">
<p>提示：尝试使用成员资格运算符。</p>
</div>
<div class="paragraph">
<p>答：更改@names到@valid-players。当通过文件的行循环，请检查$p1和$p2在@valid-players。请注意，对于<a href="https://docs.raku.org/routine/(elem">成员运算符</a>)，您也可以使用(elem)和!(elem)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">...;
my @valid-players = $file.get.words;
...;

for $file.lines -&gt; $line {
    my ($pairing, $result) = $line.split(' | ');
    my ($p1, $p2)          = $pairing.split(' ');
    if $p1 ∉ @valid-players {
        say "Warning: '$p1' is not on our list!";
    }
    if $p2 ∉ @valid-players {
        say "Warning: '$p2' is not on our list!";
    }
    ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_perl_5_到_raku_的指南_简而言之">3. Perl 5 到 Raku 的指南 - 简而言之</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这个页面试图提供从 Perl 5 到 Raku 的语法和语义变化的快速路径。无论在 Perl 5 中有什么用，必须在 Raku 中以不同的方式编写，这里应该列出（而许多新的 Raku 特性和惯用法）不需要）。</p>
</div>
<div class="paragraph">
<p>因此，这不应该被误认为初学者教程或 Raku 的宣传概述;它旨在作为 Raku 学习者的技术参考，具有强大的 Perl 5 背景，以及任何将 Perl 5 代码移植到 Raku 的人（尽管注意到自动翻译可能更方便）。</p>
</div>
<div class="paragraph">
<p>关于语义的注释;当我们在本文档中说“现在”时，我们大多只是说“现在你正在试用 Raku”。我们并不是要暗示 Perl 5 现在突然过时了。恰恰相反，我们大多数人都喜欢 Perl 5，我们期望 Perl 5 能够继续使用多年。实际上，我们更重要的目标之一是使 Perl 5 和 Raku 之间的交互顺利进行。然而，我们也喜欢 Raku 中的设计决策，它们比 Perl 5 中的许多历史设计决策更新，可以说是更好的集成。我们很多人都希望在接下来的十年或两年内，Raku 将成为更主要的语言。如果你想在未来的意义上采取“现在”，那也没关系。但是我们根本不会对导致战斗的任何/或者思考感兴趣。</p>
</div>
<div class="sect2">
<h3 id="_cpan">3.1. CPAN</h3>
<div class="paragraph">
<p>参考 <a href="https://modules.raku.org/">https://modules.raku.org/</a></p>
</div>
<div class="paragraph">
<p>如果您使用的模块尚未转换为 Raku，并且本文档中未列出任何替代方案，则可能尚未解决其在 Raku 下的使用问题。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/niner/Inline-Perl5/">Inline::Perl5</a> 项目通过使用 Perl 解释器的嵌入式实例来运行 Perl 5 代码，可以直接从 Raku 代码中使用 Perl 5 模块。</p>
</div>
<div class="paragraph">
<p>这很简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># the :from&lt;Perl5&gt; makes Raku load Inline::Perl5 first (if installed)
# and then load the Scalar::Util module from Perl 5
use Scalar::Util:from&lt;Perl5&gt; &lt;looks_like_number&gt;;
say looks_like_number "foo";   # 0
say looks_like_number "42";    # 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>许多 Perl 5 模块已经移植到 Raku，试图尽可能多地维护这些模块的 API，作为 CPAN Butterfly Plan 的一部分。 这些可以在 <a href="https://modules.raku.org/t/CPAN5">https://modules.raku.org/t/CPAN5</a> 找到。</p>
</div>
<div class="paragraph">
<p>许多 Perl 5 内置函数（目前大约 100个）已经以相同的语义移植到 Raku。 考虑一下 Perl 5 中的 shift 函数默认情况下从 <code>@_</code> 或 <code>@ARGV</code> 转移，具体取决于上下文。 这些可以在 <a href="https://modules.raku.org/t/Perl5">https://modules.raku.org/t/Perl5</a> 找到，作为可单独加载的模块，在 <a href="https://modules.raku.org/dist/P5built-ins">P5built-ins</a> 包中可以一次性获取所有这些模块。</p>
</div>
</div>
<div class="sect2">
<h3 id="_语法">3.2. 语法</h3>
<div class="paragraph">
<p>两种语言之间的语法有一些差异，从如何定义标识符开始。</p>
</div>
<div class="sect3">
<h4 id="_标识符">3.2.1. 标识符</h4>
<div class="paragraph">
<p>Raku 允许在标识符中使用破折号（ <code>-</code> ），下划线（<code>_</code>），撇号（<code>'</code>）和字母数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub test-doesn't-hang { ... }
my $ความสงบ = 42;
my \Δ = 72; say 72 - Δ;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_方法调用">3.2.2. <a href="https://docs.raku.org/language/5to6-nutshell#___top">&#8594;</a> 方法调用</h4>
<div class="paragraph">
<p>如果您已经阅读过任何 Raku 代码，那么很明显，方法调用语法现在使用的是点而不是箭头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">$person-&gt;name  # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$person.name   # Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>点符号更容易键入，更符合行业标准。 但我们也想偷取其他东西的箭头。 （如果你想知道的话，现在用 <code>~</code> 运算符完成连接。）</p>
</div>
<div class="paragraph">
<p>要调用在运行时之前名称未知的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">$object-&gt;$methodname(@args);  # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$object."$methodname"(@args); # Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果省略引号，那么 Raku 要求 <code>$methodname</code> 包含一个 <code>Method</code> 对象，而不是该方法的简单字符串名称。 是的，Raku 中的所有内容都可以被视为一个对象。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_空白">3.3. 空白</h3>
<div class="paragraph">
<p>即使启用了严格的模式和警告，Perl 5也允许在使用空格时具有惊人的灵活性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># unidiomatic but valid Perl 5
say"Hello ".ucfirst  ($people
    [$ i]
    -&gt;
    name)."!"if$greeted[$i]&lt;1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 还支持程序员的自由和创造力，但平衡语法灵活性与其设计目标一致，即具有支持单遍解析和有用错误消息的一致，确定性，可扩展语法，干净地集成自定义运算符等功能，并且不会引导程序员 意外地错误表达他们的意图。 此外，“代码高尔夫”的实践略微不再强调; Raku 的设计理念比按键更简洁。</p>
</div>
<div class="paragraph">
<p>因此，语法中有许多地方，其中空格在 Perl 5 中是可选的，但在 Raku 中是强制的或禁止的。许多这些限制不太可能涉及很多真实的 Perl 代码（例如，不允许在空白之间使用空格） sigil和变量的名称），但有一些不幸与 Perl 黑客的习惯编码风格冲突：</p>
</div>
<div class="paragraph">
<p>在参数列表的左括号之前不允许有空格。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">substr ($s, 4, 1); # Perl 5 (in Raku this would try to pass a single
                       #         argument of type List to substr)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">substr($s, 4, 1);  # Raku
substr $s, 4, 1;   # Raku - alternative parentheses-less style</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果这真的是一个问题，那么你可能想看看 Raku 生态系统中的 <code>Slang::Tuxic</code> 模块：它改变了 Raku 的语法，你可以在开放之前有一个空格 参数列表的括号。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>关键字后立即需要空格</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my($alpha, $beta);          # Perl 5, tries to call my() sub in Raku</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my ($alpha, $beta);         # Raku</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if($a &lt; 0) { ... }          # Perl 5, dies in Raku</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if ($a &lt; 0) { ... }         # Raku
if $a &lt; 0 { ... }           # Raku, more idiomatic</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">while($x-- &gt; 5) { ... }     # Perl 5, dies in Raku</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">while ($x-- &gt; 5) { ... }    # Raku
while $x-- &gt; 5 { ... }      # Raku, more idiomatic</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>前缀运算符之后或 postfix/postcircumfix运算符（包括数组/散列下标）之前不允许有空格。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">$seen {$_} ++; # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">%seen{$_}++;   # Raku</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>中缀运算符之前所需的空白，如果它与现有的 postfix/postcircumfix运算符冲突。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">$n&lt;1;   # Perl 5 (in Raku this would conflict with postcircumfix &lt; &gt;)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$n &lt; 1; # Raku</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>但是，在方法调用期间允许使用空格！</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># Perl 5
my @books = $xml
  -&gt;parse_file($file)          # some comment
  -&gt;findnodes("/library/book");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku
my @books = $xml
  .parse-file($file)           # some comment
  .findnodes("/library/book");</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，请注意，您可以使用<a href="https://docs.raku.org/language/syntax#Unspace">unspace</a>在Raku代码中添加空格，否则不允许这样做。</p>
</div>
<div class="paragraph">
<p>另请参见<a href="https://docs.raku.org/language/syntax#Lexical_conventions">语法页面中的其他词法约定</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_符号">3.4. 符号</h3>
<div class="paragraph">
<p>在 Perl 5 中，数组和哈希值根据访问方式使用更改的符号。在 Raku 中，无论变量如何被使用，这些符号都是不变的 - 您可以将它们视为变量名称的一部分。</p>
</div>
<div class="sect3">
<h4 id="_标量_2">3.4.1. $ 标量</h4>
<div class="paragraph">
<p><code>$</code> 符号现在总是与“标量”变量（例如 <code>$name</code>）一起使用，而不再用于<a href="https://docs.raku.org/language/5to6-nutshell#%5B%5D_Array_indexing%2Fslicing">数组索引</a>和<a href="https://docs.raku.org/language/5to6-nutshell#%7B%7D_Hash_indexing%2Fslicing">散列索引</a>。 也就是说，您仍然可以使用 <code>$x[1]</code> 和 <code>$x{"foo"}</code>，但它将作用于 <code>$x</code>，对类似名称的 <code>@x</code> 或 <code>%x`没有影响。 现在可以使用</code>@x[1]` 和 <code>%x{"foo"}</code> 访问这些内容。</p>
</div>
</div>
<div class="sect3">
<h4 id="_数组">3.4.2. @ 数组</h4>
<div class="paragraph">
<p>@ 符号现在总是与"数组"变量一起使用（例如 <code>@months</code>，<code>@months<a href="https://docs.raku.org/language/5to6-nutshell#%7B%7D_Hash_indexing%2Fslicing">2</a></code>，<code>@months[2, 4]</code>），而不再用于[值切片哈希]。</p>
</div>
</div>
<div class="sect3">
<h4 id="_散列_2">3.4.3. % 散列</h4>
<div class="paragraph">
<p><code>%</code> 符号现在总是与“哈希”变量一起使用（例如 <code>%calories</code>, <code>%calories&lt;apple&gt;</code>, <code>%calories&lt;pear plum&gt;</code>），而不再用于<a href="https://docs.raku.org/language/5to6-nutshell#%5B%5D_Array_indexing%2Fslicing">键/值切片数组</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_sub">3.4.4. Sub</h4>
<div class="paragraph">
<p><code>&amp;</code> 符号现在一直使用（并且没有反斜杠的帮助）来引用命名子例程/运算符的函数对象而不调用它，即使用名称作为“名词”而不是“动词”：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my $sub = \&amp;foo; # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sub = &amp;foo;  # Raku</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">callback =&gt; sub { say @_ }  # Perl 5 - can't pass built-in sub directly</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">callback =&gt; &amp;say            # Raku - &amp; gives "noun" form of any sub</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 Raku 在完成编译后不允许在词法范围内添加/删除符号，因此没有等效于 Perl 5 的 undef＆foo;，并且将定义与 Perl 5 定义的 ＆foo 最接近的符号::（'＆foo'） （使用“动态符号查找”语法）。 但是，您可以使用我的＆foo声明一个可变的命名子例程; 然后通过分配给＆foo在运行时更改其含义。</p>
</div>
<div class="paragraph">
<p>在 Perl 5 中，与普通子调用相比，＆符号可以另外用于以特殊方式调用子例程，具有略微不同的行为。 在 Raku 中，这些特殊形式不再可用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&amp;foo(&#8230;&#8203;) 用于规避函数原型</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 Raku 中没有原型，不管你是否传递一个文字代码块或一个包含代码对象的变量作为参数，它就不再有区别了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># Perl 5:
first_index { $_ &gt; 5 } @values;
&amp;first_index($coderef, @values); # (disabling the prototype that parses a
                                     # literal block as the first argument)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku:
first { $_ &gt; 5 }, @values, :k;   # the :k makes first return an index
first $coderef, @values, :k;</code></pre>
</div>
</div>
<div class="paragraph">
<p>＆FOO; 和goto＆foo; 重新使用调用者的参数列表/替换调用堆栈中的调用者。 Raku可以使用callame进行重新调度，也可以使用nextsame和nextx，它们在Perl 5中没有完全等效。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">sub foo { say "before"; &amp;bar;     say "after" } # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub foo { say "before"; bar(|@_); say "after" } # Raku - have to be explicit</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">sub foo { say "before"; goto &amp;bar } # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto foo (|) {*};
multi foo ( Any $n ) {
    say "Any"; say $n;
};
multi foo ( Int $n ) {
    say "Int"; callsame;
};
foo(3); # /language/functions#index-entry-dispatch_callsame</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_glob">3.4.5. * Glob</h4>
<div class="paragraph">
<p>在Perl 5中，<code>*</code> sigil引用了 Perl 用于存储非词法变量，文件句柄，子和格式的 GLOB 结构。</p>
</div>
<div class="paragraph">
<p>当文件句柄需要传递给子文件时，您最有可能在早期Perl版本上编写的代码中遇到 GLOB，该版本不支持词法文件句柄。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># Perl 5 - ancient method
sub read_2 {
    local (*H) = @_;
    return scalar(&lt;H&gt;), scalar(&lt;H&gt;);
}
open FILE, '&lt;', $path or die;
my ($line1, $line2) = read_2(*FILE);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在转换为 Raku 之前，您应该重构 Perl 5 代码以消除对 GLOB 的需求。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># Perl 5 - modern use of lexical filehandles
sub read_2 {
    my ($fh) = @_;
    return scalar(&lt;$fh&gt;), scalar(&lt;$fh&gt;);
}
open my $in_file, '&lt;', $path or die;
my ($line1, $line2) = read_2($in_file);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里只是一个可能的 Raku 翻译：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku
sub read-n($fh, $n) {
    return $fh.get xx $n;
}
my $in-file = open $path or die;
my ($line1, $line2) = read-n($in-file, 2);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_数组索引切片">3.5. 数组索引/切片</h3>
<div class="paragraph">
<p>数组上的索引和切片操作不再会影响变量的符号，副词可用于控制切片的类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>索引</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say $months[2]; # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @months[2]; # Raku - @ instead of $</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>值切片</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say join ',', @months[6, 8..11]; # Perl 5 and Raku</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>键/值切片</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say join ',', %months[6, 8..11];    # Perl 5
say join ',', @months[6, 8..11]:kv; # Raku - @ instead of %; use :kv adverb</code></pre>
</div>
</div>
<div class="paragraph">
<p>另请注意，下标方括号现在是一个普通的postcircumfix运算符，而不是一个特殊的句法形式，因此<a href="https://docs.raku.org/language/5to6-nutshell#exists">检查元素的存在</a>和<a href="https://docs.raku.org/language/5to6-nutshell#delete">未设置元素</a>是通过副词完成的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_散列索引切片">3.6. {} 散列索引/切片</h3>
<div class="paragraph">
<p>散列上的索引和切片操作不再影响变量的符号，副词可用于控制切片的类型。此外，单字下标不再在花括号内神奇地自动引用;相反，新的尖括号版本可用，它始终自动引用其内容（使用与 <code>qw</code> //引用构造相同的规则）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>索引</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say $calories{"apple"}; # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %calories{"apple"}; # Raku - % instead of $</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say $calories{apple};   # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %calories&lt;apple&gt;;   # Raku - angle brackets; % instead of $
say %calories«"$key"»;  # Raku - double angles interpolate as a list of Str</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>值切片</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say join ',', @calories{'pear', 'plum'}; # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say join ',', %calories{'pear', 'plum'}; # Raku - % instead of @
say join ',', %calories&lt;pear plum&gt;;      # Raku (prettier version)
my $keys = 'pear plum';
say join ',', %calories«$keys»;          # Raku the split is done after interpolation</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>键/值索引</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say join ',', %calories{'pear', 'plum'};    # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say join ',', %calories{'pear', 'plum'}:kv; # Raku - use :kv adverb
say join ',', %calories&lt;pear plum&gt;:kv;      # Raku (prettier version)</code></pre>
</div>
</div>
<div class="paragraph">
<p>还要注意，下标花括号现在是一个普通的 postcircumfix 操作符而不是一个特殊的语法形式，因此检查键的存在和删除键是用副词完成的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_创建引用并使用它们">3.7. 创建引用并使用它们</h3>
<div class="paragraph">
<p>在 Perl 5 中，在创建时返回对匿名数组和散列和 subs 的引用。 使用\运算符生成对现有命名变量和 subs 的引用。 “引用/解除引用”这个比喻并没有干净地映射到实际的 Raku 容器系统，所以我们必须关注引用运算符的意图而不是实际的语法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my $aref = \@aaa  ; # Perl 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如，这可能用于将引用传递给例程。但是在Raku中，传递了（单个）底层对象（你可以认为它是一种通过引用传递）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array = 4,8,15;
{ $_[0] = 66 }(@array);   # run the block with @array aliased to $_
say @array; #  OUTPUT: «[66 8 15]»</code></pre>
</div>
</div>
<div class="paragraph">
<p>传递 <code>@array</code> 的基础Array对象，并在声明的例程中修改其第一个值。</p>
</div>
<div class="paragraph">
<p>在 Perl 5 中，取消引用整个引用的语法是 type-sigil 和花括号，在花括号内引用。 在 Raku 中，这个概念根本不适用，因为参考隐喻并不真正适用。</p>
</div>
<div class="paragraph">
<p>在 Perl 5 中，箭头运算符 <code>&#8594;</code> 用于单个访问复合引用或通过引用调用 sub。 在 Raku 中，点运算符。 始终用于对象方法，但其余方法并不真正适用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># Perl 5
    say $arrayref-&gt;[7];
    say $hashref-&gt;{'fire bad'};
    say $subref-&gt;($foo, $bar);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在相对较新版本的 Perl 5（5.20及更高版本）中，新功能允许使用箭头运算符进行解除引用：请参阅 <a href="https://metacpan.org/pod/release/SHAY/perl-5.20.1/pod/perl5200delta.pod#Experimental_Postfix_Dereferencing">Postfix Dereferencing</a>。 这可以用于从标量创建数组。 此操作通常称为 decont，如在去包容化中，并且在Raku中使用诸如 <code>.list</code> 和 <code>.hash</code> 之类的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># Perl 5.20
    use experimental qw&lt; postderef &gt;;
    my @a = $arrayref-&gt;@*;
    my %h = $hashref-&gt;%*;
    my @slice = $arrayref-&gt;@[3..7];</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku
    my @a = $contains-an-array.list;        # or @($arrayref)
    my %h = $contains-a-hash.hash;          # or %($hashref)</code></pre>
</div>
</div>
<div class="paragraph">
<p>“Zen” 切片做同样的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku
    my @a = $contains-an-array[];
    my %h = $contains-a-hash{};</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关详细信息，请参阅<a href="https://docs.raku.org/language/containers">文档的“容器”部分</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_运算符">3.8. 运算符</h3>
<div class="paragraph">
<p>有关所有运算符的完整详细信息，请参阅<a href="https://docs.raku.org/language/operators">运算符文档</a>。</p>
</div>
<div class="paragraph">
<p>没发生变化的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>+</code> 数字加法</p>
</li>
<li>
<p><code>-</code> 数字减法</p>
</li>
<li>
<p><code>*</code> 数字乘法</p>
</li>
<li>
<p><code>/</code> 数字除法</p>
</li>
<li>
<p><code>%</code> 数字求模</p>
</li>
<li>
<p><code>**</code> 数字指数</p>
</li>
<li>
<p><code>++</code> 数字递增</p>
</li>
<li>
<p><code>--</code> 数字递减</p>
</li>
<li>
<p><code>! &amp;&amp; || ^</code> 布尔，高优先级</p>
</li>
<li>
<p><code>not and or xor</code> 布尔，低优先级</p>
</li>
<li>
<p><code>== != &lt; &gt; &#8656; &gt;=</code> 数字比较</p>
</li>
<li>
<p><code>eq ne lt gt le ge</code> 字符串比较</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_逗号_列表分割符">3.9. , (逗号) 列表分割符</h3>
<div class="paragraph">
<p>没有改变，但请注意，为了将数组变量展平为列表（为了追加或添加更多项目的前缀），应该使用|操作员（另见<a href="https://docs.raku.org/type/Slip">Slip</a>）。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @numbers = 100, 200, 300;
my @more_numbers = 500, 600, 700;
my @all_numbers = |@numbers, 400, |@more_numbers;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样就可以连接数组。</p>
</div>
<div class="paragraph">
<p>请注意，右侧不需要任何括号：List Separator 负责创建列表，而不是括号！</p>
</div>
<div class="sect3">
<h4 id="_cmp_三路比较">3.9.1. &lt;&#8658; cmp 三路比较</h4>
<div class="paragraph">
<p>在 Perl 5 中，这些运算符返回 -1, 0 或 1。在 Raku 中，它们返回 <code>Order::Less</code>，<code>Order::Same</code> 或 <code>Order::More</code>。</p>
</div>
<div class="paragraph">
<p><code>cmp</code> 现在命名为 <code>leg</code>; 它强制字符串上下文进行比较。</p>
</div>
<div class="paragraph">
<p><code>&lt;&#8658;</code> 仍然强制数字上下文。</p>
</div>
<div class="paragraph">
<p>Raku 中的 <code>cmp</code> 执行 <code>&lt;&#8658;</code> 或 <code>leg</code>，具体取决于其参数的现有类型。</p>
</div>
</div>
<div class="sect3">
<h4 id="_智能匹配运算符">3.9.2. ~~ 智能匹配运算符</h4>
<div class="paragraph">
<p>虽然运算符没有改变，但确切匹配的规则取决于两个参数的类型，并且这些规则在 Perl 5 和 Raku 中大不相同。请参阅 <a href="https://docs.raku.org/routine/<sub>~"></sub>~</a>和 <a href="https://docs.raku.org/language/operators#index-entry-smartmatch_operator">smartmatch 运算符</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_字符串位运算符">3.9.3. &amp; | ^ 字符串位运算符</h4>

</div>
<div class="sect3">
<h4 id="_数字位运算符">3.9.4. &amp; | ^ 数字位运算符</h4>

</div>
<div class="sect3">
<h4 id="_布尔运算符">3.9.5. &amp; | ^ 布尔运算符</h4>
<div class="paragraph">
<p>在 Perl 5 中，<code>&amp; | ^</code> 根据参数的内容调用。例如，<code>31 | 33</code> 返回与 <code>“31”|“33”</code> 不同的结果。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，这些单字符操作已被删除，并被两个字符的操作系统取代，这些操作将他们的参数强制转换为所需的上下文。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Infix ops (two arguments; one on each side of the op)
+&amp;  +|  +^  And Or Xor: Numeric
~&amp;  ~|  ~^  And Or Xor: String
?&amp;  ?|  ?^  And Or Xor: Boolean

# Prefix ops (one argument, after the op)
+^  Not: Numeric
~^  Not: String
?^  Not: Boolean (same as the ! op)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_数字左移右移运算符">3.9.6. &lt;&lt; &gt;&gt; 数字左移|右移运算符</h4>
<div class="paragraph">
<p>由 <code>+&lt;</code> 和 <code>+&gt;</code> 代替。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say 42 &lt;&lt; 3; # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 42 +&lt; 3; # Raku</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_胖逗号">3.9.7. &#8658; 胖逗号</h4>
<div class="paragraph">
<p>在 Perl 5 中，<code>&#8658;</code> 的行为就像一个逗号，但也引用了它的左侧。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，<code>&#8658;</code> 是 <a href="https://docs.raku.org/type/Pair">Pair</a> 运算符，原理上完全不同，但在许多情况下都是相同的。</p>
</div>
<div class="paragraph">
<p>如果您在哈希初始化中使用 <code>&#8658;</code>，或者将参数传递给期望 hashref 的 sub，则用法可能相同。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub get_the_loot { ... }; # Raku stub
# Works in Perl 5 and Raku
my %hash = ( AAA =&gt; 1, BBB =&gt; 2 );
get_the_loot( 'diamonds', { quiet_level =&gt; 'very', quantity =&gt; 9 }); # Note the curly braces</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你使用 <code>&#8658;</code> 作为一个方便的快捷方式，不必引用列表的一部分，或者将参数传递给一个需要 <code>KEY</code>，<code>VALUE</code>，<code>KEY</code>，<code>VALUE</code> 的平面列表的子，那么继续使用 <code>&#8658;</code> 可能会破坏你的代码。 最简单的解决方法是将该胖箭头更改为常规逗号，并手动将引号添加到其左侧。 或者，您可以更改 sub 的API以<a href="https://docs.raku.org/type/Signature#Slurpy_%28A.K.A._variadic%29_parameters">slurp哈希</a>。 一个更好的长期解决方案是将sub的API改为期望Pairs; 但是，这需要您一次更改所有 sub 调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># Perl 5
sub get_the_loot {
    my $loot = shift;
    my %options = @_;
    # ...
}
# Note: no curly braces in this sub call
get_the_loot( 'diamonds', quiet_level =&gt; 'very', quantity =&gt; 9 );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku, original API
sub get_the_loot( $loot, *%options ) { # The * means to slurp everything
    ...
}
get_the_loot( 'diamonds', quiet_level =&gt; 'very', quantity =&gt; 9 ); # Note: no curly braces in this API

# Raku, API changed to specify valid options
# The colon before the sigils means to expect a named variable,
# with the key having the same name as the variable.
sub get_the_loot( $loot, :$quiet_level?, :$quantity = 1 ) {
    # This version will check for unexpected arguments!
    ...
}
get_the_loot( 'diamonds', quietlevel =&gt; 'very' ); # Throws error for misspelled parameter name</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_三元运算符">3.9.8. ?  : 三元运算符</h4>
<div class="paragraph">
<p>条件运算符 <code>? :</code> 已经被替换成 `?? !! `。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my $result = $score &gt; 60 ?  'Pass' :  'Fail'; # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result = $score &gt; 60 ?? 'Pass' !! 'Fail'; # Raku</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_点号_字符串连接">3.9.9. .(点号) 字符串连接</h4>
<div class="paragraph">
<p>替换为波浪号。</p>
</div>
<div class="paragraph">
<p>助记：想到用针和线将两个字符串“拼接”在一起。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">$food = 'grape' . 'fruit'; # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$food = 'grape' ~ 'fruit'; # Raku</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_x_列表复制或字符串复制运算符">3.9.10. x 列表复制或字符串复制运算符</h4>
<div class="paragraph">
<p>在 Perl 5 中，x 是复制运算符，它在标量或列表上下文中的行为有所不同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在标量上下文中，<code>x</code> 重复一个字符串;</p>
</li>
<li>
<p>在列表上下文中 <code>x</code> 重复一个列表，但前提是左参数是括号！</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Raku 使用两个不同的复制运算符来实现上述目的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>x</code> 表示字符串重复（在任何上下文中）;</p>
</li>
<li>
<p><code>xx</code> 表示列表重复（在任何上下文中）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>助记符：<code>x</code> 很短，<code>xx</code> 很长，所以 <code>xx</code> 是用于列表的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># Perl 5
    print '-' x 80;             # Print row of dashes
    @ones = (1) x 80;           # A list of 80 1's
    @ones = (5) x @ones;        # Set all elements to 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku
    print '-' x 80;             # Unchanged
    @ones = 1 xx 80;            # Parentheses no longer needed
    @ones = 5 xx @ones;         # Parentheses no longer needed</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_两个点或三个点范围操作或_flipflop_运算符">3.9.11. .. &#8230;&#8203; 两个点或三个点，范围操作或 flipflop 运算符</h4>
<div class="paragraph">
<p>在 Perl 5 中，<code>..</code> 是两个完全不同的运算符之一，具体取决于上下文。</p>
</div>
<div class="paragraph">
<p>在列表上下文中，<code>..</code> 是熟悉的范围运算符。 Perl 5 代码的范围不应该要求翻译。</p>
</div>
<div class="paragraph">
<p>在标量上下文中，<code>..</code> 和 <code>&#8230;&#8203;</code> 是鲜为人知的 Flipflop 运算符。 它们已被 <code>ff</code> 和 <code>fff</code> 取代。</p>
</div>
</div>
<div class="sect3">
<h4 id="_字符串插值">3.9.12. 字符串插值</h4>
<div class="paragraph">
<p>在 Perl 5 中，<code>"${foo}s"</code> 从其旁边的常规文本中删除变量名。 在 Raku 中，只需将花括号扩展为包括sigil：<code>"{$foo}s"</code>。 事实上，这是插入表达式的一个非常简单的例子。</p>
</div>
</div>
<div class="sect3">
<h4 id="_复合语句">3.9.13. 复合语句</h4>
<div class="paragraph">
<p>这些语句包括条件和循环。</p>
</div>
<div class="sect4">
<h5 id="_条件语句">条件语句</h5>
<div class="sect5">
<h6 id="_if_elsif_else_unless">if elsif else unless</h6>
<div class="paragraph">
<p>大部分没有变化; 条件周围的括号现在是可选的，但如果使用，则不能立即跟随关键字，否则它将被视为函数调用。 将条件表达式绑定到变量也有一点不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">if (my $x = dostuff()) {...}  # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if dostuff() -&gt; $x {...}      # Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>（您仍然可以在 Raku 中使用我的表单，但它将扩展到外部块，而不是内部。）</p>
</div>
<div class="paragraph">
<p>除非条件仅允许 Raku 中的单个块;它不允许使用 elsif 或 else 子句。</p>
</div>
</div>
<div class="sect5">
<h6 id="_given_when">given-when</h6>
<div class="paragraph">
<p>给定时构造类似于 <code>if-elsif-else</code> 语句链或类似于例如 <code>switch-case</code> 构造。 C. 它具有一般结构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given EXPR {
    when EXPR { ... }
    when EXPR { ... }
    default { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在其最简单的形式中，构造如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given $value {                   # assigns $_
    when "a match" {             # if $_ ~~ "a match"
        # do-something();
    }
    when "another match" {       # elsif $_ ~~ "another match"
        # do-something-else();
    }
    default {                    # else
        # do-default-thing();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是很简单的，因为标量值在 <code>when</code> 语句中与 <code>$<em></code> 匹配，这是由给定的设置。更一般地说，匹配实际上是 <code>$</em></code> 上的智能匹配，这样可以使用更复杂的实体（如regexp）进行查找而不是标量值。</p>
</div>
<div class="paragraph">
<p>另请参阅上面的smartmatch op上的警告。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_循环">3.10. 循环</h3>
<div class="sect3">
<h4 id="_while_until">3.10.1. while until</h4>
<div class="paragraph">
<p>大部分没有变化;条件周围的括号现在是可选的，但如果使用，则不能立即跟随关键字，否则它将被视为函数调用。将条件表达式绑定到变量也有一点不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">while (my $x = dostuff()) {...}  # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">while dostuff() -&gt; $x {...}      # Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>（您仍然可以在 Raku 中使用我的表单，但它将扩展到外部块，而不是内部。）</p>
</div>
<div class="paragraph">
<p>请注意，从文件句柄逐行读取已更改。</p>
</div>
<div class="paragraph">
<p>在 Perl 5 中，它是使用菱形运算符在while循环中完成的。使用for而不是while是一个常见的错误，因为for会导致整个文件立即被吸入，从而淹没了程序的内存使用情况。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，<code>for</code> 语句是<strong>惰性</strong>的，所以我们使用 <code>.lines</code> 方法在 <code>for</code> 循环中逐行读取。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">while (&lt;IN_FH&gt;)  { } # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $IN_FH.lines { } # Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>另请注意，在 Raku 中，默认情况下会 chomp 行。</p>
</div>
</div>
<div class="sect3">
<h4 id="_do_whileuntil">3.10.2. do while/until</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># Perl 5
do {
    ...
} while $x &lt; 10;

do {
    ...
} until $x &gt;= 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该构造仍然存在，但是 <code>do</code> 被重命名为 <code>repeat</code>，以更好地表示构造的作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku
repeat {
    ...
} while $x &lt; 10;

repeat {
    ...
} until $x &gt;= 10;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_for_foreach">3.10.3. for foreach</h4>
<div class="paragraph">
<p>首先要注意关于 <code>for</code> 和 <code>foreach</code> 关键字的这种常见误解：许多程序员认为他们区分C风格的三表达形式和列表迭代器形式;他们不！事实上，关键词是可以互换的; Perl 5 编译器在括号中查找分号以确定要解析的循环类型。</p>
</div>
<div class="paragraph">
<p>C 风格的三因子形式现在使用 <code>loop</code> 关键字，否则保持不变。括号仍然是必需的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">for  ( my $i = 1; $i &lt;= 10; $i++ ) { ... } # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop ( my $i = 1; $i &lt;= 10; $i++ ) { ... } # Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>循环迭代器表单以Raku命名，foreach不再是关键字。 for循环具有以下规则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>括号是可选的;</p>
</li>
<li>
<p>迭代变量（如果有的话）已经从列表前面出现，再出现在列表和添加的箭头操作符之后;</p>
</li>
<li>
<p>迭代变量现在总是词法的：<code>my</code> 既不需要也不允许;</p>
</li>
<li>
<p>迭代变量是当前列表元素的只读别名（在 Perl 5 中它是一个读写别名！）。如果需要读写别名，请将迭代变量前面的 <code>&#8594;</code> 更改为 <code>&lt;&#8594;</code>。从 Perl 5 进行翻译时，检查循环变量的使用以确定是否需要读写。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">for my $car (@cars)  {...} # Perl 5; read-write</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @cars  -&gt; $car   {...} # Raku; read-only
for @cars &lt;-&gt; $car   {...} # Raku; read-write</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果正在使用默认主题 <code>$_</code>，那么它也是读写的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">for (@cars)      {...} # Perl 5; $_ is read-write</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @cars        {...} # Raku; $_ is read-write
for @cars &lt;-&gt; $_ {...} # Raku; $_ is also read-write</code></pre>
</div>
</div>
<div class="paragraph">
<p>在每次迭代中可以使用列表中多个元素，只需在箭头操作符后指定多个变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array = 1..10;
for @array -&gt; $first, $second {
    say "First is $first, second is $second";
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_each">3.10.4. each</h4>
<div class="paragraph">
<p>这是 Perl 5 的 <code>while…each(%hash) or while…each(@array)</code> 的等价物，（即迭代数据结构的键/索引和值）而 Raku 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">while (my ($i, $v) = each(@array)) { ... } # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @array.kv -&gt; $i, $v { ... } # Raku</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">while (my ($k, $v) = each(%hash)) { ... } # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for %hash.kv -&gt; $k, $v { ... } # Raku</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_控制流语句">3.10.5. 控制流语句</h4>
<div class="paragraph">
<p>没发生变化的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>next</p>
</li>
<li>
<p>last</p>
</li>
<li>
<p>redo</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_continue">continue</h5>
<div class="paragraph">
<p>不再有 <code>continue</code> 块了。而是在循环体内使用 <code>NEXT</code> 块（phaser）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># Perl 5
    my $str = '';
    for (1..5) {
        next if $_ % 2 == 1;
        $str .= $_;
    }
    continue {
        $str .= ':'
    }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku
    my $str = '';
    for 1..5 {
        next if $_ % 2 == 1;
        $str ~= $_;
        NEXT {
            $str ~= ':'
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，phasers 并不需要块。当您不想要另一个作用域时，这非常方便：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku
    my $str = '';
    for 1..5 {
        next if $_ % 2 == 1;
        $str ~= $_;
        NEXT $str ~= ':';
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_函数">3.11. 函数</h3>
<div class="sect3">
<h4 id="_带有裸块的内置函数">3.11.1. 带有裸块的内置函数</h4>
<div class="paragraph">
<p>之前接受裸块的内置函数，其后没有逗号，其余参数现在需要在块和参数之间使用逗号，例如 <code>map</code>，<code>grep</code> 等。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my @results = grep { $_ eq "bars" } @foo; # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @results = grep { $_ eq "bars" }, @foo; # Raku</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_delete">3.11.2. delete</h4>
<div class="paragraph">
<p>变成了 <a href="https://docs.raku.org/language/5to6-nutshell#%7B%7D_Hash_indexing%2Fslicing">{} 哈希下标</a>和<a href="https://docs.raku.org/language/5to6-nutshell#%5B%5D_Array_indexing%2Fslicing">[</a>数组下标]运算符的副词。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my $deleted_value = delete $hash{$key};  # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $deleted_value = %hash{$key}:delete;  # Raku - use :delete adverb</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my $deleted_value = delete $array[$i];  # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $deleted_value = @array[$i]:delete;  # Raku - use :delete adverb</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exists">3.11.3. exists</h4>
<div class="paragraph">
<p>变成了 <a href="https://docs.raku.org/language/5to6-nutshell#%7B%7D_Hash_indexing%2Fslicing">{} 哈希下标</a>和<a href="https://docs.raku.org/language/5to6-nutshell#%5B%5D_Array_indexing%2Fslicing">[</a>数组下标]运算符的副词。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say "element exists" if exists $hash{$key};  # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "element exists" if %hash{$key}:exists;  # Raku - use :exists adverb</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">say "element exists" if exists $array[$i];  # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "element exists" if @array[$i]:exists;  # Raku - use :exists adverb</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_正则表达式_regexregexp">3.12. 正则表达式 (regex/regexp)</h3>
<div class="sect3">
<h4 id="_和_变成了_和">3.12.1. =~ 和 !~ 变成了 ~~ 和 !~~</h4>
<div class="paragraph">
<p>在 Perl 5 中，使用 <code>=~</code> 正则表达式绑定运算符对变量进行匹配和替换。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，使用了 <code>~~</code> 智能匹配运算符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">next if $line  =~ /static/  ; # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">next if $line  ~~ /static/  ; # Raku</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">next if $line  !~ /dynamic/ ; # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">next if $line !~~ /dynamic/ ; # Raku</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">$line =~ s/abc/123/;          # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$line ~~ s/abc/123/;          # Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，可以使用新的 <code>.match</code> 和 <code>.subst</code> 方法。请注意，<a href="https://docs.raku.org/routine/subst">.subst是非可变的</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_捕获从_0_开始而非从_1_开始">3.12.2. 捕获从 0 开始而非从 1 开始</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">/(.+)/ and print $1; # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/(.+)/ and print $0; # Raku</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_移动修饰符">3.12.3. 移动修饰符</h4>
<div class="paragraph">
<p>将任何修饰符从正则表达式的末尾移动到开头。这可能需要您在 <code>/abc/</code> 这样的普通匹配上添加可选的 <code>m</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">next if $line =~    /static/i ; # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">next if $line ~~ m:i/static/  ; # Raku</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_添加_p5_或_perl5_副词">3.12.4. 添加 :P5 或 :Perl5 副词</h4>
<div class="paragraph">
<p>如果实际的正则表达式很复杂，您可能希望通过添加 <code>P5</code> 修饰符来原样使用它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">next if $line =~    m/[aeiou]/   ; # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">next if $line ~~ m:P5/[aeiou]/   ; # Raku, using P5 modifier
next if $line ~~ m/  &lt;[aeiou]&gt; / ; # Raku, native new syntax</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，Perl 5 正则表达式语法可以追溯到很多年前，可能缺少自 Raku 项目开始以来添加的功能。</p>
</div>
</div>
<div class="sect3">
<h4 id="_特殊匹配器通常属于_语法">3.12.5. 特殊匹配器通常属于 &lt;&gt; 语法</h4>
<div class="paragraph">
<p>Perl 5 正则表达式支持许多特殊匹配语法的情况。它们不会全部列在这里，但通常不是被 <code>()</code> 包围，断言将被 <code>&lt;&gt;</code> 包围着。</p>
</div>
<div class="paragraph">
<p>对于字符类，这意味着：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[abc]</code> 变成了 <code>&lt;[abc]&gt;</code></p>
</li>
<li>
<p><code>[^abc]</code> 变成了 <code>&#8592;[abc]&gt;</code></p>
</li>
<li>
<p><code>[a-zA-Z]</code> 变成了 <code>&lt;[a..zA..Z]&gt;</code></p>
</li>
<li>
<p><code><a id=":upper:"></a>`变成了 `&lt;:Upper&gt;</code></p>
</li>
<li>
<p><code>[abc[:upper:]]</code> 变成了 <code>&lt;[abc]+:Upper&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于环视断言：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>(?=[abc])</code> 变成了 <code>&lt;?[abc]&gt;</code></p>
</li>
<li>
<p><code>(?=ar?bitrary* pattern)</code> 变成了 <code>&lt;before ar?bitrary* pattern&gt;</code></p>
</li>
<li>
<p><code>(?!=[abc])</code> 变成了 <code>&lt;![abc]&gt;</code></p>
</li>
<li>
<p><code>(?!=ar?bitrary* pattern)</code> 变成了 <code>&lt;!before ar?bitrary* pattern&gt;</code></p>
</li>
<li>
<p><code>(?&#8656;ar?bitrary* pattern)</code> 变成了 <code>&lt;after ar?bitrary* pattern&gt;</code></p>
</li>
<li>
<p><code>(?&lt;!ar?bitrary* pattern)</code> 变成了 <code>&lt;!after ar?bitrary* pattern&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关更多信息，请参阅<a href="https://docs.raku.org/language/regexes#Lookahead_assertions_%3C%3Fbefore_pattern%3E">向前查看断言</a>。</p>
</div>
<div class="paragraph">
<p>（和 &lt;&gt; 语法无关, “环视” <code>/foo\Kbar/</code> 变成了 <code>/foo &lt;( bar )&gt; /</code>）</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>(?(?{condition))yes-pattern|no-pattern)</code> 变成了 <code>[ &lt;?{condition}&gt; yes-pattern | no-pattern ]</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_最长_token_匹配ltm_取代了备选分支">3.12.6. 最长 token 匹配(LTM) 取代了备选分支</h4>
<div class="paragraph">
<p>在 Raku 正则表达式中，<code>|</code> 遵循 LTM，它根据一组规则决定哪个备选分支赢得了一个模糊匹配，而不是先写出哪个。</p>
</div>
<div class="paragraph">
<p>解决这个问题最简单的方法就是在你的 Perl 5 正则表达式中把任何 <code>|</code> 更改为 <code>||</code>。</p>
</div>
<div class="paragraph">
<p>但是，如果正则表达式用 <code>||</code> 写的是继承或组成使用 <code>|</code> 的语法无论是设计还是拼写错误，结果可能无法按预期工作。因此，当匹配过程变得复杂时，您最终需要对两者都有所了解，尤其是 LTM 策略的工作原理。此外，`|  可能是语法重用的更好选择。</p>
</div>
</div>
<div class="sect3">
<h4 id="_命名捕获">3.12.7. 命名捕获</h4>
<div class="paragraph">
<p>这些工作方式略有不同;他们也只使用最新版本的 Perl 5。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">use v5.22;
"þor is mighty" =~ /is (?&lt;iswhat&gt;\w+)/n;
say $+{iswhat};</code></pre>
</div>
</div>
<div class="paragraph">
<p>非捕获组中的内容用于实现捕获后面的内容，直到组的末尾（the）。捕获转到带有捕获名称的键下的 <code>%+</code> 哈希。在 Raku 中，<a href="https://docs.raku.org/language/regexes#Capturing_groups">命名捕获以这种方式工作</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">"þor is mighty" ~~ /is \s+ $&lt;iswhat&gt;=(\w+)/;
say $&lt;iswhat&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在正则表达式中进行实际赋值;这与用于外部变量的语法相同。</p>
</div>
</div>
<div class="sect3">
<h4 id="_注释">3.12.8. 注释</h4>
<div class="paragraph">
<p>与 Perl 5 一样，注释在正则表达式中照常工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ word #`(match lexical "word") /</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_begin_unitcheck_check_init_和_end">3.13. BEGIN, UNITCHECK, CHECK, INIT 和 END</h3>
<div class="paragraph">
<p>除了 <code>UNITCHECK</code> 之外，所有这些特殊块也存在于 Raku 中。在 Raku 中，这些被称为 <a href="https://docs.raku.org/language/phasers">Phasers</a>。但是有一些差异！</p>
</div>
<div class="sect3">
<h4 id="_unitcheck_变为_check">3.13.1. UNITCHECK 变为 CHECK</h4>
<div class="paragraph">
<p>Raku 中目前没有直接等效的 <code>CHECK</code> 块。Raku 中的 <code>CHECK</code> phaser 与 Perl 5 中的 <code>UNITCHECK</code> 块具有相同的语义：只要它出现的编译单元完成解析，它就会运行。这被认为是比 Perl 5 中 <code>CHECK</code> 块的当前语义更加理智的语义。但出于兼容性原因，不可能在 Perl 5 中更改 <code>CHECK</code> 块的语义，因此在 5.10 中引入了 <code>UNITCHECK</code> 块。因此决定 Raku <code>CHECK</code> phaser 将遵循更健全的 Perl 5 <code>UNITCHECK</code> 语义。</p>
</div>
</div>
<div class="sect3">
<h4 id="_不再需要块">3.13.2. 不再需要块</h4>
<div class="paragraph">
<p>在 Perl 5 中，这些特殊块必须具有花括号，这意味着单独的范围。在 Raku 中，这不是必需的，允许这些特殊块与周围的词法范围共享它们的范围。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my $foo;             # Perl 5
BEGIN { $foo = 42 }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">BEGIN my $foo = 42;  # Raku</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_关于预编译改变了语义">3.13.3. 关于预编译改变了语义</h4>
<div class="paragraph">
<p>如果将其放在正在预编译的模块中，则这些步骤将仅在预编译期间执行，而不是在加载预编译模块时执行。 因此，当从 Perl 5 移植模块代码时，您可能需要更改 <code>BEGIN</code> 和 <code>CHECK</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_编译指令">3.14. 编译指令</h3>
<div class="sect3">
<h4 id="_strict">3.14.1. strict</h4>
<div class="paragraph">
<p>严格模式现在默认启用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_warnings">3.14.2. warnings</h4>
<div class="paragraph">
<p>警告现在默认开启。</p>
</div>
<div class="paragraph">
<p>目前 <code>no warnings</code> <a href="https://docs.raku.org/language/glossary#NYI">还未实现</a> ，但是把东西放在一个安静的 <code>{}</code> 中会让其沉默。</p>
</div>
</div>
<div class="sect3">
<h4 id="_autodie">3.14.3. autodie</h4>
<div class="paragraph">
<p>由 <code>autodie</code> 更改以在异常时抛出异常的函数现在通常默认返回 <code>Failures</code>。您可以毫无问题地测试失败的定义/真实性。如果以任何其他方式使用 <code>Failure</code>，则将抛出由 <code>Failure</code> 封装的 <code>Exception</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># Perl 5
open my $i_fh, '&lt;', $input_path;  # Fails silently on error
use autodie;
open my $o_fh, '&gt;', $output_path; # Throws exception on error</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku
my $i_fh = open $input_path,  :r; # Returns Failure on error
my $o_fh = open $output_path, :w; # Returns Failure on error</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为您可以毫无问题地检查真实性，所以您可以在 <code>if</code> 语句中使用 <code>open</code> 的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku
if open($input_path,:r) -&gt; $handle {
    .say for $handle.lines;
}
else {
    # gracefully handle the fact that the open() failed
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_base_parent">3.14.4. base, parent</h4>
<div class="paragraph">
<p>在类声明中，<code>is</code> 关键字在 Raku 中替换了 <code>use base</code> 和 <code>use parent</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># Perl 5
package Cat;
use base qw(Animal);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku
class Cat is Animal {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，必须在编译时知道 <code>Animal</code> 类才能继承它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_bigint_bignum_bigrat">3.14.5. bigint bignum bigrat</h4>
<div class="paragraph">
<p>不再相关。</p>
</div>
<div class="paragraph">
<p><code>Int</code> 现在是任意精度，因为 <code>Rat</code> 的分子（分母限制为 <code>2**64</code>，之后它将自动升级到 <code>Num</code> 以保持性能）。如果你想要一个具有任意精度分母的 <code>Rat</code>，可以使用 <code>FatRat</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_constant">3.14.6. constant</h4>
<div class="paragraph">
<p>在 Raku 中，<code>constant</code> 是变量的声明符，就像 <code>my</code> 一样，除了变量永久锁定到其初始化表达式的结果（在编译时计算）。</p>
</div>
<div class="paragraph">
<p>所以，将 <code>&#8658;</code> 更改为 <code>=</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">use constant DEBUG =&gt; 0; # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant DEBUG = 0;      # Raku</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">use constant pi =&gt; 4 * atan2(1, 1); # Perl 5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">tau, pi, e, i; # built-in constants in Raku
τ, π, 𝑒        # and their unicode equivalents</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_编码">3.14.7. 编码</h4>
<div class="paragraph">
<p>允许您以非 ascii 或非 utf8 编写脚本。 Raku 目前仅使用 utf8 作为其脚本。</p>
</div>
</div>
<div class="sect3">
<h4 id="_整数">3.14.8. 整数</h4>
<div class="paragraph">
<p>Perl pragma 使用整数运算而不是浮点运算。在 Raku 中没有这样的等价物。如果你在计算中使用原生整数，那么这将是最接近的事情。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my int $foo = 42;
my int $bar = 666;
say $foo * $bar;    # uses native integer multiplication</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_lib">3.14.9. lib</h4>
<div class="paragraph">
<p>处理在编译时查找模块的位置。底层逻辑与 Perl 5 <strong>非常</strong>不同，但在使用等效语法的情况下，在 Raku 中 <code>use lib</code> 与 Perl 5 中的相同。</p>
</div>
</div>
<div class="sect3">
<h4 id="_mro">3.14.10. mro</h4>
<div class="paragraph">
<p>不再相关。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，方法调用现在始终使用 C3 方法解析顺序。如果需要查找给定类的父类，可以这样调用 <code>mro</code> 元方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Animal.^mro;    # .^ indicates calling a meta-method on the object</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_uft8">3.14.11. uft8</h4>
<div class="paragraph">
<p>不再相关：在 Raku 中，源代码应该采用 utf8 编码。</p>
</div>
</div>
<div class="sect3">
<h4 id="_vars">3.14.12. vars</h4>
<div class="paragraph">
<p>在 Perl 5 中不鼓励使用。 参阅 <a href="https://perldoc.perl.org/vars.html">https://perldoc.perl.org/vars.html</a>。</p>
</div>
<div class="paragraph">
<p>在转换为 Raku 之前，您应该重构 Perl 5 代码以消除 <code>use vars</code> 的需要。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_命令行标记">3.15. 命令行标记</h3>
<div class="paragraph">
<p>请参阅 <a href="https://github.com/rakudo/rakudo/wiki/Running-rakudo-from-the-command-line">Rakudo 使用的命令行标记</a></p>
</div>
<div class="paragraph">
<p>不变的：</p>
</div>
<div class="paragraph">
<p>-c -e -h -I -n -p -v -V</p>
</div>
<div class="ulist">
<ul>
<li>
<p>-a</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>更改您的代码以手动使用 <code>.split</code>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>-F</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>更改您的代码以手动使用 <code>.split</code>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>-l</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在这是默认行为。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>-M -m</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>只有 <code>-M</code> 仍然存在。而且，由于您不能再使用“no Module”语法，因此不再使用带有 <code>-</code> 的 <code>-M</code> 来 “no” 模块。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>-E</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于已启用所有功能，因此只需使用小写 <code>-e</code>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>-d, -dt, -d:foo, -D, etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>替换为 <code>++BUG</code> metasyntactic 选项。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>-s</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>切换解析现在由 MAIN 子例程的参数列表完成。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># Perl 5
    #!/usr/bin/perl -s
    if ($xyz) { print "$xyz\n" }
./example.pl -xyz=5
5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku
    sub MAIN( Int :$xyz ) {
        say $xyz if $xyz.defined;
    }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku example.p6 --xyz=5
5
raku example.p6 -xyz=5
5</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>it</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>被移除了</p>
</div>
<div class="ulist">
<ul>
<li>
<p>-P -u -U -W -X</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>被移除了，参阅 <a href="https://design.raku.org/S19.html#Removed_Syntactic_Features">S19#Removed Syntactic Features.</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>-w</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在是默认行为。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>-s, -T</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这已被淘汰。 <a href="https://www.reddit.com/r/raku/comments/718z4o/taint_mode_for_perl_6/">Reddit 讨论了几种复制“污点”模式的方法</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_文件相关的运算符">3.16. 文件相关的运算符</h3>
<div class="sect3">
<h4 id="_将文本文件的行读入数组">3.16.1. 将文本文件的行读入数组</h4>
<div class="paragraph">
<p>在 Perl 5 中，读取文本文件行的常用习惯用法如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">open my $fh, "&lt;", "file" or die "$!";
my @lines = &lt;$fh&gt;;                # lines are NOT chomped
close $fh;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中，这已经简化为</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @lines = "file".IO.lines;  # auto-chomped</code></pre>
</div>
</div>
<div class="paragraph">
<p>不要试图尝试在文件中进行 slurping 并将结果字符串拆分为换行符，因为这会给出一个带有尾随空元素的数组，这比你预期的要多一些（它也更复杂），例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># initialize the file to read
spurt "test-file", q:to/END/;
first line
second line
third line
END
# read the file
my @lines = "test-file".IO.slurp.split(/\n/);
say @lines.elems;    #-&gt; 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果由于某种原因你想要首先 slurp 文件，那么你可以在 <code>slurp</code> 的结果上调用 <code>lines</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @lines = "test-file".IO.slurp.lines;  # also auto-chomps</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，请注意 <code>$!</code> 与 Raku 中的文件操作失败无关。一个 IO 操作无法返回失败而不是抛出异常。 如果要返回失败消息，则它本身就是失败，而不是 <code>$!</code>. 要做同样的事情，我需要检查并报告 Perl 5：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my $fh = open('./bad/path/to/file', :w) or die $fh;</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意：<code>$fh</code> 而不是 <code>$!</code>. 现在，您可以将 <code>$<em></code> 设置为失败并使用 <code>$</em></code> 来消亡：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open('./bad/path/to/file', :w) orelse .die;</code></pre>
</div>
</div>
<div class="paragraph">
<p>尝试使用失败的任何操作都将导致程序出错并终止。即使只是调用 <code>.self</code> 方法也足够了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open('./bad/path/to/file', :w).self;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_捕获可执行文件的标准输出">3.16.2. 捕获可执行文件的标准输出。</h4>
<div class="paragraph">
<p>而在 Perl 5 中，你会这样做</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my $arg = 'Hello';
my $captured = `echo \Q$arg\E`;
my $captured = qx(echo \Q$arg\E);</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者使用 <code>String::ShellQuote</code>（因为 <code>\Q&#8230;&#8203;\E</code> 不完全正确）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">my $arg = shell_quote 'Hello';
my $captured = `echo $arg`;
my $captured = qx(echo $arg);</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中，您可能希望在不使用 shell 的情况下运行命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $arg = 'Hello';
my $captured = run('echo', $arg, :out).out.slurp;
my $captured = run(«echo "$arg"», :out).out.slurp;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你真的想要，你也可以使用 shell：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $arg = 'Hello';
my $captured = shell("echo $arg", :out).out.slurp;
my $captured = qqx{echo $arg};</code></pre>
</div>
</div>
<div class="paragraph">
<p>但请注意，在这种情况下根本没有保护！ <code>run</code> 不使用 shell，因此不需要转义参数（参数直接传递）。如果你使用 shell 或 <code>qqx</code>，那么一切都会变成一个长字符串，然后传递给 shell。除非您非常仔细地验证您的参数，否则很有可能使用此类代码引入 shell 注入漏洞。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_环境变量">3.17. 环境变量</h3>
<div class="sect3">
<h4 id="_perl_模块库路径">3.17.1. Perl 模块库路径</h4>
<div class="paragraph">
<p>在 Perl 5 中，为 Perl 模块指定额外搜索路径的环境变量之一是 <code>PERL5LIB</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ PERL5LIB="/some/module/lib" perl program.pl</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中，这是类似的，只需要改变一个数字！您可能已经猜到了，您只需要使用 <code>PERL6LIB</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ PERL6LIB="/some/module/lib" raku program.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Perl 5 中，使用 ':'（冒号）作为 <code>PERL5LIB</code> 的目录分隔符，但在 Raku 中使用 ','（逗号）。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ export PERL5LIB=/module/dir1:/module/dir2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ export PERL6LIB=/module/dir1,/module/dir2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>（Raku 无法识别 <code>PERL5LIB</code> 或旧的 Perl 环境变量 <code>PERLLIB</code>。）</p>
</div>
<div class="paragraph">
<p>与 Perl 5 一样，如果未指定 <code>PERL6LIB</code>，则需要通过 <code>use lib</code> pragma 指定程序中的库路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use lib '/some/module/lib'</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>PERL6LIB</code> 在 Raku 中更具开发人员便利性（与 Perl5 中 <code>PERL5LIB</code> 的等效用法相反），模块消费者不应使用它，因为将来可能会将其删除。这是因为 Raku 的模块加载与操作系统路径不直接兼容。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_misc">3.18. Misc</h3>
<div class="sect3">
<h4 id="_0_为真">3.18.1. '0' 为真</h4>
<div class="paragraph">
<p>与 Perl 5 不同，只包含零（'0'）的字符串为 <code>True</code>。由于 Raku 具有核心类型，因此更有意义。这也意味着常见的模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">... if defined $x and length $x; # or just length() in modern perls</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中变的简单</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">... if $x;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dump">3.18.2. dump</h4>
<div class="paragraph">
<p>不见了。</p>
</div>
<div class="paragraph">
<p>Raku 设计允许自动透明地保存和加载编译的字节码。</p>
</div>
<div class="paragraph">
<p>到目前为止，Rakudo 仅支持模块。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_autoload">3.19. AUTOLOAD</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/typesystem#index-entry-FALLBACK_%28method%29">FALLBACK</a> 方法提供类似的功能。</p>
</div>
<div class="sect3">
<h4 id="_从模块导入特定函数">3.19.1. 从模块导入特定函数</h4>
<div class="paragraph">
<p>在 Perl 5 中，可以选择性地从给定模块导入函数，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">use ModuleName qw{foo bar baz};</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中，通过使用相关子节点上的 <code>is export</code> 角色来指定要导出的函数;然后导出具有此角色的所有 <strong>subs</strong>。因此，以下模块 <code>Bar</code> 导出 subs <code>foo</code> 和 <code>bar</code> 但不导出 <code>baz</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module Bar;

sub foo($a) is export { say "foo $a" }
sub bar($b) is export { say "bar $b" }
sub baz($z) { say "baz $z" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用此模块，只需 <code>use Bar</code>，即可使用 <code>foo</code> 和 <code>bar</code> 函数</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Bar;
foo(1);    #=&gt; "foo 1"
bar(2);    #=&gt; "bar 2"</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果尝试使用 <code>baz</code>，则会在编译时引发“未声明的例程”错误。</p>
</div>
<div class="paragraph">
<p>那么，如何重新创建能够有选择地导入函数的 Perl 5 行为呢？通过在模块内定义一个 <code>EXPORT</code> sub，它指定要导出的函数并删除 <code>module Bar</code> 语句。</p>
</div>
<div class="paragraph">
<p>以前的模块 <code>Bar</code> 现在只是一个名为 <code>Bar.pm6</code> 的文件，其中包含以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub EXPORT(*@import-list) {
    my %exportable-subs =
        '&amp;foo' =&gt; &amp;foo,
        '&amp;bar' =&gt; &amp;bar,
        ;
    my %subs-to-export;
    for @import-list -&gt; $import {
        if grep $sub-name, %exportable-subs.keys {
            %subs-to-export{$sub-name} = %exportable-subs{$sub-name};
        }
    }
    return %subs-to-export;
}

sub foo($a, $b, $c) { say "foo, $a, $b, $c" }
sub bar($a) { say "bar, $a" }
sub baz($z) { say "baz, $z" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，不再通过 <code>is export</code> 角色显式地导出 subs，而是通过 <code>EXPORT</code> sub 指定我们想要导出的模块中的 subs，然后我们填充一个包含实际将被导出的 subs 的哈希。 <code>@import-list</code> 由调用代码中的 <code>use</code> 语句设置，因此允许我们有选择地导入模块可用的 subs。</p>
</div>
<div class="paragraph">
<p>因此，要仅导入 <code>foo</code> 例程，我们在调用代码中执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Bar &lt;foo&gt;;
foo(1);       #=&gt; "foo 1"</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里我们看到即使 <code>bar</code> 是可导出的，如果我们没有明确地导入它，它也无法使用。因此，这会在编译时导致“未声明的例程”错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Bar &lt;foo&gt;;
foo(1);
bar(5);       #!&gt; "Undeclared routine: bar used at line 3"</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这将有效</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Bar &lt;foo bar&gt;;
foo(1);       #=&gt; "foo 1"
bar(5);       #=&gt; "bar 5"</code></pre>
</div>
</div>
<div class="paragraph">
<p>另请注意，即使在 <code>use</code> 语句中指定，<code>baz</code> 仍然不可导致：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Bar &lt;foo bar baz&gt;;
baz(3);       #!&gt; "Undeclared routine: baz used at line 2"</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了使这个工作，显然必须跳过许多箍。在标准用例中，通过 <code>is export</code> 角色指定要导出的函数，Raku 会以正确的方式为您自动创建 <code>EXPORT</code> sub，因此应该非常仔细地考虑是否值得编写自己的 <code>EXPORT</code> 例程。</p>
</div>
</div>
<div class="sect3">
<h4 id="_从模块导入特定函数组">3.19.2. 从模块导入特定函数组</h4>
<div class="paragraph">
<p>如果要从模块中导出函数组，只需要为组分配名称，其余的将自动运行。如果在 sub 声明中指定 <code>is  export</code>，则实际上是将此子例程添加到 <code>:DEFAULT</code> 导出组。但是您可以将子例程添加到另一个组或多个组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module Bar;
sub foo() is export { }                   # added by default to :DEFAULT
sub bar() is export(:FNORBL) { }          # added to the FNORBL export group
sub baz() is export(:DEFAULT:FNORBL) { }  # added to both</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以现在你可以像这样使用 <code>Bar</code> 模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Bar;                     # imports foo / baz
use Bar :FNORBL;             # imports bar / baz
use Bar :ALL;                # imports foo / bar / baz</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意 <code>:ALL</code> 是一个自动生成的组，它包含具有 <code>is export</code> trait 的所有子例程。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_核心模块">3.20. 核心模块</h3>
<div class="sect3">
<h4 id="_datadumper">3.20.1. Data::Dumper</h4>
<div class="paragraph">
<p>在 Perl 5 中，<a href="https://metacpan.org/pod/Data::Dumper">Data::Dumper</a> 模块用于序列化，以及程序员调试程序数据结构的视图。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，这些任务是使用 <code>.perl</code> 方法完成的，每个对象都有 <code>.perl</code> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># Given:
    my @array_of_hashes = (
        { NAME =&gt; 'apple',   type =&gt; 'fruit' },
        { NAME =&gt; 'cabbage', type =&gt; 'no, please no' },
    );
# Perl 5
    use Data::Dumper;
    $Data::Dumper::Useqq = 1;
    print Dumper \@array_of_hashes; # Note the backslash.</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku
say @array_of_hashes.perl; # .perl on the array, not on its reference.</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Perl 5 中，Data::Dumper 具有更复杂的可选调用约定，允许命名 VAR。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，在变量的 sigil 前面放置一个冒号，将其转换为一个 Pair，其中包含 var 名称的键和 var 值的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Given:
    my ( $foo, $bar ) = ( 42, 44 );
    my @baz = ( 16, 32, 64, 'Hike!' );
# Perl 5
    use Data::Dumper;
    print Data::Dumper-&gt;Dump(
        [     $foo, $bar, \@baz   ],
        [ qw(  foo   bar   *baz ) ],
    );
# Output
#    $foo = 42;
#    $bar = 44;
#    @baz = (
#             16,
#             32,
#             64,
#             'Hike!'
#           );</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku
say [ :$foo, :$bar, :@baz ].perl;
# OUTPUT: «["foo" =&gt; 42, "bar" =&gt; 44, "baz" =&gt; [16, 32, 64, "Hike!"]]»</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于开发人员来说，还有一个特定于 Rakudo 的调试辅助工具，称为 <code>dd</code>（Tiny Data Dumper，它很小，它失去了“t”）。这将打印 STDERR 上给定变量的 <code>.perl</code> 表示和一些可以反省的额外信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku
dd $foo, $bar, @baz;
# OUTPUT: «Int $foo = 42
# Int $bar = 44
# Array @baz = [16, 32, 64, "Hike!"]
# »</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_getoptlong">3.20.2. Getopt::Long</h4>
<div class="paragraph">
<p>切换解析现在由 <code>MAIN</code> 子例程的参数列表完成。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl"># Perl 5
    use 5.010;
    use Getopt::Long;
    GetOptions(
        'length=i' =&gt; \( my $length = 24       ), # numeric
        'file=s'   =&gt; \( my $data = 'file.dat' ), # string
        'verbose'  =&gt; \( my $verbose           ), # flag
    ) or die;
    say $length;
    say $data;
    say 'Verbosity ', ($verbose ? 'on' : 'off') if defined $verbose;
perl example.pl
    24
    file.dat
perl example.pl --file=foo --length=42 --verbose
    42
    foo
    Verbosity on

perl example.pl --length=abc
    Value "abc" invalid for option length (number expected)
    Died at c.pl line 3.</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku
    sub MAIN( Int :$length = 24, :file($data) = 'file.dat', Bool :$verbose ) {
        say $length if $length.defined;
        say $data   if $data.defined;
        say 'Verbosity ', ($verbose ?? 'on' !! 'off');
    }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">raku example.p6
    24
    file.dat
    Verbosity off
raku example.p6 --file=foo --length=42 --verbose
    42
    foo
    Verbosity on
raku example.p6 --length=abc
    Usage:
      c.p6 [--length=&lt;Int&gt;] [--file=&lt;Any&gt;] [--verbose]</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，Raku 会在命令行解析时自动生成错误的完整用法消息。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_自动翻译">3.21. 自动翻译</h3>
<div class="paragraph">
<p>查找 Raku 版本的 Perl 5 构造的快速方法是通过自动翻译器运行它。</p>
</div>
<div class="paragraph">
<p>注意：这些翻译人员尚未完成。</p>
</div>
<div class="sect3">
<h4 id="_蓝虎">3.21.1. 蓝虎</h4>
<div class="paragraph">
<p>该项目致力于 Perl 代码的自动化现代化。它（还）没有 Web 前端，因此必须在本地安装才有用。它还包含一个单独的程序，用于将 Perl 5 正则表达式转换为 Raku。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/Util/Blue_Tiger/">https://github.com/Util/Blue_Tiger/</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_perlito">3.21.2. Perlito</h4>
<div class="paragraph">
<p>在线翻译！</p>
</div>
<div class="paragraph">
<p>该项目是一套 Perl 交叉编译器，包括 Perl 5 到 6 的转换。它有一个 Web 前端，因此无需安装即可使用。到目前为止，它仅支持 Perl 5 语法的子集。</p>
</div>
<div class="paragraph">
<p><a href="https://fglock.github.io/Perlito/perlito/perlito5.html">https://fglock.github.io/Perlito/perlito/perlito5.html</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_perl_toraku">3.21.3. Perl-ToRaku</h4>
<div class="paragraph">
<p>Jeff Goff 为 Perl 5 设计的 <a href="https://metacpan.org/release/JGOFF/Perl-ToRaku-0.03">Perl::ToRaku</a> 模块是围绕 Perl::Critic 的框架设计的。它旨在将 Perl5 转换为可编译（如果不一定运行）的 Raku 代码，只需进行最少的更改。代码转换器是可配置和可插拔的，因此您可以创建和贡献自己的转换，并根据自己的需要定制现有的转换。您可以从 CPAN 安装最新版本，也可以在 GitHub 上实时关注项目。在线转换器可能在某些时候可用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_其他翻译知识来源">3.21.4. 其他翻译知识来源</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://perlgeek.de/en/article/5-to-6">https://perlgeek.de/en/article/5-to-6</a></p>
</li>
<li>
<p><a href="https://github.com/Util/Blue_Tiger/">https://github.com/Util/Blue_Tiger/</a></p>
</li>
<li>
<p><a href="https://rakuadvent.wordpress.com/2011/12/23/day-23-idiomatic-perl-6/">https://rakuadvent.wordpress.com/2011/12/23/day-23-idiomatic-perl-6/</a></p>
</li>
<li>
<p><a href="https://docs.raku.org/language/5to6-overview">https://docs.raku.org/language/5to6-overview</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_perl_5_到_raku_的指南_概览">4. Perl 5 到 Raku 的指南 - 概览</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这些文档不应该被误认为是初学者教程或 Raku 的宣传概述; 它旨在作为具有很强 Perl 5 背景的人学习 Raku 的技术参考，以及任何将 Perl 5 代码移植到 Raku 的人。</p>
</div>
<div class="sect2">
<h3 id="_果壳中的_raku">4.1. 果壳中的 Raku</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/5to6-nutshell">果壳中的 Raku</a>提供了语法，运算符，复合语句，正则表达式，命令行标志以及各种其他零碎内容的快速概述。</p>
</div>
</div>
<div class="sect2">
<h3 id="_句法差异">4.2. 句法差异</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/5to6-perlsyn">语法章节</a>提供的 Perl 5 和 Raku 之间的语法区别的一个概述：它是如何保持大部分形式自由的，写注释的其他方法，以及 <code>switch</code> 如何是一个很 Raku 的东西。</p>
</div>
</div>
<div class="sect2">
<h3 id="_raku_中的运算符">4.3. Raku 中的运算符</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/5to6-perlop">运算符章节</a>将引导您从<a href="https://metacpan.org/pod/distribution/perl/pod/perlop.pod">Perl 5 的 perlop</a>运算符在Raku 中的等价物。</p>
</div>
</div>
<div class="sect2">
<h3 id="_raku_中的函数">4.4. Raku 中的函数</h3>
<div class="paragraph">
<p>该<a href="https://docs.raku.org/language/5to6-perlfunc">函数章节</a>描述了所有的 Perl 5 函数和它们的 Raku 等价物和任何行为差异。它还提供了对提供 Perl 5 函数行为的生态系统模块的引用，这些函数存在于 Raku 中，具有稍微不同的语义（例如 <code>shift</code>），或者在 Raku 中不存在（例如 <code>tie</code>）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_raku_中的特殊变量">4.5. Raku 中的特殊变量</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/5to6-perlvar">特殊变量章节</a>描述很多 Perl 5 中的特殊（标点符号）变量是否以及如何在 Raku 中的支持。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_perl_5_到_raku_的指南_函数">5. Perl 5 到 Raku 的指南 - 函数</h2>
<div class="sectionbody">
<div class="paragraph">
<p>由于太长, 请参阅原文。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_perl_5_到_raku_的指南_运算符">6. Perl 5 到 Raku 的指南 - 运算符</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_描述">6.1. 描述</h3>
<div class="paragraph">
<p>一个（希望）全面的 Perl 5 运算符列表及其 Raku 等价物，并在必要时记录它们之间的差异。</p>
</div>
</div>
<div class="sect2">
<h3 id="_注意">6.2. 注意</h3>
<div class="paragraph">
<p>本文档*没有*详细解释运算符。本文档旨在指导您从 Perl 5 <code>perlop</code> 文档中的操作符过渡到 Raku 中的等效文档。有关 Raku 等效文档的完整文档，请参阅<a href="https://docs.raku.org/language/operators">Raku文档</a>。</p>
</div>
<div class="sect3">
<h4 id="_运算符优先级和关联性">6.2.1. 运算符优先级和关联性</h4>
<div class="paragraph">
<p>运算符优先级表在 Raku 中与在 Perl 5 中有所不同，因此这里不再详述。如果您需要知道 Raku 中给定运算符的优先级和关联性，请参阅<a href="https://docs.raku.org/language/operators#Operator_precedence">运算符优先级</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_项和列表运算符">6.2.2. 项和列表运算符</h4>
<div class="paragraph">
<p>Perl 5 <code>perlop</code> 文档中列出的作为一元运算符和列表运算符的内容在这个章节里往往可以被视为函数，例如 <code>print</code> 和 <code>chdir</code>。因此，您可以在<a href="https://docs.raku.org/language/5to6-perlfunc">函数</a>指南中找到有关它们的信息。括号仍用于分组。有一点需要注意：在 Raku 中，是`,`（逗号）创建列表<strong>而不是</strong>圆括号。所以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @foo = 1,2,3,4,5;   # no parentheses needed
.say for 1,2,3,4,5;    # also no parentheses

my $scalar = (1);      # *not* a list, as there is no comma
my $list   = (1,);     # a List in a scalar container</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_箭头运算符">6.2.3. 箭头运算符</h4>
<div class="paragraph">
<p>由于您通常不会在 Raku 中使用引用，因此箭头作为解除引用运算符可能不太有用。但是，如果您确实需要解引用某些内容，则箭头就是点号。它也是方法调用的中的点号。因此，Perl 5 中的 <code>$arrayref&#8594;<a href="https://docs.raku.org/language/terms#Pair">7</a> ` 在 Raku 中变成 `$arrayref.[7]</code>，类似地, <code>$user&#8594;name</code> 变成了 <code>$user.name</code>。<code>&#8658;</code> 箭头用于构建 Pair 对，参考[Pair 术语文档]。</p>
</div>
</div>
<div class="sect3">
<h4 id="_自动递增和自动递减">6.2.4. 自动递增和自动递减</h4>
<div class="paragraph">
<p>和 Perl 5 中工作的一样。一个可能的警告是对于 <code>` 它们调用 `succ` 方法, 对于 `--` 他们调用 `pred` 方法。对于内置数字类型，这是不太可能做一些不寻常的，但自定义类型可以定义自己的 `succ` 和 `pred` 方法，所以在这种情况下，你应该注意的是什么是 `</code> 和 <code>--</code> *真正*能做的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_指数">6.2.5. 指数</h4>
<div class="paragraph">
<p>像你期望的那样工作。在 Perl 5 的 perlop 中关于 <code><strong></code> 绑定比一元减号更紧密的警告（即 <code>-2 </strong> 4</code> 被计算为 <code>-(2 <strong> 4)</code> 而不是 <code>(-2) </strong> 4</code>）也适用于 Raku。</p>
</div>
</div>
<div class="sect3">
<h4 id="_符号一元运算符">6.2.6. 符号一元运算符</h4>
<div class="paragraph">
<p>如在 Perl 5 中那样，一元 <code>!</code> 和 <code>-</code> 进行逻辑和算术否定。<code>?^</code> 用于按位逻辑否定，文档指出这相当于 <code>!</code>。值得注意的是，这些分别强制他们的参数 为 <code>Bool</code> 和 <code>Numeric</code> 类型。</p>
</div>
<div class="paragraph">
<p>一元 <code>~</code> 是 Raku 中的字符串上下文运算符，因此使用前缀 <code>+^</code> 进行逐位整数否定。假设两个补码。</p>
</div>
<div class="paragraph">
<p><code>+</code> *确实*在 Raku 中产生作用，强转其参数为数值类型。</p>
</div>
<div class="paragraph">
<p>一元 <code>\</code> 没有了。如果你真的想要对现有的命名变量进行“引用”，你可以使用项上下文，如下所示：<code>$aref = item(@array)</code> 或者可以通过更熟悉的前缀 <code>$</code>： <code>$aref = $@array</code>。请注意，您并没有真正获得引用，而是一个带有引用对象的标量容器。</p>
</div>
<div class="paragraph">
<p>您可以使用 <code>&amp;</code> sigil 获取命名子例程的“引用” ：<code>$sref = &amp;foo</code>。匿名数组，散列和 sub 创建过程中<strong>立即</strong>返回底层对象：<code>$sref = sub { }</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_绑定运算符">6.2.7. 绑定运算符</h4>
<div class="paragraph">
<p><code>=~</code> 和 <code>!~</code> 分别被 <code>~~</code> 和 <code>!~~</code> 取代。那些认为 Perl 5 中的智能匹配坏掉的人会很高兴听到它在 Raku 中运行得更好，因为更强的坚定意味着更少的猜测。有关<a href="https://docs.raku.org/language/operators#index-entry-smartmatch_operator">smartmatch</a>在 Raku 中的工作原理的更详细说明，请参阅<a href="https://docs.raku.org/language/operators#index-entry-smartmatch_operator">smartmatch 文档</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_乘法运算符">6.2.8. 乘法运算符</h4>
<div class="paragraph">
<p>二元 <code>*</code>，<code>/</code> 和 <code>%</code> 分别执行乘法，除法和取模运算，和 Perl 5 中一样。</p>
</div>
<div class="paragraph">
<p>二元 <code>x</code> 运算符在 Raku 中略有不同，并且他有一个同伴儿。<code>print '-' x 80;</code> 给你一个 80 个破折号的字符串，但是对于 <code>@ones = (1) x 80;</code> 给你一个 80 个 “1” 的列表的 Perl 5行为，你会使用 <code>@ones = 1 xx 80;</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_加法运算符">6.2.9. 加法运算符</h4>
<div class="paragraph">
<p>二元 <code>+</code> 和 <code>-</code> 分别进行加法和减法运算，如您所料。</p>
</div>
<div class="paragraph">
<p>由于 <code>.</code> 是方法调用运算符，所以二元 <code>~</code> 在 Raku 中充当字符串连接运算符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_shift_operators">6.2.10. Shift operators</h4>
<div class="paragraph">
<p><code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 已被 <code>+&lt;</code> 和 <code>+&gt;</code> 取代。</p>
</div>
</div>
<div class="sect3">
<h4 id="_命名一元运算符">6.2.11. 命名一元运算符</h4>
<div class="paragraph">
<p>如上所述，您可以在<a href="https://docs.raku.org/language/5to6-perlfunc">函数</a>指南中找到它们。</p>
</div>
</div>
<div class="sect3">
<h4 id="_关系运算符">6.2.12. 关系运算符</h4>
<div class="paragraph">
<p>这些都像 Perl 5 中那样工作。</p>
</div>
</div>
<div class="sect3">
<h4 id="_相等运算符">6.2.13. 相等运算符</h4>
<div class="paragraph">
<p><code>==</code> 和  <code>!=</code> 都像 Perl 5 中那样工作。</p>
</div>
<div class="paragraph">
<p><code>&lt;&#8658; ` 和 `cmp</code> 在 Raku 中有不同的行为。<code>&lt;&#8658; ` 做数值比较，但返回 `Order::Less</code>、<code>Order::Same</code> 或者 <code>Order::More</code> 而不是Perl 5 中的 <code>-1</code>、<code>0</code> 或 <code>1</code>。要获得 <code>cmp</code> 的 Perl 5 行为（使用它返回 <code>Order</code> 对象而不是整数的更改），您应该使用 <code>leg</code> 运算符。</p>
</div>
<div class="paragraph">
<p><code>cmp</code> 要么做 <code>&lt;&#8658;</code> 要么做 <code>leg</code>，这取决于其参数的现有类型。</p>
</div>
<div class="paragraph">
<p><code>~~</code> 是 Perl 5 中的智能匹配运算符，但它也*只是* Raku 中的匹配运算符，如上所述。有关智能匹配在 Raku 中的工作原理，请参阅<a href="https://docs.raku.org/language/operators#index-entry-smartmatch_operator">smartmatch文档</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_智能匹配运算符_2">6.2.14. 智能匹配运算符</h4>
<div class="paragraph">
<p>有关<a href="https://docs.raku.org/language/operators#index-entry-smartmatch_operator">smartmatch</a>在 Raku 中的工作原理的更详细说明，请参阅<a href="https://docs.raku.org/language/operators#index-entry-smartmatch_operator">smartmatch文档</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_bitwise_and">6.2.15. Bitwise And</h4>
<div class="paragraph">
<p>二元 <code>&amp;</code> 在 Raku 中是 <code>+&amp;</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_bitwise_or_and_exclusive_or">6.2.16. Bitwise Or and Exclusive Or</h4>
<div class="paragraph">
<p>按位或已经从 Perl 5 中的 <code>|</code> 变成 Raku 中的 <code>+|</code>。同样地，按位 XOR <code>^</code> 变成了 <code>+^</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_c_style_的逻辑和">6.2.17. C-style 的逻辑和</h4>
<div class="paragraph">
<p>不变。</p>
</div>
</div>
<div class="sect3">
<h4 id="_c_style_逻辑或">6.2.18. C-style 逻辑或</h4>
<div class="paragraph">
<p>不变。</p>
</div>
</div>
<div class="sect3">
<h4 id="_logical_defined_or">6.2.19. Logical Defined-Or</h4>
<div class="paragraph">
<p>在 Raku 中保持为 <code>//</code>。返回第一个有定义的操作数，或者返回最后一个操作数。此外，还有一个低优先级版本，称为 <code>orelse</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_range_运算符">6.2.20. Range 运算符</h4>
<div class="paragraph">
<p>在列表上下文中，<code>..</code> 作为范围运算符运行，不需要更改。也就是说，存在可能有用的排他性范围运算符。这些是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>中缀 <code>..^</code> 不包括末端;</p>
</li>
<li>
<p>中缀 <code>^..</code> 不包括起点;</p>
</li>
<li>
<p>中缀 <code>`<sup>..</sup></code> 不包括起点和末端;</p>
</li>
<li>
<p><code>^</code> 从零开始的前缀，不包括末端。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示了所有上述范围运算符的效果（请注意圆括号仅用于允许方法调用）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1..^5).list;  # (1 2 3 4)
(1^..5).list;  # (2 3 4 5)
(1^..^5).list; # (2 3 4)
(^5).list;     # (0 1 2 3 4)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Perl 5 中，在标量上下文中，运算符 <code>..</code> 和 <code>&#8230;&#8203;</code> 像触发器(flip-flop)操作符一样，即使它们鲜为人知且可能较少使用。Raku 中的那些运算符分别由<a href="https://docs.raku.org/routine/ff">ff</a>和<a href="https://docs.raku.org/routine/fff">fff</a>代替。</p>
</div>
</div>
<div class="sect3">
<h4 id="_条件运算符">6.2.21. 条件运算符</h4>
<div class="paragraph">
<p>条件运算符 <code>?:</code> 已替换为 <code>?? !!</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$x = $ok  ? $yes  : $no;  # Perl 5
$x = $ok ?? $yes !! $no;  # Raku</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_赋值运算符">6.2.22. 赋值运算符</h4>
<div class="paragraph">
<p>虽然没有完整记录，但 S03 表明数学和逻辑赋值运算符应该像您期望的那样工作。一个值得注意的变化是 <code>.=</code> 在左侧的对象上调用可变方法（也可以是类型对象）。这允许以下有用的惯用法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class LongClassName {
    has $.frobnicate;
}
my LongClassName $bar .= new( frobnicate =&gt; 42 ); # no need to repeat class name</code></pre>
</div>
</div>
<div class="paragraph">
<p>这确保了 <code>$bar</code> 只能包含一个 <code>LongClassName</code> 对象，并且不必重复（并且可能拼写错误）类名。</p>
</div>
<div class="paragraph">
<p><code>~=</code> 是字符串连接赋值，正如您可能期望的更改 <code>.</code> 和 <code>~</code>。此外，按位赋值运算符可能不会分为数字和字符串版本（<code>&amp;=</code> 等等，相对 <code>&amp;.=</code> 等），因为该功能目前在 Perl 5 本身中是实验性的 - 尽管，这并没有具体记录。</p>
</div>
</div>
<div class="sect3">
<h4 id="_逗号运算符">6.2.23. 逗号运算符</h4>
<div class="paragraph">
<p>逗号运算符大多按预期工作，但从技术上讲，它创建<a href="https://docs.raku.org/type/List">列表</a>）或分隔函数调用中的参数。此外，还有一个 <code>:</code> 变体可以将函数调用转换为方法调用 - 请参阅<a href="https://docs.raku.org/language/operators#infix_%253A">此页面</a>。</p>
</div>
<div class="paragraph">
<p>`&#8658; `运算符，或*胖箭头*，工作方式类似于 Perl 5 的“胖逗号”，因为它允许在其左侧的无引号（普通）标识符，但在 Raku 中它构造 Pair 对象，而不是仅仅作为分隔符发挥作用。如果您试图将一行 Perl 5 代码直接翻译为 Raku，它应该会按预期运行。</p>
</div>
</div>
<div class="sect3">
<h4 id="_列表运算符_rightward">6.2.24. 列表运算符 (rightward)</h4>
<div class="paragraph">
<p>与命名一元运算符一样，您可以在<a href="https://docs.raku.org/language/5to6-perlfunc">函数</a>下找到这些。</p>
</div>
</div>
<div class="sect3">
<h4 id="_逻辑非">6.2.25. 逻辑非</h4>
<div class="paragraph">
<p><code>!</code> 的优先级较低版本。对于 <code>!</code>，强转其参数为 <code>Bool</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_逻辑和">6.2.26. 逻辑和</h4>
<div class="paragraph">
<p>如 Perl 5 中的 较低优先级版本的 <code>&amp;&amp;</code> 一样。</p>
</div>
</div>
<div class="sect3">
<h4 id="_逻辑或或独占或">6.2.27. 逻辑或或独占或</h4>
<div class="paragraph">
<p><code>or</code> 是低优先级版本的 <code>||</code>，并且 <code>xor</code> 是低优先级版本的 <code>^^</code>。</p>
</div>
<div class="paragraph">
<p>此外，还有一个低优先级版本的 <code>//</code>，称为 <code>orelse</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_引用和引用类似的运算符">6.2.28. 引用和引用类似的运算符</h4>
<div class="paragraph">
<p>有关引用构造的所有详细信息，请参阅<a href="https://docs.raku.org/language/quoting">引用</a>。</p>
</div>
<div class="paragraph">
<p>有一个引用运算符，允许绝对的文字字符串：<code>Q</code> 或者 <code>｢…｣</code>，尽管后者可能很难在你的键盘上找到，这取决于你的键盘&#8230;&#8203;&#8230;&#8203;反斜杠转义也*没有*应用在 <code>Q</code> 引用的字符串上。例如 <code>Q{This is still a closing curly brace → \}</code> 合成的是 "This is still a closing curly brace → \"。</p>
</div>
<div class="paragraph">
<p><code>q</code> 做你期望的，允许反斜杠转义。例如 <code>q{This is not a closing curly brace → \}, but this is → }</code> 返回 "This is not a closing curly brace → }, but this is →"。与 Perl 5 一样，您可以使用单引号获得此行为。</p>
</div>
<div class="paragraph">
<p><code>qq</code> 允许变量插值。但是，默认情况下，只插入标量变量。要获得其他变量插值，您需要在它们后面放置方括号（所谓的<a href="https://docs.raku.org/language/subscripts#index-entry-Zen_slices">zen-slice</a>）以使它们进行插值。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = &lt;1 2 3&gt;;
say qq/@a[] example@example.com/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果为 “1 2 3 <a href="mailto:example@example.com">example@example.com</a>”。哈希以相同的方式进行插值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %a = 1 =&gt; 2, 3 =&gt; 4;
say "%a{}";</code></pre>
</div>
</div>
<div class="paragraph">
<p>导致空格分隔 Pair 对儿, Tab 将每对中的键与值分开（因为这是 <code>Pair</code> 的标准字符串化，并且哈希在字符串化时充当 <code>Pair</code> 的列表）。您还可以使用花括号在字符串中插入 Raku 代码。有关所有详细信息，请参阅<a href="https://docs.raku.org/language/quoting#Interpolation%253A_qq">插值</a>。</p>
</div>
<div class="paragraph">
<p><code>qw</code> 像 Perl 5 中那样工作，也可以呈现为 <code>&lt;&#8230;&#8203;&gt;</code>。例如 <code>qw/a b c/</code> 相当于 <code>&lt;a b c&gt;</code>。</p>
</div>
<div class="paragraph">
<p>还有一个能插值的 <code>qw</code> 版本，即 <code>qqw</code>。所以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;
say qqw/$a b c/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>给你 “42 b c”。</p>
</div>
<div class="paragraph">
<p>Shell 引用可以通过 <code>qx</code> 获得，但是你应该注意，反引号不像 Perl 5 那样进行 shell 引用，并且 Perl 变量*不*在 <code>qx</code> 字符串中进行插值。如果需要在 shell 命令字符串中插入 Perl 变量，则可以改为使用 <code>qqx</code>。</p>
</div>
<div class="paragraph">
<p>Raku 中没有 <code>qr</code> 运算符了。</p>
</div>
<div class="paragraph">
<p><code>tr///</code> 与 Perl 5 中的工作方式类似。需要注意的是范围的指定方式不同。您可以使用“a..z”代替使用范围“a-z”，即使用 Perl 的范围运算符。<code>tr///</code> 有一个方法版本，记录的更好，称为 <code>.trans</code>。<code>.trans</code> 使用 Pair 对儿的列表，如下所示：可以在<a href="https://design.raku.org/S05.html#Transliteration">https://design.raku.org/S05.html#Transliteration中</a>找到更广泛的使用说明。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$x.trans(
    ['a'..'c'] =&gt; ['A'..'C'],
    ['d'..'q'] =&gt; ['D'..'Q'],
    ['r'..'z'] =&gt; ['R'..'Z']
    );</code></pre>
</div>
</div>
<div class="paragraph">
<p>等价的 <code>y///</code> 已经废除了。</p>
</div>
<div class="paragraph">
<p>在 Raku 中 <code>:to</code> 以不同方式指定了 Heredocs。您可以使用引号运算符，例如，<code>q:to/END/;</code> 将以 “END” 开头的 heredoc 结尾。类似地，您可以根据引用运算符进行转义和插值，即带有 <code>Q</code> 的文字值, 带有 <code>q</code>  的反斜杠转义和带有插值的 <code>qq</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_io_运算符">6.2.29. I/O 运算符</h4>
<div class="paragraph">
<p>有关 Raku 中输入/输出的完整详细信息，请参阅<a href="https://docs.raku.org/language/io">io</a>。</p>
</div>
<div class="paragraph">
<p>因为 <code>&lt;&#8230;&#8203;&gt; ` 与 Raku 中的 quote-words 构造一样，</code>&lt;&gt; ` 不用于从文件中读取行。您可以通过 <code>IO</code> 从文件名创建对象或使用打开的文件句柄然后在任何一种情况下在它身上调用 <code>.lines</code> 来实现。或者例如 <code>my @a = "filename".IO.lines;</code> 或 <code>my $fh = open "filename", :r;my @a = $fh.lines;</code>（在后一种情况下，我们使用 <code>:r</code> 专门打开用于读取的文件）。要以迭代方式执行此操作，可以用以下方式 使用 <code>for</code> 循环：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 'huge-csv'.IO.lines -&gt; $line {
    # Do something with $line
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意那里的 <code>&#8594;</code> 用法。这是块语法的一部分，而在 Raku 中要用在 <code>if</code>，<code>for</code>，<code>while</code> 等块中。</p>
</div>
<div class="paragraph">
<p>如果你想将整个文件 slurp 为标量，你会惊讶的！- 使用 <code>.slurp</code> 方法。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = "filename".IO.slurp;
=== ... or ...
my $fh = open "filename", :r;
my $x = $fh.slurp;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如<a href="https://docs.raku.org/language/5to6-perlvar">特殊变量</a>指南中所述，<code>ARGV</code> 魔术输入文件句柄已被替换 <code>$*ARGFILES</code>，并且`@ARGV` 命令行参数数组已被替换 <code>@*ARGS</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_no_ops">6.2.30. No-ops</h4>
<div class="paragraph">
<p><code>1 while foo();</code> 与 Perl 5 中的工作方式相同，但它会生成警告。在 Raku 中，这个惯用法现在被写成了 <code>Nil while foo();</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_按位字符串运算符">6.2.31. 按位字符串运算符</h4>
<div class="paragraph">
<p>单独记录在上面了，但总结如下&#8230;&#8203;&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>按位整数否定加上前缀 <code>+^</code>。按位布尔否定是 <code>?^</code>。</p>
</div>
<div class="paragraph">
<p>按位与是 <code>+&amp;</code>。</p>
</div>
<div class="paragraph">
<p>按位整数或是 <code>+|</code>。按位整数 xor 是中缀 <code>+^</code>。按位布尔或是 <code>?|</code>。</p>
</div>
<div class="paragraph">
<p>左移和右移是 <code>+&lt;</code> 和 <code>+&gt;</code>。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_raku_语法">7. Raku 语法</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_描述_2">7.1. 描述</h3>
<div class="paragraph">
<p>关于 Perl 5 和 Raku 之间差异的全面（希望）描述。</p>
</div>
</div>
<div class="sect2">
<h3 id="_注意_2">7.2. 注意</h3>
<div class="paragraph">
<p>我*不会*详细解释 Raku 语法。本文档旨在指导你从 Perl 5 中的工作原理过渡到 Raku 中的等效工具。有关 Raku 语法的完整文档，请参阅 Raku 文档。</p>
</div>
</div>
<div class="sect2">
<h3 id="_自由形式">7.3. 自由形式</h3>
<div class="paragraph">
<p>Raku 仍然*主要是*自由形式。但是，有一些情况下，空白的存在或缺失现在很重要。例如，在 Perl 5 中，你可以省略关键字后面的空格（例如 <code>while($x &lt; 5)</code> 或 <code>my($x, $y)</code>）。在 Raku 中，这个空白是必需的，因此 <code>while ($x &lt; 5)</code> 或 <code>my ($x, $y)</code>。但是，在 Raku 中，你可以完全省略括号：<code>while $x &lt; 5 `。这适用于 `if</code>，<code>for</code> 等等。</p>
</div>
<div class="paragraph">
<p>奇怪的是，在 Perl 5 中，你可以在数组或散列与其下标之间以及后缀运算符之间留出空格。所以 <code>$seen {$_} ` 是有效的。Raku 再不这样了。Raku 中现在必须是 `%seen{$_}</code>。</p>
</div>
<div class="paragraph">
<p>如果能让你感觉更好，你可以使用反斜杠来 “unspace” 空格，这样你就可以使用空格，否则它将被禁止。</p>
</div>
<div class="paragraph">
<p>有关详细信息，请参阅<a href="https://docs.raku.org/language/5to6-nutshell#Whitespace">空白</a>。</p>
</div>
<div class="sect3">
<h4 id="_声明">7.3.1. 声明</h4>
<div class="paragraph">
<p>正如<a href="https://docs.raku.org/language/5to6-perlfunc">函数</a> 指南中所述，Raku 中没有 <code>undef</code> 。声明但未初始化的标量变量将计算其类型。换句话说，<code>my $x;say $x;</code> 会给你"(Any)"。<code>my Int $y;say $y;</code> 会给你"(Int)"。</p>
</div>
</div>
<div class="sect3">
<h4 id="_注释_2">7.3.2. 注释</h4>
<div class="paragraph">
<p><code>#</code> 在 Perl 5 中开始一个运行到行尾的注释。</p>
</div>
<div class="paragraph">
<p>嵌入式注释以井号字符和反引号开头，后跟开口括号字符，并持续到匹配的闭合括号字符。像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if #`( why would I ever write an inline comment here? ) True {
    say "something stupid";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与 Perl 5 一样，你可以使用 pod 指令在注释 <code>=begin comment</code> 之前和 <code>=end comment</code> 之后创建多行注释。</p>
</div>
</div>
<div class="sect3">
<h4 id="_真和假">7.3.3. 真和假</h4>
<div class="paragraph">
<p>Perl 5 与 Raku 之间的一个真正区别在于，与 Perl 5 不同，Raku 将字符串`"0"` 视为真。数字 <code>0</code> 仍为 <code>false</code>，你可以使用前缀 <code>+</code> 将字符串 <code>"0"</code> 强制转换为数字以使其为 <code>false</code>。Raku 还具有实际的布尔类型，因此，在许多情况下，你可以使用 <code>True</code> 和 <code>False</code>，而无需担心哪些值计为 true 和 false。</p>
</div>
</div>
<div class="sect3">
<h4 id="_语句修饰符">7.3.4. 语句修饰符</h4>
<div class="paragraph">
<p>大多数情况下，语句修饰符仍然有效，但有一些例外。</p>
</div>
<div class="paragraph">
<p>首先，<code>for</code> 循环是 Perl 5 中已知的 <code>foreach</code> 循环，C 风格的 <code>for`循环不用于 Raku。要获得该行为，你需要 `loop</code>。<code>loop</code> 不能用作语句修饰符。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，你无法使用 <code>do {&#8230;&#8203;} while $x</code> 形式。你将需要用 <code>repeat</code> 替换 <code>do</code> 形式。<code>do {&#8230;&#8203;} until $x</code> 类似。</p>
</div>
</div>
<div class="sect3">
<h4 id="_复合语句_2">7.3.5. 复合语句</h4>
<div class="paragraph">
<p>Perl 5 的最大变化是 <code>given</code> 在 Raku 中默认不是实验性质的或禁用的了。有关 <code>given</code> 的详细信息，请参阅<a href="https://docs.raku.org/language/control#given">此页面</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_循环控制">7.3.6. 循环控制</h4>
<div class="paragraph">
<p><code>next</code>，<code>last</code> 和 <code>redo</code> 在 Perl 5 到 Raku 中没有变化。</p>
</div>
<div class="paragraph">
<p>但是 <code>continue</code>，在 Raku 中不存在。你将在循环体中使用 <code>NEXT</code> 块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Perl 5
my $str = '';
for (1..5) {
    next if $_ % 2 == 1;
    $str .= $_;
}
continue {
    $str .= ':'
}

# Raku
my $str = '';
for 1..5 {
    next if $_ % 2 == 1;
    $str ~= $_;
    NEXT {
        $str ~= ':'
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_for_循环">7.3.7. For 循环</h4>
<div class="paragraph">
<p>如上所述，C 风格的 <code>for</code> 循环在 Raku 中不称为 <code>for</code> 循环。它们只是 <code>loop</code> 循环。要编写无限循环，你不需要使用C语言风格的 <code>loop (;;) {&#8230;&#8203;}</code>，只是完全省略规范：<code>loop {&#8230;&#8203;}</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_foreach_循环">7.3.8. Foreach 循环</h4>
<div class="paragraph">
<p>在 Perl 5 中，<code>for</code> 除了用于 C 风格的 <code>for</code> 循环之外，它还是`foreach` 的同义词。在 Raku 中，<code>for</code> 仅用于 <code>foreach</code> 样式的循环。</p>
</div>
</div>
<div class="sect3">
<h4 id="_switch_语句">7.3.9. Switch 语句</h4>
<div class="paragraph">
<p>Raku 具有真实的 switch 语句，通过提供 <code>given</code> 与由处理的单个情况的 <code>when</code> 和 <code>default</code>。基本语法是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given EXPR {
    when EXPR { ... }
    when EXPR { ... }
    default { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>完整的细节可以在<a href="https://docs.raku.org/language/control#given">这里</a>找到。</p>
</div>
</div>
<div class="sect3">
<h4 id="_goto">7.3.10. Goto</h4>
<div class="paragraph">
<p><code>goto</code> 目前尚未实施（尚未）。标签<strong>已</strong>实现，可用作 <code>next</code>，<code>last</code> 和 <code>redo</code> 的目标：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">FOO:                         # Labels end with colons, like in Perl 5
for ^10 {
    say "outer for before";
    for ^10 {
        say "inner for";
        last FOO;
    }
    say "outer for after";   # Will not show because of the "last"
}
=== outer for before
=== inner for</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关 <code>goto</code> 的计划，请参阅 &lt;<a href="https://design.raku.org/S04.html#The_goto_statement&gt;。" class="bare">https://design.raku.org/S04.html#The_goto_statement&gt;。</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_省略语句">7.3.11. 省略语句</h4>
<div class="paragraph">
<p><code>&#8230;&#8203;</code>（以及 <code>!!!</code> 和 <code>???</code>）用于创建存根(stub)声明。这比 Perl 5 中使用的 <code>&#8230;&#8203;</code> 要复杂得多，所以你可能想要查看 <a href="https://design.raku.org/S06.html#Stub_declarations" class="bare">https://design.raku.org/S06.html#Stub_declarations</a> 以了解详细信息。尽管如此，尽管它在 Raku 中的作用得到了扩展，但它似乎还没有*明显的*理由说明它为什么不能完成它在 Perl 5 中所扮演的角色。</p>
</div>
</div>
<div class="sect3">
<h4 id="_pods_嵌入式文档">7.3.12. PODs: 嵌入式文档</h4>
<div class="paragraph">
<p>Pod 已经在 Perl 5 和 Raku 之间发生了变化。可能最大的区别在于你需要将你的 pod 放在 <code>=begin pod</code> 和 <code>=end pod</code> 指令之间。这里和那里也有一些调整。例如，正如我在编写这些文档时发现的那样，垂直条（<code>|</code>）在 <code>X&lt;&gt;</code> 代码中很重要，并且不清楚如何将字面 <code>|</code> 插入他们。你最好的选择可能是使用 Raku 解释器检查你的 pod。你可以使 <code>--doc</code> 开关执行此操作。例如 <code>raku --doc Whatever.pod</code>。这将输出任何问题到标准错误。（根据你安装 raku 的方式/位置，你可能需要指定 <code>Pod::To::Text</code> 的位置。）有关 Raku 样式 pod 的详细信息，请访问 &lt;<a href="https://design.raku.org/S26.html&gt;。" class="bare">https://design.raku.org/S26.html&gt;。</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_特殊变量">8. 特殊变量</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_描述_3">8.1. 描述</h3>
<div class="paragraph">
<p>一个（希望）全面的 Perl 5 特殊变量列表及其 Raku 等价物，并在必要时记录它们之间的变化。</p>
</div>
</div>
<div class="sect2">
<h3 id="_注意_3">8.2. 注意</h3>
<div class="paragraph">
<p>本文档试图引导读者从 Perl 5 中的特殊变量到 Raku 中的等效变量。有关 Raku 特殊变量的完整文档，请参阅每个变量的 Raku 文档。</p>
</div>
</div>
<div class="sect2">
<h3 id="_特殊变量_2">8.3. 特殊变量</h3>
<div class="sect3">
<h4 id="_通用变量">8.3.1. 通用变量</h4>
<div class="ulist">
<ul>
<li>
<p>$ARG</p>
</li>
<li>
<p>$_</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>值得庆幸的是， <code>$<em></code> 是 Perl 5 中的常规默认变量。Raku 的主要区别在于现在你可以在它身上调用方法。 例如，Perl 5 的 <code>say $</em></code> 可以在 Raku 中以 <code>$_.say</code> 表示。 此外，因为它是默认变量，您甚至不需要使用变量名称。 前面的例子也可以 通过使用 <code>.say</code> 实现。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>@ARG</p>
</li>
<li>
<p>@_</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于 Raku 现在具有函数签名，您的参数可以去那里，而不是依赖于 <code>@<em></code>。 事实上，如果你使用函数签名，使用 <code>@</em></code> 会吐出你告诉它不能覆盖一个现有签名。</p>
</div>
<div class="paragraph">
<p>但是，如果您不使用函数签名，则 <code>@<em></code> 将包含您传递给函数的参数, 就像它在Perl 5中那样。再次，与 <code>$</em></code> 一样 ，您可以在其上调用方法。 与 <code>$<em></code> 不同，你不能假设 <code>@</em></code> 为 这些方法的默认变量（即 <code>@_.shift</code> works， <code>.shift</code> 不 work）。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$LIST_SEPARATOR</p>
</li>
<li>
<p>$"</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>目前，Raku 中没有与 List Separator 变量等效的设计文档 S28 在那里说 不是一个，所以你可能不想屏住呼吸。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$PROCESS_ID</p>
</li>
<li>
<p>$PID</p>
</li>
<li>
<p>$$</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 Raku 中用 <code>$*PID</code> 替换 <code>$$</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p>$PROGRAM_NAME</p>
</li>
<li>
<p>$0</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以通过 <code>$*PROGRAM-NAME</code> 访问 Raku 中的程序名称 。 注意： Raku 中的 <code>$0</code> 是保持正则表达式匹配中第一个捕获值的变量（即捕获变量现在从 <code>$0</code> 而不是 <code>$1</code> 开始 )。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$REAL_GROUP_ID</p>
</li>
<li>
<p>$GID</p>
</li>
<li>
<p>$(</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 Raku 中，组信息由 <code>$*GROUP</code> 处理 ，它包含一个 IntStr 类型的对象  因此 可以在字符串或数字上下文中使用。 因此，组ID通过 <code>+$*GROUP</code> 获得 ， 而组名通过 <code>~$*GROUP</code> 获得 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$EFFECTIVE_GROUP_ID</p>
</li>
<li>
<p>$EGID</p>
</li>
<li>
<p>$)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Raku目前似乎没有提供有效的组ID。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$REAL_USER_ID</p>
</li>
<li>
<p>$UID</p>
</li>
<li>
<p>$&lt;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 Raku 中，用户信息由 <code>$*USER`处理 ，后者持有 IntStr 类型的对象，因此可以 可以在字符串或数字上下文中使用（这类似于处理组信息的方式） 由 `$*GROUP</code> 对象）。 因此，用户ID通过 <code>+$*USER</code> 获得 ，而用户名通过 <code>~$*USER</code> 获得 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$EFFECTIVE_USER_ID</p>
</li>
<li>
<p>$EUID</p>
</li>
<li>
<p>$&gt;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Raku当前似乎没有提供有效的用户ID。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$SUBSCRIPT_SEPARATOR</p>
</li>
<li>
<p>$SUBSEP</p>
</li>
<li>
<p>$;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Raku中不包含下标分隔符变量。坦率地说，如果你的Perl 5代码正在使用它，那就是 几乎可以肯定，真的很老。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$a</p>
</li>
<li>
<p>$b</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>$a</code> 和 <code>$b</code> 在 Raku 中没有特殊含义 <code>.sort()</code> 不会将它们用于任何特殊的东西。 他们只是常规的旧变量。 通过使用具有更多功能的占位符参数的块来扩展此功能。 占位符变量是使用 <code>^twigil</code> 创建的 （例如 <code>$^z</code> 。它们可以在裸块中使用或在没有显式参数列表的子程序。 块的参数将分配给占位符 Unicode 顺序中的变量。 I. e。 即使变量出现在块中的顺序 （<code>$^q</code>, <code>$^z</code>, <code>$^a</code>） ，它们将按顺序分配 （<code>$^a</code>, <code>$^q</code>, <code>$^z</code>） 。 人机工程学：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sort { $^a cmp $^z }, 1, 5, 6, 4, 2, 3;
# OUTPUT: «(1 2 3 4 5 6)␤»
sort { $^g cmp $^a }, 1, 5, 6, 4, 2, 3;
# OUTPUT: «(6 5 4 3 2 1)␤»
for 1..9 { say $^c, $^a, $^b; last }
# OUTPUT: «312␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关占位符变量的更多信息，请参阅<a href="https://docs.raku.org/language/variables#The_%5E_Twigil">此页面</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>%ENV</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>％ENV已被Raku中的％*ENV取代。请注意，此哈希的键可能不完全是 在Perl 5和Raku之间相同。例如， Raku的％ENV中缺少OLDPWD 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$OLD_PERL_VERSION</p>
</li>
<li>
<p>$]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Raku 的运行版本由 <code>$*PERL</code> 特殊变量保存，即一个对象。 正在运行的版本是 通过 <code>$*PERL.version</code> 检索 ，返回类似 <code>v6.c</code> 的内容 ; Perl 的完整字符串化版本解释器是通过 <code>~$*PERL</code> 获得的 ，它返回类似于 Raku（6.c）的内容 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$SYSTEM_FD_MAX</p>
</li>
<li>
<p>$^F</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>虽然设计文件（S28）表明这可能会变成 <code>$*SYS_FD_MAX</code> ，但这还没有b被实现。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>@F</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>[需要进一步研究]此时有点混乱。 设计文档S28表示 @F in Perl 5在Raku中被 @_ 取代 ，但目前还不清楚它是如何工作的。 另一方面，它是目前的 有点问题，因为 Perl 5 to Raku Translation doc 指出 <code>-a</code> 和 <code>-F</code> 命令 - rakudo 尚未实现行开关。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>@INC</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Raku 中不再存在。请使用“use lib”来操作要搜索的模块存储库。 该 最接近 <code>@INC</code> 的是 <code>$*REPO</code>。 但这与@INC完全不同 因为 Raku 的预编译功能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Print out a list of compunit repositories
.say for $*REPO.repo-chain;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>%INC</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Raku 中不再存在。因为每个 Repository 都负责记住哪些模块已经装好了。 您可以获得所有已加载模块（编译单元）的列表，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Test;
use MyModule;
say flat $*REPO.repo-chain.map(*.loaded); #-&gt; (MyModule Test)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>$INPLACE_EDIT</p>
</li>
<li>
<p>$^I</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>S28 建议使用 <code>$*INPLACE_EDIT</code>，但它尚不存在。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$^M</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>S28 建议使用 <code>$*EMERGENCY_MEMORY</code>，但它尚不存在。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$OSNAME</p>
</li>
<li>
<p>$^o</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这有点不清楚。 它可能取决于你的意思是“操作系统的名称” 作为设计文档 <a href="https://design.raku.org/S28.html">S28</a> 有三个不同的建议，所有建议都给出了不同的答案。</p>
</div>
<div class="paragraph">
<p>目前有三个主要对象包含有关“运行环境”的信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>$*KERNEL</code> 提供有关正在运行的操作系统内核的信息;</p>
</li>
<li>
<p><code>$*DISTRO</code> 提供有关操作系统分发的信息;</p>
</li>
<li>
<p><code>$*VM</code> 提供有关 Raku 的运行后端机器的信息。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以上所有对象都有共同的方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>version</code> 提供该组件的版本号;</p>
</li>
<li>
<p><code>name</code> 提供该组件的助记符名称;</p>
</li>
<li>
<p><code>auth</code> 为该组件提供已知作者。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>作为一个简短示例，以下代码打印有关上述所有组件的信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $*KERNEL, $*DISTRO, $*VM -&gt; $what {
    say $what.^name;
    say 'version '  ~ $what.version
        ~ ' named ' ~ $what.name
        ~ ' by '    ~ $what.auth;
}

# Kernel
# version 4.10.0.42.generic named linux by unknown
# Distro
# version 17.04.Zesty.Zapus named ubuntu by https://www.ubuntu.com/
# VM
# version 2017.11 named moar by The MoarVM Team</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面所有的 <code>Str</code> 方法产生了当前时间的信息的短版本名字 。</p>
</div>
<div class="paragraph">
<p>所有对象都有其他方法，在尝试识别正确运行的实例时非常有用， 有关更多信息，请使用 <code>&lt;.^methods&gt;</code> 来内省以上所有内容。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>%SIG</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>没有等效变量。 要在接收信号时执行代码，您可以调用 <a href="https://docs.raku.org/routine/signal#%28Supply%29_sub_signal">signal</a> 子程序，返回可以点击的 <code>Supply</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$SIG{"INT"} = sub { say "bye"; exit }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">signal(SIGINT).tap: { say "bye"; exit }; loop {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，如果您有一个通用代码，想知道它得到了哪个信号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">signal(SIGINT).tap: -&gt; $signal { say "bye with $signal"; exit }; loop {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在事件驱动的情况下使用信号的更惯用的方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    whenever signal(SIGINT) {
        say "goodbye";
        done
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>$BASETIME</p>
</li>
<li>
<p>$^T</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 Raku 中用 <code>$*INIT-INSTANT</code> 替换 。 与 Perl 5 不同，这不是自纪元以来的秒数，而是一个 <a href="https://docs.raku.org/type/Instant">Instant</a> 对象，以原子秒计，带有分数。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$PERL_VERSION</p>
</li>
<li>
<p>$^V</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>与 <code>$]</code> 一样，这已被 <code>$*PERL.version</code> 取代。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>${^WIN32_SLOPPY_STAT}</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 Raku 中没有类似的东西。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$EXECUTABLE_NAME</p>
</li>
<li>
<p>$^X</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这已被 <code>$*EXECUTABLE-NAME</code> 取代 。 请注意，还有 <code>$*EXECUTABLE</code> ，这在 Raku 中是一个 <code>IO</code> 对象。</p>
</div>
</div>
<div class="sect3">
<h4 id="_与正则表达式相关的变量">8.3.2. 与正则表达式相关的变量</h4>
<div class="sect4">
<h5 id="_性能问题">性能问题</h5>
<div class="paragraph">
<p>如下所示，  <code>$`</code>, <code>$&amp;</code> 和 <code>$'</code> 从 Raku 中删除了，主要由 <code>$/</code> 和它的变体代替， 消除它们，Perl 5 中的相关性能问题不适用。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>$&lt;digits&gt; ($1, $2, &#8230;&#8203;)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Raku 中的这些现有变量与 Perl 5 中的相同，除了它们现在从 <code>$0</code> 开始而不是 <code>$1</code>。 此外，它们是匹配变量 <code>$/</code> 中索引项的同义词。 例如  <code>$0</code> 相当于 <code>$/[0]， `$1</code> 相当于 `$/[1]`等。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$MATCH</p>
</li>
<li>
<p>$＆</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>$/</code> 现在包含<a href="https://docs.raku.org/type/Match">匹配</a>对象，因此 <code>$＆</code> 的 Perl 5 行为可以通过字符串化来获得，即 <code>~$/</code> 。 请注意，虽然 <code>$/.Str</code> 也可以工作， 但 <code>~$/</code> 目前是更常见的用法。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>${^MATCH}</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于以前的性能问题已经废除，因此 Raku 中没有使用此变量。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$PREMATCH</p>
</li>
<li>
<p>$`</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>替换为 <code>$/.prematch</code> 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>${^PREMATCH}</p>
<div class="literalblock">
<div class="content">
<pre>由于以前的性能问题已经废除，因此 Raku 中没有使用此变量。</pre>
</div>
</div>
</li>
<li>
<p>$POSTMATCH</p>
</li>
<li>
<p>$'</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>替换为 <code>$/.postmatch</code>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>${^POSTMATCH}</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于以前的性能问题已经废除，因此 Raku 中没有使用此变量。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$LAST_PAREN_MATCH</p>
</li>
<li>
<p>$+</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 Raku 中不存在，但你可以使用 <code>$/[<strong>-1].Str</code> 获得相同的信息。(<code>$/[</strong>-1]</code> 将是匹配对象，而不是实际的字符串)。</p>
</div>
<div class="paragraph">
<p>如果您想了解其工作原理，可以查看以下文档：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.raku.org/routine/">%20</a>#language_documentation_Operators[[]routine] 例程</p>
</li>
<li>
<p><a href="https://docs.raku.org/type/Whatever">Whatever</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可能</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://design.raku.org/S02.html#line_1126">https://design.raku.org/S02.html#line_1126</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>虽然设计文件并不总是最新的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$LAST_SUBMATCH_RESULT</p>
</li>
<li>
<p>$^N</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>S28 建议 <code>$*MOST_RECENT_CAPTURED_MATCH</code> ，但似乎没有任何实现的变量匹配 <code>$^N</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>@LAST_MATCH_END</p>
</li>
<li>
<p>@+</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>与大多数正则表达式相关的变量一样，此功能至少部分地移至 Raku 中的 <code>$/</code>  变量。或者，在这种情况下，编号变量是索引的别名。 偏移是通过使用 <code>.to</code> 方法找到。 例如, 第一个偏移是 <code>$/[0].to</code> ，它与 <code>$0.to</code> 同义。 Perl 5 提供的 <code>$+[0]</code>  由 <code>$/.to</code> 提供。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>%LAST_PAREN_MATCH</p>
</li>
<li>
<p>%+</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>再一次，我们转移到 <code>$/</code>。 前面的 <code>$+{$match}</code> 是 <code>$/{$match}</code>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>@LAST_MATCH_START</p>
</li>
<li>
<p>@-</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>类似于使用 <code>.to</code> 方法替换 <code>@+</code> ，使用 <code>$/</code> 上的 <code>.from</code> 方法替换 <code>@-</code> 及其变化。 第一个偏移是 <code>$/[0].from</code> 或等价的 <code>$0.from</code>。 Perl 5 的 <code>$-[0]</code> 是 <code>$/.from</code>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>%LAST_MATCH_START</p>
</li>
<li>
<p>%-</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>与 <code>%+</code> 非常相似 ，使用 <code>%-{$match}</code> 将替换为 <code>$/{$match}</code> 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$LAST_REGEXP_CODE_RESULT</p>
</li>
<li>
<p>$^R</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>没有等价物。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>${^RE_DEBUG_FLAGS}</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>没有等价物。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>${^RE_TRIE_MAXBUF}</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>没有等价物。</p>
</div>
</div>
<div class="sect4">
<h5 id="_与文件句柄相关的变量">与文件句柄相关的变量</h5>
<div class="ulist">
<ul>
<li>
<p>$ARGV</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>读取行时当前文件的名称可以通过 <code>$*ARGFILES.path</code> 获得。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>@ARGV</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>@*ARGS</code> 包含命令行参数。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ARGV</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这被 <code>$*ARGFILES</code> 取代 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ARGVOUT</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于尚未实现 <code>-i</code> 命令行开关，因此还没有相当于 <code>ARGVOUT</code> 的功能 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$OUTPUT_FIELD_SEPARATOR</p>
</li>
<li>
<p>$OFS</p>
</li>
<li>
<p>$</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>目前没有明显的等价物</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$INPUT_LINE_NUMBER</p>
</li>
<li>
<p>$NR</p>
</li>
<li>
<p>$.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>不存在直接替代品。</p>
</div>
<div class="paragraph">
<p>迭代时使用 行方法 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 或 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 类型，您可以在其上调用 <code>.kv</code> 方法 获取交错的索引和值列表（然后每个循环迭代2次）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for "foo".IO.lines.kv -&gt; $n, $line {
    say "{$n + 1}: $line"
}
# OUTPUT:
# 1: a
# 2: b
# 3: c
# 4: d</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 <a href="https://docs.raku.org/type/IO::CatHandle">IO::CatHandle</a> 类型（其中 <code>$*ARGFILES</code> 是一个），你可以使用 <a href="https://docs.raku.org/type/IO::CatHandle#method_on-switch">on-switch</a> hook 在句柄开关上重置行号，并手动递增。 另请参阅 <a href="https://modules.raku.org/repo/IO::CatHandle::AutoLines">IO::CatHandle::AutoLines</a> 和 <a href="https://modules.raku.org/repo/LN">LN</a> 模块简化此操作。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$INPUT_RECORD_SEPARATOR</p>
</li>
<li>
<p>$RS</p>
</li>
<li>
<p>$/</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这可以通过文件句柄上的 <code>.nl-in</code> 方法访问 。 例如。 <code>$*IN.nl-in</code>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$OUTPUT_RECORD_SEPARATOR</p>
</li>
<li>
<p>$ORS</p>
</li>
<li>
<p>$\</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这可以通过文件句柄上的 <code>.nl-out</code> 方法访问 。 例如 <code>$*OUT.nl-out</code>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$OUTPUT_AUTOFLUSH</p>
</li>
<li>
<p>$|</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>没有全球替代品。 对于其他设置，TTY 句柄默认是无缓冲的 <a href="https://docs.raku.org/routine/out-buffer">out-buffer</a> 设置为零或者使用 <code>:!out-buffer</code> 在特定的 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a>上和 open 一块使用 。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>${^LAST_FH}</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 Raku 中没有实现。</p>
</div>
</div>
<div class="sect4">
<h5 id="_与格式相关的变量">与格式相关的变量</h5>
<div class="paragraph">
<p>Raku中没有内置格式。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_错误变量">8.3.3. 错误变量</h4>
<div class="paragraph">
<p>关于 Raku 中的错误变量如何变化，因此这里不再详细说明。</p>
</div>
<div class="paragraph">
<p>引用 Raku <a href="https://docs.raku.org/language/variables#index-entry-%2524%21">docs</a> 中的说法，<code>$!</code> 是错误变量。</p>
</div>
<div class="paragraph">
<p>与 Raku 的其余部分一样，它是一个根据类型返回各种内容的错误类型或<a href="https://docs.raku.org/type/Exception">异常</a> 。</p>
</div>
<div class="paragraph">
<p>特别是在处理<a href="https://docs.raku.org/type/Exception">异常</a>时, <code>$!</code> 提供有关抛出异常的信息， 假设程序没有停止：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">try {
    fail "Boooh";
    CATCH {
        # within the catch block
        # the exception is placed into $_
        say 'within the catch:';
        say $_.^name ~ ' : ' ~ $_.message;
        $_.resume; # do not abort
    }
}

# outside the catch block the exception is placed
# into $!
say 'outside the catch:';
say $!.^name ~ ' : ' ~ $!.message;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以上代码生成以下输出</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">within the catch:
X::AdHoc : Boooh
outside the catch:
X::AdHoc : Boooh</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，如前所述， <code>$!</code> 变量保存异常对象。</p>
</div>
</div>
<div class="sect3">
<h4 id="_与解释器状态相关的变量">8.3.4. 与解释器状态相关的变量</h4>
<div class="ulist">
<ul>
<li>
<p>$COMPILING</p>
</li>
<li>
<p>$^C</p>
</li>
<li>
<p>$^D</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>目前没有这些变量的等价物。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>${^ENCODING}</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>虽然在 Perl 5 中已弃用 ，但在 <code>$?ENC</code> 中 可能有某种等价物 ，但这还远未明朗。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>${^GLOBAL_PHASE}</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>没有 Raku 等价物。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$^H</p>
</li>
<li>
<p>%^H</p>
</li>
<li>
<p>${^OPEN}</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 Raku 中可能有也可能没有这些等价物，但它们是内部的，你不应该搞乱 与他们在一起 - 当然，如果您对 Raku 的理解需要您阅读本文，那么肯定不会阅读该文献&#8230;&#8203;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>$PERLDB</p>
</li>
<li>
<p>$^P</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Raku 调试器与 Perl 5 调试器相似的可能性最小，此时此处也是如此，似乎不等于这个变量。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>${^TAINT}</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>S28 声称这个变量是“待定”的。 目前不在 Raku 中。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>${^UNICODE}</p>
</li>
<li>
<p>${^UTF8CACHE}</p>
</li>
<li>
<p>${^UTF8LOCALE}</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些与 Unicode 相关的变量似乎不存在于 Raku 中，但是 - 也许？ - 可能在某处有 <code>$?ENC</code> 类似物吗？  然而，这完全未经证实。</p>
</div>
</div>
<div class="sect3">
<h4 id="_弃用和删除变量">8.3.5. 弃用和删除变量</h4>
<div class="paragraph">
<p>不言而喻，因为已经从 Perl 5 中删除了这些，所以应该没有必要告诉你如何在 Raku 中使用它们。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_haskell_到_raku_简而言之">9. Haskell 到 Raku - 简而言之</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Haskell 和 Raku 是非常不同的语言。这很明显。 但是，这并不意味着没有相似之处或共同的想法！ 此页面尝试让一个 Haskell 用户启动并运行 Raku。Haskell 用户可能会发现，在用 Raku 编写脚本时，他们不需要放弃所有 Haskelly 的想法。</p>
</div>
<div class="paragraph">
<p>请注意，这不应该被误认为是初学者教程或 Raku 概述; 它旨在作为具有强大 Haskell 背景的 Raku 学习者的技术参考。</p>
</div>
<div class="sect2">
<h3 id="_类型">9.1. 类型</h3>
<div class="sect3">
<h4 id="_类型_vs_值">9.1.1. 类型 vs 值</h4>
<div class="paragraph">
<p>在 Haskell 中, 您有类型级编程, 然后进行值级编程。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-haskell" data-lang="haskell">plusTwo :: Integer -&gt; Integer   -- Types
plusTwo x = x + 2               -- Values</code></pre>
</div>
</div>
<div class="paragraph">
<p>您不要像下面那样在 Haskell 中混合类型和值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">plusTwo 2          -- This is valid
plusTwo Integer    -- This is not valid</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中, 类型(亦称为类型对象)和值处于同样的级别</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub plus-two(Int $x --&gt; Int) { $x + 2 }

plus-two(2);   # This is valid
plus-two(Int); # This is valid</code></pre>
</div>
</div>
<div class="paragraph">
<p>我将再用一个例子来说明 Raku 这个独特之处:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub is-string(Str $ --&gt; True)  {}
multi sub is-string(Any $ --&gt; False) {}

is-string('hello');    #True
is-string(4);          #False</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_maybe">9.1.2. Maybe</h4>
<div class="paragraph">
<p>在 Haskell 中，您有一个 Maybe 类型, 可以让您放弃空类型的烦恼。 假设您有一个将 String 解析为 Integer 的假设函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">parseInt :: String -&gt; Maybe Integer

case parseInt myString of
  Just x  -&gt; x
  Nothing -&gt; 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中, 由于类型对象与常规对象共存，因此我们拥有 <code>Defined</code> 和 <code>Undefined</code> 对象的概念。 平常的类型对象是 undefined 的, 而实例化后的对象是 defined 的。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_javascript_到_raku_简而言之">10. Javascript 到 Raku - 简而言之</h2>
<div class="sectionbody">
<div class="paragraph">
<p>此页面试图为有经验的  Node.js 用户提供学习 Raku 的方法。这里将解释两种语言之间通用的功能，以及语法和功能上的主要差异。</p>
</div>
<div class="paragraph">
<p>这不是学习 Raku 的教程; 对于中高级技能级别的 Node.js 用户，这只是一个参考。</p>
</div>
<div class="sect2">
<h3 id="_基础语法">10.1. 基础语法</h3>
<div class="sect3">
<h4 id="_hello_world">10.1.1. "Hello, world!"</h4>
<div class="paragraph">
<p>让我们从学习新语言时第一个典型的程序开始。在 Node.js 中，hello world 程序将编写如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">console.log('Hello, world!');</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下是在 Raku 中以相同方式编写此内容的几种方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say('Hello, world!');
say 'Hello, world!';</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 Raku 中的函数调用，括号是可选的。虽然分号在 Node.js 中大多是可选的，但对于 Raku 中的表达式而言分号是必需的。</p>
</div>
<div class="paragraph">
<p>现在我们对世界打过招呼了，让我们迎接我们的好朋友 Joe。我们将再次从 Node.js 开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">let name = 'Joe';
console.log('What\'s up,' + name + '?');
console.log(`What's up, {name}?`);
console.log("What's up, ", name, "?");</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为他没有听到我们，所以让我再问候他一次，这次是在 Raku 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $name = 'Joe';
say 'What\'s up, ' ~ $name ~ '?';
say "What's up, $name?";
say "What's up, ", $name, "?";</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里只有几个不同之处：Raku 中的大多数变量都有所谓的 sigils，这就是它名称前面的 <code>$</code>，字符串连接使用 <code>~</code> 运算符代替 <code>+</code>。这两种语言的共同点是支持字符串插值。</p>
</div>
<div class="paragraph">
<p>基本的例子就到这里了，让我们更详细地解释两种语言之间的相似之处。</p>
</div>
</div>
<div class="sect3">
<h4 id="_变量_2">10.1.2. 变量</h4>
<div class="paragraph">
<p>Node.js 中的变量可以像这样定义;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var foo = 1;    // Lexically scoped with functions and modules
let foo = 1;    // Lexically scoped with blocks
const foo = 1;  // Lexically scoped with blocks; constant

global.foo = 1; // Dynamically scoped; global
foo = 1;        // Ditto, but implicit; forbidden in strict mode</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中没有 <code>var</code> 的等价物。需要注意的一点是，Raku 中没有可变的吊装; 变量在它们所在的行上定义和分配，未在其作用域的顶部定义，稍后在该行赋值。</p>
</div>
<div class="paragraph">
<p>这是在 Raku 中定义等效类型的变量的方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $foo = 1;      # Lexically scoped with blocks
our $foo = 1;     # Lexically scoped with blocks and modules
constant foo = 1; # Lexically scoped with blocks and modules; constant

my $*foo = 1;       # Dynamically scoped with blocks
OUR::&lt;$foo&gt; = 1;    # Dynamically scoped with blocks and modules
GLOBAL::&lt;$foo&gt; = 1; # Dynamically scoped; global</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用`my`您使用的位置`let`，<code>our</code> 您需要在最外层范围内定义的变量以及 <code>constant</code> 您使用的位置 <code>const</code>。</p>
</div>
<div class="paragraph">
<p>动态范围变量的引用方式与它们在Node.js中的词汇范围变量相同。用户定义的那些使用一个`$<strong><code>，</code>@</strong><code>，</code>%<strong><code>，或 `&amp;</strong></code> twigil。有关 sigils，twigils和变量容器的更多信息，请参阅有关<a href="https://docs.raku.org/language/variables">变量</a>的文档。</p>
</div>
<div class="paragraph">
<p>Node.js 中的变量可以覆盖具有相同名称的外部作用域中的其他变量（尽管linters通常会根据它们的配置方式来抱怨它）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">let foo = 1;
function logDupe() {
    let foo = 2;
    console.log(foo);
}

logDupe(2);       // 2
console.log(foo); // 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 也允许这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $foo = 1;
sub log-dupe {
    my $foo = 2;
    say $foo;
}

log-dupe; # 2
say $foo; # 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_运算符_2">10.1.3. 运算符</h4>
<div class="sect4">
<h5 id="_赋值">赋值</h5>
<div class="paragraph">
<p><code>=</code> 运算符可以跨两种语言相同。</p>
</div>
<div class="paragraph">
<p>Raku 中的 <code>:=</code> 运算符将值绑定到变量。将变量绑定到另一个变量会为它们提供相同的值和容器，这意味着一个变量属性也会改变另一个变量。绑定变量不能被重新分配`=<code>或突变</code>++<code>，</code>--`等，但它们可以被重新绑定到另一个值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %map;            # This is a hash, roughly equivalent to a JS object or map
my %unbound = %map;
my %bound := %map;
%map&lt;foo&gt; = 'bar';
say %unbound;       # {}
say %bound;         # {foo =&gt; bar}

%bound := %unbound;
say %bound;         # {}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_相等">相等</h5>
<div class="paragraph">
<p>Node.js有两个相等运算符：<code>==`和</code>===`。</p>
</div>
<div class="paragraph">
<p>`==`是松散的平等算子。比较具有相同类型的操作数时，如果两个操作数相等，则返回true。但是，如果操作数是不同的类型，它们在被比较之前都被转换为它们的基元，这意味着它们将返回true：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">console.log(1 == 1);   // true
console.log('1' == 1); // true
console.log([] == 0);  // true</code></pre>
</div>
</div>
<div class="paragraph">
<p>类似地，在Raku中，如果它们不共享相同的类型，则在比较之前将两个操作数强制转换为Numeric：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1 == 1;       # True
say '1' == 1;     # True
say [1,2,3] == 3; # True, since the array has three elements</code></pre>
</div>
</div>
<div class="paragraph">
<p>倒数`==<code>是</code>!=`。</p>
</div>
<div class="paragraph">
<p>Raku有另一个类似于的运算符 <code>==</code>：<code>eq</code>。如果它们是不同的类型，而不是将操作数转换为Numeric，而不是`eq`将它们转换为字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '1' eq '1'; # True
say 1 eq '1';   # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>逆的`eq`是`ne`或`!eq`。</p>
</div>
<div class="paragraph">
<p>`===`是严格的相等运算符。如果两个操作数是相同的值，则返回true。比较对象时，如果它们是完全相同的对象，*则只*返回true：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">console.log(1 === 1);   // true
console.log('1' === 1); // false
console.log({} === {}); // false

let obj = {};
let obj2 = obj;
console.log(obj === obj2); // true;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中，运算符的行为相同，但有一个例外：两个具有相同值但容器不同的对象将返回false：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1 === 1; # True
say '1' === 1; # True
say {} === {};  # False

my \hash = {};
my %hash = hash;
say hash === %hash; # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>在最后一种情况下，它是相同的对象，但容器是不同的，这就是它返回False的原因。</p>
</div>
<div class="paragraph">
<p>倒数`===<code>是</code>!==`。</p>
</div>
<div class="paragraph">
<p>这是Raku的其他相等运算符很有用的地方。如果值具有不同的容器，则`eqv`可以使用操作员。此运算符也可用于检查深度相等性，通常需要在Node.js中使用库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say {a =&gt; 1} eqv {a =&gt; 1}; # True;

my \hash = {};
my %hash := hash;
say hash eqv %hash; # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要检查两个变量是否具有相同的容器和值，请使用`=:=`运算符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @arr = [1,2,3];
my @arr2 := @arr;   # Bound variables keep the container of the other variable
say @arr =:= @arr2; # True</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_smartmatching">Smartmatching</h5>
<div class="paragraph">
<p>Raku有一个用于比较值的最后一个运算符，但它不完全是一个相等运算符。这就是 <code>~~</code> 智能匹配运算符。这有几个用途：它可以像 <code>instanceof</code> 在Node.js 中一样使用，以匹配正则表达式，并检查值是否是散列，包，集或映射中的键：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'foo' ~~ Str; # True

my %hash = a =&gt; 1;
say 'a' ~~ %hash; # True

my $str = 'abc';
$str ~~ s/abc/def/; # Mutates $str, like foo.replace('abc', 'def')
say $str;           # def</code></pre>
</div>
</div>
<div class="paragraph">
<p>在我们讨论 Raku 中 <code>instanceof</code> 的时候, Node.js 对象的 <code>constructor</code>  属性相当于 <code>WHAT</code> 属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">console.log('foo'.constructor); // OUTPUT: String
say 'foo'.WHAT; # OUTPUT: Str</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_numeric">Numeric</h5>
<div class="paragraph">
<p>Node.js的有`+<code>，</code>-<code>，</code>/<code>，</code><strong><code>，</code>%<code>，和（在ES6）</code></strong>*`作为数字运算符。当操作数是不同类型时，类似于相等运算符，在执行操作之前会转换为它们的基元，从而使这成为可能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">console.log(1 + 2);   // 3
console.log([] + {}); // [object Object]
console.log({} + []); // 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>In Raku, again, they are converted to a Numeric type, as before:</p>
</div>
<div class="paragraph">
<p>在Raku中，它们再次转换为数字类型，如前所述：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1 + 2;        # 3
say [] + {};      # 0
say {} + [1,2,3]; # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, Raku has <code>div</code> and <code>%%</code>. <code>div</code> behaves like <code>int</code> division in C, while <code>%%</code> checks if one number is cleanly divisible by another or not:</p>
</div>
<div class="paragraph">
<p>另外，Raku有`div`和`%%<code>。`div`表现得像`int`C中的分裂，同时</code>%%`检查一个数字是否可以被另一个数字完全整除：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 4 div 3; # 1
say 4 %% 3;  # False
say 6 %% 3;  # True</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_bitwise">Bitwise</h5>
<div class="paragraph">
<p>Node.js has <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, and <code>~</code> for bitwise operators:</p>
</div>
<div class="paragraph">
<p>Node.js的有`&amp;`，<code>|</code>，<code>^</code>，<code><sub></code>，<code>&lt;&lt;</code>，<code>&gt;&gt;</code>，<code>&gt;&gt;&gt;</code>，和`</sub>`对位运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">console.log(1 &lt;&lt; 1);  // 2
console.log(1 &gt;&gt; 1);  // 0
console.log(1 &gt;&gt;&gt; 1); // 0
console.log(1 &amp; 1);   // 1
console.log(0 | 1);   // 1
console.log(1 ^ 1);   // 0
console.log(~1);      // -2</code></pre>
</div>
</div>
<div class="paragraph">
<p>In Raku, there is no equivalent to <code>&gt;&gt;&gt;</code>. All bitwise operators are prefixed with <code>+</code>, however two&#8217;s complement uses <code>+^</code> instead of <code>~</code>:</p>
</div>
<div class="paragraph">
<p>在Raku中，没有相当于`&gt;&gt;&gt;`。所有按位运算符都以前缀为前缀`+<code>，但是使用两个补码</code>+^<code>而不是</code>~`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1 +&lt; 1; # 2
say 1 +&gt; 1; # 0
            # No equivalent for &gt;&gt;&gt;
say 1 +&amp; 1; # 1
say 0 +| 1; # 1
say 1 +^ 1; # 0
say +^1;    # -2</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_custom_operators_and_operator_overloading">Custom operators and operator overloading</h5>
<div class="paragraph">
<p>Node.js does not allow operator overloading without having to use a Makefile or build Node.js with a custom version of V8. Raku allows custom operators and operator overloading natively! Since all operators are subroutines, you can define your own like so:</p>
</div>
<div class="paragraph">
<p>Node.js不允许运算符重载而不必使用Makefile或使用自定义版本的V8构建Node.js. Raku允许自定义操作符和操作符本机重载！由于所有运算符都是子程序，因此您可以像这样定义自己的运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;||=&gt;($a, $b) is equiv(&amp;infix:&lt;+=&gt;) { $a || $b }

my $foo = 0;
$foo ||= 1;
say $foo; # OUTPUT: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Operators can be defined as <code>prefix</code>, <code>infix</code>, or <code>postfix</code>. The <code>is tighter</code>, <code>is equiv</code>, and <code>is looser</code> traits optionally define the operator&#8217;s precedence. In this case, <code>||=</code> has the same precedence as <code>+=</code>.</p>
</div>
<div class="paragraph">
<p>Note how <code>multi</code> is used when declaring the operator subroutines. This allows multiple subroutines with the same name to be declared while also having different signatures. This will be explained in greater detail in the <a href="https://docs.raku.org/language/js-nutshell#Functions">Functions</a> section. For now, all we need to know is that it allows us to override any native operator we want:</p>
</div>
<div class="paragraph">
<p>运算符可以定义为`prefix`，<code>infix</code>，或`postfix`。的`is tighter`，<code>is equiv`和`is looser`性状选择定义操作的优先级。在这种情况下，</code>||=<code>具有相同的优先级</code>+=`。</p>
</div>
<div class="paragraph">
<p>注意`multi`在声明操作符子例程时如何使用。这允许声明具有相同名称的多个子例程，同时具有不同的签名。这将在“ <a href="https://docs.raku.org/language/js-nutshell#Functions">功能”</a>部分中详细说明。目前，我们需要知道的是它允许我们覆盖我们想要的任何本机运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=== Using the `is default` trait here forces this subroutine to be chosen first,
=== so long as the signature of the subroutine matches.
multi sub prefix:&lt;++&gt;($a) is default { $a - 1 }

my $foo = 1;
say ++$foo; # OUTPUT: 0</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_control_flow">10.1.4. Control flow</h4>
<div class="sect4">
<h5 id="_ifelse">if/else</h5>
<div class="paragraph">
<p>You should be familiar with how <code>if</code>/<code>else</code> looks in JavaScript:</p>
</div>
<div class="paragraph">
<p>您应该熟悉 JavaScript 中的 <code>if</code>/ <code>else</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">let diceRoll = Math.ceil(Math.random() * 6) + Math.ceil(Math.random() * 6);
if (diceRoll === 2) {
    console.log('Snake eyes!');
} else if (diceRoll === 16) {
    console.log('Boxcars!');
} else {
    console.log(`Rolled ${diceRoll}.`);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In Raku, <code>if</code>/<code>else</code> works largely the same, with a few key differences. One, parentheses are not required. Two, <code>else if</code> is written as <code>elsif</code>. Three, the if clause may be written <strong>after</strong> a statement:</p>
</div>
<div class="paragraph">
<p>在Raku中，<code>if</code>/的`else`工作方式基本相同，只有一些关键的区别。一，括号不是必需的。二，<code>else if`写成`elsif</code>。三，if语句可以*在*声明*后*写出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int $dice-roll = ceiling rand * 12 + ceiling rand * 12;
if $dice-roll == 2 {
    say 'Snake eyes!';
} elsif $dice-roll == 16 {
    say 'Boxcars!';
} else {
    say "Rolled $dice-roll.";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, though less efficient, this could be written to use <code>if</code> after statements:</p>
</div>
<div class="paragraph">
<p>或者，虽然效率较低，但可以`if`在语句后使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int $dice-roll = ceiling rand * 12 + ceiling rand * 12;
say 'Snake eyes!'        if $dice-roll == 2;
say 'Boxcars!'           if $dice-roll == 16;
say "Rolled $dice-roll." if $dice-roll !~~ 2 | 16;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku also has <code>when</code>, which is like <code>if</code>, but if the condition given is true, no code past the <code>when</code> block within the block it&#8217;s in is executed:</p>
</div>
<div class="paragraph">
<p>Raku也有`when`，就像是`if`，但是如果给出的条件为真，`when`那么执行它所执行的块中没有代码超过块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    when True {
        say 'In when block!'; # OUTPUT: In when block!
    }
    say 'This will never be output!';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, Raku has <code>with</code>, <code>orwith</code>, and <code>without</code>, which are like <code>if</code>, <code>else if</code>, and <code>else</code> respectively, but instead of checking whether their condition is true, they check if it&#8217;s defined.</p>
</div>
<div class="paragraph">
<p>此外，Raku的有`with`，<code>orwith`和`without</code>，这是一样`if`，`else if`和，`else`分别但是，不是检查自己的条件是否为真，他们检查，如果它被定义。</p>
</div>
</div>
<div class="sect4">
<h5 id="_switch">switch</h5>
<div class="paragraph">
<p>Switch statements are a way of checking for equality between a given value and a list of values and run some code if one matches. <code>case</code> statements define each value to compare to. <code>default</code>, if included, acts as a fallback for when the given value matches no cases. After matching a case, <code>break</code> is typically used to prevent the code from the cases that follow the one matched from being executed, though rarely this is intentionally omitted.</p>
</div>
<div class="paragraph">
<p>Switch语句是一种检查给定值和值列表之间相等性的方法，并在匹配时运行一些代码。<code>case`语句定义要比较的每个值。`default</code>，如果包含，则作为给定值不匹配任何情况的后备。在匹配案例之后，`break`通常用于防止代码跟随匹配的案例执行，尽管很少有意省略。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">const ranklist = [2, 3, 4, 5, 6, 7, 8, 9, 'Jack', 'Queen', 'King', 'Ace'];
const ranks    = Array.from(Array(3), () =&gt; ranklist[Math.floor(Math.random() * ranks.length)]);
let   score    = 0;

for (let rank of ranks) {
    switch (rank) {
        case 'Jack':
        case 'Queen':
        case 'King':
            score += 10;
            break;
        case 'Ace';
            score += (score &lt;= 11) ? 10 : 1;
            break;
        default:
            score += rank;
            break;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In Raku, <code>given</code> can be used like switch statements. There is no equivalent to <code>break</code> since <code>when</code> blocks are most commonly used like <code>case</code> statements. One major difference between <code>switch</code> and <code>given</code> is that a value passed to a <code>switch</code> statement will only match cases that are exactly equal to the value; <code>given</code> values are smartmatched (<code>~~</code>) against the <code>when</code> values.</p>
</div>
<div class="paragraph">
<p>在Raku中，<code>given`可以像switch语句一样使用。没有相应的，`break`因为`when`块最常用于`case`语句。`switch`和之间的一个主要区别`given`是传递给`switch`语句的值只匹配与值完全相等的情况; `given`值是</code>~~<code>针对值的smartmatched（）`when</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my     @ranklist = [2, 3, 4, 5, 6, 7, 8, 9, 'Jack', 'Queen', 'King', 'Ace'];
my     @ranks    = @ranklist.pick: 3;
my Int $score    = 0;

for @ranks -&gt; $rank {
    # The when blocks implicitly return the last statement they contain.
    $score += do given $rank {
        when 'Jack' | 'Queen' | 'King' { 10 }
        when 'Ace' { $score &lt;= 11 ?? 10 !! 1 }
        default { $_ }
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If there are multiple <code>when</code> blocks that match the value passed to <code>given</code> and you wish to run more than one of them, use <code>proceed</code>. <code>succeed</code> may be used to exit both the <code>when</code> block it&#8217;s in and the given block, preventing any following statements from being executed:</p>
</div>
<div class="paragraph">
<p>如果有多个`when`块与传递的值匹配，<code>given`并且您希望运行多个块，请使用`proceed</code>。`succeed`可用于退出`when`它所在的块和给定的块，防止执行以下任何语句：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given Int {
    when Int     { say 'Int is Int';     proceed }
    when Numeric { say 'Int is Numeric'; proceed }
    when Any     { say 'Int is Any';     succeed }
    when Mu      { say 'Int is Mu'               } # Won't output
}

=== OUTPUT:
=== Int is Int
=== Int is Numeric
=== Int is Any</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_for_while_and_dowhile">for, while, and do/while</h5>
<div class="paragraph">
<p>There are three different types of for loops in JavaScript:</p>
</div>
<div class="paragraph">
<p>JavaScript中有三种不同类型的for循环：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">// C-style for loops
const letters = {};
for (let ord = 0x61; ord &lt;= 0x7A; ord++) {
    let letter = String.fromCharCode(ord);
    letters[letter] = letter.toUpperCase();
}

// for..in loops (typically used on objects)
for (let letter in letters) {
    console.log(letters[letter]);
    # OUTPUT:
    # A
    # B
    # C
    # etc.
}

// for..of loops (typically used on arrays, maps, and sets)
for (let letter of Object.values(letters)) {
    console.log(letter);
    # OUTPUT:
    # A
    # B
    # C
    # etc.
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku <code>for</code> loops most closely resemble <code>for..of</code> loops, since they work on anything as long as it&#8217;s iterable. C-style loops are possible to write using <code>loop</code>, but this is discouraged since they&#8217;re better written as <code>for</code> loops using ranges. Like <code>if</code> statements, <code>for</code> may follow a statement, with the current iteration being accessible using the <code>$<em></code> variable (known as "it"). Methods on <code>$</em></code> may be called without specifying the variable:</p>
</div>
<div class="paragraph">
<p>Raku <code>for`循环最接近`for..of`循环，因为只要它是可迭代的，它们就可以处理任何东西。C风格的循环可以使用`loop</code>，但不鼓励这样做，因为它们更好地编写为`for`使用范围的循环。类似`if`语句，<code>for`可以遵循一个语句，当前迭代可以使用</code>$<em>`变量（称为“它”）访问。`$</em>`可以在不指定变量的情况下调用方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Str %letters{Str};
%letters{$_} = .uc for 'a'..'z';
.say for %letters.values;
=== OUTPUT:
=== A
=== B
=== C
=== etc.</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>while</code> loops work identically between JavaScript and Raku. Raku also has <code>until</code> loops, where instead of iterating until the given condition is false, they iterate until the condition is true.</p>
</div>
<div class="paragraph">
<p><code>do/while</code> loops are known as <code>repeat/while</code> loops in Raku. Likewise with <code>while</code>, <code>repeat/until</code> loops also exist and loop until the given condition is false.</p>
</div>
<div class="paragraph">
<p>To write infinite loops in Raku, use <code>loop</code> rather than <code>for</code> or <code>while</code>.</p>
</div>
<div class="paragraph">
<p>In JavaScript, <code>continue</code> is used to skip to the next iteration in a loop, and <code>break</code> is used to exit a loop early:</p>
</div>
<div class="paragraph">
<p>`while`循环在JavaScript和Raku之间的工作相同.Raku也有`until`循环，而不是迭代直到给定条件为假，它们迭代直到条件为真。</p>
</div>
<div class="paragraph">
<p><code>do/while`循环`repeat/while`在Raku 中称为循环。同样`while</code>，`repeat/until`循环也存在并循环，直到给定条件为假。</p>
</div>
<div class="paragraph">
<p>要在Raku中编写无限循环，请使用`loop`而不是`for`或`while`。</p>
</div>
<div class="paragraph">
<p>在JavaScript中，`continue`用于跳转到循环中的下一个迭代，并`break`用于提前退出循环：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">let primes = new Set();
let i      = 2;

do {
    let isPrime = true;
    for (let prime of primes) {
        if (i % prime == 0) {
            isPrime = false;
            break;
        }
    }
    if (!isPrime) continue;
    primes.add(i);
} while (++i &lt; 20);

console.log(primes); # OUTPUT: Set { 2, 3, 5, 7, 11, 13, 17, 19 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In Raku, these are known as <code>next</code> and <code>last</code> respectively. There is also <code>redo</code>, which repeats the current iteration without evaluating the loop&#8217;s condition again.</p>
</div>
<div class="paragraph">
<p><code>next</code>/<code>redo</code>/<code>last</code> statements may be followed by a label defined before an outer loop to make the statement work on the loop the label refers to, rather than the loop the statement is in:</p>
</div>
<div class="paragraph">
<p>在Raku中，这些分别称为`next`和`last`。还有`redo`，它重复当前迭代而不再评估循环的条件。</p>
</div>
<div class="paragraph">
<p><code>next</code>/ <code>redo</code>/ `last`语句后跟一个在外部循环之前定义的标签，以使该语句在标签所引用的循环上起作用，而不是该语句所在的循环：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %primes is SetHash;
my Int $i = 2;

OUTSIDE:
repeat {
    next OUTSIDE if $i %% $_ for %primes.keys;
    %primes{$i}++;
} while ++$i &lt; 20;

say %primes; # OUTPUT: SetHash(11 13 17 19 2 3 5 7)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_do">do</h5>
<div class="paragraph">
<p><code>do</code> is not currently a feature in JavaScript, however a proposal has been made to <a href="https://github.com/tc39/proposal-do-expressions">add it to ECMAScript</a>. <code>do</code> expressions evaluate a block and return the result:</p>
</div>
<div class="paragraph">
<p>`do`目前不是JavaScript中的一项功能，但已提出<a href="https://github.com/tc39/proposal-do-expressions">将其添加到ECMAScript</a>的提案。`do`表达式计算一个块并返回结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant VERSION        = v2.0.0;
constant VERSION_NUMBER = do {
    my @digits = VERSION.Str.comb(/\d+/);
    :16(sprintf "%02x%02x%04x", |@digits)
};
say VERSION_NUMBER; # OUTPUT: 33554432</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_types">10.1.5. Types</h4>
<div class="sect4">
<h5 id="_creating_types">Creating types</h5>
<div class="paragraph">
<p>In JavaScript, types are created by making a class (or a constructor in ES5 and earlier). If you&#8217;ve used TypeScript, you can define a type as a subset of other types like so:</p>
</div>
<div class="paragraph">
<p>在JavaScript中，通过创建类（或ES5及更早版本中的构造函数）来创建类型。如果您使用过TypeScript，则可以将类型定义为其他类型的子集，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">type ID = string | number;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In Raku, classes, roles, subsets, and enums are considered types. Creating classes and roles will be discussed in <a href="https://docs.raku.org/language/js-nutshell#Object-oriented_programming">the OOP section of this article</a>. Creating an ID subset can be done like so:</p>
</div>
<div class="paragraph">
<p>在Raku中，类，角色，子集和枚举被视为类型。创建类和角色将在本文<a href="https://docs.raku.org/language/js-nutshell#Object-oriented_programming">的OOP部分中讨论</a>。创建ID子集可以这样完成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset ID where Str | Int;</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the documentation on <a href="https://docs.raku.org/language/typesystem#subset">subset</a> and <a href="https://docs.raku.org/type/Junction">Junction</a> for more information.</p>
</div>
<div class="paragraph">
<p>TypeScript enums may have numbers or strings as their values. Defining the values is optional; by default, the value of the first key is 0, the next key, 1, the next, 2, etc. For example, here is an enum that defines directions for extended ASCII arrow symbols (perhaps for a TUI game):</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参阅<a href="https://docs.raku.org/language/typesystem#subset">子集</a>和<a href="https://docs.raku.org/type/Junction">连接</a>的文档。</p>
</div>
<div class="paragraph">
<p>TypeScript枚举可以包含数字或字符串作为其值。定义值是可选的; 默认情况下，第一个键的值为0，下一个键为1，下一个键为2，等等。例如，这是一个枚举，用于定义扩展ASCII箭头符号的方向（可能用于TUI游戏）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">enum Direction (
    UP    = '↑',
    DOWN  = '↓',
    LEFT  = '←',
    RIGHT = '→'
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Enums in Raku may have any type as their keys' values. Enum keys (and optionally, values) can be defined by writing <code>enum</code>, followed by the name of the enum, then the list of keys (and optionally, values), which can be done using <a href="https://docs.raku.org/language/quoting#Word_quoting%3A_%3C_%3E">&lt; &gt;</a>, <a href="https://docs.raku.org/language/quoting#Word_quoting_with_interpolation_and_quote_protection%3A_%C2%AB_%C2%BB">« »</a>, or <a href="https://docs.raku.org/language/operators#term_%28_%29">( )</a>. <code>( )</code> must be used if you want to define values for the enum&#8217;s keys. Here is the Direction enum as written in Raku:</p>
</div>
<div class="paragraph">
<p>Raku中的枚举可以使用任何类型作为其键值。枚举键（以及可选的值）可以通过写入来定义`enum`，然后是枚举的名称，然后是键列表（以及可选的值），可以使用<a href="https://docs.raku.org/language/quoting#Word_quoting%3A_%3C_%3E">&lt;&gt;</a>，<a href="https://docs.raku.org/language/quoting#Word_quoting_with_interpolation_and_quote_protection%3A_%C2%AB_%C2%BB">«»</a>或<a href="https://docs.raku.org/language/operators#term_%28_%29">（）来完成</a>。`( )`如果要为枚举键定义值，则必须使用。这是Raku中编写的Direction枚举：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Direction (
    UP    =&gt; '↑',
    DOWN  =&gt; '↓',
    LEFT  =&gt; '←',
    RIGHT =&gt; '→'
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the documentation on <a href="https://docs.raku.org/language/typesystem#enum">enum</a> for more information.</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参阅<a href="https://docs.raku.org/language/typesystem#enum">枚举</a>文档。</p>
</div>
</div>
<div class="sect4">
<h5 id="_using_types">Using types</h5>
<div class="paragraph">
<p>In TypeScript, you can define the type of variables. Attempting to assign a value that doesn&#8217;t match the type of the variable will make the transpiler error out. This is done like so:</p>
</div>
<div class="paragraph">
<p>在TypeScript中，您可以定义变量的类型。尝试分配与变量类型不匹配的值将导致转换器错误。这样做是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">enum Name (Phoebe, Daniel, Joe);
let name: string = 'Phoebe';
name = Phoebe; # Causes tsc to error out

let hobbies: [string] = ['origami', 'playing instruments', 'programming'];

let todo: Map&lt;string, boolean&gt; = new Map([
    ['clean the bathroom', false],
    ['walk the dog', true],
    ['wash the dishes', true]
]);

let doJob: (job: string) =&gt; boolean = function (job: string): boolean {
    todo.set(job, true);
    return true;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In Raku, variables can be typed by placing the type between the declarator (<code>my</code>, <code>our</code>, etc.) and the variable name. Assigning a value that doesn&#8217;t match the variable&#8217;s type will throw either a compile-time or runtime error, depending on how the value is evaluated:</p>
</div>
<div class="paragraph">
<p>在Raku中，变量可以通过将说明符（之间的类型被键入`my`，`our`等）和变量名。分配与变量类型不匹配的值将引发编译时或运行时错误，具体取决于值的计算方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Name &lt;Phoebe Daniel Joe&gt;;
my Str $name = 'Phoebe';
$name = Phoebe; # Throws a compile-time error

=== The type here defines the type of the elements of the array.
my Str @hobbies = ['origami', 'playing instruments', 'programming'];

=== The type between the declarator and variable defines the type of the values
=== of the hash.
=== The type in the curly braces defines the type of the keys of the hash.
my Bool %todo{Str} = (
    'clean the bathroom' =&gt; False,
    'walk the dog'       =&gt; True,
    'wash the dishes'    =&gt; True
);

=== The type here defines the return value of the routine.
my Bool &amp;do-job = sub (Str $job --&gt; Bool) {
    %todo{$job} = True;
};</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_比较_javascript_和_raku_的类型">比较 JavaScript 和 Raku 的类型</h5>
<div class="paragraph">
<p>Here is a table of some JavaScript types and their equivalents in Raku:</p>
</div>
<div class="paragraph">
<p>以下是Raku中一些JavaScript类型及其等价物的表格：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JavaScript</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Raku</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mu, Any, Hash</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List, Array, Seq</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Str</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int, Num, Rat</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Map</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Map, Hash</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set, SetHash</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><code>Object</code> is both a superclass of all types in JavaScript and a way to create a hash. In Raku, <a href="https://docs.raku.org/type/Mu">Mu</a> is a superclass of all types, though usually you want to use <a href="https://docs.raku.org/type/Any">Any</a> instead, which is a subclass of <code>Mu</code> but also a superclass of nearly every type, with <a href="https://docs.raku.org/type/Junction">Junction</a> being an exception. When using <code>Object</code> as a hash, <a href="https://docs.raku.org/type/Hash">Hash</a> is what you want to use.</p>
</div>
<div class="paragraph">
<p>There are three types equivalent to <code>Array</code>. <a href="https://docs.raku.org/type/Array">Array</a> is most similar to <code>Array</code>, since it acts as a mutable array. <a href="https://docs.raku.org/type/List">List</a> is similar to <code>Array</code>, but is immutable. <a href="https://docs.raku.org/type/Seq">Seq</a> is used to create lazy arrays.</p>
</div>
<div class="paragraph">
<p><code>String</code> and <a href="https://docs.raku.org/type/Str">Str</a> are for the most part used identically.</p>
</div>
<div class="paragraph">
<p>There are several different types in Raku equivalent to <code>Number</code>, but the three you&#8217;ll most commonly see are <a href="https://docs.raku.org/type/Int">Int</a>, <a href="https://docs.raku.org/type/Num">Num</a>, and <a href="https://docs.raku.org/type/Rat">Rat</a>. <code>Int`represents an integer. `Num</code> represents a floating-point number, making it the most similar to <code>Number</code>. <code>Rat</code> represents a fraction of two numbers, and is used when <code>Num</code> cannot provide precise enough values.</p>
</div>
<div class="paragraph">
<p><code>Boolean</code> and <a href="https://docs.raku.org/type/Bool">Bool</a> are for the most part used identically.</p>
</div>
<div class="paragraph">
<p><code>Map</code> has both a mutable and an immutable equivalent in Raku. <a href="https://docs.raku.org/type/Map">Map</a> is the immutable one, and <a href="https://docs.raku.org/type/Hash">Hash</a> is the mutable one. Don&#8217;t get them mixed up! Like <code>Map</code> in JavaScript, <code>Map</code> and <code>Hash</code> can have any type of key or value, not just strings for keys.</p>
</div>
<div class="paragraph">
<p>Like <code>Map</code>, <code>Set</code> also has both a mutable and an immutable equivalent in Raku. <a href="https://docs.raku.org/type/Set">Set</a> is the immutable one, and <a href="https://docs.raku.org/type/SetHash">SetHash</a> is the mutable one.</p>
</div>
<div class="paragraph">
<p><code>Object`既是JavaScript中所有类型的超类，也是创建哈希的方法。在Raku中，<a href="https://docs.raku.org/type/Mu">穆</a>是所有类型的超类，尽管通常要使用<a href="https://docs.raku.org/type/Any">任何</a>代替，这是的一个子类`Mu</code>，而且几乎所有类型的超类，与<a href="https://docs.raku.org/type/Junction">接线</a>是一个例外。当`Object`用作哈希时，<a href="https://docs.raku.org/type/Hash">哈希</a>就是你想要使用的。</p>
</div>
<div class="paragraph">
<p>有三种类型相当于`Array`。<a href="https://docs.raku.org/type/Array">数组</a>最相似`Array`，因为它充当可变数组。<a href="https://docs.raku.org/type/List">列表</a>类似于`Array`，但是是不可变的。<a href="https://docs.raku.org/type/Seq">Seq</a>用于创建惰性数组。</p>
</div>
<div class="paragraph">
<p>`String`和<a href="https://docs.raku.org/type/Str">Str</a>在大多数情况下使用相同。</p>
</div>
<div class="paragraph">
<p>Raku中有几种不同的类型相当于`Number`，但你最常见的三种是<a href="https://docs.raku.org/type/Int">Int</a>，<a href="https://docs.raku.org/type/Num">Num</a>和<a href="https://docs.raku.org/type/Rat">Rat</a>。<code>Int`表示整数。`Num`表示一个浮点数，使其最相似`Number</code>。`Rat`表示两个数字的一小部分，并且在`Num`无法提供足够精确的值时使用。</p>
</div>
<div class="paragraph">
<p>`Boolean`和<a href="https://docs.raku.org/type/Bool">Bool</a>在大多数情况下使用相同。</p>
</div>
<div class="paragraph">
<p>`Map`既具有可变的，并且在Raku的不可变等效<a href="https://docs.raku.org/type/Map">地图</a>是不可变的一个，并且<a href="https://docs.raku.org/type/Hash">哈希</a>是可变的一个。不要混淆他们！就像`Map`在JavaScript中，`Map`并且`Hash`可以有任何类型的键或值，而不仅仅是钥匙串。</p>
</div>
<div class="paragraph">
<p>像`Map`，`Set`也都一个可变的和Raku中一个不变的等效<a href="https://docs.raku.org/type/Set">设置</a>是不可变的一个，并且<a href="https://docs.raku.org/type/SetHash">SetHash</a>是可变的。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_函数_2">10.1.6. 函数</h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_面向对象编程">10.2. 面向对象编程</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="_异步编程">10.3. 异步编程</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="_网络_api">10.4. 网络 API</h3>
<div class="sect3">
<h4 id="_网络">10.4.1. 网络</h4>
<div class="paragraph">
<p>In Raku, there are two APIs for dealing with networking: <code>IO::Socket::INET</code> (for synchronous networking), and <code>IO::Socket::Async</code> (for asynchronous networking).</p>
</div>
<div class="paragraph">
<p><code>IO::Socket::INET</code> currently only supports TCP connections. Its API resembles that of C&#8217;s socket API. If you&#8217;re familiar with that, then it won&#8217;t take long to understand how to use it. For example, here&#8217;s an echo server that closes the connection after receiving its first message:</p>
</div>
<div class="paragraph">
<p>在Raku中，有两个用于处理网络的API :( <code>IO::Socket::INET`用于同步网络）和`IO::Socket::Async</code>（用于异步网络）。</p>
</div>
<div class="paragraph">
<p>`IO::Socket::INET`目前只支持TCP连接。它的API类似于C的套接字API。如果您熟悉它，那么理解如何使用它不会花费很长时间。例如，这是一个echo服务器，它在收到第一条消息后关闭连接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my IO::Socket::INET $server .= new:
    :localhost&lt;localhost&gt;,
    :localport&lt;8000&gt;,
    :listen;

my IO::Socket::INET $client .= new: :host&lt;localhost&gt;, :port&lt;8000&gt;;
$client.print: 'Hello, world!';

my IO::Socket::INET $conn = $server.accept;
my Str $msg               = $conn.recv;
say $msg; # OUTPUT: Hello, world!
$conn.print($msg);

say $client.recv; # OUTPUT: Hello, world!
$conn.close;
$client.close;
$server.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, <code>IO::Socket::INET</code> connections are IPv4 only. To use IPv6 instead, pass <code>:family(PF_INET6)</code> when constructing a server or a client.</p>
</div>
<div class="paragraph">
<p>In contrast, <code>IO::Socket::Async</code> supports both IPv4 and IPv6 without the need to specify which family you wish to use. It also supports UDP sockets. Here&#8217;s how you would write the same echo server as above asynchronously (note that <code>Supply.tap</code> is multithreaded; if this is undesirable, use <code>Supply.act</code> instead:</p>
</div>
<div class="paragraph">
<p>默认情况下，<code>IO::Socket::INET`连接仅限IPv4。要使用IPv6，请</code>:family(PF_INET6)`在构建服务器或客户端时传递。</p>
</div>
<div class="paragraph">
<p>相反，`IO::Socket::Async`支持IPv4和IPv6，无需指定要使用的族。它还支持UDP套接字。以下是如何异步编写与上面相同的echo服务器（请注意，这`Supply.tap`是多线程的;如果这是不合需要的，请`Supply.act`改用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = IO::Socket::Async.listen('localhost', 8000);
my $server = $supply.tap(-&gt; $conn {
    $conn.Supply.tap(-&gt; $data {
        say $data; # OUTPUT: Hello, world!
        await $conn.print: $data;
        $conn.close;
    })
});

my $client = await IO::Socket::Async.connect('localhost', 8000);
$client.Supply.tap(-&gt; $data {
    say $data; # OUTPUT: Hello, world!
    $client.close;
    $server.close;
});

await $client.print: 'Hello, world!';</code></pre>
</div>
</div>
<div class="paragraph">
<p>The equivalent code in Node.js looks like this:</p>
</div>
<div class="paragraph">
<p>Node.js中的等效代码如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">const net = require('net');

const server = net.createServer(conn =&gt; {
    conn.setEncoding('utf8');
    conn.on('data', data =&gt; {
        console.log(data); # OUTPUT: Hello, world!
        conn.write(data);
        conn.end();
    });
}).listen(8000, 'localhost');

const client = net.createConnection(8000, 'localhost', () =&gt; {
    client.setEncoding('utf8');
    client.on('data', data =&gt; {
        console.log(data); # OUTPUT: Hello, world!
        client.end();
        server.close();
    });
    client.write("Hello, world!");
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_httphttps">10.4.2. HTTP/HTTPS</h4>
<div class="paragraph">
<p>Raku doesn&#8217;t natively support HTTP/HTTPS. However, CPAN packages such as <a href="https://cro.services/">Cro</a> help fill the gap.</p>
</div>
<div class="paragraph">
<p>Raku本身不支持HTTP / HTTPS。然而，像<a href="https://cro.services/">Cro</a>这样的CPAN包填补了这个空白。</p>
</div>
</div>
<div class="sect3">
<h4 id="_dns">10.4.3. DNS</h4>
<div class="paragraph">
<p>Raku does not currently support the majority of the features that Node.js&#8217;s DNS module implements. <code>IO::Socket::INET</code> and <code>IO::Socket::Async</code> can resolve hostnames, but features like resolving DNS records and reverse IP lookups are not implemented yet. There are some modules that are a work in progress, such as <a href="https://github.com/tbrowder/Net-DNS-BIND-Manage-Raku/">Net::DNS::BIND::Manage</a>, that aim to improve DNS support.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Raku目前不支持Node.js的DNS模块实现的大多数功能。`IO::Socket::INET`并且`IO::Socket::Async`可以解析主机名，但尚未实现解析DNS记录和反向IP查找等功能。有些模块正在进行中，例如link:https://github.com/tbrowder/Net-DNS-BIND-Manage-Raku/[Net </dt>
<dd>
<p>DNS :: BIND :: Manage]，旨在改善DNS支持。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_punycode">10.4.4. Punycode</h4>
<div class="paragraph">
<p>Punycode support is available through the <a href="https://github.com/Kaiepi/p6-Net-LibIDN">Net::LibIDN</a>, <a href="https://github.com/Kaiepi/p6-Net-LibIDN2">Net::LibIDN2</a>, and <a href="https://github.com/FROGGS/p6-IDNA-Punycode">IDNA::Punycode</a> modules on CPAN.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">通过CPAN上的link:https://github.com/Kaiepi/p6-Net-LibIDN[Net </dt>
<dd>
<p>LibIDN]，<a href="https://github.com/Kaiepi/p6-Net-LibIDN2">Net :: LibIDN2</a>和<a href="https://github.com/FROGGS/p6-IDNA-Punycode">IDNA :: Punycode</a>模块可以获得Punycode支持。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_文件系统_api">10.5. 文件系统 API</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect2">
<h3 id="_模块和包">10.6. 模块和包</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_python_到_raku_简而言之">11. Python 到 Raku - 简而言之</h2>
<div class="sectionbody">
<div class="paragraph">
<p>此页面试图为来自 Python 背景的人们提供学习 Raku 的方法。我们在 Raku 中讨论了许多 Python 构造和惯用法的等价语法。</p>
</div>
<div class="sect2">
<h3 id="_基本语法">11.1. 基本语法</h3>
<div class="sect3">
<h4 id="_hello_world_2">11.1.1. Hello, world</h4>
<div class="paragraph">
<p>让我们从打印 "Hello, world!" 开始吧。 Raku 中的 <a href="https://docs.raku.org/routine/put">put</a> 关键字相当于 Python 中的 <a href="https://docs.raku.org/routine/print">print</a>。与 Python 2 一样，括号是可选的。换行符添加到行尾。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python 2</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">print "Hello, world!"</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Python 3</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">print("Hello, world!")</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put "Hello, world!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有 <a href="https://docs.raku.org/routine/say">say</a> 关键字，其行为类似，但会调用其参数的 <a href="https://docs.raku.org/routine/gist">gist</a> 方法。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $hello = "Hello, world!";
say $hello;  # also prints "Hello, world!"
             # same as: put $hello.gist</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Python 中 <code>'</code> 和 <code>"</code> 是可互换的。在 Raku 中两者都可用于引用, 但双引号(<code>"</code>)表示应该进行插值。例如, 以 <code>$</code> 开头的变量和包含在花括号中的表达式会被插值。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $planet = 'earth';
say "Hello, $planet";   # Hello, earth
say 'Hello, $planet';   # Hello, $planet
say "Hello, planet number { 1 + 2 }"; # Hello, planet number 3</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_语句分隔符">11.1.2. 语句分隔符</h4>
<div class="paragraph">
<p>在 Python 中，换行符表示语句的结束。有一些例外：换行符之前的反斜杠继续跨行语句。此外，如果有一个不匹配的开括号，方括号或花括号，则该语句将继续跨行，直到匹配的花括号被关闭。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，分号表示语句的结束。如果分号是块的最后一个语句，则可以省略分号。如果有一个结束花括号后跟换行符，也可以省略分号。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">print 1 + 2 + \
    3 + 4
print ( 1 +
    2 )</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1 + 2 +
    3 + 4;
say 1 +
    2;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_块儿">11.1.3. 块儿</h4>
<div class="paragraph">
<p>在 Python 中，缩进用于表示块。 Raku 使用花括号表示块儿。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">if 1 == 2:
    print "Wait, what?"
else:
    print "1 is not 2."</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 1 == 2 {
    say "Wait, what?"
} else {
    say "1 is not 2."
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于条件句中的表达式，括号在两种语言中都是可选的，如上所示。</p>
</div>
</div>
<div class="sect3">
<h4 id="_变量_3">11.1.4. 变量</h4>
<div class="paragraph">
<p>在 Python 中，变量是同时声明和初始化的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">foo = 12
bar = 19</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中，<code>my</code> 声明符声明了一个词法变量。变量可以用 <code>=</code> 初始化。此变量可以先声明，然后再初始化或声明并立即初始化。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $foo;       # declare
$foo = 12;     # initialize
my $bar = 19;  # both at once</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，你可能已经注意到，Raku 中的变量通常以符号开头 - 符号表示其容器的类型。 以 <code>$</code> 开头的变量持有标量。 以 <code>@</code> 开头的变量持有数组和以 <code>%</code> 开头的变量持有一个 hash(dict)。 如果用 <code>\</code> 声明它们，则不可变变量可以是无符号的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">s = 10
l = [1, 2, 3]
d = { a : 12, b : 99 }

print s
print l[2]
print d['a']
# 10, 2, 12</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = 10;
my @l = 1, 2, 3;
my %d = a =&gt; 12, b =&gt; 99;
my \x = 99;

say $s;
say @l[1];
say %d&lt;a&gt;;  # or %d{'a'}
say x;
# 10, 2, 12, 99</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_作用域">11.1.5. 作用域</h4>
<div class="paragraph">
<p>在 Python 中，函数和类创建一个新的作用域，但没有其他的块构造函数（例如循环，条件）创建一个作用域。在 Python 2 中，列表推导不会创建新的作用域，但在 Python 3 中，它们创建新的作用域。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，每个块都创建了一个词法作用域</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">if True:
    x = 10
print x
# x is now 10</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if True {
    my $x = 10
}
say $x
# error, $x is not declared in this scope</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;
if True {
    $x = 10
}
say $x
# ok, $x is 10</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">x = 10
for x in 1, 2, 3:
   pass
print x
# x is 3</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my \x = 10;
for 1, 2, 3 -&gt; \x {
    # do nothing
    }
say x;
# x is 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Python 中的 Lambdas 可以在 Raku 中写为块或尖号块。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">l = lambda i: i + 12</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $l = -&gt; $i { $i + 12 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>构建 lambdas 的另一个Raku 惯用法是使用 Whatever star, <code>*</code>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $l = * + 12    # same as above</code></pre>
</div>
</div>
<div class="paragraph">
<p>表达式中的 <code><strong></code> 将成为参数的占位符，并在编译时将表达式转换为 lambda。 表达式中的每个 <code></strong></code> 都是一个单独的位置参数。</p>
</div>
<div class="paragraph">
<p>有关子例程和块的更多结构，请参阅以下部分。</p>
</div>
<div class="paragraph">
<p>另一个例子(来自Python <a href="https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result">FAQ</a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">squares = []
for x in range(5):
    squares.append(lambda: x ** 2)
print squareslink:[2]
print squareslink:[4]
# both 16 since there is only one x</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my \squares = [];
for ^5 -&gt; \x {
    squares.append({ x² });
}
say squareslink:[2];
say squareslink:[4];
# 4, 16 since each loop iteration has a lexically scoped x,</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，<code>^N</code> 类似于 <code>range(N)</code>。 类似地，<code>N..^M</code> 的作用类似于 <code>range(N,M)</code>（从 N 到 M-1 的列表）。 范围 <code>N..M</code> 是从 N 到 M 的列表。<code>..</code> 之前或之后的 <code>^</code> 表示应排除列表的开始或结束端点（或两者都）。</p>
</div>
<div class="paragraph">
<p>另外，<code>x²</code> 是一种编写 <code>x ** 2</code> 的可爱方式（也可以正常工作）; unicode 上标 2 是一个数字。 许多其他 unicode 运算符正如你所期望的那样工作(指数, 分数, π)，但是可以在 Raku 中使用的每个 unicode 运算符或符号都具有 ASCII 等价物。</p>
</div>
</div>
<div class="sect3">
<h4 id="_控制流">11.1.6. 控制流</h4>
<div class="paragraph">
<p>Python 有 <code>for</code> 循环和 <code>while</code> 循环:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">for i in 1, 2:
    print i
j = 1
while j &lt; 3:
    print j
    j += 1

# 1,2,1,2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 也有 <code>for</code> 循环和 <code>while</code> 循环:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 1, 2 -&gt; $i {
    say $i
}
my $j = 1;
while $j &lt; 3 {
    say $j;
    $j += 1
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>(Raku 还有一些循环结构：<code>repeat &#8230;&#8203; until</code>，<code>repeat &#8230;&#8203; while</code>，<code>until</code> 和 <code>loop</code>。)</p>
</div>
<div class="paragraph">
<p><code>last</code> 在 Raku 中退出一个循环，类似于 Python 中的 <code>break</code>。 Python 中的 <code>continue</code> 在 Raku 中是 <code>next</code>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">for i in range(10):
    if i == 3:
        continue
    if i == 5:
        break
    print i</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for ^10 -&gt; $i {
    next if $i == 3;
    last if $i == 5;
    say $i;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>if</code> 作为语句修饰符(如上所述)在 Raku 中是可接受的，甚至在列表解析之外也可以。</p>
</div>
<div class="paragraph">
<p>Python <code>for</code> 循环中的 <code>yield</code> 语句生成一个 <code>generator</code>，就像 Raku 中的 <code>gather/take</code> 构造一样。这两个都打印 1,2,3。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def count():
    for i in 1, 2, 3:
        yield i

for c in count():
    print c</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub count {
    gather {
        for 1, 2, 3 -&gt; $i {
            take $i
        }
    }
}

for count() -&gt; $c {
    say $c;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_lambdas_函数和子例程">11.1.7. Lambdas， 函数和子例程</h4>
<div class="paragraph">
<p>在 Python 中用 <code>def</code> 声明的函数（子例程）在 Raku 中是用 <code>sub</code> 来完成的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">def add(a, b):
    return a + b

sub add(\a, \b) {
    return a + b
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>return</code> 是可选的; 最后一个表达式的值被用作返回值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add(\a, \b) {
    a + b
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># using variables with sigils
sub add($a, $b) {
    $a + $b
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用位置参数或关键字参数调用 Python 2 函数。这些是由调用者决定的。在 Python 3 中，一些参数可能是"keyword only"的。在 Raku 中，位置参数和命名参数由例程的签名确定。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def speak(word, times):
    for i in range(times):
        print word
speak('hi', 2)
speak(word='hi', times=2)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>位置参数</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub speak($word, $times) {
  say $word for ^$times
}
speak('hi', 2);</code></pre>
</div>
</div>
<div class="paragraph">
<p>以冒号开头的命名参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub speak(:$word, :$times) {
  say $word for ^$times
}
speak(word =&gt; 'hi', times =&gt; 2);
speak(:word&lt;hi&gt;, :times&lt;2&gt;);      # Alternative, more idiomatic</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 支持多重分派，因此可以通过将例程声明为 <code>multi</code> 来提供多个签名。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub speak($word, $times) {
  say $word for ^$times
}
multi sub speak(:$word, :$times) {
    speak($word, $times);
}
speak('hi', 2);
speak(:word&lt;hi&gt;, :times&lt;2&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用多种格式发送命名参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub hello {...};
# all the same
hello(name =&gt; 'world'); # fat arrow syntax
hello(:name('world'));  # pair constructor
hello :name&lt;world&gt;;     # &lt;&gt; quotes words and makes a list
my $name = 'world';
hello(:$name);          # lexical var with the same name</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建匿名函数可以使用带有块或尖号块的 <code>sub</code> 来完成。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">square = lambda x: x ** 2</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $square = sub ($x) { $x ** 2 };  # anonymous sub
my $square = -&gt; $x { $x ** 2 };     # pointy block
my $square = { $^x ** 2 };          # placeholder variable
my $square = { $_ ** 2 };           # topic variable</code></pre>
</div>
</div>
<div class="paragraph">
<p>占位符变量按字典顺序排列以形成位置参数。 因此这些是相同的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $power = { $^x ** $^y };
my $power = -&gt; $x, $y { $x ** $y };</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_列表解析">11.1.8. 列表解析</h4>
<div class="paragraph">
<p>可以组合 Postfix 语句修饰符和块以在 Raku 中轻松创建列表解析。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">print [ i * 2 for i in 3, 9 ]                      # OUTPUT: «[6, 18]␤»</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ( $_ * 2 for 3, 9 );                           # OUTPUT: «(6 18)␤»
say ( { $^i * 2 } for 3, 9 );                      # OUTPUT: «(6 18)␤»
say ( -&gt; \i { i * 2 } for 3, 9 );                  # OUTPUT: «(6 18)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以应用条件，但 <code>if</code> 关键字首先出现，而不像 Python 那样，<code>if</code> 是第二个出现。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">print [ x * 2 for x in 1, 2, 3 if x &gt; 1 ]          # OUTPUT: «[4, 6]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>vs</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ( $_ * 2 if $_ &gt; 1 for 1, 2, 3 );              # OUTPUT: «(4 6)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于嵌套循环，交叉乘积运算符 <code>X</code> 将会有帮助：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">print [ i + j for i in 3,9 for j in 2,10 ]         # OUTPUT: «[5, 13, 11, 19]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>变成以下任何一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ( { $_[0] + $_[1] } for (3,9) X (2,10) );      # OUTPUT: «(5 13 11 19)␤»
say ( -&gt; (\i, \j) { i + j } for (3,9) X (2,10) );  # OUTPUT: «(5 13 11 19)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>map</code>（就像 Python 的 <code>map</code> 一样）和 <code>grep</code>（就像 Python 的 <code>filter</code> 一样）是另一种选择。</p>
</div>
</div>
<div class="sect3">
<h4 id="_类和对象">11.1.9. 类和对象</h4>
<div class="paragraph">
<p>这是 Python <a href="https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables">文档</a>中的一个示例。首先让我们回顾一下"实例变量"，这些变量在 Raku 中称为属性:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Dog:
    def __init__(self, name):
        self.name = name</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Dog {
    has $.name;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于每个创建的类，Raku 默认提供构造函数方法 <code>new</code>，它接受命名参数。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">d = Dog('Fido')
e = Dog('Buddy')
print d.name
print e.name</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $d = Dog.new(:name&lt;Fido&gt;); # or: Dog.new(name =&gt; 'Fido')
my $e = Dog.new(:name&lt;Buddy&gt;);
say $d.name;
say $e.name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 中的类属性可以通过几种方式声明。一种方法是仅声明一个词法变量和一个访问它的方法。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Dog:
    kind = 'canine'                # class attribute
    def __init__(self, name):
        self.name = name           # instance attribute
d = Dog('Fido')
e = Dog('Buddy')
print d.kind
print e.kind
print d.name
print e.name</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Dog {
    my $kind = 'canine';           # class attribute
    method kind { $kind }
    has $.name;                    # instance attribute
}

my $d = Dog.new(:name&lt;Fido&gt;);
my $e = Dog.new(:name&lt;Buddy&gt;);
say $d.kind;
say $e.kind;
say $d.name;
say $e.name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了在 Raku 中改变属性，必须在属性上使用 <code>is rw</code> trait：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Dog:
    def __init__(self, name):
        self.name = name
d = Dog()
d.name = 'rover'</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Dog {
    has $.name is rw;
}
my $d = Dog.new;
$d.name = 'rover';</code></pre>
</div>
</div>
<div class="paragraph">
<p>继承使用 <code>is</code> 来完成:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Animal:
    def jump(self):
        print ("I am jumping")

class Dog(Animal):
    pass

d = Dog()
d.jump()</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Animal {
    method jump {
        say "I am jumping"
    }
}

class Dog is Animal {
}

my $d = Dog.new;
$d.jump;</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据需要多次使用 <code>is</code> trait 可以实现多重继承。或者，它可以与 <code>also</code> 关键字一起使用。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Dog(Animal, Friend, Pet):
    pass</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Animal {}; class Friend {}; class Pet {};
...;
class Dog is Animal is Friend is Pet {};</code></pre>
</div>
</div>
<div class="paragraph">
<p>或</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Animal {}; class Friend {}; class Pet {};
...;
class Dog is Animal {
    also is Friend;
    also is Pet;
    ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_装饰器">11.1.10. 装饰器</h4>
<div class="paragraph">
<p>Python 中的装饰器是一种将函数包装在另一个函数中的方法。在 Raku 中，这是通过 <code>wrap</code> 完成的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Python</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def greeter(f):
    def new():
        print 'hello'
        f()
    return new

@greeter
def world():
    print 'world'

world();</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub world {
    say 'world'
}

&amp;world.wrap(sub () {
    say 'hello';
    callsame;
});

world;</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种方法是使用 trait：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># declare the trait 'greeter'
multi sub trait_mod:&lt;is&gt;(Routine $r, :$greeter) {
    $r.wrap(sub {
        say 'hello';
        callsame;
    })
}

sub world is greeter {
    say 'world';
}

world;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_上下文管理">11.1.11. 上下文管理</h4>
<div class="paragraph">
<p>Python 中的上下文管理器声明了在进入或退出作用域时发生的操作。</p>
</div>
<div class="paragraph">
<p>这是一个 Python 上下文管理器，可以打印字符串&#8217;hello'，'world&#8217;和&#8217;bye'。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class hello:
    def __exit__(self, type, value, traceback):
        print 'bye'
    def __enter__(self):
        print 'hello'

with hello():
    print 'world'</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 "enter" 和 "exit" 事件，将块作为参数传递将是一种方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub hello(Block $b) {
    say 'hello';
    $b();
    say 'bye';
}

hello {
    say 'world';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个相关的想法是&#8217;<a href="https://docs.raku.org/language/phasers">Phasers</a>'，它可以设置为在进入或离开一个区块时运行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    LEAVE say 'bye';
    ENTER say 'hello';
    say 'world';
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_input">11.1.12. input</h4>
<div class="paragraph">
<p>在 Python 3 中，<code>input</code> 关键字用于提示用户。可以为此关键字提供可选参数，该参数将写入标准输出而不带尾随换行符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">user_input = input("Say hi → ")
print(user_input)</code></pre>
</div>
</div>
<div class="paragraph">
<p>出现提示时，您可以输入 <code>Hi</code> 或任何其他字符串，这些字符串将存储在 <code>user_input</code> 变量中。这类似于 Raku 中的 <a href="https://docs.raku.org/routine/prompt">prompt</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $user_input = prompt("Say hi → ");
say $user_input; # OUTPUT: whatever you entered.</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ruby_到_raku">12. Ruby 到 Raku</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_基本语法_2">12.1. 基本语法</h3>
<div class="sect3">
<h4 id="_语句结束分号">12.1.1. 语句结束分号</h4>
<div class="paragraph">
<p>Ruby 使用换行(有几个例外)来探测大部分语句的结束, 只要表达式已经完成。通过把运算符挂在行的末尾以保证解析会继续而打断一个长的表达式的做法很常见:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">foo +     # 在 Ruby  中结尾的运算符意味着解析会继续
  bar +
  baz</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中你必须显式地使用 <code>;</code> 来结束语句, 这允许更好的反馈和更灵活的断行。有两个例外不需要显式的 <code>;</code>,  块儿中的最后一条语句, 在块自身的闭合花括号<strong>之后</strong>(如果那一行上没有任何其它东西):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 5 &lt; $x &lt; 10 {
    say "Yep!";
    $x = 17     # 在闭合花括号 } 之前不需要分号 ;
}               # 因为换行, 在闭合花括号 } 之后不需要分号 ;
say "Done!";    # 如果后面什么也没有, 那么这儿的分号也不需要</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_空白_2">12.1.2. 空白</h4>
<div class="paragraph">
<p>Ruby 中允许使用大量令人吃惊的灵活的空白, 即使在开启了严格模式和警告的情况下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby"># 不符合习惯但是在 Ruby 中是合法的
puts"Hello "+
(people [ i]
    . name
    ) . upcase+"!"if$greeted[i]&lt;1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Perl  6 也遵从程序员的自由和创造力，但是平衡的语法灵活性与其设计目标是一致的---确定性的，可扩展的语法，支持单程解析和有用的错误消息，组合功能，如利落地自定义运算符，不会导致程序员意外弄错他们的意图。 此外，不再强调 "代码高尔夫"; Raku 在概念上更为简洁, 而不是在少敲了几次键上。</p>
</div>
<div class="paragraph">
<p>因此，在语法中有很多地方，在 Ruby 中空格是可选的但是在 Raku 中却是强制的或禁止的。许多这些限制不太可能涉及很多现实的 Perl 代码（例如，在数组变量和它的方括号之间不允许有空格 ），但不幸的是有一些与某些 Ruby 黑客的习惯编码风格冲突：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在参数列表的开括号「<code>(</code>」之前不允许有空格</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">foo (3, 4, 1); # 在 Ruby 或 Raku 中都不正确 ( 在 Raku 中这会
               # 尝试为 foo 传递一个 List 类型的单个参数)
foo(3, 4, 1);  # Ruby 和 Raku 中都可以
foo 3, 4, 1;   # Ruby 和 Raku 中都可以 - 圆括号是可供选择的-less style</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>关键字后面立刻需要跟着空格</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if(a &lt; 0); ...; end         # OK in Ruby
if ($a &lt; 0) { ... }         # Raku
if $a &lt; 0   { ... }         # Raku, 更地道

while(x &gt; 5); ...; end      # OK in Ruby
while ($x &gt; 5) { ... }      # Raku
while $x &gt; 5   { ... }      # Raku, 更地道</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>后缀/后环缀 操作符(包括数组/散列下标)前面不允许有空格。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">seen [ :fish ] = 1    # Ruby, 不地道, 但是允许这样写
%seen&lt; fish &gt; = 1;    # Raku, 'seen' 后面不允许出现空格</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>中缀操作符之前需要空格, 如果它和已经存在的后缀/后环缀 操作符冲突的话。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">n&lt;1     # Ruby (in Raku this would conflict with postcircumfix &lt; &gt;)
$n &lt; 1; # Raku</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_方法调用_send">12.1.3. 方法调用, .send</h4>
<div class="paragraph">
<p>方法调用使用点语法, 就像 Ruby 那样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">person.name    # Ruby
$person.name   # Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>要调用一个直到运行时才直到名字的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">object.send(methodname, args);  # Ruby
$object."$methodname"(@args);   # Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你遗漏了双引号, 那么 Raku 会期望 <code>$methodname</code> 包含一个 <code>Method</code> 对象, 而不是单单是那个方法名的字符串表示。</p>
</div>
</div>
<div class="sect3">
<h4 id="_变量符号作用域_和通用类型">12.1.4. 变量、符号、作用域 和通用类型</h4>
<div class="paragraph">
<p>在 Ruby 中，变量主要使用 sigils 指示作用域。 <code>$</code> 用于全局作用域，<code>@@</code> 用于类作用域，<code>@</code> 用作实例作用域，无符号用于局部变量（包括参数）。 <code>&amp;</code> 符号也用于表示方法引用。符号的前缀为 <code>:</code>，但它们不是可变的，所以不是真正的符号。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，符号主要用于指代包含的值实现的角色，表明值的类型（或至少接口）。 符号是不变的，不管变量是如何使用的 - 你可以把它们看作变量名的一部分。</p>
</div>
<div class="paragraph">
<p>变量的作用域改为由声明本身（my，has，our，etc）表示。</p>
</div>
<div class="sect4">
<h5 id="_变量作用域">变量作用域</h5>
<div class="paragraph">
<p>对于局部变量，Ruby 在赋值时使用隐式变量声明，并限于当前块。 在 Ruby 中，if 或 while 内置结构的内容不是块或作用域。</p>
</div>
<div class="paragraph">
<p>Raku 使用显式作用域指示符，并且不会隐式地创建变量。 每一个地方你看到的 <code>{&#8230;&#8203;}</code> 都是一个作用域，它包括一个条件或循环的主体。 常用的作用域声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">foo = 7        # Ruby, variable scope is defined by first assignment and
               # extends to the end of the current block

my  $foo = 7   # Raku, lexical scoped to the current block
our $foo = 7   # Raku, package scoped
has $!foo = 7  # Raku, instance scoped (attribute)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_标量_3"><code>$</code> 标量</h5>
<div class="paragraph">
<p><code>$</code> 符号始终与"标量"变量（例如 <code>$name</code>）一起使用。这些是单值(single-value) 容器。</p>
</div>
<div class="paragraph">
<p>这是最通用的变量类型，对其内容没有限制。 注意，你仍然可以寻址/使用它的内容，如 <code>$x[1]</code>，<code>$x{"foo"}</code> 和 <code>$f("foo")</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_数组_2"><code>@</code> 数组</h5>
<div class="paragraph">
<p><code>@</code> 总是与"数组"变量一起使用（例如 <code>@months</code>，<code>@months[2]</code>，<code>@months[2,4]</code> 用于数组切片）。 使用 <code>@</code> 符号的变量只能包含执行 Positional 角色的东西，Positional 角色指的是位置索引和切片功能。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>索引</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">puts months[2]; # Ruby
say @months[2]; # Raku</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>值切片</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">puts months[8..11].join(',') # Ruby
say @months[8..11].join(',') # Raku</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_散列_3"><code>%</code> 散列</h5>
<div class="paragraph">
<p><code>%</code> 符号始终与"散列"变量一起使用（例如`%calories`, <code>%calories&lt;apple&gt;</code>, <code>%calories&lt;pear plum&gt;</code>）。 使用 <code>%</code> 符号的变量只能包含执行关联(<code>Associative</code>)角色的内容。</p>
</div>
<div class="paragraph">
<p>Ruby 使用方括号来访问数组和哈希值。 Raku 使用花括号来代替散列。 尖括号版本也是可用的，它总是自动引起其内容（不带引号的字符串）：</p>
</div>
<div class="paragraph">
<p>副词可以用来控制切片的类型。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>索引</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">puts calories["apple"]  # Ruby
say %calories{"apple"}; # Raku

puts calories["apple"]  # Ruby
puts calories[:apple]   # Ruby, symbols for keys are common
say %calories&lt;apple&gt;;   # Raku - angle brackets instead of single-quotes
say %calories«$key»;    # Raku - double angles interpolate as double-quotes</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>值切片</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">puts calories.values_at('pear', 'plum').join(',') # Ruby
puts calories.values_at(%w(pear plum)).join(',')  # Ruby, pretty?

say %calories{'pear', 'plum'}.join(',');          # Raku
say %calories&lt;pear plum&gt;.join(',');               # Raku (prettier)
my $keys = 'pear plum';
say %calories«$keys».join(','); # Raku, interpolated split</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>键/值切片</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say calories.slice('pear', 'plum').join(','); # Ruby, with ActiveRecord
say %calories{'pear', 'plum'}:kv.join(',');   # Raku - 使用 :kv 副词
say %calories&lt;pear plum&gt;:kv.join(',');        # Raku (更好看的版本)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_sub_2"><code>&amp;</code> Sub</h5>
<div class="paragraph">
<p><code>&amp;</code> 符号与 Ruby 的 <code>&amp;</code> 非常类似，用于引用一个具名的子例程/操作符的函数对象，而不调用它，即把名字用作"名词"而不是"动词"。 使用 <code>&amp;</code> 符号的变量只能包含 <code>Callable</code> 角色的内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">add = -&gt; n, m { n + m } # Ruby lambda for an addition function
add.(2, 3)              # =&gt; 5, Ruby invocation of a lambda
add.call(2, 3)          # =&gt; 5, Ruby invocation of a lambda

my &amp;add = -&gt; $n, $m { $n + $m } # Raku addition function
&amp;add(2, 3)                      # =&gt; 5, you can keep the sigil
add(2, 3)                       # =&gt; 5, and it works without it

foo_method = &amp;foo;     # Ruby
my &amp;foo_method = &amp;foo; # Raku

some_func(&amp;say) # Ruby pass a function reference
some_func(&amp;say) # Raku passes function references the same way</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常在 Ruby 中，我们传递一个块作为最后一个参数，这是特别用于 DSL 中。 这可以是通过 <code>yield</code> 调用的隐式参数，也可以是带有前缀 <code>&amp;</code> 的显式块。 在 Raku 中，Callable 参数总是被变量名称（而不是yield）列出和调用，并且有多种调用函数的方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Ruby, declare a method and call the implicit block argument
def f
  yield 2
end

# Ruby, invoke f, pass it a block with 1 argument
f do |n|
  puts "Hi #{n}"
end

# Raku, declare a method with an explicit block argument
sub f(&amp;g:($)) {
  g(2)
}

# Raku, invoke f, pass it a block with 1 argument
# There are several other ways to do this
f(-&gt; $n { say "Hi {$n}" }) # Explicit argument
f -&gt; $n { say "Hi {$n}" }  # Explicit argument, no parenthesis
f { say "Hi {$^n}" }       # Implicit argument

# Additionally, if 'f' is a method on instance 'obj' you can use C&lt;:&gt;
# instead of parenthesis
obj.f(-&gt; $n { say "Hi {$n}" })  # Explicit argument
obj.f: -&gt; $n { say "Hi {$n}" }  # Explicit argument, no parenthesis
obj.f: { say "Hi {$^n}" }       # Implicit argument, no parenthesis</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_吞噬参数_参数扩展"><code>*</code> 吞噬参数/ 参数扩展</h5>
<div class="paragraph">
<p>在 Ruby 中，你可以声明一个参数，使用 <code>*</code> 前缀将所传递参数的剩余部分传递到数组中。 它在 Raku 中的工作方式相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">def foo(*args); puts "I got #{args.length} args!"; end # Ruby
sub foo(*@args) { say "I got #{@args.elems} args!" }   # Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能想将数组扩展为一组参数。 在 Raku 中，这也使用 <code>*</code> 前缀：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">args = %w(a b c)         # Ruby
foo(*args)

my @args = &lt;a b c&gt;       # Raku
foo(*@args)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 有许多更高级的传递参数和接收参数的方法，参见<a href="https://docs.raku.org/language/functions#Signatures">签名</a>和<a href="https://docs.raku.org/type/Capture">捕获</a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_twigils">Twigils</h5>
<div class="paragraph">
<p>Raku 另外还使用 "twigs"，它是关于变量的进一步指示符，并且在符号和变量名的其余部分之间。 例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$foo     # Scalar with no twigil
$!foo    # 私有实例变量
$.foo    # Instance variable accessor
$*foo    # Dynamically scoped variable
$^foo    # A positional (placeholder) parameter to a block
$:foo    # 具名参数
$=foo    # POD (文档) 变量
$?FILE   # Current source filename. ? twigil 表明这是一个编译时值
$~foo    # Sublanguage seen by parser, uncommon</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然每个例子都使用 <code>$</code> 符号，但大多数可以使用 <code>@</code>（Positional）或 <code>%</code>（Associative）。</p>
</div>
</div>
<div class="sect4">
<h5 id="_符号_2"><code>:</code> 符号</h5>
<div class="paragraph">
<p>Raku 通常在 Ruby 使用符号的地方使用字符串。 关于这点的一个主要例子是散列键。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">address[:joe][:street] # Typical Ruby nested hash with symbol keys
%address&lt;joe&gt;&lt;street&gt;  # Typical Raku nested hash with string keys</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 有冒号对语法，有时看起来像Ruby符号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">:age            # Ruby symbol

# All of these are equivalent for Raku
:age            # Raku pair with implicit True value
:age(True)      # Raku pair with explicit True value
age =&gt; True     # Raku pair using arrow notation
"age" =&gt; True   # Raku pair using arrow notation and explicit quotes</code></pre>
</div>
</div>
<div class="paragraph">
<p>很多时候你可能会使用一个没有显式值的冒号对，并假装它是一个 Ruby 符号，但它不是惯用的 Raku。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_操作符">12.2. 操作符</h3>
<div class="paragraph">
<p>许多操作符在 Ruby 和 Raku 中有类似的用法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>, 列表分割符</p>
</li>
<li>
<p><code>+</code> 数值加法</p>
</li>
<li>
<p><code>-</code> 数值减法</p>
</li>
<li>
<p><code>*</code> 数值乘法</p>
</li>
<li>
<p>/ 数值除法</p>
</li>
<li>
<p>% 数值求模</p>
</li>
<li>
<p>** 数值指数</p>
</li>
<li>
<p>! &amp;&amp; || 布尔, 高优先级</p>
</li>
<li>
<p>not and or 布尔, 低优先级</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以使用 <code>$x` 而不是 `x += 1` 作为递增变量的快捷方式。这可以用作预增量 `$x</code>（增量，返回新值）或后增量 <code>$x++</code>（增量，返回旧值）。</p>
</div>
<div class="paragraph">
<p>您可以使用 <code>$x--</code> 而不是 <code>x -= 1</code> 作为递减变量的快捷方式。这可以用作预减量 <code>--$x</code>（递减，返回新值）或递减后 <code>$x--</code>（递减，返回旧值）。</p>
</div>
<div class="sect3">
<h4 id="_比较">12.2.1. == != &lt; &gt; &#8656; &gt;= 比较</h4>
<div class="paragraph">
<p>Raku 中, 数字和字符串之间比较是分开的，以避免常见错误。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>== != &lt; &gt; &#8656; &gt;= 比较</p>
</li>
<li>
<p>eq ne lt gt le ge 字符串比较</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，使用 <code>==</code> 尝试将值转换为数字，并且 <code>eq</code> 尝试将值转换为字符串。</p>
</div>
</div>
<div class="sect3">
<h4 id="_三向比较">12.2.2. <code>&lt;&#8658;</code> 三向比较</h4>
<div class="dlist">
<dl>
<dt class="hdlist1">在 Ruby 中，<code>&lt;&#8658;</code> 运算符返回 -1,0 或1。 在 Raku 中，它们返回 `Order </dt>
<dd>
<p>Less`，<code>Order :: Same</code> 或 <code>Order :: More</code>。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>&lt;&#8658;</code> 用于强制数字上下文比较。</p>
</div>
<div class="paragraph">
<p><code>leg</code>（"Less，Equal 或者 Greater?"）用于强制字符串上下文比较。</p>
</div>
<div class="paragraph">
<p><code>cmp</code> 要么是 <code>&lt;&#8658;</code> 比较, 要么是 <code>leg</code> 比较，这取决于它的参数的现有类型。</p>
</div>
</div>
<div class="sect3">
<h4 id="_智能匹配运算符_3">12.2.3. <code>~~</code> 智能匹配运算符</h4>
<div class="paragraph">
<p>这是一个非常常见的匹配运算符，它不存在于 Ruby 中。这里有些例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "match!" if $foo ~~ /bar/;      # Regex match
say "match!" if $foo ~~ "bar";      # String match
say "match!" if $foo ~~ :(Int, Str) # Signature match (destructure)</code></pre>
</div>
</div>
<div class="paragraph">
<p>参见 <a href="https://design.raku.org/S03.html#Smart_matching">S03/智能匹配</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_数字位操作">12.2.4. &amp; | ^ 数字位操作</h4>

</div>
<div class="sect3">
<h4 id="_布尔运算">12.2.5. &amp; | ^ 布尔运算</h4>
<div class="paragraph">
<p>在 Raku 中，这些单字符操作被移除了，并被两个字符操作代替，它们将它们的参数强制到所需的上下文中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Infix ops (two arguments; one on each side of the op)
+&amp;  +|  +^  And Or Xor: Numeric
~&amp;  ~|  ~^  And Or Xor: String
?&amp;  ?|  ?^  And Or Xor: Boolean

# Prefix ops (one argument, after the op)
+^  Not: Numeric
~^  Not: String
?^  Not: Boolean (same as the ! op)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_条件链式操作符">12.2.6. <code>&amp;.</code> 条件链式操作符</h4>
<div class="paragraph">
<p>Ruby 使用  <code>&amp;.</code> 运算符链接方法，而不会在一个返回 nil 的调用中产生错误。在 Raku 中因为同样的目的使用 <code>.?</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_数值左右移位操作符铲shovel操作符">12.2.7. &lt;&lt; &gt;&gt; 数值左/右移位操作符，铲(shovel)操作符</h4>
<div class="paragraph">
<p>替换为 <code>+&lt;</code> 和 <code>+&gt;</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">puts 42 &lt;&lt; 3  # Ruby
say  42 +&lt; 3; # Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，Ruby 经常使用 <code>&lt;&lt;</code> 运算符作为"铲操作符"，这类似于`.push`。这种用法在 Raku 中不常见。</p>
</div>
</div>
<div class="sect3">
<h4 id="_和_键_值分隔符">12.2.8. <code>&#8658;`和 `:</code> 键-值分隔符</h4>
<div class="paragraph">
<p>在 Ruby 中，<code>&#8658;</code> 用于 Hash 字面声明和参数传递的键/值对的上下文中。 当左边是符号时用 <code>:</code> 作速记符。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，<code>&#8658;</code> 是对(Pair)运算符，这在原理上是非常不同的，但在许多情况下工作相同。</p>
</div>
<div class="paragraph">
<p>如果你在哈希字面值中使用 <code>&#8658;</code>，那么用法非常类似：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">hash = { "AAA" =&gt; 1, "BBB" =&gt; 2 }  # Ruby, though symbol keys are more common
my %hash = ( AAA =&gt; 1, BBB =&gt; 2 ); # Raku, uses ()'s though {} usually work</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_三目运算符">12.2.9. <code>?:</code> 三目运算符</h4>
<div class="paragraph">
<p>在 Raku 中，这被拼写为两个问号，而不是一个问号，和两个感叹号而不是一个冒号。这种与常见三目运算符的偏离消除了多种歧义的情况，并使得假的情况更突出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">result     = (  score &gt; 60 )  ? 'Pass'  : 'Fail'; # Ruby
my $result = ( $score &gt; 60 ) ?? 'Pass' !! 'Fail'; # Raku</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_字符串连接">12.2.10. <code>+</code> 字符串连接</h4>
<div class="paragraph">
<p>替换为波浪线符号（<code>~</code>）。助记符：想想用针和线缝合两个字符串。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$food = 'grape' + 'fruit'  # Ruby
$food = 'grape' ~ 'fruit'; # Raku</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_字符串插值_2">12.2.11. 字符串插值</h4>
<div class="paragraph">
<p>在 Ruby 中，"<mark>{foo}s" 界定嵌入在双引号字符串中的块。在 Raku 中删除 <code></mark></code> 前缀："{$foo}s"。和 Ruby 一样，你可以将任意代码放在嵌入式块中，它将在字符串上下文中渲染。</p>
</div>
<div class="paragraph">
<p>简单变量可以插入到双引号字符串中，而不使用块语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Ruby
name = "Bob"
puts "Hello! My name is #{name}!"

# Raku
my $name = "Bob"
say "Hello! My name is $name!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ruby 中的嵌入式块的结果使用 <code>.to_s</code> 来获取字符串上下文。 Raku 使用 <code>.Str</code> 或 <code>.gist</code> 得到相同的效果。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_复合语句_3">12.3. 复合语句</h3>
<div class="sect3">
<h4 id="_条件">12.3.1. 条件</h4>
<div class="sect4">
<h5 id="_if_elsif_else_unless_2">if elsif else unless§</h5>
<div class="paragraph">
<p>这在 Ruby 和 Raku 之间非常相似，但是 Raku 使用 <code>{}</code> 来清楚地描述块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Ruby
if x &gt; 5
    puts "Bigger!"
elsif x == 5
    puts "The same!"
else
    puts "Smaller!"
end

# Raku
if x &gt; 5 {
    say "Bigger!"
} elsif x == 5 {
    puts "The same!"
} else {
    puts "Smaller!"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将条件表达式绑定到变量上有一点不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if x = dostuff(); ...; end   # Ruby
if dostuff() -&gt; $x {...}     # Raku, block-assignment uses arrow</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>unless</code> 条件仅允许 Raku 中的单个块; 它不允许 <code>elsif</code> 或 <code>else</code> 子句。</p>
</div>
</div>
<div class="sect4">
<h5 id="_cese_when"><code>cese-when</code></h5>
<div class="paragraph">
<p>Raku 的 <code>given-when</code> 结构像一个 <code>if-elsif-else</code> 语句链或者类似于 Ruby 中的 <code>case-when</code>。一个很大的区别是，Ruby 使用 <code>==</code> 比较每个条件，但 Raku 使用更一般的智能匹配 <code>~~</code> 运算符。</p>
</div>
<div class="paragraph">
<p>它具有以下一般结构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given EXPR {
    when EXPR { ... }
    when EXPR { ... }
    default { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在其最简单的形式中，构造如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given $value {
    when "a match" {
        do-something();
    }
    when "another match" {
        do-something-else();
    }
    default {
        do-default-thing();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这在 <code>when</code> 语句中匹配标量值的情况下是简单的。更一般地，匹配实际上是对输入值的智能匹配，使得可以使用更复杂的诸如正则表达式的实体的而非标量值来查找。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_循环_2">12.3.2. 循环</h4>
<div class="sect4">
<h5 id="_while_until_2">while until</h5>
<div class="paragraph">
<p>大部分不变;圆括号周围的条件是可选的，但如果使用了，不能立即跟随关键字，否则它将被视为一个函数调用。将条件表达式绑定到变量上也有一些不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">while x = dostuff(); ...; end    # Ruby
while dostuff() -&gt; $x {...}      # Raku</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_for_each">for .each</h5>
<div class="paragraph">
<p>for 循环在 Ruby 中是罕见的，我们通常在可枚举上使用 <code>.each</code>。对 Raku 的最直接的翻译是对 <code>.each</code> 和 <code>.map</code> 都使用 <code>.map</code>，但是我们通常直接使用 <code>for</code> 循环。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Ruby for loop
for n in 0..5
    puts "n: #{n}"
end

# Ruby, more common usage of .each
(0..5).each do |n|
    puts "n: #{n}"
end

# Raku
for 0..5 -&gt; $n {
    say "n: $n";
}

# Raku, mis-using .map
(0..5).map: -&gt; $n {
    say "n: $n";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Ruby 中，.each 的迭代变量是列表元素的副本，修改它对原始列表没有影响。请注意，它是 REFERENCE 的副本，因此您仍然可以更改其引用的值。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，该别名是只读的（为了安全起见），因此它的行为与 Ruby 完全一样，除非把 <code>&#8594;</code> 改为 <code>&lt;&#8594;</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">cars.each { |car| ... }    # Ruby; read-only reference
for @cars  -&gt; $car   {...} # Raku; read-only
for @cars &lt;-&gt; $car   {...} # Raku; read-write</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_流程中断语句">12.3.3. 流程中断语句</h4>
<div class="paragraph">
<p>与 Ruby 相同：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>next</p>
</li>
<li>
<p>redo</p>
</li>
<li>
<p>break</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这在 Raku 中是 <code>last</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_正则表达式regex_regexp">12.4. 正则表达式（Regex / Regexp）</h3>
<div class="paragraph">
<p>Raku 中的正则表达式与 Ruby 中的正则表达式明显不同，它更强大。例如，默认情况下，Raku 将忽略空格，所有字符必须转移。正则表达式可以很容易地以组合和声明的方式建立高效的 grammars。</p>
</div>
<div class="paragraph">
<p>有很多强大的 Raku regex 的特性，特别是使用相同的语法定义整个 gramamrs。请参阅<a href="https://docs.raku.org/language/regexes">正则表达式</a>和 <a href="https://docs.raku.org/language/grammars">Grammars</a>。</p>
</div>
<div class="sect3">
<h4 id="_match_方法和_运算符">12.4.1. .match 方法和 =~ 运算符</h4>
<div class="paragraph">
<p>在 Ruby 中，可以使用 <code>=~</code> regexp 匹配运算符或 <code>.match</code> 方法对变量执行正则表达式匹配。在 Raku 中，使用 ~~ 智能匹配运算符，或 <code>.match</code> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">next if line   =~ /static/   # Ruby
next if $line  ~~ /static/;  # Raku

next if line  !~  /dynamic/ ; # Ruby
next if $line !~~ /dynamic/ ; # Raku

next if line.match(/static/)    # Ruby
next if $line.match(/static/);  # Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，可以使用 <code>.match`和 `.subst</code> 方法。注意 <code>.subst</code> 是不可变的。参见 <a href="https://design.raku.org/S05.html#Substitution">S05/替换</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_sub_和_sub">12.4.2. <code>.sub</code> 和 <code>.sub!</code></h4>
<div class="paragraph">
<p>在 Raku 中，通常使用 <code>s///</code> 运算符来执行正则表达式替换。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">fixed = line.sub(/foo/, 'bar')        # Ruby, non-mutating
my $fixed = $line.subst(/foo/, 'bar') # Raku, non-mutating

line.sub!(/foo/, 'bar')   # Ruby, mutating
$line ~~ s/foo/bar/;      # Raku, mutating</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_正则表达式选项">12.4.3. 正则表达式选项</h4>
<div class="paragraph">
<p>将任何选项从正则表达式的结尾移动到开头。这可能需要您在 <code>/abc/</code> 等纯匹配中添加可选的 <code>m</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">next if $line =~    /static/i # Ruby
next if $line ~~ m:i/static/; # Raku</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_空格被忽略大多数东西必须被引起来">12.4.4. 空格被忽略，大多数东西必须被引起来</h4>
<div class="paragraph">
<p>为了帮助可读性和可重用性，在 Raku 的正则表达式中，空格并不重要。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/this is a test/ # Ruby, boring string
/this.*/         # Ruby, possibly interesting string

/ this " " is " " a " " test / # Raku, each space is quoted
/ "this is a test" / # Raku, quoting the whole string
/ this .* /          # Raku, possibly interesting string</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_特殊匹配器通常属于_语法_2">12.4.5. 特殊匹配器通常属于 <code>&lt;&gt;</code> 语法</h4>
<div class="paragraph">
<p>Raku 的正则表达式有很多支持特殊匹配语法的情况。它们不会全部列在这里，但通常不是被 <code>()</code> 包围，断言将被 <code>&lt;&gt;</code> 包围。</p>
</div>
<div class="paragraph">
<p>对于字符类，这意味着：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[abc]</code> 变为 <code>&lt;[abc]&gt;</code></p>
</li>
<li>
<p><code>[^abc]</code> 变为 <code>&#8592;[abc]&gt;</code></p>
</li>
<li>
<p><code>[a-zA-Z]</code> 变为 <code>&lt;[a..zA..Z]&gt;</code></p>
</li>
<li>
<p><code><a id=":upper:"></a></code> 变为 <code>&lt;:upper&gt;</code></p>
</li>
<li>
<p><code>[abc[:upper:]]</code> 变为 <code>&lt;[abc]+:Upper&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于环视断言：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>(?=[abc])</code> 变为 <code>&lt;?[abc]&gt;</code></p>
</li>
<li>
<p><code>(?=ar?bitrary* pattern)</code> 变为 <code>&lt;before ar?bitrary* pattern&gt;</code></p>
</li>
<li>
<p><code>(?!=[abc])</code> 变为 <code>&lt;![abc]&gt;</code></p>
</li>
<li>
<p><code>(?!=ar?bitrary* pattern)</code> 变为 <code>&lt;!before ar?bitrary* pattern&gt;</code></p>
</li>
<li>
<p><code>(?&#8656;ar?bitrary* pattern)</code> 变为 <code>&lt;after ar?bitrary* pattern&gt;</code></p>
</li>
<li>
<p><code>(?&lt;!ar?bitrary* pattern)</code> 变为 <code>&lt;!after ar?bitrary* pattern&gt;</code></p>
</li>
<li>
<p><code>(Unrelated to &lt;&gt; syntax, the "lookaround" /foo\Kbar/</code> 变为 <code>/foo &lt;( bar )&gt; /</code></p>
</li>
<li>
<p><code>(?(?{condition))yes-pattern|no-pattern)</code> 变为 <code>[ &lt;?{condition}&gt; yes-pattern | no-pattern ]</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_最长令牌匹配ltm替代交替">12.4.6. 最长令牌匹配（LTM）替代交替</h4>
<div class="paragraph">
<p>在 Raku regexes 中，<code>|</code> 执行最长令牌匹配（LTM），它决定哪个备选分支根据一组规则赢得模棱两可的匹配，而不是根据在正则表达式中首先写出哪个备选分支。</p>
</div>
<div class="paragraph">
<p>要避免新的逻辑，请在你的 Ruby 正则表达式中把任何 <code>|</code> 更改为 <code>||</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_文件相关操作">12.5. 文件相关操作</h3>
<div class="sect3">
<h4 id="_将文本文件的行读入数组_2">12.5.1. 将文本文件的行读入数组</h4>
<div class="paragraph">
<p>Ruby 和 Raku 都很容易将文件中的所有行读取到单个变量中，在这两种情况下，每一行都删除了换行符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">lines = File.readlines("file")   # Ruby
my @lines = "file".IO.lines;     # Raku, create an IO object from a string</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_迭代文本文件的行">12.5.2. 迭代文本文件的行</h4>
<div class="paragraph">
<p>不建议将整个文件读入内存。 Raku 中的 <code>.lines</code> 方法返回一个延迟序列，但是赋值给数组会强制读取文件。最好迭代结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Ruby
File.foreach("file") do |line|
    puts line
end

# Raku
for "file".IO.lines -&gt; $line {
    say $line
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_面向对象">12.6. 面向对象</h3>
<div class="sect3">
<h4 id="_基本类方法属性">12.6.1. 基本类，方法，属性</h4>
<div class="paragraph">
<p>在 Ruby 和 Raku 之间类的定义是相似的。 Ruby 使用 <code>def</code> 定义方法，而 Raku 使用 <code>method</code> 定义方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Ruby
class Foo
    def greet(name)
        puts "Hi #{name}!"
    end
end

# Raku
class Foo {
    method greet($name) {
        say "Hi $name!"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Ruby 中，你可以使用一个属性而不预先声明它，你可以告诉它这是一个属性，因为 <code>@</code> 符号。您还可以使用 <code>attr_accessor</code> 及其变体轻松创建访问器。在 Raku 中，你使用 <code>has</code> 声明符和各种符号。你可以使用 <code>!</code> twigil 作为私有属性或 <code>.</code> 创建一个访问器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Ruby
class Person
    attr_accessor :age    # Declare .age as an accessor method for @age
    def initialize
        @name = 'default' # Assign default value to private instance var
    end
end

# Raku
class Person {
    has $.age;              # Declare $!age and accessor methods
    has $!name = 'default'; # Assign default value to private instance var
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>.new</code> 方法创建类的新实例。在 Ruby 中，您必须在 <code>initialize</code> 内根据需要手动给实例变量赋值。在 Raku 中，您将获得一个接受访问器属性的键/值对的默认构造函数，并可以在 <code>BUILD</code> 方法中进一步设置。像 Ruby 一样，你可以重写 <code>new</code> 自身以获取更高级的功能，但这是罕见的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Ruby
class Person
    attr_accessor :name, :age
    def initialize(attrs)
        @name = attrs[:name] || 'Jill'
        @age  = attrs[:age] || 42
        @birth_year = Time.now.year - @age
    end
end
p = Person.new( name: 'Jack', age: 23 )

# Raku
class Person
    has $.name = 'Jill';
    has $.age  = 42;
    has $!birth_year;
    method BUILD {
        $!birth_year = now.Date.year - $.age;
    }
}
p = Person.new( name =&gt; 'Jack', age =&gt; 23 )</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_私有方法">12.6.2. 私有方法</h4>
<div class="paragraph">
<p>Raku 中的私有方法声明的时候在他们的名字前置一个 <code>!</code> 符号，并且调用的时候使用 <code>!</code> 代替 <code>.</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Ruby
class Foo
    def visible
        puts "I can be seen!"
        hidden
    end

    private
    def hidden
        puts "I cannot easily be called!"
    end
end

# Raku
class Foo {
    method visible {
        say "I can be seen!"
        self!hidden
    }

    method !hidden {
        say "I cannot easily be called!"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个重要的注意事项是，在 Ruby 中孩子对象可以看到父对象中的私有方法（所以他们更像是其他语言中的"受保护"的方法）。在 Raku 中，孩子对象不能调用父对象中的私有方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_元">12.6.3. 元</h4>
<div class="paragraph">
<p>这里有一些元编程的例子。注意，Raku 将元方法与常规方法分离开了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">person = Person.new       # Ruby, create a new person
my $person = Person.new   # Raku, create a new person

person.class              # Ruby, returns Person (class)
$person.WHAT              # Raku, returns Person (class)

person.methods            # Ruby
$person.^methods          # Raku, using .^ syntax to access meta-methods

person.instance_variables # Ruby
$person.^attributes       # Raku</code></pre>
</div>
</div>
<div class="paragraph">
<p>像 Ruby 一样，在 Raku 中，一切都是对象，但并不是所有的操作都等同于 <code>.send</code>。许多运算符是使用类型化多重分派（具有类型的函数签名）来决定使用哪个实现的全局函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">5.send(:+, 3)    # =&gt; 8, Ruby
&amp;link:5, 3[+]       # =&gt; 8, Raku, reference to infix addition operator

&amp;[+].^candidates # Raku, lists all signatures for the + operator</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅<a href="https://docs.raku.org/language/mop">元对象协议</a>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_环境变量_2">12.7. 环境变量</h3>
<div class="sect3">
<h4 id="_perl_模块库路径_2">12.7.1. Perl 模块库路径</h4>
<div class="paragraph">
<p>在 Ruby 中，为模块指定额外搜索路径的环境变量之一是 <code>RUBYLIB</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$ RUBYLIB="/some/module/lib" ruby program.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Raku 中，这是相似的，你只需要更改名称。正如你可能猜到的，你只需要使用 <code>PERL6LIB</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ PERL6LIB="/some/module/lib" raku program.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>与 Ruby 一样，如果不指定 <code>PERL6LIB</code>，则需要通过 <code>use lib</code> 指令在程序中指定库路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Ruby and Raku
use lib '/some/module/lib';</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_misc_2">12.8. Misc.</h3>
<div class="sect3">
<h4 id="_从模块导入特定函数_2">12.8.1. 从模块导入特定函数</h4>
<div class="paragraph">
<p>在 Ruby 中没有内置的方法来选择性地从模块中导入/导出方法。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，通过在相关的 subs 上使用 "is export" 角色来指定要导出的函数，然后导出所有具有此角色的 subs。因此，下面的 <code>Bar</code> 模块导出 subs <code>foo</code> 和 <code>bar</code>，但不导出 <code>baz</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module Bar; # remainder of the file is in module Bar { ... }

sub foo($a) is export { say "foo $a" }
sub bar($b) is export { say "bar $b" }
sub baz($z) { say "baz $z" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用此模块，只需 <code>use Bar</code>，函数 <code>foo</code> 和 <code>bar</code> 将可用</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Bar;
foo(1);    #=&gt; "foo 1"
bar(2);    #=&gt; "bar 2"</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您尝试使用 <code>baz</code>， 那么在编译时会引发 "Undeclared routine" 的错误。</p>
</div>
<div class="paragraph">
<p>一些模块允许选择性地导入函数，它们看起来像：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Bar &lt;foo&gt;; # Import only foo
foo(1);        #=&gt; "foo 1"
bar(2);        # Error!</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_optionparser解析命令行标志">12.9. OptionParser，解析命令行标志</h3>
<div class="paragraph">
<p>Raku 中的命令行参数开关解析由 <code>MAIN</code> 子例程的参数列表完成。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Ruby
require 'optparse'
options = {}
OptionParser.new do |opts|
    opts.banner = 'Usage: example.rb --length=abc'
    opts.on("--length", "Set the file") do |length|
        raise "Length must be &gt; 0" unless length.to_i &gt; 0
        options[:length] = length
    end
    opts.on("--filename", "Set the file") do |filename|
        options[:file] = filename
    end
    opts.on("--verbose", "Increase verbosity") do |verbose|
        options[:verbose] = true
    end
end.parse!

puts options[:length]
puts options[:filename]
puts 'Verbosity ', (options[:verbose] ? 'on' : 'off')

ruby example.rb --filename=foo --length=42 --verbose
    42
    foo
    Verbosity on

ruby example.rb --length=abc
    Length must be &gt; 0

# Raku
sub MAIN ( Int :$length where * &gt; 0, :filename = 'file.dat', Bool :$verbose ) {
    say $length;
    say $data;
    say 'Verbosity ', ($verbose ?? 'on' !! 'off');
}

raku example.p6 --file=foo --length=42 --verbose
    42
    foo
    Verbosity on
raku example.p6 --length=abc
    Usage:
      c.p6 [--length=&lt;Int&gt;] [--file=&lt;Any&gt;] [--verbose]</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，Raku 在命令行解析错误时会自动生成一个完整的使用消息。</p>
</div>
</div>
<div class="sect2">
<h3 id="_rubygems外部库">12.10. RubyGems，外部库</h3>
<div class="paragraph">
<p>请参阅 <a href="https://modules.raku.org/，其中提供了越来越多的" class="bare">https://modules.raku.org/，其中提供了越来越多的</a> Raku 库以及管理它们的工具。</p>
</div>
<div class="paragraph">
<p>如果您使用的模块尚未转换为 Raku，并且本文档中未列出任何备选方案，那么它在 Raku 下的使用可能尚未解决。</p>
</div>
<div class="paragraph">
<p>你可以尝试使用 <code>Inline::Ruby</code> 从 Raku 程序中调用现有的 Ruby 代码。这使用 ruby 解释器的嵌入式实例来运行从 Raku 脚本调用的 Ruby 代码。注意，这是一个 EXPERIMENTAL 库。类似地你可以使用 <code>Inline::Perl5</code>，<code>Inline::Python</code> 和其他调用其他语言的库。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_类和对象_2">13. 类和对象</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 有一个丰富的内置语法来定义和使用类。</p>
</div>
<div class="paragraph">
<p>默认构造函数允许为创建的对象设置属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Point {
    has Int $.x;
    has Int $.y;
}

class Rectangle {
    has Point $.lower;
    has Point $.upper;

    method area() returns Int {
        ($!upper.x - $!lower.x) * ( $!upper.y - $!lower.y);
    }
}

# Create a new Rectangle from two Points
my $r = Rectangle.new(lower =&gt; Point.new(x =&gt; 0, y =&gt; 0), upper =&gt; Point.new(x =&gt; 10, y =&gt; 10));

say $r.area(); # OUTPUT: «100␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>您也可以提供自己的构建和构建实现。下面更详细的例子展示了 Raku 中依赖处理器的外观。它展示了自定义构造函数，私有属性和公共属性，方法以及签名的各个方面。它代码不多，但结果是有趣和有用的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Task {
    has      &amp;!callback;
    has Task @!dependencies;
    has Bool $.done;

    # Normally doesn't need to be written
    # BUILD is the equivalent of a constructor in other languages
    method new(&amp;callback, *@dependencies) {
        return self.bless(:&amp;callback, :@dependencies);
    }

    submethod BUILD(:&amp;!callback, :@!dependencies) { }

    method add-dependency(Task $dependency) {
        push @!dependencies, $dependency;
    }

    method perform() {
        unless $!done {
            .perform() for @!dependencies;
            &amp;!callback();
            $!done = True;
        }
    }
}

my $eat =
    Task.new({ say 'eating dinner. NOM!' },
        Task.new({ say 'making dinner' },
            Task.new({ say 'buying food' },
                Task.new({ say 'making some money' }),
                Task.new({ say 'going to the store' })
            ),
            Task.new({ say 'cleaning kitchen' })
        )
    );

$eat.perform();</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_从类开始">13.1. 从类开始</h3>
<div class="paragraph">
<p>和许多其他语言一样，Raku 使用 <code>class</code> 关键字来定义一个类。接下来的块可能包含任意代码，就像其他块一样，但类通常包含状态和行为声明。示例代码包括通过 <code>has</code> 关键字引入的属性(状态)以及通过 <code>method</code> 关键字引入的行为。</p>
</div>
<div class="paragraph">
<p>声明一个类会创建一个新的*类型对象*，默认情况下，它将被安装到当前包中(就像使用 <code>our</code> 作用域声明的变量一样)。此类型对象是类的“空实例”。例如，<code>Int</code> 和 <code>Str</code> 等类型引用 Raku 内置类之一的类型对象。上面的示例使用类名称 <code>Task</code>，以便其他代码稍后可以引用它，例如通过调用 <code>new</code> 方法来创建类实例。</p>
</div>
<div class="paragraph">
<p>您可以使用 <code>.DEFINITE</code> 方法来确定你拥有的是实例还是类型对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Int.DEFINITE; # OUTPUT: «False␤» (type object)
say 426.DEFINITE; # OUTPUT: «True␤»  (instance)

class Foo {};
say Foo.DEFINITE;     # OUTPUT: «False␤» (type object)
say Foo.new.DEFINITE; # OUTPUT: «True␤»  (instance)</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以使用类型表情符号来仅接受实例或类型对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi foo (Int:U) { "It's a type object!" }
multi foo (Int:D) { "It's an instance!"   }
say foo Int; # OUTPUT: «It's a type object!␤»
say foo 42;  # OUTPUT: «It's an instance!␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_状态">13.2. 状态</h3>
<div class="paragraph">
<p>类块中的前三行声明所有属性(在其他语言中称为字段或实例存储)。就像 <code>my</code> 变量不能从其声明的作用域之外访问一样，属性不能在类的外面访问。这种封装是面向对象设计的关键原则之一。</p>
</div>
<div class="paragraph">
<p>第一个声明指定回调的实例存储 - 为执行对象表示的任务而调用的一些代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">has &amp;!callback;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>&amp;</code> sigil 表示该属性代表可调用的内容。 <code>!</code> 字符是一个 <strong>twigil</strong>，或 <strong>secondary sigil</strong>。twigil 组成变量名称的一部分。在这种情况下，<code>!</code> twigil 强调，这个属性对类是私有的。</p>
</div>
<div class="paragraph">
<p>第二个声明也使用私有 twigil:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">has Task @!dependencies;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而，这个属性表示一个项目的数组，所以它需要 <code>@</code> sigil。这些项目分别指定一个任务，在完成之前必须先完成这些任务。而且，这个属性的类型声明表明该数组只能包含 <code>Task</code> 类的实例(或者它的某个子类)。</p>
</div>
<div class="paragraph">
<p>第三个属性表示任务完成的状态:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">has Bool $.done;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个标量属性(带有 <code>$</code> sigil)有一个 <code>Bool</code> 类型。而不是 <code>!</code> twigil，使用 <code>.</code> twigil。尽管 Raku 确实对属性进行了封装，但它也可以避免编写访问器方法。替换！与。都声明属性 $!done 和一个名为 done 的访问器方法。就好像你写了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">has Bool $!done;
method done() { return $!done }</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，这不像某些语言允许的那样声明公共属性;你真的得到了一个私有属性和一个方法，而无需手动编写该方法。你可以自由地编写自己的访问器方法，如果你将来需要做一些比返回值更复杂的事情。</p>
</div>
<div class="paragraph">
<p>请注意，使用。 twigil创建了一个方法，将提供对该属性的只读访问权限。如果该对象的用户应该能够重置任务的完成状态(也许再次执行)，则可以更改属性声明:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">has Bool $.done is rw;</code></pre>
</div>
</div>
<div class="paragraph">
<p>rw特征会导致生成的访问器方法返回一些外部代码可以修改的内容以更改该属性的值。</p>
</div>
<div class="paragraph">
<p>您还可以为属性提供默认值(对于有和没有访问者的情况，这些默认值同样适用):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">has Bool $.done = False;</code></pre>
</div>
</div>
<div class="paragraph">
<p>分配是在对象构建时进行的。此时评估右侧，甚至可以引用早期的属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">has Task @!dependencies;
has $.ready = not @!dependencies;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_静态字段">13.3. 静态字段?</h3>
<div class="paragraph">
<p>Raku 没有静态关键字。尽管如此，任何类都可以声明模块可以做的任何事情，所以使范围变量听起来像是个好主意。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Singleton {
    my Singleton $instance;
    method new {!!!}
    submethod instance {
        $instance = Singleton.bless unless $instance;
        $instance;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由我或我们定义的类属性也可以在声明时初始化，但是我们在这里实现Singleton模式，并且必须在第一次使用时创建对象。预测执行属性初始化的时刻不是100％，因为它可以在编译，运行时或两者期间发生，尤其是在使用use关键字导入类时。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class HaveStaticAttr {
      my Foo $.foo = some_complicated_subroutine;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>类属性也可以用辅助sigil声明 - 以类似于对象属性的方式 - 如果属性将被公开，将生成只读访问器。</p>
</div>
</div>
<div class="sect2">
<h3 id="_方法">13.4. 方法</h3>
<div class="paragraph">
<p>虽然属性赋予对象状态，但方法赋予对象行为。我们暂时忽略新方法;这是一种特殊的方法。考虑第二种方法add-dependency，它将一项新任务添加到任务的依赖列表中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method add-dependency(Task $dependency) {
    push @!dependencies, $dependency;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在许多方面，这看起来很像一个子声明。但是，有两个重要的区别。首先，将此例程声明为方法将其添加到当前类的方法列表中，因此Task类的任何实例都可以使用它调用它。方法调用操作符。其次，一种方法将其调用者放入特殊变量 <code>self</code> 中。</p>
</div>
<div class="paragraph">
<p>该方法本身将传入的参数(它必须是Task类的一个实例)并将其推送到invocant的@！dependencies属性上。</p>
</div>
<div class="paragraph">
<p>执行方法包含依赖性处理程序的主要逻辑:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method perform() {
    unless $!done {
        .perform() for @!dependencies;
        &amp;!callback();
        $!done = True;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它不需要参数，而是使用对象的属性。首先，通过检查$！done属性来检查任务是否已经完成。如果是这样，那就没有什么可做的了。</p>
</div>
<div class="paragraph">
<p>否则，该方法执行所有任务的依赖关系，使用 <code>for</code> 构造遍历 <code>@!dependencies</code> 属性中的所有项。此迭代将每个项目(每个项目都放置一个Task对象)放入主题变量 <code>$_</code> 中。使用 。方法调用操作符而不指定明确的调用者将当前主题用作调用者。因此，迭代构造对当前调用者的 <code>@!dependencies</code> 属性中的每个Task对象调用 <code>.perform()</code> 方法。</p>
</div>
<div class="paragraph">
<p>在所有的依赖关系完成之后，通过直接调用 <code>&amp;!</code> 回调属性来执行当前任务的任务。这是括号的目的。最后，该方法将 <code>$!done</code> 属性设置为 <code>True</code>，以便后续对该对象执行的调用(例如，如果此 Task 是另一个 Task 的依赖项)将不会重复该任务。</p>
</div>
</div>
<div class="sect2">
<h3 id="_私有方法_2">13.5. 私有方法</h3>
<div class="paragraph">
<p>就像属性一样，方法也可以是私有的。私有方法声明带有前缀感叹号。他们被称为 <code>self!</code>, 随后是方法的名称。要调用另一个类的私有方法，调用类必须被调用类信任。信任关系是用信任声明的，而且要信任的类必须已经声明。调用另一个类的私有方法需要该类的实例和该方法的全限定名称。信任也允许访问私有属性</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class B {...}

class C {
    trusts B;
    has $!hidden = 'invisible';
    method !not-yours () { say 'hidden' }
    method yours-to-use () {
        say $!hidden;
        self!not-yours();
    }
}

class B {
    method i-am-trusted () {
        my C $c.=new;
        $c!C::not-yours();
    }
}

C.new.yours-to-use(); # the context of this call is GLOBAL, and not trusted by C
B.new.i-am-trusted();</code></pre>
</div>
</div>
<div class="paragraph">
<p>信任关系不受继承。要信任全局名称空间，可以使用伪包GLOBAL。</p>
</div>
</div>
<div class="sect2">
<h3 id="_构造函数">13.6. 构造函数</h3>
<div class="paragraph">
<p>Raku比构造函数领域的许多语言更自由。构造函数是任何返回类实例的东西。而且，构造函数是普通的方法。您从基类 <code>Mu</code> 继承了一个名为 <code>new</code> 的默认构造函数，但您可以自由覆盖 <code>new</code>，如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method new(&amp;callback, *@dependencies) {
    return self.bless(:&amp;callback, :@dependencies);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 中的构造函数和 <code>C#</code> 和 <code>Java</code> 等语言中的构造函数最大的不同之处在于，它不是以某种方式为已经神奇创建的对象设置状态，而是由 Raku 构造函数自己创建对象。最简单的方法是调用也是从Mu继承的祝福方法。 <code>bless</code> 方法期望一组命名参数为每个属性提供初始值。</p>
</div>
<div class="paragraph">
<p>该示例的构造函数将位置参数转换为命名参数，以便该类可以为其用户提供一个很好的构造函数。第一个参数是回调(将执行任务的东西)。其余参数是相关的 Task 实例。构造函数将这些捕获到 <code>@dependencies</code> slurpy 数组中，并将它们作为命名参数传递给bless(注意: <code>&amp;callback</code> 使用变量的名称 - 减去 sigil  - 作为参数的名称)。</p>
</div>
<div class="paragraph">
<p>私有属性确实是私有的。这意味着 <code>bless</code> 不允许直接将事物绑定到 <code>&amp;!callback</code> 和 <code>@!</code> 依赖关系。为了做到这一点，我们重写 <code>BUILD</code> 子方法，这是通过 <code>bless</code> 在全新对象上调用的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">submethod BUILD(:&amp;!callback, :@!dependencies) { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <code>BUILD</code> 在新创建的 Task 对象的上下文中运行，因此可以操作这些私有属性。这里的技巧是使用私有属性( <code>&amp;!callback</code> 和 <code>@!</code> 依赖项)作为 <code>BUILD</code> 参数的绑定目标。零样板初始化！查看对象获取更多信息。</p>
</div>
<div class="paragraph">
<p>BUILD方法负责初始化所有属性，还必须处理默认值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">has &amp;!callback;
has @!dependencies;
has Bool ($.done, $.ready);
submethod BUILD(
        :&amp;!callback,
        :@!dependencies,
        :$!done = False,
        :$!ready = not @!dependencies
    ) { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>请参阅对象构造以获取更多影响对象构造和属性初始化的选项。</p>
</div>
</div>
<div class="sect2">
<h3 id="_消费我们的类">13.7. 消费我们的类</h3>
<div class="paragraph">
<p>创建一个类后，您可以创建该类的实例。声明一个自定义构造函数提供了一种简单的方式来声明任务及其依赖关系。要创建没有依赖关系的单个任务，请写下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $eat = Task.new({ say 'eating dinner. NOM!' });</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的章节解释说，声明类Task在命名空间中安装了一个类型对象。这个类型对象是类的一个“空实例”，特别是没有任何状态的实例。您可以调用该实例的方法，只要它们不尝试访问任何状态;新是一个例子，因为它创建了一个新对象，而不是修改或访问现有对象。</p>
</div>
<div class="paragraph">
<p>不幸的是，晚餐从未奇迹般地发生。它有依赖任务:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $eat =
    Task.new({ say 'eating dinner. NOM!' },
        Task.new({ say 'making dinner' },
            Task.new({ say 'buying food' },
                Task.new({ say 'making some money' }),
                Task.new({ say 'going to the store' })
            ),
            Task.new({ say 'cleaning kitchen' })
        )
    );</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意自定义构造函数和明智的空白使用如何清除任务依赖关系。</p>
</div>
<div class="paragraph">
<p>最后，<code>perform</code> 方法调用按顺序递归调用各种其他依赖项上的 <code>perform</code> 方法，并给出以下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">making some money
going to the store
buying food
cleaning kitchen
making dinner
eating dinner. NOM!</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_继承">13.8. 继承</h3>
<div class="paragraph">
<p>面向对象编程提供了继承的概念，作为代码重用的机制之一。 Raku 支持一个类从一个或多个类继承的能力。当一个类从另一个类继承时，它会通知方法调度器遵循继承链寻找一个派发方法。对于通过方法关键字定义的标准方法以及通过其他方式(如属性访问器)生成的方法，都会发生这种情况。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Employee {
    has $.salary;
}

class Programmer is Employee {
    has @.known_languages is rw;
    has $.favorite_editor;

    method code_to_solve( $problem ) {
        return "Solving $problem using $.favorite_editor in "
        ~ $.known_languages[0];
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，Programmer类型的任何对象都可以使用Employee类中定义的方法和访问器，就像它们来自Programmer类一样。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $programmer = Programmer.new(
    salary =&gt; 100_000,
    known_languages =&gt; &lt;Perl5 Raku Erlang C++&gt;,
    favorite_editor =&gt; 'vim'
);

say $programmer.code_to_solve('halting problem'), " will get ", $programmer.salary(), "\$";
#OUTPUT: «Solving halting problem using vim in Perl5 will get 100000$␤»</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_重写继承到的方法">13.8.1. 重写继承到的方法</h4>
<div class="paragraph">
<p>当然，类可以通过定义它们自己来覆盖由父类定义的方法和属性。下面的例子演示了 Baker 类覆盖 Cook 的 <code>cook</code> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Cook is Employee {
    has @.utensils  is rw;
    has @.cookbooks is rw;

    method cook( $food ) {
        say "Cooking $food";
    }

    method clean_utensils {
        say "Cleaning $_" for @.utensils;
    }
}

class Baker is Cook {
    method cook( $confection ) {
        say "Baking a tasty $confection";
    }
}

my $cook = Cook.new(
    utensils =&gt; &lt;spoon ladle knife pan&gt;,
    cookbooks =&gt; 'The Joy of Cooking',
    salary =&gt; 40000);

$cook.cook( 'pizza' );       # OUTPUT: «Cooking pizza␤»
say $cook.utensils.perl;     # OUTPUT: «["spoon", "ladle", "knife", "pan"]␤»
say $cook.cookbooks.perl;    # OUTPUT: «["The Joy of Cooking"]␤»
say $cook.salary;            # OUTPUT: «40000␤»

my $baker = Baker.new(
    utensils =&gt; 'self cleaning oven',
    cookbooks =&gt; "The Baker's Apprentice",
    salary =&gt; 50000);

$baker.cook('brioche');      # OUTPUT: «Baking a tasty brioche␤»
say $baker.utensils.perl;    # OUTPUT: «["self cleaning oven"]␤»
say $baker.cookbooks.perl;   # OUTPUT: «["The Baker's Apprentice"]␤»
say $baker.salary;           # OUTPUT: «50000␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为调度员会在 Baker 上移到父级之前看到 Cook 的 <code>cook</code> 方法，所以调用 Baker 的 <code>cook</code> 方法。</p>
</div>
<div class="paragraph">
<p>要访问继承链中的方法，请使用重新分派或 <code>MOP</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_多重继承">13.9. 多重继承</h3>
<div class="paragraph">
<p>如前所述，一个类可以从多个类继承。当一个类从多个类继承时，调度员知道在查找方法时要查看这两个类。 Raku 使用 <code>C3</code> 算法对多个继承层次进行线性化，这比深度优先搜索更好地处理多重继承。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class GeekCook is Programmer is Cook {
    method new( *%params ) {
        push( %params&lt;cookbooks&gt;, "Cooking for Geeks" );
        return self.bless(|%params);
    }
}

my $geek = GeekCook.new(
    books           =&gt; 'Learning Raku',
    utensils        =&gt; ('stainless steel pot', 'knife', 'calibrated oven'),
    favorite_editor =&gt; 'MacVim',
    known_languages =&gt; &lt;Raku&gt;
);

$geek.cook('pizza');
$geek.code_to_solve('P =? NP');</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在所有可用于 Programmer 和 Cook 类的方法都可以从 GeekCook 类中获得。</p>
</div>
<div class="paragraph">
<p>虽然多重继承是知道和偶尔使用的有用概念，但重要的是要了解有更多有用的 OOP 概念。当达到多重继承时，最好考虑是否通过使用角色来更好地实现设计，这通常更安全，因为它们强制类作者明确地解决冲突的方法名称。有关角色的更多信息，请参阅角色。</p>
</div>
</div>
<div class="sect2">
<h3 id="_also_声明符">13.10. also 声明符</h3>
<div class="paragraph">
<p>通过在特征前加上也可以在类声明主体中列出要继承的类。这也适用于角色组合特质。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class GeekCook {
    also is Programmer;
    also is Cook;
    # ...
}

role A {};
role B {};
class C { also does A; also does B }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_自省">13.11. 自省</h3>
<div class="paragraph">
<p>自省是在程序中收集有关某些对象的信息的过程，而不是通过阅读源代码，而是通过查询对象(或控制对象)来获取某些属性，例如其类型。</p>
</div>
<div class="paragraph">
<p>给定一个对象 <code>$o</code> 和前面几节的类定义，我们可以问一些问题:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $o ~~ Employee { say "It's an employee" };
if $o ~~ GeekCook { say "It's a geeky cook" };
say $o.WHAT;
say $o.perl;
say $o.^methods(:local)».name.join(', ');
say $o.^name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出可能如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">It's an employee
(Programmer)
Programmer.new(known_languages =&gt; ["Perl", "Python", "Pascal"],
        favorite_editor =&gt; "gvim", salary =&gt; "too small")
code_to_solve, known_languages, favorite_editor
Programmer</code></pre>
</div>
</div>
<div class="paragraph">
<p>前两个测试每个智能匹配类名称。如果对象是该类或继承类，则返回 true。因此，所讨论的对象是 <code>Employee</code> 类，或者是继承它的类，但不是 <code>GeekCook</code>。</p>
</div>
<div class="paragraph">
<p><code>.WHAT</code> 方法返回与对象 <code>$o</code> 关联的类型对象，它告诉我们 <code>$o</code> 的确切类型:在这种情况下是 <code>Programmer</code>。</p>
</div>
<div class="paragraph">
<p><code>$o.perl</code> 返回一个可以作为 Perl 代码执行的字符串，并且再现原始对象 <code>$o</code>。虽然这在所有情况下都不能很好地工作，但它对调试简单对象非常有用。 <code>$o.^methods(:local)</code> 产生一个可以在 <code>$o</code> 上调用的方法列表。 <code>:local</code> 命名参数将返回的方法限制为在 Programmer 类中定义的方法，并排除继承的方法。</p>
</div>
<div class="paragraph">
<p>使用 <code>.^</code> 而不是单个点调用方法的语法意味着它实际上是对其元类的一个方法调用，该类是管理 Programmer 类的属性的类 - 或者您感兴趣的任何其他类。班级也启用了其他反省方式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $o.^attributes.join(', ');
say $o.^parents.map({ $_.^name }).join(', ');</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，<code>$o.^name</code> 调用元对象的名称方法，这毫不意外地返回类名称。</p>
</div>
<div class="paragraph">
<p>自省对于调试和学习语言和新库非常有用。当一个函数或方法返回一个你不知道的对象时，用 <code>.WHAT</code> 查找它的类型，用 <code>.perl</code> 等等来查看它的构造方法，你会很清楚它的返回值是什么。使用 <code>.^</code> 方法，您可以了解您可以对课程做些什么。</p>
</div>
<div class="paragraph">
<p>但也有其他应用程序:将对象序列化为一串字节的例程需要知道该对象的属性，可以通过内省查找该对象的属性。</p>
</div>
</div>
<div class="sect2">
<h3 id="_重写默认的_gist_方法">13.12. 重写默认的 gist 方法</h3>
<div class="paragraph">
<p>有些类可能需要它自己的版本，它会覆盖当被调用以提供类的默认表示时被打印的简洁方式。例如，异常可能只想写入有效负载而不是完整对象，以便更清楚发生了什么。但是，每个班级你都可以这样做:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Cook {
    has @.utensils  is rw;
    has @.cookbooks is rw;

    method cook( $food ) {
        return "Cooking $food";
    }

    method clean_utensils {
        return "Cleaning $_" for @.utensils;
    }

    multi method gist(Cook:U:) { '⚗' ~ self.^name ~ '⚗' }
    multi method gist(Cook:D:) { '⚗ Cooks with ' ~ @.utensils.join( " ‣ ") ~ ' using ' ~ @.cookbooks.map( "«" ~ * ~ "»").join( " and ") }
}

my $cook = Cook.new(
    utensils =&gt; &lt;spoon ladle knife pan&gt;,
    cookbooks =&gt; ['Cooking for geeks','The French Chef Cookbook']);

say Cook.gist; # OUTPUT: «⚗Cook⚗»
say $cook.gist; # OUTPUT: «⚗ Cooks with spoon ‣ ladle ‣ knife ‣ pan using «Cooking for geeks» and «The French Chef Cookbook»␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常你会想定义两个方法，一个用于类，另一个用于实例;在这种情况下，类方法使用 alambic 符号，下面定义的实例方法聚合了我们在厨师上的数据以叙述方式显示。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>例如，封闭不容易以这种方式复制;如果你不知道封闭是什么，不要担心。此外，当前的实现方式在倾倒循环数据结构方面存在问题，但预期它们可以在某些时候由 <code>.perl</code> 正确处理。</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_命令行接口_概述">14. 命令行接口 - 概述</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 脚本的默认命令行界面由三部分组成：</p>
</div>
<div class="sect2">
<h3 id="_将命令行参数解析为捕获">14.1. 将命令行参数解析为捕获</h3>
<div class="paragraph">
<p>这将查看 <a href="https://docs.raku.org/language/variables#index-entry-%40%2AARGS">@*ARGS</a> 中的值，根据某些策略解释这些值，并创建一个 <code>Capture</code> 对象。解析器的替代方式可以由开发者提供或使用模块安装。</p>
</div>
</div>
<div class="sect2">
<h3 id="_使用该捕获调用提供的main子例程">14.2. 使用该捕获调用提供的MAIN子例程</h3>
<div class="paragraph">
<p>标准多<a href="https://docs.raku.org/language/functions#index-entry-declarator_multi-Multi-dispatch">分重分派</a>用于使用生成的 <code>Capture</code> 对象调用 MAIN 子例程。这意味着您的 MAIN子 例程可能是一个 <code>multi sub</code>，其中每个候选程序负责处理给定命令行参数的某些部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="_如果调用_main_失败则创建显示使用信息">14.3. 如果调用 MAIN 失败，则创建/显示使用信息</h3>
<div class="paragraph">
<p>如果多重分派失败，则应尽可能通知脚本的用户失败的原因。默认情况下，这是通过检查每个 MAIN 候选 sub 的签名以及任何关联的 pod 信息来完成的。然后在 STDERR 上向用户显示结果（如果指定了 <code>--help</code>，则在 STDOUT 上显示）。生成使用信息的替代方式可以由开发者提供或使用模块安装。</p>
</div>
</div>
<div class="sect2">
<h3 id="_sub_main">14.4. sub MAIN</h3>
<div class="paragraph">
<p>在运行所有相关的输入phasers（<code>BEGIN</code>，<code>CHECK</code>，<code>INIT</code>，<code>PRE</code>，<code>ENTER</code>）并执行脚本的主线之后，将执行具有特殊名称 MAIN 的子程序。如果没有 MAIN sub，则不会发生错误：您的脚本只需要在脚本的主线中执行工作，例如参数解析。</p>
</div>
<div class="paragraph">
<p>从 MAIN sub 的任何正常退出将导致退出代码为 <code>0</code>，表示成功。 MAIN 子的任何返回值都将被忽略。如果抛出未在 MAIN 子内部处理的异常，则退出代码将为 <code>1</code>。如果调度到 <code>MAIN</code> 失败，则在 STDERR 上将显示一条用法消息，退出代码将为 2。</p>
</div>
<div class="paragraph">
<p>命令行参数存在于 <code>@*ARGS</code> 动态变量中，并且可以在调用 MAIN 单元之前在脚本的主线中进行更改。</p>
</div>
<div class="paragraph">
<p>（多个子 MAIN 的候选者）的签名确定使用标准<a href="https://docs.raku.org/language/glossary#index-entry-Multi-Dispatch">多重分派</a>语义实际调用哪个候选者。</p>
</div>
<div class="paragraph">
<p>一个简单的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># inside file 'hello.p6'
sub MAIN($name) {
    say "Hello $name, how are you?"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您调用该脚本没有任何参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku hello.p6
Usage:
  hello.p6 &lt;name&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果为参数指定默认值，则无论是否指定名称，运行脚本始终有效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># inside file 'hello.p6'
sub MAIN($name = 'bashful') {
    say "Hello $name, how are you?"
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku hello.p6
Hello bashful, how are you?</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku hello.p6 Liz
Hello Liz, how are you?</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种方法是使 <code>sub MAIN</code> 成为一个 <code>multi sub</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># inside file 'hello.p6'
multi sub MAIN()      { say "Hello bashful, how are you?" }
multi sub MAIN($name) { say "Hello $name, how are you?"   }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将提供与上述示例相同的输出。您是否应该使用任何一种方法来实现预期目标完全取决于您。</p>
</div>
<div class="paragraph">
<p>使用单个位置和多个命名参数的更复杂的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># inside "frobnicate.p6"
sub MAIN(
  Str   $file where *.IO.f = 'file.dat',
  Int  :$length = 24,
  Bool :$verbose
) {
    say $length if $length.defined;
    say $file   if $file.defined;
    say 'Verbosity ', ($verbose ?? 'on' !! 'off');
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了 <code>file.dat</code>，这将以这种方式工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku frobnicate.p6
24
file.dat
Verbosity off</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者这样 <code>--verbose</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku frobnicate.p6 --verbose
24
file.dat
Verbosity on</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果文件 <code>file.dat</code> 不存在，或者您指定了另一个不存在的文件名，您将获得从 <code>MAIN</code> 子的内省创建的标准用法消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku frobnicate.p6 doesntexist.dat
Usage:
  frobnicate.p6 [--length=&lt;Int&gt;] [--verbose] [&lt;file&gt;]</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然您不必在代码中执行任何操作，但它仍然可能被视为有点简洁。但是通过使用 pod 功能提供提示，有一种简单的方法可以更好地使用该消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># inside "frobnicate.p6"
sub MAIN(
  Str   $file where *.IO.f = 'file.dat',  #= an existing file to frobnicate
  Int  :$length = 24,                     #= length needed for frobnication
  Bool :$verbose,                         #= required verbosity
) {
    say $length if $length.defined;
    say $file   if $file.defined;
    say 'Verbosity ', ($verbose ?? 'on' !! 'off');
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>哪个会改善这样的用法消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku frobnicate.p6 doesntexist.dat
Usage:
  frobnicate.p6 [--length=&lt;Int&gt;] [--verbose] [&lt;file&gt;]

    [&lt;file&gt;]          an existing file to frobnicate
    --length=&lt;Int&gt;    length needed for frobnication
    --verbose         required verbosity</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sub_main_opts">14.5. %*SUB-MAIN-OPTS</h3>
<div class="paragraph">
<p>通过设置 <code>%*SUB-MAIN-OPTS</code> 哈希中的选项，可以在将参数传递给 <code>sub MAIN {}</code> 之前更改参数的处理方式。由于动态变量的性质，需要设置 <code>%*SUB-MAIN-OPTS</code> 哈希并使用适当的设置填充它。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %*SUB-MAIN-OPTS =
  :named-anywhere,    # allow named variables at any location
  # other possible future options / custom options
;
sub MAIN ($a, $b, :$c, :$d) {
    say "Accepted!"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可用选项包括：</p>
</div>
</div>
<div class="sect2">
<h3 id="_named_anywhere">14.6. named-anywhere</h3>
<div class="paragraph">
<p>默认情况下，传递给程序的命名参数（即 <code>MAIN</code>）在任何位置参数后都不会出现。但是，如果将 <code>%*SUB-MAIN-OPTS&lt;named-anywhere&gt;</code> 设置为 true 值，则可以在任何位置指定命名参数，即使在位置参数之后也是如此。例如，可以使用以下命令调用上述程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku example.p6 1 --c=2 3 --d=4</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_is_hidden_from_usage">14.7. is hidden-from-USAGE</h3>
<div class="paragraph">
<p>有时您希望排除MAIN候选者显示在任何自动生成的使用消息中。这可以通过向您不想显示的 MAIN 候选者的规范添加 <code>hidden-from-USAGE</code> 特征来实现。扩展前面的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># inside file 'hello.p6'
multi sub MAIN() is hidden-from-USAGE {
    say "Hello bashful, how are you?"
}
multi sub MAIN($name) {  #= the name by which you would like to be called
    say "Hello $name, how are you?"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，如果您只使用命名变量调用此脚本，您将获得以下用法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku hello.p6 --verbose
Usage:
  hello.p6 &lt;name&gt; -- the name by which you would like to be called</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有第一个候选者 <code>hidden-from-USAGE</code> 特征，它看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku hello.p6 --verbose
Usage:
  hello.p6
  hello.p6 &lt;name&gt; -- the name by which you would like to be called</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然技术上是正确的，但也不能读。</p>
</div>
</div>
<div class="sect2">
<h3 id="_main_的单位作用域定义">14.8. MAIN 的单位作用域定义</h3>
<div class="paragraph">
<p>如果整个程序体驻留在 <code>MAIN</code> 中，则可以使用单位声明符，如下所示（调整前面的示例）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit sub MAIN(
  Str   $file where *.IO.f = 'file.dat',
  Int  :$length = 24,
  Bool :$verbose,
);  # &lt;- note semicolon here

say $length if $length.defined;
say $file   if $file.defined;
say 'Verbosity ', ($verbose ?? 'on' !! 'off');
# rest of script is part of MAIN</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，这只适用于只有一个（仅）<code>sub MAIN</code> 的情况。</p>
</div>
</div>
<div class="sect2">
<h3 id="_sub_usage">14.9. sub USAGE</h3>
<div class="paragraph">
<p>如果找不到给定命令行参数的 <code>MAIN</code> 的多候选者，则调用 sub <code>USAGE</code>。如果未找到此类方法，编译器将输出默认用法消息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#|(is it the answer)
multi MAIN(Int $i) { say $i == 42 ?? 'answer' !! 'dunno' }
#|(divide two numbers)
multi MAIN($a, $b){ say $a/$b }

sub USAGE() {
    print Q:c:to/EOH/;
    Usage: {$*PROGRAM-NAME} [number]

    Prints the answer or 'dunno'.
EOH
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过只读 <code>$*USAGE</code> 变量，sub <code>USAGE</code> 内的默认用法消息可用。它将基于可用的 <code>sub MAIN</code> 候选者及其参数生成。如前所示，您可以使用 <code>#|(&#8230;&#8203;)</code> Pod 块为每个候选项指定其他扩展描述以设置 <a href="https://docs.raku.org/routine/WHY">WHY</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_拦截_cli_参数解析2018_10_v6_d_and_later">14.10. 拦截 CLI 参数解析(2018.10, v6.d and later)</h3>
<div class="paragraph">
<p>您可以通过自己提供 <code>ARGS-TO-CAPTURE</code> 子例程，或者从生态系统中可用的任何 <a href="https://modules.raku.org/search/?q=getopt">Getopt</a> 模块中导入一个子例程来替换或扩充参数解析的默认方式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_sub_args_to_capture">14.11. sub ARGS-TO-CAPTURE</h3>
<div class="paragraph">
<p><code>ARGS-TO-CAPTURE</code> 子程序应该接受两个参数：一个 <a href="https://docs.raku.org/type/Callable">Callable</a> 表示要执行的 <code>MAIN</code> 单元（因此可以在必要时进行内省）和一个带有来自命令行的参数的数组。它应该返回一个将用于调度 <code>MAIN</code> 单元的 <a href="https://docs.raku.org/type/Capture">Capture</a> 对象。一个非常人为的例子，它将根据输入的某个关键字创建一个 <code>Capture</code>（在测试脚本的命令行界面时可以很方便）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub ARGS-TO-CAPTURE(&amp;main, @args --&gt; Capture) {
    # if we only specified "frobnicate" as an argument
    @args == 1 &amp;&amp; @args[0] eq 'frobnicate'
      # then dispatch as MAIN("foo","bar",verbose =&gt; 2)
      ?? Capture.new( list =&gt; &lt;foo bar&gt;, hash =&gt; { verbose =&gt; 2 } )
      # otherwise, use default processing of args
      !! &amp;*ARGS-TO-CAPTURE(&amp;main, @args)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，动态变量 <a href="https://docs.raku.org/language/variables#%26%2AARGS-TO-CAPTURE">&amp;*ARGS-TO-CAPTURE</a> 可用于执行捕获处理的默认命令行参数，因此如果您不想，则不必重新发明整个轮子。</p>
</div>
</div>
<div class="sect2">
<h3 id="_拦截使用消息生成2018_10v6_d及更高版本">14.12. 拦截使用消息生成（2018.10，v6.d及更高版本）</h3>
<div class="paragraph">
<p>您可以通过自己提供 <code>GENERATE-USAGE</code> 子例程，或者从生态系统中可用的任何 <a href="https://modules.raku.org/search/?q=getopt">Getopt</a> 模块导入一个子例程来替换或扩充默认的使用方式消息生成方式（在向 MAIN 发送失败之后）。</p>
</div>
<div class="sect3">
<h4 id="_sub_run_main">14.12.1. sub RUN-MAIN</h4>
<div class="paragraph">
<p>定义为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub RUN-MAIN(&amp;main, $mainline, :$in-as-argsfiles)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">该程序允许完全控制 <code>MAIN</code> 的处理。它得到一个 <code>Callable</code>，它是应该执行的 <code>MAIN</code>，主线执行的返回值和其他命名变量</dt>
<dd>
<p><code>in-as-argsfiles</code> 如果 STDIN 应该被视为 <code>$*ARGFILES</code>，它将为 <code>True</code>。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>如果未提供 <code>RUN-MAIN</code>，将运行默认的 <code>RUN-MAIN</code> 以查找旧接口的子例程，例如 <code>MAIN_HELPER</code> 和 <code>USAGE</code>。如果找到，将执行“旧”语义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Hero {
    has @!inventory;
    has Str $.name;
    submethod BUILD( :$name, :@inventory ) {
        $!name = $name;
        @!inventory = @inventory
    }
}

sub new-main($name, *@stuff ) {
    Hero.new(:name($name), :inventory(@stuff) ).perl.say
}

RUN-MAIN( &amp;new-main, Nil );</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将打印生成的对象的名称（第一个参数）。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sub_generate_usage">14.13. sub GENERATE-USAGE</h3>
<div class="paragraph">
<p><code>GENERATE-USAGE</code> 子例程应该接受一个 <code>Callable</code>，表示由于调度失败而未执行的 <code>MAIN</code> 子例程。这可以用于内省。所有其他参数都是设置为发送到MAIN的参数。它应该返回您想要显示给用户的使用信息的字符串。这个例子只是重新创建从处理参数创建的 <code>Capture</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub GENERATE-USAGE(&amp;main, |capture) {
    capture&lt;foo&gt;:exists
      ?? "You're not allowed to specify a --foo"
      !! &amp;*GENERATE-USAGE(&amp;main, |capture)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用 multi 子例程来创建相同的效果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub GENERATE-USAGE(&amp;main, :$foo!) {
    "You're not allowed to specify a --foo"
}
multi sub GENERATE-USAGE(&amp;main, |capture) {
    &amp;*GENERATE-USAGE(&amp;main, |capture)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，动态变量 <a href="https://docs.raku.org/language/variables#%26%2AGENERATE-USAGE"><code>&amp;*GENERATE-USAGE</code></a> 可用于执行默认使用消息生成，因此您不必重新发明整个轮子。</p>
</div>
</div>
<div class="sect2">
<h3 id="_拦截_main_调用2018_10之前v6_e">14.14. 拦截 MAIN 调用（2018.10之前，v6.e）</h3>
<div class="paragraph">
<p>较旧的接口使得一个接口完全拦截对 <code>MAIN</code> 的调用。这取决于是否存在 <code>MAIN_HELPER</code> 子程序，如果在程序的主线中找到 <code>MAIN</code> 子程序，则该子程序将被调用。</p>
</div>
<div class="paragraph">
<p>此接口从未记录过。但是，使用此未记录的界面的任何程序将继续运行，直到 <code>v6.e</code>。从 <code>v6.d</code> 开始，使用未记录的 API 将导致 <code>DEPRECATED</code> 消息。</p>
</div>
<div class="paragraph">
<p>生态系统模块可以提供新旧接口，以便与旧版本的 Raku 兼容：如果较新的 Raku 识别出新的（记录的）接口，它将使用它。如果没有可用的新接口子例程，但旧的 <code>MAIN_HELPER</code> 接口是，那么它将使用旧接口。</p>
</div>
<div class="paragraph">
<p>如果模块开发人员决定仅为 <code>v6.d</code> 或更高版本提供模块，则可以从模块中删除对旧接口的支持。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_并发">15. 并发</h2>
<div class="sectionbody">
<div class="paragraph">
<p>与大多数现代编程语言一样，Raku 被设计为<a href="https://en.wikipedia.org/wiki/Concurrent_computing">支持并发</a>（允许多个事件同时发生）和异步编程（有时称为事件驱动或反应式编程 - 即程序某些部分的事件或变化可能会导致程序流异步地改变程序的其它部分）。</p>
</div>
<div class="paragraph">
<p>Perl 的并发设计的目的是提供一个高层级的，可组合的，一致的接口，而不管如下所述的虚拟机通过工具层怎样为特定操作的系统来实现它。</p>
</div>
<div class="paragraph">
<p>此外，某些 Perl 的特性可以隐式地以异步的方式操作，所以为了确保这些特性可预测的互通，用户代码应在可能情况下，避免较低层级的并发的 API（即<a href="https://docs.raku.org/type/Thread">线程</a>和<a href="https://docs.raku.org/type/Scheduler">调度器</a>），并使用高层级接口。</p>
</div>
<div class="sect2">
<h3 id="_high_level_apis">15.1. High-level APIs</h3>
<div class="sect3">
<h4 id="_promises">15.1.1. Promises</h4>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Promise">Promise</a>（在其他编程环境中也被称为 <strong>future</strong>）封装了在获得 promise 时可能尚未完成或甚至未开始的计算结果。<code>Promise</code> 从 <code>Planned</code> 状态开始, 结果要么是 <code>Kept</code> 状态, 这意味着该 promise 已成功完成, 要么是 <code>Broken</code> 状态, 意味着该 promise 已失败。 通常这就是用户代码需要以并行或异步方式操作的使用最多的功能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $p1 = Promise.new;
say $p1.status;       # OUTPUT: «Planned␤»
$p1.keep('Result');
say $p1.status;       # OUTPUT: «Kept␤»
say $p1.result;       # OUTPUT: «Result␤»
                      # (since it has been kept, a result is available!)

my $p2 = Promise.new;
$p2.break('oh no');
say $p2.status;       # Broken
say $p2.result;       # dies, because the promise has been broken

CATCH { default { say .^name, ': ', .Str } };
# OUTPUT: «X::AdHoc+{X::Promise::Broken}: oh no␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Promise</code> 通过组合, 例如通过链接(chaining), 通常通过 <a href="https://docs.raku.org/type/Promise#method_then">then</a> 方法获取更多力量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise1 = Promise.new();
my $promise2 = $promise1.then(
    -&gt; $v { say $v.result; "Second Result"}
);
$promise1.keep("First Result");
say $promise2.result;   # First Result \n Second Result</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里 <a href="https://docs.raku.org/type/Promise#method_then">then</a> 方法安排代码(即圆括号中的闭包)在第一个 <a href="https://docs.raku.org/type/Promise">Promise</a> 为 kept 或 broken 时执行, 它自身返回一个新的 Promise, 这个新的 Promise 会在执行代码时与结果一块保存。 (如果代码执行失败则 broken ) <code>keep</code> 更改 promise 的状态为 <strong>Kept</strong>, 并设置结果为位置参数。<code>result</code> 阻塞当前执行的线程直到那个 promise 变为 kept 或 broken, 如果它是 kept, 那么它会返回那个结果(即传递给 <code>keep</code> 的值, ) 否则它会根据传递给 <code>break</code> 的值抛出异常。后者的行为如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise1 = Promise.new();
my $promise2 = $promise1.then(-&gt; $v { say "Handled but : "; say $v.result});
$promise1.break("First Result");
try $promise2.result;
say $promise2.cause;        # Handled but : \n First Result</code></pre>
</div>
</div>
<div class="paragraph">
<p>当它在原来的作为参数传递的 promise 上调用 <code>result</code> 方法时, 这里的 <code>break</code> 会导致 <code>then</code> 代码块抛出异常, 这随后会导致第二个 promise 变为 broken, 在它的结果被接收时反过来引发一个异常。然后能从 <code>cause</code> 中访问那个实际的 <a href="https://docs.raku.org/type/Exception">Exception</a> 对象。如果那个 promise 还没有变为 broken, 那么 <code>cause</code> 会引发 <a href="https://docs.raku.org/type/X$COLON$COLONPromise$COLON$COLONCauseOnlyValidOnBroken">X::Promise::CauseOnlyValidOnBroken</a> 异常。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Promise">Promise</a> 也可以安排在未来自动保存(kept):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise1 = Promise.in(5);
my $promise2 = $promise1.then(-&gt; $v { say $v.status; 'Second Result' });
say $promise2.result; # 5 秒后打印出: Kept\n Second Result</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Promise#method_in">in</a> 方法创建了一个新的 promise 并安排一个新的任务在不早于所提供的秒数内在它身上调用 <code>keep</code>, 返回一个新的 <a href="https://docs.raku.org/type/Promise">Promise</a> 对象。</p>
</div>
<div class="paragraph">
<p>promises 的一个非常频繁的用法是运行一段代码, 并且一旦它成功地返回就 keep 那个 promise, 或者当那块代码死掉时中断(break)那个 promise。<a href="https://docs.raku.org/type/Promise#method_start">start</a> 方法为此提供了一种快捷方式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.start(
    { my $i = 0; for 1 .. 10 { $i += $_ }; $i}
);
say $promise.status;    # Kept
say $promise.result;    # 55</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里返回的 promise 的结果(<code>result</code>)是从代码返回的值。类似地, 如果那段代码失败了(那个 promise 也因此被中断), 那么 <code>cause</code> 会成为抛出的那个 <a href="https://docs.raku.org/type/Exception">Exception</a> 对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.start({ die "Broken Promise" });
try $promise.result; # Nil
say $promise.cause;  # Broken Promise
                     #  in block &lt;unit&gt; at &lt;unknown file&gt; line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个模式太常见了以至于它还提供了子例程形式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = start {
    my $i = 0;
    for 1 .. 10 {
        $i += $_
    }
    $i
}
my $result = await $promise;
say $result;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>await</code> 几乎等价于在由 <code>start</code> 返回的 promise 对象身上调用 <code>result</code> 但是它也会接受一组 promises 并返回每个 promise 的结果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $p1 = start {
    my $i = 0;
    for 1 .. 10 {
        $i += $_
    }
    $i
};
my $p2 = start {
    my $i = 0;
    for 1 .. 10 {
        $i -= $_
    }
    $i
};
my @result = await $p1, $p2;
say @result;            # [55 -55]</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了 <code>await</code> 之外, 两个类方法把几个 <a href="https://docs.raku.org/type/Promise">Promise</a> 对象合并到一个新的 promise 对象中: 当所有原来的 promises 是 kept 或 broken 时, <code>allof</code> 返回一个 kept 状态的 promise:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.allof(
    Promise.in(2),
    Promise.in(3)
);

await $promise;
say "All done"; # Should be not much more than three seconds later</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且当原 promises 中的任何一个的状态变为 kept 或 broken 时, <code>anyof</code> 返回将为 kept 的新 promise:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = Promise.anyof(
    Promise.in(3),
    Promise.in(8600)
);

await $promise;
say "All done"; # Should be about 3 seconds later</code></pre>
</div>
</div>
<div class="paragraph">
<p>不同于 <code>await</code>，然而如果不引用原来的 promise, 那么就访问不了原来状态为 kept 的 promise 的结果，因此当任务的完成或其他方面对于消费者来说比实际结果更重要时，或者当通过其它方式收集结果时。 你可能，例如，您可以创建一个依赖的Promise，它会检查每个原始的 promise：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @promises;
for 1..5 -&gt; $t {
    push @promises, start {
        sleep $t;
        Bool.pick;
    };
}
say await Promise.allof(@promises).then({ so all(@promises&gt;&gt;.result) });</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果所有的 promise 都保持为 True, 那么它会打印 True, 否则会打印 False。</p>
</div>
<div class="paragraph">
<p>如果你正在创建一个 promise，你打算保持或中断自己，那么在你做之前, 你可能不想要任何可能会收到 promise 以无意（或否则）保持或中断该 promise 的代码。 为了这个目的，就有了方法 <a href="https://docs.raku.org/type/Promise#method_vow">vow</a>，它返回一个 <a href="https://docs.raku.org/type/Vow">Vow</a> 对象，它成为 promise 能被保留或中断的唯一机制。 如果试图直接保持或断开这个 Promise ，则会抛出 <a href="https://docs.raku.org/type/X$COLON$COLONPromise$COLON$COLONVowed">X::Promise::Vowed</a> 异常，只要 <code>vow</code> 对象保持私有，那么 promise 的状态就是安全的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub get_promise {
    my $promise = Promise.new;
    my $vow = $promise.vow;
    Promise.in(10).then({$vow.keep});
    $promise;
}

my $promise = get_promise();

# Will throw an exception
# "Access denied to keep/break this Promise; already vowed"
$promise.keep;</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回一个将被自动保存或断开的 promise 的方法，如 <code>in</code> 或 <code>start</code> 将会做到这一点，所以没有必要这样做。</p>
</div>
</div>
<div class="sect3">
<h4 id="_supplies">15.1.2. Supplies</h4>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Supply">Supply</a> 是异步数据流传输机制，其可以以类似于其他编程语言中的"事件"的方式同时由一个或多个消费者消费，并且可以被视为开启"事件驱动"或反应式设计。</p>
</div>
<div class="paragraph">
<p>最简单的是，Supply 是一个消息流，可以有多个通过方法 <code>tap</code> 创建的订阅者，其数据项可以使用 <code>emit</code> 放置。</p>
</div>
<div class="paragraph">
<p>Supply 可以是现场的(<code>live</code>)或按需的(<code>on-demand</code>)。 现场(<code>live</code>)供应就像电视广播：那些调入(收听/收看)的人不会得到先前发出的值。 点播(<code>on-demand</code>)广播就像 Netflix：每个开始流式传输电影（点击电源）的人，总是从头开始（获取所有的值），不管有多少人正在观看它。 请注意，没有为`按需`供应保留历史记录，而是为供应的每次点击运行 <code>supply</code> 块。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Netflix: 在线观看电影的网站</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>实时供应(<code>live Supply</code>)由 <a href="https://docs.raku.org/type/Supplier">Supplier</a> 工厂创建，每个发出的值在添加时传递给所有活动的 tappers：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supplier = Supplier.new;
my $supply   = $supplier.Supply;

$supply.tap( -&gt; $v { say $v });

for 1 .. 10 {
    $supplier.emit($_); # 1\n2\n3\n4\n5\n6\n7\n8\n9\n10
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>tap</code> 在供应商<a href="https://docs.raku.org/type/Supplier">Supplier</a>创建的 Supply 对象上调用，并且新值在供应商<a href="https://docs.raku.org/type/Supplier">Supplier</a>上发出。</p>
</div>
<div class="paragraph">
<p>或者作为由 <code>supply</code> 关键字创建的按需供应 <a href="https://docs.raku.org/type/Supply">Supply</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = supply {
    for 1 .. 10 {
        emit($_);
    }
}
$supply.tap( -&gt; $v { say $v });
# 1\n2\n3\n4\n5\n6\n7\n8\n9\n10</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，供应块中的代码在每次供应返回的供应被窃取时执行，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = supply {
    for 1 .. 10 {
        emit($_);
    }
}
$supply.tap( -&gt; $v { say "First : $v" });
$supply.tap( -&gt; $v { say "Second : $v" });</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>tap</code> 方法返回一个 <a href="https://docs.raku.org/type/Tap">Tap</a> 对象，它可以用来获取关于 tap 的信息，并且当我们不再对事件感兴趣时关闭它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supplier = Supplier.new;
my $supply   = $supplier.Supply;

my $tap = $supply.tap( -&gt; $v { say $v });

$supplier.emit("OK");
$tap.close;
$supplier.emit("Won't trigger the tap");</code></pre>
</div>
</div>
<div class="paragraph">
<p>在供应对象(supply object)上调用 <code>done</code> 调用可以为任何 tap 指定的 <code>done</code> 回调，但不会阻止任何其他事件被发送到流，或者接收它们。</p>
</div>
<div class="paragraph">
<p>方法 <code>interval</code> 返回一个新的按需供应，它会以指定的间隔定期发出一个新事件。 发出的数据是从0开始的整数，对于每个事件递增。 以下代码输出 0 .. 5：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval(2);
$supply.tap(-&gt; $v { say $v });
sleep 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也可以使用 <code>react</code> 关键字书写(输出0..4)：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    whenever Supply.interval(2) -&gt; $v {
        say $v;
        done() if $v == 4;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，<a href="https://docs.raku.org/language/concurrency#index-entry-whenever">whenever</a> 关键字使用 <a href="https://docs.raku.org/type/Supply#method_act">.act</a> 从提供的块在 Supply 上创建一个 tap。 当在其中一个 tap 中调用 <code>done()</code> 时，退出 <code>react</code> 块。</p>
</div>
<div class="paragraph">
<p>第二个参数可以提供给 <code>interval</code>，它指定第一个事件触发之前的延迟（以秒为单位）。 通过 <code>interval</code> 创建的 supply 的每个 tap 都有自0开始的自身序列，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = Supply.interval(2);
$supply.tap(-&gt; $v { say "First $v" });
sleep 6;
$supply.tap(-&gt; $v { say "Second $v"});
sleep 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以从将要依次发出的值的列表中按需创建 Supply(供给)，因此第一个按需示例（打印1到10）可以写作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    whenever Supply.from-list(1..10) -&gt; $v {
        say $v;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用方法 <code>grep</code> 和 <code>map</code> 分别过滤或转换现有的供应对象(supply object)，以类似具名列表方法的方式创建新供应(supply)：<code>grep</code> 返回这样一个供应(supply)，以至于只有在源流上发出的那些事件的 <code>grep</code> 条件为真时才在第二个 supply 上发出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supplier = Supplier.new;
my $supply = $supplier.Supply;
$supply.tap(-&gt; $v { say "Original : $v" });
my $odd_supply = $supply.grep({ $_ % 2 });
$odd_supply.tap(-&gt; $v { say "Odd : $v" });
my $even_supply = $supply.grep({ not $_ % 2 });
$even_supply.tap(-&gt; $v { say "Even : $v" });
for 0 .. 10 {
    $supplier.emit($_);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>map</code> 返回一个新的 supply(供应)，使得对于发送到原始供应的每个项目，发出作为传递给 <code>map</code> 表达式的结果的新项目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supplier = Supplier.new;
my $supply = $supplier.Supply;
$supply.tap(-&gt; $v { say "Original : $v" });
my $half_supply = $supply.map({ $_ / 2 });
$half_supply.tap(-&gt; $v { say "Half : $v" });
for 0 .. 10 {
    $supplier.emit($_);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要在 supply(供应)完成时运行一个操作，您可以通过在对 <code>tap</code> 的调用中设置 <code>done</code> 和 <code>quit</code> 选项来完成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$supply.tap: { ... },
    done =&gt; { say 'Job is done.' },
    quit =&gt; {
        when X::MyApp::Error { say "App Error: ", $_.message }
    };</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>quit</code> 块的工作方式非常类似于 <code>CATCH</code>。 如果异常被标记为由 <code>when</code> 或 <code>default</code> 块看到，那么异常会被捕获并处理。 否则，异常继续沿调用树向上（即，与没有设置 <code>quit</code> 时行为相同）。</p>
</div>
<div class="paragraph">
<p>如果你伴随着 <code>whenever</code> 使用 <code>react</code> 或者 <code>supply</code> block 语法，你可以在你的 <code>whenever</code> 块中添加 phasers 来处理来自 tapped supply 的 <code>done</code> 和 <code>quit</code> 消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">react {
    whenever $supply {
        ...; # your usual supply tap code here
        LAST { say 'Job is done.' }
        QUIT { when X::MyApp::Error { say "App Error: ", $_.message } }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的行为与在 <code>tap</code> 上设置 <code>done</code> 和 <code>quit</code> 相同。</p>
</div>
</div>
<div class="sect3">
<h4 id="_channels">15.1.3. Channels</h4>
<div class="paragraph">
<p>通道(<a href="https://docs.raku.org/type/Channel">Channel</a>)是线程安全的队列，可以具有多个读取器和写入器，可以被认为在操作上与“fifo”(先进先出)或命名管道相似，除了它不启用进程间通信之外。 应该注意的是，作为真正的队列，发送到通道的每个值将仅在先读，先服务的基础上对于单个读取器可用：如果想要多个读取器能够接收可能想要发送的每个项目那么请考虑<a href="https://docs.raku.org/type/Supply">Supply</a>。</p>
</div>
<div class="paragraph">
<p>项目(item)通过方法 <a href="https://docs.raku.org/type/Channel#method_send">send</a> 排队到通道上，方法 <a href="https://docs.raku.org/type/Channel#method_receive">receive</a> 从队列中删除一个项目并返回，如果队列为空，则阻塞它直到发送新项目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new;
$channel.send('Channel One');
say $channel.receive;  # 'Channel One'</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用 <a href="https://docs.raku.org/type/Channel#method_close">close</a> 方法关闭了通道，那么任何发送(<code>send</code>)都将导致抛出异常 <a href="https://docs.raku.org/type/X$COLON$COLONChannel$COLON$COLONSendOnClosed">X::Channel::SendOnClosed</a>，并且如果队列中没有更多的项目，接收(<code>receive</code>) 将抛出一个 <a href="https://docs.raku.org/type/X$COLON$COLONChannel$COLON$COLONReceiveOnClosed">X::Channel::ReceiveOnClosed</a> 异常。</p>
</div>
<div class="paragraph">
<p>方法<a href="https://docs.raku.org/type/Channel#method_list">list</a>返回通道上的所有项目，并将阻塞，直到其他项目被排队，除非通道关闭：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new;
await (^10).map: -&gt; $r {
    start {
        sleep $r;
        $channel.send($r);
    }
}
$channel.close;
for $channel.list -&gt; $r {
    say $r;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有从通道返回可用项目的非阻塞方法<a href="https://docs.raku.org/type/Channel#method_poll">poll</a>, 或者, 如果没有项目或通道被关闭则返回 <a href="https://docs.raku.org/type/Nil">Nil</a>，这当然意味着必须检查通道以确定其是否关闭：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $c = Channel.new;

# Start three Promises that sleep for 1..3 seconds, and then
# send a value to our Channel
^3 .map: -&gt; $v {
    start {
        sleep 3 - $v;
        $c.send: "$v from thread {$*THREAD.id}";
    }
}

# Wait 3 seconds before closing the channel
Promise.in(3).then: { $c.close }

# Continuously loop and poll the channel, until it's closed
my $is-closed = $c.closed;
loop {
    if $c.poll -&gt; $item {
        say "$item received after {now - INIT now} seconds";
    }
    elsif $is-closed {
        last;
    }

    say 'Doing some unrelated things...';
    sleep .6;
}

# Doing some unrelated things...
# Doing some unrelated things...
# 2 from thread 5 received after 1.2063182 seconds
# Doing some unrelated things...
# Doing some unrelated things...
# 1 from thread 4 received after 2.41117376 seconds
# Doing some unrelated things...
# 0 from thread 3 received after 3.01364461 seconds
# Doing some unrelated things...</code></pre>
</div>
</div>
<div class="paragraph">
<p>方法 <a href="https://docs.raku.org/type/Channel#method_closed">closed</a> 返回一个 Promise，当通道关闭时，它将被保存(kept)（因此在布尔上下文中将被计算为 True）。</p>
</div>
<div class="paragraph">
<p><code>.poll</code> 方法可以与 <code>.receive</code> 方法结合使用，作为一种缓存机制，其中 <code>.poll</code> 返回的值不足是需要获取更多值并加载到通道的信号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub get-value {
    return $c.poll // do { start replenish-cache; $c.receive };
}

sub replenish-cache {
    for ^20 {
        $c.send: $_ for slowly-fetch-a-thing();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用通道代替前面描述的 <code>whenever</code> 和 <code>react</code> 块中的 <a href="https://docs.raku.org/type/Supply">Supply</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $channel = Channel.new;
my $p = start {
    react {
        whenever $channel {
            say $_;
        }
    }
}

await (^10).map: -&gt; $r {
    start {
        sleep $r;
        $channel.send($r);
    }
}

$channel.close;
await $p;</code></pre>
</div>
</div>
<div class="paragraph">
<p>还可以使用<a href="https://docs.raku.org/type/Supply#method_Channel">通道方法</a>从<a href="https://docs.raku.org/type/Supply">Supply</a>获得<a href="https://docs.raku.org/type/Channel">通道</a>，该通道方法返回通过 <a href="https://docs.raku.org/type/Supply">Supply</a> 上的 <code>tap</code> 馈送的通道：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supplier = Supplier.new;
my $supply   = $supplier.Supply;
my $channel = $supply.Channel;

my $p = start {
    react  {
        whenever $channel -&gt; $item {
            say "via Channel: $item";
        }
    }
}

await (^10).map: -&gt; $r {
    start {
        sleep $r;
        $supplier.emit($r);
    }
}

$supplier.done;
await $p;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Channel</code> 将返回一个不同的通道，每次调用时都会使用相同的数据。 这可以用于例如将 <a href="https://docs.raku.org/type/Supply">Supply</a> 输出到一个或多个通道以在程序中提供的不同接口。</p>
</div>
</div>
<div class="sect3">
<h4 id="_procasync">15.1.4. Proc::Async</h4>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Proc$COLON$COLONAsync">Proc::Async</a> 构建在所描述的设施上以异步方式运行并与外部程序交互：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $proc = Proc::Async.new('echo', 'foo', 'bar');

$proc.stdout.tap(-&gt; $v { print "Output: $v" });
$proc.stderr.tap(-&gt; $v { print "Error:  $v" });

say "Starting...";
my $promise = $proc.start;

await $promise;
say "Done.";

# Output:
# Starting...
# Output: foo bar
# Done.</code></pre>
</div>
</div>
<div class="paragraph">
<p>命令的路径以及命令的任何参数都提供给该构造函数。 该命令将不被执行，直到调用 <a href="https://docs.raku.org/type/Proc$COLON$COLONAsync#method_start">start</a>，它将返回一个 Promise，当程序退出时该 Promise 变为 kept 状态。 程序的标准输出和标准错误分别从 <a href="https://docs.raku.org/type/Proc$COLON$COLONAsync#method_stdout">stdout</a> 和 <a href="https://docs.raku.org/type/Proc$COLON$COLONAsync#method_stderr">stderr</a> 方法中作为 Supply 对象提供，可以根据需要进行分接。</p>
</div>
<div class="paragraph">
<p>如果要写入程序的标准输入，您可以给构造函数提供 <code>:w</code> 副词，并使用方法 <a href="https://docs.raku.org/type/Proc$COLON$COLONAsync#method_write">write</a>，<a href="https://docs.raku.org/type/Proc$COLON$COLONAsync#method_print">print</a> 或 <a href="https://docs.raku.org/type/Proc$COLON$COLONAsync#method_say">say</a> 在程序启动后写入打开的管道：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $proc = Proc::Async.new(:w, 'grep', 'foo');

$proc.stdout.tap(-&gt; $v { print "Output: $v" });

say "Starting...";
my $promise = $proc.start;

$proc.say("this line has foo");
$proc.say("this one doesn't");

$proc.close-stdin;
await $promise;
say "Done.";

# Output:
# Starting...
# Output: this line has foo
# Done.</code></pre>
</div>
</div>
<div class="paragraph">
<p>一些程序（例如本例中没有文件参数的 <code>grep</code>）在关闭标准输入之前不会退出，因此在完成写入后可以调用 <a href="https://docs.raku.org/type/Proc$COLON$COLONAsync#method_close-stdin">close-stdin</a>，以允许由 <code>start</code> 返回的 Promise 的状态变为 kept。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_low_level_apis">15.2. Low-level APIs</h3>
<div class="sect3">
<h4 id="_threads">15.2.1. Threads</h4>
<div class="paragraph">
<p>最低级别的并发接口由 <a href="https://docs.raku.org/type/Thread">Thread</a> 提供。 线程可以被认为是可以最终在处理器上运行的一段代码，其布置几乎完全由虚拟机和/或操作系统完成。 线程应该被考虑，对于所有意图，很大程度上是不受管理的，应避免在用户代码中直接使用它们。</p>
</div>
<div class="paragraph">
<p>线程可以被创建，然后随后实际运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $thread = Thread.new(code =&gt; { for  1 .. 10  -&gt; $v { say $v }});
# ...
$thread.run;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者可以在单个调用中创建和运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $thread = Thread.start({ for  1 .. 10  -&gt; $v { say $v }});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这两种情况下，由 <a href="https://docs.raku.org/type/Thread">Thread</a> 对象封装的代码的完成可以用 <code>finish</code> 方法来等待，该方法将阻塞直到线程完成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$thread.finish;</code></pre>
</div>
</div>
<div class="paragraph">
<p>除此之外，没有用于同步或资源共享的其他设施，这主要是为什么应当强调线程不可能直接用于用户代码。</p>
</div>
</div>
<div class="sect3">
<h4 id="_schedulers">15.2.2. Schedulers</h4>
<div class="paragraph">
<p>并发 API 的下一级由实现角色<a href="https://docs.raku.org/type/Scheduler">Scheduler</a>定义的接口的类提供。 调度程序接口的目的是提供一种机制来确定使用哪些资源来运行特定任务以及何时运行它。 大多数较高级别的并发 API 是基于调度器构建的，并且用户代码根本不需要使用它们，尽管一些方法，例如在 <a href="https://docs.raku.org/type/Proc$COLON$COLONAsync">Proc::Async</a>，<a href="https://docs.raku.org/type/Promise">Promise</a> 和 <a href="https://docs.raku.org/type/Supply">Supply</a> 中找到的方法允许您明确地提供调度器。</p>
</div>
<div class="paragraph">
<p>当前缺省全局调度程序在变量 <code>$*SCHEDULER</code> 中可用。</p>
</div>
<div class="paragraph">
<p>调度程序的主接口（确实是<a href="https://docs.raku.org/type/Scheduler">Scheduler</a>接口所需的唯一方法）是 <code>cue</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method cue(:&amp;code, Instant :$at, :$in, :$every, :$times = 1; :&amp;catch)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将按照由副词（如在<a href="https://docs.raku.org/type/Scheduler">Scheduler</a>中记录的）所确定的方式使用由调度器实现的执行方案来调度 <code>&amp;code</code> 中的 <code>Callable</code> 以执行。 例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $i = 0;
my $cancellation = $*SCHEDULER.cue({ say $i++}, every =&gt; 2 );
sleep 20;</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设 <code>$*SCHEDULER</code> 没有从默认值改变，将以大约每两秒打印数字0到10（即使用操作系统调度容差）。 在这种情况下，代码将被调度运行，直到程序正常结束，但是该方法返回一个 <a href="https://docs.raku.org/type/Cancellation">Cancellation</a> 对象，它可以用来在正常完成之前取消调度执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $i = 0;
my $cancellation = $*SCHEDULER.cue({ say $i++}, every =&gt; 2 );
sleep 10;
$cancellation.cancel;
sleep 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>应该只输出 0 到 5，</p>
</div>
<div class="paragraph">
<p>尽管 <a href="https://docs.raku.org/type/Scheduler">Scheduler</a> 接口提供的所有功能明显优于 <a href="https://docs.raku.org/type/Thread">Thread</a> 提供的，但是通过更高级别的接口可以获得所有的功能，并且不应该有必要直接使用调度器，除非在上述情况下，调度器可以被明确地提供给某些方法。</p>
</div>
<div class="paragraph">
<p>如果库具有特殊要求，例如 UI 库可能希望所有代码在单个 UI 线程中运行，或者可能需要一些定制的优先级机制，则库可能希望提供备选的调度器实现，然而，被作为标准的实现和下面的描述应该足以满足大多数用户代码。</p>
</div>
</div>
<div class="sect3">
<h4 id="_threadpoolscheduler">15.2.3. ThreadPoolScheduler</h4>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/ThreadPoolScheduler">ThreadPoolScheduler</a> 是默认调度程序，它维护一个根据需要分配的线程池，根据需要创建新的线程，直到创建调度程序对象时作为参数给出的最大数目（默认值为16）。如果超过最大值 那么 <code>cue</code> 可以对代码进行排队，直到线程变得可用为止。</p>
</div>
<div class="paragraph">
<p>Rakudo 允许在程序启动时由环境变量 <code>RAKUDO_MAX_THREADS</code> 在默认调度程序中设置允许的最大线程数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_currentthreadscheduler">15.2.4. CurrentThreadScheduler</h4>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/CurrentThreadScheduler">CurrentThreadScheduler</a> 是一个非常简单的调度程序，它将始终调度代码在当前线程上立即运行。 暗示这个调度器的 <code>cue</code> 将阻塞，直到代码完成执行，把它的效用限制在某些特殊情况，如测试。</p>
</div>
</div>
<div class="sect3">
<h4 id="_locks">15.2.5. Locks</h4>
<div class="paragraph">
<p>类 <a href="https://docs.raku.org/type/Lock">Lock</a> 在并发环境中提供了保护共享数据的低级机制，并因此是高级 API 中支持线程安全性的关键，这在其他编程语言中有时称为 “Mutex”。 因为较高级别的类（<a href="https://docs.raku.org/type/Promise">Promise</a>，<a href="https://docs.raku.org/type/Supply">Supply</a> 和 <a href="https://docs.raku.org/type/Channel">Channel</a>）在需要时使用 <a href="https://docs.raku.org/type/Lock">Lock</a>，所以用户代码不可能直接使用 Lock。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Lock">Lock</a> 的主接口是方法 <a href="https://docs.raku.org/type/Lock#method_protect">protect</a>，它确保一个代码块（通常称为“临界区”）只能在一个线程中同时执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $lock = Lock.new;

my $a = 0;

await (^10).map: {
    start {
            $lock.protect({
                my $r = rand;
                sleep $r;
                $a++;
            });
    }
}

say $a; # 10</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>protect</code> 返回代码块返回任何东西。</p>
</div>
<div class="paragraph">
<p>因为 <code>protect</code> 将阻止任何等着要执行临界区的线程，所以代码应该尽可能快。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_safety_concerns">15.3. Safety Concerns</h3>
<div class="paragraph">
<p>一些共享数据并发问题相比其他问题并不明显。 关于这个问题的好文章请看这个<a href="https://6guts.wordpress.com/2014/04/17/racing-to-writeness-to-wrongness-leads/">博客</a>。</p>
</div>
<div class="paragraph">
<p>要注意的一个特别的问题是当容器自动更新或发生扩展时。 当<a href="https://docs.raku.org/type/Array">数组</a>或<a href="https://docs.raku.org/type/Hash">哈希</a>条目被赋初始值时，底层结构被更改，并且那个操作不是异步安全的。 例如，在这段代码中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array;
my $slot := @array[20];
$slot = 'foo';</code></pre>
</div>
</div>
<div class="paragraph">
<p>第三行是临界区，因为那就是数组被扩展之时。 最简单的解决方法是使用 <code>&lt;Lock&gt;</code> 来保护临界区。 一个可能更好的解决方案是重构代码，以使共享容器不是必需的。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_核心模块_2">16. 核心模块</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Rakudo 实现包含一些您可能想要使用的模块。以下是它们的列表，以及它们的源代码的链接。</p>
</div>
<div class="sect2">
<h3 id="_compunit_模块和角色">16.1. <code>CompUnit::*</code> 模块和角色</h3>
<div class="paragraph">
<p>这些模块主要由分发构建工具使用，并不打算由最终用户使用（至少在版本6.c之前）。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/rakudo/rakudo/blob/master/lib/CompUnit/Repository/Staging.pm6"><code>CompUnit::Repository::Staging</code></a>.</p>
</li>
<li>
<p><a href="https://github.com/rakudo/rakudo/blob/master/src/core/CompUnit/RepositoryRegistry.pm6"><code>CompUnit::Repository::(FileSystem|Installation|AbsolutePath|Unknown|NQP|Raku|RepositoryRegistry)</code></a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_nativecall_模块">16.2. <code>NativeCall</code> 模块</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/rakudo/rakudo/blob/master/lib/NativeCall.pm6"><code>NativeCall</code></a> 原生调用接口 (<a href="https://docs.raku.org/language/nativecall.html">docs</a>)</p>
</li>
<li>
<p><a href="https://github.com/rakudo/rakudo/blob/master/lib/NativeCall/Types.pm6"><code>NativeCall::Types</code></a> 由 <code>NativeCall</code> 使用</p>
</li>
<li>
<p><a href="https://github.com/rakudo/rakudo/blob/master/lib/NativeCall/Compiler/GNU.pm6"><code>NativeCall::Compiler::GNU</code></a> 由 <code>NativeCall</code> 使用</p>
</li>
<li>
<p><a href="https://github.com/rakudo/rakudo/blob/master/lib/NativeCall/Compiler/MSVC.pm6"><code>NativeCall::Compiler::MSVC</code></a> 由 <code>NativeCall</code> 使用</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_其它模块">16.3. 其它模块</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/rakudo/rakudo/blob/master/lib/Pod/To/Text.pm6"><code>Pod::To::Text</code></a> 由多个外部模块使用</p>
</li>
<li>
<p><a href="https://github.com/rakudo/rakudo/blob/master/lib/Test.pm6"><code>Test</code></a> Test 子例程 (<a href="https://docs.raku.org/language/testing">docs</a>)</p>
</li>
<li>
<p><a href="https://github.com/rakudo/rakudo/blob/master/lib/experimental.pm6"><code>experimental</code></a></p>
</li>
<li>
<p><a href="https://github.com/rakudo/rakudo/blob/master/lib/newline.pm6"><code>newline</code></a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_使用_raku_做数学计算">17. 使用 Raku 做数学计算</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_sets">17.1. Sets</h3>
<div class="paragraph">
<p>Raku 包括 <a href="https://docs.raku.org/type/Set">Set</a> 数据类型，以及对<a href="https://docs.raku.org/language/setbagmix#Set%2FBag_Operators">大多数 set 操作</a>的支持。<a href="https://en.wikipedia.org/wiki/Algebra_of_sets">并集和交集</a>不仅是原生操作，它们使用自然符号 <code>∩</code> 和 <code>∪</code>。例如，此代码将检查有限数量集的集算术的基本定律：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @arbitrary-numbers = ^100;
my \U = @arbitrary-numbers.Set;

my @sets;

@sets.push: Set.new( @arbitrary-numbers.pick( @arbitrary-numbers.elems.rand)) for @arbitrary-numbers;

my (@union, @intersection);

for @sets -&gt; $set {
    @union.push: $set ∩ $set === $set;
    @intersection.push: $set ∪ $set === $set;
}

say "Idempotent union is ", so @union.all;
# OUTPUT: «Idempotent union is True»
say "Idempotent intersection is ", so @intersection.all;
# OUTPUT: «Idempotent intersection is True»
my (@universe, @empty-set, @id-universe, @id-empty);

for @sets -&gt; \A {
    @universe.push: A ∪ U === U;
    @id-universe.push: A ∩ U === A;
    @empty-set.push: A ∩ ∅ === ∅;
    @id-empty.push: A ∪ ∅ === A;
}

say "Universe dominates ", so @universe.all;    # OUTPUT: «Universe dominates True»
say "Empty set dominates ", so @empty-set.all;  # OUTPUT: «Empty set dominates True»

say "Identity with U ", so @id-universe.all;    # OUTPUT: «Identity with U True»
say "Identity with ∅ ", so @id-empty.all;       # OUTPUT: «Identity with ∅ True»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个使用 Raku 已经定义的<a href="https://docs.raku.org/language/setbagmix#term_%25E2%2588%2585">空集</a>的代码中，我们不仅检查集合代数中的等式是否成立，我们还通过<a href="https://docs.raku.org/language/variables#index-entry-%5C_%28sigilless_variables%29">无符号变量</a>和集合运算符的 Unicode 形式使用表达式。尽可能接近原始形式; 例如，<code>A ∪ U === U</code>，除了使用<a href="https://docs.raku.org/routine/===">值标识运算符 &#8656;=&#8658;</a> 与<a href="https://en.wikipedia.org/wiki/Algebra_of_sets">维基百科条目</a>中的实际数学表达式非常接近。</p>
</div>
<div class="paragraph">
<p>我们甚至可以测试摩根定律，如下面的代码所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @alphabet = 'a'..'z';
my \U = @alphabet.Set;
sub postfix:&lt;⁻&gt;(Set $a) { U ⊖ $a }
my @sets;
@sets.push: Set.new( @alphabet.pick( @alphabet.elems.rand)) for @alphabet;
my ($de-Morgan1,$de-Morgan2) = (True,True);
for @sets X @sets -&gt; (\A, \B){
    $de-Morgan1 &amp;&amp;= (A ∪ B)⁻  === A⁻ ∩ B⁻;
    $de-Morgan2 &amp;&amp;= (A ∩ B)⁻  === A⁻ ∪ B⁻;
}
say "1st De Morgan is ", $de-Morgan1;
say "2nd De Morgan is ", $de-Morgan2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们声明 - 作为补语运算，它计算通用集U和我们集之间的对称差⊖。一旦宣布这一点，就可以比较容易地表达诸如A和B的并集 <code>(A ∪ B)⁻</code> 的补集，其符号与原始数学符号非常接近。</p>
</div>
</div>
<div class="sect2">
<h3 id="_算术">17.2. 算术</h3>
<div class="paragraph">
<p>Raku 可以使用不同的数据类型进行算术运算。 <a href="https://docs.raku.org/type/Num">Num</a>，<a href="https://docs.raku.org/type/Rat">Rat</a> 和 <a href="https://docs.raku.org/type/Complex">Complex</a> 都可以<a href="https://en.wikipedia.org/wiki/Field_(mathematics">在操作加法，减法，乘法和除法下作为场</a>)运行。等效的数学领域是：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Raku class</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Field</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C&lt;Rat&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ℚ</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C&lt;Num&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ℝ</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C&lt;Complex&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ℂ</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><code>Int`s 虽然在技术上与 <strong>Z</strong> 相对应，但它并不是真正的数学领域，因为它们不是在四个算术运算下关闭的，并且整数不满足<a href="https://math.stackexchange.com/questions/2192317/set-of-integers-not-a-field/2192330">同一性公理</a>。但是，如果使用整数除法 `div</code>，它们的操作将始终产生其他整数;但是，如果使用 <code>/</code>，通常结果将是 <a href="https://docs.raku.org/type/Rat">Rat</a>。</p>
</div>
<div class="paragraph">
<p>此外，<code>Int</code> 可以进行无限精度算术（或者至少在存储器允许的情况下无限制;还可以发生数字溢出(<code>Numeric overflow</code>)），如果数字太大则不会回落到 <a href="https://docs.raku.org/type/Num">Num</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @powers = 2, 2 ** * ... Inf; say @powers[4].chars; # OUTPUT: «19729␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样严格地说，行为类似于数学领域的 Rational 类是 <a href="https://docs.raku.org/type/FatRat">FatRat</a>。出于效率原因，当数字足够大或者分子和分母之间存在很大差异时，操作 <code>Rats</code> 时会回落到 <code>Num</code>。 <code>FatRat</code> 可以使用任意精度，与默认的 <code>Int</code> 类相同。</p>
</div>
<div class="paragraph">
<p>生态系统中的某些模块可以使用数学方法处理其他数据类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/pierre-vigier/Raku-Math-Matrix">Math::Matrix</a> 操作矩阵字段。</p>
</li>
<li>
<p><a href="https://github.com/Util/Raku-Math-Quaternion">Math::Quaternion</a> 操作<a href="https://en.wikipedia.org/wiki/Quaternion">四元数字段</a>，这是复数的推广。</p>
</li>
<li>
<p><a href="https://github.com/colomon/Math-Polynomial">Math::Polynomial</a> 与多项式一起使用，并且能够用它们进行简单的算术运算。</p>
</li>
<li>
<p><a href="https://github.com/raydiak/Math-Symbolic">Math::Symbolic</a>，用于符号数学</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>数字会自动变为其实际表示的数字类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.^name.say for (4, ⅗, 1e-9, 3+.1i); # OUTPUT: «Int␤Rat␤Num␤Complex␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也使算术运算最适合特定类型</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say .33-.22-.11 == 0; # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这儿，所有数字都被解释为 `Rat`s，这使得操作准确。通常，大多数语言会将它们解释为浮点数，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say .33.Num -.22.Num - .11.Num; # OUTPUT: «1.3877787807814457e-17␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于这样的情况，Raku 还包括一个近似相等的运算符(` approximately equal `)，<a href="https://docs.raku.org/language/operators#infix_%3D~%3D">≅</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say .33.Num -.22.Num - .11.Num ≅ 0; # OUTPUT: «True␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_序列">17.3. 序列</h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Sequence">序列</a>是允许重复的对象的枚举集合，也是 Raku 中称为 <a href="https://docs.raku.org/type/Seq">Seq</a> 的第一类数据类型。 <code>Seq</code> 能够表示无限序列，如自然数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my \𝕟 = 1,2 … ∞;
say 𝕟[3];# OUTPUT: «4␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>无限序列使用 ∞，<code>Inf</code> 或 <code>*</code>（Whatever）作为终止符。 <code>&#8230;&#8203;</code> 是列表生成器，只要插入第一个数字，它实际上可以理解算术和几何级数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1,5,9 … * &gt; 100;
# OUTPUT: «(1 5 9 13 17 21 25 29 33 37 41 45 49 53 57 61 65 69 73 77 81 85 89 93 97 101)␤»
say 1,3,9 … * &gt; 337; # OUTPUT: «(1 3 9 27 81 243 729)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>当生成的数字大于 100 时，第一个序列将终止; 第二个序列，当它大于 337 时，是几何级数。</p>
</div>
<div class="paragraph">
<p>可以使用任意生成器的事实可以很容易地生成像 <a href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci</a> 这样的序列：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1,1, * + * … * &gt; 50;#  OUTPUT: «(1 1 2 3 5 8 13 21 34 55)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上，我们可以通过这种方式计算<a href="https://en.wikipedia.org/wiki/Golden_ratio">黄金比例</a>的近似值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @phis = (2.FatRat, 1 + 1 / * ... *);
my @otherphi = (1 - @phis[200], 1 + 1 / * ... *);
say @otherphi[^10, |(20, 30 ... 100)];# OUTPUT:
# «((-0.61803398874989484820458683436563811772030918
# -0.61803398874989484820458683436563811772030918
# -0.61803398874989484820458683436563811772030918
# -0.61803398874989484820458683436563811772030918
# -0.61803398874989484820458683436563811772030918
# -0.618033…»</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/ajs/raku-Math-Sequences">Math::Sequences</a> 模块包含许多已为你定义的数学序列。它定义了<a href="https://oeis.org/">百科全书中的许多序列</a>，其中一些序列的原始名称，如 ℤ 或 ℝ。</p>
</div>
<div class="paragraph">
<p>一些集合运算符也对序列进行操作，它们可用于查明对象是否是其中的一部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 876 ∈ (7,14 … * &gt; 1000) ; # OUTPUT: «False␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种特殊情况下，我们可以看出 <code>876</code> 是否是 7 的直接倍数，但同样的原理适用于使用复杂发生器的其他序列。我们也可以使用集合包含运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (55,89).Set ⊂ (1,1, * + * … * &gt; 200); # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然它没有考虑到它是否实际上是一个子序列，但这里只是存在两个元素;集合没有顺序，即使您没有将子序列显式地转换为Set或显式地将其转换为Seq，它也会被强制转换为包含运算符的应用程序。</p>
</div>
</div>
<div class="sect2">
<h3 id="_数学常数">17.4. 数学常数</h3>
<div class="paragraph">
<p>Raku 已经包含了一组数学常量作为核心的一部分。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say π; # OUTPUT: «3.141592653589793»
say τ; # Equivalent to 2π; OUTPUT: «6.283185307179586»
say 𝑒; # OUTPUT: «2.718281828459045␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>它们的拉丁名字 <code>e</code>, <code>pi</code> 和 <code>tau</code> 也是可得的, 具有相同的值 (尽管 <code>𝑒</code> 在 MoarVM 外面访问不了).</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/JJ/p6-math-constants/pulls">Math::Constants</a> 模块包括一系列额外的物理和数学常数，例如前面提到的黄金比率 <code>φ</code> 或普朗克常数 <code>ℎ</code>。</p>
</div>
<div class="paragraph">
<p>由于 Raku 允许定义使用 Unicode 字形的变量，以及没有任何类型的 sigil 的变量和常量名称，因此使用概念的实际数学名称来尽可能地命名它们被认为是一种好的做法。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_输入_unicode_字符">18. 输入 Unicode 字符</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 允许把 unicode 字符用作变量名. 很多操作符使用 unicode 符号(特别是在 set/bag 操作符中)还有一些引号结构. 因此, 知道如何把这些符号输入编辑器, Raku shell 和 命令行中是极好的, 特别是现实键盘中不存在那个符号的时候.</p>
</div>
<div class="paragraph">
<p>在各种操作系统和环境下关于输入 unicode 字符的通用信息可以在 Wikipedia <a href="https://en.wikipedia.org/wiki/Unicode_input">unicode 输入页</a> 中找到.</p>
</div>
<div class="sect2">
<h3 id="_xcompose_linux">18.1. XCompose (Linux)</h3>

</div>
<div class="sect2">
<h3 id="_wincomposewindows">18.2. WinCompose(Windows)</h3>
<div class="sect3">
<h4 id="_终端_shell和编辑器">18.2.1. 终端, shell和编辑器</h4>

</div>
<div class="sect3">
<h4 id="_vim">18.2.2. Vim</h4>
<div class="paragraph">
<p>在 Vim 中, unicode 字符是通过先按 <code>Ctrl-V</code>(也表示为 <code>^V</code>), 然后按下 <code>u</code> 和 要输入的 unicode 字符的十六进制值来输入的(在插入模式).  例如, 希腊字母  <code>λ</code> (lambda) 是通过组合键来输入的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">^Vu03BB</code></pre>
</div>
</div>
<div class="paragraph">
<p>更多关于在 Vim 中输入特殊字符的信息可以在 Vim Wikia 页 <a href="http://vim.wikia.com/wiki/Entering_special_characters">键入特殊字符</a> 中找到.</p>
</div>
</div>
<div class="sect3">
<h4 id="_emacs">18.2.3. Emacs</h4>
<div class="paragraph">
<p>在 Emacs 中, unicode 字符的输入是首先输入和弦 <code>Ctrl-x 8 Enter</code> , 然后再输入 unicode 代码点的十六进制数字, 然后回车. 因此, 要输入希腊字母 <code>λ (lambda)</code> 使用下面的组合键(命令之间添加了空格以使清晰):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Ctrl-x 8 Enter 3bb Enter</code></pre>
</div>
</div>
<div class="paragraph">
<p>更多关于在 Emacs 中输入 unicode 字符的信息可以在 <a href="http://www.emacswiki.org/emacs/UnicodeEncoding"> Unicode 编码 Emacs wiki 页面</a>  中找到.</p>
</div>
</div>
<div class="sect3">
<h4 id="_unix_shell">18.2.4. Unix shell</h4>
<div class="paragraph">
<p>在 bash shell 中, 要输入 unicode 字符先键入 <code>Ctrl-Shift-u</code>, 然后键入 unicode 代码点的值后回车. 例如, 要键入属于操作符(<code>∈</code>)这个 unicode 字符, 使用下面的组合键(添加的空白是为了清晰):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Ctrl-Shift-u 2208 Enter</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在 Unix shell 中开启了 REPL, 这也是一种在 perl 6 的 REPL 中输入 unicode 字符的方式之一.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_raku中有用的_unicode_字符">18.3. Raku中有用的 Unicode 字符</h3>
<div class="sect3">
<h4 id="_小引号">18.3.1. 小引号</h4>
<div class="paragraph">
<p>这些字符在法语和德语中是当作引号使用的. 在 Raku 中, 它们仍然用作引号(在 POD 中是单引号, 在普通代码中是双引号), 还可以标示超运算符. 下面是这些符号和它们的 unicode 十六进制值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">符号 unicode代码点 ascii equivalent
«	U+00AB	      &lt;&lt;
»	U+00BB	      &gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此, 下面这些结构是可用的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">C« fixed-width POD text »
say (1, 2) »+« (3, 4);     # 4 6 ; element-wise add
@array »+=» 42;            # add 42 to each element of @array
say «moo»;                 # moo
my $baa = 123; say «$baa»; # 123</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_setbag_操作符">18.3.2. Set/bag 操作符</h4>
<div class="paragraph">
<p>下面列出的 <a href="http://doc.raku.org/language/setbagmix#Set%2FBag_Operators">set/bag 操作符</a> 都有与集合理论相关的符号, unicode 代码点, 和它们的 ascii 等价物. 要构成这样的一个字符, 只需键入字符组合键(例如 Vim中的 <code>Ctrl-V u</code>, Bash 中的 <code>Ctrl-Shift-u</code>), 然后输入 unicode 代码点的十六进制数.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">操作符	unicode代码点	ascii equivalent
∈	  U+2208	    (elem)
∉	  U+2209	    !(elem)
∋	  U+220B	    (cont)
∌	  U+220C	    !(cont)
⊆	  U+2286	    (&lt;=)
⊈	  U+2288	    !(&lt;=)
⊂	  U+2282	    (&lt;)
⊄	  U+2284	    !(&lt;)
⊇	  U+2287	    (&gt;=)
⊉	  U+2289	    !(&gt;=)
⊃	  U+2283	    (&gt;)
⊅	  U+2285	    !(&gt;)
≼	  U+227C	    (&lt;+)
≽	  U+227D	    (&gt;+)
∪	  U+222A	    (|)
∩	  U+2229	    (&amp;)
∖	  U+2216	    (-)
⊖	  U+2296	    (^)
⊍	  U+228D	    (.)
⊎	  U+228E	    (+)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_数学符号">18.3.3. 数学符号</h4>
<div class="paragraph">
<p>Wikipedia 包含了一个 <a href="https://en.wikipedia.org/wiki/Mathematical_operators_and_symbols_in_Unicode">unicode 中数学操作符和符号</a> 的完整列表, 还有它们数学意义的链接.</p>
</div>
</div>
<div class="sect3">
<h4 id="_希腊字符">18.3.4. 希腊字符</h4>
<div class="paragraph">
<p>希腊字符可以用作变量名了. 查看 <a href="https://en.wikipedia.org/wiki/Greek_alphabet#Greek_in_Unicode">Greek in Unicode Wikipedia article</a> 列表获取希腊和埃及字符还有它们的 unicode 代码点.</p>
</div>
<div class="paragraph">
<p>例如, 把数值3赋值给 <code>π</code>, 在 Vim 中输入(添加的空格是为了清晰):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $Ctrl-V u 03C0 = 3;  # same as: my $π = 3;
say $Ctrl-V u 03C0;     # 3    same as: say $π;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_上标和下标">18.3.5. 上标和下标</h4>
<div class="paragraph">
<p>使用 <code>U+207x</code>, <code>U+208x</code> 和 (less often)  <code>U+209x</code> 范围能直接创建一个有限的<a href="http://en.wikipedia.org/wiki/Superscripts_and_Subscripts">上标和下标</a>的集合. 然而, 要生成一个值的平方或立方, 你需要使用 <code>U+00B2</code> 和 <code>U+00B3</code> , 因为这些被定义在 <a href="http://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block"> Latin1 supplement Unicode block</a>) 中.</p>
</div>
<div class="paragraph">
<p>因此, 要书写泰勒级数展开, 你可以在 Vim 中输入:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">exp(x) = 1 + x + xCtrl-V u 00B2/2! + xCtrl-V u 00B3/3! + ... + xCtrl-V u 207F/n!
# which would appear as
exp(x) = 1 + x + x²/2! + x³/3! + ... + xⁿ/n!</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者指定列表中从1到k 的元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> ACtrl-V u 2081, ACtrl-V u 2082, ..., ACtrl-V u 2096
 # which would appear as
 A₁, A₂, ..., Aₖ</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_grammar_指南">19. Grammar 指南</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_开始之前">19.1. 开始之前</h3>
<div class="sect3">
<h4 id="_为什么是_grammars">19.1.1. 为什么是 grammars?</h4>
<div class="paragraph">
<p>Grammars 解析字符串并从这些字符串返回数据结构。Grammars 可用于编写执行程序以确定程序是否可以运行（如果它是一个有效的程序），将网页分解成组成部分，或在其它的东西中识别句子的不同部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="_我什么时候该使用_grammars">19.1.2. 我什么时候该使用 grammars?</h4>
<div class="paragraph">
<p>如果你有驯服或解释的字符串，grammar 提供工具来完成这项工作。</p>
</div>
<div class="paragraph">
<p>该字符串可能是一个文件, 您想把它拆分成多个章节; 也许是一个协议，比如 SMTP，你需要指定哪些“命令”来自用户提供的数据;也许你正在设计自己的领域特定语言。Grammars 可以提供帮助。</p>
</div>
</div>
<div class="sect3">
<h4 id="_grammars_的广义概念">19.1.3. grammars 的广义概念</h4>
<div class="paragraph">
<p>正则表达式（<a href="https://docs.raku.org/language/regexes">Regexes</a>）适用于查找字符串中的模式。然而，对于一些任务来说，如同时查找多个模式，或者组合模式，或者单独测试可能围绕字符串正则表达式的模式是不够的。</p>
</div>
<div class="paragraph">
<p>在使用 HTML 时，您可以定义一个 grammar 来识别 HTML 标记，包括开始和结束元素以及它们之间的文本。然后，您可以将这些元素组织到数据结构中，例如数组或散列。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_更多_grammar_技术">19.2. 更多 Grammar 技术</h3>
<div class="paragraph">
<p>你总是会遇到令人头疼的字符串解析。举个例子, 据说  HTML 不能被有效地分解和解析，只需使用正则表达式来排序元素。另一个例子是定义单词和符号可能构成语言并提供含义的顺序。这正 和 Perl 的 Gramamr 系统完美契合。</p>
</div>
<div class="paragraph">
<p>Grammar 非常适合接受字符串，试图理解它们，然后将它们保存到一个你实际可以使用的数据结构中。如果你有某种带顺序或解释类型的字符串，Grammar 给你一些很强大的工具，使解析字符串更容易。</p>
</div>
<div class="paragraph">
<p>你的字符串可能是整个文件，你需要分成几个部分。也或许是一行一行的。也许你有一个正在使用的 SMTP 那样的协议，想要一个方便有条理的方式来定义哪些“命令”需要在用户数据的后面，使协议工作。也许你想创建自己的基于字符串的协议。也许你正在设计自己的语言。</p>
</div>
<div class="paragraph">
<p>正则表达式（regex）很好地在字符串中查找模式并操作它们。然而，当你需要同时找到多个模式，或者需要组合模式，或者测试可能围绕字符串的模式或其他模式 - 单单用正则表达式是不够的。</p>
</div>
<div class="paragraph">
<p>Grammar 提供了一种方式来定义如何使用正则表达式来检查字符串，并且可以将这些正则表达式组合在一起以提供更多的意义。</p>
</div>
<div class="paragraph">
<p>例如，在HTML的情况下，您可以定义一个语法，它可以识别HTML标记（开始和结束元素以及它们之间的文本），并通过将这些元素填充到数据结构中来对这些元素进行操作，例如数组或散列，然后可以轻松使用。实质上，Grammar 提供了一种定义可用于解析任意大小和复杂度的字符串的完整语言或规范的手段。</p>
</div>
<div class="sect3">
<h4 id="_概念描述">19.2.1. 概念描述</h4>
<div class="paragraph">
<p>Gramamr 被定义为对象, 就像 Perl 中的其它东西。从技术上讲, Gramamr 是普通的类加上一点额外的魔法, 我们稍后就说到它&#8201;&#8212;&#8201;还有一点限制。你像类那样命名和定义一个 Grammar, 除了使用「grammar」关键字代替「class」。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar My::Gram { ..methods 'n stuff... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Grammar 包含像方法那样的元素, 这些方法叫做 <strong>regex</strong>, <strong>token</strong> 或 <strong>rule</strong>。这些方法是有名字的, 就像方法有名字一样。它们每一个都定义一个 regex, token 或 rule（它们几乎是同样的东西(并不真的一样)）。</p>
</div>
<div class="paragraph">
<p>一旦你定义了你的 Grammar, 在你的程序中通过 Grammar 的名字调用它并传递你想解析的字符串。该字符串将通过你的 regex, token 和 rule “方法”定义的规则运行。 完成后，将返回一个 Match 对象，该对象已填充了用于定义方法的名称所结构化并存储的数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $matchObject = My::Gram.parse($what-a-big-string-you-have);</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，你可能想知道，如果我让所有这些定义的正则表达式只返回他们的结果，那么这该如何帮助在字符串中向前或向后解析东西呢，或需要从多个那样的正则表达式组合的东西。 ..这就是 grammar action 发挥作用的地方。</p>
</div>
<div class="paragraph">
<p>对于你的 grammar 中匹配的每个“方法”，你会得到一个可调用的动作，用那个匹配你可以做一些有趣或聪明的事情。 你还可以得到一个最重要的 action，你可以使用这个 action 把它们捆绑在一起，并自定义构建一个你可能想要返回的数据结构，其中所有疯狂的字符串解析在你很好的排序和定义的数据结构是有意义的。 默认情况下，此 over-arching 方法称为 TOP。 我们也会得到更多的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_技术概览">19.2.2. 技术概览</h4>
<div class="paragraph">
<p>Grammars  就像类那样定义, 除了使用 <code>grammar</code> 关键字代替 <code>class</code>. grammars 中的「methods」叫做 <strong>regex</strong>, <strong>token</strong>, 或 <strong>rule</strong>。虽然 Regex 方法慢但是彻底&#8201;&#8212;&#8201;它们会在字符串中向后查看并真的尝试匹配。Token 方法更快一点并且它们忽略空白。Rule 方法和 token 方法一样, 但是它们在你的"regex" 定义中消费空白。</p>
</div>
<div class="paragraph">
<p>当方法(regex, token 或 rule)在 grammar 中匹配后, 匹配到的字符串被放入最终将返回的 Match 对象中, 并且它将使用与您选择命名的方法相同的名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar My::Gram {
  token TOP { &lt;thingy&gt; .* }
  token thingy { 'clever_text_keyword' }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以在这里，如果你写 <code>my $match = My::Gram.parse($string)</code> - 并且你的字符串以 'clever_text_keyword' 开头, 那么你会得到一个匹配对象，在你的匹配对象中包含用「thingy」 标记的 'clever_text_keyword' 字符串。  这些可以变得越来越复杂，根据你的需要，如你所想。</p>
</div>
<div class="paragraph">
<p>现在, 我们说说 TOP。 TOP 方法(regex, token or rule)是必须匹配一切的(默认)的包罗万象的 regex。 如果传递进来解析的字符串与 TOP regex 不匹配，则返回的匹配对象将为空（<code>Any</code>）。</p>
</div>
<div class="paragraph">
<p>正如你可以看到的，在 TOP 中，提到了 <code>&lt;thingy&gt;</code> 标记。 <code>&lt;thingy&gt;</code> 被定义在下一行，<code>token thingy &#8230;&#8203;</code>。 这意味着 'clever_text_keyword' <strong>必须</strong>是传入的字符串中的第一个东西，否则 grammar 解析将失败，而我们将得到一个空匹配。 这对于识别有人可能给你应该被丢弃的畸形的东西是极好的。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_通过一个例子学习_grammar_rest_设计">19.3. 通过一个例子学习 Grammar - REST 设计</h3>
<div class="paragraph">
<p>让我们假设我们要将一个 URL 解析成组成 RESTful 请求的组件部分。假设我们希望网址的工作方式如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>URI 的第一部分，我们称之为“主体”，如零件，产品或人。</p>
</li>
<li>
<p>URI 的第二部分，我们称之为“命令”，就像标准的 CRUD 东西（创建，检索，更新或删除）。</p>
</li>
<li>
<p>URI 的第三部分将是任意数据。也许我们将使用的具体ID，或者一个由“/”分隔的长列表数据。</p>
</li>
<li>
<p>当我们得到一个URL时，我们需要把上面的1-3放在一个很好的我们可以使用的数据结构中，而不必做各种分割，并且可以很容易地在未来改变或扩展（或扩展） 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，如果我们在服务器上有一个 "/product/update/7/notify" 的 URI，我们希望我们的 Grammar 给我们一个很好的 <code>$match</code> 对象，它有一个“product”“subject”，一个”更新““command和”7/notify“的”数据“（现在）。</p>
</div>
<div class="paragraph">
<p>我们做的第一件事是定义 grammar 类。我们将需要定义我们的主题，命令和数据。我想我们将为他们使用 token，因为我们不关心正则表达式中的空格。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar REST {
  token subject { \w+ }
  token command { \w+ }
  token data    { .*  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>到目前为止，这个 REST Grammar 说，我们想要一个只是单词字符的主题，一个只是单词字符的命令和剩余全部是字符串的数据（在这种情况下为 URI）。</p>
</div>
<div class="paragraph">
<p>但是在我们的大字符串中，我们不知道这些正则表达式匹配将会进入什么顺序。我们需要能够将这些匹配的 token 放在我们将作为该字符串传递的URI的更大的上下文中。 这就是 TOP 方法要做的。 因此，我们添加 TOP，并在其中放置我们的 token 名称，以及其它应该出现的有效字符串。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar REST {
  token TOP { '/' &lt;subject&gt; '/' &lt;command&gt; '/' &lt;data&gt; }
  token subject { \w+ }
  token command { \w+ }
  token data    { .*  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>实际上，您可以用它从基本的 CRUD 的 URI 中提取您的数据，其中包含所有3个参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $match = REST.parse('/product/update/7/notify');
say $match;</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">«｢/product/update/7/notify｣␤
 subject =&gt; ｢product｣
 command =&gt; ｢update｣
 data =&gt; ｢7/notify｣»</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，可以使用 <code>$match&lt;subject&gt;</code> 或 <code>$match&lt;command&gt;</code> 或 <code>$match&lt;data&gt;</code> 直接访问数据以返回解析的值。 它们每个都包含可以进一步工作的匹配对象，或强制转换为字符串（<code>$match&lt;command&gt;.Str</code>）</p>
</div>
<div class="sect3">
<h4 id="_添加一点灵活性">19.3.1. 添加一点灵活性</h4>
<div class="paragraph">
<p>到目前为止，REST语法将处理检索，删除和更新。 但是，create 命令没有第三部分（数据部分）。 这意味着如果我们尝试解析 creat URL，我们的 Grammar 将无法匹配。 为了避免这种情况，我们需要使最后一个数据位置匹配可选，以及它前面的'/'。 这很容易通过为分组的'/'和 TOP token 的数据组件添加一个问号来表示它们的可选性质，就像一个普通的正则表达式那样。 所以现在我们有：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar REST {
    token TOP     { '/' &lt;subject&gt; '/' &lt;command&gt; [ '/' &lt;data&gt; ]? }
    token subject { \w+ }
    token command { \w+ }
    token data    { .* }
}

my $m = REST.parse('/product/create');
say $m&lt;subject&gt;, $m&lt;command&gt;;

# OUTPUT: «｢product｣｢create｣␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们想象，为了演示的目的，我们可能想允许用户从终端输入这些相同的 URI。 在这种情况下，他们可能在'/'之间放置空格，因为用户容易破坏事物。 如果我们想要适应这种可能性，我们可以用另一个 token 替换 TOP 中的 '/'，以允许在它的任何一边的空格。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar REST {
    token TOP     { &lt;slash&gt;&lt;subject&gt;&lt;slash&gt;&lt;command&gt;[&lt;slash&gt;&lt;data&gt;]? }
    token subject { \w+ }
    token command { \w+ }
    token data    { .* }

    token slash   { \s* '/' \s* }
}

my $m = REST.parse('/ product / update /7 /notify');
say $m;

# OUTPUT: «｢/ product / update /7 /notify｣␤
#          slash =&gt; ｢/ ｣
#          subject =&gt; ｢product｣
#          slash =&gt; ｢ / ｣
#          command =&gt; ｢update｣
#          slash =&gt; ｢ /｣
#          data =&gt; ｢7 /notify｣»</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们在我们的匹配对象中得到一些额外的垃圾，即那些斜线，但有一些非常好的方法，使我们得到一个整洁的返回值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_添加一些约束">19.3.2. 添加一些约束</h4>
<div class="paragraph">
<p>我们希望我们的 RESTful Grammar 只允许 CRUD 操作。 还有我们想要解析的东西。 这意味着我们上面的“命令”应该有四个值之一：create, retrieve, update 或 delete.。</p>
</div>
<div class="paragraph">
<p>有几种方法来完成这个。 例如，您可以更改 command 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token command { \w+ }

# ...becomes...

token command { 'create'|'retrieve'|'update'|'delete' }</code></pre>
</div>
</div>
<div class="paragraph">
<p>要成功解析 URI，<code>/</code> 之间的字符串的第二部分必须是那些 CRUD 值之一，否则解析失败。这正是我们想要的。</p>
</div>
<div class="paragraph">
<p>还有另一种技术可以在选项膨胀时提供更大的灵活性并提高可读性：原型正则表达式(proto-regexes)。</p>
</div>
<div class="paragraph">
<p>为了利用这些原型正则表达式（实际上是 multi methods）将我们限制为有效的 CRUD 选项，我们将用以下代替 <code>token command</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto token command {*}
token command:sym&lt;create&gt;   { &lt;sym&gt; }
token command:sym&lt;retrieve&gt; { &lt;sym&gt; }
token command:sym&lt;update&gt;   { &lt;sym&gt; }
token command:sym&lt;delete&gt;   { &lt;sym&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>sym</code> 关键字用于创建各种原型正则表达式(proto-regex)选项。每个选项都被命名(例如, <code>sym&lt;update&gt;</code>), 并且为了使用该选项，会使用相同的名字自动生成一个特殊的 <code>&lt;sym&gt;</code> token。</p>
</div>
<div class="paragraph">
<p>可以在原型正则表达式选项块中使用 <code>&lt;sym&gt;</code> token 以及其他用户定义的 tokens 来定义特定的“匹配条件”。正则表达式 tokens 是编译过的形式，一旦定义，随后就不能被副词动作(例如: i)修改。因此，由于它是自动生成的，所以特殊的 <code>&lt;sym&gt;</code> token 仅在需要与选项名称完全匹配时才有用。</p>
</div>
<div class="paragraph">
<p>如果对于其中一个原型正则表达式选项，出现匹配条件，则整个原型的搜索终止。匹配数据以匹配对象的形式分配给父原型 token。如果使用特殊 <code>&lt;sym&gt;</code> token，并形成全部或部分实际匹配，则将其保留为匹配对象中的子级别，否则它将不存在。</p>
</div>
<div class="paragraph">
<p>使用这样的原型正则表达式给了我们很大的灵活性。例如，不是返回 <code>&lt;sym&gt;</code>，在这种情况下是匹配的整个字符串，我们可以输入自己的字符串，或做其他有趣的事情。我们可以用“token subject”方法做同样的事，并将其限制为仅对有效主题（如&#8217;part&#8217;或&#8217;people&#8217;等）进行正确解析。</p>
</div>
</div>
<div class="sect3">
<h4 id="_把我们的_restful_grammar_组合在一块">19.3.3. 把我们的 RESTful Grammar 组合在一块</h4>
<div class="paragraph">
<p>目前为止我们的 RESTful URIs 的处理如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar REST
{
    token TOP { &lt;slash&gt;&lt;subject&gt;&lt;slash&gt;&lt;command&gt;[&lt;slash&gt;&lt;data&gt;]? }

    proto token command {*}
    token command:sym&lt;create&gt;   { &lt;sym&gt; }
    token command:sym&lt;retrieve&gt; { &lt;sym&gt; }
    token command:sym&lt;update&gt;   { &lt;sym&gt; }
    token command:sym&lt;delete&gt;   { &lt;sym&gt; }

    token subject { \w+ }
    token data    { .* }
    token slash   { \s* '/' \s* }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们看看各种 URI，以及它们在通过我们的 Grammar 时是如何表现的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @uris = ['/product/update/7/notify',
            '/product/create',
            '/item/delete/4'];

for @uris -&gt; $uri {
    my $m = REST.parse($uri);
    say "Sub: $m&lt;subject&gt; Cmd: $m&lt;command&gt; Dat: $m&lt;data&gt;";
}

# OUTPUT: «Sub: product Cmd: update Dat: 7/notify␤
#          Sub: product Cmd: create Dat:
#          Sub: item Cmd: delete Dat: 4»</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，由于 <code>&lt;data&gt;</code> 与第二个字符串没有匹配，因此 <code>$m&lt;data&gt;</code> 将为 <code>Nil</code>，然后在 <code>say</code> 函数的字符串上下文中使用它会发出警告。</p>
</div>
<div class="paragraph">
<p>只用 grammar 的这一部分，我们就能获得几乎所有我们正在寻找的东西。 URI 被解析，我们得到一个数据结构。</p>
</div>
<div class="paragraph">
<p><strong>data</strong> token 将 URI 的整个末尾作为一个字符串返回。 4 很好。但是从 '7/notify' 中我们只需要那个 7。为了得到 7，我们将使用 grammar 类的另一个特性: actions。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_grammar_actions">19.4. Grammar Actions</h3>
<div class="paragraph">
<p>在 Grammar 类中使用 Grammar actions 来处理匹配。Actions 在它们自己的类中定义，与 grammar 类不同。</p>
</div>
<div class="paragraph">
<p>您可以将 grammar action 看作 grammar 插件扩展模块的一种。很多时候你都会很开心的使用 grammars。但是当你需要进一步处理其中的一些字符串时，你可以插入 Actions 扩展模块。</p>
</div>
<div class="paragraph">
<p>要使用 action，可以使用名为 <code>actions</code> 的命名参数，它应该包含 action 类的一个实例。通过上面的代码，如果我们的 action 类调用了 REST-actions，我们会像这样解析 URI 字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $matchObject = REST.parse($uri, actions =&gt; REST-actions.new);

#   …or if you prefer…

my $matchObject = REST.parse($uri, :actions(REST-actions.new));</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你将你的 action 方法命名为与你的 grammar 方法（tokens，regexes，rules）相同的名称，那么当您的 grammar 方法匹配时，具有相同名称的 action 方法将自动调用。该方法还将传递相应的匹配对象（由 <code>$/</code> 变量表示）。</p>
</div>
<div class="paragraph">
<p>我们来看一个例子。</p>
</div>
<div class="paragraph">
<p>我们回到我们离开的地方:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar REST
{
    token TOP { &lt;slash&gt;&lt;subject&gt;&lt;slash&gt;&lt;command&gt;[&lt;slash&gt;&lt;data&gt;]? }

    proto token command {*}
    token command:sym&lt;create&gt;   { &lt;sym&gt; }
    token command:sym&lt;retrieve&gt; { &lt;sym&gt; }
    token command:sym&lt;update&gt;   { &lt;sym&gt; }
    token command:sym&lt;delete&gt;   { &lt;sym&gt; }

    token subject { \w+ }
    token data    { .* }
    token slash   { \s* '/' \s* }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>回想一下，我们想要进一步处理 data token "7/notify", 以获得 7. 为此，我们将创建一个与具名 token 名称相同的方法的 action 类。在这种情况下，我们的 token 被命名为 <code>data</code>，因此我们的方法也被命名为 <code>data</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class REST-actions
{
    method data($/) { $/.split('/') }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，当我们通过 Grammar 传递 URI 字符串时，<strong>data</strong> token 匹配将传递给 REST-actions 的 <strong>data</strong> 方法。action 方法会按照 <code>/</code> 字符拆分字符串，返回列表的第一个元素将是 ID 号 (即 "7/notify" 中的 7)。</p>
</div>
<div class="paragraph">
<p>但你高兴的太早了。</p>
</div>
<div class="sect3">
<h4 id="_用_make_和_made_使_grammars_保持整洁">19.4.1. 用 "make" 和 "made" 使 grammars 保持整洁</h4>
<div class="paragraph">
<p>如果 grammar 在 data 上调用上面的 action，那么 <strong>data</strong> 方法将被调用，但是返回到程序的大的 <code>TOP</code> grammar 匹配结果中不会显示任何内容。 为了使 action 的结果显示出来，我们需要在这个结果上调用 <a href="https://docs.raku.org/routine/make">make</a>，这个结果可以是很多东西，包括字符串，数组或散列结构。</p>
</div>
<div class="paragraph">
<p>你可以想象，<code>make</code> 把该结果存到 grammar 中一个特殊的容器化区域中。 我们所制作(<code>make</code>)的所有东西，稍后都可以通过 <a href="https://docs.raku.org/routine/made">made</a> 来访问。</p>
</div>
<div class="paragraph">
<p>因此，代替我们的上面的 REST-actions 类，我们应该写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class REST-actions
{
    method data($/) { make $/.split('/') }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们为 match split（它返回一个列表）中添加 <code>make</code> 时，这个 action 将返回一个<strong>数据结构</strong>给我们的 grammar，它将与原 grammar 的 <code>data</code> token 分开存储。 这样，如果我们需要，我们可以操作两者。</p>
</div>
<div class="paragraph">
<p>如果我们想从这个长的 URI 中访问 7 这个 ID, 那么我们访问从我们所制成的(<code>made</code>)的 <code>data</code> action 返回的列表的第一个元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $uri = '/product/update/7/notify';

my $match = REST.parse($uri, actions =&gt; REST-actions.new);

say $match&lt;data&gt;.made[0];  # OUTPUT: «7␤»
say $match&lt;command&gt;.Str;   # OUTPUT: «update␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们在 <strong>data</strong> 上调用 <code>made</code>，因为我们想要我们所制成的(<code>made</code>)（使用 <code>make</code>）action 的结果以得到分割后的数组。这好极了！但是，如果我们能够构造(<code>make</code>)一个包含我们想要的所有东西的更友好的数据结构，而不是强转类型和牢记数组，是不是更好？</p>
</div>
<div class="paragraph">
<p>就像 Grammar 中匹配整个字符串的 <code>TOP</code>, actions 也有一个 TOP 方法。我们可以构造(<code>make</code>)所有单独的匹配组件，如 <code>data</code> 或 <code>subject</code> 或 <code>command</code>，然后我们可以将它们放置在我们将在 TOP 中构造(<code>make</code>)的数据结构中。当我们返回最终的匹配对象时，之后就可以访问该数据结构了。</p>
</div>
<div class="paragraph">
<p>要做到这一点，我们要做的是将方法 <code>TOP</code> 添加到 action 类中，在该方法中，从组件片段中构造(<code>make</code>)出我们喜欢的任何数据结构。</p>
</div>
<div class="paragraph">
<p>所以，我们的 action 类现在变成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class REST-actions
{
    method TOP ($/) {
        make { subject =&gt; $&lt;subject&gt;.Str,
               command =&gt; $&lt;command&gt;.Str,
               data    =&gt; $&lt;data&gt;.made }
    }

    method data($/) { make $/.split('/') }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在我们的 <code>TOP</code> 方法中，<code>subject</code> 与我们在 grammar 中匹配的 <strong>subject</strong> 保持相同。 此外， <code>command</code> 返回匹配到的(create, update, retrieve, 或 delete)的有效 <code>&lt;sym&gt;</code>。 我们把每个匹配都强转为 <code>.Str</code>，因为我们不需要整个匹配对象。</p>
</div>
<div class="paragraph">
<p>但是我们想要确定的是，在 <code>$&lt;data&gt;</code> 对象上使用 <code>made</code> 方法，因为我们想要访问那个我们在 action 中使用 <code>make</code> 制成的(<code>made</code>)的分割，而不是正确的 <code>$&lt;data&gt;</code> 对象。</p>
</div>
<div class="paragraph">
<p>我们在 grammar action 的 <code>TOP</code> 方法中构造(<code>make</code>)一些东西之后，我们可以通过在 grammar 结果对象上通过调用 <code>made</code> 方法来访问所有的自定义值。 代码现在变成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $uri = '/product/update/7/notify';

my $match = REST.parse($uri, actions =&gt; REST-actions.new);

my $rest = $match.made;
say $rest&lt;data&gt;[0];   # OUTPUT: «7␤»
say $rest&lt;command&gt;;   # OUTPUT: «update␤»
say $rest&lt;subject&gt;;   # OUTPUT: «product␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你不需要完整的返回匹配对象，你可以从你的 actions 的 TOP 方法中只返回 made 后的数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $uri = '/product/update/7/notify';

my $rest = REST.parse($uri, actions =&gt; REST-actions.new).made;

say $rest&lt;data&gt;[0];   # OUTPUT: «7␤»
say $rest&lt;command&gt;;   # OUTPUT: «update␤»
say $rest&lt;subject&gt;;   # OUTPUT: «product␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>哦，我们忘了摆脱那个丑陋的数组元素编号了吗？ 嗯。 让我们在 <code>TOP</code> grammar 的自定义返回中构造(<code>make</code>) 一个新东西 - 我们称之为 <code>subject-id</code>，并将它设置为 <code>&lt;data&gt;</code> 的第0个元素。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class REST-actions
{
    method TOP ($/) {
        make { subject    =&gt; $&lt;subject&gt;.Str,
               command    =&gt; $&lt;command&gt;.Str,
               data       =&gt; $&lt;data&gt;.made,
               subject-id =&gt; $&lt;data&gt;.made[0] }
    }

    method data($/) { make $/.split('/') }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们可以这样做:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $uri = '/product/update/7/notify';

my $rest = REST.parse($uri, actions =&gt; REST-actions.new).made;

say $rest&lt;command&gt;;    # OUTPUT: «update␤»
say $rest&lt;subject&gt;;    # OUTPUT: «product␤»
say $rest&lt;subject-id&gt;; # OUTPUT: «7␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面是完整的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar REST
{
    token TOP { &lt;slash&gt;&lt;subject&gt;&lt;slash&gt;&lt;command&gt;[&lt;slash&gt;&lt;data&gt;]? }

    proto token command {*}
    token command:sym&lt;create&gt;   { &lt;sym&gt; }
    token command:sym&lt;retrieve&gt; { &lt;sym&gt; }
    token command:sym&lt;update&gt;   { &lt;sym&gt; }
    token command:sym&lt;delete&gt;   { &lt;sym&gt; }

    token subject { \w+ }
    token data    { .* }
    token slash   { \s* '/' \s* }
}


class REST-actions
{
    method TOP ($/) {
        make { subject    =&gt; $&lt;subject&gt;.Str,
               command    =&gt; $&lt;command&gt;.Str,
               data       =&gt; $&lt;data&gt;.made,
               subject-id =&gt; $&lt;data&gt;.made[0] }
    }

    method data($/) { make $/.split('/') }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_直接添加_actions">19.4.2. 直接添加 actions</h4>
<div class="paragraph">
<p>上面我们看到如何将 grammars 与 actions 对象相关联，并在匹配对象上执行 actions。但是，当我们想要处理匹配对象时，这不是唯一的方法。看下面的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G {
  rule TOP { &lt;function-define&gt; }
  rule function-define {
    'sub' &lt;identifier&gt;
    {
      say "func " ~ $&lt;identifier&gt;.made;
      make $&lt;identifier&gt;.made;
    }
    '(' &lt;parameter&gt; ')' '{' '}'
    { say "end " ~ $/.made; }
  }
  token identifier { \w+ { make ~$/; } }
  token parameter { \w+ { say "param " ~ $/; } }
}

G.parse('sub f ( a ) { }');
# OUTPUT: «func f␤param a␤end f␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个例子是解析器的缩版。让我们更专注于它显示的功能。</p>
</div>
<div class="paragraph">
<p>首先，我们可以在 grammar 本身中添加 action，一旦正则表达式的控制流到达它们，就会执行这些 action。请注意，action 对象的方法将始终在整个正则表达式项匹配后执行。其次，它展示了 <code>make</code> 真正做了什么，它不过是 <code>$/.made = &#8230;&#8203;</code> 的语法糖。这个技巧引入了一种从正则表达式 item 中传递消息的方法。</p>
</div>
<div class="paragraph">
<p>希望这有助于向您介绍 Raku 中的 Grammar，并向您展示 grammar
和 grammar action 类是如何协同工作的。有关更多信息，请查看更高级的 <a href="https://docs.raku.org/language/grammars">Perl Grammar指南</a>。</p>
</div>
<div class="paragraph">
<p>对于更多的 Grammar 调试，请参见 <a href="https://github.com/jnthn/grammar-debugger">Grammar::Debugger</a>。它为每个 grammar tokens 提供了断点调试和颜色高亮的匹配(MATCH)和匹配失败(FAIL)的输出。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_输入和输出">20. 输入和输出</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在这里，我们简要概述了与文件相关的输入/输出操作。详细信息可以在 <a href="https://docs.raku.org/type/IO">IO</a> 角色的文档中找到，也可以在 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a>  和 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 类型中找到。</p>
</div>
<div class="sect2">
<h3 id="_读取文件">20.1. 读取文件</h3>
<div class="paragraph">
<p>读取文件内容的一种方法是通过带有 <code>:r</code>（读取）文件模式选项的 <code>open</code> 函数打开文件，并吞噬内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open "testfile", :r;
my $contents = $fh.slurp;
$fh.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里我们使用 <code>IO::Handle</code> 对象上的 <code>close</code> 方法显式地关闭文件句柄。这是一种非常传统的读取文件内容的方法。但是，同样的事情可像这样更容易和更清楚地完成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $contents = "testfile".IO.slurp;
# or in procedural form:
$contents = slurp "testfile"</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过将 <code>IO</code> 角色添加到文件名字符串中，我们实际上能够将字符串作为文件对象本身引用，从而直接吞噬其内容中。请注意，<code>slurp</code> 负责为你打开和关闭文件。</p>
</div>
<div class="sect3">
<h4 id="_逐行读取">20.1.1. 逐行读取</h4>
<div class="paragraph">
<p>当然，我们也可以选择逐行读取文件。将排除新行分隔符（即  <code>$*IN.nl-in</code>）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 'huge-csv'.IO.lines -&gt; $line {
    # Do something with $line
}

# or if you'll be processing later
my @lines = 'huge-csv'.IO.lines;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_写文件">20.2. 写文件</h3>
<div class="paragraph">
<p>要将数据写入文件，我们再次选择调用 <code>open</code> 函数的传统方法 - 这次使用 <code>:w</code>（write）选项 - 并将数据打印到文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open "testfile", :w;
$fh.print("data and stuff\n");
$fh.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者使用等效的 <code>say</code>，因此不再需要显式的换行符了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open "testfile", :w;
$fh.say("data and stuff");
$fh.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以通过使用 <code>spurt</code> 在写入模式下打开文件，将数据写入文件并再次为我们关闭来简化此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">spurt "testfile", "data and stuff\n";</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，所有（文本）文件都写为 UTF-8，但是如果需要，可以通过 <code>:enc</code> 选项指定显式编码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">spurt "testfile", "latin1 text: äöüß", enc =&gt; "latin1";</code></pre>
</div>
</div>
<div class="paragraph">
<p>要将格式化的字符串写入文件, 请使用 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 的 <a href="https://docs.raku.org/routine/printf">printf</a> 函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open "testfile", :w;
$fh.printf("formatted data %04d\n", 42);
$fh.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要追加到文件，请在显式地打开文件句柄时指定 <code>:a</code> 选项，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open "testfile", :a;
$fh.print("more data\n");
$fh.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者使用等效的 <code>say</code>，因此不再需要显式的换行符了,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = open "testfile", :a;
$fh.say("more data");
$fh.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者甚至在调用 <code>spurt</code> 时加上 <code>:append</code> 选项:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">spurt "testfile", "more data\n", :append;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要将二进制数据显式地写入文件，请使用 <code>:bin</code> 选项打开它。然后输入/输出操作将使用 <code>Buf</code> 类型而不是 <code>Str</code> 类型。</p>
</div>
</div>
<div class="sect2">
<h3 id="_复制和重命名文件">20.3. 复制和重命名文件</h3>
<div class="paragraph">
<p>例程 <code>copy</code>, <code>rename</code>, 和 <code>move</code> 是可用的以避免低级别的系统命令。 在 <a href="https://docs.raku.org/routine/copy">copy</a>, <a href="https://docs.raku.org/routine/rename">rename</a>, 和 <a href="https://docs.raku.org/routine/move">move</a> 查看详情. 一些例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $filea = 'foo';
my $fileb = 'foo.bak';
my $filec = '/disk1/foo';  # note 'diskN' is assumed to be a physical storage device

copy $filea, $fileb;              # overwrites $fileb if it exists
copy $filea, $fileb, :createonly; # fails if $fileb exists

rename $filea, 'new-foo';              # overwrites 'new-foo' if it exists
rename $filea, 'new-foo', :createonly; # fails if 'new-foo' exists

# use move when a system-level rename may not work
move $fileb, '/disk2/foo';              # overwrites '/disk2/foo' if it exists
move $fileb, '/disk2/foo', :createonly; # fails if '/disk2/foo' exists</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_检查文件和目录">20.4. 检查文件和目录</h3>
<div class="paragraph">
<p>在 <code>IO::Handle</code> 对象上使用 <code>e</code> 方法来测试文件或目录是否存在。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if "nonexistent_file".IO.e {
    say "file exists";
}
else {
    say "file doesn't exist";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以使用冒号对语法来实现相同的功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if "path/to/file".IO ~~ :e {
    say 'file exists';
}
my $file = "path/to/file";
if $file.IO ~~ :e {
    say 'file exists';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与文件存在检查类似，也可以检查路径是否是目录。例如，假设文件 <code>testfile</code> 和目录  <code>lib</code> 存在，我们将从存在测试方法 <code>e</code> 获得相同的结果，即两者都存在：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "testfile".IO.e;  # OUTPUT: «True␤»
say "lib".IO.e;       # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，由于它们中只有一个是目录，因此目录测试方法 <code>d</code> 将给出不同的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "testfile".IO.d;  # OUTPUT: «False␤»
say "lib".IO.d;       # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们通过文件测试方法 <code>f</code> 检查路径是否是文件时，结果自然会反过来：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "testfile".IO.f;  # OUTPUT: «True␤»
say "lib".IO.f;       # OUTPUT: «False␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有其他方法可用于查询文件或目录，一些有用的方法是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $f = "file";

say $f.IO.modified; # return time of last file (or directory) change
say $f.IO.accessed; # return last time file (or directory) was read
say $f.IO.s;        # return size of file (or directory inode) in bytes</code></pre>
</div>
</div>
<div class="paragraph">
<p>更多方法和详细信息请查看 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_获取目录列表">20.5. 获取目录列表</h3>
<div class="paragraph">
<p>要列出当前目录的内容，请使用 <code>dir</code> 函数。它返回 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 对象的列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say dir;          # OUTPUT: «"/path/to/testfile".IO "/path/to/lib".IO␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>要列出给定目录中的文件和目录，只需将路径作为参数传递给 <code>dir</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say dir "/etc/";  # OUTPUT: «"/etc/ld.so.conf".IO "/etc/shadow".IO ....␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_创建和移除目录">20.6. 创建和移除目录</h3>
<div class="paragraph">
<p>要创建一个新目录，只需使用目录名作为参数调用函数 <code>mkdir</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">mkdir "newdir";</code></pre>
</div>
</div>
<div class="paragraph">
<p>该函数在成功时返回创建目录的名称，在失败时返回 <code>Nil</code>。因此，标准的 Perl 惯用法按预期工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">mkdir "newdir" or die "$!";</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>rmdir</code> 来移除*空*目录:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rmdir "newdir" or die "$!";</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_进程间通信">21. 进程间通信</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_运行程序">21.1. 运行程序</h3>
<div class="paragraph">
<p>许多程序需要能够运行其他程序，我们需要将信息传递给它们并接收它们的输出和退出状态。在 Raku 中运行程序非常简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">run 'git', 'status';</code></pre>
</div>
</div>
<div class="paragraph">
<p>这一行运行名为 “git” 的程序，并将 “git” 和 “status” 传递给它的命令行。它将使用 <code>%*ENV&lt;PATH&gt;</code> 设置找到该 git 程序。</p>
</div>
<div class="paragraph">
<p>如果您想通过向 shell 发送命令行来运行程序，那么也有一个工具。所有 shell 元字符都由 shell 解释，包括管道，重定向，环境变量替换等。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">shell 'ls -lR | gzip -9 &gt; ls-lR.gz';</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>shell</code> 用户输入时应小心。</p>
</div>
</div>
<div class="sect2">
<h3 id="_proc_对象">21.2. Proc 对象</h3>
<div class="paragraph">
<p><code>run</code> 和 <code>shell</code> 都返回一个<a href="https://docs.raku.org/type/Proc">PROC</a>对象，它可以使用具有更详细的进程进行通信。请注意，除非您关闭所有输出管道，否则程序通常不会终止。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $git = run 'git', 'log', '--oneline', :out;
for $git.out.lines -&gt; $line {
    my ($sha, $subject) = $line.split: ' ', 2;
    say "$subject [$sha]";
}
$git.out.close();</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果程序失败（以非零退出码退出），它将在返回的<a href="https://docs.raku.org/type/Proc">Proc</a>对象沉没时抛出异常。您可以将其保存为变量，甚至是匿名变量，以防止下沉：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ = run '/bin/false'; # does not sink the Proc and so does not throw</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过传递 <code>:out</code> 和 <code>:err</code> 标志来告诉 <code>Proc</code> 对象将输出捕获为文件句柄。您也可以通过 <code>:in</code> 标记传递输入。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $echo = run 'echo', 'Hello, world', :out;
my $cat  = run 'cat', '-n', :in($echo.out), :out;
say $cat.out.get;
$cat.out.close();</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用 <code>Proc</code> 捕获PID，将信号发送到应用程序，并检查 exitcode。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $crontab = run 'crontab', '-l';
if $crontab.exitcode == 0 {
    say 'crontab -l ran ok';
}
else {
    say 'something went wrong';
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_procasync_对象">21.3. Proc::Async 对象</h3>
<div class="paragraph">
<p>当您需要更多地控制与另一个进程的通信时，您将需要使用<a href="https://docs.raku.org/type/Proc::Async">Proc::Async</a>。该类提供对与程序进行异步通信的支持，以及向该程序发送信号的能力。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Get ready to run the program
my $log = Proc::Async.new('tail', '-f',  '/var/log/system.log');
$log.stdout.tap(-&gt; $buf { print $buf });
$log.stderr.tap(-&gt; $buf { $*ERR.print($buf) });

# Start the program
my $done = $log.start;
sleep 10;

# Tell the program to stop
$log.kill('QUIT');

# Wait for the program to finish
await $done;</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的小程序使用“tail”程序每 10 秒打印出名 <code>system.log</code> 的日志内容，然后通过 QUIT 信号告诉程序停止。</p>
</div>
<div class="paragraph">
<p>虽然 <code>Proc</code> 使用 <code>IO::Handle</code> 提供对输出的访问，但 <code>Proc::Async</code> 使用异步 supplies 提供访问（请参阅<a href="https://docs.raku.org/type/Supply">Supply</a>）。</p>
</div>
<div class="paragraph">
<p>如果要在等待原始程序完成时运行程序并执行某些工作，则 <code>start</code> 例程将返回<a href="https://docs.raku.org/type/Promise">Promise</a>，该程序在程序退出时保留(kept)。</p>
</div>
<div class="paragraph">
<p>使用 <code>write</code> 方法将数据传递到程序中。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_迭代">22. 迭代</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_iterator_和_iterable_角色">22.1. Iterator 和 Iterable 角色</h3>
<div class="paragraph">
<p>Raku 是一种函数式语言，但在处理复杂的数据结构时，函数需要保持住。特别是，他们需要一个可以应用于所有这些界面的统一接口。此接口由 <a href="https://docs.raku.org/type/Iterator">Iterator</a> 和 <a href="https://docs.raku.org/type/Iterable">Iterable</a> 角色提供。</p>
</div>
<div class="paragraph">
<p><code>Iterable</code> 角色相对简单。它为迭代器方法提供了一个存根，该方法实际上是由诸如 <code>for</code> 之类的语句使用的。 <code>for</code> 会在它前面的变量上调用 <code>.iterator</code>，然后为每个项目运行一次块。其他方法（如数组赋值）将使 <code>Iterable</code> 类以相同的方式运行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class DNA does Iterable {
    has $.chain;
    method new ($chain where {
                       $chain ~~ /^^ &lt;[ACGT]&gt;+ $$ / and
                       $chain.chars %% 3 } ) {
        self.bless( :$chain );
    }

    method iterator(DNA:D:){ $.chain.comb.rotor(3).iterator }
};

my @longer-chain =  DNA.new('ACGTACGTT');
say @longer-chain.perl;
# OUTPUT: «[("A", "C", "G"), ("T", "A", "C"), ("G", "T", "T")]␤»

say  @longer-chain».join("").join("|"); #OUTPUT: «ACG|TAC|GTT␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个示例中，它是 <a href="https://docs.raku.org/type/Iterable">Iterable</a> 中示例的扩展，显示了如何调用 <code>.iterator</code>，只是在将创建的对象分配给<a href="https://docs.raku.org/type/Positional">位置</a>变量 <code>@long-chain</code> 时调用此方法;这个变量是一个数组，我们在最后一个例子中对它进行操作。</p>
</div>
<div class="paragraph">
<p>（可能有点容易混淆）<code>Iterator</code> 角色比 <code>Iterable</code> 更复杂一点。首先，它提供了一个常量 <code>IterationEnd</code>，但它提供了一系列方法，如 <code>.pull-one</code>，它允许在几个上下文中进行更精细的迭代操作：添加或删除项目，或跳过它们以访问其他项目。实际上，该角色为所有其他方法提供了一个默认实现，因此唯一需要定义的方法就是 <code>pull-one</code>，其中只提供了一个 <code>stub</code>。虽然 <code>Iterable</code> 提供了高级变量循环，<code>Iterator</code> 提供了在循环的每次迭代中调用的低级函数。让我们用这个角色扩展前面的例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class DNA does Iterable does Iterator {
    has $.chain;
    has Int $!index = 0;

    method new ($chain where {
                       $chain ~~ /^^ &lt;[ACGT]&gt;+ $$ / and
                       $chain.chars %% 3 } ) {
        self.bless( :$chain );
    }

    method iterator( ){ self }
    method pull-one( --&gt; Mu){
        if $!index &lt; $.chain.chars {
            my $codon = $.chain.comb.rotor(3)[$!index div 3];
            $!index += 3;
            return $codon;
        } else {
            return IterationEnd;
        }
    }
};

my $a := DNA.new('GAATCC');
.say for $a; # OUTPUT: «(G A A)␤(T C C)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们声明一个 <code>DNA</code> 类，它扮演两个角色，<code>Iterator</code> 和 <code>Iterable</code>;该类将包含一个字符串，该字符串将被约束为长度为3的倍数且仅由 ACGT 组成。我们先来看看 <code>pull-one</code> 方法。每次发生新的迭代时都会调用这个，因此它必须保持最后一个的状态。 <code>$.index</code> 属性将在调用中保持该状态; <code>pull-one</code> 将检查链的末尾是否已到达，并将返回角色提供的 <code>IterationEnd</code> 常量。实际上，实现这种低级接口简化了 <code>Iterable</code> 接口的实现。现在迭代器将成为对象本身，因为我们可以在其上调用 <code>pull-one</code> 来依次访问每个成员;因此，<code>.iterator</code> 将回归自我;这是可能的，因为对象将同时是 <code>Iterable</code> 和 <code>Iterator</code>。</p>
</div>
<div class="paragraph">
<p>这并非总是如此，并且在大多数情况下 <code>.iterator</code> 将必须构建要返回的迭代器类型，例如我们在前面的示例中所做的;但是，此示例显示了构建满足迭代器和可迭代角色的类所需的最少代码。</p>
</div>
</div>
<div class="sect2">
<h3 id="_如何迭代上下文化和主题变量">22.2. 如何迭代：上下文化和主题变量</h3>
<div class="paragraph">
<p><code>for</code> 和其他循环将每次迭代中生成的项放入<a href="https://docs.raku.org/language/variables#index-entry-topic_variable">主题变量</a> $_+ 中，或将它们捕获到与块一起声明的变量中。这些变量可以直接在循环中使用，而不需要使用 <a href="https://docs.raku.org/syntax/$CIRCUMFLEX_ACCENT#%28Traps_to_avoid%29_twigil_%5E">^twigil</a> 来声明它们。</p>
</div>
<div class="paragraph">
<p>使用 <a href="https://docs.raku.org/language/operators#index-entry-&#8230;&#8203;_operators">序列运算符</a>时会发生隐式迭代。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1,1,1, { $^a²+2*$^b+$^c } … * &gt; 300; # OUTPUT: «(1 1 1 4 7 16 46 127 475)</code></pre>
</div>
</div>
<div class="paragraph">
<p>生成块正在运行一次，而完成序列的条件，在这种情况下，术语大于300，则不满足。这具有运行循环的副作用，但也创建了输出列表。</p>
</div>
<div class="paragraph">
<p>这可以通过使用 <a href="https://docs.raku.org/syntax/gather%20take">gather/take</a> 块来更系统地完成，这是一种不同类型的迭代构造，而不是在 sink 上下文中运行，每次迭代都返回一个项目。这个 <a href="https://rakuadvent.wordpress.com/2009/12/23/day-23-lazy-fruits-from-the-gather-of-eden/">Advent Calendar</a> 教程解释了这种循环的用例;实际上，<code>gather</code> 不是一个循环结构，而是一个语句前缀，它收集 <code>take</code> 生成的项并从中创建一个列表。</p>
</div>
</div>
<div class="sect2">
<h3 id="_经典循环以及为什么我们不喜欢它们">22.3. 经典循环以及为什么我们不喜欢它们</h3>
<div class="paragraph">
<p>经典循环，循环变量递增，可以通过 <a href="https://docs.raku.org/language/control#loop">loop 关键字</a>在 Raku 中完成。其他 <a href="https://docs.raku.org/language/control#repeat%2Fwhile%2C_repeat%2Funtil">repeat</a>和 <a href="https://docs.raku.org/language/control#while%2C_until">while</a> 循环也是可能的。</p>
</div>
<div class="paragraph">
<p>但是，总的来说，他们是沮丧的。 Raku 是一种功能和并发语言;在 Raku 中编码时，你应该以功能的方式看待循环：逐个处理迭代器产生的项目，即将一个项目提供给一个没有任何辅助效果的块。该功能视图还允许通过<a href="https://docs.raku.org/routine/hyper">hyper</a>或<a href="https://docs.raku.org/routine/race">race</a>自动线程方法轻松并行化操作。</p>
</div>
<div class="paragraph">
<p>如果您对旧的循环感觉更舒服，该语言允许您使用它们。但是，在可能的情况下尝试使用功能和并发迭代构造被认为是更多的p6y。</p>
</div>
<div class="paragraph">
<p><strong>注意：由于版本6.d循环可以从最后一个语句的值中生成值列表。</strong></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_模块开发工具">23. 模块开发工具</h2>
<div class="sectionbody">
<div class="paragraph">
<p>以下是您可以在 Raku 生态系统中找到的模块列表，旨在使开发 Raku 模块的体验更加有趣。</p>
</div>
<div class="sect2">
<h3 id="_模块构建器和创作工具">23.1. 模块构建器和创作工具</h3>
<div class="paragraph">
<p>一些模块和工具可帮助您生成属于模块分发的文件。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://modules.raku.org/dist/App::Assixt">App::Assixt</a> 模块开发者的助手</p>
</li>
<li>
<p><a href="https://modules.raku.org/dist/App::Mi6">App::Mi6</a> Raku 的最小创作工具</p>
</li>
<li>
<p><a href="https://modules.raku.org/dist/META6">META6</a> 用 Raku META 文件做事</p>
</li>
<li>
<p><a href="https://bitbucket.org/rightfold/module-skeleton">Module::Skeleton</a> 生成骨架模块</p>
</li>
<li>
<p><a href="https://modules.raku.org/dist/p6doc">p6doc</a> 生成文档最终产品</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_测试">23.2. 测试</h3>
<div class="paragraph">
<p>一些模块质量测试。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://modules.raku.org/dist/Test::META">Test::META</a> 测试您的 META6.json 文件</p>
</li>
<li>
<p><a href="https://modules.raku.org/dist/Test::Output">Test::Output</a> 测试程序生成的 STDOUT 和 STDERR 的输出</p>
</li>
<li>
<p><a href="https://modules.raku.org/dist/Proc::Screen">Test::Screen</a> 使用<strong>GNU screen</strong>测试全屏VT应用程序</p>
</li>
<li>
<p><a href="https://modules.raku.org/dist/Test::When">Test::When</a> 控制测试运行时间（作者测试，在线测试等）</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_nativecall">23.3. NativeCall</h3>
<div class="paragraph">
<p>这里有一些模块可以帮助您使用 NativeCall。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://modules.raku.org/dist/NativeHelpers::Array">NativeHelpers::Array</a> 提供处理 CArray 的例程</p>
</li>
<li>
<p><a href="https://modules.raku.org/dist/App::GPTrixie">App::GPTrixie</a> 从 C 头文件生成 NativeCall 代码</p>
</li>
<li>
<p><a href="https://modules.raku.org/dist/NativeCall::TypeDiag">NativeCall::TypeDiag</a> 提供测试 CStruct 的例程</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_sample_modules">23.4. Sample modules</h3>
<div class="paragraph">
<p>仅作为极简主义示例，安装程序测试或骨架的模块。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://modules.raku.org/dist/Foo">Foo</a> 具有两个不同版本分布的模块</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_模块包">24. 模块包</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>注意</strong> “模块”是 Raku 中的重载术语; 本文档重点介绍 <code>module</code> 声明符的使用。</p>
</div>
<div class="sect2">
<h3 id="_什么是模块">24.1. 什么是模块?</h3>
<div class="paragraph">
<p>模块，如类和 grammars，是一种<a href="https://docs.raku.org/language/packages">包</a>。模块对象是 <code>ModuleHOW</code> 元类的实例; 这提供了某些功能，可用于创建命名空间，版本控制，代理和数据封装（另请参见<a href="https://docs.raku.org/syntax/class">类</a>和<a href="https://docs.raku.org/syntax/role">角色</a>）。</p>
</div>
<div class="paragraph">
<p>要创建模块，请使用 <code>module</code> 声明符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">module M {}
say M.HOW;   # OUTPUT: «Raku::Metamodel::ModuleHOW.new»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里我们定义一个名为 <code>M</code> 的新模块; 内省 <code>HOW</code> 确认了底层的元类 <code>M</code> 是 <code>Raku::Metamodel::ModuleHOW</code>。</p>
</div>
<div class="sect3">
<h4 id="_何时使用模块">24.1.1. 何时使用模块</h4>
<div class="paragraph">
<p>模块主要用于封装不属于类或角色定义的代码和数据。模块内容（类，子程序，变量等）可以从具有 <code>is export</code> trait 的模块中导出; 一旦`import` 或 <code>use</code> 了模块，这些内容在调用者的命名空间中就可用了。模块还可以选择性地在其命名空间中通过 <code>our</code> 暴露符号以进行限定引用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用模块">24.1.2. 使用模块</h4>
<div class="paragraph">
<p>为了说明模块作用域和导出规则，我们首先定义一个简单的模块 <code>M</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">module M {
  sub greeting ($name = 'Camelia') { "Greetings, $name!" }
  our sub loud-greeting (--&gt; Str)  { greeting().uc       }
  sub friendly-greeting is export  { greeting('friend')  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>回想一下，子例程是词法作用域的，除非另有说明（声明符 <a href="https://docs.raku.org/syntax/sub"><code>sub</code></a> 等效于 <code>my sub</code>），因此`greeting` 在上面的示例中，词法作用域为模块并且在其外部不可访问。我们还使用 <code>our</code> 声明符定义了 <code>loud-greeting</code>，这意味着除了在词法作用域内，它还在模块的符号表中起了别名。最后，<code>friendly-greeting</code> 标记为导出; 导入模块时，它将在*调用者的*符号表中注册：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">import M;               # import the module
say M::loud-greeting;   # OUTPUT: «GREETINGS, CAMELIA!»
say friendly-greeting;  # OUTPUT: «Greetings, friend!»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_磁盘上的模块">24.2. 磁盘上的模块</h3>
<div class="paragraph">
<p>虽然 <code>.pm</code> 和 <code>.pm6</code> 文件（以下简称: <code>.pm6</code>) 有时被称为“模块”，但它们实际上只是在您写了 <code>need</code>，<code>use</code> 或者 <code>require</code> 时加载和编译的普通文件。</p>
</div>
<div class="paragraph">
<p>对于我们一直使用的意义上提供模块的 <code>.pm6</code>  文件，它需要如上所述用的用 <code>module</code> 声明一个模块。例如，通过将模块 <code>M</code> 放入 <code>Foo.pm6</code> 内部，我们可以按如下方式加载和使用模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Foo;                # find Foo.pm6, run need followed by import
say M::loud-greeting;   # OUTPUT: «GREETINGS, CAMELIA!»
say friendly-greeting;  # OUTPUT: «Greetings, friend!»</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意文件名和模块名之间的解耦 - <code>.pm6</code> 文件可以声明零个或多个具有任意标识符的模块。</p>
</div>
<div class="sect3">
<h4 id="_文件和模块命名">24.2.1. 文件和模块命名</h4>
<div class="paragraph">
<p>我们通常希望 <code>.pm6</code> 文件提供*单个*模块，仅此而已。这里的常见约定是文件 basename 与模块名称匹配。回到 <code>Foo.pm6</code>，显而易见的是，它仅提供单个模块，<code>M</code>; 在这种情况下，我们可能想要重命名 <code>M</code> 为 <code>Foo</code>。修改后的文件将为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">module Foo {
  sub greeting ($name = 'Camelia') { "Greetings, $name!" }
  our sub loud-greeting (--&gt; Str)  { greeting().uc       }
  sub friendly-greeting is export  { greeting('friend')  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可被调用者更一致地使用（注意 <code>use Foo</code> 和 <code>Foo::</code> 之间的关系）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Foo;
say Foo::loud-greeting;  # OUTPUT: «GREETINGS, CAMELIA!»
say friendly-greeting;   # OUTPUT: «Greetings, friend!»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <code>Foo.pm6</code> 在源树中放置得更深，例如在 <code>lib/Utils/Foo.pm6</code> 中，我们可以选择命名模块 <code>Utils::Foo</code> 以保持一致性。</p>
</div>
<div class="sect4">
<h5 id="_unit_关键字"><code>unit</code> 关键字</h5>
<div class="paragraph">
<p>只提供单个模块的文件可以用 <code>unit</code> 关键字更简洁地编写; <code>unit module</code> 指定编译单元的其余部分是声明的模块的一部分。这里 <code>Foo.pm6</code> 使用 <code>unit</code> 重写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module Foo;

sub greeting ($name = 'Camelia') { "Greetings, $name!" }
our sub loud-greeting (--&gt; Str)  { greeting().uc       }
sub friendly-greeting is export  { greeting('friend')  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>单元声明后的所有内容都是 <code>Foo</code> 模块规范的一部分。</p>
</div>
<div class="paragraph">
<p>（请注意，<code>unit</code> 也可以用于 <code>class</code>，<code>grammar</code> 和 <code>role</code>）。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_如果我省略了module会发生什么">24.2.2. 如果我省略了`module`会发生什么?</h4>
<div class="paragraph">
<p>为了更好地理解在 <code>Foo.pm6</code> 中 <code>module</code> 声明符在做什么，让我们将它与变体文件 <code>Bar.pm6</code> 进行对比，它省略了声明。下面的子程序定义几乎相同（唯一的区别在于 <code>greeting</code> 的正文，为了清晰起见而修改）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub greeting ($name = 'Camelia') { "Greetings from Bar, $name!" }
our sub loud-greeting (--&gt; Str)  { greeting().uc                }
sub friendly-greeting is export  { greeting('friend')           }</code></pre>
</div>
</div>
<div class="paragraph">
<p>提醒一下，这是我们以前使用 <code>Foo.pm6</code> 的方式，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Foo;
say Foo::loud-greeting;  # OUTPUT: «GREETINGS, CAMELIA!»
say friendly-greeting;   # OUTPUT: «Greetings, friend!»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是我们使用 <code>Bar.pm6</code> 的方式，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Bar;
say loud-greeting;       # OUTPUT: «GREETINGS FROM BAR, CAMELIA!»
say friendly-greeting;   # OUTPUT: «Greetings from Bar, friend!»</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>loud-greeting</code> 的使用，而不是 <code>Bar::loud-greeting</code> 因为 <code>Bar</code> 不是已知符号（我们没有在 <code>Bar.pm6</code> 中创建一个以那个名字命名的 <code>module</code>）。但是为什么 <code>loud-greeting`是可调用的, 即使我们没有将其标记为导出。答案很简单，`Bar.pm6</code> 不创建一个新的包命名空间 - <code>$?PACKAGE</code> 仍设置为 <code>GLOBAL</code> 当我们将 <code>loud-greeting`声明为 `our</code> 时，它被注册到 <code>GLOBAL</code> 符号表中。</p>
</div>
<div class="sect4">
<h5 id="_词法别名和安全">词法别名和安全</h5>
<div class="paragraph">
<p>值得庆幸的是，Raku 保护我们免受意外调用地点定义的痛击（例如内置函数）。除了 <code>Bar.pm6</code> 考虑以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">our sub say ($ignored) { print "oh dear\n" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会创建一个词法别名，将内置 <code>say</code> 隐藏在 <code>Bar.pm6</code> <strong>内部</strong> 但保持调用者 <code>say</code> 不变。因此，以下 <code>say</code> 调用仍然按预期工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Bar;
say 'Carry on, carry on...';  # OUTPUT: «Carry on, carry on...»</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_模块">25. 模块</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_导出和选择性导出">25.1. 导出和选择性导出</h3>
<div class="sect3">
<h4 id="_is_export">25.1.1. is export</h4>
<div class="paragraph">
<p>packages(包), subroutines(子例程), variables(变量), constants(常量) 和 enums(枚举) , 通过在它们的名字后面添加 <code>is export</code> 特性来导出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module MyModule;
our $var is export = 3;
sub foo is export { ... };
constant $FOO is export = "foobar";
enum FooBar is export &lt;one two three&gt;;

# Packages like classes can be exported too
class MyClass is export {};

# If a subpackage is in the namespace of the current package
# it doesn't need to be explicitly exported
class MyModule::MyClass {};</code></pre>
</div>
</div>
<div class="paragraph">
<p>就像所有的 traits 一样, 如果应用到子例程(routine)上, "is export" 应该出现在参数列表的后面:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub foo (Str $string) is export {...}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以给 <code>is export</code> 传递命名参数以组织要导出的符号, 然后导入程序 (importer) 可以剔除和选择导入哪一个。有 3 个预先定义好的标签： <code>ALL</code>, <code>DEFAULT</code>, <code>MANDATORY</code>（强制的）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># lib/MyModule.pm
unit module MyModule;
sub bag        is export              { ... }
sub pants      is export(:MANDATORY)  { ... }
sub sunglasses is export(:day)        { ... }
sub torch      is export(:night)      { ... }
sub underpants is export(:ALL)        { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># main.pl
use lib 'lib';
use MyModule;           #bag, pants
use MyModule :DEFAULT;  #the same
use MyModule :day;      #pants, sunglasses
use MyModule :night;    #pants, torch
use MyModule :ALL;      #bag, pants, sunglasses, torch, underpants</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_unitexport">25.1.2. UNIT::EXPORT::*</h4>
<div class="paragraph">
<p>表象之下, 其实 <code>is export</code> 是把符号添加到 <code>EXPORT</code> 命名空间中的 <code>UNIT</code> 作用域包中。例如, <code>is export(:FOO)</code> 会把目标添加到 <code>UNIT::EXPORT::FOO</code> 包中。这正是 Raku 决定导入什么所做的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module MyModule;

sub foo is export         { ... }
sub bar is export(:other) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>等价于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module MyModule;

my package EXPORT::DEFAULT {
  our sub foo { ... }
}

my package EXPORT::other {
  our sub bar { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>多数时候, <code>is export</code> 足够用了, 但是当你想动态生成要导出的符号时, <code>EXPORT</code> 包就很有用了。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># lib/MyModule.pm
unit module MuModule;

my package EXPORT::DEFAULT {
  for &lt;zero one two three four&gt;.kv -&gt; $number, $name {
      for &lt;sqrt log&gt; -&gt; $func {
          OUR::{'&amp;' ~ $func ~ '-of-' ~ $name } := sub { $number."$func()" };
      }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># main.pl
use MyModule;
say sqrt-of-four; #-&gt; 2
say log-of-zero;  #-&gt; -Inf</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_export">25.1.3. EXPORT</h4>
<div class="paragraph">
<p>你可以用一个 <code>EXPORT</code> 子例程导出任意符号。 <code>EXPORT</code> 必须返回一个 <code>Map</code>, 在 map 里面键是符号名, 键值是想要的值。符号名应该包含(如果有的话)关联类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class MyModule::Class { ... }

sub EXPORT {
  {
      '$var'      =&gt; 'one',
      '@array'    =&gt; &lt;one two three&gt;,
      '%hash'     =&gt; { one =&gt; 'two', three =&gt; 'four'},
      '&amp;doit'     =&gt; sub { ... },
      'ShortName' =&gt; MyModule::class
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># main.pl
use lib 'lib';
use MyModule;
say $var;
say @array;
say %hash;
doit();
say ShortName.new;  #-&gt; MyModule::Class.new</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, <code>EXPORT</code> 不能声明在包内, 因为目前的 rakudo(2015.09) 好像把 EXPORT 当作 compunit 的一部分而非包的一部分。</p>
</div>
<div class="paragraph">
<p>虽然 <code>UNIT::EXPORT</code> 包处理传递给 <code>use</code> 的命名参数, 而 <code>EXPORT</code> sub 处理位置参数。如果你把位置参数传递给 <code>use</code>, 那么这些参数会被传递给 <code>EXPORT</code>. 如果传递了位置参数, 那么 module 就不再需要导出默认符号了。你仍然可以伴随着你的位置参数, 通过显式地给 use 传递 <code>:DEFAULT</code> 参数来导入它们。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># lib/MyModule

class MyModule::Class {}

sub EXPORT($short_name?) {
    {
      do $short_name =&gt; MyModule::Class if $short_name
    }
}

sub always is export(:MANDATORY) { say "works" }

#import with :ALL or :DEFAULT to get
sub shy is export { say "you found me!" }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># main.pl
use lib 'lib';
use MyModule 'foo';
say foo.new(); #MyModule::Class.new
always();      #OK   - is imported
shy();         #FAIL - won't be imported</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_发布模块">25.2. 发布模块</h3>
<div class="paragraph">
<p>如果你已经写了一个 Raku模块, 你想把它分享到社区, 我们会很高兴地把它放到 Raku 模块文件夹清单中。<a href="http://modules.raku.org/">Raku modules directory</a></p>
</div>
<div class="paragraph">
<p>现在, 你需要使用 git 对你的模块进行版本控制。</p>
</div>
<div class="paragraph">
<p>这需要你有一个 Github 帐号, 以使你的模块能被从它的 Github 仓库中分享出去。</p>
</div>
<div class="paragraph">
<p>要分享你的模块, 按照下面说的做：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建一个以你的模块命名的工程文件夹。 例如, 如果你的模块是 <code>Vortex::TotalPerspective</code> , 那么就创建一个叫做 <code>Vortex::TotalPerspective</code> 的工程文件夹。这个工程目录的名字也会被用作 Github 仓库的名字。</p>
</li>
<li>
<p>让你的工程目录看起来像这样：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Vortex-TotalPerspective/
|-- lib
|   `-- Vortex
|       `-- TotalPerspective.pm
|-- LICENSE
|-- META.info
|-- README.md
`-- t
    `-- basic.t</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你的工程包含能帮助主模块完成工作的其它模块, 它们应该被放到你的 lib 目录中像这样组织：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">lib
`-- Vortex
    |-- TotalPerspective.pm
    `-- TotalPerspective
        |-- FairyCake.pm
        `-- Gargravarr.pm</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>README.md</code> 文件是一个 markdown 格式的文件, 它稍后会被 Github 自动渲染成 HTML</p>
</li>
<li>
<p>关于 LICENSE 文件, 如果你没有其它选择, 就是用和 Rakudo Raku 一样的 LICENSE 把。仅仅把它的原始 <a href="https://github.com/rakudo/rakudo/blob/nom/LICENSE">license</a> 复制/粘贴进你自己的 LICENSE 文件中。</p>
</li>
<li>
<p>如果你还没有任何测试, 现在你可以忽略 <code>t</code> 目录 和 <code>basic.t</code> 文件。关于如何写测试, 你可以看看其它模块是怎么使用 <code>Test</code> 的。它和 Perl'5 的 <code>Test::More</code> 很类似。</p>
</li>
<li>
<p>如果要文档化你的模块, 在你的模块中使用 <a href="http://design.raku.org/S26.html">Raku Pod</a> 标记。欢迎给模块写文档, 并且为了浏览的方便, 一旦 Raku module directory(或其它网站) 开始把 Pod 文档渲染成 HTML, 写文档尤为重要。</p>
</li>
<li>
<p>让你的 <code>META.info</code> 文件看起来像这样:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> {
        "name"        : "Vortex::TotalPerspective",
        "version"     : "0.1.0",
        "description" : "Wonderful simulation to get some perspective.",
        "author"      : "Your Name",
        "provides"    : {
            "Vortex::TotalPerspective" : "lib/Vortex/TotalPerspective.pm"
        },
        "depends"     : [ ],
        "source-url"  : "git://github.com/you/Vortex-TotalPerspective.git"
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于选择版本号的方案, 或许使用 "major.minor.patch" （查看  the spec on versioning 获取详细信息 ）。如果版本号现在对你或你的用户来说不重要, 你可以给版本那儿放上一颗星(*)。</p>
</div>
<div class="paragraph">
<p>在 <code>provides</code> 一节, 包含进你的发布中提供的所有命名空间。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>把你的工程放在 git 版本控制之下, 如果你还未这样做。</p>
</li>
<li>
<p>一旦你对你的工程满意了, 在 Github 上为它创建一个仓库。必要的话,  查看 <a href="https://help.github.com/">Github&#8217;s help docs</a>。 你的 Github 仓库的名字应该和你工程目录的名字一样。创建完 Githhub 仓库后, Github 会为你展示怎么配置你的本地仓库以获悉你的 Github 仓库。</p>
</li>
<li>
<p>把你的工程推送到 Github。</p>
</li>
<li>
<p>在 IRC 频道找个人帮你展示怎么把你的模块添加到<a href="https://github.com/raku/ecosystem">ecosystem</a>, 或者让他们是否能替你添加。</p>
</li>
<li>
<p>pull 请求被接收之后, 等个把小时。如果你的模块没有出现在  <a href="http://modules.raku.org/" class="bare">http://modules.raku.org/</a> , 请到 <a href="http://modules.raku.org/log/update.log" class="bare">http://modules.raku.org/log/update.log</a> 翻看log 日志文件, 以查找是否有错误。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>就是这样啦！ 感谢为 Raku 社区做贡献！</p>
</div>
<div class="paragraph">
<p>如果你想尝试安装你的模块, 使用熊猫 panda 安装工具, 这已经包含在 Rakudo Raku 中了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">zef install Vortex::TotalPerspective</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会下载你的模块到它自己的工作目录(<code>~/.panda</code>), 在那儿创建 build, 并把模块安装到 <code>~/.raku</code></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_创建操作符">26. 创建操作符</h2>
<div class="sectionbody">
<div class="paragraph">
<p>通过使用 <code>sub</code> 关键字后跟 <code>prefix</code>, <code>infix</code>, <code>postfix</code>, <code>circumfix</code>, 或 <code>postcircumfix;</code> 声明运算符; 然后是冒号结构中的冒号和运算符名称。对于（后）环缀操作符，用空格分隔这两部分。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub hello {
    say "Hello, world!";
}

say &amp;hello.^name;   # OUTPUT: «Sub␤»
hello;              # OUTPUT: «Hello, world!␤»

my $s = sub ($a, $b) { $a + $b };
say $s.^name;       # OUTPUT: «Sub␤»
say $s(2, 5);       # OUTPUT: «7␤»

# Alternatively we could create a more
# general operator to sum n numbers
sub prefix:&lt;Σ&gt;( *@number-list ) {
    [+] @number-list
}

say Σ (13, 16, 1); # OUTPUT: «30␤»

sub infix:&lt;:=:&gt;( $a is rw, $b is rw ) {
    ($a, $b) = ($b, $a)
}

my ($num, $letter) = ('A', 3);
say $num;          # OUTPUT: «A␤»
say $letter;       # OUTPUT: «3␤»

# Swap two variables' values
$num :=: $letter;

say $num;          # OUTPUT: «3␤»
say $letter;       # OUTPUT: «A␤»

sub postfix:&lt;!&gt;( Int $num where * &gt;= 0 ) { [*] 1..$num }
say 0!;            # OUTPUT: «1␤»
say 5!;            # OUTPUT: «120␤»

sub postfix:&lt;♥&gt;( $a ) { say „I love $a!“ }
42♥;               # OUTPUT: «I love 42!␤»

sub postcircumfix:&lt;⸨ ⸩&gt;( Positional $a, Whatever ) {
    say $a[0], '…', $a[*-1]
}

[1,2,3,4]⸨*⸩;      # OUTPUT: «1…4␤»

constant term:&lt;♥&gt; = "♥"; # We don't want to quote "love", do we?
sub circumfix:&lt;α ω&gt;( $a ) {
    say „$a is the beginning and the end.“
};

α♥ω;               # OUTPUT: «♥ is the beginning and the end.␤»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_正则表达式最佳实践和陷阱">27. 正则表达式最佳实践和陷阱</h2>
<div class="sectionbody">
<div class="paragraph">
<p>为了提供强大的正则表达式和 grammar，这里有一些代码布局和可读性的最佳实践，实际匹配的内容，以及避免常见的陷阱。</p>
</div>
<div class="sect2">
<h3 id="_代码布局">27.1. 代码布局</h3>
<div class="paragraph">
<p>如果没有 <code>:sigspace</code> 副词，在 Raku 正则表达式中空格并不重要。 使用它自己的优势，并插入空格，增加可读性。 此外，必要时插入注释。</p>
</div>
<div class="paragraph">
<p>比较非常紧凑的写法</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex float { &lt;[+-]&gt;?\d*'.'\d+[e&lt;[+-]&gt;?\d+]? }</code></pre>
</div>
</div>
<div class="paragraph">
<p>和这种可读性更好的写法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex float {
     &lt;[+-]&gt;?        # optional sign
     \d*            # leading digits, optional
     '.'
     \d+
     [              # optional exponent
        e &lt;[+-]&gt;?  \d+
     ]?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据经验， 在原子周围和组的内部使用空白; 将量词直接放在原子之后; 并垂直对齐开口和闭合关方括号和括号。</p>
</div>
<div class="paragraph">
<p>在括号或方括号内使用替换列表时，请对齐竖线：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex example {
    &lt;preamble&gt;
    [
    || &lt;choice_1&gt;
    || &lt;choice_2&gt;
    || &lt;choice_3&gt;
    ]+
    &lt;postamble&gt;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_保持短小">27.2. 保持短小</h3>
<div class="paragraph">
<p>正则代码通常比常规代码更紧凑。 因为他们用这么少的字符就做得那么多，所以保持了正则表达式的简短。</p>
</div>
<div class="paragraph">
<p>当你可以给正则表达式的一部分命名时，通常最好将它放入一个单独的，命名的正则表达式中。</p>
</div>
<div class="paragraph">
<p>例如，您可以以前面获取浮点正则表达式为例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex float {
     &lt;[+-]&gt;?        # optional sign
     \d*            # leading digits, optional
     '.'
     \d+
     [              # optional exponent
        e &lt;[+-]&gt;?  \d+
     ]?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并将其分解为部件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my token sign { &lt;[+-]&gt; }
my token decimal { \d+ }
my token exponent { 'e' &lt;sign&gt;? &lt;decimal&gt; }
my regex float {
    &lt;sign&gt;?
    &lt;decimal&gt;?
    '.'
    &lt;decimal&gt;
    &lt;exponent&gt;?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这有助于，特别是当正则表达式变得更加复杂时。 例如，您可能希望在存在指数的情况下使小数点可选。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex float {
    &lt;sign&gt;?
    [
    || &lt;decimal&gt;?  '.' &lt;decimal&gt; &lt;exponent&gt;?
    || &lt;decimal&gt; &lt;exponent&gt;
    ]
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_要匹配什么">27.3. 要匹配什么</h3>
<div class="paragraph">
<p>输入数据格式通常没有明确的规范，或者程序员不知道规范。 然后，按照你的期望自由是好的，但只要没有可能的含糊之处。</p>
</div>
<div class="paragraph">
<p>例如，在 <code>ini</code> 文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[section]
key=value</code></pre>
</div>
</div>
<div class="paragraph">
<p>section 标题内可以有什么内容？ 只允许一个词可能限制性太强。 有人可能会写`[two words]`，或使用破折号等。而不是问内部允许什么，可能值得问一下：什么是不允许的？</p>
</div>
<div class="paragraph">
<p>显然，不允许闭合方括号，因为 <code>[a]b]</code> 是不明确的。 根据同一论点，应禁止开口方括号。 这让我们失望了</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token header { '[' &lt;-[ \[\] ]&gt;+ ']' }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你只处理一行就没问题。 但是，如果您正在处理整个文件，那么正则表达式会解析</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[with a
newline in between]</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可能不是一个好主意。妥协是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token header { '[' &lt;-[ \[\] \n ]&gt;+ ']' }</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，在后处理中，从 section 标题中删除前导和尾随空格和制表符。</p>
</div>
</div>
<div class="sect2">
<h3 id="_匹配空白">27.4. 匹配空白</h3>
<div class="paragraph">
<p><code>:sigspace</code> 副词（或使用 <code>rule</code> 声明符而不是 <code>token</code> 或 <code>regex</code>）非常便于隐式解析可能出现在许多地方的空格。</p>
</div>
<div class="paragraph">
<p>回到解析 <code>ini</code> 文件的例子，我们有</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex kvpair { \s* &lt;key=identifier&gt; '=' &lt;value=identifier&gt; \n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可能不像我们想要的那样的文字，因为用户可能在等号周围放置空格。 那么，我们可以试试这个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex kvpair { \s* &lt;key=identifier&gt; \s* '=' \s* &lt;value=identifier&gt; \n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>但那看起来很笨重，所以我们尝试别的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my rule kvpair { &lt;key=identifier&gt; '=' &lt;value=identifier&gt; \n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>可是等等！ 值之后的隐式空格匹配会占用所有空格，包括换行符，因此 <code>\n+</code> 没有任何东西可以匹配（并且 <code>rule</code> 也禁用了回溯，因此没有运气）。</p>
</div>
<div class="paragraph">
<p>因此，将隐式空格的定义重新定义为输入格式中不重要的空白非常重要。</p>
</div>
<div class="paragraph">
<p>这通过重新定义 token <code>ws</code> 来工作; 但是，它只适用于 <a href="https://docs.raku.org/language/grammars">grammars</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar IniFormat {
    token ws { &lt;!ww&gt; \h* }
    rule header { \s* '[' (\w+) ']' \n+ }
    token identifier  { \w+ }
    rule kvpair { \s* &lt;key=identifier&gt; '=' &lt;value=identifier&gt; \n+ }
    token section {
        &lt;header&gt;
        &lt;kvpair&gt;*
    }

    token TOP {
        &lt;section&gt;*
    }
}

my $contents = q:to/EOI/;
    [passwords]
        jack = password1
        joy = muchmoresecure123
    [quotas]
        jack = 123
        joy = 42
EOI
say so IniFormat.parse($contents);</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了将所有正则表达式都放入 grammar 并将其转换为 tokens（因为它们无论如何都不需要回溯），有趣的一点是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token ws { &lt;!ww&gt; \h* }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在进行隐式空格分析的时候会调用该 token。 当它不在两个单词字符之间（ <code>&lt;!ww&gt;</code>，"在单词中"的否定断言）和零个或多个水平空格字符之间匹配。 对水平空格的限制很重要，因为换行符（垂直空格）会分隔记录，不应被隐式匹配。</p>
</div>
<div class="paragraph">
<p>不过，潜伏着一些与空白相关的麻烦。 正则表达式 <code>\n+</code> 与 <code>\n \n</code> 之类的字符串不匹配，因为两个换行符之间有空白。 要允许此类输入字符串，请将 <code>\n+</code> 替换为 <code>\n\s*</code>。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_关于文档">28. 关于文档</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本文档集代表了正在努力记录 Raku 编程语言的目标是：全面; 使用方便; 易于导航; 对新手和经验丰富的 Raku 程序员都很有用。</p>
</div>
<div class="paragraph">
<p>该文档的 HTML 版本位于线上的 <a href="https://docs.raku.org/">https://docs.raku.org</a>。</p>
</div>
<div class="paragraph">
<p>该文档的官方来源位于 <a href="https://github.com/raku/doc">GitHub上的raku/doc</a>。</p>
</div>
<div class="paragraph">
<p>本特定文档快速概述了<a href="https://github.com/raku/doc/blob/master/CONTRIBUTING.md">在GitHub上的贡献</a>中更详细描述的过程。本文档还简要介绍了编写 Raku Pod 文件，这些文件可以渲染为 HTML 和其他格式。</p>
</div>
<div class="sect2">
<h3 id="_结构">28.1. 结构</h3>
<div class="paragraph">
<p>所有文档都是用 Raku Pod 编写的，并保存在 <code>doc/</code> 目录 <code>doc/Language/</code> 和 <code>doc/Type/</code> 子目录中。这些文件作为定义集合或“文档”处理，然后进行后处理并链接在一起。</p>
</div>
</div>
<div class="sect2">
<h3 id="_从_pod_生成_html">28.2. 从 Pod 生成 HTML</h3>
<div class="paragraph">
<p>要从 Pod 文件生成 HTML，你需要：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>最新版本的 Rakudo Raku 编译器</p>
</li>
<li>
<p>Raku 模块Pod::To::HTML，Pod::To::BigPage 和 URI::Escape（可以通过<a href="https://github.com/ugexe/zef">zef</a>安装）。</p>
</li>
<li>
<p><strong>可选</strong>：<a href="https://www.graphviz.org/">GraphViz</a>，用于创建 Raku 类型之间关系的图形</p>
</li>
<li>
<p><strong>可选</strong>：<a href="https://github.com/atom/highlights">Atom Highlights</a> 和 <a href="https://atom.io/packages/language-raku">language-raku</a>，用于语法高亮显示</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要在文件`html/`文件夹中生成文档，请运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku htmlify.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>要从 Web 服务器托管文档，请安装 Perl 5 和 Mojolicious::Lite，然后运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">perl app.pl daemon</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_贡献">28.3. 贡献</h3>
<div class="paragraph">
<p>文档是用 Raku Pod 编写的。</p>
</div>
<div class="paragraph">
<p>有关 Raku Pod 的快速介绍，请参阅<a href="https://docs.raku.org/language/pod">Raku Pod</a>。</p>
</div>
<div class="paragraph">
<p>有关 Raku Pod 规范的完整详细信息，请参见<a href="https://design.raku.org/S26.html">概要26,文档</a>。</p>
</div>
<div class="sect3">
<h4 id="_添加定义">28.3.1. 添加定义</h4>
<div class="paragraph">
<p>Documentables 可以使用 <code>=headN</code> Pod 指令来定义，其中 <code>N</code> 大于零（例如，<code>=head1</code>，<code>=head2</code>，&#8230;&#8203;）。</p>
</div>
<div class="paragraph">
<p>该指令之后的所有段落和块，直到同一级别的下一个指令，将被视为可记录的一部分。所以，在：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod6" data-lang="pod6">=head2 My Definition

Some paragraphs, followed by some code:

    my Code $examples = "amazing";

Mind === blown.

=head3 Minor details about My Definition

It's fantastic.

=head2 And now, for something completely different

…</code></pre>
</div>
</div>
<div class="paragraph">
<p>可记录的 ` My Definition` 延伸到了 <code>=head2 And now…</code>。</p>
</div>
<div class="paragraph">
<p>可记录文件可能包含其他文件。例如，类可记录文件通常包含类实现的方法。</p>
</div>
<div class="paragraph">
<p>定义必须采用下列形式之一才能被识别为名为 document 文件的起点。首先是文档源代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod6" data-lang="pod6">=item X&lt;C&lt;How to use the þ infix&gt; | infix,þ&gt; (This a special case, which
is always considered a definition)

=item C&lt;The þ Infix&gt;

=item B&lt;The C&lt;þ&gt; Infix&gt;

=item C&lt;Infix þ&gt;

=item B&lt;Infix C&lt;þ&gt;&gt;

=item C&lt;trait is cached&gt; (A special case for the L&lt;trait|/language/functions#Traits&gt; documentables)</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后是渲染页面上的结果：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>How to use the þ infix</code> （这是一种特殊情况，始终被视为定义）</p>
</li>
<li>
<p><code>The þ Infix</code></p>
</li>
<li>
<p><strong>The þ Infix</strong></p>
</li>
<li>
<p><code>Infix þ</code></p>
</li>
<li>
<p><strong>Infix þ</strong></p>
</li>
<li>
<p><code>trait is cached</code>（<a href="https://docs.raku.org/language/functions#Traits">trait</a>文档的特例）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在可以使用 HTML 文档中的搜索字段搜索这些项。</p>
</div>
<div class="paragraph">
<p>您可以使用粗体（<strong>B&lt;&gt;</strong>）或斜体（<strong>I&lt;&gt;</strong>）添加强调，可以使用或不使用代码格式（<strong>C&lt;&gt;</strong>）。由于当前的解析器限制，必须采取特殊步骤将<strong>X&lt;&gt;</strong>与其他格式代码一起使用; 例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod6" data-lang="pod6">=item X&lt;B&lt;foo&gt;|foo&gt; a fancy subroutine</code></pre>
</div>
</div>
<div class="paragraph">
<p>像这样渲染</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>foo</strong> a fancy subroutine</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，管道（“|”）之后的文本没有格式。另请注意，<strong>C&lt;&gt;</strong>保留空格并将文本视为逐字处理。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_社区">29. 社区</h2>
<div class="sectionbody">
<div class="paragraph">
<p>“Perl 5是我对 Perl 的重写。我希望 Raku 能够成为社区重写的 Perl, 并且 Raku 是社区的 Perl。” - 拉里沃尔</p>
</div>
<div class="sect2">
<h3 id="_raku_社区">29.1. Raku 社区</h3>
<div class="paragraph">
<p><code>freenode.net</code> 上的 <code>#raku</code> 频道有很多人，他们很乐意提供支持和回答问题。可以在 <a href="https://raku.org/community/">raku.org 社区页面</a> 中找到更多资源。 <a href="https://raku.org/">Camelia</a> 是她身上带有 P 6 的多色蝴蝶，她是这个多元化和热情的社区的象征。我们广泛使用 <a href="https://raku.org/community/irc">#raku</a> IRC 频道进行沟通，提问和简单地闲逛。查看此<a href="http://www.ircbeginner.com/ircinfo/abbreviations.html">IRC术语</a>资源，了解那里经常使用的缩写。 <a href="https://stackoverflow.com/questions/tagged/raku">StackOverflow</a> 也是一个很好的资源，用于提出问题并帮助其他人解决他们的 Raku 问题和挑战。</p>
</div>
</div>
<div class="sect2">
<h3 id="_raku_周刊">29.2. Raku 周刊</h3>
<div class="paragraph">
<p>Elizabeth Mattijsen 通常在 “Raku Weekly” 博客中发帖，这是有关 Raku 的帖子，推文，评论和其他有趣花絮的摘要。是知道 Perl 社区正在发生什么的最佳单个资源。</p>
</div>
</div>
<div class="sect2">
<h3 id="_raku_降临节日历">29.3. Raku 降临节日历</h3>
<div class="paragraph">
<p>Raku 社区每年 12 月都会发布一个 <a href="https://rakuadvent.wordpress.com/">Advent Calendar</a>，每天都有 Raku 教程，直到圣诞节。通过不同的 Raku 频道和 <a href="https://github.com/raku/mu">Raku/mu</a> 存储库完成组织和日期分配。如果您想参与，它将在10月底开始组织，因此请查看上面的频道。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_faq">30. FAQ</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_通用">30.1. 通用</h3>
<div class="sect3">
<h4 id="_rakudo_和_raku_的区别是什么">30.1.1. Rakudo 和 Raku 的区别是什么？</h4>
<div class="paragraph">
<p>Rakudo 是 Raku 的一个实现。目前它是完成度最好的但是过去也有其它的实现, 将来也可能会有其它实现。Raku 是语言的定义。很多场合</p>
</div>
<div class="paragraph">
<p>这两个名字可以宽松地使用并互相替换。</p>
</div>
</div>
<div class="sect3">
<h4 id="_会有_raku_版本_6_0_0_吗">30.1.2. 会有 Raku 版本 6.0.0 吗?</h4>
<div class="paragraph">
<p>第一个稳定语言版本的版本称为 v6.c，而不是 6.0.0。 不同的命名方案使得不太可能发布具有精确版本 6.0.0 的语言。</p>
</div>
<div class="paragraph">
<p>您可以使用下面的代码检查您的 Rakudo 编译器是当前至少是什么版本（注意这可能不是真正的供应商二进制文件）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku -e 'say q[too old] if $*PERL.version before Version.new(q[6.c])'</code></pre>
</div>
</div>
<div class="paragraph">
<p>它首先由 Rakudo Raku 编译器版本的 2015.12 实现，并且可能通过使用 'use 6.c' 指令在可预见的未来支持后续版本。 下一个语言版本（无发布日期）为 v6.d.</p>
</div>
</div>
<div class="sect3">
<h4 id="_作为一个_raku_初学者我应该安装什么">30.1.3. 作为一个 Raku 初学者我应该安装什么？</h4>
<div class="paragraph">
<p>如果你是一个 Linux 或 Mac 用户, 你可能需要下载 <a href="http://rakudo.org/downloads/star/">Rakudo Star</a> 并通过编译 MoarVM 版本安装（一个简单的处理）</p>
</div>
<div class="paragraph">
<p>如果你是一个 Windows 32 或 64 位用户, 那么 Rakudo Star 二进制版本在 rakudo 网站也能获得。你需要 Windows Git 来使用 panda。</p>
</div>
<div class="paragraph">
<p>Linux 和 Mac 二进制版本稍后也可能从供应商和第三方那儿获取到。尽管供应商版本可能过时了。</p>
</div>
<div class="paragraph">
<p>或者有一个官方的 rakudo star Docker 镜像, 地址为 <a href="https://hub.docker.com/<em>/rakudo-star/"><a href="https://hub.docker.com/" class="bare">https://hub.docker.com/</a></em>/rakudo-star/</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_作为一个中高级用户我想跟进_rakudo_开发">30.1.4. 作为一个中高级用户我想跟进 Rakudo 开发</h4>
<div class="paragraph">
<p>安装类似于 Perl 5 的 perlbrew&#8201;&#8212;&#8201;<a href="https://github.com/tadzik/rakudobrew">rakudobrew</a> , 同等的 Python 还有 Ruby 工具。</p>
</div>
</div>
<div class="sect3">
<h4 id="_从哪里能找到关于_raku_的好文档">30.1.5. 从哪里能找到关于 Raku 的好文档？</h4>
<div class="paragraph">
<p>最令人信赖的信息能在 raku.org 或那儿的直接链接。</p>
</div>
<div class="paragraph">
<p>你也可以使用 <a href="https://www.google.co.uk/search?q=site:irclog.perlgeek.de+inurl:raku">Google</a> 搜索 Freenode #raku IRC 频道。</p>
</div>
<div class="paragraph">
<p><a href="http://www.raku.org/documentation/" class="bare">http://www.raku.org/documentation/</a> 和 <a href="http://doc.raku.org/" class="bare">http://doc.raku.org/</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_什么是_raku_spec">30.1.6. 什么是 Raku spec？</h4>
<div class="paragraph">
<p>"spec" 指的是 Raku的官方测试套件。它被称作 roast 并被托管在 <a href="https://github.com/raku/roast">github</a> 上.</p>
</div>
<div class="paragraph">
<p>它被用来测量一个 Raku 的实现有多彻底。</p>
</div>
</div>
<div class="sect3">
<h4 id="_有没有_raku_的术语相关的项目">30.1.7. 有没有 Raku 的术语相关的项目？</h4>
<div class="paragraph">
<p>查看 <a href="http://design.raku.org/S99.html">glossary</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_我是一个_perl_5_程序员_perl_5_和_raku_的区别在哪儿">30.1.8. 我是一个 Perl 5 程序员. Perl 5 和 Raku 的区别在哪儿？</h4>
<div class="paragraph">
<p>在 link: <a href="https://docs.raku.org/language/5to6-nutshell"> https://docs.raku.org/language/5to6-nutshell</a> 下面查看 ‘5to6-nutshell’ pod 文档和相关页面。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_模块_2">30.2. 模块</h3>
<div class="sect3">
<h4 id="_raku_有_cpan_吗_或者_raku_会使用_perl_5_的_cpan_吗">30.2.1. Raku 有 CPAN 吗? 或者 Raku 会使用 Perl 5 的 CPAN 吗?</h4>
<div class="paragraph">
<p>Raku 还没有像 CPAN 那样成熟的模块仓库. 但是 <a href="http://modules.raku.org/">modules.raku.org</a> 有很多已知的 Raku 模块, <a href="https://github.com/tadzik/panda/">panda</a> 能在 Rakudo 上安装这些模块.</p>
</div>
</div>
<div class="sect3">
<h4 id="_我能在_raku_中使用_perl_5的模块吗">30.2.2. 我能在 Raku 中使用 Perl 5的模块吗？</h4>
<div class="paragraph">
<p>使用 <a href="https://github.com/niner/Inline-Perl5/">Inline::Perl5</a> 能让大部分 Perl 5 模块工作, 它甚至能很好地运行 Perl 5 的 Catalyst 和 DBI。</p>
</div>
</div>
<div class="sect3">
<h4 id="_我能在_raku_中使用_c_和_c_吗">30.2.3. 我能在 Raku 中使用 C 和 C++ 吗？</h4>
<div class="paragraph">
<p><a href="http://docs.raku.org/language/nativecall">Nativecall</a> 让这个特别容易。</p>
</div>
</div>
<div class="sect3">
<h4 id="_nativecall_找不到_libfoo_so_并且我只有_libfoo_so_1_2">30.2.4. Nativecall 找不到 libfoo.so 并且我只有 libfoo.so.1.2!</h4>
<div class="paragraph">
<p>这在 Debian 那样的系统中很常见。 你需要安装 "libfoo-dev" 来为丢失的文件设置符号链接。</p>
</div>
</div>
<div class="sect3">
<h4 id="_所有的传统_unix_库函数去哪儿了">30.2.5. 所有的传统 Unix 库函数去哪儿了？</h4>
<div class="paragraph">
<p>使用 Nativecall 访问它们很容易。
<a href="https://github.com/cspencer/raku-posix">POSIX</a> 模块也可以。</p>
</div>
</div>
<div class="sect3">
<h4 id="_rakudo_有核心标准库吗">30.2.6. Rakudo 有核心标准库吗?</h4>
<div class="paragraph">
<p>Rakudo 是一个包含最小电量的编译器发布（Test 和 Nativecall等等），像 linux 内核一样。</p>
</div>
<div class="paragraph">
<p>Rakudo Star 是一个带有一些有用模块的 rakudo, 并且更多的模块可以从生态系统里安装。</p>
</div>
</div>
<div class="sect3">
<h4 id="_有像_bdeparse_那样的东西吗我怎么抓住_ast">30.2.7. 有像 B::Deparse 那样的东西吗?/我怎么抓住 AST?</h4>
<div class="paragraph">
<p>使用 <code>raku --target=ast -e 'very-short-example()'</code> 来抓取编译单元的抽象语法树(AST)。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_语言特性">30.3. 语言特性</h3>
<div class="sect3">
<h4 id="_我怎么_dump_raku_的数据结构就像_perl_5_的_datadumper_和类似的">30.3.1. 我怎么 dump Raku 的数据结构(就像 Perl 5 的 Data::Dumper 和类似的)？</h4>
<div class="paragraph">
<p>examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $foo="bar"
dd $foo        # Str $foo = "bar"
say :$foo.perl # :foo("bar")
say :$foo.gist # foo =&gt; bar</code></pre>
</div>
</div>
<div class="paragraph">
<p>生态系统中还有模块来做这个事情, 例如 <a href="https://github.com/tony-o/raku-data-dump/">Data::Dump</a> 使用颜色来 Dump。</p>
</div>
</div>
<div class="sect3">
<h4 id="_我怎么在_raku_提示符repl中找到历史命令行">30.3.2. 我怎么在 Raku 提示符（REPL）中找到历史命令行？</h4>
<div class="paragraph">
<p>从生态系统中安装 <a href="https://github.com/hoelzro/p6-linenoise/">Linenoise</a>.</p>
</div>
<div class="paragraph">
<p>作为一种选择, 在 UNIX 那样的系统中可以安装 rlwrap。这在类 Debian 系统中可以通过`apt-get install rlwrap` 安装。</p>
</div>
</div>
<div class="sect3">
<h4 id="_为什么_rakudo_编译器有时候报错更友好">30.3.3. 为什么 Rakudo 编译器有时候报错更友好？</h4>
<div class="paragraph">
<p>如果在输出中出现 <code>SORRY!</code> , 则错误是编译时错误, 否则是运行时错误。</p>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1/0     # Attempt to divide 1 by zero using div

sub foo ( Int $a, Int $b ) {...}
foo(1)      # ===SORRY!=== Error while compiling ...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_什么是_any">30.3.4. 什么是 (Any)?</h4>
<div class="paragraph">
<p><a href="http://doc.raku.org/routine/type%2FAny">Any</a> 是一个用于新类的默认超类(superclass)的顶层类。
它经常在这样的上下文出现：变量被定义但没有被赋值， 这里它类似于其它语言中的 undef 或 null 值。</p>
</div>
<div class="paragraph">
<p>examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $foo;
say $foo;       # (Any) 注意圆括号表明的类型对象
say $foo.^name  # Any</code></pre>
</div>
</div>
<div class="paragraph">
<p>(Any) 不应该被用于检查 definedness。 在 Raku 中, definedness 可能是一个对象的属性。 通常实例是被定义的, 而类型对象是未定义的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1.defined       # True
say (Any).defined   # False</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_so_是什么">30.3.5. so 是什么?</h4>
<div class="paragraph">
<p><code>so</code> 是一个松散优先级的操作符, 它强制上下文为 <a href="https://docs.raku.org/type/Bool">Bool</a>.</p>
</div>
<div class="paragraph">
<p><code>so</code> 拥有和 <code>?</code> 前缀操作符同样的语义, 就像 <code>and</code> 是 <code>&amp;&amp;</code> 的低优先级版本一样.</p>
</div>
<div class="paragraph">
<p>用法示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so 1|2 == 2;    # Bool::True</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中, 比较的结果(结果是 <a href="https://docs.raku.org/type/Junction">Junction</a>)在打印之前被转换为 Bool 值了.</p>
</div>
</div>
<div class="sect3">
<h4 id="_签名中的那些_d_和_u_是什么东东">30.3.6. 签名中的那些 :D 和 :U 是什么东东？</h4>
<div class="paragraph">
<p>在 Raku 中, 类和其它类型是对象, 并且传递自身类型的类型检测。
例如如果你声明一个变量</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int $x = 42;</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么, 你不仅可以给它赋值整数（即， Int 类的实例）, 还能给它赋值 Int 类型对象自身：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$x = Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想排除类型对象, 你可以追加一个 <code>:D</code> 类型微笑符, 它代表"定义"（definite）:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int:D $x = 42;
$x = Int;  # dies with:
           # Type check failed in assignment to $x;
           # expected Int:D but got Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样地, <code>:U</code> 约束为未定义的值, 即类型对象。
要显式地允许类型对象或实例, 你可以使用 <code>:_</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_签名中的_是什么东东">30.3.7. 签名中的 -&#8594; 是什么东东？</h4>
<div class="paragraph">
<p><code>-&#8594;</code> 是一个返回值约束, 要么是类型要么是有定义的值。</p>
</div>
<div class="paragraph">
<p>类型约束的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub divide-to-int( Int $a, Int $b --&gt; Int ) {
        return ($a / $b).narrow;
}

divide-to-int(3, 2)
# Type check failed for return value; expected Int but got Rat</code></pre>
</div>
</div>
<div class="paragraph">
<p>有明确返回值的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub discard-random-number( --&gt; 42 ) { rand }
say discard-random-number
# 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，最终值被抛弃，因为已经指定了返回值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_any_和_mu_的区别是什么">30.3.8. Any 和 Mu 的区别是什么?</h4>
<div class="paragraph">
<p><code>Mu</code> 是所派生出的所有其它类型的基类型. <code>Any</code> 是从  <code>Mu`派生来的, 代表着任何类型的 Raku 值. 主要区别是, `Any</code> 不包含 <code>Junction</code>.</p>
</div>
<div class="paragraph">
<p>子例程参数的默认类型是 <code>Any</code>, 以至于当你声明 <code>sub foo ($a)</code> 时, 你真正表达的是 <code>sub foo (Any $a)</code> . 类似地, 类的声明被假定继承自 <code>Any</code>, 除非使用了像 <code>is Mu</code> 这样的 trait 特征.</p>
</div>
</div>
<div class="sect3">
<h4 id="_怎么从_junction_中提取值">30.3.9. 怎么从 Junction 中提取值?</h4>
<div class="paragraph">
<p>如果你想从 <a href="https://docs.raku.org/type/Junction">Junction</a> 中提取值(特征态), 那你可能正误入歧途. 应该使用 <a href="https://docs.raku.org/type/Set">Set</a> 代替</p>
</div>
<div class="paragraph">
<p>Junctions 作为匹配器, 而不是使用它们做代数.</p>
</div>
<div class="paragraph">
<p>如果你还是想那样做, 你可以滥用自动线程(autothreading):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub eigenstates(Mu $j) {
    my @states;
    -&gt; Any $s { @states.push: $s }.($j);
    @states;
}

say eigenstates(1|2|3).join(', ');
# prints 1, 2, 3 or a permutation thereof</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_如果_str_是不可变的_那么_s_是怎么工作的_如果_int_是不可变的_i_是怎么工作的">30.3.10. 如果 Str 是不可变的, 那么 <code>s///</code> 是怎么工作的? 如果 Int 是不可变的, <code>$i++</code> 是怎么工作的?</h4>
<div class="paragraph">
<p>在 Raku 中, 很多基本类型是不可变的, 但是保存它们的变量不是. <code>s///</code> 作用于变量上, 在这个变量中放入一个新创建的字符串对象. 同样地, <code>$i++</code> 作用于 <code>$i</code> 变量上, 而不是作用在它里面的值身上.</p>
</div>
<div class="paragraph">
<p>更多详情请查看:  <a href="http://doc.raku.org/language/containers">containers</a> 文档。</p>
</div>
</div>
<div class="sect3">
<h4 id="_什么是数组引用和自动解引用_我仍然需要_符号吗">30.3.11. 什么是数组引用和自动解引用? 我仍然需要 @ 符号吗?</h4>
<div class="paragraph">
<p>在 Raku 中, 几乎所有的东西都是引用. 所以谈论 taking references 没有多大意义. 不像 Perl 5 那样, Raku 的标量变量也能直接包含数组:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 2, 3;
say @a;                 # "1 2 3\n"
say @a.WHAT;            # (Array)

my $scalar = @a;
say $scalar;            # "1 2 3\n"
say $scalar.WHAT;       # (Array)</code></pre>
</div>
</div>
<div class="paragraph">
<p>最大的区别是, 标量中的数组在列表上下文中是一个值, 然而数组会被愉快地迭代:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 2, 3;
my $s = @a;

for @a { ... }          # loop body executed 3 times
for $s { ... }          # loop body executed only once

my @flat = flat @a, @a;
say @flat.elems;        # 6

my @nested = flat $s, $s;
say @nested.elems;      # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用 <code>@( &#8230;&#8203; )</code> 或通过在表达式身上调用 <code>.list</code> 方法来强制展平, 使用 <code>$( &#8230;&#8203; )</code> 或通过在表达式身上调用 <code>.item</code> 方法强制为 item  上下文(不展平).</p>
</div>
</div>
<div class="sect3">
<h4 id="_为什么还要符号_你不能没有它们吗">30.3.12. 为什么还要符号? 你不能没有它们吗?</h4>
<div class="paragraph">
<p>有几个原因:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它们使插值变量到字符串中变得更容易</p>
</li>
<li>
<p>它们为不同的变量和 twigils 组成了微型命名空间, 因此避免了名字冲突</p>
</li>
<li>
<p>它们允许简单的 单数/复数 区别</p>
</li>
<li>
<p>它们像使用强制性名词标记的自然语言一样工作，所以我们的大脑为处理它而生</p>
</li>
<li>
<p>它们不是强制性的，因为你可以声明无符号名字（如果你不介意含糊不清）</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_类型_str_不支持关联索引">30.3.13. 类型 Str 不支持关联索引</h4>
<div class="paragraph">
<p>你可能会把字符串插值和 HTML 搞混。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $foo = "abc";
say "$foo&lt;html-tag&gt;";</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 认为 <code>$foo</code> 是一个散列而 <code>&lt;html-tag&gt;</code> 是一个字符串字面量的散列键。使用闭包来帮助你理解吧。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $foo = "abc";
say "{$foo}&lt;html-tag&gt;";</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_raku_有协程吗_什么是_yield">30.3.14. Raku 有协程吗? 什么是 yield ?</h4>
<div class="paragraph">
<p>Raku 没有 Python 那样的 <code>yield</code> 语句, 但是它通过惰性列表却能提供类似的功能. 有两种很潮的方式来写出能返回惰性列表的例程:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># first method, gather/take
my @values := gather while have_data() {
    # do some computations
    take some_data();
    # do more computations
}

# second method, use .map or similar method
# on a lazy list
my @squares := (1..*).map(-&gt; $x { $x * $x });
# or
my @squares = (1..*).map(-&gt; \x { x² });</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_为什么我需要反斜线unspace在多行上分割方法调用">30.3.15. 为什么我需要反斜线(unspace)在多行上分割方法调用?</h4>
<div class="paragraph">
<p>(请在这儿添加答案)</p>
</div>
</div>
<div class="sect3">
<h4 id="_为什么我不能从_new_方法初始化私有属性_我怎么修复它">30.3.16. 为什么我不能从 new 方法初始化私有属性, 我怎么修复它?</h4>
<div class="paragraph">
<p>这样的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    has $!x;
    method show-x {
        say $!x;
    }
}
A.new(x =&gt; 5).show-x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不会打印出 5. Private 属性是私有的, 这意味着私有属性在外面是不可见的. 如果默认的构造器能够初始化私有属性, 那么这些私有属性就会泄露到公共 API 中.</p>
</div>
<div class="paragraph">
<p>如果你仍旧想让它工作, 你可以添加一个 <code>submethod BUILD</code> 来初始化它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class B {
    has $!x;
    submethod BUILD(:$!x) { }
    method show-x {
        say $!x;
    }
}
A.new(x =&gt; 5).show-x;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>BUILD</code> 由默认的构造器使用用户传递给构造器的所有具名参数调用（间接地, 更多细节查看<a href="https://docs.raku.org/language/objects#Object_Construction">Object Construction</a>）。 <code>:$!x</code> 是名为 <code>x</code> 的具名参数, 当使用名为 <code>x</code> 的具名参数来调用时, 它的值被绑定到属性 <code>$!x</code> 上.</p>
</div>
<div class="paragraph">
<p>但不要这样做。如果名字是 public 的，使用 <code>$.x</code> 以那样的方式声明没有什么不好，因为默认情况下外部视图是只读的(readonly)，你仍然可以使用 <code>$!x</code> 从内部访问它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_say_put_和_print_怎么不同_为什么不同">30.3.17. say, put 和 print 怎么不同, 为什么不同?</h4>
<div class="paragraph">
<p>最明显的区别是, <code>say</code> 和 <code>put</code> 在输出后面添加了一个换行符, 而 <code>print</code> 没有.</p>
</div>
<div class="paragraph">
<p>但是还有另外一个区别: <code>print</code> 和 <code>put</code> 通过对每一个传递来的 item 调用 <code>Str</code> 方法来把它的参数转换为字符串, 相反,  <code>say</code> 使用  <code>gist</code> 方法. 前者是为计算机设计的, 后者是为人类.</p>
</div>
<div class="paragraph">
<p>或者它俩被解析的方式不同, <code>$obj.Str</code> 给出一个字符串表示, <code>$obj.gist</code> 是对象的一个简短总结, 适合编程人员的快速识别, <code>$obj.perl</code> 打印一个 Perlish 的表示.</p>
</div>
<div class="paragraph">
<p>例如, 类型对象, 也是熟知的 “未定义值”, 字符串化为一个空的字符串和警告, 而 <code>gist</code> 方法返回由一对圆括号包裹的类型的名字.(用于表明除了类型之外什么也没有).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Date $x;     # $x now contains the Date type object
print $x;       # empty string plus warning
say $x;         # (Date)\n</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以, <code>say</code> 优化的用于调试和向人们展示, <code>print</code> 和 <code>put</code> 更适合于产生用于其它程序的输出.</p>
</div>
<div class="paragraph">
<p><code>put</code> 因此是 <code>print</code> 和 <code>say</code> 之间的一种混合; 像 <code>print</code>, 它的输出适合于其它程序, 也像 <code>say</code>, 它在输出的末尾添加了换行符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_token_和_rule_之间的区别是什么">30.3.18. token 和 rule 之间的区别是什么?</h4>
<div class="paragraph">
<p><code>regex</code> , <code>token</code> 和 <code>rule</code> 这三个都引入了正则表达式, 但是语义略微有一点不同.</p>
</div>
<div class="paragraph">
<p><code>token</code> 隐含了 <code>:ratchet</code> 或 <code>:r</code> 修饰符, 这防止了 rule 的回溯.</p>
</div>
<div class="paragraph">
<p><code>rule</code> 隐含了 <code>:ratchet</code> 和  <code>:sigspace</code> (缩写为 <code>:s</code>)修饰符, 这意味着规则(rule)不会回溯, 并且它把 regex 的文本中的空白当作 <code>&lt;.ws&gt;</code> 调用(例如匹配空白, 除了在两个单词字符之间之外, 它是可选的).  regex 开头的空白和备选分支中每个分支开头的空白会被忽略.</p>
</div>
<div class="paragraph">
<p><code>regex</code> 声明一个简单的正则表达式，没有任何隐含的修饰符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_die_和_fail_之间的区别是什么">30.3.19. die 和 fail 之间的区别是什么?</h4>
<div class="paragraph">
<p><code>die</code> 抛出一个异常.</p>
</div>
<div class="paragraph">
<p><code>fail</code> 返回一个 Failure 对象。 （如果调用者已经声明了 <code>use fatal;</code> 在调用作用域中, <code>fail</code> 会抛出一个异常而不返回）</p>
</div>
<div class="paragraph">
<p><code>Failure</code> 是一个 “未知的” 或 “懒惰的” 异常.它是一个含有异常的对象, 当这个 Failure 被用作普通的对象或者在 sink 上下文中忽略它时, 则会抛出一个异常.</p>
</div>
<div class="paragraph">
<p>Failure 从 <code>defined</code> 检查中返回 False, 并且你可以使用 <code>exception</code> 方法提取出异常.</p>
</div>
</div>
<div class="sect3">
<h4 id="_为什么_wantarray_或_want_不见了_我能在不同的上下文中返回不同的东西吗">30.3.20. 为什么 wantarray 或 want 不见了? 我能在不同的上下文中返回不同的东西吗?</h4>
<div class="paragraph">
<p>Perl 拥有 <a href="https://docs.raku.org/language/5to6-perlfunc#wantarray">wantarray</a> 函数来告诉你这是在空上下文, 标量上下文,还是在列表上下文中调用的. Raku 没有与之等价的结构, 因为上下文不是向内流动的,  例如, 子例程不知道调用所在的上下文.</p>
</div>
<div class="paragraph">
<p>一个愿意是因为 Raku 有多重分派, 在这样一个例子中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi w(Int $x) { say 'Int' }
multi w(Str $x) { say 'Str' }
w(f());</code></pre>
</div>
</div>
<div class="paragraph">
<p>没办法决定子例程 <code>f</code> 的调用者想要一个字符串还是想要一个整数, 因为它还不知道调用者是什么. 通常这要求解决 halting 问题, 在这个问题上, 即使写 Raku编译器的人也会遇到麻烦.</p>
</div>
<div class="paragraph">
<p>在 Raku 中达到上下文敏感的方式是返回一个知道怎样响应方法调用的对象.</p>
</div>
<div class="paragraph">
<p>例如, regex 匹配返回 Match <a href="http://doc.raku.org/type/Match">对象</a>, 该对象知道怎样响应列表索引, 散列索引, 并能变成匹配的字符串.</p>
</div>
</div>
<div class="sect3">
<h4 id="_pointer_和_opaquepointer_的区别是声明">30.3.21. Pointer 和 OpaquePointer 的区别是声明?</h4>
<div class="paragraph">
<p><code>OpaquePointer</code> 被废弃了并且已经用 <code>Pointer</code> 代替了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_raku_实现">30.4. Raku 实现</h3>
<div class="sect3">
<h4 id="_哪个_raku_的实现是可用的">30.4.1. 哪个 Raku 的实现是可用的?</h4>
<div class="paragraph">
<p>当前开发最好的是 Rakudo(使用多个虚拟机后端)。历史上的实现还包括 Niecza (.NET) 和 Pugs (Haskell). 其它的列出在 <a href="https://www.raku.org/compilers/">Raku Compilers</a> 下面。</p>
</div>
</div>
<div class="sect3">
<h4 id="_rakudo_是用什么语言写的">30.4.2. Rakudo 是用什么语言写的?</h4>
<div class="paragraph">
<p>NQP 是（1）NQP 代码，（2）底层虚拟机使用的任何语言，（3）一些第三方 C 和 Java 库，以及（4）早期运行构建过程创建的一些引导文件的混合 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_为什么我不能把所有的数值都赋值给_num_类型的变量">30.4.3. 为什么我不能把所有的数值都赋值给 Num 类型的变量?</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Num $x = 42;
# dies with
# Type check failed in assignment to '$x'; expected 'Num' but got 'Int'</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://doc.raku.org/type/Num">Num</a> 是浮点类型, 与 <a href="http://doc.raku.org/type/Int"> integers</a> 不兼容. 如果你想要一个允许任何数字值的类型约束, 使用 <a href="http://doc.raku.org/type/Numeric">Numeric</a> (它也允许<a href="http://doc.raku.org/type/Complex">复数</a>), 或 <a href="http://doc.raku.org/type/Real">Real</a>如果你想排除复数.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_元问题和宣传">30.5. 元问题和宣传</h3>
<div class="sect3">
<h4 id="_raku_什么时间会准备好_就是现在吗">30.5.1. Raku 什么时间会准备好? 就是现在吗?</h4>
<div class="paragraph">
<p>编程语言和它们的编译器的准备就绪不是一个二元决策. 因为它们(语言和实现)能进化, 它们平稳地发展变得更可用. 根据你对编程语言的要求, 它可能适合也可能不适合你.</p>
</div>
<div class="paragraph">
<p>请查看 <a href="http://raku.org/compilers/features">功能对比矩阵</a> 了解更详尽的实现了的功能.</p>
</div>
<div class="paragraph">
<p>请注意, Larry Wall 已经在 FOSDEM 2015 会议上宣布, 一个产品级的 Rakudo Raku 将会在 2015 圣诞节发布.</p>
</div>
</div>
<div class="sect3">
<h4 id="_为什么我要学习_raku_它有什么了不起的吗">30.5.2. 为什么我要学习 Raku? 它有什么了不起的吗?</h4>
<div class="paragraph">
<p>Raku 统一了很多其它编程语言中不经常有的伟大想法. 虽然其中的几种语言提供了其中的某些功能, 但是没有提供全部.</p>
</div>
<div class="paragraph">
<p>不像大部分语言那样, 它提供了：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku 提供了过程式的, 面向对象的和函数式编程方法。</p>
</li>
<li>
<p>易于使用的一致性语法, 数据结构中的符号不变性。</p>
</li>
<li>
<p>完全基于字素的 Unicode 支持, 包括附件 #29</p>
</li>
<li>
<p>足够清晰的正则表达式, 更易读, 更多功能。</p>
</li>
<li>
<p>Junctions 允许多个可能性的简单检测, 例如 $a == 1|3|42（意思是 $a 等于 1 或 3 或 42）</p>
</li>
<li>
<p>相对于全局变量, 动态作用域变量提供了词法作用域备选</p>
</li>
<li>
<p>强调可组合性和本地作用域以阻止「超距作用」。例如, imports 总是本地作用域的。</p>
</li>
<li>
<p>易于理解的一致性作用域规则和闭包</p>
</li>
<li>
<p>强大的面向对象, 含有类和 roles(所有的东西都可以当做对象)。继承、子类型、代码复用。</p>
</li>
<li>
<p>内省到对象和元对象中（叠罗汉）</p>
</li>
<li>
<p>元对象协议允许元编程而不需要生成/解析代码。</p>
</li>
<li>
<p>子例程和方法签名，便于解包位置参数和命名参数。</p>
</li>
<li>
<p>根据元数,类型和可选的额外代码使用不同的签名对同一具名子例程/方法进行多重分派。</p>
</li>
<li>
<p>未知子例程/不可能的分派在编译时给出错误报告。</p>
</li>
<li>
<p>可选的渐进类型检查，无需额外的运行时成本。 还有可选类型注解。</p>
</li>
<li>
<p>基于对编译器/运行时状态的内省的高级错误报告。这意味着更有用，更精确的错误信息。</p>
</li>
<li>
<p>Phasers(如 BEGIN/END) 允许代码作用域 进入/退出, 首次循环/last/next 和其它更多上下文中执行。</p>
</li>
<li>
<p>高级并发模型，用于隐式以及显式多进程处理，这超越了原始线程和锁。 Raku 的并发提供了一组丰富的（可组合的）工具。</p>
</li>
<li>
<p>多核计算机越来越多地被使用，由于并行性使得 Raku 可以使用多核，包括隐式（例如使用&gt;&gt;.方法）和显式 (start {code}) 。这很重要，因为摩尔定律正在结束。</p>
</li>
<li>
<p>提供结构化语言支持以实现异步执行代码的编程。</p>
</li>
<li>
<p>Supplies 允许在发生某些事情时执行代码（如定时器，信号或文件系统事件）。</p>
</li>
<li>
<p>react/whenever/supply 关键字允许容易地构建交互式，事件驱动的应用程序。</p>
</li>
<li>
<p>懒惰求值，如果可能的话，急切求值当需要或必要时。这意味着，例如，惰性列表，甚至无限延迟列表，如斐波纳契序列或所有素数。</p>
</li>
<li>
<p>原生数据类型用于更快的处理</p>
</li>
<li>
<p>使用 NativeCall 连接到 C/C++ 中的外部库非常简单。</p>
</li>
<li>
<p>使用 Inline::Perl5 和 Inline::Python 连接 Perl 5(CPAN)/Python 非常简单。</p>
</li>
<li>
<p>可以同时安装和加载模块的多个版本。</p>
</li>
<li>
<p>由于更简单的更新/升级策略，简化了系统管理。</p>
</li>
<li>
<p>简单的数值计算没有损失精度，因为 Rats（有理数）。</p>
</li>
<li>
<p>用于解析数据或代码的可扩展语法（Raku 用它解析自身）</p>
</li>
<li>
<p>Raku 是一种非常易变的语言（定义自己的函数，运算符，traits 和数据类型，为您修改解析器）。</p>
</li>
<li>
<p>很多的数据类型选择，加上创建自己的类型的可能性。</p>
</li>
<li>
<p>具有适当边界检查的多维成型的和/或原生数组</p>
</li>
<li>
<p>在某个匹配出现时, 词法解析期间随时执行代码</p>
</li>
<li>
<p>添加自定义运算符或添加 trait 特征和编写子例程一样简单。</p>
</li>
<li>
<p>在任何运算符（系统或自定义添加的）上自动生成超运算符。</p>
</li>
<li>
<p>运行在各种后端上。目前 MoarVM 和 JVM，JavaScript在开发中，可能会有更多。</p>
</li>
<li>
<p>执行期间（JIT）热代码路径的运行时优化。</p>
</li>
<li>
<p>运行在小型（例如 Raspberry Pi）和大型多处理器硬件上。</p>
</li>
<li>
<p>基于垃圾收集：没有及时销毁，所以引用计数没有必要。使用 phasers 用以及时的动作。</p>
</li>
<li>
<p>方法可以在运行时混合到任何实例化的对象中，例如。以允许添加带外数据。</p>
</li>
<li>
<p>通过使用具有多重分派和自动生成使用信息的 MAIN 子例程，使命令行接口易于访问。</p>
</li>
<li>
<p>更少的代码行创建更紧凑的程序。名字的霍夫曼编码允许更好的可读性。</p>
</li>
<li>
<p>使用简单的迭代器接口定义的惰性列表，任何类可以通过最小化的提供单个方法来提供。</p>
</li>
<li>
<p>Perl  6 的座右铭与 Perl一直保持不变：Perl是不同的。简而言之，Perl旨在"使容易的工作变得容易，使困难的工作变得可能"。和"条条大路通罗马"。现在有更多 -Ofun 添加进来。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请查看 <a href="http://raku.org/compilers/features">功能比较矩阵</a> 获取更多信息.</p>
</div>
</div>
<div class="sect3">
<h4 id="_为什么不把它叫做除了_perl_以外的其它东西">30.5.3. 为什么不把它叫做除了 Perl 以外的其它东西?</h4>
<div class="paragraph">
<p>很多人建议, Raku 跟之前的 Perl 版本的区别太大了, 我们应该考虑给它改名, 或者考虑到 Raku 伤害了 Perl 5, 仅仅拥有同样的名字却有更高的版本号.</p>
</div>
<div class="paragraph">
<p>Raku 仍然叫做 “Perl" 的主要原因是:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Raku 仍然是一个 perlish 风格的语言, 和之前的版本遵守相同的底层思想(用于微型命名空间的符号, 条条大路通罗马, 吸收了很多自然语言的思想..)</p>
</li>
<li>
<p>Raku 的代码很 perlish.</p>
</li>
<li>
<p>Perl 仍然是一个强健的品牌名, 我们不想马上抛弃它</p>
</li>
<li>
<p>找到一个替代的名字很困难. 而且, “camelia” 和 “rakudo" 不是合适的编程语言名</p>
</li>
<li>
<p>即使 Raku 更改了它的名字, Perl 5 也不大可能增加它的版本号为 6.因为 Raku 已经根植于人们的头脑中了</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_raku_对我来说足够快了吗">30.5.4. Raku 对我来说足够快了吗?</h4>
<div class="paragraph">
<p>那取决于你正在做什么。Raku 一直奉行“做对的事情然后做的更快”的哲学进行开发。对于某些东西来说它够快了, 但是需要做的更多。
Raku 大部分是由志愿者开发的, 但是 Raku 的性能在不久的将来有待提高, 因为 MoarVM 后端包含一个现代的即时（JIT）编译器。
Perl 5 程序员应该意识到 Raku 在面向对象方面有很多内建函数并且还有更多其它的。
简单的基准测试会误导除非你在你的 Perl 5脚本中包含了诸如 Moose, 类型检测模块等。</p>
</div>
<div class="paragraph">
<p>下面这个粗超的基准测试, 使用了所有诸如此类的一般说明, 能展示 Raku 在某些类似任务上能和 Perl 5的速度接近。
在你的系统上尝试下, 你可能会感到很惊讶!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Raku version
use v6;

class Foo { has $.i is rw };

for (1..1_000_000) -&gt; $i {
    my $obj = Foo.new;
    $obj.i = $i;
}

# Perl 5 version
package Foo;
use Moose;

has i =&gt; (is =&gt; 'rw');

__PACKAGE__-&gt;meta-&gt;make_immutable;

for my $i (1..1_000_000) {
    my $obj = Foo-&gt;new;
    $obj-&gt;i($i);
}

1;

# Another Perl 5 version that offers bare-bones set of features
# compared to Moose/Raku's version but those are not needed in this
# specific, simple program anyway.
package Foo;
use Mojo::Base -base;

has 'i';

for my $i (1..1_000_000) {
    my $obj = Foo-&gt;new;
    $obj-&gt;i($i);
}

1;

# A perl program which works under both perl5 (with perl -Mbigint)
# and raku

my ($prev, $current) = (1, 0);

for (0..100_000) {
    ($prev, $current) = ($current, $prev + $current);
}
print $current;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_术语">31. 术语</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_匿名">31.1. 匿名</h3>
<div class="paragraph">
<p>子例程、方法或子方法，当它们不能通过名字调用时，就被称为匿名的</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># named subroutine
sub double($x) { 2 * $x };
# 匿名子例程,存储在一个具名的标量里
my $double = sub ($x) { 2 * $x };</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，匿名子例程仍然可以有名字</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># 使用 anon 关键字使子例程匿名
my $s = anon sub triple($x) { 3 * $x }
say $s.name;        # triple</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_副词">31.2. 副词</h3>
<div class="paragraph">
<p>通常, 副词是函数的命名参数.  也有一些其它特殊语法形式允许副词出现在某些合适的地方:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">q:w"foo bar"   # ":w" is a Quotelike form modifier adverb
m:g/a|b|c/     # ":g" is also
4 +&gt; 5 :rotate # ":rotate" is an operator adverb
@h{3}:exists   # ":exists" is also, but is known as a subscript adverb</code></pre>
</div>
</div>
<div class="paragraph">
<p>副词通常使用冒号对儿标记来表示, 因为这个原因, 冒号对儿标记法也以副词对儿形式著称:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">:a(4)          # Same as "a" =&gt; 4</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_autothreading">31.3. Autothreading</h3>
<div class="paragraph">
<p><code>Autothreading</code> 是这样的: 如果你传递一个 <code>junction</code> 给子例程, 该子例程期望的参数类型为`Any` 或它的子类型. 那么这个子例程调用会被执行多次, 每次使用一个不同的 junction 状态. 这些调用的结果被组合成一个跟原 <code>junction</code> 同类型的 <code>junction</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($x) { 2 * $x };
if f(1|2|3) == 4 {
    say 'success';
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 <code>f()</code> 是含有一个参数的子例程，然而因为它没有显式的类型声明，它就被隐式的声明为 <code>Any</code> 型。 Junction 参数使 <code>f(1|2|3)</code> 调用在内部作为 <code>f(1)|f(2)|f(3)</code> 执行,而结果是跟原 <code>junction</code> 同类型的 <code>junction</code> , 即  <code>2|4|6</code>.  这种把一个 <code>Junction</code> 分成对多次函数调用的处理就叫做 <code>autothreading</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_colon_pair_and_colon_list">31.4. Colon Pair and Colon List</h3>
<div class="paragraph">
<p>冒号对儿是用于创建或 Pair 对象的便捷语法. 两种最常见的形式是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">:a(4)          # Same as "a" =&gt; 4,   same as Pair.new(:key&lt;a&gt;,:value(5))
:a&lt;4&gt;          # Same as "a" =&gt; "4", same as Pair.new(:key&lt;a&gt;,:value&lt;5&gt;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也是人们熟知的副词对儿形式. 注意, 当冒号后面括号前面的部分不是一个合法的标识符的时候, 会应用其它语义, 不是所有的副词对儿都创建 <code>Pair</code> 对象.
另外两个常见的形式是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">:a             # Same as :a(True)
:!a            # Same as :a(False)</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个 colon 列表是一个仅包含冒号对儿的列表, 不需要逗号, 甚至不需要空格:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">:a(4):c:!d:c   # Same as a =&gt; 4, c =&gt; True, d =&gt; False, c =&gt; True</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_constraint">31.5. Constraint</h3>
<div class="paragraph">
<p>约束是给参数或 subset 类型添加的限制. 通过单词 where 引入约束. 在下面的例子中, 约束用于确保 , 当调用一个名为 abbreviate 的子例程, 其参数为一个长度小于 10 个字符的字符串时,会抛出一个错误:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub abbreviate (Str $thing where { .chars &gt;= 10 }) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>上例中的 Str 也是一个约束, 但是经常作为"类型约束".</p>
</div>
</div>
<div class="sect2">
<h3 id="_instance">31.6. Instance</h3>
<div class="paragraph">
<p>类的实例在其它编程语言中也叫对象. 对象存储属性, 通常是 new 方法调用的返回值, 或者是对象字面量.
大部分类型的实例被定义为 True, 例如 <code>defined($instance)</code> 为 True.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Str $str = "hello";  ## 这使用内建类型,例如 Str
if defined($str) {
    say "Oh, yeah. I'm defined.";
} else {
    say "No. Something off? ";
}
## if you wanted objects...
class A {
    # nothing here for now.
}
my $an_instance = A.new;
say $an_instance.defined.perl;# defined($an_instance) works too.</code></pre>
</div>
</div>
<div class="paragraph">
<p>类拥有方法和属性的所有蓝图, 而类的实例把蓝图带到真实世界中.</p>
</div>
</div>
<div class="sect2">
<h3 id="_invocant">31.7. Invocant</h3>
<div class="paragraph">
<p>在 Raku 中调用方法的对象叫做调用者. 在方法中它就是 <code>self</code> 引用的东西.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'str'.uc;   # 'str' 是 方法 uc 的调用者</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_literal">31.8. Literal</h3>
<div class="paragraph">
<p>字面量是一块直接代表对象的代码, 通常指向对象自身.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 2;      # the 2 is a literal
say $x;         # $x is not a literal, but a variable</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lvalue">31.9. lvalue</h3>
<div class="paragraph">
<p>lvalue 或者左值是能出现在赋值操作符左侧的任何东西; 典型的左值有变量,私有属性和 `is rw`属性, 变量列表和左值子例程.
左值的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Declaration             lvalue          Comments
my $x;                  $x
my ($a, $b);            ($a, $b)
has $!attribute;        $!attribute     Only inside classes
has $.attrib is rw;     $.attrib
sub a is rw { $x };     a()</code></pre>
</div>
</div>
<div class="paragraph">
<p>不是左值的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">3                        # literals
constant x = 3;          # constants
has $.attrib;            # attributes; you can only assign to $!attrib
sub f { }; f();          # "normal" subs are not writable
sub f($x) { $x = 3 };    # error - parameters are read-only by default</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mainline">31.10. Mainline</h3>
<div class="paragraph">
<p><code>mainline</code> 是程序中不属于任何 block 的程序文本.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6;     # mainline
sub f {
            # not in mainline, in sub f
}
f();        # in mainline again</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_slurpy">31.11. Slurpy</h3>
<div class="paragraph">
<p>子例程或方法中的形参如果能接收任意数量的参数, 那这个形参就会被认为是 <code>slurpy</code> 的. 它由参数名字前面的星号标出.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub sum (*@numbers) {
    return [+] @numbers;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_type_object">31.12. Type Object</h3>
<div class="paragraph">
<p>类型对象是一个代表类 <code>/role/package/grammar/enum</code> 的对象. 它通常和类型名相同.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A { };
say A;              # A is the type object
my $x = A.new();    # same here
my $x = class {
    method greet() {
        say "hi";
    }
}

# $x now holds a type object returned from the
# anonymous class definition</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pod_文档">32. Pod 文档</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku Pod 是一种易于使用的标记语言。 Pod 可用于编写语言文档，用于文档化程序和模块，以及其他类型的文档组合。</p>
</div>
<div class="paragraph">
<p>每个 Pod 文档必须以 <code>=begin pod</code> 开头，以 <code>=end pod</code> 结束。这两个分隔符之间的所有内容都将被处理并用于生成文档。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=begin pod

A very simple Raku Pod document

=end pod</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_块结构">32.1. 块结构</h3>
<div class="paragraph">
<p>Pod 文档可能包含多个 Pod 块。有四种方法可以定义块（分隔符，段落，缩写和声明符）; 前三个产生相同的结果，但第四个不同。你可以使用最方便你的特定文档任务的任何形式。</p>
</div>
<div class="sect3">
<h4 id="_分割符块">32.1.1. 分割符块</h4>
<div class="paragraph">
<p>分隔块由 <code>=begin</code> 和 <code>=end</code> 标记限定，两者都后跟有效的 Raku 标识符，后者是块的 <code>typename</code>。完全小写的类型名称（例如 <code>=begin head1</code>）或完全大写（例如：<code>=begin SYNOPSIS</code>）保留。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=begin head1
Top Level Heading
=end head1</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配置信息">32.2. 配置信息</h3>
<div class="paragraph">
<p>在 typename 之后， <code>=begin</code> 标记行的其余部分被视为块的配置信息。此信息由不同类型的块以不同方式使用，但始终使用 Raku-ish 选项对指定。也就是说，任何：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">alue is&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specify with&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Or with&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Or with&#8230;&#8203;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">List</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:key[$e1, $e2, &#8230;&#8203;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:key($e1, $e2, &#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:key{$k1&#8658;$v1, $k2&#8658;$v2}</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean (true)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:key</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:key(True)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:key[True]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean (false)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:!key</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:key(False)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:key[False]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:key&lt;str&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:key('str')</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:key("str")</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:key(42)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:key[42]</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:key(2.3)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:key[2.3]</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>其中'$e1，$e2，&#8230;&#8203;'是 String，Int，Number 或 Boolean 类型的列表元素。列表可能具有混合元素类型。请注意，单元素列表将转换为其元素的类型（String，Int，Number 或 Boolean）。另请注意，如果需要，可以使用“bigints”。</p>
</div>
<div class="paragraph">
<p>对于散列，'$k1，$k2，&#8230;&#8203;'是 Str 类型的键，'$v1，$2，&#8230;&#8203;'是 String，Int，Number 或 Boolean 类型的值。</p>
</div>
<div class="paragraph">
<p>字符串由单引号或双引号分隔。空格在字符串之外是微不足道的。散列键不需要引用分隔，除非它们包含重要的空格。</p>
</div>
<div class="paragraph">
<p>当然，所有选项键和值必须是常量，因为Pod是一种规范语言，而不是编程语言。具体来说，选项值不能是闭包。有关各种Raku对符号的详细信息，请参见概要2。</p>
</div>
<div class="paragraph">
<p>配置部分可以通过在第一（虚拟）列中带有=后跟空白字符的那些行开始在后续行上扩展。 （注意：此功能尚未实现。当前所有配置信息必须与= begin标记行在同一行提供，或=为段落块的名称提供。）</p>
</div>
<div class="sect3">
<h4 id="_段落块">32.2.1. 段落块</h4>
<div class="paragraph">
<p>段落块以 <code>=for</code> 标记开始，以下一个 Pod 指令或第一个空行结束。 <code>=for</code> 标记后面跟着块的类型名加上，可选地，跟上面描述的分隔块中的任何配置数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=for head1
Top Level Heading</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_缩写块">32.3. 缩写块</h3>
<div class="paragraph">
<p>缩写块以 <code>=</code> 符号开头，紧接着是块的类型名称。以下所有数据都是块内容的一部分，因此无法为缩写块指定配置数据。该块在下一个Pod指令或第一个空行结束。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=head1 Top Level Heading</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_声明器块">32.4. 声明器块</h3>
<div class="paragraph">
<p>声明器块与其他声明块不同，没有特定类型，而是附加到某些源代码。</p>
</div>
<div class="paragraph">
<p>声明器块由特殊注释引入：<code><mark>=</code> 或 <code></mark>|</code>，必须紧跟空格或左括号。如果后跟一个空格，则该块在行尾终止;如果后跟一个或多个左括号，则该块由关闭括号的匹配序列终止。</p>
</div>
<div class="paragraph">
<p>以＃开头的块附加到它们之后的代码，以 <code>#=</code> 开头的块附加到它们之前的代码。</p>
</div>
<div class="paragraph">
<p>由于声明器块附加到源代码，因此它们可用于记录类，角色，子例程等。</p>
</div>
<div class="paragraph">
<p>WHY方法可用于这些类，角色，子例程等，以返回附加的 Pod 值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| Base class for magicians
class Magician {
  has Int $.level;
  has Str @.spells;
}

#| Fight mechanics
sub duel(Magician $a, Magician $b) {
}
#= Magicians only, no mortals.

say Magician.WHY; # OUTPUT: «Base class for magicians␤»
say &amp;duel.WHY.leading; # OUTPUT: «Fight mechanics␤»
say &amp;duel.WHY.trailing; # OUTPUT: «Magicians only, no mortals.␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些声明可以扩展多个块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#|( This is an example of stringification:
    * Numbers turn into strings
    * Regexes operate on said strings
    * C&lt;with&gt; topicalizes and places result into $_
)
sub search-in-seq( Int $end, Int $number ) {
    with (^$end).grep( /^$number/ ) {
        .say for $_&lt;&gt;;
    }
}
#=« Uses
    * topic
    * decont operator
»</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过使用匹配的括号构造对，例如 <code>()</code> 或 <code>«»</code>，注释可以扩展多行。但是，这种格式不会转换为 <code>raku -doc</code> 的多行显示。</p>
</div>
</div>
<div class="sect2">
<h3 id="_块类型">32.5. 块类型</h3>
<div class="paragraph">
<p>Pod提供多种标准块类型。</p>
</div>
<div class="sect3">
<h4 id="_标题">32.5.1. 标题</h4>
<div class="paragraph">
<p>可以使用= headN来定义标题，其中N大于零（例如，= head1，= head2，&#8230;&#8203;）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=head1 A Top Level Heading

=head2 A Second Level Heading

=head3 A Third Level Heading</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_普通段落">32.5.2. 普通段落</h4>
<div class="paragraph">
<p>普通段落由在当前嵌套级别格式化为文档的文本组成，其中空格被挤压，线条填充，并且应用了任何特殊的内联标记。</p>
</div>
<div class="paragraph">
<p>普通段落由一个或多个连续的文本行组成，每行文本以非空白字符开头。段落由第一个空行或块指令终止。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=head1 This is a heading block

This is an ordinary paragraph.
Its text  will   be     squeezed     and
short lines filled. It is terminated by
the first blank line.

This is another ordinary paragraph.
Its     text    will  also be squeezed and
short lines filled. It is terminated by
the trailing directive on the next line.

=head2 This is another heading block

This is yet another ordinary paragraph,
at the first virtual column set by the
previous directive</code></pre>
</div>
</div>
<div class="paragraph">
<p>普通段落不需要明确的标记或分隔符。</p>
</div>
<div class="paragraph">
<p>或者，还有一个显式的 <code>=para</code> 标记，可用于明确标记段落。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=para
This is an ordinary paragraph.
Its text  will   be     squeezed     and
short lines filled.</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，可以使用较长 <code>= begin para</code> 和 <code>=end para</code> 形式。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=begin para
This is an ordinary paragraph.
Its text  will   be     squeezed     and
short lines filled.

This is still part of the same paragraph,
which continues until an...
=end para</code></pre>
</div>
</div>
<div class="paragraph">
<p>如前面的示例所示，在分隔 <code>=begin para</code> 和 <code>=end para</code> 块中，保留任何空行。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_代码块">32.6. 代码块</h3>
<div class="paragraph">
<p>代码块用于指定源代码，应该在没有重新调整的情况下进行渲染，不需要空格压缩，也不需要识别任何内联格式代码。通常，这些块用于显示代码，标记或其他文本规范的示例，并使用固定宽度字体进行渲染。</p>
</div>
<div class="paragraph">
<p>代码块可以隐式地指定为一行或多行文本，每行文本以空白字符开头。然后通过空行终止隐式代码块。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">This ordinary paragraph introduces a code block:

    my $name = 'John Doe';
    say $name;</code></pre>
</div>
</div>
<div class="paragraph">
<p>代码块也可以通过将它们包含在= begin code和= end code中来显式定义</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">   =begin code
    my $name = 'John Doe';
    say $name;
   =end code</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_io_块">32.7. I/O 块</h3>
<div class="paragraph">
<p>Pod 提供用于指定程序输入和输出的块。</p>
</div>
<div class="paragraph">
<p><code>=input</code> 块用于指定预先格式化的键盘输入，应该在不重新对齐或挤压空格的情况下进行渲染。</p>
</div>
<div class="paragraph">
<p><code>=output</code> 块用于指定预先格式化的终端或文件输出，也应该在没有重新调整或空白压缩的情况下进行渲染。</p>
</div>
</div>
<div class="sect2">
<h3 id="_列表">32.8. 列表</h3>
<div class="sect3">
<h4 id="_无序列表">32.8.1. 无序列表</h4>
<div class="paragraph">
<p>Pod 中的列表被指定为一系列 <code>=item</code> 块。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">The three suspects are:

=item  Happy
=item  Sleepy
=item  Grumpy</code></pre>
</div>
</div>
<div class="paragraph">
<p>三名嫌犯是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Happy</p>
</li>
<li>
<p>Sleepy</p>
</li>
<li>
<p>Grumpy</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_定义列表">32.8.2. 定义列表</h4>
<div class="paragraph">
<p>定义术语或命令的列表使用 <code>=defn</code>，等同于 HTML 中的 DL 列表</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=defn Happy
When you're not blue.

=defn blue
When you're not happy.</code></pre>
</div>
</div>
<div class="paragraph">
<p>将以这种方式呈现：</p>
</div>
<div class="paragraph">
<p>Happy When you&#8217;re not blue.</p>
</div>
<div class="paragraph">
<p>Blue When you&#8217;re not happy.</p>
</div>
<div class="paragraph">
<p>目前，它可能是一个简单的HTML段落，但将来可能会发生变化。</p>
</div>
</div>
<div class="sect3">
<h4 id="_多层级列表">32.8.3. 多层级列表</h4>
<div class="paragraph">
<p>列表可以是多级的，使用 <code>=item1</code>，<code>=item2</code>，<code>=item3</code> 等块指定每个级别的项目。</p>
</div>
<div class="paragraph">
<p>请注意，<code>=item</code> 只是 <code>=item1</code> 的缩写。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=item1  Animal
=item2     Vertebrate
=item2     Invertebrate

=item1  Phase
=item2     Solid
=item2     Liquid
=item2     Gas</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Animal</p>
</li>
<li>
<p>Vertebrate</p>
</li>
<li>
<p>Invertebrate</p>
</li>
<li>
<p>Phase</p>
</li>
<li>
<p>Solid</p>
</li>
<li>
<p>Liquid</p>
</li>
<li>
<p>Gas</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_多段落列表">32.8.4. 多段落列表</h4>
<div class="paragraph">
<p>使用 <code>=item</code> 块（ <code>=begin item</code> 和 <code>=end item</code> ）的分隔形式，我们可以指定包含多个段落的项目。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Let's consider two common proverbs:

=begin item
I&lt;The rain in Spain falls mainly on the plain.&gt;

This is a common myth and an unconscionable slur on the Spanish
people, the majority of whom are extremely attractive.
=end item

=begin item
I&lt;The early bird gets the worm.&gt;

In deciding whether to become an early riser, it is worth
considering whether you would actually enjoy annelids
for breakfast.
=end item

As you can see, folk wisdom is often of dubious value.</code></pre>
</div>
</div>
<div class="paragraph">
<p>让我们考虑两个常见的谚语：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The rain in Spain falls mainly on the plain.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is a common myth and an unconscionable slur on the Spanish people, the majority of whom are extremely attractive.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The early bird gets the worm.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In deciding whether to become an early riser, it is worth considering whether you would actually enjoy annelids for breakfast.</p>
</div>
<div class="paragraph">
<p>正如你所看到的，民间智慧往往具有可疑的价值。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_表">32.9. 表</h3>
<div class="paragraph">
<p>查看此页面以获取与<a href="https://docs.raku.org/language/tables">表</a>相关的文档</p>
</div>
</div>
<div class="sect2">
<h3 id="_pod_注释">32.10. Pod 注释</h3>
<div class="paragraph">
<p>Pod评论是Pod渲染器忽略的评论。</p>
</div>
<div class="paragraph">
<p>注释对于元文档（记录文档）很有用。单行注释使用comment关键字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=comment Add more here about the algorithm</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于多行注释，请使用带分隔符的注释块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=begin comment
This comment is
multi-line.
=end comment</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_语义块">32.11. 语义块</h3>
<div class="paragraph">
<p>所有大写块类型名称都保留用于指定标准文档，发布，源组件或元信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=NAME
=AUTHOR
=VERSION
=TITLE
=SUBTITLE</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_格式化代码">32.12. 格式化代码</h3>
<div class="paragraph">
<p>格式代码提供了一种向一段文本添加内联标记的方法。
所有Pod格式代码都包含一个大写字母，紧接着是一组尖括号。
格式代码可以嵌套其他格式代码。</p>
</div>
<div class="sect3">
<h4 id="_粗体">32.12.1. 粗体</h4>
<div class="paragraph">
<p>要以粗体格式化文本，请将其括在 <code>B&lt; &gt;</code> 中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Raku is B&lt;awesome&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku is <strong>awesome</strong></p>
</div>
</div>
<div class="sect3">
<h4 id="_斜体">32.12.2. 斜体</h4>
<div class="paragraph">
<p>要用斜体格式化文本，请将其括在 `I&lt; &gt;`中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Raku is I&lt;awesome&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku is <strong>awesome</strong></p>
</div>
</div>
<div class="sect3">
<h4 id="_下划线">32.12.3. 下划线</h4>
<div class="paragraph">
<p>要在文本下划线将其括在 <code>U&lt;&gt;</code> 中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Raku is U&lt;awesome&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_代码">32.12.4. 代码</h4>
<div class="paragraph">
<p>要将文本标记为代码并将其逐字处理，请将其括在 <code>C&lt; &gt;</code> 中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">C&lt;my $var = 1; say $var;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>my $var = 1; say $var;</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_链接">32.12.5. 链接</h4>
<div class="paragraph">
<p>要创建链接，请将其括在 <code>L&lt; &gt;</code> 中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Raku homepage L&lt;https://raku.org&gt;
L&lt;Raku homepage|https://raku.org&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku homepage <a href="https://raku.org/">https://raku.org</a></p>
</div>
<div class="paragraph">
<p><a href="https://raku.org/">Raku homepage</a></p>
</div>
<div class="paragraph">
<p>要创建指向同一文档中某个部分的链接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Comments L&lt;#Comments&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Comments <a href="https://docs.raku.org/language/pod#Comments">Comments</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_注释_3">32.12.6. 注释</h4>
<div class="paragraph">
<p>注释是从不呈现的文本。</p>
</div>
<div class="paragraph">
<p>要创建注释，请将其括在 <code>Z&lt; &gt;</code> 中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Raku is awesome Z&lt;Of course it is!&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku is awesome</p>
</div>
</div>
<div class="sect3">
<h4 id="_笔记">32.12.7. 笔记</h4>
<div class="paragraph">
<p>注释呈现为脚注。</p>
</div>
<div class="paragraph">
<p>要创建一个注释，请将其括在 <code>N&lt; &gt;</code> 中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Raku is multi-paradigmatic N&lt;Supporting Procedural, Object Oriented, and Functional programming&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_键盘输入">32.12.8. 键盘输入</h4>
<div class="paragraph">
<p>要将文本标记为键盘输入，请将其括在 <code>K&lt; &gt;</code> 中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Enter your name K&lt;John Doe&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_终端输出">32.12.9. 终端输出</h4>
<div class="paragraph">
<p>要将文本标记为终端输出，请将其括在 <code>T&lt; &gt;</code> 中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Hello T&lt;John Doe&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_unicode">32.12.10. Unicode</h4>
<div class="paragraph">
<p>要在 Pod 文档中包含 Unicode 代码点或 HTML5 字符引用，请将它们包含在 `E&lt; &gt;`中</p>
</div>
<div class="paragraph">
<p>`E&lt; &gt;`可以包含一个数字，该数字被视为所需代码点的十进制 Unicode 值。它还可以使用 Raku 表示法为显式数字括起显式二进制，八进制，十进制或十六进制数字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Raku makes considerable use of the E&lt;171&gt; and E&lt;187&gt; characters.

Raku makes considerable use of the E&lt;laquo&gt; and E&lt;raquo&gt; characters.

Raku makes considerable use of the E&lt;0b10101011&gt; and E&lt;0b10111011&gt; characters.

Raku makes considerable use of the E&lt;0o253&gt; and E&lt;0o273&gt; characters.

Raku makes considerable use of the E&lt;0d171&gt; and E&lt;0d187&gt; characters.

Raku makes considerable use of the E&lt;0xAB&gt; and E&lt;0xBB&gt; characters.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku makes considerable use of the « and » characters.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_渲染_pod">32.13. 渲染 Pod</h3>
<div class="sect3">
<h4 id="_html">32.13.1. HTML</h4>
<div class="paragraph">
<p>要从 Pod 生成 HTML，你需要 <code>Pod::To::HTML</code> 模块。</p>
</div>
<div class="paragraph">
<p>如果尚未安装，请通过运行以下命令进行安装：<code>zef install Pod::To::HTML</code></p>
</div>
<div class="paragraph">
<p>使用终端运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku --doc=HTML input.pod6 &gt; output.html</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_markdown">32.13.2. Markdown</h4>
<div class="paragraph">
<p>要从 Pod 生 Markdown，你需要 <code>Pod::To::Markdown</code> 模块。</p>
</div>
<div class="paragraph">
<p>如果尚未安装，请通过运行以下命令进行安装：<code>zef install Pod::To::Markdown</code></p>
</div>
<div class="paragraph">
<p>使用终端运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku --doc=Markdown input.pod6 &gt; output.md</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_text">32.13.3. Text</h4>
<div class="paragraph">
<p>为了从 Pod 生成 Text，你可以使用默认的 <code>Pod::To::Text</code> 模块。</p>
</div>
<div class="paragraph">
<p>使用终端，运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku --doc=Text input.pod6 &gt; output.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以省略 <code>=Text</code> 部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku --doc input.pod6 &gt; output.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>你甚至可以将 Pod 直接嵌入到你的程序中，并使用 multi MAIN 子例程将传统的 Unix 命令行 "--man" 选项添加到你的程序中，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi MAIN(Bool :$man)
{
    run $*EXECUTABLE, '--doc', $*PROGRAM;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在 <code>myprogram --man</code> 将输出你的 Pod 渲染为手册页。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_访问_pod">32.14. 访问 Pod</h3>
<div class="paragraph">
<p>为了从 Raku 程序中访问 Pod 文档，需要使用特殊的 <code>=</code> twigil，如<a href="https://docs.raku.org/language/variables#The_%3D_Twigil">变量部分</a>所述。</p>
</div>
<div class="paragraph">
<p><code>=</code> twigil 提供了对 Pod 结构的内省，提供了一个 <a href="https://docs.raku.org/type/Pod::Block">Pod::Block</a> 树根，从中可以访问 Pod 文档的整个结构。</p>
</div>
<div class="paragraph">
<p>例如，以下代码内省了自己的Pod文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=begin pod

=head1 This is an head1 title

This is a paragraph.

=head2 Subsection

Here some text for the subsection.

=end pod

for $=pod -&gt; $pod-item {
    for $pod-item.contents -&gt; $pod-block {
      $pod-block.perl.say;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生以下输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Pod::Heading.new(level =&gt; 1, config =&gt; {}, contents =&gt; [Pod::Block::Para.new(config =&gt; {}, contents =&gt; ["This is an head1 title"])]);
Pod::Block::Para.new(config =&gt; {}, contents =&gt; ["This is a paragraph."]);
Pod::Heading.new(level =&gt; 2, config =&gt; {}, contents =&gt; [Pod::Block::Para.new(config =&gt; {}, contents =&gt; ["Subsection"])]);
Pod::Block::Para.new(config =&gt; {}, contents =&gt; ["Here some text for the subsection."]);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pod_6_表格">33. Pod 6 表格</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku POD 表的官方规范位于文档规范中：<a href="https://raw.githubusercontent.com/raku/specs/master/S26-documentation.pod">表</a>。虽然 Pod 6 的规格尚未完全妥善处理，但仍有几个项目正在进行纠正。一个这样的项目是确保正确处理 Pod 6 表。</p>
</div>
<div class="paragraph">
<p>作为该工作的一部分，本文档通过示例解释了 Pod 6 表的当前状态：有效表，无效表和丑陋表（即，由于草率构造，可能导致与用户期望的不同的有效表） 。</p>
</div>
<div class="sect2">
<h3 id="_restrictions">33.1. Restrictions</h3>
<div class="paragraph">
<p>1.唯一有效的列分隔符要么是可见的（<code>|</code> 或 <code>+</code>）（注意在可见列分隔符之前和之后至少需要一个空格）或不可见[两个或多个连续的空格（WS）字符（例如， '  '）]。在表格的左侧或右侧通常不会识别列分隔符，但是右侧的列分隔符可能会导致一个或多个空单元格，具体取决于其他行中单元格的数量。（请注意，作为单元格数据一部分的管道或加号字符将导致意外的额外列，除非使用反斜杠转义字符，例如 <code>\|</code> 或 <code>\+</code>。）</p>
</div>
<div class="paragraph">
<p>2.在同一个表中混合可见和不可见的列分隔符是非法的。</p>
</div>
<div class="paragraph">
<p>3.唯一有效的行分隔符字符是 <code>_</code>，<code>-</code>，<code>+</code>，<code>' '</code>，<code>|</code> 和 <code>=</code>。</p>
</div>
<div class="paragraph">
<p>4.连续的内部行分隔符是非法的。</p>
</div>
<div class="paragraph">
<p>5.前导和尾随行分隔符会生成警告。</p>
</div>
<div class="paragraph">
<p>6.当前忽略表格单元格中的格式，并将其视为纯文本。</p>
</div>
<div class="paragraph">
<p>提示：在开发过程中，使用环境变量 <code>RAKUDO_POD6_TABLE_DEBUG</code> 将向您展示 Rakudo 如何在将 pod 表传递给渲染器之前解释它们，例如 <strong>Pod::To::HTML</strong>，<strong>Pod::To::Text</strong> 和 <strong>Pod::To::Markdown</strong>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_最佳实践">33.2. 最佳实践</h3>
<div class="paragraph">
<p>提示：由于在表行上进行额外的循环，不遵循以下最佳实践可能需要更多的表处理。</p>
</div>
<div class="paragraph">
<p>1.对列分隔符使用 WS 很脆弱，它们只能用于简单表。以下 <code>Ugly Tables</code> 部分说明了这个问题。</p>
</div>
<div class="paragraph">
<p>2.仔细对齐表格列和行。请参阅后面的最佳实践中的示例。</p>
</div>
<div class="paragraph">
<p>3.不要在表上使用可见的边框。</p>
</div>
<div class="paragraph">
<p>4.对于具有标题和单行或多行内容的表，在标题后使用一个或多个连续的等号（'='）作为行分隔符，并使用一个或多个连续的连字符（'-'）作为表的内容部分中的行分隔符。例如，</p>
</div>
<div class="ulist">
<ul>
<li>
<p>标题和单行或多行内容</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">=begin table
 hdr col 0 | hdr col 1
 ======================
 row 0     | row 0
 col 0     | col 1
 ----------------------
 row 1     | row 1
 col 0     | col 1
 ----------------------
=end table</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>标题和单行内容</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">=begin table
 hdr col 0   | hdr col 1
 ======================
 row 0 col 0 | row 0 col 1
 row 1 col 0 | row 1 col 1
=end table</code></pre>
</div>
</div>
<div class="paragraph">
<p>5.对于没有标题和多行内容的表，请使用一个或多个连续连字符（'-'）作为表格内容部分中的行分隔符。例如，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">=begin table
 row 0       | row 0
 col 0       | col 1
 ----------------------
 row 1 col 0 | row 1 col 1
=end table</code></pre>
</div>
</div>
<div class="paragraph">
<p>6.对于具有许多行且没有多行内容的表，不使用行分隔符就可以了。但是，如果一行或多行包含多行内容，则通过在每个内容行之间使用行分隔线（可见或不可见）来确保正确的结果更容易。</p>
</div>
<div class="paragraph">
<p>7.确保故意空单元格具有列分隔符，否则会出现关于短行填充空单元格的警告。（表行总是与具有最多单元格的行具有相同数量的单元格。右边用空单元格填充短行并生成警告。）</p>
</div>
<div class="paragraph">
<p>8.此示例中使用的 <code>=begin table</code> 行可以为表添加标题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">=begin table :caption&lt;My Tasks&gt;
mow lawn
take out trash
=end table</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然不是一个好的做法，但目前正在使用另一种定义标题的方法，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">=begin table :config{caption =&gt; "My Tasks"}
mow lawn
take out trash
=end table</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，把标题放在 <code>config</code> 哈希中的替代方法必须在实现 <code>:caption</code> 方法之前，但现在认为该方法已被弃用。该练习将在已经发布的 <code>6.d</code> 版本中生成警告，并将在 <code>6.e</code> 版本中引发异常。</p>
</div>
</div>
<div class="sect2">
<h3 id="_good_tables">33.3. Good tables</h3>
<div class="paragraph">
<p>以下是有效（好）表的示例（取自当前的<a href="https://github.com/raku/roast">规范测试</a>）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">=begin table
        The Shoveller   Eddie Stevens     King Arthur's singing shovel
        Blue Raja       Geoffrey Smith    Master of cutlery
        Mr Furious      Roy Orson         Ticking time bomb of fury
        The Bowler      Carol Pinnsler    Haunted bowling ball
=end table
=table
    Constants           1
    Variables           10
    Subroutines         33
    Everything else     57

=for table
    mouse    | mice
    horse    | horses
    elephant | elephants

=table
    Animal | Legs |    Eats
    =======================
    Zebra  +   4  + Cookies
    Human  +   2  +   Pizza
    Shark  +   0  +    Fish

=table
        Superhero     | Secret          |
                      | Identity        | Superpower
        ==============|=================|================================
        The Shoveller | Eddie Stevens   | King Arthur's singing shovel

=begin table

                        Secret
        Superhero       Identity          Superpower
        =============   ===============   ===================
        The Shoveller   Eddie Stevens     King Arthur's
                                          singing shovel

        Blue Raja       Geoffrey Smith    Master of cutlery

        Mr Furious      Roy Orson         Ticking time bomb
                                          of fury

        The Bowler      Carol Pinnsler    Haunted bowling ball

=end table
=table
    X | O |
   ---+---+---
      | X | O
   ---+---+---
      |   | X

=table
    X   O
   ===========
        X   O
   ===========
            X

=begin table

foo
bar

=end table</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bad_tables">33.4. Bad tables</h3>
<div class="paragraph">
<p>以下是无效（坏）表的示例，它们应在解析期间触发未处理异常。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>同一行中不允许混合列分隔符类型：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">=begin table
r0c0 +  r0c1 | r0c3
=end table</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>同一个表中不允许使用混合的可见和空格列分隔符类型：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">=begin table
r0c0 +  r0c1 | r0c3
r1c0    r0c1   r0c3
=end table</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>不允许连续两个行内分隔符：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">=begin table
r0c0 |  r0c1
============
============
r1c0 |  r1c1
=end table</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ugly_tables">33.5. Ugly tables</h3>
<div class="paragraph">
<p>以下是有效表可能是两列的示例，但列未对齐，因此每个列都将解析为单列表。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>带 WS 列分隔符的未对齐列：</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，第二行的两个单词仅由<strong>一个</strong> WS 字符分隔，而至少需要<strong>两个</strong>相邻的 WS 字符才能定义列分隔。<strong>这是一个有效的表，但将被解析为单列表</strong>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">=begin table
r0c0    r0c1
 r1c0 r0c1
=end table</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>带有可见列分隔符的未对齐列：</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，第二行有两个单词由可见字符（<code>|</code>）分隔，但该字符不会被识别为列分隔符，因为它的两边都没有相邻的 WS 字符。虽然这是一个合法的表，但结果将不是用户的意图，因为第一行有两列，而第二行只有一列，因此它将有一个空的第二列。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-pod" data-lang="pod">=begin table
r0c0  |  r0c1
 r1c0 |r0c1
=end table</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_项">34. 项</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 中的大部分句法结构能归类为项和操作符. 这儿你能找到各种不同类型的项的概览.</p>
</div>
<div class="sect2">
<h3 id="_literals">34.1. Literals</h3>
<div class="sect3">
<h4 id="_int">34.1.1. Int</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">42
12_300_00
:16&lt;DEAD_BEEF&gt;    #十六进制</code></pre>
</div>
</div>
<div class="paragraph">
<p>Int 字面量由数字组成, 并且能在数字之间包含下划线. 使用 <code>:radix&lt;number&gt;</code> 冒号对儿形式能指定 10 进制外的其它进制.</p>
</div>
</div>
<div class="sect3">
<h4 id="_rat_有理数">34.1.2. Rat   有理数</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">12.34
1_200.345_678</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rat(有理数)字面量由一个点号分割的两部分整数组成. 注意尾部的点号是不允许的, 所以你必须写成 <code>1.0</code> 而非 <code>1.</code> ( 这个规则很重要, 因为有一个以点号开头的中缀操作符, 例如 <code>..</code> 范围操作符 ).</p>
</div>
</div>
<div class="sect3">
<h4 id="_num_浮点数">34.1.3. Num  浮点数</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">12.3e-32
3e8</code></pre>
</div>
</div>
<div class="paragraph">
<p>Num(浮点数)字面量由 Rat 或 Int 字面量后面再跟着一个字母 e 和 一个指数(可能为负)组成. <code>3e8</code> 使用 值 <code>3* 10**8</code> 构建了一个 Num.</p>
</div>
</div>
<div class="sect3">
<h4 id="_str">34.1.4. Str</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'a string''I\'m escaped!'
"I don't need to be"
"\"But I still can be,\" he said."
q|Other delimiters can be used too!|</code></pre>
</div>
</div>
<div class="paragraph">
<p>字符串字面量常常使用 <code>'</code> 或 <code>"</code> 创建, 然儿, 字符串在 Raku 中其实是一种强大的子语言.</p>
</div>
</div>
<div class="sect3">
<h4 id="_regex">34.1.5. Regex</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ match some text /
rx/slurp \s rest (.*) $/</code></pre>
</div>
</div>
<div class="paragraph">
<p>这两种会产生字面正则</p>
</div>
</div>
<div class="sect3">
<h4 id="_pair">34.1.6. Pair</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"> a =&gt; 1
'a' =&gt; 'b'
:identifier
:!identifier
:identifier&lt;value&gt;
:identifier&lt;value1 value2&gt;
:identifier($value)
:identifier['val1', 'val2']
:identifier{key1 =&gt; 'val1', key2 =&gt; 'value2'}
:$item
:@array
:%hash
:&amp;callable</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pair 对象的创建要么使用 <code>infix:«&#8658;»</code> (它会自动括起左边, 如果左边是标识符的话), 要么使用各种冒号对儿形式.  那些总是以一个冒号开头的创建形式, 冒号后面要么跟着一个标识符, 要么跟着一个已经存在的变量(不带符号的变量名作为 pair 的键, 变量的值作为 pair 的键值).</p>
</div>
<div class="paragraph">
<p>在标识符形式的冒号对儿中, 可选的值可以是任意环缀. 如果没有环缀, 那它的值就是 <code>Bool::True</code>. <code>!:identifier</code> 形式的值是 <code>Bool::False</code>.</p>
</div>
<div class="paragraph">
<p>如果冒号对儿在参数列表中, 所有的冒号对儿都会作为命名参数,   但是 <code>'quoted string' &#8658; $value</code> 除外.</p>
</div>
</div>
<div class="sect3">
<h4 id="_parcel">34.1.7. Parcel</h4>
<div class="paragraph">
<p>什么是 Parcel? &#8594; Immutable sequence of values - 不可变值的序列.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">calss Parcel is Cool does Positional { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Parcel 代表 <code>Parenthesis cell</code>, 例如, 被圆括号环绕的表达式. 除了空的 parcel 之外, 实际上是使用逗号来创建一个 Parcel.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1 + 2)  # not a Parcel
()       # empty Parcel
(1,)     # Parcel with one element
(1,3)    # Parcel with two element
1, 2, 3  # parenthesis are optional
&lt;a b c&gt;  # word-quoting
«a b c»  # also word-quoting
qw/a b c/</code></pre>
</div>
</div>
<div class="paragraph">
<p>Parcel 字面量有: 空的圆括号 (),  逗号分割的列表, 还有几种引号结构.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; say (1,2,3).WHAT
(Parcel)
&gt; say &lt;a b c&gt;.WHAT
(Parcel)
&gt; say «a b c».WHAT
(Parcel)
&gt; say (qw/a b c/).WHAT
(Parcel)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Parcels 是不可变的, 但是能包含可变容器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;
my $p = (0, $x, 2); # can assign to $p[1], but not
                    # to any other element of $p</code></pre>
</div>
</div>
<div class="paragraph">
<p>像 <code>&lt;&#8230;&#8203;&gt;</code> 这种 <code>Word-quoting</code> 结构也会创建 parcels:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;a b c&gt; # 3-element Parcel</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 flattening 列表上下文中, parcels 被展平并且会消失:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @flat = &lt;a b&gt;, &lt;c, d&gt;;
say @flat.elems;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_term">34.1.8. term *</h4>
<div class="paragraph">
<p><code>*</code> 会创建一个类型为 Whatever 的对象. 详情查看 <a href="http://doc.raku.org/type/Whatever">Whatever</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_identifier_terms">34.2. Identifier terms</h3>
<div class="paragraph">
<p>Raku中有内建的标识符项, 列出如下. 此外, 使用该语法能添加新的标识符项.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub term:&lt;fourty-two&gt; { 42 };
say fourty-two</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者作为常量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant forty-two = 42;
say fourty-two</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_self">34.2.1. self</h4>
<div class="paragraph">
<p>在方法中, self 指向方法的调用者( 例如, 方法被调用的对象). 如果把它用在没有意义的上下文中, 会抛出一个 ` X::Syntax::NoSelf` 类型的编译时错误.</p>
</div>
</div>
<div class="sect3">
<h4 id="_now">34.2.2. now</h4>
<div class="paragraph">
<p>返回一个代表当前时间的实例对象.</p>
</div>
</div>
<div class="sect3">
<h4 id="_rand">34.2.3. rand</h4>
<div class="paragraph">
<p>返回一个范围为 `0..^1`的伪随机浮点数.</p>
</div>
</div>
<div class="sect3">
<h4 id="_pi">34.2.4. pi</h4>
<div class="paragraph">
<p>返回数值 pi, 例如, 圆的周长和半径之间的比率.</p>
</div>
</div>
<div class="sect3">
<h4 id="_e">34.2.5. e</h4>
<div class="paragraph">
<p>返回欧拉数值.</p>
</div>
</div>
<div class="sect3">
<h4 id="_i">34.2.6. i</h4>
<div class="paragraph">
<p>返回复数的虚部.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_variables">34.3. Variables</h3>
<div class="paragraph">
<p>变量在变量语言文档中讨论.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_测试_2">35. 测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>测试代码是软件开发不可或缺的一部分。测试提供代码行为的自动，可重复的验证，并确保您的代码按预期工作。</p>
</div>
<div class="paragraph">
<p>在 Raku 中，<a href="https://docs.raku.org/type/Test">Test</a> 模块提供了一个测试框架，也被 Raku 的官方 spectest 套件使用。</p>
</div>
<div class="paragraph">
<p>测试函数发出符合 <a href="https://testanything.org/">Test Anything Protocol</a> 的输出。通常，它们用于 sink 上下文中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">ok check-name($meta, :$relaxed-name), "name has a hyphen rather than '::'"</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是不论测试成功与否，所有函数都会返回布尔值，如果测试失败，可以使用它来打印消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">ok check-name($meta, :$relaxed-name), "name has a hyphen rather than '::'" \
  or diag "\nTo use hyphen in name, pass :relaxed-name to meta-ok\n";</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_写测试">35.1. 写测试</h3>
<div class="paragraph">
<p>与任何 Perl 项目一样，测试位于项目基本目录的 <code>t</code> 目录下。</p>
</div>
<div class="paragraph">
<p>典型的测试文件看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.c;
use Test;      # a Standard module included with Rakudo
use lib 'lib';

plan $num-tests;

#.... tests

done-testing;  # optional with 'plan'</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们确保通过 <code>use v6.c</code> 编译指令使用 Raku，然后加载 <code>Test</code> 模块并指定库的位置。然后我们指定我们*计划*运行多少个测试（这样测试框架可以告诉我们运行的测试是否比我们预期的要多），并且在完成测试后，我们使用*完成测试*来告诉框架我们已经完成。</p>
</div>
<div class="sect3">
<h4 id="_线程安全">35.1.1. 线程安全</h4>
<div class="paragraph">
<p>请注意，<code>Test</code> 模块中的例程*不是*线程安全的。这意味着您不应该同时尝试在多个线程中使用测试例程，因为 <a href="https://testanything.org/">TAP</a> 输出可能会出现乱序并且会使解释它的程序迷惑。</p>
</div>
<div class="paragraph">
<p>目前没有计划使其线程安全。如果线程测试对您至关重要，您可能会发现一些合适的<a href="https://modules.raku.org/search/?q=Test">生态系统模块</a>，代替 <code>Test</code> 来满足您的测试需求。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_运行测试">35.2. 运行测试</h3>
<div class="paragraph">
<p>可以通过在命令行上指定测试文件名来单独运行测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ raku t/test-filename.t</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者通过 Perl 5 中的 <a href="https://perldoc.perl.org/prove.html">prove</a> 命令，其中 <code>--exec</code> 用于指定运行测试的可执行文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ prove --exec raku -r t</code></pre>
</div>
</div>
<div class="paragraph">
<p>要在第一次失败时中止测试套件，请设置 <code>PERL6_TEST_DIE_ON_FAIL</code> 环境变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">$ PERL6_TEST_DIE_ON_FAIL=1 raku t/test-filename.t</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在测试文件中使用相同的变量。在加载 <code>Test</code> 模块之前设置它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">BEGIN %*ENV&lt;PERL6_TEST_DIE_ON_FAIL&gt; = 1;
use Test;
...</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_测试计划">35.3. 测试计划</h3>
<div class="paragraph">
<p>测试计划用 <a href="https://docs.raku.org/type/Test#plan"><code>plan</code></a> 声明将要完成的计划数量，或者可能会跳过的计划数量。如果没有声明计划，<a href="https://docs.raku.org/type/Test#done-testing"><code>done-testing</code></a> 则用于声明测试结束。</p>
</div>
</div>
<div class="sect2">
<h3 id="_测试返回值">35.4. 测试返回值</h3>
<div class="paragraph">
<p><code>Test</code> 模块导出各种函数，用于检查给定表达式的返回值并生成标准化测试输出。</p>
</div>
<div class="paragraph">
<p>在实践中，表达式通常是对要进行单元测试的函数或方法的调用。<a href="https://docs.raku.org/type/Test#ok"><code>ok</code></a> 和 <a href="https://docs.raku.org/type/Test#nok"><code>nok</code></a> 将匹配 <code>True</code> 和 <code>False</code>。但是，在可能的情况下，最好使用下面的一个专门的比较测试函数，因为它们可以在比较失败时打印更有用的诊断输出。</p>
</div>
<div class="sect3">
<h4 id="_通过字符串比较">35.4.1. 通过字符串比较</h4>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Test#is"><code>is</code></a> 和 <a href="https://docs.raku.org/type/Test#isnt"><code>nok</code></a> 使用适当的运算符测试相等性，具体取决于它所处理的对象（或类）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_通过近似数字比较">35.4.2. 通过近似数字比较</h4>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Test#is-approx"><code>is-approx</code></a> 比较具有一定精度的数字，可以是绝对的或相对的。它对于精度取决于内部表示的数值非常有用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_通过结构比较">35.4.3. 通过结构比较</h4>
<div class="paragraph">
<p>也可以使用 <a href="https://docs.raku.org/type/Test#is-deeply"><code>is-deeply</code></a> 比较结构，这将检查所比较的对象的内部结构是否相同。</p>
</div>
</div>
<div class="sect3">
<h4 id="_任意比较">35.4.4. 任意比较</h4>
<div class="paragraph">
<p>您可以使用 <a href="https://docs.raku.org/type/Test#cmp-ok"><code>cmp-ok</code></a> 进行任何类型的比较，它将您想要用于比较的函数或运算符作为参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_通过对象类型比较">35.4.5. 通过对象类型比较</h4>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Test#isa-ok"><code>isa-ok</code></a> 测试对象是否属于某种类型。</p>
</div>
</div>
<div class="sect3">
<h4 id="_通过方法名比较">35.4.6. 通过方法名比较</h4>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Test#can-ok"><code>can-ok</code></a> 用于对象以检查它们是否具有该特定方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_通过角色比较">35.4.7. 通过角色比较</h4>
<div class="ulist">
<ul>
<li>
<p>does-ok($variable, $role, $description?)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Test#does-ok"><code>does-ok</code></a> 检查给定变量是否可以执行某个<a href="https://docs.raku.org/language/objects#Roles">角色</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_通过正则表达式比较">35.4.8. 通过正则表达式比较</h4>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Test#like"><code>like</code></a> 和 <a href="https://docs.raku.org/type/Test#unlike"><code>unlike</code></a> 使用正则表达式检查; 在第一种情况下，如果存在匹配则通过，在第二种情况下则不通过。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_测试模块">35.5. 测试模块</h3>
<div class="paragraph">
<p>用 <a href="https://docs.raku.org/type/Test#use-ok"><code>use-ok</code></a> 实验性地加载模块，如果加载失败则会失败。</p>
</div>
</div>
<div class="sect2">
<h3 id="_测试异常">35.6. 测试异常</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Test#dies-ok"><code>dies-ok</code></a> 和 <a href="https://docs.raku.org/type/Test#lives-ok"><code>lives-ok</code></a> 是相反的测试代码的方法; 第一个检查是它抛出异常，第二个检查它不抛出异常; <a href="https://docs.raku.org/type/Test#throws-like"><code>throws-like</code></a> 检查代码是否抛出了作为参数传递的特定异常; <a href="https://docs.raku.org/type/Test#fails-like"><code>fails-like</code></a> 同样，检查代码是否返回特定类型的 <a href="https://docs.raku.org/type/Failure">Failure</a>。<a href="https://docs.raku.org/type/Test#eval-dies-ok"><code>eval-dies-ok</code></a> 和 <a href="https://docs.raku.org/type/Test#eval-lives-ok"><code>eval-lives-ok</code></a> 在测试之前计算的字符串上工作类似。</p>
</div>
</div>
<div class="sect2">
<h3 id="_grouping_tests">35.7. Grouping tests</h3>
<div class="paragraph">
<p>只有在所有子测试都是 <code>ok</code> 的时候, 这组子测试的结果才是 <code>ok</code> 的; 他们按使用 <a href="https://docs.raku.org/type/Test#subtest"><code>subtest</code></a> 分组。</p>
</div>
</div>
<div class="sect2">
<h3 id="_跳过测试">35.8. 跳过测试</h3>
<div class="paragraph">
<p>有时测试还没准备好运行，例如某个功能可能尚未实现，在这种情况下，测试可以标记为 <a href="https://docs.raku.org/type/Test#todo"><code>todo</code></a>。或者可能是某个特定功能仅适用于特定平台的情况 - 在这种情况下，可以在其他平台上 <a href="https://docs.raku.org/type/Test#skip"><code>skip</code></a> 这个测试; <a href="https://docs.raku.org/type/Test#skip-rest"><code>skip-rest</code></a> 将跳过剩余的测试，而不是跳过作为参数给出的特定数字的测试; <a href="https://docs.raku.org/type/Test#bail-out"><code>bail-out</code></a> 将简单地带着一条消息退出测试。</p>
</div>
</div>
<div class="sect2">
<h3 id="_手动控制">35.9. 手动控制</h3>
<div class="paragraph">
<p>如果上面记录的便利功能不符合您的需要，您可以使用以下函数手动指导测试套输出; <a href="https://docs.raku.org/type/Test#pass"><code>pass</code></a> 将打印测试已经通过，<a href="https://docs.raku.org/type/Test#diag"><code>diag</code></a> 将打印（可能）信息性消息。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_要避免的陷阱">36. 要避免的陷阱</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在学习一门编程语言时，可能有熟悉另一门编程语言的背景，总有一些事情会让您感到惊讶，并且可能会耗费宝贵的调试和发现时间。</p>
</div>
<div class="paragraph">
<p>本文件旨在展示常见的误解，以避免它们。</p>
</div>
<div class="paragraph">
<p>在编写 Raku 的过程中，我们付出了巨大的努力来消除语法中的瑕疵。然而，当你消灭一个瑕疵的时候，有时另一个会突然冒出来。所以我们花了很多时间去寻找最小数量的瑕疵或者试图把它们放在它们很少被看到的地方。正因为如此，Raku 的瑕疵出现在了不同的地方，而不是来自另一种语言时所期望的那样。</p>
</div>
<div class="sect2">
<h3 id="_变量和常量">36.1. 变量和常量</h3>
<div class="sect3">
<h4 id="_常量在编译时计算">36.1.1. 常量在编译时计算</h4>
<div class="paragraph">
<p>常量是在编译时计算的，所以如果在模块中使用它们，请记住，由于模块本身的预编译，它们的值将被冻结:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># WRONG (most likely):
unit module Something::Or::Other;
constant $config-file = "config.txt".IO.slurp;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$config-file</code> 将在预编译时一次性被读入。<code>config.txt</code> 文件的更改不会在你再次启动脚本时重新加载;只有当模块被重新编译时才会重新加载。</p>
</div>
<div class="paragraph">
<p>避免使用<a href="https://docs.raku.org/language/containers">容器</a>，而倾向于将值<a href="https://docs.raku.org/language/containers#Binding">绑定</a>到提供类似于常量行为的变量上，但允许更新值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Good; file gets updated from 'config.txt' file on each script run:
unit module Something::Or::Other;
my $config-file := "config.txt".IO.slurp;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_赋值为_nil_产生不同的值_通常是_any">36.1.2. 赋值为 Nil 产生不同的值, 通常是 Any</h4>
<div class="paragraph">
<p>实际上，赋给 <code>Nil</code> 会<a href="https://docs.raku.org/type/Nil">将变量还原为其默认值</a>。所以:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 4, 8, 15, 16;
@a[2] = Nil;
say @a; # OUTPUT: «[4 8 (Any) 16]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在本例中，<code>Any</code> 是 <code>Array</code> 元素的默认值。</p>
</div>
<div class="paragraph">
<p>你可以故意指定 <code>Nil</code> 作为默认值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h is default(Nil) = a =&gt; Nil;
say %h; # OUTPUT: «Hash %h = {:a(Nil)}␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者将值绑定到 <code>Nil</code>，如果结果是你想要的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@a[3] := Nil;
say @a; # OUTPUT: «[4 8 (Any) Nil]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个陷阱可能隐藏在函数的结果中，比如匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result2 = 'abcdef' ~~ / dex /;
say "Result2 is { $result2.^name }"; # OUTPUT: «Result2 is Any␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/regexes#Literals">Match 将会是 Nil</a>如果什么也没有找到。但是，如果将 <code>Nil</code> 赋给上面的 <code>$result2</code>，则会得到其默认值，如所示为 <code>Any</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用块来插入匿名状态变量">36.1.3. 使用块来插入匿名状态变量</h4>
<div class="paragraph">
<p>程序员打算让代码计数程序被调用的次数，但是计数器没有增加:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub count-it { say "Count is {$++}" }
count-it;
count-it;

# OUTPUT:
# Count is 0
# Count is 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>当涉及到状态变量时，每当该块的块被重新进入时，声明 vars 的块就会被克隆，vars 也会被重新初始化。这让像下面这样的结构表现得恰当;每次调用子程序时，循环内部的状态变量都会被重新初始化:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub count-it {
    for ^3 {
        state $count = 0;
        say "Count is $count";
        $count++;
    }
}

count-it;
say "…and again…";
count-it;


# OUTPUT:
# Count is 0
# Count is 1
# Count is 2
# …and again…
# Count is 0
# Count is 1
# Count is 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样的布局存在于我们的 bug 程序中。双引号字符串中的 <code>{}</code> 不仅仅是执行一段代码的插值。它实际上是它自己的块，就像在上面的例子中，每次进入子例程时都会被克隆，重新初始化状态变量。为了得到正确的计数，我们需要去掉内部块，使用标量上下文分析器来插入我们的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub count-it { say "Count is $($++)" }
count-it;
count-it;

# OUTPUT:
# Count is 0
# Count is 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，也可以使用<a href="https://docs.raku.org/routine/~">连接运算符</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub count-it { say "Count is " ~ $++ }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_blocks">36.2. Blocks</h3>
<div class="sect3">
<h4 id="_提防空_block">36.2.1. 提防空 "block"</h4>
<div class="paragraph">
<p>花括号用于声明块。然而，空花括号会声明一个哈希。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ = {say 42;} # Block
$ = {;}       # Block
$ = {…}       # Block
$ = { }       # Hash</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想有效地声明一个空的块，你可以使用第二种形式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;does-nothing = {;};
say does-nothing(33); # OUTPUT: «Nil␤»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_对象">36.3. 对象</h3>
<div class="sect3">
<h4 id="_给属性赋值">36.3.1. 给属性赋值</h4>
<div class="paragraph">
<p>新手通常会这样想，因为带有访问器的属性被声明为 <code>has $.x</code>，在类里面它们可以给 <code>$.x</code> 赋值 。事实并非如此。</p>
</div>
<div class="paragraph">
<p>例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.c;
class Point {
    has $.x;
    has $.y;
    method double {
        $.x *= 2;   # WRONG
        $.y *= 2;   # WRONG
        self;
    }
}

say Point.new(x =&gt; 1, y =&gt; -2).double.x
# OUTPUT: «Cannot assign to an immutable value␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>方法 <code>double</code> 中的第一行标记为 <code># WRONG</code>，因为 <code>$.x</code> 是 <code>$( self.x )</code> 的缩写。是对只读访问器的调用。</p>
</div>
<div class="paragraph">
<p>语法 <code>has $.x</code> 是 <code>has $!x; method x() { $!x }</code> 的简写，因此实际属性称为$!将自动生成只读访问器方法。</p>
</div>
<div class="paragraph">
<p>因此，编写方法 <code>double</code> 的正确方法是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method double {
    $!x *= 2;
    $!y *= 2;
    self;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它直接作用于属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_build_防止从构造函数参数中自动初始化属性">36.3.2. BUILD 防止从构造函数参数中自动初始化属性</h4>
<div class="paragraph">
<p>在定义自己的 <code>BUILD</code> 子方法时，必须自己初始化所有属性。例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.c;
class A {
    has $.x;
    has $.y;
    submethod BUILD {
        $!y = 18;
    }
}

say A.new(x =&gt; 42).x;       # OUTPUT: «Any␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>留下 <code>$!x</code> 未初始化，因为自定义的 <code>BUILD</code> 没有初始化它。</p>
</div>
<div class="paragraph">
<p><strong>注意</strong>:考虑使用 <a href="https://docs.raku.org/language/objects#index-entry-TWEAK">TWEAK</a>。<a href="https://docs.raku.org/language/glossary#Rakudo">Rakudo</a> 自发布 2016.11 以来支持 <a href="https://docs.raku.org/language/objects#index-entry-TWEAK">TWEAK</a> 方法。</p>
</div>
<div class="paragraph">
<p>一种可能的补救方法是显式地初始化 <code>BUILD</code> 中的属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">submethod BUILD(:$x) {
    $!y = 18;
    $!x := $x;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可以简化为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">submethod BUILD(:$!x) {
    $!y = 18;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种更普遍的方法是不去管 <code>BUILD</code>，而是与 <code>BUILDALL</code> 机制挂钩:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.c;
class A {
    has $.x;
    has $.y;
    method BUILDALL(|c) {
        callsame;
        $!y = 18;
        self
    }
}

say A.new(x =&gt; 42).x;       # OUTPUT: «42␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>记住 <code>BUILDALL</code> 是一个方法，而不是子方法。这是因为在默认情况下，每个类层次结构只有一个这样的方法，而 <code>BUILD</code> 是每个类显式调用的。这就是为什么为了正确地初始化父对象，需要在 <code>BUILDALL</code> 中使用 <code>callsame</code>，而不是在 <code>BUILD</code> 中(关于该主题的更多信息请参阅<a href="https://docs.raku.org/language/objects#Object_construction">对象创建</a>)。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_空白_3">36.4. 空白</h3>
<div class="sect3">
<h4 id="_regex_中的空白不按字面匹配">36.4.1. regex 中的空白不按字面匹配</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'a b' ~~ /a b/; # OUTPUT: «False␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，regexe 中的空白被认为是一种可选的没有语义的填充，就像 Raku 语言的其他部分一样。</p>
</div>
<div class="paragraph">
<p>匹配空白的方法:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>\s</code> 匹配任何一个空白，<code>\s+</code> 匹配至少一个空白</p>
</li>
<li>
<p><code>' '</code>(引号中的空格)以匹配单个空格</p>
</li>
<li>
<p><code>\t</code>， <code>\n</code> 匹配特定空格(制表符，换行符)</p>
</li>
<li>
<p><code>\h</code>， <code>\v</code>，用于水平，垂直空白</p>
</li>
<li>
<p><code>.ws</code> 是一个内建的空白规则，它通常如你所愿</p>
</li>
<li>
<p>对于 <code>m:s/a b/</code> 或 <code>m:sigspace/a b/</code>， regex 中的空白匹配任意空格</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_模棱两可的解析">36.4.2. 模棱两可的解析</h4>
<div class="paragraph">
<p>虽然有些语言允许您删除记号之间尽可能多的空白，但是 Raku 就不那么宽容了。最重要的准则是我们不鼓励使用代码高尔夫，所以不要在空格上浪费时间(这些限制背后更严重的潜在原因是单遍解析和解析 Raku 程序的能力，而实际上不需要<a href="https://en.wikipedia.org/wiki/Backtracking">回溯</a>)。</p>
</div>
<div class="paragraph">
<p>你应留意的常见区域是:</p>
</div>
<div class="sect4">
<h5 id="_块与散列切片的歧义性">块与散列切片的歧义性</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># WRONG; trying to hash-slice a Bool:
while ($++ &gt; 5){ .say }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># RIGHT:
while ($++ &gt; 5) { .say }

# EVEN BETTER; Raku does not require parentheses there:
while $++ &gt; 5 { .say }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_化简与数组构造函数的歧义性">化简与数组构造函数的歧义性</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># WRONG; ambiguity with `[&lt;]` meta op:
my @a = [[&lt;foo&gt;],];</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># RIGHT; reductions cannot have spaces in them, so put one in:
my @a = [[ &lt;foo&gt;],];

# No ambiguity here, natural spaces between items suffice to resolve it:
my @a = [[&lt;foo bar ber&gt;],];</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_小于与单词引用关联索引">小于与单词引用/关联索引</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># WRONG; trying to index 3 associatively:
say 3&lt;5&gt;4</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># RIGHT; prefer some extra whitespace around infix operators:
say 3 &lt; 5 &gt; 4</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_捕获">36.4.3. 捕获</h4>
<div class="sect4">
<h5 id="_捕获中的容器与值">捕获中的容器与值</h5>

</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_容器">37. 容器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节介绍了处理变量和容器元素时所涉及的间接级别。解释了 Raku 中使用的容器的不同类型，以及适用于它们的操作，如赋值，绑定和展平。最后讨论了更多高级主题，如自引用数据，类型约束和自定义容器。</p>
</div>
<div class="sect2">
<h3 id="_变量是什么">37.1. 变量是什么?</h3>
<div class="paragraph">
<p>有些人喜欢说“一切都是对象”，但实际上在 Raku 中变量不是对用户暴露的对象。</p>
</div>
<div class="paragraph">
<p>当编译器遇到类似 <code>my $x</code> 的变量声明时，它会将其注册到某个内部符号表中。此内部符号表用于检测未声明的变量，并将变量的代码生成与正确的作用域联系起来。</p>
</div>
<div class="paragraph">
<p>在运行时，变量显示为*词法板中*的条目，或*简称*为*lexpad*。这是一个每个作用域的数据结构，它存储每个变量的指针。</p>
</div>
<div class="paragraph">
<p>在 <code>my $x</code> 这种情况下，变量的 <code>$x</code> 的 lexpad 条目是指向 <code>Scalar</code> 类型对象的指针，通常称为*容器*。</p>
</div>
</div>
<div class="sect2">
<h3 id="_标量容器">37.2. 标量容器</h3>
<div class="paragraph">
<p>虽然 <a href="https://docs.raku.org/type/Scalar"><code>Scalar</code></a> 类型的对象在 Raku 中无处不在，但您很少直接将它们视为对象，因为大多数操作*都是去容器化的*，这意味着它们会对 <code>Scalar</code> 容器的内容而不是容器本身起作用。</p>
</div>
<div class="paragraph">
<p>在这样的代码中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 42;
say $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>赋值 <code>$x = 42</code> 在标量容器中存储指向 <code>Int</code> 对象 42 的指针，lexpad 条目 <code>$x</code> 指向该标量容器。</p>
</div>
<div class="paragraph">
<p>赋值运算符要求左侧的容器将值存储在其右侧。究竟是什么意思取决于容器类型。因为 <code>Scalar</code> 它意味着“用新的值替换先前存储的值”。</p>
</div>
<div class="paragraph">
<p>请注意，子例程签名允许传递容器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($a is rw) {
    $a = 23;
}
my $x = 42;
f($x);
say $x;         # OUTPUT: «23»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在子例程内部，lexpad 条目 <code>$a</code> 指向 <code>$x</code> 指向子例程外部的同一容器。这就是为什么给 <code>$a</code> 赋值也修改了 <code>$x</code> 的内容。</p>
</div>
<div class="paragraph">
<p>同样，例程可以返回容器，如果它被标记为 <code>is rw</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 23;
sub f() is rw { $x };
f() = 42;
say $x;         # OUTPUT: «42»</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于显式返回，必须使用 <code>return-rw</code> 而不是 <code>return</code>。</p>
</div>
<div class="paragraph">
<p>返回容器是 <code>is rw</code> 属性访问器的工作方式。所以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    has $.attr is rw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>相当于</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    has $!attr;
    method attr() is rw { $!attr }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>标量容器对类型检查和大多数只读访问都是透明的。<code>.VAR</code> 使它们可见：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 42;
say $x.^name;       # OUTPUT: «Int»
say $x.VAR.^name;   # OUTPUT: «Scalar»</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且参数上的 <code>is rw</code> 需要存在可写的 Scalar 容器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f($x is rw) { say $x };
f 42;
CATCH { default { say .^name, ': ', .Str } };
# OUTPUT: «X::Parameter::RW: Parameter '$x' expected a writable container, but got Int value»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_callable_容器">37.3. Callable 容器</h3>
<div class="paragraph">
<p>可调用容器在 <a href="https://docs.raku.org/type/Routine">Routine</a> 调用语法和存储在容器中的对象的 <a href="https://docs.raku.org/type/Callable#method_CALL-ME">CALL-ME</a> 方法的实际调用之间提供了桥梁。声明容器时需要使用符号 <code>&amp;</code>  ，执行时必须省略 <code>Callable</code>。默认类型约束是 <a href="https://docs.raku.org/type/Callable">Callable</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;callable = -&gt; $ν { say "$ν is", $ν ~~ Int??" whole"!!" not whole" }
callable( ⅓ );
callable( 3 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>当提到存储在容器中的值时，必须提供 signal 符号。这反过来允许 <code>Routine</code> 被用作调用的<a href="https://docs.raku.org/type/Signature#Constraining_signatures_of_Callables">参数</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f() {}
my &amp;g = sub {}
sub caller(&amp;c1, &amp;c2){ c1, c2 }
caller(&amp;f, &amp;g);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_绑定">37.4. 绑定</h3>
<div class="paragraph">
<p>在赋值之后，Raku 还支持 <code>:=</code> *绑定*运算符。将值或容器绑定到变量时，会修改变量的 lexpad 条目（而不仅仅是它指向的容器）。如果你这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x := 42;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后 <code>$x</code> 的 lexpad 条目直接指向 <code>Int</code> 42. 这意味着你不能再给它赋值了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x := 42;
$x = 23;
CATCH { default { say .^name, ': ', .Str } };
# OUTPUT: «X::AdHoc: Cannot assign to an immutable value»</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以将变量绑定到其他变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 0;
my $b = 0;
$a := $b;
$b = 42;
say $a;         # OUTPUT: «42»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，在初始绑定之后，<code>$a</code> 的 lexpad 条目和 <code>$b</code> 的lexpad 条目两者都指向同一个标量容器，因此给一个变量赋值也会改变另一个变量的内容。</p>
</div>
<div class="paragraph">
<p>您之前已经看到过这种情况：它正是签名参数标记为 <code>is rw</code> 的情况。</p>
</div>
<div class="paragraph">
<p>无符号变量和带有 <code>is raw</code> trait 的参数总是绑定的（无论使用 <code>=</code> 或 <code>:=</code> ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;
my \b = $a;
b++;
say $a;         # OUTPUT: «43»

sub f($c is raw) { $c++ }
f($a);
say $a;         # OUTPUT: «44»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_scalar_容器和_listy_things">37.5. Scalar 容器和 listy things</h3>
<div class="paragraph">
<p>在 Raku 中有许多位置容器类型，其语义略有不同。最基本的是 <a href="https://docs.raku.org/type/List">List</a>; 它由逗号运算符创建。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, 2, 3).^name;    # OUTPUT: «List»</code></pre>
</div>
</div>
<div class="paragraph">
<p>列表是不可变的，这意味着您无法更改列表中的元素数。但是，如果其中一个元素恰好是标量容器，您仍然可以给它赋值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 42;
($x, 1, 2)[0] = 23;
say $x;                 # OUTPUT: «23»
($x, 1, 2)[1] = 23;     # Cannot modify an immutable value
CATCH { default { say .^name, ': ', .Str } };
# OUTPUT: «X::Assignment::RO: Cannot modify an immutable Int»</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以列表不关心它的元素是值还是容器，它们只是存储和检索给它们的任何东西。</p>
</div>
<div class="paragraph">
<p>列表也可以是惰性的; 在这种情况下，最终的元素是根据迭代器的要求生成的。</p>
</div>
<div class="paragraph">
<p><code>Array</code> 就像一个列表，除了它强制所有元素都是容器，这意味着你总是可以给元素赋值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 2, 3;
@a[0] = 42;
say @a;         # OUTPUT: «[42 2 3]»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@a</code> 实际上存储了三个标量容器。<code>@a[0]</code> 返回其中一个，赋值运算符用新的整数替换该容器中存储的整数值 <code>42</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_赋值和绑定给数组变量">37.6. 赋值和绑定给数组变量</h3>
<div class="paragraph">
<p>对标量变量和数组变量的赋值都执行相同的操作：丢弃旧值，并输入一些新值。</p>
</div>
<div class="paragraph">
<p>然而，很容易观察到它们有多么不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 42; say $x.^name;   # OUTPUT: «Int»
my @a = 42; say @a.^name;   # OUTPUT: «Array»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是因为 <code>Scalar</code> 容器类型隐藏得很好，但 <code>Array</code> 没有这样的效果。对数组变量的赋值也是强制性的，因此可以将非数组值赋给数组变量。</p>
</div>
<div class="paragraph">
<p>要将非 <code>Array</code> 放入数组变量，绑定起作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a := (1, 2, 3);
say @a.^name;               # OUTPUT: «List»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_绑定到数组元素">37.7. 绑定到数组元素</h3>
<div class="paragraph">
<p>作为一个奇怪的旁注，Raku 支持绑定到数组元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = (1, 2, 3);
@a[0] := my $x;
$x = 42;
say @a;                     # OUTPUT: «[42 2 3]»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您已经阅读并理解了之前的解释，那么现在是时候知道这是如何工作的了。毕竟，绑定到变量需要该变量的 lexpad 条目，虽然数组有一个 lexpad 条目 ，但每个数组元素都没有 lexpad 条目，因为您无法在运行时展开 lexpad。</p>
</div>
<div class="paragraph">
<p>答案是在语法级别识别绑定到数组元素，而不是为正常绑定操作发出代码，在数组上调用特殊方法（<code>BIND-KEY</code> 被调用）。此方法处理与数组元素的绑定。</p>
</div>
<div class="paragraph">
<p>请注意，虽然支持，但通常应避免直接将非容器化事物绑定到数组元素中。这样做可能会在以后使用数组时产生反直觉的结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = (1, 2, 3);
@a[0] := 42;         # This is not recommended, use assignment instead.
my $b := 42;
@a[1] := $b;         # Nor is this.
@a[2] = $b;          # ...but this is fine.
@a[1, 2] := 1, 2;    # runtime error: X::Bind::Slice
CATCH { default { say .^name, ': ', .Str } };
# OUTPUT: «X::Bind::Slice: Cannot bind to Array slice»</code></pre>
</div>
</div>
<div class="paragraph">
<p>混合列表和数组的操作通常可以防止发生这种意外情况。</p>
</div>
</div>
<div class="sect2">
<h3 id="_展平_项和容器">37.8. 展平, 项和容器</h3>
<div class="paragraph">
<p>Raku 中的 <code>%</code> 和 <code>@</code> Sigils 通常指示迭代构造的多个值，而 <code>$</code> sigil 仅指示一个值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 2, 3;
for @a { };         # 3 iterations
my $a = (1, 2, 3);
for $a { };         # 1 iteration</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@</code>-sigiled 变量不会在列表上下文中展平：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 2, 3;
my @b = @a, 4, 5;
say @b.elems;               # OUTPUT: «3»</code></pre>
</div>
</div>
<div class="paragraph">
<p>有些操作会使不在标量容器内的子列表被展平：slurpy parameters（<code>*@a</code>）和显式调用 <code>flat</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 2, 3;
say (flat @a, 4, 5).elems;  # OUTPUT: «5»

sub f(*@x) { @x.elems };
say f @a, 4, 5;             # OUTPUT: «5»</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用 <code>|</code> 创建 <a href="https://docs.raku.org/type/Slip">Slip</a>，将列表引入另一个列表中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @l := 1, 2, (3, 4, (5, 6)), [7, 8, (9, 10)];
say (|@l, 11, 12);    # OUTPUT: «(1 2 (3 4 (5 6)) [7 8 (9 10)] 11 12)»
say (flat @l, 11, 12) # OUTPUT: «(1 2 3 4 5 6 7 8 (9 10) 11 12)»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第一种情况下，<code>@l</code> 的每个元素都作为结果列表的相应元素*滑动*。另一方面，<code>flat</code> *扁平化*所有元素，包括所包含数组的元素，除了 <code>(9 10)</code>。</p>
</div>
<div class="paragraph">
<p>如上所述，标量容器可防止扁平化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f(*@x) { @x.elems };
my @a = 1, 2, 3;
say f $@a, 4, 5;            # OUTPUT: «3»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@</code> 字符也可以用作将参数强制为列表的前缀，从而删除标量容器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = (1, 2, 3);
.say for @$x;               # 3 iterations</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，*解容器*运算符 <code>&lt;&gt;</code> 更适合去除非列表项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = ^Inf .grep: *.is-prime;
say "$_ is prime" for @$x;  # WRONG! List keeps values, thus leaking memory
say "$_ is prime" for $x&lt;&gt;; # RIGHT. Simply decontainerize the Seq

my $y := ^Inf .grep: *.is-prime; # Even better; no Scalars involved at all</code></pre>
</div>
</div>
<div class="paragraph">
<p>方法通常不关心他们的调用者是否在标量中，所以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = (1, 2, 3);
$x.map(*.say);              # 3 iterations</code></pre>
</div>
</div>
<div class="paragraph">
<p>在三个元素的列表上 map，而不是在一个元素上 map。</p>
</div>
</div>
<div class="sect2">
<h3 id="_自引用数据">37.9. 自引用数据</h3>
<div class="paragraph">
<p>容器类型（包括 <code>Array</code> 和 <code>Hash</code>）允许您创建自引用结构。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a;
@a[0] = @a;
put @a.perl;
# OUTPUT: «((my @Array_75093712) = [@Array_75093712,])»</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然 Raku 不会阻止您创建和使用自引用数据，但这样做可能会导致您尝试转储数据。作为最后的手段，您可以使用 Promises 来<a href="https://docs.raku.org/type/Promise#method_in">处理</a>超时。</p>
</div>
</div>
<div class="sect2">
<h3 id="_类型约束">37.10. 类型约束</h3>
<div class="paragraph">
<p>任何容器都可以具有<a href="https://docs.raku.org/language/typesystem#Type_objects">类型对象</a>或<a href="https://docs.raku.org/language/typesystem#subset">subset</a>形式的类型约束。两者都可以放在声明符和变量名之间，也可以放在 trait <a href="https://docs.raku.org/type/Variable#trait_is_dynamic">of</a>。之后。约束是变量的属性，而不是容器的属性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset Three-letter of Str where .chars == 3;
my Three-letter $acronym = "ÞFL";</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，类型约束是（编译类型定义的）subset <code>Three-letter</code>。</p>
</div>
<div class="paragraph">
<p>变量可能没有容器，但仍然提供重新绑定和类型检查重新绑定的能力。原因是在这种情况下绑定运算符<a href="https://docs.raku.org/language/operators#infix_%3A%3D"><code>:=</code></a> 执行类型检查：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int \z = 42;
z := 100; # OK
z := "x"; # Typecheck failure</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如，当绑定到 <a href="https://docs.raku.org/type/Hash">Hash</a> 键时，情况并非如此，因为绑定随后由方法调用处理（即使语法保持不变，使用 <code>:=</code> 运算符）。</p>
</div>
<div class="paragraph">
<p><code>Scalar</code> 容器的默认类型约束是 <a href="https://docs.raku.org/type/Mu">Mu</a>。<code>.VAR.of</code> 方法提供了对容器类型约束的内省，对于 <code>@</code> 和 <code>%</code> sigiled 变量，它给出了值的约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Str $x;
say $x.VAR.of;  # OUTPUT: «(Str)»
my Num @a;
say @a.VAR.of;  # OUTPUT: «(Num)»
my Int %h;
say %h.VAR.of;  # OUTPUT: «(Int)»</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_definedness_约束">37.10.1. Definedness 约束</h4>
<div class="paragraph">
<p>容器还可以强制执行变量是定义的。在声明中放一个笑脸：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int:D $def = 3;
say $def;   # OUTPUT: «3»
$def = Int; # Typecheck failure</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还需要在声明中初始化变量，毕竟变量不能是未定义的。</p>
</div>
<div class="paragraph">
<p>也可以在使用<a href="https://docs.raku.org/language/variables#Default_defined_variables_pragma">默认定义变量 pragma</a> 的作用域中声明的所有变量中强制执行此约束。来自其他语言的人们总是会定义变量，他们希望看看。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_自定义容器">37.11. 自定义容器</h3>
<div class="paragraph">
<p>为了提供自定义容器，Raku 提供了 <code>Proxy</code> 这个类 。当从容器中存储或提取值时，需要调用两个方法。类型检查不是由容器本身完成的，并且 readonlyness 等其他限制可以被破坏。因此，返回的值必须与它绑定的变量的类型相同。我们可以使用类型捕获来处理 Raku 中的类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub lucky(::T $type) {
    my T $c-value; # closure variable
    return Proxy.new(
        FETCH =&gt; method () { $c-value },
        STORE =&gt; method (T $new-value) {
            X::OutOfRange.new(what =&gt; 'number', got =&gt; '13', range =&gt; '-∞..12, 14..∞').throw
                if $new-value == 13;
            $c-value = $new-value;
        }
    );
}

my Int $a := lucky(Int);
say $a = 12;    # OUTPUT: «12»
say $a = 'FOO'; # X::TypeCheck::Binding
say $a = 13;    # X::OutOfRange
CATCH { default { say .^name, ': ', .Str } };</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_上下文和上下文化">38. 上下文和上下文化</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在许多情况下，需要上下文来解释容器的值。在 Raku 中，我们将使用 context 将容器的值强制转换为某种类型或类，或者决定如何处理它，就像接收器(sink)上下文的情况一样。</p>
</div>
<div class="sect2">
<h3 id="_sink_上下文">38.1. Sink 上下文</h3>
<div class="paragraph">
<p><strong>Sink</strong> 相当于 <code>void</code> 上下文，也就是说，我们抛出（在接收器下面）操作的结果或块的返回值的上下文。通常，当语句不知道如何处理该值时，将在警告和错误中调用此上下文。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $sub = -&gt; $a { return $a² };
$sub; # OUTPUT: «WARNINGS:
Useless use of $sub in sink context (line 1)»</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用 <a href="https://docs.raku.org/routine/sink-all"><code>sink-all</code></a> 方法在 <a href="https://docs.raku.org/type/Iterator">Iterator</a> 上强制使用该接收器上下文。<a href="https://docs.raku.org/type/Proc">Proc</a>也可以通过 <a href="https://docs.raku.org/type/Proc#method_sink"><code>sink</code></a> 方法沉没，迫使它们引发异常而不返回任何东西。</p>
</div>
<div class="paragraph">
<p>通常，如果在 sink 上下文中进行计算，则块将发出警告; 但是，在 sink 上下文中 <a href="https://docs.raku.org/language/control#Flow%2529_gather_take">gather/take</a> 块是显式计算的，并使用 <code>take</code> 显式返回值。</p>
</div>
<div class="paragraph">
<p>在 sink 上下文中，对象将调用其 <code>sink</code> 方法（如果存在）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub foo {
    return [&lt;a b c&gt;] does role {
        method sink { say "sink called" }
    }
}
foo
# OUTPUT: sink called</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_number_上下文">38.2. Number 上下文</h3>
<div class="paragraph">
<p>这个上下文，可能除了上面的所有内容之外，都是*转换*或*解释*上下文，因为它们接收无类型或类型化的变量，并将其类型化为执行操作所需的任何内容。在某些情况下，这意味着转换（例如从 <a href="https://docs.raku.org/type/Str">Str</a> 到 <a href="https://docs.raku.org/type/Numeric">Numeric</a>）; 在其他情况下只是一种解释（<a href="https://docs.raku.org/type/IntStr">IntStr</a> 将被解释为 <a href="https://docs.raku.org/type/Int">Int</a> 或 <a href="https://docs.raku.org/type/Str">Str</a>）。</p>
</div>
<div class="paragraph">
<p>每当我们需要对变量应用数值运算时，就会调用*数字上下文*。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $not-a-string="1                 ";
my $neither-a-string="3                        ";
say $not-a-string+$neither-a-string; # OUTPUT: «4»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的代码中，只要只有几个数字而没有其他字符，字符串将在数字上下文中解释。但是，它可以具有任意数量的前导或尾随空格。</p>
</div>
<div class="paragraph">
<p>可以使用算术运算符强制数字上下文，例如 <code>+</code> 或 <code>-</code>。在该上下文中，<a href="https://docs.raku.org/routine/Numeric"><code>Numeric</code></a> 将调用该方法（如果可用），并将返回的值用作对象的数值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $t = True;
my $f = False;
say $t+$f;      # OUTPUT: «1»
say $t.Numeric; # OUTPUT: «1»
say $f.Numeric; # OUTPUT: «0»
my $list= &lt;a b c&gt;;
say True+$list; # OUTPUT: «4»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在*列表*那样的东西的情况下，数值通常等于 <code>.elems</code>; 在某些情况下，像<a href="https://docs.raku.org/routine/Numeric#%28Thread%29_method_Numeric">Thread</a> 一样，它将返回唯一的线程标识符。</p>
</div>
</div>
<div class="sect2">
<h3 id="_string_上下文">38.3. String 上下文</h3>
<div class="paragraph">
<p>在*字符串上下文中*，值可以作为字符串进行操作。例如，此上下文用于强制非字符串值，以便可以将它们打印到标准输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put $very-complicated-and-hairy-object; # OUTPUT: something meaningful</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者当智能匹配正则表达式时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">put 333444777 ~~ /(3+)/; # OUTPUT: «｢333｣ 0 =&gt; ｢333｣»</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常，将在变量上调用 <a href="https://docs.raku.org/routine/Str"><code>Str</code></a> 例程以将其上下文化; 因为这个方法是从 <a href="https://docs.raku.org/type/Mu">Mu</a> 继承的，所以它始终存在，但并不总能保证工作。在某些核心类中，它会发出警告。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/routine/<sub>"><code></sub></code></a> 是（一元）字符串上下文化器。作为运算符，它连接字符串，但作为前缀运算符，它成为字符串上下文运算符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array = [ [1,2,3], [4,5,6]];
say ~@array; # OUTPUT: «1 2 3 4 5 6»</code></pre>
</div>
</div>
<div class="paragraph">
<p>当 <code><a href="https://docs.raku.org/language/operators#Reduction_operators">~</a></code> 应用于列表时，这也将在 [<strong>reduction</strong>] 上下文中发生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [~] [ 3, 5+6i, Set(&lt;a b c&gt;), [1,2,3] ]; # OUTPUT: «35+6ic a b1 2 3»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在那个情况下, 空列表或其它容器会字符串化为一个空字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [~] [] ; # OUTPUT: «␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <a href="https://docs.raku.org/routine/<sub>#%28Operators%29_infix_</sub>"><code>~</code></a> 也作为缓冲区连接运算符，因此必须检查每个元素是否为空，因为字符串上下文中的单个空缓冲区将表现为字符串，从而产生错误。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [~] Buf.new(0x3,0x33), Buf.new(0x2,0x22);
# OUTPUT: «Buf:0x&lt;03 33 02 22&gt;»</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $non-empty = Buf.new(0x3, 0x33);
my $empty = [];
my $non-empty-also = Buf.new(0x2,0x22);
say [~] $non-empty, $empty, $non-empty-also;
# OUTPUT: «Cannot use a Buf as a string, but you called the Stringy method on it</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <code>~</code> 将字符串上下文放入此列表的第二个元素，<a href="https://docs.raku.org/routine/<sub>#%28Operators%29_infix_</sub>"><code>~</code></a> 将使用适用于字符串的第二个形式，从而产生所显示的错误。只需确保连接的所有内容都是缓冲区即可避免此问题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $non-empty = Buf.new(0x3, 0x33);
my $empty = Buf.new();
my $non-empty-also = Buf.new(0x2,0x22);
say [~] $non-empty, $empty, $non-empty-also; # OUTPUT: «Buf:0x&lt;03 33 02 22&gt;»</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常，上下文会通过调用 contextualizer 将变量强制转换为特定类型; 在 mixins 的情况下，如果混合了上下文类，它将以这种方式运行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $described-number = 1i but 'Unity in complex plane';
put $described-number; # OUTPUT: «Unity in complex plane»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>but</code> 创建一个 mixin，它使用 <code>Str</code> 方法赋予复数。<code>put</code> 将它 <code>Str</code> 上下文化为一个字符串，即它调用字符串上下文，使用上面显示的结果。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_控制语句">39. 控制语句</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_语句_2">39.1. 语句</h3>
<div class="paragraph">
<p>Raku 程序由一个或多个语句组成。简单语句由分号分隔。以下程序将打印 “Hello”，然后在下一行打印“World”。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "Hello";
say "World";</code></pre>
</div>
</div>
<div class="paragraph">
<p>在语句中出现空白的大多数地方，且在分号之前，语句可能会分成许多行。此外，多个语句可能出现在同一行。这会很尴尬，但上面的内容也可以写成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say
"Hello"; say "World";</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_块儿_2">39.2. 块儿</h3>
<div class="paragraph">
<p>与许多语言一样，Raku 使用 <code>{</code> 和 <code>}</code> 将 `blocks`括起来以将多个语句转换为单个语句。可以省略块中最后一个语句和闭合 `}`之间的分号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{ say "Hello"; say "World" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>当块单独作为一个语句存在时，它将在前一个语句完成后立即进入，并且其中的语句将被执行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1;                    # OUTPUT: «1»
{ say 2; say 3 };         # OUTPUT: «23»
say 4;                    # OUTPUT: «4»</code></pre>
</div>
</div>
<div class="paragraph">
<p>除非它作为一个语句单独存在，否则一个块只会创建一个闭包。内部的语句不会立即执行。闭包是另一个主题，如何使用它们在<a href="https://docs.raku.org/language/functions#Blocks_and_lambdas">别处</a>有解释。现在，了解块何时运行以及何时不运行是非常重要的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "We get here"; { say "then here." }; { say "not here"; 0; } or die;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，在运行第一个语句之后，第一个块独立作为第二个语句，因此我们运行里面的语句。第二个块不是单独作为一个语句，所以相反，它创建了一个 <code>Block</code> 类型的对象，但不运行它。对象实例通常被认为是 true，因此代码不会死掉，即使该块被计算为 0，它是否被执行。该示例没有说明如何处理`Block`对象，因此它会被丢弃。</p>
</div>
<div class="paragraph">
<p>下面介绍的大多数流控制结构只是告诉 Raku 何时，如何以及多少次进入像第二个块那样的块。</p>
</div>
<div class="paragraph">
<p>在我们深入这些之前，关于语法的一个重要的注意事项：如果在通常放置分号的结束大括号之后的行上没有任何内容（或者只有注释），则不需要分号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># All three of these lines can appear as a group, as is, in a program
{ 42.say }                # OUTPUT: «42»
{ 43.say }                # OUTPUT: «43»
{ 42.say }; { 43.say }    # OUTPUT: «42 43»</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;但是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{ 42.say }  { 43.say }    # Syntax error
{ 42.say; } { 43.say }    # Also a syntax error, of course</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，在换行编辑器中退格时要小心：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{ "Without semicolons line-wrapping can be a bit treacherous.".say } \
{ 43.say } # Syntax error</code></pre>
</div>
</div>
<div class="paragraph">
<p>无论如何，在大多数语言中你必须注意这一点，以防止代码意外被注释掉。为清楚起见，下面的许多示例可能包含不必要的分号。</p>
</div>
<div class="paragraph">
<p>对于任何顶级表达式，类主体的行为类似于简单的块;  这同样适用于角色和其他包，如语法（实际上是类）或模块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class C {
    say "I live";
    die "I will never live!"
};
my $c = C.new;                              │
# OUTPUT: Fails and writes «I live␤II will never live!␤I</code></pre>
</div>
</div>
<div class="paragraph">
<p>该块首先运行第一个语句，然后`die`打印第二个语句。<code>$c</code> 永远不会得到值。</p>
</div>
</div>
<div class="sect2">
<h3 id="_phasers">39.3. Phasers</h3>
<div class="paragraph">
<p>块可能有*phasers*：即将他们的执行分解成特别阶段运行阶段的特殊标记块。有关详细信息，请参阅页面<a href="https://docs.raku.org/language/phasers">phasers</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_do_2">39.4. do</h3>
<div class="paragraph">
<p>块不能是独立的语句, 运行这样一个块的最简单方法是在它前面写上一个 <code>do</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># This dies half of the time
do { say "Heads I win, tails I die."; Bool.pick } or die; say "I win.";</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，您需要在 <code>do</code> 和块之间留一个空格。</p>
</div>
<div class="paragraph">
<p>整个 <code>do {&#8230;&#8203;}</code> 计算为块儿的最终值。当需要该值时，将运行该块以计算表达式的剩余部分。所以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">False and do { 42.say };</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;不会打印 42。但是，每次计算包含它的表达式时，只会计算一次：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># This says "(..1 ..2 ..3)" not "(..1 ...2 ....3)"
my $f = "."; say do { $f ~= "." } X~ 1, 2, 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>换句话说，它遵循与其他所有东西相同的具体规则。</p>
</div>
<div class="paragraph">
<p>从技术上讲，<code>do</code> 是一个只运行一次迭代的循环。</p>
</div>
<div class="paragraph">
<p><code>do</code> 也可以用在一个裸语句上（没有花括号）但这主要是为了避免需要用圆括号扩住语句的语法，如果它是表达式中的最后一个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">3, do if 1 { 2 }  ; # OUTPUT: «(3, 2)»
3,   (if 1 { 2 }) ; # OUTPUT: «(3, 2)»
3,    if 1 { 2 }  ; # Syntax error</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_start">39.5. start</h3>
<div class="paragraph">
<p><strong>异步</strong>运行块的最简单方法是在它之前写上一个 <code>start</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">start { sleep 1; say "done" }
say "working";
# working, done</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，您需要在 <code>start</code> 和块儿之间留一个空格。在上面的示例中，<code>start</code> 块处于 sink 上下文中，因为它未赋值给变量。从版本 6.d 开始，这种块儿附加了一个异常处理程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">start { die "We're dead"; }
say "working";
sleep 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码将在版本 6.d 中打印 <code>Unhandled exception in code scheduled on thread 4 We&#8217;re dead</code>，而在版本 6.c 中等待 10 秒后它将立即退出。</p>
</div>
<div class="paragraph">
<p>如果你对块儿的结果不感兴趣, <code>start {&#8230;&#8203;}</code> 会立即返回一个可被安全忽略的 <code>Promise</code>。如果你对块儿的最终值<strong>感</strong>兴趣，你可以调用返回的 promise 上的 <code>.result</code> 方法。所以：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $promise = start { sleep 10; 42 }
# ... do other stuff
say "The result is $promise.result()";</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果块内的代码尚未完成，则 <code>.result</code> 调用将等待直到完成。</p>
</div>
<div class="paragraph">
<p><code>start</code> 也可用于裸语句（不带花括号）。这主要用于, 当在对象上调用子例程/方法是异步执行的唯一事情时。</p>
</div>
</div>
<div class="sect2">
<h3 id="_if">39.6. if</h3>
<div class="paragraph">
<p>要有条件地运行代码块，请使用 <code>if</code> 后跟条件。条件，表达式，将在 <code>if</code> 完成之前的语句之后立即进行计算。只有在条件被强转为 <code>Bool</code> 为真时, 才会计算附加到条件的块。与某些语言不同，条件不必用圆括号括起来，而块周围的 <code>{</code> 和 <code>}</code> 是必需的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 1 { "1 is true".say }  ; # says "1 is true"
if 1   "1 is true".say    ; # syntax error, missing block
if 0 { "0 is true".say }  ; # does not say anything, because 0 is false
if 42.say and 0 { 43.say }; # says "42" but does not say "43"</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有一种“语句修饰符”的形式的 <code>if</code>。在这种情况下，if 和 then 条件在您想要有条件地运行的代码之后。请注意，仍然始终首先计算条件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">43.say if 42.say and 0;     # says "42" but does not say "43"
43.say if 42.say and 1;     # says "42" and then says "43"
say "It is easier to read code when 'if's are kept on left of screen"
    if True;                # says the above, because it is true
{ 43.say } if True;         # says "43" as well</code></pre>
</div>
</div>
<div class="paragraph">
<p>语句修饰符形式最好谨慎使用。</p>
</div>
<div class="paragraph">
<p><code>if</code> 语句本身要么 <a href="https://docs.raku.org/type/Slip">slip</a>我们一个空列表，如果它不运行块，否则就会返回该块产生的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $d = 0; say (1, (if 0 { $d += 42; 2; }), 3, $d); # says "(1 3 0)"
my $c = 0; say (1, (if 1 { $c += 42; 2; }), 3, $c); # says "(1 2 3 42)"
say (1, (if 1 { 2, 2 }), 3);         # does not slip, says "(1 (2 2) 3)"</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于语句修饰符，是一样的，除非你有语句的值而不是块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, (42 if True) , 2); # says "(1 42 2)"
say (1, (42 if False), 2); # says "(1 2)"
say (1,  42 if False , 2); # says "(1 42)" because "if False, 2" is true</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>if</code> 默认不改变主题变量（<code>$_</code>）。为了访问条件表达式生成的值，您必须更强烈地要求它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = 1; if 42 { $_.say }                ; # says "1"
$_ = 1; if 42 -&gt; $_ { $_.say }          ; # says "42"
$_ = 1; if 42 -&gt; $a { $_.say;  $a.say } ; # says "1" then says "42"
$_ = 1; if 42       { $_.say; $^a.say } ; # says "1" then says "42"</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_elseelsif">39.6.1. else/elsif</h4>
<div class="paragraph">
<p>组合条件可以通过用 <code>else</code> 跟在 <code>if</code> 条件后面来产生, 以提供一个备选块，当条件表达式为假来运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 0 { say "no" } else { say "yes" }   ; # says "yes"
if 0 { say "no" } else{ say "yes" }    ; # says "yes", space is not required</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>else</code> 不能用分号将条件语句分开，但作为一个特例，换行符是可行的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 0 { say "no" }; else { say "yes" }  ; # syntax error
if 0 { say "no" }
else { say "yes" }                     ; # says "yes"</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>elsif</code>, 额外的条件可以被夹在 <code>if</code> 和 <code>else</code> 之间。只有在前面的所有条件都为假的情况下才会计算额外条件，并且只运行第一个真实条件旁边的块。如果你愿意，你可以以一个 <code>elsif</code> 而不是一个 <code>else</code> 结束。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 0 { say "no" } elsif False { say "NO" } else { say "yes" } # says "yes"
if 0 { say "no" } elsif True { say "YES" } else { say "yes" } # says "YES"

if 0 { say "no" } elsif False { say "NO" } # does not say anything

sub right { "Right!".say; True }
sub wrong { "Wrong!".say; False }
if wrong() { say "no" } elsif right() { say "yes" } else { say "maybe" }
# The above says "Wrong!" then says "Right!" then says "yes"</code></pre>
</div>
</div>
<div class="paragraph">
<p>您不能将语句修饰符形式用于 <code>else</code> 或 <code>elsif</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">42.say if 0 else { 43.say }            # syntax error</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于分号和换行, 所有相同的规则都适用，始终如一。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 0 { say 0 }; elsif 1 { say 1 }  else { say "how?" } ; # syntax error
if 0 { say 0 }  elsif 1 { say 1 }; else { say "how?" } ; # syntax error
if 0 { say 0 }  elsif 1 { say 1 }  else { say "how?" } ; # says "1"
if 0 { say 0 } elsif 1 { say 1 }
else { say "how?" }                                    ; # says "1"

if 0 { say 0 }
elsif 1 { say 1 } else { say "how?" }                  ; # says "1"

if        0 { say "no" }
elsif False { say "NO" }
else        { say "yes" }                              ; # says "yes"</code></pre>
</div>
</div>
<div class="paragraph">
<p>整个东西要么<a href="https://docs.raku.org/type/Slip">slips</a>我们一个空列表（如果没有运行块）或者返回由运行的块产生的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $d = 0; say (1,
                (if 0 { $d += 42; "two"; } elsif False { $d += 43; 2; }),
                3, $d); # says "(1 3 0)"
my $c = 0; say (1,
                (if 0 { $c += 42; "two"; } else { $c += 43; 2; }),
                3, $c); # says "(1 2 3 43)"</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在 <code>else</code> 中获取前一个表达式的值，它可以来自 <code>if</code> 或者最后一个 <code>elsif</code>,  如果存在的话：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = 1; if 0     { } else -&gt; $a { "$_ $a".say } ; # says "1 0"
$_ = 1; if False { } else -&gt; $a { "$_ $a".say } ; # says "1 False"

if False { } elsif 0 { } else -&gt; $a { $a.say }  ; # says "0"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_unless">39.6.2. unless</h4>
<div class="paragraph">
<p>当你厌倦了输入 “if not (X)” 时，你可能会用 <code>unless</code> 来反转条件语句的意义。你不能使用把 <code>else</code> 或 <code>elsif</code> 与 <code>unless</code> 用在一起。因为那最终会让人感到困惑。除了这两个不同,  <code>unless</code> 的工作方式和 <a href="https://docs.raku.org/language/control#if">if</a> 相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unless 1 { "1 is false".say }  ; # does not say anything, since 1 is true
unless 1   "1 is false".say    ; # syntax error, missing block
unless 0 { "0 is false".say }  ; # says "0 is false"
unless 42.say and 1 { 43.say } ; # says "42" but does not say "43"
43.say unless 42.say and 0;      # says "42" and then says "43"
43.say unless 42.say and 1;      # says "42" but does not say "43"

$_ = 1; unless 0 { $_.say }           ; # says "1"
$_ = 1; unless 0 -&gt; $_ { $_.say }     ; # says "0"
$_ = 1; unless False -&gt; $a { $a.say } ; # says "False"

my $c = 0; say (1, (unless 0 { $c += 42; 2; }), 3, $c); # says "(1 2 3 42)"
my $d = 0; say (1, (unless 1 { $d += 42; 2; }), 3, $d); # says "(1 3 0)"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_with_orwith_without">39.6.3. <code>with</code>, <code>orwith</code>, <code>without</code></h4>
<div class="paragraph">
<p><code>with</code> 语句像 <code>if</code> 一样，但它测试 definedness 而不是真假。此外，它在条件上主题化，很像 <code>given</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">with "abc".index("a") { .say }      # prints 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>代替 <code>elsif</code>，<code>orwith</code> 可用于链定义性测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># The below code says "Found a at 0"
my $s = "abc";
with   $s.index("a") { say "Found a at $_" }
orwith $s.index("b") { say "Found b at $_" }
orwith $s.index("c") { say "Found c at $_" }
else                 { say "Didn't find a, b or c" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以混合基于 <code>if</code> 和基于 <code>with</code> 的子句。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># This says "Yes"
if 0 { say "No" } orwith Nil { say "No" } orwith 0 { say "Yes" };</code></pre>
</div>
</div>
<div class="paragraph">
<p>与 <code>unless</code> 一样，您可以使用 <code>without</code> 检查 undefinedness，但是您可能不会添加一个 <code>else</code> 子句：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $answer = Any;
without $answer { warn "Got: {$_.perl}" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>也有 <code>with</code> 和 <code>without</code> 语句修饰符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $answer = (Any, True).roll;
say 42 with $answer;
warn "undefined answer" without $answer;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_when">39.7. when</h3>
<div class="paragraph">
<p><code>when</code> 块类似于 <code>if</code> 块，它们中的一个或两个都可以用在外部块中; 他们也都有一个“语句修饰符”形式。但是如何处理外部块中的相同代码是有区别的：当 <code>when</code> 块执行时，控制被传递到封闭块并忽略后面的语句; 但是当 <code>if</code> 块执行时，后面的语句会被执行。<a href="https://docs.raku.org/language/control#fn-1">[1]</a>以下例子应说明 <code>if</code> 或 <code>when</code> 块的默认行为，假设没有特殊出口或其他副作用的语句被包括在 <code>if</code> 或 <code>when</code> 块中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    if X {...} # if X is true in boolean context, block is executed
    # following statements are executed regardless
}
{
    when X {...} # if X is true in boolean context, block is executed
                 # and control passes to the outer block
    # following statements are NOT executed
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果以上 <code>if</code> 和 <code>when</code> 块出现在文件作用域内，则在每种情况下都会执行后面的语句。</p>
</div>
<div class="paragraph">
<p>还有另外一个功能，<code>when</code> 有而 <code>if</code> 没有的：<code>when</code> 的布尔上下文测试默认为 <code>$_ ~~</code>，而 <code>if</code> 的不是。这会影响如何在没有 <code>$_</code> (在这种情况下是 <code>Any</code>。 并且 <code>Any</code> 智能匹配`True`：<code>Any ~~ True</code> 产生 <code>True</code>)值的 <code>when</code> 块儿中使用X。请看以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    my $a = 1;
    my $b = True;
    when $a    { say 'a' }; # no output
    when so $a { say 'a' }  # a (in "so $a" 'so' coerces $a to Boolean context True
                            # which matches with Any)
    when $b    { say 'b' }; # no output (this statement won't be run)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，<code>when</code> 语句修饰符形式不影响在另一个块内部或外部执行以下语句：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "foo" when X; # if X is true statement is executed
                  # following statements are not affected</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于成功匹配将退出块，这段代码的行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = True;
my $a;
{
    $a = do when .so { "foo" }
};
say $a; # OUTPUT: «(Any)»</code></pre>
</div>
</div>
<div class="paragraph">
<p>解释了，因为在存储或处理任何值之前放弃了 <code>do</code> 块。但是，在这种情况下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = False;
my $a;
{
    $a = do when .so { "foo" }
};
say $a; # OUTPUT: «False»</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为比较是假的，所以不会放弃该块，因此 <code>$a</code> 实际上会得到一个值。</p>
</div>
</div>
<div class="sect2">
<h3 id="_for">39.8. for</h3>
<div class="paragraph">
<p><code>for</code> 循环迭代一个列表，每次迭代, 运行<a href="https://docs.raku.org/type/Block">块</a>中的语句一次，。如果块接受参数，则列表元素作为参数提供。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @foo = 1..3;
for @foo { $_.print } # prints each value contained in @foo
for @foo { .print }   # same thing, because .print implies a $_ argument
for @foo { 42.print } # prints 42 as many times as @foo has elements</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，尖括号语法或<a href="https://docs.raku.org/language/variables#The_%5E_twigil">占位符</a>可用于命名参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @foo = 1..3;
for @foo -&gt; $item { print $item }
for @foo { print $^item }            # same thing</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以声明多个参数，在这种情况下，迭代器在运行块之前根据需要从列表中获取尽可能多的元素。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @foo = 1..3;
for @foo.kv -&gt; $idx, $val { say "$idx: $val" }
my %hash = &lt;a b c&gt; Z=&gt; 1,2,3;
for %hash.kv -&gt; $key, $val { say "$key =&gt; $val" }
for 1, 1.1, 2, 2.1 { say "$^x &lt; $^y" }  # says "1 &lt; 1.1" then says "2 &lt; 2.1"</code></pre>
</div>
</div>
<div class="paragraph">
<p>尖块的参数可以具有默认值，允许处理缺少元素的列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @list = 1,2,3,4;
for @list -&gt; $a, $b = 'N/A', $c = 'N/A' {
    say "$a $b $c"
}
# OUTPUT: «1 2 3
4 N/A N/A»</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the postfix form of <code>for</code> is used a block is not required and the topic is set for the statement list.</p>
</div>
<div class="paragraph">
<p>如果使用 <code>for</code> 的后缀形式，则不需要块，并且为语句列表设置主题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say „I $_ butterflies!“ for &lt;♥ ♥ ♥&gt;;
# OUTPUT«I ♥ butterflies!
I ♥ butterflies!
I ♥ butterflies!»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>for</code> 可以在惰性列表上使用 - 只在需要时从列表中取元素，因此要逐行读取文件，您可以使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $*IN.lines -&gt; $line { .say }</code></pre>
</div>
</div>
<div class="paragraph">
<p>迭代变量总是有词法的，因此您无需使用 <code>my</code> 来为它们提供适当的作用域。此外，它们是只读别名。如果您需要它们进行读写，请使用 <code>&lt;&#8594;</code> 而不是 <code>&#8594;</code>。如果需要 <code>$_</code> 在 for 循环中进行读写，请明确执行此操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @foo = 1..3;
for @foo &lt;-&gt; $_ { $_++ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>for 循环可以生成每个附加块运行产生的值的 <code>List</code>。要捕获这些值，请将 for 循环放在括号中或将它们赋值给数组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(for 1, 2, 3 { $_ * 2 }).say;              # OUTPUT «(2 4 6)»
my @a = do for 1, 2, 3 { $_ * 2 }; @a.say; # OUTPUT «[2 4 6]»
my @b = (for 1, 2, 3 { $_ * 2 }); @b.say;  # OUTPUT: «[2 4 6]»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gathertake">39.9. gather/take</h3>
<div class="paragraph">
<p><code>gather</code> 是一个返回值的<a href="https://docs.raku.org/type/Seq">序列</a>的语句或块前缀。该值来自在 <code>gather</code> 块的动态作用域的<a href="https://docs.raku.org/type/Mu#routine_take">take</a>调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = gather {
    take 1;
    take 5;
    take 42;
}
say join ', ', @a;          # OUTPUT: «1, 5, 42»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gather/take</code> 可以懒惰地生成值，具体取决于上下文。如果要强制延迟计算 ，请使用<a href="https://docs.raku.org/type/Iterable#method_lazy">lazy</a>子例程或方法。绑定到标量或无符号的容器也会导致懒惰。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @vals = lazy gather {
    take 1;
    say "Produced a value";
    take 2;
}
say @vals[0];
say 'between consumption of two values';
say @vals[1];

# OUTPUT:
# 1
# between consumption of two values
# Produced a value
# 2</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gather/take</code> 是动态作用域的，因此您可以从 <code>gather</code> 里面的 subs 或方法内部调用 <code>take</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub weird(@elems, :$direction = 'forward') {
    my %direction = (
        forward  =&gt; sub { take $_ for @elems },
        backward =&gt; sub { take $_ for @elems.reverse },
        random   =&gt; sub { take $_ for @elems.pick(*) },
    );
    return gather %direction{$direction}();
}

say weird(&lt;a b c&gt;, :direction&lt;backward&gt; );          # OUTPUT: «(c b a)»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果值需要在调用方可变，请使用<a href="https://docs.raku.org/type/Mu#routine_take-rw">take-rw</a>。</p>
</div>
<div class="paragraph">
<p>请注意，<code>gather/take</code> 也适用于哈希。返回值仍然是一个 <code>Seq</code> 但在以下示例中对散列的赋值使其成为散列。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h = gather { take "foo" =&gt; 1; take "bar" =&gt; 2};
say %h;                                             # OUTPUT: «{bar =&gt; 2, foo =&gt; 1}»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_supplyemit">39.10. supply/emit</h3>
<div class="paragraph">
<p>将调用者发射到闭合的 <a href="https://docs.raku.org/language/concurrency#index-entry-supply_%28on-demand%29">supply</a> 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = supply {
    emit $_ for "foo", 42, .5;
}
$supply.tap: {
    say "received {.^name} ($_)";
}

# OUTPUT:
# received Str (foo)
# received Int (42)
# received Rat (0.5)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_given">39.11. given</h3>
<div class="paragraph">
<p><code>given</code> 语句是 Raku 中的 topicalizing 关键字, 类似于 C 语言中的 <code>switch</code>。换句话说，<code>given</code> 设置后面跟着的块里面的 <code>$_</code>。单独用例的关键词是 <code>when</code> 和 <code>default</code>。通常的惯用法看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $var = (Any, 21, any &lt;answer lie&gt;).pick;
given $var {
    when 21    { say $_ * 2    }
    when 'lie' { .say          }
    default    { say 'default' }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>given</code> 语句通常单独使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given 42 { .say; .Numeric; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这比下面的写法更容易理解：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{ .say; .Numeric; }(42)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_default_和_when">39.11.1. default 和 when</h4>
<div class="paragraph">
<p>当 <code>default</code> 语句后面的 sub-block 离开时, 包含 <code>default</code> 语句的块立马离开。好像跳过了块中的其余语句。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given 42 {
    "This says".say;
    $_ == 42 and ( default { "This says, too".say; 43; } );
    "This never says".say;
}
# The above block evaluates to 43</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>when</code> 语句也将这样做（但 <code>when</code> 语句修饰符将*不会*。）</p>
</div>
<div class="paragraph">
<p>此外，<code>when</code> 语句针对提供的表达式和 <code>topic</code>（<code>$_</code>）进行 智能匹配，以便在指定匹配时可以检查值，正则表达式和类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 42, 43, "foo", 44, "bar" {
    when Int { .say }
    when /:i ^Bar/ { .say }
    default  { say "Not an Int or a Bar" }
}
# OUTPUT: «42
43
Not an Int or a Bar
44
Bar»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种形式中，<code>given</code>/<code>when</code> 结构的行为很像一组 <code>if</code>/<code>elsif</code>/<code>else</code> 语句。注意 <code>when</code> 语句的顺序。下面的代码打印 <code>"Int"</code> 而不是 <code>42</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given 42 {
    when Int { say "Int" }
    when 42  { say 42 }
    default  { say "huh?" }
}
# OUTPUT: «Int»</code></pre>
</div>
</div>
<div class="paragraph">
<p>当 <code>when</code> 语句或 <code>default</code> 语句导致外部块返回时，嵌套 <code>when</code> 或 <code>default</code> 块不计为外部块，因此只要不打开新块，就可以嵌套这些语句并仍然在同一个“开关”(switch)中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given 42 {
    when Int {
      when 42  { say 42 }
      say "Int"
    }
    default  { say "huh?" }
}
# OUTPUT: «42»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>when</code> 语句可以智能匹配<a href="https://docs.raku.org/language/syntax#Signature_literals">签名</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_proceed">39.11.2. proceed</h4>

</div>
<div class="sect3">
<h4 id="_succeed">39.11.3. succeed</h4>
<div class="paragraph">
<p><code>proceed</code> 和 <code>succeed</code> 意在仅用于 <code>when</code> 或 <code>default</code> 块的内部。</p>
</div>
<div class="paragraph">
<p><code>proceed</code> 语句将立即离开 <code>when</code> 或 <code>default</code> 块, 跳过其余的语句，并在块后重新开始。这可以防止 <code>when</code> 或 <code>default</code> 退出外部块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given * {
    default {
        proceed;
        "This never says".say
    }
}
"This says".say;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这通常用于进入多个 <code>when</code> 块。<code>proceed</code> 在成功匹配后将恢复匹配，如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given 42 {
    when Int   { say "Int"; proceed }
    when 42    { say 42 }
    when 40..* { say "greater than 40" }
    default    { say "huh?" }
}
# OUTPUT: «Int»
# OUTPUT: «42»</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>when 40..*</code> 匹配未发生。为了匹配这样的情况，人们需要在 <code>when 42</code> 块中添加 <code>proceed</code>。</p>
</div>
<div class="paragraph">
<p>这不像 <code>C</code> 的 <code>switch</code> 语句，因为 <code>proceed</code> 不仅仅是进入直接跟随的块，它还会再次尝试匹配 <code>given</code> 值，请看以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given 42 {
    when Int { "Int".say; proceed }
    when 43  { 43.say }
    when 42  { 42.say }
    default  { "got change for an existential answer?".say }
}
# OUTPUT: «Int»
# OUTPUT: «42»</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;匹配 <code>Int</code>，跳过 <code>43</code>， 因为值不匹配，匹配 <code>42</code>，因为这是下一个真实的匹配，但不进入 <code>default</code> 块，因为该 <code>when 42</code> 块不包含 <code>proceed</code>。</p>
</div>
<div class="paragraph">
<p>相反，<code>succeed</code> 关键字短路执行并在此时退出整个 <code>given</code> 块。它也可能需要参数来指定块的最终值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given 42 {
    when Int {
        say "Int";
        succeed "Found";
        say "never this!";
    }
    when 42 { say 42 }
    default { say "dunno?" }
}
# OUTPUT: «Int»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您不在 <code>when</code> 或 <code>default</code> 块中，则尝试使用 <code>proceed</code> 或 <code>succeed</code> 是错误的。还要记住，<code>when</code> 语句修饰符形式不会导致任何块被丢弃，并且这样的语句中的任何 <code>succeed</code> 或 <code>proceed</code> 都应用于周围的子句，如果有的话：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given 42 {
    { say "This says" } when Int;
    "This says too".say;
    when * &gt; 41 {
       { "And this says".say; proceed } when * &gt; 41;
       "This never says".say;
    }
    "This also says".say;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_given_作为语句">39.11.4. given 作为语句</h4>
<div class="paragraph">
<p><code>given</code> 可以跟在语句后面, 以在给它所跟的语句中设置主题(topic)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say given "foo";
# OUTPUT: «foo»

printf "%s %02i.%02i.%i",
        &lt;Mo Tu We Th Fr Sa Su&gt;[.day-of-week - 1],
        .day,
        .month,
        .year
    given DateTime.now;
# OUTPUT: «Sa 03.06.2016»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_loop">39.12. loop</h3>
<div class="paragraph">
<p><code>loop</code> 语句接收 3 个参数, 分别是初始化, 条件和增量, 它们在元括号中用 <code>;</code> 分隔。初始化执行一次，任何变量声明都将溢出到周围的块中。每次迭代执行一次条件并将其强转为 <code>Bool</code>，如果为 <code>False</code> 则循环停止。每次迭代执行一次增量器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop (my $i = 0; $i &lt; 10; $i++) {
    say $i;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>无限循环不需要圆括号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop { say 'forever' }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>loop</code> 如果出现在列表中，则该语句可用于从附加块的每次运行结果中生成值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(loop ( my $i = 0; $i++ &lt; 3;) { $i * 2 }).say;               # OUTPUT: «(2 4 6)»
my @a = (loop ( my $j = 0; $j++ &lt; 3;) { $j * 2 }); @a.say;   # OUTPUT: «[2 4 6]»
my @b = do loop ( my $k = 0; $k++ &lt; 3;) { $k * 2 }; @b.say;  # same thing</code></pre>
</div>
</div>
<div class="paragraph">
<p>与 <code>for</code> 循环不同，不应该依赖于返回的值是否是惰性生成的。最好使用 <code>eager</code> 来保证循环的返回值真实运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub heads-in-a-row {
    (eager loop (; 2.rand &lt; 1;) { "heads".say })
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_while_until_3">39.13. while, until</h3>
<div class="paragraph">
<p>只要条件为真，<code>while</code> 语句就会执行该块。所以</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 1;
while $x &lt; 4 {
    print $x++;
}
print "\n";

# OUTPUT: «123»</code></pre>
</div>
</div>
<div class="paragraph">
<p>类似地，只要表达式为 false ，<code>until</code> 语句就会执行该块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 1;
until $x &gt; 3 {
    print $x++;
}
print "\n";

# OUTPUT: «123»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>while</code> 或 <code>until</code> 的条件可以用括号括起来，但关键字和条件的左括号之间必须有空格。</p>
</div>
<div class="paragraph">
<p><code>while</code> 和 <code>until</code> 两者可作为语句修饰符。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 42;
$x-- while $x &gt; 12</code></pre>
</div>
</div>
<div class="paragraph">
<p>另见 <code>repeat/while</code> 和下面的 <code>repeat/until</code>。</p>
</div>
<div class="paragraph">
<p>所有这些形式都可以以和 <code>loop</code> 相同的方式产生返回值。</p>
</div>
</div>
<div class="sect2">
<h3 id="_repeatwhile_repeatuntil">39.14. repeat/while, repeat/until</h3>
<div class="paragraph">
<p>*至少*执行*一次*该块，如果条件允许，则重复执行该块。这与 <code>while</code>/<code>until</code> 的不同之处在于，即使条件出现在前面，也会在循环结束时计算条件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = -42;
repeat {
    $x++;
} while $x &lt; 5;
$x.say; # OUTPUT: «5»

repeat {
    $x++;
} while $x &lt; 5;
$x.say; # OUTPUT: «6»

repeat while $x &lt; 10 {
    $x++;
}
$x.say; # OUTPUT: «10»

repeat while $x &lt; 10 {
    $x++;
}
$x.say; # OUTPUT: «11»

repeat {
    $x++;
} until $x &gt;= 15;
$x.say; # OUTPUT: «15»

repeat {
    $x++;
} until $x &gt;= 15;
$x.say; # OUTPUT: «16»

repeat until $x &gt;= 20 {
    $x++;
}
$x.say; # OUTPUT: «20»

repeat until $x &gt;= 20 {
    $x++;
}
$x.say; # OUTPUT: «21»</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有这些形式都可以以和 <code>loop</code> 相同的方式产生返回值。</p>
</div>
</div>
<div class="sect2">
<h3 id="_return">39.15. return</h3>
<div class="paragraph">
<p>sub <code>return</code> 将停止子程序或方法的执行，运行所有相关的<a href="https://docs.raku.org/language/phasers#Block_phasers">phasers</a>，并提供给定的返回值给调用者。默认返回值是 <code>Nil</code>。如果提供了返回值<a href="https://docs.raku.org/type/Signature#Constraining_return_types">类型约束</a>，则将检查它，除非返回值为 <code>Nil</code>。如果类型检查失败，则抛出异常 <a href="https://docs.raku.org/type/X::TypeCheck::Return">X::TypeCheck::Return</a>。如果它通过了, 则发生控制异常，可以通过 <a href="https://docs.raku.org/language/phasers#CONTROL">CONTROL</a> 捕获。</p>
</div>
<div class="paragraph">
<p>无论嵌套有多深，块中的任何 <code>return</code> 都与该块外部词法作用域中的第一个 <code>Routine</code> 绑定。请注意，包的根目录中的 <code>return</code> 将在运行时失败。块中被惰性计算（例如在 <code>map</code> 里面）的`return` 可能发现外部词法例程在块执行时消失了。几乎在任何情况下 <code>last</code> 都是更好的选择。有关如何处理和生成返回值的更多信息，请查看<a href="https://docs.raku.org/language/functions#Return_values">函数文档</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_return_rw">39.16. return-rw</h3>
<div class="paragraph">
<p>sub <code>return</code> 将返回值，而不是容器。这些是不可变的，并且在尝试可变(mutated)时会导致运行时错误。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub s(){ my $a = 41; return $a };
say ++s();
CATCH { default { say .^name, ': ', .Str } };
# OUTPUT: «X::Multi::NoMatch.new(dispatcher …</code></pre>
</div>
</div>
<div class="paragraph">
<p>要返回可变容器，请使用 <code>return-rw</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub s(){ my $a = 41; return-rw $a };
say ++s();
# OUTPUT: «42»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>return</code> 适用于关于 phasers 和控制异常的规则。</p>
</div>
</div>
<div class="sect2">
<h3 id="_fail">39.17. fail</h3>
<div class="paragraph">
<p>在执行所有相关的 <a href="https://docs.raku.org/language/phasers#Block_phasers">phasers</a>之后，离开例程并返回提供的 <a href="https://docs.raku.org/type/Exception">Exception</a> 或包含在 <a href="https://docs.raku.org/type/Failure">Failure</a> 里面的 <code>Str</code> 。如果调用者通过编译指令 <code>use fatal;</code> 激活致命异常，则抛出异常而不是作为 <code>Failure</code> 返回。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f { fail "WELP!" };
say f;
CATCH { default { say .^name, ': ', .Str } }
# OUTPUT: «X::AdHoc: WELP!»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_once">39.18. once</h3>
<div class="paragraph">
<p>带有前缀 <code>once</code> 的块即使放在循环或递归例程中，也只执行一次。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $guard = 3;
loop {
    last if $guard-- &lt;= 0;
    once { put 'once' };
    print 'many'
} # OUTPUT: «once
manymanymany»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这适用于包含代码对象的每个“克隆”，因此：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">({ once 42.say } xx 3).map: {$_(), $_()}; # says 42 thrice</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，当多个线程运行同一个块儿的同一克隆时，这<strong>不是</strong>线程安全的构造。还要记住，方法每个类只有一个克隆，而不是每个对象。</p>
</div>
</div>
<div class="sect2">
<h3 id="_quietly">39.19. quietly</h3>
<div class="paragraph">
<p><code>quietly</code> 块将抑制其生成的所有警告。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">quietly { warn 'kaput!' };
warn 'still kaput!';
# OUTPUT: «still kaput! [...]»</code></pre>
</div>
</div>
<div class="paragraph">
<p>从块内调用的任何例程生成的任何警告也将被抑制：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub told-you { warn 'hey...' };
quietly { told-you; warn 'kaput!' };
warn 'Only telling you now!'
# OUTPUT: «Only telling you now!
 [...] »</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_labels">39.20. LABELs</h3>
<div class="paragraph">
<p><code>while</code>，<code>until</code>，<code>loop</code> 和 <code>for</code> 循环都可以带一个标签，它可以用来标识 <code>next</code>，<code>last</code> 和 <code>redo</code> 。支持嵌套循环，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OUTAHERE: while True  {
    for 1,2,3 -&gt; $n {
        last OUTAHERE if $n == 2;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>标签也可以在嵌套循环中用于命名每个循环，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">OUTAHERE:
loop ( my $i = 1; True; $i++ ) {
  OUTFOR:
    for 1,2,3 -&gt; $n {
      # exits the for loop before its natural end
      last OUTFOR if $n == 2;
  }

  # exits the infinite loop
  last OUTAHERE if $i &gt;= 2;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_next">39.21. next</h3>
<div class="paragraph">
<p><code>next</code>  命令启动循环的下一次迭代。所以代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @x = 1, 2, 3, 4, 5;
for @x -&gt; $x {
    next if $x == 3;
    print $x;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>打印 “1245”。</p>
</div>
<div class="paragraph">
<p>如果存在<a href="https://docs.raku.org/language/phasers#NEXT"><code>NEXT</code> phaser</a>，它将在下一次迭代之前运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int $i = 0;
while ($i &lt; 10) {
  if ($i % 2 == 0) {
    next;
  }

  say "$i is odd.";

  NEXT {
    $i++;
  }
}
# OUTPUT: «1 is odd.
3 is odd.
5 is odd.
7 is odd.
9 is odd.»</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>从版本 6.d 开始，对于它们运行的迭代，循环中收集其最后一个语句值的 <code>next</code> 命令将返回 <code>Empty</code></strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_last">39.22. last</h3>
<div class="paragraph">
<p><code>last</code> 命令立即退出当前循环。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @x = 1, 2, 3, 4, 5;
for @x -&gt; $x {
    last if $x == 3;
    print $x;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>打印 “12”。</p>
</div>
<div class="paragraph">
<p>如果存在<a href="https://docs.raku.org/language/phasers#LAST"><code>LAST</code> phaser</a>，则在退出循环之前运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int $i = 1;
while ($i &lt; 10) {
  if ($i % 5 == 0) {
    last;
  }

  LAST {
    say "The last number was $i.";
  }
  NEXT {
    $i++;
  }
}
# OUTPUT: «The last number was 5.»</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>从版本 6.d 开始，对于它们运行的迭代，循环中收集其最后一个语句值的 <code>last</code> 命令将返回 <code>Empty</code></strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_redo">39.23. redo</h3>
<div class="paragraph">
<p><code>redo</code> 命令重新启动循环块，而不再计算条件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">loop {
    my $x = prompt("Enter a number");
    redo unless $x ~~ /\d+/;
    last;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_数据结构">40. 数据结构</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_标量结构">40.1. 标量结构</h3>
<div class="paragraph">
<p>某些类没有任何*内部*结构, 访问它们的一部分必须使用特定的方法。数字，字符串和其他一些整体类包含在该类中。他们使用 <code>$</code> sigil，虽然复杂的数据结构也可以使用它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $just-a-number = 7;
my $just-a-string = "8";</code></pre>
</div>
</div>
<div class="paragraph">
<p>有一个 <a href="https://docs.raku.org/type/Scalar">Scalar</a> 类，它在内部用于为使用 <code>$</code> sigil 声明的变量赋值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $just-a-number = 333;
say $just-a-number.VAR.^name; # OUTPUT: «Scalar␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>任何复杂数据结构都可以通过使用 <a href="https://docs.raku.org/type/Any#index-entry-%2524_%28item_contextualizer%29"><code>$</code></a> 在项上下文中*标量化*。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1, 2, 3, $(4, 5))[3].VAR.^name.say; # OUTPUT: «Scalar␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这意味着它将在它们的上下文中被视为标量。你仍然可以访问其内部结构。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1, 2, 3, $(4, 5))[3][0].say; # OUTPUT: «4␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>有一个有趣的副作用，或者可能是故意的特性，是标量化保留了复杂结构的同一性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for ^2 {
     my @list = (1, 1);
     say @list.WHICH;
} # OUTPUT: «Array|93947995146096␤Array|93947995700032␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>每次 <code>(1, 1)</code> 被分配时，创建的变量在 <code>===</code> 上的意义上是不同的; 如它所示，打印了内部指针所表示的不同值。然而</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for ^2 {
  my $list = (1, 1);
  say $list.WHICH
} # OUTPUT: «List|94674814008432␤List|94674814008432␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，<code>$list</code> 使用的是 Scalar sigil，因此将是一个 <code>Scalar</code>。任何具有相同值的标量都将完全相同，如打印指针时所显示的那样。</p>
</div>
</div>
<div class="sect2">
<h3 id="_复杂数据结构">40.2. 复杂数据结构</h3>
<div class="paragraph">
<p>根据你如何访问其第一级元素, 复杂的数据结构分为两大类: <a href="https://docs.raku.org/type/Positional">Positional</a>, 或类列表结构 <a href="https://docs.raku.org/type/Associative">Associative</a>, 或类键值对儿结构。 通常, 复杂数据结构, 包括对象, 会是两者的组合, 使对象属性变为键值对儿。而所有的对象都是 <a href="https://docs.raku.org/type/Mu">Mu</a> 的子类, 通常复杂对象是 <a href="https://docs.raku.org/type/Any">Any</a> 子类的实例。 虽然理论上可以在不这样做的情况下混合使用 “Positional” 或 “Associative”，但是大多数适用于复杂数据结构的方法都是在 “Any” 中实现的。</p>
</div>
<div class="paragraph">
<p>操纵这些复杂的数据结构是一项挑战，但 Raku 提供了一些可用于它们身上的函数：<a href="https://docs.raku.org/routine/deepmap"><code>deepmap</code></a> 和 <a href="https://docs.raku.org/routine/duckmap"><code>duckmap</code></a>。而前者会按顺序切换每个元素，无论块传递的是什么。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [[1, 2, [3, 4]],[[5, 6, [7, 8]]]].deepmap( *.elems );
# OUTPUT: «[[1 1 [1 1]] [1 1 [1 1]]]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这返回 <code>1</code> 因为它进入更深层次并将 <code>elems</code> 应用于元素，<code>deepmap</code> 可以执行更复杂的操作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [[1, 2, [3, 4]], [[5, 6, [7, 8]]]].duckmap:
   -&gt; $array where .elems == 2 { $array.elems };
# OUTPUT: «[[1 2 2] [5 6 2]]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，它深入到结构中，但如果它不满足块  (<code>1, 2</code>) 中的条件则返回元素本身，如果它满足则返回数组的元素数(每个子数组末尾的两个 <code>2</code> )。</p>
</div>
<div class="paragraph">
<p>由于 <code>deepmap</code> 和 <code>duckmap</code> 是 <code>Any</code> 方法，它们也适用于关联数组：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %( first =&gt; [1, 2], second =&gt; [3,4] ).deepmap( *.elems );
# OUTPUT: «{first =&gt; [1 1], second =&gt; [1 1]}␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>仅在这种情况下，它们将应用于作为值的每个列表或数组，而仅保留键。</p>
</div>
<div class="paragraph">
<p><code>Positional</code> 和 <code>Associative</code> 可以相互转换。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %( first =&gt; [1, 2], second =&gt; [3,4] ).list[0];
# OUTPUT: «second =&gt; [3 4]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，在这种情况下，对于 Rakudo &gt;= 2018.05，它每次运行时都会返回不同的值。哈希将被转换为键值对的列表，但保证它是无序的。你也可以从相反的方向进行操作，只要该列表具有偶数个元素(奇数将导致错误)：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &lt;a b c d&gt;.Hash # OUTPUT: «{a =&gt; b, c =&gt; d}␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &lt;a b c d&gt;.Hash.kv # OUTPUT: «(c d a b)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>每次运行时都会获得不同的值; <a href="https://docs.raku.org/type/Pair#method_kv"><code>kv</code></a> 把每个 <code>Pair</code> 转换成列表。</p>
</div>
<div class="paragraph">
<p>复杂数据结构通常还是 <a href="https://docs.raku.org/type/Iterable">Iterable</a> 的。 从中生成 <a href="https://docs.raku.org/routine/iterator">iterator</a> 将允许程序逐个访问结构的第一级：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for 'א'..'ס'; # OUTPUT: «א␤ב␤ג␤ד␤ה␤ו␤ז␤ח␤ט␤י␤ך␤כ␤ל␤ם␤מ␤ן␤נ␤ס␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>'א'..'ס'</code> 是一个 <a href="https://docs.raku.org/type/Range">Range</a>, 一个复杂数据结构,  把 <code>for</code> 放在它前面会迭代直到列表元素耗尽。你可以通过重写 <a href="https://docs.raku.org/routine/iterator">iterator</a> 方法(来自角色 <code>Iterable</code>)以在你的复杂数据结构上使用 <code>for</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class SortedArray is Array {
  method iterator() {
    self.sort.iterator
  }
};
my @thing := SortedArray.new([3,2,1,4]);
.say for @thing; # OUTPUT: «1␤2␤3␤4␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>for</code> 直接调用 <code>@thing</code> 上的 <code>iterator</code> 方法, 使其按顺序返回数组元素。更多信息请参阅 <a href="https://docs.raku.org/language/iterating">专门讨论迭代的页面</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_函数式结构">40.3. 函数式结构</h3>
<div class="paragraph">
<p>Raku 是一种函数式语言，因此，函数是一等*数据*结构。函数遵循 <a href="https://docs.raku.org/type/Callable">Callable</a> 角色，这是基础角色四重奏中的第 4 个元素。  <a href="https://docs.raku.org/type/Callable">Callable</a>  与 <code>&amp;</code> sigil 一起使用，尽管在大多数情况下，为了简单起见，它被省略了; 在 <code>Callables</code> 的情况下，总是允许消除这种 sigil。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;a-func= { (^($^þ)).Seq };
say a-func(3), a-func(7); # OUTPUT: «(0 1 2)(0 1 2 3 4 5 6)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Block">Block</a> 是最简单的可调用结构，因为 <code>Callable</code> 无法实例化。在这种情况下，我们实现了一个记录事件的块并可以检索它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $logger = -&gt; $event, $key = Nil  {
  state %store;
  if ( $event ) {
    %store{ DateTime.new( now ) } = $event;
  } else {
    %store.keys.grep( /$key/ )
  }
}
$logger( "Stuff" );
$logger( "More stuff" );
say $logger( Nil, "2018-05-28" ); # OUTPUT: «(Stuff More stuff)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Block</code> 有一个 <a href="https://docs.raku.org/type/Signature">Signature</a>，在这种情况下有两个参数，第一个是要记录的事件，第二个是要检索的事件的键。它们将以独立的方式使用，但其目的是展示<a href="https://docs.raku.org/syntax/state">状态变量</a> 的使用，该状态变量从每次调用到下一次调用时都会被保留。此状态变量封装在块中，除非使用块提供的简单 API，否则无法从外部访问：使用第二个参数调用块。前两个调用记录两个事件，示例底部的第三个调用使用第二种类型的调用来检索存储的值。 <code>Block</code> 可以被克隆：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $clogger = $logger.clone;
$clogger( "Clone stuff" );
$clogger( "More clone stuff" );
say $clogger( Nil, "2018-05-28" );
# OUTPUT: «(Clone stuff More clone stuff)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>克隆将重置状态变量; 代替克隆，我们可以创建改变 API 的 <strong>façades</strong>。例如，无需使用 <code>Nil</code> 作为第一个参数来检索特定日期的日志：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $gets-logs = $logger.assuming( Nil, * );
$logger( %(changing =&gt; "Logs") );
say $gets-logs( "2018-05-28" );
# OUTPUT: «({changing =&gt; Logs} Stuff More stuff)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Block#%28Code%29_method_assuming"><code>assuming</code></a> 包裹着一个块调用，给我们需要的参数赋值（在本例中为`Nil`）， 将参数传递给我们使用 <code>*</code> 表示的其他参数。 实际上，这对应于自然语言语句 “我们正在调用`$logger` *假设*第一个参数是 <code>Nil</code>”。 我们可以稍微改变这两个块的外观，以澄清它们实际上是在同一个块上运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $Logger = $logger.clone;
my $Logger::logs = $Logger.assuming( *, Nil );
my $Logger::get = $Logger.assuming( Nil, * );
$Logger::logs( &lt;an array&gt; );
$Logger::logs( %(key =&gt; 42) );
say $Logger::get( "2018-05-28" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管 <code>::</code> 通常用于调用类方法，但它实际上是变量名称的有效部分。在这种情况下，我们通常使用它们来简单地指示 <code>$Logger::logs</code> 和 <code>$Logger::get</code> 实际上是在调用 <code>$Logger</code>，我们已经大写使用了类似于类的外观。本教程的重点是，使用函数作为一等公民，以及使用状态变量，允许使用某些有趣的设计模式，例如这个。</p>
</div>
<div class="paragraph">
<p>作为这样的一等数据结构，可以在其他类型的数据可以使用的任何地方使用 callable。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @regex-check = ( /&lt;alnum&gt;/, /&lt;alpha&gt;/, /&lt;punct&gt;/ );
say @regex-check.map: "33af" ~~ *;
# OUTPUT: «(｢3｣␤ alnum =&gt; ｢3｣ ｢a｣␤ alpha =&gt; ｢a｣ Nil)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>正则表达式实际上是一种 callable 类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say /regex/.does( Callable ); # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的例子中，我们调用存储在数组中的正则表达式，并将它们应用于字符串字面值。</p>
</div>
<div class="paragraph">
<p>使用<a href="https://docs.raku.org/language/operators#infix_%25E2%2588%2598">函数组合运算符∘</a>组成 Callables：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $typer = -&gt; $thing { $thing.^name ~ ' → ' ~ $thing };
my $Logger::withtype = $Logger::logs ∘ $typer;
$Logger::withtype( Pair.new( 'left', 'right' ) );
$Logger::withtype( ¾ );
say $Logger::get( "2018-05-28" );
# OUTPUT: «(Pair → left right Rat → 0.75)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用上面定义的函数组合 <code>$Logger::logs</code> 和 <code>$typer</code>，获得一个记录其类型前面的对象的函数，例如，这对于过滤非常有用。 <code>$Logger::withtype</code> 实际上是一个复杂的数据结构，由两个以串行方式应用的函数组成，但每一个组合的 callables 都可以保持状态，从而创建复杂的变换 callables，其设计模式是：类似于面向对象领域中的对象组合。在每种特定情况下，你都必须选择最适合你的问题的编程风格。</p>
</div>
</div>
<div class="sect2">
<h3 id="_定义和约束数据结构">40.4. 定义和约束数据结构</h3>
<div class="paragraph">
<p>Raku 有不同的方法来定义数据结构，但也有许多方法来约束它们，以便你为每个问题域创建最合适的数据结构。例如，<a href="https://docs.raku.org/routine/but"><code>but</code></a> 将角色或值混合到值或变量中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %not-scalar := %(2 =&gt; 3) but Associative[Int, Int];
say %not-scalar.^name; # OUTPUT: «Hash+{Associative[Int, Int]}␤»
say %not-scalar.of;    # OUTPUT: «Associative[Int, Int]␤»
%not-scalar{3} = 4;
%not-scalar&lt;thing&gt; = 3;
say %not-scalar;       # OUTPUT: «{2 =&gt; 3, 3 =&gt; 4, thing =&gt; 3}␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，<code>but</code> 混合在 <code>Associative [Int，Int]</code> 角色中; 请注意我们正在使用绑定，以便变量的类型是所定义的，而不是 <code>%</code> sigil 强加的类型; 这个混合角色显示在用花括号包围的 <code>name</code> 中。 它的真实意义是什么？ 该角色包括两个方法，<code>of</code> 和 <code>keyof</code>; 通过混合角色，将调用新的 <code>of</code>（旧的 <code>of</code> 将返回 <code>Mu</code>，这是 Hashes 的默认值类型）。 然而，就是这样。 它并没有真正改变变量的类型，因为你可以看到，因为我们在接下来的几个语句中使用了任何类型的键和值。</p>
</div>
<div class="paragraph">
<p>但是，我们可以使用这种类型的 mixin 为变量提供新功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Lastable {
  method last() {
    self.sort.reverse[0]
  }
}
my %hash-plus := %( 3 =&gt; 33, 4 =&gt; 44) but Lastable;
say %hash-plus.sort[0]; # OUTPUT: «3 =&gt; 33␤»
say %hash-plus.last;    # OUTPUT: «4 =&gt; 44␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>Lastable</code> 中，我们使用通用的 <code>self</code> 变量来指代这个特定角色混合的任何对象; 在这种情况下，它将包含与其混合的哈希; 在其他情况下，它将包含其他内容（并可能以其他方式工作）。这个角色将为它混合的任何变量提供 <code>last</code> 方法，为 *常规*变量提供新的，可附加的功能。甚至可以<a href="https://docs.raku.org/language/objects#Mixins_of_roles">使用 <code>does</code> 关键字将角色添加到现有变量</a>。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/typesystem#subset">Subsets</a> 也可用于约束变量可能包含的值; 他们是 Raku 尝试<a href="https://en.wikipedia.org/wiki/Gradual_typing">渐进类型</a>; 它不是一个完整的尝试，因为子集在严格意义上不是真正的类型，但它们允许运行时类型检查。它为常规类型添加了类型检查功能，因此它有助于创建更丰富的类型系统，允许类似以下代码中显示的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset OneOver where (1/$_).Int == 1/$_;
my OneOver $one-fraction = ⅓;
say $one-fraction; # OUTPUT: «0.333333␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一方面，<code>my OneOver $ = ⅔;</code> 会导致类型检查错误。子集可以使用 <code>Whatever</code>，即 <code>*</code> 来引用参数; 但是每次将它用于不同的参数时都会实例化，所以如果我们在定义中使用它两次，我们就会得到一个错误。在这种情况下，我们使用主题单变量 <code>$_</code> 来检查实例化。子签名可以在<a href="https://docs.raku.org/language/typesystem#subset">签名</a> 中直接完成，无需声明。</p>
</div>
</div>
<div class="sect2">
<h3 id="_无限结构和惰性">40.5. 无限结构和惰性</h3>
<div class="paragraph">
<p>可以假设数据结构中包含的所有数据实际上都是*那里*。情况不一定如此：在许多情况下，出于效率原因或仅仅因为不可能，数据结构中包含的元素只有在实际需要时才会跳存。这种按需对项的计算称为 <a href="https://docs.raku.org/language/glossary#Reify">reification</a>.。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># A list containing infinite number of un-reified Fibonacci numbers:
my @fibonacci = 1, 1, * + * … ∞;

# We reify 10 of them, looking up the first 10 of them with array index:
say @fibonacci[^10]; # OUTPUT: «(1 1 2 3 5 8 13 21 34 55)␤»

# We reify 5 more: 10 we already reified on previous line, and we need to
# reify 5 more to get the 15th element at index 14. Even though we need only
# the 15th element, the original Seq still has to reify all previous elements:
say @fibonacci[14]; # OUTPUT: «987␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面我们具体化了用<a href="https://docs.raku.org/language/operators#index-entry-%25E2%2580%25A6_operators">序列运算符</a>创建了的 <a href="https://docs.raku.org/type/Seq">Seq</a>，但其他数据结构也使用这个概念。例如，未具体化的 <a href="https://docs.raku.org/type/Range">Range</a> 只是两个终点。在某些语言中，计算大范围的总和是一个漫长而耗费内存的过程，但 Raku 会立即计算出来:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say sum 1 .. 9_999_999_999_999; # OUTPUT: «49999999999995000000000000␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>为什么？ 因为*不用*具体化范围总就可以计算总和; 也就是说，不用弄清楚它包含的所有元素。这就是此功能存在的原因。你甚至可以使用 <a href="https://docs.raku.org/syntax/gather%20take"><code>gather</code> and <code>take</code></a> 按需具体化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $seq = gather {
    say "About to make 1st element"; take 1;
    say "About to make 2nd element"; take 2;
}
say "Let's reify an element!";
say $seq[0];
say "Let's reify more!";
say $seq[1];
say "Both are reified now!";
say $seq[^2];

# OUTPUT:
# Let's reify an element!
# About to make 1st element
# 1
# Let's reify more!
# About to make 2nd element
# 2
# Both are reified now!
# (1 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的输出之后，你可以看到 <code>gather</code> 里面的 <code>print</code> 语句只有当我们在查找元素时确定各个元素时才会执行。另请注意，这些元素只被修改了一次。当我们在示例的最后一行再次打印相同的元素时，就不再打印 <code>gather</code> 内的消息。这是因为该构造使用了来自 <a href="https://docs.raku.org/type/Seq">Seq</a> 缓存的已经确定的元素。</p>
</div>
<div class="paragraph">
<p>请注意，上面我们将 <code>gather</code> 赋值给 <a href="https://docs.raku.org/type/Scalar">Scalar</a> 容器( <code>$</code> sigil)，而不是 <a href="https://docs.raku.org/type/Positional">Positional</a> (<code>@</code> sigil)。原因是 <code>@</code>-sigiled 变量*主要是eager*。这意味着他们*大部分时间*立即*明确分配给他们的东西*。他们唯一没有这样做的时候知道这些项是 <a href="https://docs.raku.org/routine/is-lazy"><code>is-lazy</code></a>，就像我们用无穷大生成序列作为终点一样。如果我们将 <code>gather</code> 赋值给 <code>@</code>-variable，那里面的 <code>say</code> 语句就会被立即打印出来。</p>
</div>
<div class="paragraph">
<p>完全具体化列表的另一种方法是在其上调用 <a href="https://docs.raku.org/routine/elems"><code>.elems</code></a>。这就是为什么检查列表是否包含任何项最好使用 <code>.Bool</code> 方法的原因(或者只使用 <code>if @array { … }</code>)，因为你不需要明确*所有*元素以找出它们中的任何一个。</p>
</div>
<div class="paragraph">
<p>有些时候你*确实*需要在做某事之前完全具体化列表。例如，<a href="https://docs.raku.org/type/IO::Handle#method_lines"><code>IO::Handle.lines</code></a> 返回 <a href="https://docs.raku.org/type/Seq">Seq</a>。以下代码包含错误; 记住具体化，试着发现它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = "/tmp/bar".IO.open;
my $lines = $fh.lines;
close $fh;
say $lines[0];</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们打开 <a href="https://docs.raku.org/type/IO::Handle">filehandle</a>，然后分配 <a href="https://docs.raku.org/type/IO::Handle#method_lines"><code>.lines</code></a>  给  <a href="https://docs.raku.org/type/Scalar">Scalar</a> 变量，因此返回的 <a href="https://docs.raku.org/type/Seq">Seq</a> 不会立刻被具体化。 然后我们 <a href="https://docs.raku.org/routine/close"><code>close</code></a> 文件句柄，并尝试从 <code>$lines</code> 打印一个元素。</p>
</div>
<div class="paragraph">
<p>代码中的错误是在我们在最后一行具体化 <code>$lines</code> <a href="https://docs.raku.org/type/Seq">Seq</a>  时，我们*已经关闭*文件句柄。 当 <code>Seq</code> 的 iterator 试图生成我们请求的项时，会导致尝试从关闭的句柄中读取的错误。 因此，要修复错误，我们可以在关闭句柄之前分配给 <code>@</code>-sigiled 变量或在 <code>$lines</code> 上调用 <a href="https://docs.raku.org/routine/elems"><code>.elems</code></a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = "/tmp/bar".IO.open;
my @lines = $fh.lines;
close $fh;
say @lines[0]; # no problem!</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们也可以使用带有具体化副作用的任何函数，如上面提到的 <code>.elems</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = "/tmp/bar".IO.open;
my $lines = $fh.lines;
say "Read $lines.elems() lines"; # reifying before closing handle
close $fh;
say $lines[0]; # no problem!</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <a href="https://docs.raku.org/routine/eager">eager</a> 也将具体化整个序列：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = "/tmp/bar".IO.open;
my $lines = eager $fh.lines; # Uses eager for reification.
close $fh;
say $lines[0];</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_内省">40.6. 内省</h3>
<div class="paragraph">
<p>允许 <a href="https://en.wikipedia.org/wiki/Type_introspection">内省</a>(如Raku)的语言具有附加到类型系统的功能，允许开发人员访问容器和值元数据。该元数据可以在程序中使用，以根据它们的值执行不同的动作。从名称中可以明显看出，元数据是通过元类从值或容器中提取的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $any-object = "random object";
my $metadata = $any-object.HOW;
say $metadata.^mro;                   # OUTPUT: «((ClassHOW) (Any) (Mu))␤»
say $metadata.can( $metadata, "uc" ); # OUTPUT: «(uc uc)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用第一个 <code>say</code>，我们展示了元模型类的类层次结构，在本例中是 <a href="https://docs.raku.org/type/Metamodel::ClassHOW">Metamodel::ClassHOW</a>。它直接继承自 <code>Any</code>，这意味着可以使用任何方法; 它还混合了几个角色，可以为您提供有关类结构和功能的信息。但是那个特定类的方法之一是 <a href="https://docs.raku.org/type/Metamodel::ClassHOW#method_can"><code>can</code></a>，我们可以用它来查找对象是否可以使用 <code>uc</code>(大写)方法，它显然可以。但是，在某些其他情况下，当角色直接被混合到变量中时，它可能不那么明显。例如，在上面定义的的 <a href="https://docs.raku.org/language/structures#Defining_and_constraining_data_structures"><code>%hash-plus</code></a> 情况下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %hash-plus.^can("last"); # OUTPUT: «(last)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，我们使用 <code>HOW.method</code> 的*语法塘* <code>^method</code> 来检查你的数据结构是否响应该方法; 输出显示匹配方法的名称，证明我们可以使用它。</p>
</div>
<div class="paragraph">
<p>另请参见<a href="https://rakuadvent.wordpress.com/2015/12/19/day-19-introspection/">关于类内省的文章</a>，了解如何访问类属性和方法，并使用它来为该类生成测试数据;这篇<a href="https://rakuadvent.wordpress.com/2010/12/22/day-22-the-meta-object-protocol/">Advent Calendar 文章详细描述了元对象协议</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_日期和时间函数">41. 日期和时间函数</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 包括几个处理时态信息的类：<a href="https://docs.raku.org/type/Date">Date</a>，<a href="https://docs.raku.org/type/DateTime">DateTime</a>，<a href="https://docs.raku.org/type/Instant">Instant</a> 和 <a href="https://docs.raku.org/type/Duration">Duration</a>。前三个是 dateish，所以它们混合了 <a href="https://docs.raku.org/type/Dateish">Dateish</a> 角色，它定义了处理日期的类应该采用的所有方法和属性。它还包括以 <a href="https://docs.raku.org/type/X::Temporal">X::Temporal</a> 为根的异常的类层次结构。</p>
</div>
<div class="paragraph">
<p>我们将尝试在下一个（稍微扩展）的示例中说明这些类，这个示例可用于处理目录中的所有文件（默认情况下）。在目录中使用特定扩展名（默认为 <code>.p6</code>），根据他们的年龄对其进行排序，并计算每月创建的文件数量，以及在几个月的范围内表示的特定时期内修改的文件数量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6;

sub MAIN( $path = ".", $extension = "p6" ) {
    my DateTime $right = DateTime.now;
    my %metadata;
    my %files-month;
    my %files-period;
    for dir($path).grep( / \.$extension $/ ) -&gt; $file {
        CATCH {
            when X::Temporal { say "Date-related problem", .payload }
            when X::IO { say "File-related problem", .payload }
            default { .payload.say }
        }
        my Instant $modified = $file.modified;
        my Instant $accessed = $file.accessed;
        my Duration $duration = $accessed - $modified;
        my $age = $right - DateTime($accessed);
        my $time-of-day = $file.changed.DateTime.hh-mm-ss but Dateish;
        my $file-changed-date =  $file.changed.Date;
        %metadata{$file} = %( modified =&gt; $modified,
                              accessed =&gt; $accessed,
                              age =&gt; $age,
                              difference =&gt; $duration,
                              changed-tod =&gt; $time-of-day,
                              changed-date =&gt; $file-changed-date);
        %files-month{$file-changed-date.month}++;
        given $file-changed-date {
            when Date.new("2018-01-01")..^Date.new("2018-04-01") { %files-period&lt;pre-grant&gt;++}
            when Date.new("2018-04-01")..Date.new("2018-05-31") { %files-period&lt;grant&gt;++}
            default { %files-period&lt;post-grant&gt;++};
        }
    }

    %metadata.sort( { $^a.value&lt;age&gt; &lt;=&gt; $^b.value&lt;age&gt; } ).map: {
        say $^x.key, ", ",
        $^x.value&lt;accessed modified age difference changed-tod changed-date&gt;.join(", ");
    };
    %files-month.keys.sort.map: {
        say "Month $^x → %files-month{$^x}"
    };

    %files-period.keys.map: {
        say "Period $^x → %files-period{$^x}"
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>第 6 行使用 <code>DateTime</code> 来包含现在返回的当前日期和时间。</p>
</div>
<div class="paragraph">
<p>CATCH phaser 在第 11 到 15 行中声明。其主要任务是区分与 <code>DateTime</code> 相关的异常和其他类型。这种异常可能来自<a href="https://docs.raku.org/type/X::Temporal::InvalidFormat">无效格式</a>或<a href="https://docs.raku.org/type/X::DateTime::TimezoneClash">时区冲突</a>。除非文件属性有些损坏，否则两者都是不可能的，但无论如何它们都应该被捕获并与其他类型的异常分开。</p>
</div>
<div class="paragraph">
<p>我们使用第 16-17 行中的 <a href="https://docs.raku.org/type/Instant">Instants</a> 来表示访问和修改文件的时刻。 Instant 是以原子秒为单位测量的，是对时间事件的非常低级别的描述;但是，第 18 行中声明的持续时间代表两个不同实例之间转换的时间，我们将使用它来表示年龄。</p>
</div>
<div class="paragraph">
<p>对于某些变量，我们可能有兴趣用一些日期特征来处理它们。 <code>$time-of-day</code> 包含文件更改日期的时间; <code>changed</code> 将返回一个 Instant，但它将转换为日期（<code>Instant</code> 而不是 <code>Dateish</code>），然后从中提取时间。 <code>$time-of-day</code> 将有 <code>«Str+{Dateish}␤»</code> 类型。</p>
</div>
<div class="paragraph">
<p>我们将使用此变量中的日期来查找文件更改的时间段。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Date.new("2018-01-01")..^Date.new("2018-04-01")</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建一个日期<a href="https://docs.raku.org/type/Range">范围</a>，<code>$file-changed-date</code> 与它进行智能匹配。日期可以这样使用;在这种情况下，它会创建一个排除其最后一个元素的 <code>Range</code>。</p>
</div>
<div class="paragraph">
<p>这个变量也用于计算修改文件的一年中的月份。<a href="https://docs.raku.org/type/Date">日期</a> 显然是 Dateish，然后有月份方法从中提取该属性。</p>
</div>
<div class="paragraph">
<p>可以比较持续时间对象。这用于</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">     %metadata.sort({
         $^a.value&lt;age&gt; &lt;=&gt; $^b.value&lt;age&gt;
     });</code></pre>
</div>
</div>
<div class="paragraph">
<p>按年龄对文件进行排序。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_枚举">42. 枚举</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 中，枚举(<code>enum</code>)类型比其他语言复杂得多，详细信息可在<a href="https://docs.raku.org/language/typesystem#enum">此处</a>的类型描述中找到。</p>
</div>
<div class="paragraph">
<p>这个简短的文档将给出一个简单的使用示例，就像在 C 语言中一样。</p>
</div>
<div class="paragraph">
<p>假设我们有一个需要写入各种目录的程序; 我们想要一个函数，给定一个目录名，测试它（1）是否存在（2）它是否可以被该程序的用户写入; 这意味着从用户的角度来看有三种可能的状态：要么你可以写（<code>CanWrite</code>），要么没有目录（<code>NoDir</code>）或者目录存在，但你不能写（<code>NoWrite</code>）。 测试结果将决定程序接下来要采取的操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum DirStat &lt;CanWrite NoDir NoWrite&gt;;
sub check-dir-status($dir --&gt; DirStat) {
    if $dir.IO.d {
        # dir exists, can the program user write to it?
        my $f = "$dir/.tmp";
        spurt $f, "some text";
        CATCH {
            # unable to write for some reason
            return NoWrite;
        }
        # if we get here we must have successfully written to the dir
        unlink $f;
        return CanWrite;
    }
    # if we get here the dir must not exist
    return NoDir;
}

# test each of three directories by a non-root user
my $dirs =
    '/tmp',  # normally writable by any user
    '/',     # writable only by root
    '~/tmp'; # a non-existent dir in the user's home dir
for $dirs -&gt; $dir {
    my $stat = check-dir-status $dir;
    say "status of dir '$dir': $stat";
    if $stat ~~ CanWrite {
        say "  user can write to dir: $dir";
    }
}
# output
#   status of dir '/tmp': CanWrite
#     user can write to dir: /tmp
#   status of dir '/': NoWrite
#   status of dir '~/tmp': NoDir</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_异常">43. 异常</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 中的异常是保存有关错误信息的对象。例如，错误可能是意外接收数据或网络连接不再可用，或者丢失文件。异常对象存储的信息是关于错误条件的人类可读消息，错误引发的回溯等等。</p>
</div>
<div class="paragraph">
<p>所有内置异常都继承自 <a href="https://docs.raku.org/type/Exception">Exception</a>，它提供了一些基本行为，包括回溯的存储和回溯打印机的接口。</p>
</div>
<div class="sect2">
<h3 id="_热异常">43.1. 热异常</h3>
<div class="paragraph">
<p>通过调用带有描述错误的 <a href="https://docs.raku.org/routine/die">die</a> 函数来使用热异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">die "oops, something went wrong";
# RESULT: «oops, something went wrong in block &lt;unit&gt; at my-script.p6:1␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>值得注意的是，<code>die</code> 会将错误消息打印到标准错误 <code>$*ERR</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_类型化的异常">43.2. 类型化的异常</h3>
<div class="paragraph">
<p>类型化异常提供有关异常对象中存储的错误的更多信息。</p>
</div>
<div class="paragraph">
<p>例如，如果在对象上执行 <code>.zombie copy</code> 时，所需的路径 <code>foo/bar</code> 变得不可用，则可以引发 <a href="https://docs.raku.org/type/X::IO::DoesNotExist">X::IO::DoesNotExist</a>异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">die X::IO::DoesNotExist.new(:path("foo/bar"), :trying("zombie copy"))

# RESULT: «Failed to find 'foo/bar' while trying to do '.zombie copy'
#          in block &lt;unit&gt; at my-script.p6:1»</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意对象如何为回溯提供有关出错的信息。代码的用户现在可以更轻松地找到并纠正问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="_捕获异常">43.3. 捕获异常</h3>
<div class="paragraph">
<p>通过提供 <code>CATCH</code> 块可以处理异常情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">die X::IO::DoesNotExist.new(:path("foo/bar"), :trying("zombie copy"));

CATCH {
    when X::IO { $*ERR.say: "some kind of IO exception was caught!" }
}

# OUTPUT: «some kind of IO exception was caught!»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们说如果发生 <code>X::IO</code> 类型的任何异常，那么消息 <code>some kind of IO exception was caught!</code> 会被发送到 <strong>stderr</strong>，这是 <code>$*ERR.say</code> 所做的事情，在那一刻构成标准错误设备的任何内容上显示，默认情况下可能是控制台。</p>
</div>
<div class="paragraph">
<p><code>CATCH</code> 块使用类似于 <code>given/when</code> 对选项进行智能匹配的智能匹配，因此可以捕获和处理 <code>when</code> 块内的各种类别的异常。</p>
</div>
<div class="paragraph">
<p>要处理所有异常，请使用 <code>default</code> 语句。此示例打印出与普通回溯打印机几乎相同的信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">CATCH {
     default {
         $*ERR.say: .message;
         for .backtrace.reverse {
             next if .file.starts-with('SETTING::');
             next unless .subname;
             $*ERR.say: "  in block {.subname} at {.file} line {.line}";
         }
     }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，匹配目标是一个角色。要允许用户定义的异常以相同的方式匹配，它们必须实现给定的角色。仅存在于同一名称空间中看起来相似但在 <code>CATCH</code> 块中不匹配。</p>
</div>
</div>
<div class="sect2">
<h3 id="_异常处理程序和闭合块">43.4. 异常处理程序和闭合块</h3>
<div class="paragraph">
<p>在 <code>CATCH</code> 处理异常之后，退出包围 <code>CATCH</code> 块的块。</p>
</div>
<div class="paragraph">
<p>换句话说，即使成功处理异常，封闭块中的其余代码也永远不会被执行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">die "something went wrong ...";

CATCH {
    # will definitely catch all the exception
    default { .Str.say; }
}

say "This won't be said.";   # but this line will be never reached since
                             # the enclosing block will be exited immediately
# OUTPUT: «something went wrong ...␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>和这个作对比：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">CATCH {

  CATCH {
      default { .Str.say; }
  }

  die "something went wrong ...";

}

say "Hi! I am at the outer block!"; # OUTPUT: «Hi! I am at the outer block!␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关如何将控制权返回到发生异常的位置，请参阅<a href="https://docs.raku.org/language/exceptions#Resuming_of_exceptions">恢复异常</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_try_块">43.5. try 块</h3>
<div class="paragraph">
<p><code>try</code> 块是一个普通块，它隐式打开 <a href="https://docs.raku.org/language/pragmas#index-entry-fatal-fatal">use fatal pragma</a> 编译指示，并包含一个隐式 <code>CATCH</code> 块，它会删除异常，这意味着您可以使用它来包含它们。 捕获的异常存储在$中！ 变量，它包含 <code>Exception</code> 类型的值。</p>
</div>
<div class="paragraph">
<p>像这样的普通块将会失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    my $x = +"a";
    say $x.^name;
} # OUTPUT: «Failure␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，<code>try</code> 块将包含异常并将其放入 <code>$!</code> 变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">try {
    my $x = +"a";
    say $x.^name;
}

if $! { say "Something failed!" } # OUTPUT: «Something failed!␤»
say $!.^name;                     # OUTPUT: «X::Str::Numeric␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这样的块中抛出的任何异常都将被 <code>CATCH</code> 块捕获，无论是隐式的还是由用户提供的。在后一种情况下，任何未处理的异常都将被重新抛出。如果您选择不处理异常，则它们将被块包含。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">try {
    die "Tough luck";
    say "Not gonna happen";
}

try {
    fail "FUBAR";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的两个 <code>try</code> 块中，异常将包含在块中，但不会运行 <code>say</code> 语句。但我们可以处理它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class E is Exception { method message() { "Just stop already!" } }

try {
    E.new.throw; # this will be local

    say "This won't be said.";
}

say "I'm alive!";

try {
    CATCH {
        when X::AdHoc { .Str.say; .resume }
    }

    die "No, I expect you to DIE Mr. Bond!";

    say "I'm immortal.";

    E.new.throw;

    say "No, you don't!";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">I'm alive!
No, I expect you to DIE Mr. Bond!
I'm immortal.
Just stop already!
  in block &lt;unit&gt; at exception.p6 line 21</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <code>CATCH</code> 块只处理 <code>die</code> 语句抛出的 <code>X::AdHoc</code> 异常，而不处理 <code>E</code> 异常。 如果没有 <code>CATCH</code> 块，所有异常都将被包含和删除，如上所示。 恢复将在异常抛出后立即恢复执行; 在这种情况下，在 <code>die</code> 语句中。 有关详细信息，请参阅有关<a href="https://docs.raku.org/language/exceptions#Resuming_of_exceptions">恢复异常</a>的部分。</p>
</div>
<div class="paragraph">
<p><code>try-block</code> 是一个普通的块，因此将其最后一个语句视为自身的返回值。 因此，我们可以将其用作右手边。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say try { +"99999" } // "oh no"; # OUTPUT: «99999␤»
say try { +"hello" } // "oh no"; # OUTPUT: «oh no␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过返回表达式的返回值来间接尝试块支持 <code>else</code> 块，如果抛出异常，则返回 <a href="https://docs.raku.org/type/Nil">Nil</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">with try +"♥" {
    say "this is my number: $_"
} else {
    say "not my number!"
}
# OUTPUT: «not my number!␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>try</code> 也可以和语句一块用而非块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say try "some-filename.txt".IO.slurp // "sane default";
# OUTPUT: «sane default␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>try</code> 实际导致的是，通过 <code>use fatal pragma</code>，立即抛出在其范围内发生的异常，但通过这样做，从抛出异常的点调用 <code>CATCH</code> 块，定义其范围。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $error-code = "333";
sub bad-sub {
    die "Something bad happened";
}
try {
    my $error-code = "111";
    bad-sub;

    CATCH {
        default {
            say "Error $error-code ", .^name, ': ',.Str
        }
    }
}
# OUTPUT: «Error 111 X::AdHoc: Something bad happened␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_抛出异常">43.6. 抛出异常</h3>
<div class="paragraph">
<p>可以使用Exception对象的 <code>.throw</code> 方法显式抛出异常。</p>
</div>
<div class="paragraph">
<p>此示例抛出 AdHoc 异常，捕获它并允许代码通过调用 <code>.resume</code> 方法从异常点继续。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    X::AdHoc.new(:payload&lt;foo&gt;).throw;
    "OHAI".say;
    CATCH {
        when X::AdHoc { .resume }
    }
}

"OBAI".say;

# OUTPUT: «OHAI␤OBAI␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 CATCH 块与抛出的异常不匹配，则将异常的有效负载传递给回溯打印机制。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    X::AdHoc.new(:payload&lt;foo&gt;).throw;
    "OHAI".say;
    CATCH {  }
}

"OBAI".say;

# RESULT: «foo
#          in block &lt;unit&gt; at my-script.p6:1»</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一个示例不会从异常点恢复。相反，它会在封闭块之后继续，因为捕获了异常，然后在 CATC H块之后控制继续。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    X::AdHoc.new(:payload&lt;foo&gt;).throw;
    "OHAI".say;
    CATCH {
        when X::AdHoc { }
    }
}

"OBAI".say;

# OUTPUT: «OBAI␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>throw 可以被视为 die 的方法形式，只是在这种特殊情况下，例程的 sub 和 method 形式有不同的名称。</p>
</div>
</div>
<div class="sect2">
<h3 id="_异常恢复">43.7. 异常恢复</h3>
<div class="paragraph">
<p>异常会中断控制流并将其从抛出语句后的语句中转移出去。可以恢复用户处理的任何异常，并且控制流将继续使用抛出异常的语句之后的语句。为此，请在异常对象上调用方法 <code>.resume</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">CATCH { when X::AdHoc { .resume } }         # this is step 2

die "We leave control after this.";         # this is step 1

say "We have continued with control flow."; # this is step 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>恢复将在导致异常的语句之后和最里面的调用帧中发生</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub bad-sub {
    die "Something bad happened";
    return "not returning";
}

{
    my $return = bad-sub;
    say "Returned $return";
    CATCH {
        default {
            say "Error ", .^name, ': ',.Str;
            $return = '0';
            .resume;

        }
    }
}
# OUTPUT:
# Error X::AdHoc: Something bad happened
# Returned not returning</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，<code>.resume</code> 将转到在 <code>die</code> 语句之后发生的 <code>return</code> 语句。请注意，<code>$return</code> 的赋值不起作用，因为 CATCH 语句发生在对 <code>bad-sub</code> 的调用中，<code>bad-sub</code> 通过 <code>return</code> 语句为其分配不返回的值。</p>
</div>
</div>
<div class="sect2">
<h3 id="_未捕获的异常">43.8. 未捕获的异常</h3>
<div class="paragraph">
<p>如果抛出异常但未捕获异常，则会导致程序以非零状态代码退出，并且通常会将消息输出到程序的标准错误流。通过在异常对象上调用 <code>gist</code> 方法获得此消息。您可以使用它来抑制打印回溯的默认行为以及消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class X::WithoutLineNumber is X::AdHoc {
    multi method gist(X::WithoutLineNumber:D:) {
            $.payload
    }
}
die X::WithoutLineNumber.new(payload =&gt; "message")

# prints "message\n" to $*ERR and exits, no backtrace</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_控制异常">43.9. 控制异常</h3>
<div class="paragraph">
<p>某些关键字会引发控制异常，并自动或由相应的 phaser 处理。任何未处理的控制异常都将转换为正常异常。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{ return; CATCH { default { $*ERR.say: .^name, ': ',.Str } } }

# OUTPUT: «X::ControlFlow::Return: Attempt to return outside of any Routine␤»
# was CX::Return</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_raku_中的函数_2">44. Raku 中的函数</h2>
<div class="sectionbody">
<div class="paragraph">
<p>例程（Routines）是 Raku 中代码重用的最小手段。它们有几种形式，最明显的是属于类和角色并与对象相关联的方法，还有函数, 也叫做子例程或短子程序，它们独立于对象而存在。</p>
</div>
<div class="paragraph">
<p>子例程默认是词法（<code>my</code>）作用域的，对它们的调用通常在编译时解析。</p>
</div>
<div class="paragraph">
<p>子例程可以具有<a href="https://docs.raku.org/type/Signature">签名</a>，也称为*参数列表*，其指定签名期望的参数（如果有的话）。 它可以指定（或保持打开）参数的数量和类型，以及返回值。</p>
</div>
<div class="paragraph">
<p>子例程的内省通过<a href="https://docs.raku.org/type/Routine">例程</a>提供。</p>
</div>
<div class="sect2">
<h3 id="_定义创建使用_函数">44.1. 定义/创建/使用 函数</h3>
<div class="sect3">
<h4 id="_子例程">44.1.1. 子例程</h4>
<div class="paragraph">
<p>创建子例程的基本方法是使用 <code>sub</code> 声明符，后跟可选<a href="https://docs.raku.org/language/syntax#Identifiers">标识符</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub my-func { say "Look ma, no args!" }
my-func;</code></pre>
</div>
</div>
<div class="paragraph">
<p>sub 声明符返回可以存储在任何容器中的 <a href="https://docs.raku.org/type/Sub">Sub</a> 类型的值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;c = sub { say "Look ma, no name!" }
c;     # OUTPUT: «Look ma, no name!␤»

my Any:D $f = sub { say 'Still nameless...' }
$f();  # OUTPUT: «Still nameless...␤»

my Code \a = sub { say ‚raw containers don't implement postcircumfix:&lt;( )&gt;‘ };
a.();  # OUTPUT: «raw containers don't implement postcircumfix:&lt;( )&gt;␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>sub</code> 声明符将在编译时在当前作用域内声明一个新名称。因此，任何间接性都必须在编译时解析：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant aname = 'foo';
sub ::(aname) { say 'oi‽' };
foo;</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦将宏添加到 Raku 中，这将变得更有用。</p>
</div>
<div class="paragraph">
<p>为了使子程序接受参数，<a href="https://docs.raku.org/type/Signature">签名</a>被放置在子例程名称和它的函数主体之间，在括号中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub exclaim ($phrase) {
    say $phrase ~ "!!!!"
}
exclaim "Howdy, World";</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认地, 子例程是<a href="https://docs.raku.org/syntax/my">词法作用域</a>的。即 <code>sub foo {&#8230;&#8203;}</code> 和 <code>my sub foo {&#8230;&#8203;}</code> 是相同的并且只被定义在当前作用域中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub escape($str) {
    # Puts a slash before non-alphanumeric characters
    S:g[&lt;-alpha -digit&gt;] = "\\$/" given $str
}

say escape 'foo#bar?'; # foo\#bar\?

{
    sub escape($str) {
        # Writes each non-alphanumeric character in its hexadecimal escape
        S:g[&lt;-alpha -digit&gt;] = "\\x[{ $/.ord.base(16) }]" given $str
    }

    say escape 'foo#bar?' # foo\x[23]bar\x[3F]
}

# Back to original escape function
say escape 'foo#bar?'; # foo\#bar\?</code></pre>
</div>
</div>
<div class="paragraph">
<p>子例程不必命名; 这种情况下, 它们被叫做匿名的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say sub ($a, $b) { $a ** 2 + $b ** 2 }(3, 4) # 25</code></pre>
</div>
</div>
<div class="paragraph">
<p>但在这种情况下，通常希望使用更简洁的块语法。可以就地调用子例程和块，如上例所示。</p>
</div>
</div>
<div class="sect3">
<h4 id="_blocks_和_lambdas">44.1.2. Blocks 和 Lambdas</h4>
<div class="paragraph">
<p>每当你看到像</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{ $_ + 42 }, -&gt; $a, $b { $a ** $b }</code></pre>
</div>
</div>
<div class="paragraph">
<p>或</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{ $^text.indent($:spaces) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>那么这是<a href="https://docs.raku.org/type/Block">块</a>语法。 它在每个 <code>if</code>，<code>for</code>，<code>while</code> 等关键字之后使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 1, 2, 3, 4 -&gt; $a, $b {
    say $a ~ $b;
}
# OUTPUT: «12␤34␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>它们也可以作为匿名代码块自己使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say { $^a ** 2 + $^b ** 2}(3, 4) # 25</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关块语法的详细信息，请参阅<a href="https://docs.raku.org/type/Block">块</a>类型的文档。</p>
</div>
</div>
<div class="sect3">
<h4 id="_签名">44.1.3. 签名</h4>
<div class="paragraph">
<p>函数接受的参数在其签名中有描述。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub format(Str $s) { ... }
-&gt; $a, $b { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关签名的语法和使用的详细信息，请参阅 <a href="https://docs.raku.org/type/Signature">Signature</a> 类的文档。</p>
</div>
</div>
<div class="sect3">
<h4 id="_自动签名">44.1.4. 自动签名</h4>
<div class="paragraph">
<p>如果没有提供签名，但在函数体中使用了两个自动变量 <code>@<em></code> 或 <code>%</em></code> 中的任何一个，则将生成带有 <code><strong>@<em></code> 或 <code></strong>%</em></code> 的签名。 两个自动变量可以同时使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub s { say @_, %_ };
dd &amp;s.signature # OUTPUT«:(*@_, *%_)␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_参数">44.1.5. 参数</h4>
<div class="paragraph">
<p>参数以逗号分隔列表的形式提供。 要消除嵌套调用的歧义, 可以使用圆括号或副词形式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f(&amp;c){ c() * 2 }; # call the function reference c with empty parameter list
sub g($p){ $p - 2 };
say(g(42)); # nest call to g in call to say
f: { say g(666) }; # call f with a block</code></pre>
</div>
</div>
<div class="paragraph">
<p>当调用函数时，位置参数应该以与函数签名相同的顺序提供。 命名参数可以以任何顺序提供，但是最好将命名参数放在位置参数之后。 在函数调用的参数列表中，支持一些特殊的语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f(|c){};
f :named(35);     # 具名参数(in "adverb" form.)
f named =&gt; 35;    # 也是具名参数.
f :35named;       # 使用缩写的副词形式的具名参数
f 'named' =&gt; 35;  # 不是具名参数, 而是一个 Pair 位置参数
my \c = &lt;a b c&gt;.Capture;
f |c;             # Merge the contents of Capture $c as if they were supplied</code></pre>
</div>
</div>
<div class="paragraph">
<p>传递给函数的参数在概念上首先被收集在 Capture 容器中。 关于这些容器的语法和使用的细节可以在 <a href="https://docs.raku.org/type/Capture">Capture</a> 类的文档中找到。</p>
</div>
<div class="paragraph">
<p>当使用命名参数时，请注意，正常的 List "pair-chaining" 允许在命名参数之间跳过逗号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f(|c){};
f :dest&lt;/tmp/foo&gt; :src&lt;/tmp/bar&gt; :lines(512);
f :32x :50y :110z;   # This flavor of "adverb" works, too
f :a:b:c;            # The spaces are also optional.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_返回值">44.1.6. 返回值</h4>
<div class="paragraph">
<p>任何块或例程将把它的最后一个表达式作为返回值提供给调用者。如果 <a href="https://docs.raku.org/language/control#return">return</a> 或 <a href="https://docs.raku.org/language/control#return-rw">return-rw</a> 被调用，它们的参数（如果有的话）将成为返回值。 默认返回值为 <a href="https://docs.raku.org/type/Nil">Nil</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub a { 42 };
sub b { say a };
b;
# OUTPUT«42␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>多个返回值作为列表或通过创建<a href="https://docs.raku.org/type/Capture">捕获</a>返回。 解构可以用于解开多个返回值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub a { 42, 'answer' };
put a.perl;
# OUTPUT«(42, "answer")␤»

my ($n, $s) = a;
put [$s, $n];
# OUTPUT«answer 42␤»

sub b { &lt;a b c&gt;.Capture };
put b.perl;
# OUTPUT«\("a", "b", "c")␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_返回类型约束">44.1.7. 返回类型约束</h4>
<div class="paragraph">
<p>Raku 有很多方式来指定函数的返回类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub foo(--&gt; Int)      {}; say &amp;foo.returns; # (Int)
sub foo() returns Int {}; say &amp;foo.returns; # (Int)
sub foo() of Int      {}; say &amp;foo.returns; # (Int)
my Int sub foo()      {}; say &amp;foo.returns; # (Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>尝试返回另外一种类型的值会引起编译错误。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub foo() returns Int { "a"; }; foo; # Type check fails</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，<code>Nil</code> 和 <code>Failure</code> 是免于返回类型约束，并且可以从任何子例程返回，而不管其约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub foo() returns Int { fail   }; foo; # Failure returned
sub bar() returns Int { return }; bar; # Nil returned</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_多重分派">44.1.8. 多重分派</h4>
<div class="paragraph">
<p>Raku 允许你使用同一个名字但是不同签名写出几个子例程。当子例程按名字被调用时, 运行时环境决定哪一个子例程是最佳匹配, 然后调用那个候选者。你使用 <code>multi</code> 声明符来声明每个候选者。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi congratulate($name) {
    say "祝你生日快乐, $name";
}

multi congratulate($name, $age) {
    say "祝 $age 岁生日快乐, $name";
}

congratulate 'Camelia'; # 祝你生日快乐, Camelia
congratulate 'Rakudo', 15; # 祝你 15 岁生日快乐, Rakudo</code></pre>
</div>
</div>
<div class="paragraph">
<p>分发/分派(dispatch) 可以发生在参数的数量(元数)上, 但是也能发生在类型上:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi as-json(Bool $d) { $d ?? 'true' !! 'false' }
multi as-json(Real $d) { ~$d }
multi as-json(@d)      { sprintf '[%s]', @d.map(&amp;as-json).join(', ') }

say as-json([True, 42]); # [true, 42]</code></pre>
</div>
</div>
<div class="paragraph">
<p>不带任何指定例程类型的 <code>multi</code> 总是默认为 <code>sub</code>, 但是你也可以把 <code>multi</code> 用在方法(methods)上。那些候选者全都是对象的 <code>multi</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Congrats {
    multi method congratulate($reason, $name) {
        say "Hooray for your $reason, $name";
    }
}

role BirthdayCongrats {
    multi method congratulate('birthday', $name) {
        say "Happy birthday, $name";
    }
    multi method congratulate('birthday', $name, $age) {
        say "Happy {$age}th birthday, $name";
    }
}

my $congrats = Congrats.new does BirthdayCongrats;

$congrats.congratulate('升职', 'Cindy');   #-&gt; 恭喜你升职,Cindy
$congrats.congratulate('birthday', 'Bob'); #-&gt; Happy birthday, Bob</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_proto">44.1.9. proto</h4>
<div class="paragraph">
<p><a href="https://docs.raku.org/syntax/proto">proto</a> 从形式上声明了 <code>multi</code> 候选者之间的`共性`。 proto 充当作能检查但不会修改参数的包装器。看看这个基本的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto congratulate(Str $reason, Str $name, |) {*}
multi congratulate($reason, $name) {
   say "Hooray for your $reason, $name";
}
multi congratulate($reason, $name, Int $rank) {
   say "Hooray for your $reason, $name -- you got rank $rank!";
}

congratulate('being a cool number', 'Fred');     # OK
congratulate('being a cool number', 'Fred', 42); # OK
congratulate('being a cool number', 42);         # Proto match error</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有的 <code>multi congratulate</code> 都会遵守基本的签名, 这个签名中有两个字符串参数, 后面跟着可选的更多的参数。 <code>|</code> 是一个未命名的 <code>Capture</code> 形参, 它允许 <code>multi</code> 接收额外的参数。第三个 congratulate 调用在编译时失败, 因为第一行的 proto 的签名变成了所有三个 multi congratulate 的共同签名, 而 42 不匹配 <code>Str</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &amp;congratulate.signature #-&gt; (Str $reason, Str $name, | is raw)</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以给 <code>proto</code> 一个函数体, 并且在你想执行 dispatch 的地方放上一个 <code>{*}</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># attempts to notify someone -- returns False if unsuccessful
proto notify(Str $user,Str $msg) {
   my \hour = DateTime.now.hour;
   if hour &gt; 8 or hour &lt; 22 {
      return {*};
   } else {
      # we can't notify someone when they might be sleeping
      return False;
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>{*}</code> 总是分派给带有参数的候选者。默认参数和类型强制转换会起作用单不会传递。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto mistake-proto(Str() $str, Int $number = 42) {*}
multi mistake-proto($str,$number) { say $str.WHAT }
mistake-proto(7,42);   #-&gt; (Int) -- coercions not passed on
mistake-proto('test'); #!&gt; fails -- defaults not passed on</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_约定和惯用法">44.2. 约定和惯用法</h3>
<div class="paragraph">
<p>虽然上面描述的调度系统提供了很多灵活性，但是存在一些大多数内部函数以及许多模块中的函数将遵循的约定。 这些将产生一致的外观和感觉。</p>
</div>
<div class="sect3">
<h4 id="_吞噬约定">44.2.1. 吞噬约定</h4>
<div class="paragraph">
<p>也许最重要的是处理 slurpy 列表参数的方式。 大多数时候，函数不会自动展平吞噬(slurpy)列表。 罕见的例外是在列表的列表上没有合理行为的那些函数（例如chrs），或者与已建立的习语有冲突的函数，例如 <a href="https://docs.raku.org/routine/pop">pop</a> 是 <a href="https://docs.raku.org/routine/push">push</a> 的逆操作。</p>
</div>
<div class="paragraph">
<p>如果你想匹配这个外观和感觉，任何可迭代(Iterable)参数必须使用 <code>**@slurpy</code> 逐个元素地打开，有两个细微差别：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.raku.org/language/containers#Scalar_containers">Scalar 容器</a>内的 Iterable 不计数。</p>
</li>
<li>
<p>在顶层使用 <code>,</code> 创建的列表只能计数为一个 Iterable。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这可以通过使用带有 <code>+</code> 或 <code>+@</code> 而不是 `**`的 slurpy 来实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub grab(+@a) { "grab $_".say for @a }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这非常接近于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub grab(**@a) { "grab $_".say for @a }
multi sub grab(\a) {
    a ~~ Iterable and a.VAR !~~ Scalar ?? nextwith(|a) !! nextwith(a,)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这导致以下行为，称为「单参数规则」，并且理解什么时间调用 slurpy 函数很重要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grab(1, 2);      # grab 1 grab 2
grab((1, 2));    # grab 1 grab 2
grab($(1, 2));   # grab 1 2
grab((1, 2), 3); # grab 1 2 grab 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>这也使得用户请求的展平感觉一致，无论有没有子列表，或很多</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grab(flat (1, 2), (3, 4));   # grab 1 grab 2 grab 3 grab 4
grab(flat $(1, 2), $(3, 4)); # grab 1 2 grab 3 4
grab(flat (1, 2));           # grab 1 grab 2
grab(flat $(1, 2));          # grab 1 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>值得注意的是，在这些情况下将绑定和无符号变量混合在一起需要一点技巧，因为在绑定期间没有使用 Scalar 中间人。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = (1, 2);  # Normal assignment, equivalent to $(1, 2)
grab($a);       # grab 1 2
my $b := (1, 2); # Binding, $b links directly to a bare (1, 2)
grab($b);       # grab 1 grab 2
my \c = (1, 2);  # Sigilless variables always bind, even with '='
grab(c);        # grab 1 grab 2</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_函数是一等对象">44.3. 函数是一等对象</h3>
<div class="paragraph">
<p>函数和其他代码对象可以作为值传递，就像任何其他对象一样。</p>
</div>
<div class="paragraph">
<p>有几种方法来获取代码对象。 您可以在声明点将其赋值给变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $square = sub (Numeric $x) { $x * $x }
# and then use it:
say $square(6);    # 36</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，您可以通过使用它前面的 <code>&amp;</code> 来引用现有的具名函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub square($x) { $x * $x };

# get hold of a reference to the function:
my $func = &amp;square</code></pre>
</div>
</div>
<div class="paragraph">
<p>这对于高阶函数非常有用，即，将其他函数作为输入的函数。 一个简单高阶函数的是 <a href="https://docs.raku.org/type/List#routine_map">map</a>，它对每个输入元素应用一个函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub square($x) { $x * $x };
my @squared = map &amp;square,  1..5;
say join ', ', @squared;        # 1, 4, 9, 16, 25</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_中缀形式">44.3.1. 中缀形式</h4>
<div class="paragraph">
<p>要像中缀运算符那样调用具有2个参数的子例程，请使用由 <code>[</code> 和 <code>]</code> 包围的子例程引用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub plus { $^a + $^b };
say 21 [&amp;plus] 21;
# OUTPUT«42␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_闭包">44.3.2. 闭包</h4>
<div class="paragraph">
<p>Raku 中的所有代码对象都是闭包，这意味着它们可以从外部作用域引用词法变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub generate-sub($x) {
    my $y = 2 * $x;
    return sub { say $y };
    #      ^^^^^^^^^^^^^^  inner sub, uses $y
}
my $generated = generate-sub(21);
$generated(); # 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 <code>$y</code> 是 <code>generate-sub</code> 中的词法变量，并且返回的内部子例程使用了 <code>$y</code>。 到内部 sub 被调用时，<code>generate-sub</code> 已经退出。 然而内部 sub 仍然可以使用 <code>$y</code>，因为它关闭了变量。</p>
</div>
<div class="paragraph">
<p>一个不太明显但有用的闭包示例是使用 <a href="https://docs.raku.org/type/List#routine_map">map</a> 乘以数字列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $multiply-by = 5;
say join ', ', map { $_ * $multiply-by }, 1..5;     # 5, 10, 15, 20, 25</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里传递给 <code>map</code> 的块从外部作用域引用变量 <code>$multiply-by</code>，使块成为闭包。</p>
</div>
<div class="paragraph">
<p>没有闭包的语言不能轻易地提供高阶函数，它们像 map 一样易于使用和强大。</p>
</div>
</div>
<div class="sect3">
<h4 id="_routines">44.3.3. Routines</h4>
<div class="paragraph">
<p>例程是遵守 <a href="https://docs.raku.org/type/Routine">Routine</a> 类型的代码对象，最明显的是 <a href="https://docs.raku.org/type/Sub">Sub</a>，<a href="https://docs.raku.org/type/Method">方法</a>，<a href="https://docs.raku.org/type/Regex">正则表达式</a>和<a href="https://docs.raku.org/type/Submethod">Submethod</a>。</p>
</div>
<div class="paragraph">
<p>他们携带除了<a href="https://docs.raku.org/type/Block">块</a>提供的额外的功能：他们可以作为 <a href="https://docs.raku.org/language/functions#Multi-dispatch">multis</a>，你可以<a href="https://docs.raku.org/type/Routine#method_wrap">包装</a>它们，并使用 <code>return</code> 提前退出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $keywords = set &lt;if for unless while&gt;;

sub has-keyword(*@words) {
    for @words -&gt; $word {
        return True if $word (elem) $keywords;
    }
    False;
}

say has-keyword 'not', 'one', 'here';       # False
say has-keyword 'but', 'here', 'for';       # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 <code>return</code> 不仅仅是将离开它所调用的块的内部，而是离开整个程序。 一般来说，块对于 <code>return</code> 是透明的，它们附加到外部程序。</p>
</div>
<div class="paragraph">
<p>例程(Routines)可以是内联的，并且因此为包装设置了障碍。 使用指令 <code>use soft;</code> 以防止内联在运行时允许包装。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub testee(Int $i, Str $s){
    rand.Rat * $i ~ $s;
}

sub wrap-to-debug(&amp;c){
    say "wrapping {&amp;c.name} with arguments {&amp;c.signature.perl}";
    &amp;c.wrap: sub (|args){
        note "calling {&amp;c.name} with {args.gist}";
        my \ret-val := callwith(|args);
        note "returned from {&amp;c.name} with return value {ret-val.perl}";
        ret-val
    }
}

my $testee-handler = wrap-to-debug(&amp;testee);
# OUTPUT«wrapping testee with arguments :(Int $i, Str $s)»

say testee(10, "ten");
# OUTPUT«calling testee with \(10, "ten")␤returned from testee with return value "6.151190ten"␤6.151190ten»
&amp;testee.unwrap($testee-handler);
say testee(10, "ten");
# OUTPUT«6.151190ten␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_定义操作符">44.3.4. 定义操作符</h4>
<div class="paragraph">
<p>操作符只是有趣名字的子例程。 有趣的名称由类别名称（中缀，前缀，后缀，环缀，后环缀）组成，后面跟着冒号，以及一个或多个操作符名称的列表（在环缀和后环缀的情况下为两个组件）。</p>
</div>
<div class="paragraph">
<p>这既适用于向现有运算符添加多个候选项，也适用于定义新的运算符。 在后一种情况下，新子例程的定义自动将新运算符安装到 语法(grammar)中，但仅在当前词法作用域中。 通过 <code>use</code> 或 <code>import</code> 导入操作符也使其可用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># adding a multi candidate to an existing operator:
multi infix:&lt;+&gt;(Int $x, "same") { 2 * $x };
say 21 + "same";            # 42

# 定义一个新的操作符
sub postfix:&lt;!&gt;(Int $x where { $x &gt;= 0 }) { [*] 1..$x };
say 6!;                     # 720</code></pre>
</div>
</div>
<div class="paragraph">
<p>运算符声明变得尽快可用，因此您甚至可以递归到刚才定义的运算符中，如果您真的想要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub postfix:&lt;!&gt;(Int $x where { $x &gt;= 0 }) {
    $x == 0 ?? 1 !! $x * ($x - 1)!
}
say 6!;                     # 720</code></pre>
</div>
</div>
<div class="paragraph">
<p>环缀和后环缀操作符由两个分隔符组成，一个开口和一个闭合。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub circumfix:&lt;START END&gt;(*@elems) {
    "start", @elems, "end"
}

say START 'a', 'b', 'c' END;        # start a b c end</code></pre>
</div>
</div>
<div class="paragraph">
<p>后环缀也接收这个术语，在它们被作为参数解析之后：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub postcircumfix:&lt;!! !!&gt;($left, $inside) {
    "$left -&gt; ( $inside )"
}
say 42!! 1 !!;      # 42 -&gt; ( 1 )</code></pre>
</div>
</div>
<div class="paragraph">
<p>块可以直接赋值给操作符名。 使用变量声明符，并在操作符名前加上一个 <code>&amp;</code> 符号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;infix:&lt;ieq&gt; = -&gt; |l { [eq] l&gt;&gt;.fc };
say "abc" ieq "Abc";
# OUTPUT«True␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_优先级">44.3.5. 优先级</h4>
<div class="paragraph">
<p>Raku 中的运算符优先级相对于现有运算符指定。 <code>is tighter</code>、<code>is equiv</code> 和 <code>is looser</code> 特性能使用一个运算符提供，新的运算符优先级与之相关。 可以应用更多的特征。</p>
</div>
<div class="paragraph">
<p>例如，<code>infix:&lt;*&gt;</code> 的优先级高于 <code>infix:&lt;+&gt;</code>，并且在中间挤压一个像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;!!&gt;($a, $b) is tighter(&amp;infix:&lt;+&gt;) {
    2 * ($a + $b)
}

say 1 + 2 * 3 !! 4;     # 21</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 <code>1 + 2 * 3 !! 4</code> 被解析为 <code>1 + ((2 * 3) !! 4)</code>，因为新的 <code>!!</code> 运算符的优先级在 <code>+</code> 和 <code>*</code> 之间。</p>
</div>
<div class="paragraph">
<p>可以使用下面的代码实现相同的效果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;!!&gt;($a,$b) is looser(&amp;infix:&lt;x&gt;) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>要将新运算符置于与现有运算符相同的优先级别上，请使用 <code>is equiv(&amp;other-operator)</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_结合性">44.3.6. 结合性</h4>
<div class="paragraph">
<p>当同一个操作符在一行中连续出现多次时，有多种可能的解释。 例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1 + 2 + 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>能被解析为</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1 + 2) + 3 # 左结合性</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者解析为</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1 + (2 + 3) # 右结合性</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于实数的加法，区别有点模糊，因为 <code>+</code> 是<a href="https://en.wikipedia.org/wiki/Associative_property">数学上相关的</a>。</p>
</div>
<div class="paragraph">
<p>但对其他运算符来说它很重要。 例如对于指数/幂运算符，<code>infix:&lt;**&gt;</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 2 ** (2 ** 3);      # 256
say (2 ** 2) ** 3;      # 64</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 拥有以下可能的结合性配置：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Assoc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Meaning of $a ! $b ! $c</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">L</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">left</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">($a ! $b) ! $c</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">R</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">right</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$a ! ($b ! $c)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">non</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ILLEGAL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">chain</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">($a ! $b) and ($b ! $c)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">list</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">infix:&lt;!&gt;($a; $b; $c)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>您可以使用 <code>is assoc</code> trait 指定运算符的结合性，其中 <code>left</code> 是默认的结合性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;§&gt;(*@a) is assoc&lt;list&gt; {
    '(' ~ @a.join('|') ~ ')';
}

say 1 § 2 § 3;      # (1|2|3)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_traits">44.3.7. Traits</h4>
<div class="paragraph">
<p>特性（<strong>traits</strong>）是在编译时运行以修改类型，变量，例程，属性或其他语言对象的行为的子例程。</p>
</div>
<div class="paragraph">
<p>traits 的例子有：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class ChildClass is ParentClass { ... }
#                ^^ trait, with argument ParentClass
has $.attrib is rw;
#            ^^^^^  trait with name 'rw'
class SomeClass does AnotherRole { ... }
#               ^^^^ trait
has $!another-attribute handles &lt;close&gt;;
#                       ^^^^^^^ trait</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有之前章节中的 <code>is tighter</code>、<code>is looser</code>、<code>is equiv</code>、<code>is assoc</code> 等。</p>
</div>
<div class="paragraph">
<p>Traits 是 <code>trait_mod&lt;VERB&gt;</code> 形式的 subs, 其中  <code>VERB</code> 代表像 <code>is</code>、<code>does</code>、<code>handles</code> 那样的名字。它接受修改后的东西作为参数, 还有名字作为具名参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub trait_mod:&lt;is&gt;(Routine $r, :$doubles!) {
    $r.wrap({
        2 * callsame;
    });
}

sub square($x) is doubles {
    $x * $x;
}

say square 3;       # 18</code></pre>
</div>
</div>
<div class="paragraph">
<p>请参阅内置常规性状文档的<a href="https://docs.raku.org/type/Routine">类型例程</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_重新分派">44.3.8. 重新分派</h4>
<div class="paragraph">
<p>在某些情况下，例程可能想从链中调用下一个方法。 这个链可以是类层次结构中的父类的列表，或者它可以是来自多分派的较不具体的 multi 候选者，或者它可以是来自`wrap`的内部例程。</p>
</div>
<div class="paragraph">
<p>在所有这些情况下，您可以使用 <code>callwith</code> 通过您自己选择的参数调用链中的下一个例程。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi a(Any $x) {
    say "Any $x";
    return 5;
}
multi a(Int $x) {
    say "Int $x";
    my $res = callwith($x + 1);
    say "Back in Int with $res";
}

a 1;
# OUTPUT:
# Int 1
# Any 2
# Back in Int with 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里，<code>a 1</code> 首先调用最具体的 <code>Int</code> 候选者，并且 <code>callwith</code> 重新调度到较不具体的 <code>Any</code> 候选者。</p>
</div>
<div class="paragraph">
<p>通常，重新分派传递和调用者接收到的相同的参数，因此有一个特殊的例程：<code>callsame</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi a(Any $x) {
    say "Any $x";
    return 5;
}
multi a(Int $x) {
    say "Int $x";
    my $res = callsame;
    say "Back in Int with $res";
}

a 1;        # Int 1\n Any 1\n Back in Int with 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个常见的用例是重新分派到链中的下一个例程，之后不执行任何其他操作。 这就是为什么我们有 <code>nextwith</code> 和 <code>nextsame</code>，它使用任意的参数调用下一个例程（<code>nextwith</code>）或与调用者接收（<code>nextsame</code>）相同的参数，但不会返回给调用者。 或者对其进行不同的措辞，<code>nextsame</code> 和 <code>nextwith</code> 变体用下一个候选项替换当前的调用帧(callframe)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi a(Any $x) {
    say "Any $x";
    return 5;
}
multi a(Int $x) {
    say "Int $x";
    nextsame;
    say "back in a";    # never executed, because 'nextsame' doesn't return
}

a 1;        # Int 1\n Any 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>如前所述，multi sub 不是唯一能在 call，call me，nextwith 和 next 中有帮助的情况。 下面是是调度到包装的例程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># enable wrapping:
use soft;

# function to be wrapped:
sub square-root($x) { $x.sqrt }

&amp;square-root.wrap(sub ($num) {
   nextsame if $num &gt;= 0;
   1i * callwith(abs($num));
});

say square-root(4);     # 2
say square-root(-4);    # 0+2i</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一个用例是从父类中重分派给方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class LoggedVersion is Version {
    method new(|c) {
        note "New version object created with arguments " ~ c.perl;
        nextsame;
    }
}

say LoggedVersion.new('1.0.2');</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你需要对被包装的代码进行多次调用或获得一个引用，例如内省它，你可以使用 <code>nextcallee</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub power-it($x) { $x * $x }
sub run-it-again-and-again($x) {
    my &amp;again = nextcallee;
    again again $x;
}

&amp;power-it.wrap(&amp;run-it-again-and-again);
say power-it(5);    # 625</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_强制类型">44.3.9. 强制类型</h4>
<div class="paragraph">
<p>强制类型可以帮助您在例程中拥有特定类型，但接受更宽的输入。 当调用例程时，参数将自动转换为较窄的类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub double(Int(Cool) $x) {
    2 * $x
}

say double '21'; # 42
say double Any;  # Type check failed in binding $x; expected 'Cool' but got 'Any'</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的 <code>Int</code> 是参数将被强制的目标类型，而 <code>Cool</code> 是例程接受的作为输入的类型。</p>
</div>
<div class="paragraph">
<p>如果接受的输入类型为 <code>Any</code>，则可以将 <code>Int(Any)</code> 缩写为 <code>Int()</code>。</p>
</div>
<div class="paragraph">
<p>强制只需查找与目标类型具有相同名称的方法即可。 所以你可以为你自己的类型定义强制，像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Bar {...}

class Foo {
   has $.msg = "I'm a foo!";

   method Bar {
       Bar.new(:msg($.msg ~ ' But I am now Bar.'));
   }
}

class Bar {
   has $.msg;
}

sub print-bar(Bar() $bar) {
   say $bar.WHAT; # (Bar)
   say $bar.msg;  # I'm a foo! But I am now Bar.
}

print-bar Foo.new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>强制类型应该在类型工作的任何地方工作，但 Rakudo 当前（2015.02）仅针对子例程参数实现了它们。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sub_main_2">44.4. sub MAIN</h3>
<div class="paragraph">
<p>具有特殊名称 MAIN 的 sub 在所有相关 parsers 之后执行，并且其签名是可以解析命令行参数的装置。 支持 multi 方法，如果未提供命令行参数，则会自动生成并显示使用方法。 所有命令行参数在 <a href="https://docs.raku.org/language/variables#Dynamic_variables">@*ARGS</a> 中也可用，它可以在被 MAIN 处理之前进行变换。</p>
</div>
<div class="paragraph">
<p><code>MAIN</code> 的返回值被忽略。 要提供除 0 以外的退出代码，请调用 <a href="https://docs.raku.org/routine/exit">exit</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN( Int :$length = 24,
           :file($data) where { .IO.f // die "file not found in $*CWD" } = 'file.dat',
           Bool :$verbose )
{
    say $length if $length.defined;
    say $data   if $data.defined;
    say 'Verbosity ', ($verbose ?? 'on' !! 'off');

    exit 1;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sub_usage_2">44.5. sub USAGE</h3>
<div class="paragraph">
<p>如果对于给定的命令行参数没有找到 <code>MAIN</code> 的多个候选者，则调用 sub <code>USAGE</code>。 如果没有找到此类方法，则输出生成的使用消息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub MAIN(Int $i){ say $i == 42 ?? 'answer' !! 'dunno' }

sub USAGE(){
print Q:c:to/EOH/;
Usage: {$*PROGRAM-NAME} [number]

Prints the answer or 'dunno'.
EOH
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_grammars">45. Grammars</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Grammar 是一种功能强大的工具, 用于对文本进行解构。Grammar 通常返回通过解释文本而创建的数据结构。</p>
</div>
<div class="paragraph">
<p>例如, 使用 Raku 风格的 grammar 来解析和执行 Raku 自身。</p>
</div>
<div class="paragraph">
<p>对于普通 Raku 用户来说, 更实用的一个例子是 <a href="https://github.com/moritz/json">JSON::Tiny</a> 模块, 该模块可以反序列化任何合法的 JSON 文件, 而且反序列代码只有不到 100 行, 还能扩展。</p>
</div>
<div class="paragraph">
<p>如果你在学校就不喜欢 grammar, 不要让它成为阻止你学习 grammar 的理由。Grammar 允许你像类组织方法那样组织正则表达式。</p>
</div>
<div class="sect2">
<h3 id="_具名正则">45.1. 具名正则</h3>
<div class="paragraph">
<p>Grammar 的主要组成部分是 <a href="http://doc.raku.org/language/regexes">regexes</a>。 而 Raku 的 <a href="http://doc.raku.org/language/regexes">regexes</a> 语法不在该文档的讨论范围内, 具名正则有自己的特殊语法, 这跟子例程的定义很像:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># 普通 regex 中空格被忽略, [] 是非捕获括号
my regex number { \d+ [ \. \d+ ]? }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中我们使用 <code>my</code> 关键字指定这个 regex 是本地作用域的, 因为具名正则通常用于 grammar 里面。</p>
</div>
<div class="paragraph">
<p>正则被命名的好处是能够轻松地在其它地方重用正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so "32.51" ~~ &amp;number;                         # OUTPUT: «True␤»
say so "15 + 4.5" ~~ /&lt;number&gt;\s* '+' \s*&lt;number&gt;/ # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>regex</code> 不是具名正则的唯一声明符, 实际上 , regex 声明符用的最少。 大多数情况下, 使用的是 <code>token</code> 或 <code>rule</code> 声明符。token 和 rule 这两个声明符都是带棘齿(<code>ratcheing</code>)的, 这意味着如果匹配失败, 那么匹配引擎就不会回溯并继续尝试匹配了。这通常可以满足你的需求, 但不适用于所有情况:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex works-but-slow { .+ q } # 可能会回溯
my token fails-but-fast { .+ q } # 不回溯
my $s = 'Tokens and rules won\'t backtrack, which makes them fail quicker!';
say so $s ~~ &amp;works-but-slow; # OUTPUT: «True␤»
say so $s ~~ &amp;fails-but-fast; # OUTPUT: «False␤»
                              # .+ 得到了整个字符串但不回溯</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, 非回溯是作用在项上的, 即, 如下面的示例所示, 如果匹配了某些内容, 则将永远不会回溯。 但是, 如果匹配失败, 但是 <code>|</code> 或 <code>||</code> 引入了另一个候选者, 将会重试匹配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my token tok-a { .* d  };
my token tok-b { .* d | bd };
say so "bd" ~~ &amp;tok-a;        # OUTPUT: «False␤»
say so "bd" ~~ &amp;tok-b;        # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_rules">45.1.1. Rules</h4>
<div class="paragraph">
<p><code>token</code> 和 <code>rule</code> 声明符的唯一区别就是 <code>rule</code> 声明符会让正则中的 <a href="https://docs.raku.org/language/regexes#Sigspace">:sigspace</a> 修饰符起效:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my token non-space-y { 'once' 'upon' 'a' 'time' }
my rule space-y { 'once' 'upon' 'a' 'time' }
say so 'onceuponatime'    ~~ &amp;non-space-y; # OUTPUT: «True␤»
say so 'once upon a time' ~~ &amp;non-space-y; # OUTPUT: «False␤»
say so 'onceuponatime'    ~~ &amp;space-y;     # OUTPUT: «False␤»
say so 'once upon a time' ~~ &amp;space-y;     # OUTPUT: «True␤»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_创建_grammar">45.2. 创建 Grammar</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Grammar">Grammar</a> 是使用 grammar 关键字而不是 class 关键字声明类时, 它们自动获得的超类。Grammar 只能用于解析文本; 如果想提取复杂的数据, 则可以在 grammar 中添加 action, 或者建议将 <a href="http://doc.raku.org/language/grammars#Action_Objects">action 对象</a>和 grammar 结合使用。如果未使用 action 对象, 则 <code>.parse</code> 返回一个 <a href="https://docs.raku.org/type/Match">Match</a> 对象并默认把默认的匹配对象 <a href="https://docs.raku.org/syntax/$$SOLIDUS">$/</a> 设置为相同的值。</p>
</div>
<div class="sect3">
<h4 id="_原型正则">45.2.1. 原型正则</h4>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Grammar">Grammar</a> 由 rule, token 和 regex 组成; 他们实际上都是方法, 因为 grammar 是类。</p>
</div>
<div class="paragraph">
<p>这些方法可以共用一个名称和功能, 因此可以使用 <a href="https://docs.raku.org/syntax/proto">proto</a>。</p>
</div>
<div class="paragraph">
<p>例如, 如果你有很多备选分支(alternations), 则可能难以生成可读性好的代码或将 grammar 子类化。在下面的 <code>Actions</code> 类中, <code>TOP</code> 方法中的三元操作符并不理想, 并且当我们添加的操作越多, 它就变得越糟糕:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Calculator {
    token TOP { [ &lt;add&gt; | &lt;sub&gt; ] }
    rule  add { &lt;num&gt; '+' &lt;num&gt; }
    rule  sub { &lt;num&gt; '-' &lt;num&gt; }
    token num { \d+ }
}

class Calculations {
    method TOP ($/) { make $&lt;add&gt; ?? $&lt;add&gt;.made !! $&lt;sub&gt;.made; }
    method add ($/) { make [+] $&lt;num&gt;; }
    method sub ($/) { make [-] $&lt;num&gt;; }
}

say Calculator.parse('2 + 3', actions =&gt; Calculations).made;

# OUTPUT: «5␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了让事情变得更好, 我们可以在 token 上使用类似于 <code>:sym&lt;&#8230;&#8203;&gt;</code> 副词的原型正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Calculator {
    token TOP { &lt;calc-op&gt; }

    proto rule calc-op          {*}
          rule calc-op:sym&lt;add&gt; { &lt;num&gt; '+' &lt;num&gt; }
          rule calc-op:sym&lt;sub&gt; { &lt;num&gt; '-' &lt;num&gt; }

    token num { \d+ }
}

class Calculations {
    method TOP              ($/) { make $&lt;calc-op&gt;.made; }
    method calc-op:sym&lt;add&gt; ($/) { make [+] $&lt;num&gt;; }
    method calc-op:sym&lt;sub&gt; ($/) { make [-] $&lt;num&gt;; }
}

say Calculator.parse('2 + 3', actions =&gt; Calculations).made;

# OUTPUT: «5␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个 grammar 中, 备选分支(alternation)已经被 <code>&lt;calc-op&gt;</code> 替换掉了, 这实际上是我们将要创建的一组值的名称。为此, 我们使用 <code>proto rule calc-op</code> 定义了一个 rule 原型类型(prototype)。我们之前的每个备选分支都由新的 rule <code>calc-op</code> 定义替换, 并且备选分支的名字附加有 <code>:sym&lt;&gt;</code> 副词。</p>
</div>
<div class="paragraph">
<p>在声明 action 的类中, 我们现在摆脱了三目操作符, 仅从 <code>$&lt;calc-op&gt;</code> 匹配对象上获取 <code>.made</code> 值。现在各备选分支的 action 都遵循与 grammar 相同的命名模式:  <code>method calc-op:sym&lt;add&gt;</code> 和 <code>method calc-op:sym&lt;sub&gt;</code>。</p>
</div>
<div class="paragraph">
<p>当你将 grammar 和 action 子类化时, 可以看到此方法的真正魅力。假设我们想为 calculator 增加一个乘法功能:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar BetterCalculator is Calculator {
    rule calc-op:sym&lt;mult&gt; { &lt;num&gt; '*' &lt;num&gt; }
}

class BetterCalculations is Calculations {
    method calc-op:sym&lt;mult&gt; ($/) { make [*] $&lt;num&gt; }
}

say BetterCalculator.parse('2 * 3', actions =&gt; BetterCalculations).made;

# OUTPUT: «6␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们需要做的只是对 <code>calc-op</code> 组添加额外的 rule 和 action, 感谢原型正则表达式, 所有的东西都能正常工作。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_特殊的_token">45.3. 特殊的 token</h3>
<div class="sect3">
<h4 id="_top">45.3.1. TOP</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Foo {
    token TOP { \d+ }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TOP</code> token 是用 grammar 解析时, 尝试匹配的默认第一个 token。请注意, 如果使用 <a href="https://docs.raku.org/type/Grammar#method_parse">.parse</a> 方法进行解析, 那么 <code>token TOP</code> 会自动地锚定到字符串的开头和结尾。如果不想解析整个字符串, 请使用 <a href="https://docs.raku.org/type/Grammar#method_subparse">.subparse</a>。</p>
</div>
<div class="paragraph">
<p>也可以使用 <code>rule TOP</code> 或 <code>regex TOP</code>。</p>
</div>
<div class="paragraph">
<p>在 <code>.parse</code>、<code>.subparse</code> 或 <code>.parsefile</code> 中使用 <code>:rule</code> 命名参数可以选择一个不同的 token 来进行首次匹配。 这些都是 <code>Grammar</code> 方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ws">45.3.2. ws</h4>
<div class="paragraph">
<p>默认的 <code>ws</code> 匹配零个或多个空白字符, 只要所匹配之处不在单词里面(用代码来表示就是 <code>regex ws { &lt;!ww&gt; \s* }</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># First &lt;.ws&gt; matches word boundary at the start of the line
# and second &lt;.ws&gt; matches the whitespace between 'b' and 'c'
say 'ab   c' ~~ /&lt;.ws&gt; ab &lt;.ws&gt; c /; # OUTPUT: «｢ab   c｣␤»

# Failed match: there is neither any whitespace nor a word
# boundary between 'a' and 'b'
say 'ab' ~~ /. &lt;.ws&gt; b/;             # OUTPUT: «Nil␤»

# Successful match: there is a word boundary between ')' and 'b'
say ')b' ~~ /. &lt;.ws&gt; b/;             # OUTPUT: «｢)b｣␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住, 我们对空白不感兴趣, 所以我们在 <code>ws</code> 前面加了一个点, 以避免捕获。由于空格通常是分隔符, 因此通常会找到它。</p>
</div>
<div class="paragraph">
<p>当使用 <code>rule</code> 代替 <code>token</code> 时, 会默认启用 <code>:sigspace</code>, 并且将项和闭合圆括号/方括号之后的任何空白都转换为对 <code>ws</code> 的非捕获调用, 写为 <code>&lt;.ws&gt;</code>。 其中 <code>.</code> 表示不捕捉。 也就是说：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rule entry { &lt;key&gt; '=' &lt;value&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>等价于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token entry { &lt;key&gt; &lt;.ws&gt; '=' &lt;.ws&gt; &lt;value&gt; &lt;.ws&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以重新定义自己的 <code>ws</code> token:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Foo {
    rule TOP { \d \d }
}.parse: "4   \n\n 5"; # Succeeds

grammar Bar {
    rule TOP { \d \d }
    token ws { \h*   }
}.parse: "4   \n\n 5"; # Fails</code></pre>
</div>
</div>
<div class="paragraph">
<p>甚至捕获空白, 但你需要显式地使用它。 请注意, 在下一个示例中, 我们使用 <code>token</code> 代替 <code>rule</code>, 因为后者会导致空白被隐式的非捕获 <code>.ws</code> 占用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Foo { token TOP {\d &lt;ws&gt; \d} };
my $parsed = Foo.parse: "3 3";
say $parsed&lt;ws&gt;; # OUTPUT: «｢ ｣␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sym">45.3.3. sym</h4>
<div class="paragraph">
<p><code>&lt;sym&gt;</code> token 可以在原型正则表达式中使用, 以匹配该特定正则表达式的 <code>:sym</code> 副词的字符串值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Foo {
    token TOP { &lt;letter&gt;+ }
    proto token letter {*}
    token letter:sym&lt;P&gt; { &lt;sym&gt; }
    token letter:sym&lt;e&gt; { &lt;sym&gt; }
    token letter:sym&lt;r&gt; { &lt;sym&gt; }
    token letter:sym&lt;l&gt; { &lt;sym&gt; }
    token letter:sym&lt;*&gt; {   .   }
}.parse("I ♥ Perl", actions =&gt; class {
    method TOP($/) { make $&lt;letter&gt;.grep(*.&lt;sym&gt;).join }
}).made.say; # OUTPUT: «Perl␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你已经将原型正则表达式与要匹配的字符串区分开来时, 这会派上用场, 因为使用 <code>&lt;sym&gt;</code> token 可防止重复这些字符串。</p>
</div>
</div>
<div class="sect3">
<h4 id="_总是成功断言">45.3.4. 总是成功断言</h4>
<div class="paragraph">
<p><code>&lt;?&gt;</code> 是始终成功断言。 当它用作 grammar 中的 token 时, 它可以被用于触发 Action 类方法。在下面的 grammar 中, 我们查找阿拉伯数字并且使用始终成功断言定义 <code>succ</code> token。</p>
</div>
<div class="paragraph">
<p>在 action 类中, 我们使用对 <code>succ</code> 方法的调用来设置(在这个例子中, 我们在 <code>@!numbers</code> 中准备了一个新元素)。在 <code>digit</code> 方法中, 我们把阿拉伯数字转换为梵文数字并且把它添加到 <code>@!numbers</code> 数组的最后一个元素中。多亏了 <code>succ</code>, 最后一个元素总是当前正被解析的 <code>digit</code> 数字的数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar Digifier {
    rule TOP {
        [ &lt;.succ&gt; &lt;digit&gt;+ ]+
    }
    token succ  { &lt;?&gt; }
    token digit { &lt;[0..9]&gt; }
}

class Devanagari {
    has @!numbers;
    method digit ($/) { @!numbers.tail ~= &lt;०  १  २  ३  ४  ५  ६  ७  ८  ९&gt;[$/] }
    method succ  ($)  { @!numbers.push: ''     }
    method TOP   ($/) { make @!numbers[^(*-1)] }
}

say Digifier.parse('255 435 777', actions =&gt; Devanagari.new).made;
# OUTPUT: «(२५५ ४३५ ७७७)␤»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_grammar_中的方法">45.4. Grammar 中的方法</h3>
<div class="paragraph">
<p>在 grammar 中使用 <code>method</code> 代替 <code>rule</code> 或 <code>token</code> 也是可以的, 只要它们返回一个 <a href="https://docs.raku.org/type/Match">Match</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar DigitMatcher {
    method TOP (:$full-unicode) {
        $full-unicode ?? self.num-full !! self.num-basic;
    }
    token num-full  { \d+ }
    token num-basic { &lt;[0..9]&gt;+ }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的 grammar 会根据提供给 <code>subparse</code> 方法的参数尝试不同的匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say +DigitMatcher.subparse: '12७१७९०९', args =&gt; \(:full-unicode);
# OUTPUT: «12717909␤»

say +DigitMatcher.subparse: '12७१७९०९', args =&gt; \(:!full-unicode);
# OUTPUT: «12␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_grammar_中的动态变量">45.5. Grammar 中的动态变量</h3>
<div class="paragraph">
<p>可以在 token 标记中定义变量, 方法是在定义变量的代码行前面加上 <code>:</code>。 通过花括号, 可以将任意代码嵌入到 token 中的任何位置。 这对于保存 token 标记之间的状态很有用, 可用于更改 grammar 解析文本的方式。 在 token 中使用动态变量(带有 <code>$<strong></code>, <code>@</strong></code>, <code>&amp;*</code>, <code>%*</code> twigils 的变量)可在其定义的那个变量内级联遍历此后定义的所有 token, 从而避免了将它们作为参数从 token 传递到 token。</p>
</div>
<div class="paragraph">
<p>动态变量的一种用途是匹配保护。 此示例使用守卫来解释哪个正则表达式类按字面意义解析空格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar GrammarAdvice {
    rule TOP {
        :my Int $*USE-WS;
        "use" &lt;type&gt; "for" &lt;significance&gt; "whitespace by default"
    }
    token type {
        | "rules"   { $*USE-WS = 1 }
        | "tokens"  { $*USE-WS = 0 }
        | "regexes" { $*USE-WS = 0 }
    }
    token significance {
        | &lt;?{ $*USE-WS == 1 }&gt; "significant"
        | &lt;?{ $*USE-WS == 0 }&gt; "insignificant"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里, 仅当提及 rules, tokens 或 regexes 所指定的状态与正确的守卫匹配时, 诸如 "use rules for significant whitespace by default" 之类的文本才会匹配：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say GrammarAdvice.subparse("use rules for significant whitespace by default");
# OUTPUT: «use rules for significant whitespace by default»

say GrammarAdvice.subparse("use tokens for insignificant whitespace by default");
# OUTPUT: «use tokens for insignificant whitespace by default»

say GrammarAdvice.subparse("use regexes for insignificant whitespace by default");
# OUTPUT: «use regexes for insignificant whitespace by default»

say GrammarAdvice.subparse("use regexes for significant whitespace by default")
# OUTPUT: #&lt;failed match&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_grammar_中的属性">45.6. Grammar 中的属性</h3>
<div class="paragraph">
<p>Grammar 中可以定义属性。 但是, 只能通过方法访问属性。 尝试从 token 标记中使用它们会引发异常, 因为 token 标记是 <a href="https://docs.raku.org/type/Match">Match</a> 的方法, 而不是 grammar 本身。 请注意, 从 token 标记中调用的方法中更改属性只会修改该 token 自己的 <code>match</code> 对象的属性! 如果将 grammar 属性设置为公开, 则可以在解析后返回的匹配项中访问 grammar 属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar HTTPRequest {
    has Bool $.invalid;

    token TOP {
        &lt;type&gt; &lt;.ns&gt; &lt;path&gt; &lt;.ns&gt; 'HTTP/1.1' &lt;.crlf&gt;
        [ &lt;field&gt; &lt;.crlf&gt; ]+
        &lt;.crlf&gt;
        $&lt;body&gt;=.*
    }

    token type {
        | [ GET | POST | OPTIONS | HEAD | PUT | DELETE | TRACE | CONNECT ] &lt;.accept&gt;
        | &lt;-[\/]&gt;+ &lt;.error&gt;
    }

    token path {
        | '/' [[\w+]+ % \/] [\.\w+]? &lt;.accept&gt;
        | '*' &lt;.accept&gt;
        | \S+ &lt;.error&gt;
    }

    token field {
        | $&lt;name&gt;=\w+ &lt;.ns&gt; ':' &lt;.ns&gt; $&lt;value&gt;=&lt;-crlf&gt;* &lt;.accept&gt;
        | &lt;-crlf&gt;+ &lt;.error&gt;
    }

    method error(--&gt; ::?CLASS:D) {
        $!invalid = True;
        self;
    }

    method accept(--&gt; ::?CLASS:D) {
        $!invalid = False;
        self;
    }

    token crlf { # network new line (usually seen as "\r\n")
        # Several internet protocols (such as HTTP, RF 2616) mandate
        # the use of ASCII CR+LF (0x0D 0x0A) to terminate lines at
        # the protocol level (even though, in practice, some applications
        # tolerate a single LF).
        # Raku, Raku grammars and strings (Str) adhere to Unicode
        # conformance. Thus, CR+LF cannot be expressed unambiguously
        # as \r\n in in Raku grammars or strings (Str), as Unicode
        # conformance requires \r\n to be interpreted as \n alone.
        \x[0d] \x[0a]
    }
    token ns { # network space
        # &lt;ws&gt; would consume, e.g., newlines, and \h (and \s) would accept
        # more codepoints than just ASCII single space and the tab character.
        [ ' ' | &lt;[\t]&gt; ]*
    }
}

my $crlf = "\x[0d]\x[0a]";
my $header = "GOT /index.html HTTP/1.1{$crlf}Host: docs.raku.org{$crlf}{$crlf}body";
my $m = HTTPRequest.parse($header);
say "type(\"$m.&lt;type&gt;\")={$m.&lt;type&gt;.invalid}";
# OUTPUT: type("GOT ")=True
say "path(\"$m.&lt;path&gt;\")={$m.&lt;path&gt;.invalid}";
# OUTPUT: path("/index.html")=False
say "field(\"$m.&lt;field&gt;[0]\")={$m.&lt;field&gt;[0].invalid}";
# OUTPUT: field("Host: docs.raku.org")=False</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意：如果我们想以某种方式（在此不完整示例的上下文中）严格遵守 HTTP/1.1(RFC 2616), 则 <code>$crlf</code> 和 token <code>&lt;.crlf&gt;</code> 是必需的。 原因是, 与 RFC 2616 相比, Raku 是 Unicode 兼容的, 并且 <code>\r\n</code> 需要解释为单个 <code>\n</code>, 从而阻止 grammar 在 HTTP 协议的某些场景中正确解析包含 <code>\r\n</code> 的字符串。 请注意属性 <code>invalid</code> 在每个组件中都是本地的(例如, 对于 <code>&lt;type&gt;</code> 其值为 <code>True</code>, 而对于 <code>&lt;path&gt;</code> 其 值为 <code>False</code>)。 还要注意我们有一个 <code>accept</code> 方法, 否则 <code>invalid</code> 属性将是未初始化的(即使存在)。</p>
</div>
</div>
<div class="sect2">
<h3 id="_传递参数到_grammar_中">45.7. 传递参数到 Grammar 中</h3>
<div class="paragraph">
<p>要将参数传递到 grammar 中, 可以在 grammar 的任何解析方法上使用 <code>:args</code> 命名参数。 传递的参数应在列表中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar demonstrate-arguments {
    rule TOP ($word) {
    "I like" $word
    }
}

# Notice the comma after "sweets" when passed to :args to coerce it to a list
say demonstrate-arguments.parse("I like sweets", :args(("sweets",)));
# OUTPUT: «｢I like sweets｣␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦传入参数, 就可以在 grammar 内调用命名正则表达式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar demonstrate-arguments-again {
    rule TOP ($word) {
        &lt;phrase-stem&gt;&lt;added-word($word)&gt;
    }

    rule phrase-stem {
       "I like"
    }

    rule added-word($passed-word) {
       $passed-word
    }
}

say demonstrate-arguments-again.parse("I like vegetables", :args(("vegetables",)));
# OUTPUT: ｢I like vegetables｣␤»
# OUTPUT:  «phrase-stem =&gt; ｢I like ｣␤»
# OUTPUT:  «added-word =&gt; ｢vegetables｣␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外, 你可以初始化动态变量并在 grammar 中使用任何这样的参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar demonstrate-arguments-dynamic {
   rule TOP ($*word, $*extra) {
      &lt;phrase-stem&gt;&lt;added-words&gt;
   }
   rule phrase-stem {
      "I like"
   }
   rule added-words {
      $*word $*extra
   }
}

say demonstrate-arguments-dynamic.parse("I like everything else",
  :args(("everything", "else")));
# OUTPUT: «｢I like everything else｣␤»
# OUTPUT:  «phrase-stem =&gt; ｢I like ｣␤»
# OUTPUT:  «added-words =&gt; ｢everything else｣␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_action_object">45.8. Action Object</h3>
<div class="paragraph">
<p>一个成功的 grammar 匹配会给你一棵<a href="https://docs.raku.org/type/Match">匹配</a>对象的解析树, 匹配树越深入, 则 grammar 中的分支越多, 那么在匹配树中导航以获取你真正感兴趣的信息就变的越来越困难。</p>
</div>
<div class="paragraph">
<p>为了避免你在匹配树中迷失, 你可以提供一个 action 对象。Grammar 中每次成功解析具名规则(named rule)之后, 它都会尝试调用一个和该 grammar rule 同名的方法, 并给这个方法传递一个 <code>Match</code> 对象作为位置参数。如果不存在这样的同名方法, 就跳过。</p>
</div>
<div class="paragraph">
<p>这儿有一个例子来说明 grammar 和 action：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar TestGrammar {
    token TOP { \d+ }
}

class TestActions {
    method TOP($/) {
        $/.make(2 + $/);
    }
}

my $match = TestGrammar.parse('40', actions =&gt; TestActions.new);
say $match;         # OUTPUT: «｢40｣␤»
say $match.made;    # OUTPUT: 42</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TestActions</code> 的一个实例作为具名参数 <code>actions</code> 被传递给 <a href="https://docs.raku.org/routine/parse">parse</a> 调用, 然后当 token <code>TOP</code> 匹配成功之后, 就会自动调用方法 <code>TOP</code>, 并传递匹配对象作为此方法的参数。</p>
</div>
<div class="paragraph">
<p>为了明确说明该参数是匹配对象, 该示例使用 <code>$/</code> 作为 action 方法的参数名, 尽管这只是一个方便的约定, 没有内在的含义。 <code>$match</code> 也可以工作, 尽管使用 <code>$/</code> 确实提供了将 <code>$&lt;capture&gt;</code> 作为 <code>$/&lt;capture&gt;</code> 的快捷方式的优势; 无论如何, 我们在 <code>TOP</code> 的 action 中使用了另一个参数。</p>
</div>
<div class="paragraph">
<p>下面是一个更有说服力的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar KeyValuePairs {
    token TOP {
        [&lt;pair&gt; \v+]*
    }

    token pair {
        &lt;key=.identifier&gt; '=' &lt;value=.identifier&gt;
    }

    token identifier {
        \w+
    }
}

class KeyValuePairsActions {
    method pair      ($/) {
        $/.make: $&lt;key&gt;.made =&gt; $&lt;value&gt;.made
    }
    method identifier($/) {
        # subroutine `make` is the same as calling .make on $/
        make ~$/
    }

    method TOP ($match) {
        # can use any variable name for parameter, not just $/
        $match.make: $match&lt;pair&gt;».made
    }
}


my $actions = KeyValuePairsActions;
my @res = KeyValuePairs.parse(q:to/EOI/, :$actions).made;
second=b
hits=42
perl=6
EOI

for @res -&gt; $p {
    say "Key: $p.key()\tValue: $p.value()";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Key: second     Value: b
Key: hits       Value: 42
Key: perl       Value: 6</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>pair</code> 这个 rule, 解析一对由等号分割的 pair, 将对 token <code>identifier</code> 的两次调用起了别名以分割捕获名称, 从而使它们使用起来更容易, 更直观, 因为它们会用在对应的 action 中。对应的 action 方法构建了一个 <a href="https://docs.raku.org/type/Pair">Pair</a> 对象, 并使用子匹配对象的 <code>.made</code> 属性。这(就如 <code>TOP</code> action 方法一样)也暴露了一个事实: 子匹配的 action 方法在那些调用正则/外部正则之前就被调用。所以 action 方法是按<a href="https://en.wikipedia.org/wiki/Tree_traversal#Post-order">后续</a>调用的。</p>
</div>
<div class="paragraph">
<p>名为 <code>TOP</code> 的 action 方法仅仅把由 <code>pair</code> 这个 rule 的多重匹配组成的所有对象收集到一块, 然后以一个列表的方式返回。</p>
</div>
<div class="paragraph">
<p>还要注意 <code>KeyValuePairsActions</code> 是作为类型对象传递给 <code>parse</code> 方法的, 这是因为 action 方法中没有使用属性(属性只能通过实例来访问)。</p>
</div>
<div class="paragraph">
<p>我们可以使用继承扩展上面的例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use KeyValuePairs;

unit grammar ConfigurationSets is KeyValuePairs;

token TOP {
    &lt;configuration-element&gt;+ %% \v
}

token configuration-element {
    &lt;pair&gt;+ %% \v
}

token comment {
    \s* '#' .+? $$
}

token pair {
    &lt;key=.identifier&gt; '=' &lt;value=.identifier&gt; &lt;comment&gt;?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将对前面的示例进行子类化（实际上是对 grammar 进行子类化）。 我们通过添加注释来重写 <code>pair</code> 的定义； 以前的 <code>TOP</code> rule 已降级为 <code>configuration-element</code>, 并且有一个新的 <code>TOP</code> 现在考虑由垂直空白分隔的配置元素集。 我们还可以通过子类化 action 类来重用 action：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use KeyValuePairs;

unit class ConfigurationSetsActions is KeyValuePairsActions;

method configuration-element($match) {
    $match.make: $match&lt;pair&gt;».made
}

method TOP ($match) {
    my @made-elements = gather for $match&lt;configuration-element&gt; {
        take $_.made
    };
    $match.make( @made-elements );

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有现有的 action 都可以重用, 尽管显然必须为 grammar 中的新元素(包括 <code>TOP</code>)编写新的 action。 这些可以和此脚本一起使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use ConfigurationSets;
use ConfigurationSetsActions;

my $actions = ConfigurationSetsActions;
my $sets = ConfigurationSets.parse(q:to/EOI/, :$actions).made;
second=b # Just a thing
hits=42
perl=6

third=c # New one
hits=33
EOI

for @$sets -&gt; $set {
    say "Element→ $set";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Element→ second b hits 42 perl 6
Element→ third c hits 33</code></pre>
</div>
</div>
<div class="paragraph">
<p>其它情况下, action 方法可能会在属性中保存状态。 那么这当然需要你传递一个实例给 <code>parse</code> 方法。</p>
</div>
<div class="paragraph">
<p>注意, <code>token ws</code> 有点特殊: 当 <code>:sigspace</code> 开启的时候(就是我们使用 <code>rule`的时候), 它会替换某些空白序列。这就是为什么 `rule pair</code> 中等号周围的空格可以正常工作的原因, 以及为什么在闭合 <code>}</code> 之前的空白不会吞噬 token <code>TOP</code> 中的换行符的原因。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_散列和映射">46. 散列和映射</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_关联角色和关联类">46.1. 关联角色和关联类</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Associative">关联</a>角色是 Hash 和 Map 以及 <a href="https://docs.raku.org/type/MixHash">MixHash</a> 等其他类的基础。它定义了将在关联类中使用的两种类型; 默认情况下，您可以使用任何内容（字面意思，因为任何 <a href="https://docs.raku.org/type/Any">Any</a> 子类的类都可以使用）<a href="https://docs.raku.org/language/hashmap#Non-string_keys_%28object_hash%29%2C_although_it_will_be_coerced_to_a_string%2C_and_any_object_as_value._You_can_access_these_types_using_the_C%3Cof">作为键</a>和 <code>keyof</code> 方法。</p>
</div>
<div class="paragraph">
<p>默认情况下，使用 <code>%</code> sigil 声明的任何对象都将获得 Associative 角色，默认情况下将表现为散列，但此角色仅提供上述两种方法，以及默认的 Hash 行为。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (%).^name ; # 输出 Hash</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反，如果未混入 <code>Associative</code> 角色，则不能使用 <code>%</code> sigil，但由于此角色没有任何关联属性，因此你必须重新定义<a href="https://docs.raku.org/language/operators#postcircumfix_%7B_%7D">散列下标操作符</a>的行为。为此，你必须重写几个函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Logger does Associative[Cool,DateTime] {
    has %.store;

    method log( Cool $event ) {
        %.store{ DateTime.new( now ) } = $event;
    }

    multi method AT-KEY ( ::?CLASS:D: $key) {
        my @keys = %.store.keys.grep( /$key/ );
        %.store{ @keys };
    }

    multi method EXISTS-KEY (::?CLASS:D: $key) {
        %.store.keys.grep( /$key/ )??True!!False;
    }

    multi method DELETE-KEY (::?CLASS:D: $key) {
        X::Assignment::RO.new.throw;
    }

    multi method ASSIGN-KEY (::?CLASS:D: $key, $new) {
        X::Assignment::RO.new.throw;
    }

    multi method BIND-KEY (::?CLASS:D: $key, \new){
        X::Assignment::RO.new.throw;
    }
}
say Logger.of;                   # OUTPUT: «(Cool)»
my %logger := Logger.new;
say %logger.of;                  # OUTPUT: «(Cool)»

%logger.log( "Stuff" );
%logger.log( "More stuff");

say %logger&lt;2018-05-26&gt;;         # OUTPUT: «(More stuff Stuff)»
say %logger&lt;2018-04-22&gt;:exists;  # OUTPUT: «False»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们定义了一个具有关联语义的 logger，它可以使用日期（或其中一部分）作为键。由于我们将参数化 <code>Associative</code> 为那些特定类，<code>of</code> 将返回我们使用的值类型，在这里为 <code>Cool</code>（我们只能记录列表或字符串）。混合 <code>Associative</code> 角色赋予其使用 <code>%</code> sigil 的权利; 因为 <code>%</code>-sigilled 变量默认获得 <code>Hash</code> 类型，所以在定义中需要绑定。</p>
</div>
<div class="paragraph">
<p>此 log 将仅附加，这就是为什么我们转义关联数组隐喻以使用 <code>log</code> 方法向日志添加新事件。但是，一旦添加它们，我们就可以按日期检索它们或检查它们是否存在。对于第一个，我们必须重写 <code>AT-KEY</code> multi 方法，对于后者 <code>EXIST-KEY</code>。在最后两个语句中，我们展示了下标操作如何调用 <code>AT-KEY</code>，而 <code>:exists</code> 副词调用 <code>EXISTS-KEY</code>。</p>
</div>
<div class="paragraph">
<p>我们重写 <code>DELETE-KEY</code>，<code>ASSIGN-KEY</code> 和 <code>BIND-KEY</code>，但只抛出异常。尝试赋值，删除或绑定值到键上将导致 <code>Cannot modify an immutable Str (value)</code> 异常抛出。</p>
</div>
<div class="paragraph">
<p>使类关联提供了一种使用哈希来使用和使用它们的非常方便的方法; 在 <a href="http://cro.services/docs/reference/cro-http-client#Setting_the_request_body">Cro</a> 中可以看到一个例子，它广泛使用它来方便使用哈希定义结构化请求并表达其响应。</p>
</div>
</div>
<div class="sect2">
<h3 id="_可变哈希和不可变映射">46.2. 可变哈希和不可变映射</h3>
<div class="paragraph">
<p>Hash 是从键到值的可变映射（在其他编程语言中称为字典，哈希表或映射）。这些值都是标量容器，这意味着你可以给它们赋值。另一方面，<a href="https://docs.raku.org/type/Map">Map</a>s是不可变的。键与值配对后，此配对无法更改。</p>
</div>
<div class="paragraph">
<p>Maps 和 hashes 通常存储在百分号 <code>%</code> 变量中，用于表示它们是关联的(Associative)。</p>
</div>
<div class="paragraph">
<p>通过 <code>{}</code> postcircumfix 运算符使用键访问 Hash 和 map 元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %*ENV{'HOME', 'PATH'}.perl;
# OUTPUT: «("/home/camelia", "/usr/bin:/sbin:/bin")␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>一般的<a href="https://docs.raku.org/language/subscripts">下标</a>规则适用于提供字符串字面量列表的快捷方式，包括插值和不插值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h = oranges =&gt; 'round', bananas =&gt; 'bendy';
say %h&lt;oranges bananas&gt;;
# OUTPUT: «(round bendy)␤»

my $fruit = 'bananas';
say %h«oranges "$fruit"»;
# OUTPUT: «(round bendy)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>您只需分配一个未使用的键即可添加新对：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h;
%h{'new key'} = 'new value';</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hash_赋值">46.3. Hash 赋值</h3>
<div class="paragraph">
<p>将一个元素列表赋值给一个哈希变量首先清空该变量，然后迭代右侧的元素。如果元素是 <a href="https://docs.raku.org/type/Pair">Pair</a>，则将其键作为新的哈希键，并将其值作为该键的新哈希值。否则，该值被强制转换为 <a href="https://docs.raku.org/type/Str">Str</a> 并用作散列键，而列表的下一个元素则被视为相应的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h = 'a', 'b', c =&gt; 'd', 'e', 'f';</code></pre>
</div>
</div>
<div class="paragraph">
<p>等价于</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h = a =&gt; 'b', c =&gt; 'd', e =&gt; 'f';</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h = &lt;a b c d e f&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>甚至</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h = %( a =&gt; 'b', c =&gt; 'd', e =&gt; 'f')</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $h = { a =&gt; 'b', c =&gt; 'd', e =&gt; 'f'};</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，花括号仅在我们未将其分配给 %-sigilled 变量的情况下使用;如果我们将它用于 %-sigilled 变量，我们将遇到 <code>Potential difficulties:␤ Useless use of hash composer on right side of hash assignment; did you mean := instead?</code> 的错误。但是，正如此错误所示，只要我们使用绑定，我们就可以使用花括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h := { a =&gt; 'b', c =&gt; 'd', e =&gt; 'f'};
say %h; # OUTPUT: «{a =&gt; b, c =&gt; d, e =&gt; f}␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>嵌套哈希也可以使用相同的语法定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h =  e =&gt; f =&gt; 'g';
say %h&lt;e&gt;&lt;f&gt;; # OUTPUT: «g␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，你在这里定义的是一个指向 <a href="https://docs.raku.org/type/Pair">Pair</a> 的键，如果你想要的话，这很好，如果你的嵌套哈希有一个键。但是 <code>%h &lt;e&gt;</code> 将指向 <code>Pair</code> 会产生这些后果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h =  e =&gt; f =&gt; 'g';
%h&lt;e&gt;&lt;q&gt; = 'k';
# OUTPUT: «(exit code 1) Pair␤Cannot modify an immutable Str (Nil)␤  in block &lt;unit&gt;»</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，这将有效地定义嵌套哈希：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h =  e =&gt; { f =&gt; 'g'};
say %h&lt;e&gt;.^name;  # OUTPUT: «Hash␤»
say %h&lt;e&gt;&lt;f&gt;;     # OUTPUT: «g␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果遇到期望值的 <a href="https://docs.raku.org/type/Pair">Pair</a>，则将其用作哈希值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h = 'a', 'b' =&gt; 'c';
say %h&lt;a&gt;.^name;            # OUTPUT: «Pair␤»
say %h&lt;a&gt;.key;              # OUTPUT: «b␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果同一个键出现多次，则与其最后一次出现的值存储在哈希中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h = a =&gt; 1, a =&gt; 2;
say %h&lt;a&gt;;                  # OUTPUT: «2␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>要将哈希值分配给不具有％sigil的变量，可以使用％（）哈希构造函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $h = %( a =&gt; 1, b =&gt; 2 );
say $h.^name;               # OUTPUT: «Hash␤»
say $h&lt;a&gt;;                  # OUTPUT: «1␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果一个或多个值引用主题变量$ _，则赋值的右侧将被解释为<a href="https://docs.raku.org/type/Block">块</a>，而不是哈希：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @people = [
    %( id =&gt; "1A", firstName =&gt; "Andy", lastName =&gt; "Adams" ),
    %( id =&gt; "2B", firstName =&gt; "Beth", lastName =&gt; "Burke" ),
    # ...
];

sub lookup-user (Hash $h) { #`(Do something...) $h }

my @names = map {
    # While this creates a hash:
    my  $query = { name =&gt; "$person&lt;firstName&gt; $person&lt;lastName&gt;" };
    say $query.^name;      # OUTPUT: «Hash␤»

    # Doing this will create a Block. Oh no!
    my  $query2 = { name =&gt; "$_&lt;firstName&gt; $_&lt;lastName&gt;" };
    say $query2.^name;       # OUTPUT: «Block␤»
    say $query2&lt;name&gt;;       # fails

    CATCH { default { put .^name, ': ', .Str } };
    # OUTPUT: «X::AdHoc: Type Block does not support associative indexing.␤»
    lookup-user($query);   # Type check failed in binding $h; expected Hash but got Block
}, @people;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用了％（）哈希构造函数，则可以避免这种情况。仅使用花括号来创建块。</p>
</div>
</div>
<div class="sect2">
<h3 id="_hash_切片">46.4. Hash 切片</h3>
<div class="paragraph">
<p>您可以使用切片同时分配多个键。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h; %h&lt;a b c&gt; = 2 xx *; %h.perl.say;  # OUTPUT: «{:a(2), :b(2), :c(2)}␤»
my %h; %h&lt;a b c&gt; = ^3;     %h.perl.say;  # OUTPUT: «{:a(0), :b(1), :c(2)}␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_非字符串键对象哈希">46.5. 非字符串键（对象哈希）</h3>
<div class="paragraph">
<p>默认情况下，{} 中的键被强制为字符串。要使用非字符串键组合散列，请使用冒号前缀：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $when = :{ (now) =&gt; "Instant", (DateTime.now) =&gt; "DateTime" };</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，将对象作为键，您通常无法使用&lt;&#8230;&#8203;&gt;构造进行键查找，因为它只创建字符串和同形异义。请改用{&#8230;&#8203;}：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">:{  0  =&gt; 42 }&lt;0&gt;.say;   # Int    as key, IntStr in lookup; OUTPUT: «(Any)␤»
:{  0  =&gt; 42 }{0}.say;   # Int    as key, Int    in lookup; OUTPUT: «42␤»
:{ '0' =&gt; 42 }&lt;0&gt;.say;   # Str    as key, IntStr in lookup; OUTPUT: «(Any)␤»
:{ '0' =&gt; 42 }{'0'}.say; # Str    as key, Str    in lookup; OUTPUT: «42␤»
:{ &lt;0&gt; =&gt; 42 }&lt;0&gt;.say;   # IntStr as key, IntStr in lookup; OUTPUT: «42␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意：Rakudo实现目前错误地对{}应用与{}相同的规则，并且可以在某些情况下构造块。为避免这种情况，您可以直接实例化参数化哈希。还支持％-sigiled变量的参数化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Num %foo1      = "0" =&gt; 0e0; # Str keys and Num values
my     %foo2{Int} =  0  =&gt; "x"; # Int keys and Any values
my Num %foo3{Int} =  0  =&gt; 0e0; # Int keys and Num values
Hash[Num,Int].new: 0, 0e0;      # Int keys and Num values</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，如果您要定义一个哈希来保存您正在使用的对象作为您提供给哈希用作键的确切对象的键，那么对象哈希就是您要查找的内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %intervals{Instant};
my $first-instant = now;
%intervals{ $first-instant } = "Our first milestone.";
sleep 1;
my $second-instant = now;
%intervals{ $second-instant } = "Logging this Instant for spurious raisins.";
for %intervals.sort -&gt; (:$key, :$value) {
    state $last-instant //= $key;
    say "We noted '$value' at $key, with an interval of {$key - $last-instant}";
    $last-instant = $key;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例使用仅接受Instant类型的键的对象哈希来实现基本但类型安全的日志记录机制。我们利用一个命名的状态变量来跟踪前一个Instant，以便我们可以提供一个间隔。</p>
</div>
<div class="paragraph">
<p>对象哈希的整个要点是将密钥保持为对象本身。当前对象散列利用对象的WHICH方法，该方法返回每个可变对象的唯一标识符。这是对象标识运算符（===）所依赖的基石。顺序和容器在这里真的很重要，因为.keys的顺序是未定义的，一个匿名列表永远不会===到另一个。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %intervals{Instant};
my $first-instant = now;
%intervals{ $first-instant } = "Our first milestone.";
sleep 1;
my $second-instant = now;
%intervals{ $second-instant } = "Logging this Instant for spurious raisins.";
say ($first-instant, $second-instant) ~~ %intervals.keys;       # OUTPUT: «False␤»
say ($first-instant, $second-instant) ~~ %intervals.keys.sort;  # OUTPUT: «False␤»
say ($first-instant, $second-instant) === %intervals.keys.sort; # OUTPUT: «False␤»
say $first-instant === %intervals.keys.sort[0];                 # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于Instant定义了自己的比较方法，因此在我们的示例中，根据cmp的排序将始终提供最早的即时对象作为它返回的List中的第一个元素。</p>
</div>
<div class="paragraph">
<p>如果您想接受哈希中的任何对象，可以使用Any！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h{Any};
%h{(now)} = "This is an Instant";
%h{(DateTime.now)} = "This is a DateTime, which is not an Instant";
%h{"completely different"} = "Monty Python references are neither DateTimes nor Instants";</code></pre>
</div>
</div>
<div class="paragraph">
<p>有一种更简洁的语法，它使用绑定。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h := :{ (now) =&gt; "Instant", (DateTime.now) =&gt; "DateTime" };</code></pre>
</div>
</div>
<div class="paragraph">
<p>绑定是必要的，因为对象哈希是关于非常可靠的特定对象，这是绑定在跟踪哪些任务并不关心哪些很好的事情。</p>
</div>
</div>
<div class="sect2">
<h3 id="_约束值类型">46.6. 约束值类型</h3>
<div class="paragraph">
<p>在声明符和名称之间放置一个类型对象，以约束哈希值的所有值的类型。使用具有where子句的约束的子集。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset Powerful of Int where * &gt; 9000;
my Powerful %h{Str};
put %h&lt;Goku&gt;   = 9001;
try {
    %h&lt;Vegeta&gt; = 900;
    CATCH { when X::TypeCheck::Binding { .message.put } }
}

# OUTPUT:
# 9001
# Type check failed in binding assignval; expected Powerful but got Int (900)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_循环哈希键和值">46.7. 循环哈希键和值</h3>
<div class="paragraph">
<p>处理散列中元素的常用习惯是循环键和值，例如，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %vowels = 'a' =&gt; 1, 'e' =&gt; 2, 'i' =&gt; 3, 'o' =&gt; 4, 'u' =&gt; 5;
for %vowels.kv -&gt; $vowel, $index {
  "$vowel: $index".say;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>给出与此类似的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a: 1
e: 2
o: 4
u: 5
i: 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用kv方法从散列中提取键及其各自的值，以便我们可以将这些值传递给循环。</p>
</div>
<div class="paragraph">
<p>请注意，不能依赖打印的键和值的顺序;对于同一程序的不同运行，散列的元素并不总是以相同的方式存储在内存中。事实上，从版本2018.05开始，订单在每次调用时都保证不同。有时人们希望处理排序的元素，例如哈希的键。如果有人希望按字母顺序打印元音列表，那么就会写一个</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %vowels = 'a' =&gt; 1, 'e' =&gt; 2, 'i' =&gt; 3, 'o' =&gt; 4, 'u' =&gt; 5;
for %vowels.sort(*.key)&gt;&gt;.kv -&gt; ($vowel, $index) {
  "$vowel: $index".say;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>打印</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a: 1
e: 2
i: 3
o: 4
u: 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>按字母顺序排列。为了达到这个结果，我们按键（％vowels.sort（* .key））对元音的哈希值进行排序，然后通过将.kv方法应用于每个元素，通过一元&gt;&gt; superroperator生成元数据和值。键/值列表的列表。为了提取键/值，变量因此需要包含在括号中。</p>
</div>
<div class="paragraph">
<p>另一种解决方案是展平结果列表。然后可以使用与.kv相同的方式访问键/值对：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %vowels = 'a' =&gt; 1, 'e' =&gt; 2, 'i' =&gt; 3, 'o' =&gt; 4, 'u' =&gt; 5;
for %vowels.sort(*.key)&gt;&gt;.kv.flat -&gt; $vowel, $index {
  "$vowel: $index".say;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用解构来循环哈希。</p>
</div>
</div>
<div class="sect2">
<h3 id="_就地编辑值">46.8. 就地编辑值</h3>
<div class="paragraph">
<p>有时您可能希望在迭代时修改哈希值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %answers = illuminatus =&gt; 23, hitchhikers =&gt; 42;
# OUTPUT: «hitchhikers =&gt; 42, illuminatus =&gt; 23»
for %answers.values -&gt; $v { $v += 10 }; # Fails
CATCH { default { put .^name, ': ', .Str } };
# OUTPUT: «X::AdHoc: Cannot assign to a readonly variable or a value␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>传统上，这是通过发送密钥和值来完成的，如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %answers = illuminatus =&gt; 23, hitchhikers =&gt; 42;
for %answers.kv -&gt; $k,$v { %answers{$k} = $v + 10 };</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，可以利用块的签名来指定您希望对值进行读写访问。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %answers = illuminatus =&gt; 23, hitchhikers =&gt; 42;
for %answers.values -&gt; $v is rw { $v += 10 };</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，即使在对象哈希的情况下，也不可能进行哈希键的就地编辑。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_输入和输出全解">47. 输入和输出全解</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_基础知识">47.1. 基础知识</h3>
<div class="paragraph">
<p>绝大多数常见的 IO 工作都是由<a href="https://docs.raku.org/type/IO::Path">IO::Path</a>类型完成的。如果您想以某种形式或形状读取或写入文件，这就是您想要的类。它抽象出文件句柄（或“文件描述符”）的细节，因此你甚至不必考虑它们。</p>
</div>
<div class="paragraph">
<p>在幕后，<a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 与 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 一起使用 ; 一个你可以直接使用的类，如果你需要比 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 提供的更多控制。当与其他进程，例如通过 <a href="https://docs.raku.org/type/Proc">Proc</a> 或 <a href="https://docs.raku.org/type/Proc::Async">Proc::Async</a>类型，您还可以处理<a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 的*子类*：在<a href="https://docs.raku.org/type/IO::Pipe">IO::Pipe</a>。</p>
</div>
<div class="paragraph">
<p>最后，你有 <a href="https://docs.raku.org/type/IO::CatHandle">IO::CatHandle</a>，以及 <a href="https://docs.raku.org/type/IO::Spec">IO::Spec</a> 及其子类，你很少直接使用它们。这些类为您提供了高级功能，例如将多个文件作为一个句柄进行操作，或者进行低级路径操作。</p>
</div>
<div class="paragraph">
<p>除了所有这些类之外，Raku 还提供了几个子程序，可以让您间接使用这些类。如果您喜欢函数式编程风格或 Raku  单行程序，这些就派上用场了。</p>
</div>
<div class="paragraph">
<p>虽然 <a href="https://docs.raku.org/type/IO::Socket">IO::Socket</a> 及其子类也与输入和输出有关，但本指南并未涵盖它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="_导航路径">47.2. 导航路径</h3>
<div class="sect3">
<h4 id="_whats_an_iopath_anyway">47.2.1. What&#8217;s an IO::Path anyway?</h4>
<div class="paragraph">
<p>要将路径表示为文件或目录，请使用 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 类型。获取该类型对象的最简单方法是通过在它身上调用 <a href="https://docs.raku.org/routine/IO"><code>.IO</code></a> 方法强制将 <a href="https://docs.raku.org/type/Str">Str</a> 类型转为路径类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'my-file.txt'.IO; # OUTPUT: «"my-file.txt".IO␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>看起来这里似乎缺少某些东西 - 没有卷或绝对路径 - 但该信息实际上存在于对象中。你可以通过使用 <a href="https://docs.raku.org/routine/perl"><code>.perl</code></a> 方法看到它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'my-file.txt'.IO.perl;
# OUTPUT: «IO::Path.new("my-file.txt", :SPEC(IO::Spec::Unix), :CWD("/home/camelia"))␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这两个额外的属性 - <code>SPEC</code> 和 - <code>CWD</code> 指定路径应该使用的操作系统语义类型以及路径的“当前工作目录”，即如果它是相对路径，则它相对于该目录。</p>
</div>
<div class="paragraph">
<p>这意味着无论你如何制作一个路径，<a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 对象在技术上总是指一个绝对路径。这就是它的 <a href="https://docs.raku.org/routine/absolute"><code>.absolute</code></a> 和 <a href="https://docs.raku.org/routine/relative"><code>.relative</code></a> 方法返回 <a href="https://docs.raku.org/type/Str">Str</a> 对象的原因，它们是字符串化路径的正确方法。</p>
</div>
<div class="paragraph">
<p>但是，不要急于将任何东西字符串化起来。将路径作为 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 对象传递。在路径上运行的所有例程都可以处理它们，因此不需要转换它们。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_working_with_files">47.3. Working with files</h3>
<div class="sect3">
<h4 id="_writing_into_files">47.3.1. Writing into files</h4>

</div>
<div class="sect3">
<h4 id="_writing_new_content">47.3.2. Writing new content</h4>
<div class="paragraph">
<p>让我们制作一些文件并从中写入和读取数据！<a href="https://docs.raku.org/routine/spurt"><code>spurt</code></a> 和 <a href="https://docs.raku.org/routine/slurp"><code>slurp</code></a> 程序写和读取一块儿数据。除非您正在处理难以完全存储在内存中的非常大的文件，否则这两个例程都适合您。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">"my-file.txt".IO.spurt: "I ♥ Perl!";</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码在当前目录中创建了一个名为 <code>my-file.txt</code> 的文件，然后将文本 <code>I ♥ Perl!</code> 写入其中。如果 Raku 是您的第一语言，请庆祝您任务完成了！尝试打开您使用其他程序创建的文件，以验证您使用程序编写的内容。如果您已经了解其他语言，您可能想知道本指南是否遗漏了处理编码或错误条件等问题。</p>
</div>
<div class="paragraph">
<p>但是，这就是您需要的所有代码。默认情况下，字符串将按 <code>utf-8</code> 编码进行编码，并通过 <a href="https://docs.raku.org/type/Failure">Failure</a> 机制处理错误：这些是您可以使用常规条件处理的异常。在这种情况下，我们会让所有潜在的 <a href="https://docs.raku.org/type/Failure">Failures</a> 在调用之后陷入沉没，因此它们包含的任何<a href="https://docs.raku.org/type/Exception">异常</a>都将被抛出。</p>
</div>
</div>
<div class="sect3">
<h4 id="_追加内容">47.3.3. 追加内容</h4>
<div class="paragraph">
<p>如果您想在我们在上一节中创建的文件中添加更多内容，您可以注意 <a href="https://docs.raku.org/routine/spurt"><code>spurt</code></a> 文档中提到的 <code>:append</code> 参数。但是，为了更好地控制，让我们自己使用 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 来处理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $fh = 'my-file.txt'.IO.open: :a;
$fh.print: "I count: ";
$fh.print: "$_ " for ^10;
$fh.close;</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/routine/open"><code>.open</code></a> 方法调用打开我们的 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a>，并返回一个 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a>。我们把 <code>:a</code> 作为参数传递，表示我们想要以追加模式打开文件。</p>
</div>
<div class="paragraph">
<p>在接下来的两行代码中，我们使用 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 上的 <a href="https://docs.raku.org/routine/print"><code>.print</code></a> 常用方法打印包含 11 个文本（<code>'I count: '</code> 字符串和 10 个数字）的文本行。请注意，<a href="https://docs.raku.org/type/Failure">Failure</a> 机制再一次负责我们的所有错误检查。如果 <a href="https://docs.raku.org/routine/open"><code>.open</code></a> 失败，它将返回一个 <a href="https://docs.raku.org/type/Failure">Failure</a>，当我们尝试在其上调用 <a href="https://docs.raku.org/routine/print"><code>.print</code></a> 方法时将抛出异常。</p>
</div>
<div class="paragraph">
<p>最后，我们通过调用它上面的 <a href="https://docs.raku.org/routine/close"><code>.close</code></a> 方法来关闭 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a>。这样*做很重要*，特别是在大型程序或处理大量文件的程序中，因为许多系统对程序可以同时打开的文件数量有限制。如果您没有关闭句柄，最终您将达到该限制并且 <a href="https://docs.raku.org/routine/open"><code>.open</code></a> 调用将失败。请注意，与其他一些语言不同，Raku 不使用引用计数，因此当离开所定义的作用域时，文件句柄<strong>不会关闭</strong>。只有当它们被垃圾收集并且未能关闭句柄时，它们才会被关闭，这可能会导致程序在打开的句柄有机会在垃圾回收*之前*达到文件限制。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_从文件中读取">47.4. 从文件中读取</h3>
<div class="sect3">
<h4 id="_使用_iopath">47.4.1. 使用 IO::Path</h4>
<div class="paragraph">
<p>我们在前面的章节中已经看到，在文件中写东西是 Raku 中的单行代码。从它们中读取，同样容易：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'my-file.txt'.IO.slurp;        # OUTPUT: «I ♥ Perl!␤»
say 'my-file.txt'.IO.slurp: :bin;  # OUTPUT: «Buf[uint8]:0x&lt;49 20 e2 99 a5 20 50 65 72 6c 21&gt;␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/routine/slurp"><code>.slurp</code></a> 方法读取文件的全部内容并将其作为单个 <a href="https://docs.raku.org/type/Str">Str</a> 对象返回，如果请求二进制模式，则通过指定 <code>:bin</code> 命名参数将其作为 <a href="https://docs.raku.org/type/Buf">Buf</a> 对象返回。</p>
</div>
<div class="paragraph">
<p>由于 <a href="https://docs.raku.org/routine/slurp">slurping</a> 将整个文件加载到内存中，因此它不适合处理大文件。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 类型提供了另外两种方便的方法：<a href="https://docs.raku.org/type/IO::Path#method_words"><code>.words</code></a> 与 <a href="https://docs.raku.org/type/IO::Path#method_lines"><code>.lines</code></a>，这俩方法惰性地读取小块文件并返回（默认）不保留已消耗值的<a href="https://docs.raku.org/type/Seq">Seq</a> 对象。</p>
</div>
<div class="paragraph">
<p>这是一个示例，它在文本文件中查找提及 Perl 的行并将其打印出来。尽管文件本身太大而无法容纳到可用的<a href="https://en.wikipedia.org/wiki/Random-access_memory">RAM</a> 中，但程序运行时不会出现任何问题，因为内容是以小块的形式处理的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for '500-PetaByte-File.txt'.IO.lines.grep: *.contains: 'Perl';</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是另一个打印文件中前 100 个单词的示例，没有完全加载它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say for '500-PetaByte-File.txt'.IO.words: 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，我们通过传递 limit 参数给 <a href="https://docs.raku.org/type/IO::Path#method_words"><code>.words</code></a>而不是使用<a href="https://docs.raku.org/language/operators#index-entry-array_indexing_operator-array_subscript_operator-array_indexing_operator">列表索引操作</a> 来完成此操作。原因是在于底层仍然使用文件句柄，并且在完全使用返回的 <a href="https://docs.raku.org/type/Seq">Seq</a> 之前，句柄将保持打开状态。如果没有引用 <a href="https://docs.raku.org/type/Seq">Seq</a>，最终句柄将在垃圾收集运行期间关闭，但在大型程序中使用大量文件时，最好确保所有句柄立即关闭。所以，你应该始终确保 <a href="https://docs.raku.org/type/Seq">Seq</a> 从<a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 的 <a href="https://docs.raku.org/type/IO::Path#method_words"><code>.words</code></a> 和 <a href="https://docs.raku.org/type/IO::Path#method_lines"><code>.lines</code></a> 方法是<a href="https://docs.raku.org/language/glossary#index-entry-Reify">完全具体化</a> ; 而 limit 参数可以帮助你。</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_iohandle">47.4.2. Using IO::Handle</h4>
<div class="paragraph">
<p>当然，您可以使用 <a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 类型从文件中读取，这样可以更好地控制您正在执行的操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given 'some-file.txt'.IO.open {
    say .readchars: 8;  # OUTPUT: «I ♥ Perl␤»
    .seek: 1, SeekFromCurrent;
    say .readchars: 15;  # OUTPUT: «I ♥ Programming␤»
    .close
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/IO::Handle">IO::Handle</a> 给你 <a href="https://docs.raku.org/type/IO::Handle#method_read">.read</a>，<a href="https://docs.raku.org/type/IO::Handle#method_readchars">.readchars</a>，<a href="https://docs.raku.org/type/IO::Handle#routine_get">.get</a>，<a href="https://docs.raku.org/type/IO::Handle#method_getc">.getc</a>，<a href="https://docs.raku.org/type/IO::Handle#routine_words">.words</a>，<a href="https://docs.raku.org/type/IO::Handle#routine_lines">.lines</a>，<a href="https://docs.raku.org/type/IO::Handle#routine_slurp">.slurp</a>，<a href="https://docs.raku.org/type/IO::Handle#method_comb">.comb</a>，<a href="https://docs.raku.org/type/IO::Handle#method_split">.split</a> 和 <a href="https://docs.raku.org/type/IO::Handle#method_Supply">.Supply</a> 方法从中读取数据。有很多选择; 当你读取完时，需要关闭句柄。</p>
</div>
<div class="paragraph">
<p>与某些语言不同，当离开定义的作用域时，句柄不会自动关闭。相反，它将保持打开，直到被垃圾回收为止。为了使关闭更容易，一些方法允许您指定 <code>:close</code> 参数，您还可以使用 <a href="https://docs.raku.org/language/phasers#index-entry-will_trait"><code>will leave</code></a> trait 或 <a href="https://modules.raku.org/dist/Trait::IO"><code>Trait::IO</code></a> 模块提供的 <code>does auto-close</code> trait。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_错误的做事方法">47.5. 错误的做事方法</h3>
<div class="paragraph">
<p>本节介绍如何不执行 Raku IO。</p>
</div>
<div class="sect3">
<h4 id="_别去管_spec">47.5.1. 别去管 $*SPEC</h4>
<div class="paragraph">
<p>您可能听说过 <a href="https://docs.raku.org/language/variables#Dynamic_variables"><code>$*SPEC</code></a> 并看到过一些代码或书籍显示其用于拆分和连接路径片段的用法。它提供的一些例程名称甚至可能看起来与您在其他语言中使用的名称相似。</p>
</div>
<div class="paragraph">
<p>但是，除非您正在编写自己的 IO 框架，否则几乎不需要直接使用 <a href="https://docs.raku.org/language/variables#Dynamic_variables"><code>$*SPEC</code></a>。<a href="https://docs.raku.org/language/variables#Dynamic_variables"><code>$*SPEC</code></a> 提供低级别的东西，它的使用不仅会使你的代码难以阅读，你可能会引入安全问题（例如空字符）！</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/IO::Path"><code>IO::Path</code></a> 类型是 Raku 世界的主力。它满足所有路径操作需求，并提供快捷例程，让您避免处理文件句柄。用它而不是 <a href="https://docs.raku.org/language/variables#Dynamic_variables"><code>$*SPEC</code></a> 这样的东西。</p>
</div>
<div class="paragraph">
<p>提示：您可以使用 <code>/</code> 连接路径部分并将其提供给 <a href="https://docs.raku.org/type/IO::Path"><code>IO::Path</code></a> 例程; 无论操作系统如何，他们仍然可以做正确的事情。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># WRONG!! TOO MUCH WORK!
my $fh = open $*SPEC.catpath: '', 'foo/bar', $file;
my $data = $fh.slurp;
$fh.close;
# RIGHT! Use IO::Path to do all the dirty work
my $data = 'foo/bar'.IO.add($file).slurp;</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，将它用于 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a> 无法提供的东西是很好的。例如，<a href="https://docs.raku.org/routine/devnull"><code>.devnull</code></a> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    temp $*OUT = open :w, $*SPEC.devnull;
    say "In space no one can hear you scream!";
}
say "Hello";</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_字符串化_iopath">47.6. 字符串化 IO::Path</h3>
<div class="paragraph">
<p>不要使用 <code>.Str</code> 方法对 <a href="https://docs.raku.org/type/IO::Path"><code>IO::Path</code></a> 对象进行字符串化，除非您只是想将它们显示在某个地方以供参考或使用。<code>.Str</code> 方法返回 <a href="https://docs.raku.org/type/IO::Path"><code>IO::Path</code></a> 实例化的任何基本路径字符串。它不考虑 <a href="https://docs.raku.org/type/IO::Path#attribute_CWD"><code>$.CWD</code></a> 属性的值。例如，此代码已损坏：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $path = 'foo'.IO;
chdir 'bar';
# WRONG!! .Str DOES NOT USE $.CWD!
run &lt;tar -cvvf archive.tar&gt;, $path.Str;</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/routine/chdir"><code>chdir</code></a> 调用更改了当前目录的值，但我们创建的  <code>$path</code> 是相对于该更改之前的目录。</p>
</div>
<div class="paragraph">
<p>但是，<a href="https://docs.raku.org/type/IO::Path"><code>IO::Path</code></a> 对象*确实*知道它相对于哪个目录。我们只需要使用 <a href="https://docs.raku.org/routine/absolute"><code>.absolute</code></a> 或 <a href="https://docs.raku.org/routine/relative"><code>.relative</code></a> 来字符串化对象。两个例程都返回一个 <a href="https://docs.raku.org/type/Str"><code>Str</code></a> 对象; 它们不同之处在于结果是绝对路径还是相对路径。所以，我们可以像这样修复我们的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $path = 'foo'.IO;
chdir 'bar';
# RIGHT!! .absolute does consider the value of $.CWD!
run &lt;tar -cvvf archive.tar&gt;, $path.absolute;
# Also good:
run &lt;tar -cvvf archive.tar&gt;, $path.relative;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_注意_cwd">47.6.1. 注意 $*CWD</h4>
<div class="paragraph">
<p>虽然通常不在视线范围内，但默认情况下，每个 <a href="https://docs.raku.org/type/IO::Path"><code>IO::Path</code></a> 对象都使用 <a href="https://docs.raku.org/language/variables#Dynamic_variables"><code>$*CWD</code></a> 的当前值来设置其 <a href="https://docs.raku.org/type/IO::Path#attribute_CWD">`$.CWD`属性</a>。这意味着有两件事需要注意。</p>
</div>
</div>
<div class="sect3">
<h4 id="_temp_the_cwd">47.6.2. temp the $*CWD</h4>
<div class="paragraph">
<p>这段代码是错误的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># WRONG!!
my $*CWD = "foo".IO;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>my $*CWD</code> 让 <a href="https://docs.raku.org/language/variables#Dynamic_variables"><code>$*CWD</code></a> 变为未定义的。然后 <a href="https://docs.raku.org/routine/IO"><code>.IO</code></a> coercer 继续并将其正创建的路径的<a href="https://docs.raku.org/type/IO::Path#attribute_CWD"><code>$.CWD</code></a> 属性设置为 undefined 的 <code>$*CWD</code> 字符串化版本 ; 一个空字符串。</p>
</div>
<div class="paragraph">
<p>执行此操作的正确方法是使用 <a href="https://docs.raku.org/routine/temp"><code>temp</code></a> 而不是 <code>my</code>。它会将 <a href="https://docs.raku.org/language/variables#Dynamic_variables"><code>$*CWD</code></a> 的更改效果本地化，就像 <code>my</code> 那样，但它不会使其未定义，因此 <a href="https://docs.raku.org/routine/IO"><code>.IO</code></a> coercer 仍将获得正确的旧值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">temp $*CWD = "foo".IO;</code></pre>
</div>
</div>
<div class="paragraph">
<p>更好的是，如果要在本地化的 <a href="https://docs.raku.org/language/variables#Dynamic_variables"><code>$*CWD</code></a> 中执行某些代码，请使用该<a href="https://docs.raku.org/routine/indir"><code>indir</code></a> 例程。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_列表序列和数组">48. 列表、序列和数组</h2>
<div class="sectionbody">
<div class="paragraph">
<p>列表一直是计算机的核心部分，因为之前有计算机，在这段时间里，许多恶魔占据了他们的细节。 它们实际上是 Raku 设计中最难的部分之一，但是通过坚持和耐心，Raku 已经使用了一个优雅的系统来处理它们。</p>
</div>
<div class="sect2">
<h3 id="_literal_lists">48.1. Literal Lists</h3>
<div class="paragraph">
<p>字面上的<a href="https://docs.raku.org/type/List">列表</a>用逗号和分号不是用圆括号创建，因此：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1, 2        # This is two-element list
(1, 2)      # This is also a List, in parentheses
(1; 2)      # same List
(1)         # This is not a List, just a 1 in parentheses
(1,)        # This is a one-element List</code></pre>
</div>
</div>
<div class="paragraph">
<p>括号可用于标记`列表`的开头和结尾，因此：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1, 2), (1, 2) # This is a list of two lists.</code></pre>
</div>
</div>
<div class="paragraph">
<p>多维字面上的`列表`是通过逗号和分号组合而成的。 它们可以在常规参数列表和下标中使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so (1,2; 3,4) eqv ((1,2), (3,4));
# OUTPUT«True␤»
say('foo';); # a list with one element and the empty list
# OUTPUT«(foo)()␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>单个元素可以使用下标从列表中拉出。 列表的第一个元素的索引号为零：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, 2)[0];   # says 1
say (1, 2)[1];   # says 2
say (1, 2)[2];   # says Nil
say (1, 2)[-1];  # Error
say (1, 2)[*-1]; # 2</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_sigil">48.2. The @ sigil</h3>
<div class="paragraph">
<p>Raku 中名称为 @ 符号的变量应该包含某种类似列表的对象。 当然，其他变量也可能包含这些对象，但是 <code>@-sigiled</code> 变量总是这样，并且期望它们作用于该部分。</p>
</div>
<div class="paragraph">
<p>默认情况下，当您将`列表`分配给 <code>@-sigiled</code> 变量时，您将创建一个`数组`。 这些在下面描述。 如果你想把一个真实的的 <code>List</code> 放到一个 @ -sigiled 变量中，你可以用 <code>:=</code> 绑定代替。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a := 1, 2, 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>将列表的列表赋值给 @-sigiled 变量不提供相同的快捷方式。 在这种情况下，外部 List 成为数组的第一个元素。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = (1,2; 3,4);
say @a.flat;
# OUTPUT«((1 2) (3 4))␤»
@a := (1,2; 3,4);
say @a.flat;
# OUTPUT«((1 2 3 4)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>@_sigiled 变量像列表一样的方式之一是总是支持<a href="https://docs.raku.org/language/subscripts">位置下标</a>。 任何绑定到 @-sigiled 值的东西都必须支持 <a href="https://docs.raku.org/type/Positional">Positional</a> 角色，这保证了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a := 1;  # Type check failed in binding; expected Positional but got Int

# 但是
my @a := 1,; # (1)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reset_a_list_container">48.3. Reset a List Container</h3>
<div class="paragraph">
<p>要从 Positional 容器中删除所有元素，请将 <a href="https://docs.raku.org/type/Slip#Empty">Empty</a>，空列表 <code>()</code> 或空列表的 <code>Slip</code> 赋值给容器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 2, 3;
@a = ();
@a = Empty;
@a = |();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_iteration">48.4. Iteration</h3>
<div class="paragraph">
<p>所有的列表都可以被迭代，这意味着从列表中按顺序拿出每个元素并在最后一个元素之后停止：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 1, 2, 3 { .say } # says 1, then says 2, then says 3</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_testing_for_elements">48.5. Testing for Elements</h3>
<div class="paragraph">
<p>要测试元素将 <code>List</code> 或 <code>Array</code> 转换为 <a href="https://docs.raku.org/type/Set">Set</a> 或使用 Set <a href="https://docs.raku.org/language/setbagmix">运算符</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = &lt;foo bar buzz&gt;;
say @a.Set&lt;bar buzz&gt;; # (True True)
say so 'bar' ∈ @a;   # True</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_sequences">48.5.1. Sequences</h4>
<div class="paragraph">
<p>不是所有的列表生来都充满元素。 有些只创建他们被要求的尽可能多的元素。 这些称为序列，其类型为 <code>Seq</code>。 因为这样发生，循环返回 <code>Seqs</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(loop { 42.say })[2] # says 42 three times</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以，在 Raku 中有无限列表是很好的，只要你从不问他们所有的元素。 在某些情况下，你可能希望避免询问它们有多长 - 如果 Raku 知道一个序列是无限的，它将尝试返回 <code>Inf</code>，但它不能总是知道。</p>
</div>
<div class="paragraph">
<p>虽然 <code>Seq</code> 类确实提供了一些位置下标，但它不提供 Positional 的完整接口，因此 @-sigiled 变量可能不会绑定到 <code>Seq</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @s := (loop { 42.say }); # Error expected Positional but got Seq</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是因为 <code>Seq</code> 在使用它们之后不会保留值。 这是有用的行为，如果你有一个很长的序列，因为你可能想在使用它们之后丢弃值，以便你的程序不会填满内存。 例如，当处理一个百万行的文件时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for 'filename'.IO.lines -&gt; $line {
    do-something-with($line);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以确信文件的整个内容不会留在内存中，除非你明确地存储某个地方的行。</p>
</div>
<div class="paragraph">
<p>另一方面，在某些情况下，您可能希望保留旧值。 可以在`列表`中隐藏一个 <code>Seq</code>，它仍然是惰性的，但会记住旧的值。 这是通过调用 <code>.list</code> 方法完成的。 由于此`列表`完全支持 <code>Positional</code>，因此可以将其直接绑定到 @-sigiled 变量上。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @s := (loop { 42 }).list;
@s[2]; # Says 42 three times
@s[1]; # does not say anything
@s[4]; # Says 42 two more times</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用 <code>.cache</code> 方法代替 <code>.list</code>，这取决于您希望处理引用的方式。 有关详细信息，请参阅 <a href="https://docs.raku.org/type/Seq">Seq</a> 上的页面。</p>
</div>
</div>
<div class="sect3">
<h4 id="_slips">48.5.2. Slips</h4>
<div class="paragraph">
<p>有时候你想把一个列表的元素插入到另一个列表中。 这可以通过一个称为 <a href="https://docs.raku.org/type/Slip">Slip</a> 的特殊类型的列表来完成。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, (2, 3), 4) eqv (1, 2, 3, 4);         # says False
say (1, Slip.new(2, 3), 4) eqv (1, 2, 3, 4); # says True
say (1, slip(2, 3), 4) eqv (1, 2, 3, 4);     # also says True</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种方法是使用 <code>|</code> 前缀运算符。 注意，这有一个比逗号更严格的优先级，所以它只影响一个单一的值，但不像上面的选项，它会打碎<a href="https://docs.raku.org/type/Scalar">标量</a>。而 <code>slip</code> 不会。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, |(2, 3), 4) eqv (1, 2, 3, 4);        # says True
say (1, |$(2, 3), 4) eqv (1, 2, 3, 4);       # also says True
say (1, slip($(2, 3)), 4) eqv (1, 2, 3, 4);  # says False</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lazy_lists">48.6. Lazy Lists</h3>
<div class="paragraph">
<p>列表可以是惰性的，这意味着它们的值是根据需要计算的，并且存储供以后使用。 要创建惰性列表，请使用 <a href="https://docs.raku.org/language/control#gather%2Ftake">gather/take</a> 或<a href="https://docs.raku.org/language/operators#infix_&#8230;&#8203;">序列运算符</a>。 您还可以编写一个实现 <a href="https://docs.raku.org/type/Iterable">Iterable</a> 角色的类，并在调用 <a href="https://docs.raku.org/routine/lazy">lazy</a> 时返回 <code>True</code>。 请注意，某些方法（如 <code>elems</code>）可能会导致整个列表计算失败，如果列表也是无限的。无限列表没办法知道它的元素个数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @l = 1,2,4,8...Inf;
say @l[0..16];
# OUTPUT«(1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768 65536)␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_immutability">48.7. Immutability</h3>
<div class="paragraph">
<p>到目前为止我们谈论的列表（<code>List</code>，<code>Seq</code> 和 <code>Slip</code>）都是不可变的。 这意味着您不能从中删除元素，或重新绑定现有元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(1, 2, 3)[0]:delete; # Error Can not remove elements from a List
(1, 2, 3)[0] := 0;   # Error Cannot use bind operator with this left-hand side
(1, 2, 3)[0] = 0;    # Error Cannot modify an immutable Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果任何元素包裹在<a href="https://docs.raku.org/type/Scalar">标量</a>中，您仍然可以更改 <code>Scalar</code> 指向的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 2;
(1, $a, 3)[1] = 42;
$a.say;            # says 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;就是说，它只是列表结构本身 - 有多少个元素和每个元素的标识 - 是不可变的。 不变性不是通过元素的身份传染。</p>
</div>
</div>
<div class="sect2">
<h3 id="_list_contexts">48.8. List Contexts</h3>
<div class="paragraph">
<p>到目前为止，我们主要是在中立语境下处理列表。 实际上列表在语法层面上上下文非常敏感。</p>
</div>
<div class="sect3">
<h4 id="_list_assignment_context">48.8.1. List Assignment Context</h4>
<div class="paragraph">
<p>当一个列表出现在赋值给 @-sigiled 变量的右边时，它被“热切地”计算。 这意味着 <code>Seq</code> 将被迭代，直到它不能产生更多的元素。 这是你不想放置无限列表的地方之一，免得你的程序挂起，最终耗尽内存：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $i = 3;
my @a = (loop { $i.say; last unless --$i }); # Says 3 2 1
say "take off!";</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_flattening_context">48.8.2. Flattening "Context"</h4>
<div class="paragraph">
<p>当您的列表包含子列表，但您只想要一个平面列表时，可以展平该列表以生成一系列值，就像所有的括号被删除了一样。 无论括号中有多少层次嵌套，这都可以工作。</p>
</div>
<div class="paragraph">
<p>请注意，列表周围的标量将使其免于扁平化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for (1, (2, $(3, 4)), 5).flat { .say } # says 1, then 2, then (3 4), then 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;但是一个 @-sigiled 变量将溢出它的元素。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @l := 2, (3, 4);
for (1, @l, 5).flat { .say };      # says 1, then 2, then 3, then 4, then 5
my @a = 2, (3, 4);                 # Arrays are special, see below
for (1, @a, 5).flat { .say };      # says 1, then 2, then (3 4), then 5</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_argument_list_capture_context">48.8.3. Argument List (Capture) Context</h4>
<div class="paragraph">
<p>当列表作为函数或方法调用的参数出现时，会使用特殊的语法规则：该列表立即转换为 <code>Capture</code>。 <code>Capture</code> 本身有一个 List（<code>.list</code>）和一个 Hash（<code>.hash</code>）。 任何键没有引号的 <code>Pair</code>，或者没有括号的 <code>Pair</code> 字面量，永远不会变成 <code>.list</code>。 相反，它们被认为是命名参数，并且压缩为 <code>.hash</code>。 有关此处理的详细信息，请参阅 <a href="https://docs.raku.org/type/Capture">Capture</a> 上的页面。</p>
</div>
<div class="paragraph">
<p>考虑从`列表`中创建新`数组`的以下方法。 这些方法将 <code>List</code> 放在参数列表上下文中，因此，<code>Array</code> 只包含 1 和 2，但不包含 <code>Pair :c(3)</code>，它被忽略。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Array.new(1, 2, :c(3));
Array.new: 1, 2, :c(3);
new Array: 1, 2, :c(3);</code></pre>
</div>
</div>
<div class="paragraph">
<p>相反，这些方法不会将  <code>List</code> 放置在参数列表上下文中，所以所有元素，甚至 <code>Pair :c(3)</code>，都放置在`数组`中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Array.new((1, 2, :c(3)));
(1, 2, :c(3)).Array;
my @a = 1, 2, :c(3); Array.new(@a);
my @a = 1, 2, :c(3); Array.new: @a;
my @a = 1, 2, :c(3); new Array: @a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在参数列表上下文中，应用于 <code>Positional</code> 上的 <code>|</code> 前缀运算符总是将列表元素slip为Capture的位置参数，而应用到 <code>Associative</code> 上的 <code>|</code> 前缀运算符会把 pairs 作为具名参数 slip 进来：</p>
</div>
<div class="paragraph">
<p>`raku
my @a := 2, "c" &#8658; 3;
Array.new(1, |@a, 4);    # Array contains 1, 2, :c(3), 4
my %a = "c" &#8658; 3;
Array.new(1, |%a, 4);    # Array contains 1, 4</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">==== Slice Indexing Context

从link:https://docs.raku.org/language/subscripts#Slices[切片下标] 中的 `List` 角度来看，只有一个显着的地方在于它是不可见的：因为一个切片的副词附在 `]` 后面，切片的内部**不是**参数列表，并且没有对 pair 形式的特殊处理 。

大多数 `Positional` 类型将对切片索引的每个元素强制执行整数强制，因此那儿出现的 pairs 将生成错误，无论如何：

```raku
(1, 2, 3)[1, 2, :c(3)] # Method 'Int' not found for invocant of class 'Pair'</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;但是这完全取决于类型 - 如果它定义了pairs的顺序，它可以考虑 <code>:c(3)</code> 是有效的索引。</p>
</div>
<div class="paragraph">
<p>切片内的索引通常不会自动展平，但是子列表通常不会强制为 <code>Int</code>。 相反，列表结构保持不变，从而导致在结果中重复结构的嵌套 slice 操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ("a", "b", "c")[(1, 2), (0, 1)] eqv (("b", "c"), ("a", "b")) # says True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_range_as_slice">48.8.4. Range as Slice</h4>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Range">Range</a> 是用于下边界和上边界的容器。 生成具有 <code>Range</code> 的切片将包括这些边界之间的任何索引，包括边界。 对于无限上限，我们同意数学家 <code>Inf</code> 等于 <code>Inf-1</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1..5;
say @a[0..2];     # (1 2 3)
say @a[0..^2];    # (1 2)
say @a[0..*];     # (1 2 3 4 5)
say @a[0..^*];    # (1 2 3 4 5)
say @a[0..Inf-1]; # (1 2 3 4 5)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_array_constructor_context">48.8.5. Array Constructor Context</h4>
<div class="paragraph">
<p>在数组字面量中，初始化值的列表不在捕获上下文中，只是一个正常的列表。 然而，正如在赋值中一样，急切地对它求值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[ 1, 2, :c(3) ] eqv Array.new((1, 2, :c(3))) # says True
[while $++ &lt; 2 { 42.say; 43 }].map: *.say;   # says 42 twice then 43 twice
(while $++ &lt; 2 { 42.say; 43 }).map: *.say;   # says "42" then "43"
                                             # then "42" then "43"</code></pre>
</div>
</div>
<div class="paragraph">
<p>它把我们带到数组这儿来。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_arrays">48.9. Arrays</h3>
<div class="paragraph">
<p>数组与列表在三个主要方面不同：它们的元素可以被类型化，它们自动列出它们的元素，并且它们是可变的。 否则，它们是列表，并且在列表所在的位置被接受。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Array ~~ List     # says True</code></pre>
</div>
</div>
<div class="paragraph">
<p>第四种更微妙的方式是，当使用数组时，有时可能更难以维持惰性或使用无限序列。</p>
</div>
<div class="sect3">
<h4 id="_typing">48.9.1. Typing</h4>
<div class="paragraph">
<p>数组可以被类型化，使得它们的槽在被赋值时执行类型检查。 只允许分配 <code>Int</code> 值的数组是 <code>Array[Int]</code> 类型，可以使用 <code>Array[Int].new</code> 创建一个数组。 如果你打算仅仅为了这个目的使用 @-sigiled 变量，你可以在声明它时通过指定元素的类型来改变它的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int @a = 1, 2, 3;              # An Array that contains only Ints
my @b := Array[Int].new(1, 2, 3); # Same thing, but the variable is not typed
say @b eqv @a;                    # says True.
my @c = 1, 2, 3;                  # An Array that can contain anything
say @b eqv @c;                    # says False because types do not match
say @c eqv (1, 2, 3);             # says False because one is a List
say @b eq @c;                     # says True, because eq only checks values
say @b eq (1, 2, 3);              # says True, because eq only checks values

@a[0] = 42;                       # fine
@a[0] = "foo";                    # error: Type check failed in assignment</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的例子中，我们将一个类型化的 Array 对象绑定到一个没有指定类型的 @-sigil 变量上。 另一种方法不工作 - 你不能绑定一个类型错误的数组到一个类型化的 @-sigiled 变量上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a := Array[Int].new(1, 2, 3);     # fine
@a := Array[Str].new("a", "b");       # fine, can be re-bound
my Int @b := Array[Int].new(1, 2, 3); # fine
@b := Array.new(1, 2, 3);             # error: Type check failed in binding</code></pre>
</div>
</div>
<div class="paragraph">
<p>当使用类型化数组时，重要的是要记住它们是名义类型的。 这意味着数组的声明类型是重要的。 给定以下子声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub mean(Int @a) {
    @a.sum / @a.elems
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>传递 <code>Array[Int]</code> 的调用将成功：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int @b = 1, 3, 5;
say mean(@b);                       # @b is Array[Int]
say mean(Array[Int].new(1, 3, 5));  # Anonymous Array[Int]
say mean(my Int @ = 1, 3, 5);       # Another anonymous Array[Int]</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，由于传递一个无类型的数组，下面的调用将全部失败，即使该数组在传递时恰好包含 Int 值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @c = 1, 3, 5;
say mean(@c);                       # Fails, passing untyped Array
say mean([1, 3, 5]);                # Same
say mean(Array.new(1, 3, 5));       # Same again</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在任何给定的编译器中，可能有一些奇怪的，底层的方法来绕过数组上的类型检查，因此在处理不受信任的输入时，执行额外的类型检查是一个很好的做法，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for @a -&gt; Int $i { $_++.say };</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而，只要你坚持在一个信任的代码区域内的正常赋值操作，这不会是一个问题，并且typecheck错误将在分配到数组时发生，如果他们不能在编译时捕获。 在Raku中提供的用于操作列表的核心功能不应该产生一个类型化的数组。</p>
</div>
<div class="paragraph">
<p>不存在的元素（当索引时）或已分配Nil的元素将采用默认值。 可以使用 <code>is default</code> 特征在逐个变量的基础上调整此默认值。 请注意，无类型的@ -sigiled变量的元素类型为 <code>Mu</code>，但其默认值为未定义的 <code>Any</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a;
@a.of.perl.say;                 # says "Mu"
@a.default.perl.say;            # says "Any"
@a[0].say;                      # says "(Any)"
my Numeric @n is default(Real);
@n.of.perl.say;                 # says "Numeric"
@n.default.perl.say;            # says "Real"
@n[0].say;                      # says "(Real)"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_fixed_size_arrays">48.9.2. Fixed Size Arrays</h4>
<div class="paragraph">
<p>要限制`阵列`的尺寸，请提供由 <code>,</code> 或 <code>;</code> 在数组容器的名称后面的括号中。 这样一个`数组`的值将默认为 <code>Any</code>。 形状可以在运行时通过 <code>shape</code> 方法访问。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a[2,2];
dd @a;
# OUTPUT«Array.new(:shape(2, 2), [Any, Any], [Any, Any])␤»
say @a.shape;
# OUTPUT«(2 2)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>赋值到固定大小的数组将把一个列表的列表提升为数组的数组。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a[2;2] = (1,2; 3,4);
@a[1;1] = 42;
dd @a;
# OUTPUT«Array.new(:shape(2, 2), [1, 2], [3, 42])␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_itemization">48.9.3. Itemization</h4>
<div class="paragraph">
<p>对于大多数用途，数组由多个槽组成，每个槽包含正确类型的`标量`。 每个这样的`标量`，反过来，包含该类型的值。 当数组被初始化，赋值或构造时，Raku 将自动进行类型检查值并创建标量来包含它们。</p>
</div>
<div class="paragraph">
<p>这实际上是 Raku 列表处理中最棘手的部分之一，以获得牢固的理解。</p>
</div>
<div class="paragraph">
<p>首先，请注意，因为假设数组中的项目化，它本质上意味着 <code>$(&#8230;&#8203;)</code> 被放置在您分配给数组的所有内容，如果你不把它们放在那里。 另一方面，<code>Array.perl</code> 不会将$显式地显示标量，与 <code>List.perl</code> 不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">((1, 2), $(3, 4)).perl.say; # says "((1, 2), $(3, 4))"
[(1, 2), $(3, 4)].perl.say; # says "[(1, 2), (3, 4)]"
                            # ...but actually means: "[$(1, 2), $(3, 4)]"</code></pre>
</div>
</div>
<div class="paragraph">
<p>它决定所有这些额外的美元符号和括号更多的眼睛疼痛比对用户的好处。 基本上，当你看到一个方括号，记住隐形美元符号。</p>
</div>
<div class="paragraph">
<p>第二，记住这些看不见的美元符号也防止扁平化，所以你不能真正地扁平化一个数组内的元素与正常调用 <code>flat</code> 或 <code>.flat</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">((1, 2), $(3, 4)).flat.perl.say; # (1, 2, $(3, 4)).Seq
[(1, 2), $(3, 4)].flat.perl.say; # ($(1, 2), $(3, 4)).Seq</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于方括号本身不会防止展平，因此您仍然可以使用平面将数组中的元素溢出到周围的列表中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">(0, [(1, 2), $(3, 4)], 5).flat.perl.say; # (0, $(1, 2), $(3, 4), 5).Seq</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;元素本身，但是，留在一块。</p>
</div>
<div class="paragraph">
<p>这可以阻止用户提供的数据，如果你有深嵌套的数组他们想要平面数据。 目前，他们必须手动地深度地映射结构以撤消嵌套：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say gather [0, [(1, 2), [3, 4]], $(5, 6)].deepmap: *.take; # (1 2 3 4 5 6)</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;未来版本的 Raku 可能会找到一种使这更容易的方法。 但是，当 non-itemized 列表足够时，不从函数返回数组或  itemized 列表，这是一个应该考虑作为好意给他们的用户：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当您总是想要与周围列表合并时使用 Slips</p>
</li>
<li>
<p>使用  non-itemized 列表，当你想让用户容易展平时</p>
</li>
<li>
<p>使用 itemized 列表来保护用户可能不想展平的东西</p>
</li>
<li>
<p>使用数组作为  non-itemized  列表的  non-itemized  列表，如果合适</p>
</li>
<li>
<p>如果用户想要改变结果而不首先复制结果，请使用数组。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>事实上，数组的所有元素（在`Scalar`容器中）是一个绅士的协议，而不是一个普遍强制的规则，并且在类型数组中的类型检查不太好。 请参阅下面有关绑定到阵列插槽的部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="_literal_arrays">48.9.4. Literal Arrays</h4>
<div class="paragraph">
<p>字面数组是用方括号内的 List 构造的。 列表被热切地迭代（如果可能，在编译时），并且列表中的值每个都进行类型检查和itemized。 在展平时, 方括号本身会将元素放入周围的列表中，但是元素本身不会因为 itemization 化而溢出。</p>
</div>
</div>
<div class="sect3">
<h4 id="_mutability">48.9.5. Mutability</h4>
<div class="paragraph">
<p>与列表不同，数组是可变的。 元素可以删除，添加或更改。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = "a", "b", "c";
@a.say;                  # [a b c]
@a.pop.say;              # says "c"
@a.say;                  # says "[a b]"
@a.push("d");
@a.say;                  # says "[a b d]"
@a[1, 3] = "c", "c";
@a.say;                  # says "[a c d c]"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_assigning">48.9.6. Assigning</h4>
<div class="paragraph">
<p>列表到数组的分配是急切的。 该列表将被完全求值，并且数组不应该是无限的否则程序可能挂起。 类似地，对阵列的分片的分配是急切的，但是仅仅达到所请求数量的元素，其可以是有限的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a;
@a[0, 1, 2] = (loop { 42 });
@a.say;                     # says "[42 42 42]"</code></pre>
</div>
</div>
<div class="paragraph">
<p>在赋值期间，每个值都将进行类型检查，以确保它是 <code>Array</code> 允许的类型。 任何`标量`将从每个值中剥离，一个新的`标量`将被包裹。</p>
</div>
</div>
<div class="sect3">
<h4 id="_binding">48.9.7. Binding</h4>
<div class="paragraph">
<p>单个数组槽可以以相同的方式绑定 $-sigiled 变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $b = "foo";
my @a = 1, 2, 3;
@a[2] := $b;
@a.say;          # says '[1 2 "foo"]'
$b = "bar";
@a.say;          # says '[1 2 "bar"]'</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;但强烈不建议将 Array 槽直接绑定到值。 如果你这样做，预期内置函数的惊喜。 只有当需要知道值和Scalar-Wrapped值之间的差异的可变容器时，或者对于不能使用本地类型数组的非常大的Arrays，才需要执行此操作。 这样的生物永远不应该被传递回不知情的用户。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_元对象协议">49. 元对象协议</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_自省和_raku_的对象系统">49.1. 自省和 Raku 的对象系统</h3>
<div class="paragraph">
<p>Raku 是构建在元对象层上面的。那意味着有些对象(元对象)控制着各种面向对象结构(例如类、roles、方法、属性、枚举,…)怎样去表现。</p>
</div>
<div class="paragraph">
<p>要感受类的元对象, 这儿有一个同样的例子出现2次: 一次一种 Raku中的普通声明, 一次通过元模型来表达:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    method x() { say 42 }
}
A.x(); # 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>对应于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant A := Metamodel::ClassHOW.new_type( name =&gt; 'A' );  # class A {
A.^add_method('x', my method x(A:) { say 42 });             # method x() .. .
A.^compose;                                                 # }

A.x(); # 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>(除了声明形式的运行在编译时, 后面这种形式不是)</p>
</div>
<div class="paragraph">
<p>对象后面的元对象能使用 `$obj.HOW`获取, 这儿的 HOW 代表着 <strong>Higher Order Workings</strong>(或者 HOW the *%@$ does this work?)。</p>
</div>
<div class="paragraph">
<p>这儿, 带有 `.^`的调用是元对象的调用, 所以 `A.^compose`是 `A.HOW.compose(A)`的简写。调用者也被传递到参数列表中, 以使它能够支持原型类型风格的类型系统, 那儿只有一个元对象。</p>
</div>
<div class="paragraph">
<p>就像上面的例子展示的那样, 所有的面向对象特性对使用者都是可获得的, 而不仅仅是编译器。实际上编译器就是使用元对象的这样的调用的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_元对象metaobjects">49.2. 元对象(MetaObjects)</h3>
<div class="paragraph">
<p>这些是内省的宏, 类似于方法调用。</p>
</div>
<div class="paragraph">
<p>元对象通常以 ALLCAPS(全大写)命名, 并且避免使用你自己的带有全大写名字的方法被认为是一个好的风格。这会避免和可能出现在未来版本中的任何元对象发生冲突。注意, 如果你必须使用带有全大写名字的方法的话, 把你的这个方法名字用引号引起来来间接安全地调用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#| THIS IS A CLASS FOR SHOUTING THINGS
class MY-CLASSES-ARE-ALL-CAPS {
    method WHY { "I DON'T KNOW" }
}
my $c = MY-CLASSES-ARE-ALL-CAPS.new;
say $c.WHY      # "THIS IS A CLASS FOR SHOUTING THINGS"? 显示这？你在逗我!
say $c."WHY"()  # "I DON'T KNOW"</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_what">49.2.1. WHAT</h4>
<div class="paragraph">
<p>类型的类型对象。例如 <code>42.WHAT</code> 返回 `Int`类型对象。</p>
</div>
</div>
<div class="sect3">
<h4 id="_which">49.2.2. WHICH</h4>
<div class="paragraph">
<p>对象的同一值。这能用于哈希和同一比较, 并且这是 `===`中缀操作符的实现方式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; "a".WHICH
Str|a</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_who">49.2.3. WHO</h4>
<div class="paragraph">
<p>支持对象的包</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; "a".WHO
Str</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_where">49.2.4. WHERE</h4>
<div class="paragraph">
<p>对象的内存地址。注意这在移动的/紧凑的垃圾回收实现中是不稳定的。 在稳定的同一指示器中使用 <code>WHERE</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_how">49.2.5. HOW</h4>
<div class="paragraph">
<p>元类对象(the metaclass object)：“Higher Order Workings”。</p>
</div>
</div>
<div class="sect3">
<h4 id="_why">49.2.6. WHY</h4>
<div class="paragraph">
<p>附加的 Pod 值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_definite">49.2.7. DEFINITE</h4>
<div class="paragraph">
<p>对象有一个有效的强制表现。</p>
</div>
<div class="paragraph">
<p>对于实例返回 <code>True</code>, 对于类型对象返回 <code>False</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&gt; 42.DEFINITE
True
&gt; Int.DEFINITE
False</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_var">49.2.8. VAR</h4>
<div class="paragraph">
<p>返回底层的 Scalar 对象, 如果有的话。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_元对象系统的结构">49.3. 元对象系统的结构</h3>
<div class="paragraph">
<p>对于每个类型声明符关键字, 例如 <code>class</code>、<code>role</code> 、<code>enum</code>、<code>module</code>、<code>package</code>、<code>grammar</code> 或`subset`, 就有一个独立的元类在 <code>Matamodel::`命名空间中。(Rakudo 在 `Raku::Metamodel::`命名空间中实现了它们, 然后把 `Raku::Metamodel`映射到 `Metamodel</code>)。</p>
</div>
<div class="paragraph">
<p>这些元类(meta classes)中的很多都共享公共的功能。例如 roles、grammars和 classes(类)都能包括方法和属性, 还能遵守 roles。这个共享的功能是在 roles 中实现的, 它被组合进合适的元类中。例如 <a href="http://doc.raku.org/type/Metamodel::RoleContainer">role Metamodel::RoleContainer</a>实现了类型能处理 roles 和 `Metamodel::ClassHOW`的功能, 它是在 `class`关键字后面的元类, 遵守了这个 role。</p>
</div>
</div>
<div class="sect2">
<h3 id="_bootstrapping_concerns">49.4. Bootstrapping concerns</h3>
<div class="paragraph">
<p>你可能想知道为什么 `Metamodel::ClassHOW`可以是一个类, 当按照`Metamodel::ClassHOW`作为一个类被定义时, 或者 roles 负责 role 处理的怎么能是 roles。答案是通过魔法。</p>
</div>
<div class="paragraph">
<p>开玩笑啦。自举是特别实现的。Rakudo 使用语言的对象系统来实现自举, 它恰好(几乎)就是 Raku 的一个子集: NQP, Not Quite Perl。 NQP 有原始的, class-like 叫做 <code>konwhow</code> 的性质, 它用于自举它自己的类和 roles 实现。`konwhow`建立在NQP 提供的虚拟机的原始基础上。</p>
</div>
<div class="paragraph">
<p>因为元对象是根据低级(low-level)类型引导的, 自省有时能返回低级(low-level)类型而非你期望的那个类型, 例如返回一个 NQP-level 的子例程而非普通的 `Routine`对象, 或返回一个引导的属性而非<a href="http://doc.raku.org/type/Attribute">Attribute</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_组合和静态推理">49.5. 组合和静态推理</h3>
<div class="paragraph">
<p>在 Raku中, 类型是在解析时被构造的, 所以在开始, 它必须是可变的。然而, 如果所有类型一直是可变的, 那么关于类型的所有推断会在任何类型的修改时变得无效。例如父类的列表因此类型检测的结果能在那个时候改变。</p>
</div>
<div class="paragraph">
<p>所以为了获得这两个世界中最好的东西, 当类型从可变转为不可变时是好时机。这就叫做组合, 并且对于从句法构成上声明的类型, 它发生在类型声明被完全解析时(所以总是在闭合花括号被解析时)。</p>
</div>
<div class="paragraph">
<p>如果你通过元对象系统直接创建类型, 你必须要在它们身上调用 <code>.^compose</code>, 在它们变得完全起作用之前。</p>
</div>
<div class="paragraph">
<p>很多元类也使用组合时来计算一些诸如方法解析顺序这样的属性, 发布一个方法缓存, 和其它清扫任务。在它们被组合之后干预类型有时是可能的, 但通常是造成灾难的因素。 不要那样做。</p>
</div>
</div>
<div class="sect2">
<h3 id="_能力和责任">49.6. 能力和责任</h3>
<div class="paragraph">
<p>元对象协议提供了很多常规 Raku 代码故意限制了的能力, 例如调用类中不信任你的私有方法, 窥探私有属性, 和其它通常不能完成的东西。</p>
</div>
<div class="paragraph">
<p>常规的 Raku 代码有很多就地的安全检测; 元模型中不是这样，它靠近底层的虚拟机, 违反和虚拟机的约定可以导致所有奇怪的行为, 而在正常代码中, 显而易见的会是 bugs。</p>
</div>
<div class="paragraph">
<p>所以, 在写元类型的时候要格外小心和思考。</p>
</div>
</div>
<div class="sect2">
<h3 id="_能力便利和陷阱">49.7. 能力、便利和陷阱</h3>
<div class="paragraph">
<p>元对象协议被设计的强大到实现 Raku 的对象系统。这种能力间或花费了便利的代价。</p>
</div>
<div class="paragraph">
<p>例如, 当你写了 <code>my $x = 42`并在 `$x`上调用方法时, 大部分方法会在整数 42 上起作用, 而不是在存储 42 的标量容器上。这是 Raku中设立的一块便利。元对象协议中的大部分不能提供自动忽略标量容器的便利性, 因为它们也用于实现那些标量容器。 所以, 如果你写了 `my $t = MyType; &#8230;&#8203; $t.^compose</code>, 那么你正组合那个`$<code>变量表明的标量, 而不是 `MyType</code>。</p>
</div>
<div class="paragraph">
<p>结果就是你需要很详尽的理解 Raku 的底层以避免陷阱, 当使用 MOP 时, 并且不能期望得到和普通 Raku 代码提供的 "do what I mean" 的便利。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_原生调用接口">50. 原生调用接口</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_入门指南">50.1. 入门指南</h3>
<div class="paragraph">
<p>能想象出的最简单的 <code>NativeCall</code> 用法应该类似于这样的东西：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;
sub some_argless_function() is native('something') { * }
some_argless_function();</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一行导入了各种 <code>traits</code> 和类型，接下来的一行看起来很像相对普通的 Raku 子例程声明 - 稍微有点变化。我们使用<strong>native</strong>这个 <code>trait ` 是为了指定这个 sub 子例程实际上被定义在<strong>原生库</strong>中。Raku 会给你添加特定平台的扩展名（比如 `.so</code> 或者 <code>.dll</code>）还有任何惯常的前缀(例如: 'lib')。</p>
</div>
<div class="paragraph">
<p>当你第一次调用 “some_argless_function” 时，“<strong>lib</strong>something” 将会被加载，然后会在 libsomething 库中定位到 “some_argless_function” 函数，接下来将会进行一次调用。之后的调用将会更快，因为符号句柄会被保留。</p>
</div>
<div class="paragraph">
<p>当然，大部分的函数都会接受参数或者返回值 - 但是你可以做的其他事情只是增加了这个声明Raku sub的简单模式</p>
</div>
<div class="paragraph">
<p>但是一切你需要做的就是增加这个简单的模式，通过声明一个 Raku 的过程、在符号后面指出你想要调用的名字，并且使用 “native” trait。</p>
</div>
</div>
<div class="sect2">
<h3 id="_改变名字">50.2. 改变名字</h3>
<div class="paragraph">
<p>有时你想要 Raku 子例程的名字和加载库中使用的名字不同，可能这个名字很长, 或者有不同的大小写或者在你想要创建的模块的上下文中, 这个名字很繁琐。</p>
</div>
<div class="paragraph">
<p>NativeCall 为你提供了一个 <code>symbol</code> trait 以指定库中<strong>原生子例程</strong>的名字, 这个名字和你的 Raku 子例程名字不同。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">module Foo;
use NativeCall;
our sub init() is native('foo') is symbol('FOO_INIT') { * }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>libfoo</code> 库里面有一个子例程叫 <code>FOO_INIT</code>，因为我们创建了一个模块叫做 Foo，我们更愿意使用 <code>Foo::init</code> 调用子例程，我们使用 <code>symbol</code> trait 来指定在 <code>libfoo</code> 库名字符号的名字，然后以任何我们想要的方式调用这个子例程（这里是 “init”）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_传递值和返回值">50.3. 传递值和返回值</h3>
<div class="paragraph">
<p>普通的 Raku 签名和 <code>returns</code> trait 的使用是为了传送原生函数期望的参数类型以及返回的东西，下面有个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub add(int32, int32) returns int32 is native('calculator') { * }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们声明该函数接受两个32位整数，返回一个32位整数。你可以在<a href="https://docs.raku.org/language/nativetypes">原生类型</a>页面中找到可以传递的其他类型。 请注意，缺少 <code>returns</code> trait 用于指示 <code>void</code> 返回类型。 除指针参数化外，不要在任何地方使用 <code>void</code> 类型。</p>
</div>
<div class="paragraph">
<p>对于字符串，还有一个额外的 <code>encoded</code> trait，可以提供一些关于如何进行编组的额外提示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;
sub message_box(Str is encoded('utf8')) is native('gui') { * }</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了指定如何对返回类型进行编组，只需在子例程自身应用这个 trait 即可。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;
sub input_box() returns Str is encoded('utf8') is native('gui') { * }</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, 可以通过传递 Str 类型对象来传递 NULL 字符串指针; NULL 返回也将由类型对象表示。</p>
</div>
<div class="paragraph">
<p>如果 C 函数要求字符串的生命周期超过函数调用，则必须手动编码该参数并将其作为 <code>CArray[uint8]</code> 传递：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;
# C prototype is void set_foo(const char *)
sub set_foo(CArray[uint8]) is native('foo') { * }
# C prototype is void use_foo(void)
sub use_foo() is native('foo') { * } # will use pointer stored by set_foo()

my $string = "FOO";
# The lifetime of this variable must be equal to the required lifetime of
# the data passed to the C function.
my $array = CArray[uint8].new($string.encode.list);

set_foo($array);
# ...
use_foo();
# It's fine if $array goes out of scope starting from here.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_指定原生表示">50.4. 指定原生表示</h3>
<div class="paragraph">
<p>使用原生函数时，有时需要指定要使用的原生数据结构类型。 <code>is repr</code> 是用于此的术语。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;

class timespec is repr('CStruct') {
    has uint32 $.tv_sec;
    has long $.tv_nanosecs;
}

sub clock_gettime(uint32 $clock-id, timespec $tspec --&gt; uint32) is native { * };

my timespec $this-time .=new;

my $result = clock_gettime( 0, $this-time);

say "$result, $this-time"; # OUTPUT: «0, timespec&lt;65385480&gt;␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://linux.die.net/man/3/clock_gettime">我们调用的原始函数</a>, <a href="https://docs.raku.org/routine/clock_gettime">clock_gettime</a> 使用指向 <code>timespec</code> 结构的指针作为第二个参数。 我们在这里将它声明为一个<a href="https://docs.raku.org/routine/class">类</a>，但是将其表示指定为 <code>repr('CStruct')</code>, 以指示它对应于 C 数据结构。 当我们创建该类的对象时，我们正在创建 <code>clock_gettime</code> 所期望的指针类型。 这样，数据可以无缝地传输到原生接口和从原生接口传输。</p>
</div>
</div>
<div class="sect2">
<h3 id="_指针的基本使用">50.5. 指针的基本使用</h3>
<div class="paragraph">
<p>当你的原生函数签名需要一个指向某些原生类型（<code>int32</code>、<code>uint32`等等）的指针时，所有你需要做的就是将参数声明为 `is rw</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;
# C prototype is void my_version(int *major, int *minor)
sub my_version(int32 is rw, int32 is rw) is native('foo') { * }
my_version(my int32 $major, my int32 $minor); # Pass a pointer to</code></pre>
</div>
</div>
<div class="paragraph">
<p>有的时候你需要获取一个从 C 库返回的指针（比如一个库句柄），你不关心它指向什么 - 你只需要保存它就可以了，<code>Pointer</code> 类型就是为此而生的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;
sub Foo_init() returns Pointer is native("foo") { * }
sub Foo_free(Pointer) is native("foo") { * }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个可以正常工作，但是你可能想要使用比 <code>Pointer</code> 更好的类型，事实证明，任何具有表示“CPointer”的类都可以担任此角色，这意味着你可以通过编写如下类来暴露工作在句柄上的库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;

class FooHandle is repr('CPointer') {
    # Here are the actual NativeCall functions.
    sub Foo_init() returns FooHandle is native("foo") { * }
    sub Foo_free(FooHandle) is native("foo") { * }
    sub Foo_query(FooHandle, Str) returns int8 is native("foo") { * }
    sub Foo_close(FooHandle) returns int8 is native("foo") { * }

    # Here are the methods we use to expose it to the outside world.
    method new {
        Foo_init();
    }

    method query(Str $stmt) {
        Foo_query(self, $stmt);
    }

    method close {
        Foo_close(self);
    }

    # Free data when the object is garbage collected.
    submethod DESTROY {
        Foo_free(self);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，CPointer 表示只能保存 C 指针。 这意味着你的类不能有额外的属性。 但是，对于简单的库，这可能是向其暴露面向对象的接口的一种巧妙方式。</p>
</div>
<div class="paragraph">
<p>当然，你总是可以有一个空类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class DoorHandle is repr('CPointer') { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>只需像使用 <code>Pointer</code> 一样使用类，但有可能提高类型安全性和更易读的代码。</p>
</div>
<div class="paragraph">
<p>同样，类型对象用于表示 NULL 指针。</p>
</div>
</div>
<div class="sect2">
<h3 id="_函数指针">50.6. 函数指针</h3>
<div class="paragraph">
<p>C 库可以将指向 C 函数的指针暴露为函数的返回值和结构体的成员，例如 structs 和 unions。</p>
</div>
<div class="paragraph">
<p>使用定义所需函数参数和返回值的签名调用函数“f”返回的函数指针“$fptr”的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f() returns Pointer is native('mylib') { * }

my $fptr    = f();
my $nfptr   = nativecast(:(Str, size_t --&gt; int32), $fptr);

say $nfptr("test", 4);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_数组_3">50.7. 数组</h3>
<div class="paragraph">
<p>NativeCall 对数组有一些支持。 它受限于使用机器大小的整数，双精度和字符串，定型的数字类型，指针数组，结构体数组和数组的数组。</p>
</div>
<div class="paragraph">
<p>Raku 数组支持懒惰，在内存中以与 C 数组完全不同的方式布局。 因此，NativeCall 库提供了更原始的 CArray 类型，如果使用 C 数组，则必须使用该类型。</p>
</div>
<div class="paragraph">
<p>这是传递 C 数组的示例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub RenderBarChart(Str, int32, CArray[Str], CArray[num64]) is native("chart") { * }
my @titles := CArray[Str].new;
@titles[0]  = 'Me';
@titles[1]  = 'You';
@titles[2]  = 'Hagrid';
my @values := CArray[num64].new;
@values[0]  = 59.5e0;
@values[1]  = 61.2e0;
@values[2]  = 180.7e0;
RenderBarChart('Weights (kg)', 3, @titles, @values);</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意我们对 <code>@titles</code> 使用了绑定，而不是赋值，如果你使用赋值，则会把值放进 Raku 数组，然后它就不会工作了。如果这令你抓狂，忘记你所知道的关于 <code>@</code> 符号的事情，使用 NativeCall 的时候直接使用 <code>$</code> 吧。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;
my $titles = CArray[Str].new;
$titles[0] = 'Me';
$titles[1] = 'You';
$titles[2] = 'Hagrid';</code></pre>
</div>
</div>
<div class="paragraph">
<p>获取数组的返回值也是一样的。</p>
</div>
<div class="paragraph">
<p>某些库 API 可能会将数组作为缓冲区，将由 C 函数填充，例如，返回填充的实际项数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;
sub get_n_ints(CArray[int32], int32) returns int32 is native('ints') { * }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这些情况下，重要的是 CArray 在将其传递给原生子例程之前至少具有要填充的元素的数量，否则 C 函数可能会遍历 Perl 的内存，从而可能导致不可预测的行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $number_of_ints = 10;
my $ints = CArray[int32].allocate($number_of_ints); # instantiates an array with 10 elements
my $n = get_n_ints($ints, $number_of_ints);</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>注意：<code>allocate</code> 是在 Rakudo 2018.05 中引入的。 在此之前，你必须使用此机制将数组扩展为许多元素：</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $ints = CArray[int32].new;
my $number_of_ints = 10;
$ints[$number_of_ints - 1] = 0; # extend the array to 10 items</code></pre>
</div>
</div>
<div class="paragraph">
<p>数组的内存管理很重要。 当你自己创建一个数组时，可以根据需要为其添加元素，并根据需要为你进行扩展。 但是，这可能会导致元素在内存中移动（但是，对现有元素的赋值永远不会导致这种情况）。 这意味着如果在将数组传递给 C 库之后将数组旋转，你最好知道自己在做什么。</p>
</div>
<div class="paragraph">
<p>相比之下，当 C 库向你返回一个数组时，内存不能由 NativeCall 管理，并且它不知道数组的结束位置。 据推测，库 API 中的某些东西告诉你这一点（例如，你知道当你看到一个 null 元素时，你应该不再读取）。 请注意，NativeCall 在这里无法为您提供任何保护 - 一旦做错了，你将遇到 segfault 错误或导致内存损坏。 这不是 NativeCall 的缺点，它是原生世界的工作方式。害怕吗？ 还在这里，拥抱一下。 祝好运！</p>
</div>
</div>
<div class="sect2">
<h3 id="_carray_方法">50.8. CArray 方法</h3>
<div class="paragraph">
<p>除了每个 Raku 实例上可用的常用方法之外，CArray 还提供了以下方法，可以从 Raku 的角度与它进行交互：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>elems</code> 提供数组中的元素数量;</p>
</li>
<li>
<p><code>AT-POS</code> 在给定位置提供特定元素（从零开始）;</p>
</li>
<li>
<p><code>list</code> 提供了从原生数组迭代器构建它的数组中的元素<a href="https://docs.raku.org/type/List">列表</a>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，请考虑以下简单的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;

my $native-array = CArray[int32].new( 1, 2, 3, 4, 5 );
say 'Number of elements: ' ~ $native-array.elems;

# walk the array
for $native-array.list -&gt; $elem {
    say "Current element is: $elem";
}

# get every element by its index-based position
for 0..$native-array.elems - 1 -&gt; $position {
    say "Element at position $position is "
          ~ $native-array.AT-POS( $position );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生以下输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Number of elements: 5
Current element is: 1
Current element is: 2
Current element is: 3
Current element is: 4
Current element is: 5
Element at position 0 is 1
Element at position 1 is 2
Element at position 2 is 3
Element at position 3 is 4
Element at position 4 is 5</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_结构体">50.9. 结构体</h3>
<div class="paragraph">
<p>由于表示多态性，可以声明一个看起来很正常的 Raku 类，实际上，C 编译器将它们放置在类似的结构体定义中以相同的方式存储其属性。 所需要的只是快速使用“repr” trait：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Point is repr('CStruct') {
    has num64 $.x;
    has num64 $.y;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>声明的属性只能是 NativeCall 已知的可以转换成结构体字段的类型，目前，结构体中可以包含机器大小的整数，doubles，strings 以及其它 NativeCall 对象（CArrays，还有 CPointer 以及 CStruct reprs）。除此之外，你可以做一些跟类一样的常用的设置，你甚至可以让某些属性来自于角色或者从其它的类继承。当然，方法也完全没有问题，疯狂!</p>
</div>
<div class="paragraph">
<p>CStruct 对象以引用的形式传递到原生函数，并且原生函数必须返回 CStruct 对象的引用，对于这些引用的内存管理规则跟数组的内存管理规则很像，尽管更简单，因为结构体的大小是不变的。当你创建一个结构体，内存也一并为你分配好，当指向 CStruct 实例的变量的生命期结束，GC 会负责释放内存。当基于 CStruct 的类型作为原生函数的返回类型时，GC 并不帮你管理它的内存。</p>
</div>
<div class="paragraph">
<p>NativeCall 目前并不把对象成员放到容器里面，所以不能对对象进行赋（使用 =）新值。 相反，你必须将新值绑定到私有成员上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class MyStruct is repr('CStruct') {
    has CArray[num64] $!arr;
    has Str $!str;
    has Point $!point; # Point is a user-defined class

    submethod TWEAK {
        my $arr := CArray[num64].new;
        $arr[0] = 0.9e0;
        $arr[1] = 0.2e0;
        $!arr := $arr;
        $!str := 'Raku is fun';
        $!point := Point.new;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>正如你预测的那样，空指针由结构体类型的类型对象表示的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_cunions">50.10. CUnions</h3>
<div class="paragraph">
<p>同样地，我们可以声明一个 Raku 类，它的属性拥有和 C 编译器中联合体（<code>union</code>）的相同的内存布局，这可以使用 <code>CUnion</code> 表示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;

class MyUnion is repr('CUnion') {
    has int32 $.flags32;
    has int64 $.flags64;
}

say nativesizeof(MyUnion.new);  # 8, ie. max(sizeof(MyUnion.flags32), sizeof(MyUnion.flags64))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_嵌套的_cstructs_和_cunions">50.11. 嵌套的 CStructs 和 CUnions</h3>
<div class="paragraph">
<p>反过来, CStructs 和 CUnions 可以被周围的 CStruct 和 CUnion 引用，或者嵌入到其他的 CStructs 和 CUnions 里面，如果是引用我们则像往常一样使用 <code>has</code> 来声明，如果是嵌入则使用 <code>HAS</code> 代替：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class MyStruct is repr('CStruct') {
    has Point $.point;  # referenced
    has int32 $.flags;
}

say nativesizeof(MyStruct.new);  # 16, ie. sizeof(struct Point *) + sizeof(int32_t)

class MyStruct2 is repr('CStruct') {
    HAS Point $.point;  # embedded
    has int32 $.flags;
}

say nativesizeof(MyStruct2.new);  # 24, ie. sizeof(struct Point) + sizeof(int32_t)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_注意内存管理">50.11.1. 注意内存管理</h4>
<div class="paragraph">
<p>分配结构体以用作结构体时，请确保在 C 函数中分配自己的内存。 如果要将结构体传递给需要提前分配的 <code>Str/char*</code> 的C函数，请确保在将结构体传递给函数之前为 <code>Str</code> 类型的变量分配容器。</p>
</div>
<div class="sect4">
<h5 id="_在你的_raku_代码中">在你的 Raku 代码中&#8230;&#8203;</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class AStringAndAnInt is repr("CStruct") {
  has Str $.a_string;
  has int32 $.an_int32;

  sub init_struct(AStringAndAnInt is rw, Str, int32) is native('simple-struct') { * }

  submethod BUILD(:$a_string, :$an_int) {
    init_struct(self, $a_string, $an_int);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此代码中，我们首先设置我们的成员 <code>$.a_string</code> 和 <code>$.an_int32</code>。 之后，我们声明 <code>init_struct()</code> 函数以使 <code>init()</code> 方法包装; 然后从 <code>BUILD</code> 调用此函数以在返回创建的对象之前有效地分配值。</p>
</div>
</div>
<div class="sect4">
<h5 id="_在你的_c_代码中">在你的 C 代码中 &#8230;&#8203;</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">typedef struct a_string_and_an_int32_t_ {
  char *a_string;
  int32_t an_int32;
} a_string_and_an_int32_t;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是结构体。 注意我们在那里有怎么得到一个 <code>char *</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">void init_struct(a_string_and_an_int32_t *target, char *str, int32_t int32) {
  target-&gt;an_int32 = int32;
  target-&gt;a_string = strdup(str);

  return;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个函数中，我们通过按值分配整数并通过引用传递字符串来初始化 C 结构体。 该函数在复制字符串时将 <code>&lt;point * a_string&gt;</code> 指向的内存分配到结构中。 （注意，你还必须管理内存的释放以避免内存泄漏。）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># A long time ago in a galaxy far, far away...
my $foo = AStringAndAnInt.new(a_string =&gt; "str", an_int =&gt; 123);
say "foo is {$foo.a_string} and {$foo.an_int32}";
# OUTPUT: «foo is str and 123␤»</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类型指针">50.12. 类型指针</h3>
<div class="paragraph">
<p>将 <code>Pointer</code> 作为参数传递时可以类型化你的 <code>Pointer</code>。这不但对原生类型可用，同样适用于 <code>CArray</code> 以及 <code>CStruct</code> 定义类型，NativeCall 将不会显式为他们分配内存，即使在它们身上调用 <code>new</code> 方法也不会。这适用于那种 C 函数返回指针或者 <code>CStruct</code> 中嵌入的指针情况。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;
sub strdup(Str $s --&gt; Pointer[Str]) is native {*}
my Pointer[Str] $p = strdup("Success!");
say $p.deref;</code></pre>
</div>
</div>
<div class="paragraph">
<p>原生函数返回指向元素的数组的指针是很常见的。 可以将类型化指针解引用为数组以获取单个元素。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $n = 5;
# returns a pointer to an array of length $n
my Pointer[Point] $plot = some_other_c_routine($n);
# display the 5 elements in the array
for 1 .. $n -&gt; $i {
    my $x = $plot[$i - 1].x;
    my $y = $plot[$i - 1].y;
    say "$i: ($x, $y)";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>指针也可以更新以引用数组中的连续元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Pointer[Point] $elem = $plot;
# show differences between successive points
for 1 ..^ $n {
    my Point $lo = $elem.deref;
    ++$elem; # equivalent to $elem = $elem.add(1);
    my Point $hi = (++$elem).deref;
    my $dx = $hi.x = $lo.x;
    my $dy = $hi.y = $lo.y;
    say "$_: delta ($dx, $dy)";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过声明 <code>Pointer<a href="https://docs.raku.org/language/nativetypes#The_void_type">void</a></code> 也可以使用 Void 指针。 有关该主题的更多信息，请参阅[原生类型文档]。</p>
</div>
</div>
<div class="sect2">
<h3 id="_字符串">50.13. 字符串</h3>
<div class="sect3">
<h4 id="_显式内存管理">50.13.1. 显式内存管理</h4>

</div>
<div class="sect3">
<h4 id="_buffers_and_blobs">50.13.2. Buffers and Blobs</h4>

</div>
</div>
<div class="sect2">
<h3 id="_函数参数">50.14. 函数参数</h3>
<div class="paragraph">
<p>NativeCall 也支持把函数作为原生函数的参数，一个常用的情况就是事件驱动模型中，使用函数指针作为回调。当通过 NativeCall 绑定了这些函数，只需要提供对等的 signature 作为函数参数的约束。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># void SetCallBack(int (*callback)(char const *))
my sub SetCallBack(&amp;callback(Str --&gt; int32)) is native('mylib') { * }</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意：原生代码负责传递给 Raku 回调的值的内存管理，换句话说，NativeCall 将不会释放传递给回调的字符串占用的内存。</p>
</div>
</div>
<div class="sect2">
<h3 id="_库路径以及名字">50.15. 库路径以及名字</h3>
<div class="paragraph">
<p>native trait 接受库的名字或者全路径：</p>
</div>
<div class="paragraph">
<p>constant LIBMYSQL = 'mysqlclient';
constant LIBFOO = '/usr/lib/libfoo.so.1';</p>
</div>
<div class="paragraph">
<p>sub mysql_affectied_rows( .. ) returns int32 is native(LIBMYSQL);
sub bar is native(LIBFOO);
你也可以使用相对路径比如'./foo'，NativeCall 将会自动根据不同的平台添加对应的扩展名。
注意：native trait 和 constant 都是在编译期求值的，constant类型的变量不要依赖动态变量，比如：</p>
</div>
<div class="paragraph">
<p>constant LIBMYSQL = %*ENV&lt;P6LIB_MYSQLCLIENT&gt; || 'mysqlclient';
这将在编译期保持给定的值，在一个模块预编译时，LIBMYSQL将会始终保持那个值。</p>
</div>
<div class="sect3">
<h4 id="_abiapi版本">50.15.1. ABI/API版本</h4>
<div class="paragraph">
<p>假设你写的原生库为native('foo')， 在类Unix系统下，NativeCall 将会搜索&#8217;libfoo.so'（对于OS X是libfoo.dynlib，win32是foo.dll）。在大多数的现代系统上，将会需要你或者模块的使用者安装开发环境包，因为它们总是建议支持动态库的API/ABI的版本控制，所以&#8217;libfoo.so&#8217;大多数是一个符号链接，并且只被开发包提供。</p>
</div>
<div class="paragraph">
<p>sub foo is native('foo', v1);         # 将会查找并加载 libfoo.so.1
sub foo is native('foo', v1.2.3);    # 将会查找并加载 libfoo.so.1.2.3</p>
</div>
<div class="paragraph">
<p>my List $lib = ('foo', 'v1');
sub foo is native($lib);</p>
</div>
</div>
<div class="sect3">
<h4 id="_例程">50.15.2. 例程</h4>
<div class="paragraph">
<p>native trait 也可以接受一个Callable作为参数，允许你使用自己的方式指定将会被加载的库文件：</p>
</div>
<div class="paragraph">
<p>sub foo is native(sub { 'libfoo.so.42' } );
这个函数只会在第一个调用者访问的时候调用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_调用标准库">50.15.3. 调用标准库</h4>
<div class="paragraph">
<p>如果你想调用一个已经被加载的，或者是标准库或者来自你自己的程序的 C 函数，你可以将 Str 类型对象作为参数传递给is native，这将会是is native(Str)。
比如说，在类UNIX操作系统下，你可以使用下面的代码打印当前用户的home目录：</p>
</div>
<div class="paragraph">
<p>use NativeCall;
my class PwStruct is repr('CStruct') {
    has Str $.pw_name;
    has Str $.pw_passwd;
    has uint32 $.pw_uid;
    has uint32 $.pw_gid;
    has Str $.pw_gecos;
    has Str $.pw_dir;
    has Str $.pw_shell;
}</p>
</div>
<div class="paragraph">
<p>sub getuid()                returns uint32         is native(Str) { * }
sub getpwuid(uint32 $uid)    returns PwStruct     is native(Str) { * }</p>
</div>
<div class="paragraph">
<p>say getpwuid(getuid());
不过，使用$*HOME更方便一些 :-)</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_导出的变量">50.16. 导出的变量</h3>
<div class="paragraph">
<p>一个库导出的变量&#8201;&#8212;&#8201;也被叫做“全局（global）”或者 “外部（extern）”变量&#8201;&#8212;&#8201;可以使用cglobal访问。比如：</p>
</div>
<div class="paragraph">
<p>my $var := cglobal('libc.so.6', 'error', int32);
这将会为$var绑定一个新的Proxy对象，并且将对它的访问重定向到被“libc.so.6”导出的叫做errno的整数变量。</p>
</div>
</div>
<div class="sect2">
<h3 id="_对c的支持">50.17. 对C++的支持</h3>
<div class="paragraph">
<p>NativeCall 也支持使用来自 c 的类以及方法，就像这个例子展示的那样（还有相关的 c 文件），注意现阶段还不像 C 一样支持测试和开发。</p>
</div>
</div>
<div class="sect2">
<h3 id="_helper_函数">50.18. Helper 函数</h3>
<div class="sect3">
<h4 id="_sub_nativecast">50.18.1. sub nativecast</h4>

</div>
<div class="sect3">
<h4 id="_sub_cglobal">50.18.2. sub cglobal</h4>

</div>
<div class="sect3">
<h4 id="_sub_nativesizeof">50.18.3. sub nativesizeof</h4>

</div>
<div class="sect3">
<h4 id="_sub_explicitly_manage">50.18.4. sub explicitly-manage</h4>

</div>
</div>
<div class="sect2">
<h3 id="_例子">50.19. 例子</h3>
<div class="paragraph">
<p>一些具体示例，以及在特定平台上使用上述示例的说明。</p>
</div>
<div class="sect3">
<h4 id="_postgresql">50.19.1. PostgreSQL</h4>
<div class="paragraph">
<p><a href="https://github.com/raku/DBIish/blob/master/examples/pg.p6">DBIish</a> 中的 PostgreSQL 示例使用 NativeCall 库，并且`原生使用` Windows 中的原生 <code>_putenv</code> 函数调用。</p>
</div>
</div>
<div class="sect3">
<h4 id="_mysql">50.19.2. MySQL</h4>
<div class="paragraph">
<p>注意：请记住，自 Stretch 版本以来，Debian 已经将 MySQL 替换为 MariaDB，因此如果要安装 MySQL，请使用 <a href="https://dev.mysql.com/downloads/repo/apt/">MySQL APT 存储库</a>而不是默认存储库。</p>
</div>
<div class="paragraph">
<p>要在 <a href="https://github.com/raku/DBIish/blob/master/examples/mysql.p6">DBIish</a> 中使用 MySQL 示例，您需要在本地安装 MySQL 服务器; 在Debian-esque 系统上，它可以安装如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">wget https://dev.mysql.com/get/mysql-apt-config_0.8.10-1_all.deb
sudo dpkg -i mysql-apt-config_0.8.10-1_all.deb # Don't forget to select 5.6.x
sudo apt-get update
sudo apt-get install mysql-community-server -y
sudo apt-get install libmysqlclient18 -y</code></pre>
</div>
</div>
<div class="paragraph">
<p>在尝试示例之前，请按照这些方法准备系统：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ mysql -u root -p
SET PASSWORD = PASSWORD('sa');
DROP DATABASE test;
CREATE DATABASE test;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_microsoft_windows">50.19.3. Microsoft Windows</h4>
<div class="paragraph">
<p>这是一个 Windows API 调用的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;

sub MessageBoxA(int32, Str, Str, int32)
    returns int32
    is native('user32')
    { * }

MessageBoxA(0, "We have NativeCall", "ohai", 64);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_关于调用_c_函数的简明指南">50.19.4. 关于调用 C 函数的简明指南</h4>
<div class="paragraph">
<p>这是一个调用标准函数并在 Raku 程序中使用返回信息的示例。</p>
</div>
<div class="paragraph">
<p><code>getaddrinfo</code> 是 POSIX 标准函数，用于获取有关网络节点的网络信息，例如 <code>google.com</code>。 这是一个有趣的功能，因为它说明了 NativeCall 的许多元素。</p>
</div>
<div class="paragraph">
<p>Linux 手册提供了有关 C 可调用函数的以下信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">int getaddrinfo(const char *node, const char *service,
       const struct addrinfo *hints,
       struct addrinfo **res);</code></pre>
</div>
</div>
<div class="paragraph">
<p>该函数返回响应码 0 = 错误，1 = 成功。 数据是从 <code>addrinfo</code> 元素的链表中提取的，第一个元素由 <code>res</code> 指向。</p>
</div>
<div class="paragraph">
<p>从 NativeCall 类型表我们知道 <code>int</code> 是 <code>int32</code>。 我们也知道 <code>char *</code> 是 C <code>Str</code> 的形式 C 之一，它简单地映射到 Str。 但是 <code>addrinfo</code> 是一个结构体，这意味着我们需要编写自己的 Type 类。 但是，函数声明很简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub getaddrinfo( Str $node, Str $service, Addrinfo $hints, Pointer $res is rw )
    returns int32
    is native
    { * }</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>$res</code> 将由函数写入，因此必须将其标记为 <code>rw</code>。 由于库是标准 POSIX，因此库名称可以是 Type 定义或 null。</p>
</div>
<div class="paragraph">
<p>我们现在必须处理结构体 <code>Addrinfo</code>。 Linux 手册提供了以下信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">struct addrinfo {
               int              ai_flags;
               int              ai_family;
               int              ai_socktype;
               int              ai_protocol;
               socklen_t        ai_addrlen;
               struct sockaddr *ai_addr;
               char            *ai_canonname;
               struct addrinfo *ai_next;
           };</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>int</code>，<code>char *</code> 部分很简单。 一些研究表明 <code>socklen_t</code> 可以依赖于架构，但是是一个至少32位的无符号整数。 所以 <code>socklen_t</code> 可以映射到 <code>uint32</code> 类型。</p>
</div>
<div class="paragraph">
<p>复杂的是 <code>sockaddr</code>，它取决于 <code>ai_socktype</code> 是否是未定义的，INET 还是 INET6（标准的v4 IP 地址或 v6 地址）。</p>
</div>
<div class="paragraph">
<p>所以我们创建一个 Raku 类来映射到 C <code>struct addrinfo</code>; 当我们在它的时候，我们还为 <code>SockAddr</code> 创建了另一个类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class SockAddr is repr('CStruct') {
    has int32    $.sa_family;
    has Str      $.sa_data;
}

class Addrinfo is repr('CStruct') {
    has int32     $.ai_flags;
    has int32     $.ai_family;
    has int32     $.ai_socktype;
    has int32     $.ai_protocol;
    has int32     $.ai_addrlen;
    has SockAddr  $.ai_addr       is rw;
    has Str       $.ai_cannonname is rw;
    has Addrinfo  $.ai_next       is rw;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后三个属性的 <code>is rw</code> 反映了这些在 C 中被定义为指针。</p>
</div>
<div class="paragraph">
<p>映射到 C <code>Struct</code> 的重要一点是类的状态部分的结构，即属性。 但是，类可以有方法，而 <code>NativeCall</code> 不会“触摸”它们以映射到C.这意味着我们可以向类添加额外的方法以更易读的方式解包属性，例如，</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method flags {
    do for AddrInfo-Flags.enums { .key if $!ai_flags +&amp; .value }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过定义适当的 <code>enum</code>，<code>flags</code> 将返回一串键而不是一个打包的整数。</p>
</div>
<div class="paragraph">
<p><code>sockaddr</code> 结构中最有用的信息是节点的地址，它取决于 Socket 的族。 因此，我们可以将方法地址添加到 Raku 类中，该类根据族来解释地址。</p>
</div>
<div class="paragraph">
<p>为了获得人类可读的 IP 地址，有一个 C 函数 <code>inet_ntop</code>，它给出一个带有 <code>addrinfo</code> 的缓冲区的 <code>char *</code>。</p>
</div>
<div class="paragraph">
<p>将所有这些组合在一起会产生以下程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#!/usr/bin/env raku

use v6;
use NativeCall;

constant \INET_ADDRSTRLEN = 16;
constant \INET6_ADDRSTRLEN = 46;

enum AddrInfo-Family (
    AF_UNSPEC                   =&gt; 0;
    AF_INET                     =&gt; 2;
    AF_INET6                    =&gt; 10;
);

enum AddrInfo-Socktype (
    SOCK_STREAM                 =&gt; 1;
    SOCK_DGRAM                  =&gt; 2;
    SOCK_RAW                    =&gt; 3;
    SOCK_RDM                    =&gt; 4;
    SOCK_SEQPACKET              =&gt; 5;
    SOCK_DCCP                   =&gt; 6;
    SOCK_PACKET                 =&gt; 10;
);

enum AddrInfo-Flags (
    AI_PASSIVE                  =&gt; 0x0001;
    AI_CANONNAME                =&gt; 0x0002;
    AI_NUMERICHOST              =&gt; 0x0004;
    AI_V4MAPPED                 =&gt; 0x0008;
    AI_ALL                      =&gt; 0x0010;
    AI_ADDRCONFIG               =&gt; 0x0020;
    AI_IDN                      =&gt; 0x0040;
    AI_CANONIDN                 =&gt; 0x0080;
    AI_IDN_ALLOW_UNASSIGNED     =&gt; 0x0100;
    AI_IDN_USE_STD3_ASCII_RULES =&gt; 0x0200;
    AI_NUMERICSERV              =&gt; 0x0400;
);

sub inet_ntop(int32, Pointer, Blob, int32 --&gt; Str)
    is native {}

class SockAddr is repr('CStruct') {
    has uint16 $.sa_family;
}

class SockAddr-in is repr('CStruct') {
    has int16 $.sin_family;
    has uint16 $.sin_port;
    has uint32 $.sin_addr;

    method address {
        my $buf = buf8.allocate(INET_ADDRSTRLEN);
        inet_ntop(AF_INET, Pointer.new(nativecast(Pointer,self)+4),
            $buf, INET_ADDRSTRLEN)
    }
}

class SockAddr-in6 is repr('CStruct') {
    has uint16 $.sin6_family;
    has uint16 $.sin6_port;
    has uint32 $.sin6_flowinfo;
    has uint64 $.sin6_addr0;
    has uint64 $.sin6_addr1;
    has uint32 $.sin6_scope_id;

    method address {
        my $buf = buf8.allocate(INET6_ADDRSTRLEN);
        inet_ntop(AF_INET6, Pointer.new(nativecast(Pointer,self)+8),
            $buf, INET6_ADDRSTRLEN)
    }
}

class Addrinfo is repr('CStruct') {
    has int32 $.ai_flags;
    has int32 $.ai_family;
    has int32 $.ai_socktype;
    has int32 $.ai_protocol;
    has uint32 $.ai_addrNativeCalllen;
    has SockAddr $.ai_addr is rw;
    has Str $.ai_cannonname is rw;
    has Addrinfo $.ai_next is rw;

    method flags {
        do for AddrInfo-Flags.enums { .key if $!ai_flags +&amp; .value }
    }

    method family {
        AddrInfo-Family($!ai_family)
    }

    method socktype {
        AddrInfo-Socktype($!ai_socktype)
    }

    method address {
        given $.family {
            when AF_INET {
                nativecast(SockAddr-in, $!ai_addr).address
            }
            when AF_INET6 {
                nativecast(SockAddr-in6, $!ai_addr).address
            }
        }
    }
}

sub getaddrinfo(Str $node, Str $service, Addrinfo $hints,
                Pointer $res is rw --&gt; int32)
    is native {};

sub freeaddrinfo(Pointer)
    is native {}

sub MAIN() {
    my Addrinfo $hint .= new(:ai_flags(AI_CANONNAME));
    my Pointer $res .= new;
    my $rv = getaddrinfo("google.com", Str, $hint, $res);
    say "return val: $rv";
    if ( ! $rv ) {
        my $addr = nativecast(Addrinfo, $res);
        while $addr {
            with $addr {
                say "Name: ", $_ with .ai_cannonname;
                say .family, ' ', .socktype;
                say .address;
                $addr = .ai_next;
            }
        }
    }
    freeaddrinfo($res);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这产生如下输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">return val: 0
Name: google.com
AF_INET SOCK_STREAM
216.58.219.206
AF_INET SOCK_DGRAM
216.58.219.206
AF_INET SOCK_RAW
216.58.219.206
AF_INET6 SOCK_STREAM
2607:f8b0:4006:800::200e
AF_INET6 SOCK_DGRAM
2607:f8b0:4006:800::200e
AF_INET6 SOCK_RAW
2607:f8b0:4006:800::200e</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_raku_中的换行处理">51. Raku 中的换行处理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>不同的操作系统使用不同的字符或字符的组合来表示换行符。每种语言都有自己的一套规则来处理这个问题。 Raku 有以下几个规则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>字符串字面量中的 <code>\n</code> 表示 Unicode 代码点 10。</p>
</li>
<li>
<p>由 <code>say</code> 附加到字符串的默认 <a href="https://docs.raku.org/routine/nl-out">nl-out</a> 也是 <code>\n</code>。</p>
</li>
<li>
<p>在输出时，当在 Windows 上时，编码器默认将 <code>\n</code> 转换为 <code>\r\n</code>，当它转到文件，进程或终端时（但它不会在套接字上执行此操作）。</p>
</li>
<li>
<p>在输入时，在任何平台上，解码器默认将 <code>\r\n</code> 标准化为 <code>\n</code>，以便从文件，进程或终端（同样不是套接字）输入。</p>
</li>
<li>
<p>以上两点一起意味着你可以 - 把套接字编程放在一边 - 期望永远不会在你的程序中看到 <code>\r\n</code>（这也是许多其他语言的工作原理）。</p>
</li>
<li>
<p><a href="https://docs.raku.org/type/Encoding#method_decoder">:$translate-nl</a> 命名参数存在于控制此转换的各个位置，例如，在 <a href="https://docs.raku.org/type/Proc::Async#method_new">Proc::Async.new</a> 和 <a href="https://docs.raku.org/type/Proc::Async#method_Supply">Proc::Async.Supply</a> 中。</p>
</li>
<li>
<p>正则表达式语言中的 <code>\n</code> 是合乎逻辑的，并且匹配 <code>\r\n</code>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以通过在创建该句柄时设置 <code>:nl-out</code> 属性来更改特定句柄的默认行为。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $crlf-out = open(IO::Special.new('&lt;STDOUT&gt;'), :nl-out("\\\n\r"));
$*OUT.say: 1;     #OUTPUT: «1␤»
$crlf-out.say: 1; #OUTPUT: «1\␤␍»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，我们通过使用 <a href="https://docs.raku.org/type/IO::Special">IO::Special</a> 将标准输出复制到新句柄，我们在字符串的末尾附加一个 <code>\</code>，然后是换行符 <code>␤</code> 和回车符 <code>␍</code>; 我们打印到该句柄的所有内容都会在行尾添加这些字符，如图所示。</p>
</div>
<div class="paragraph">
<p>在正则表达式中，<a href="https://docs.raku.org/language/regexes#index-entry-regex_%5Cn-regex_%5CN-%5Cn_and_%5CN">\n</a> 是根据<a href="https://unicode.org/reports/tr18/#Line_Boundaries">逻辑换行符的Unicode定义</a>定义的。它会匹配 <code>.</code>, 还有 <code>\v</code>，以及包含空格的任何类。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_数值">52. 数值</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_int_2">52.1. Int</h3>
<div class="paragraph">
<p><code>Int</code> 类型提供任意大小的整数。它们可以像计算机内存允许的那样大，虽然有些实现在被要求生成真正惊人大小的整数时会选择抛出数字溢出错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 10**600**600
# OUTPUT: «Numeric overflow»</code></pre>
</div>
</div>
<div class="paragraph">
<p>与某些语言不同，当两个操作数都是 <a href="https://docs.raku.org/type/Int">Int</a> 类型时，使用<a href="https://docs.raku.org/routine/$SOLIDUS">`/`运算符</a>执行除法将生成小数，而不执行任何舍入。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 4/5; # OUTPUT: «0.8»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种除法产生的类型是 <a href="https://docs.raku.org/type/Rat">Rat</a> 或 <a href="https://docs.raku.org/type/Num">Num</a> 类型。换算后，如果分数的分母是小于64位，则产生 <a href="https://docs.raku.org/type/Rat">Rat</a>, 否则产生 <a href="https://docs.raku.org/type/Num">Num</a> 类型。</p>
</div>
<div class="paragraph">
<p>如果你想落得 <a href="https://docs.raku.org/type/Int">Int</a> 的结果，那么 <a href="https://docs.raku.org/routine/div">div</a> 和 <a href="https://docs.raku.org/routine/narrow">narrow</a> 例程可能会有帮助，只要有可能。<a href="https://docs.raku.org/routine/div">div</a>运算符执行整除，丢弃余数，而<a href="https://docs.raku.org/routine/narrow">narrow</a> 会把数拟合到它适合的最窄类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 5 div 2; # OUTPUT: «2»

# Result `2` is narrow enough to be an Int:
say (4/2).narrow; # OUTPUT: «2»
say (4/2).narrow.^name; # OUTPUT: «Int»

# But 2.5 has fractional part, so it ends up being a Rat type:
say (5/2).narrow.^name; # OUTPUT: «Rat»
say (5/2).narrow;       # OUTPUT: «2.5»

# Denominator is too big for a Rat, so a Num is produced:
say 1 / 10⁹⁹; # OUTPUT: «1e-99»</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 具有 <a href="https://docs.raku.org/type/FatRat">FatRat</a> 类型，可提供任意精度的分数。为什么在上一个例子中生成了有限精度的 <a href="https://docs.raku.org/type/Num">Num</a> 而不是 <a href="https://docs.raku.org/type/FatRat">FatRat</a> 类型？原因是：性能。大多数操作都很好，精度损失很少，因此不需要使用更昂贵的 <a href="https://docs.raku.org/type/FatRat">FatRat</a> 类型。如果您希望获得额外的精度，则需要自己实例化一个。</p>
</div>
</div>
<div class="sect2">
<h3 id="_num">52.2. <code>Num</code></h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Num">Num</a> 类型提供 <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">双精度浮点</a>十进制数，在其他语言中有时被称为“doubles”。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Num">Num</a> 字面量的写法是使用字母 <code>e</code> 与指数分割开。请记住，即使指数为零，字母`e` <strong>也是必需的</strong>，否则您将得到一个<a href="https://docs.raku.org/type/Rat">Rat</a> 有理数字面量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 42e0.^name; # OUTPUT: «Num»
say 42.0.^name; # OUTPUT: «Rat»</code></pre>
</div>
</div>
<div class="paragraph">
<p>区分大小写的单词 <a href="https://docs.raku.org/type/Num#Inf">Inf</a> 和 <a href="https://docs.raku.org/type/Num#NaN">NaN</a> 分别表示特殊值 infinity 和 not-a-number。可以使用 U+221E INFINITY（<code>∞</code>）字符代替 <a href="https://docs.raku.org/type/Num#Inf">Inf</a>：</p>
</div>
<div class="paragraph">
<p>Raku  尽可能遵循<a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754-2008浮点运算标准，</a>计划在以后的语言版本中实现更多的一致性。该语言保证为任何给定的 <a href="https://docs.raku.org/type/Num">Num</a> 字面量选择最接近的可表示数字，并且确实支持负零和<a href="https://en.wikipedia.org/wiki/Denormal_number">非正规</a>（也称为“次正规”）。</p>
</div>
<div class="paragraph">
<p>请记住，像 <a href="https://docs.raku.org/routine/say">say</a> 或 <a href="https://docs.raku.org/routine/put">put</a> 这样的输出例程不会非常难以区分输出<a href="https://docs.raku.org/type/Numeric">数字</a>类型的方式，并且可能选择将<a href="https://docs.raku.org/type/Num">Num</a>显示为<a href="https://docs.raku.org/type/Int">Int</a>或<a href="https://docs.raku.org/type/Rat">Rat</a>数字。要获得更明确的输出字符串，请使用<a href="https://docs.raku.org/routine/perl">perl</a>方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say  1e0;      # OUTPUT: «1»
say .5e0;      # OUTPUT: «0.5»
say  1e0.perl; # OUTPUT: «1e0»
say .5e0.perl; # OUTPUT: «0.5e0»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_complex">52.3. <code>Complex</code></h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Complex_plane">复平面</a>的<a href="https://docs.raku.org/type/Complex">复数</a>型数值。<a href="https://docs.raku.org/type/Complex">复数</a>对象包括两个 <a href="https://docs.raku.org/type/Num">Num</a> 对象以表示复数的<a href="https://docs.raku.org/routine/re">实部</a>和<a href="https://docs.raku.org/routine/im">虚部</a>。</p>
</div>
<div class="paragraph">
<p>要创建<a href="https://docs.raku.org/type/Complex">复数</a>，可以在任何其他非复数上使用<a href="https://docs.raku.org/routine/i">后缀`i`运算符</a>，可选择使用加法设置实部。要使用`i`运算符作用在 <code>NaN</code> 或 <code>Inf</code> 字面量上，请使用反斜杠将其与它们分开。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 42i;      # OUTPUT: «0+42i»
say 73+42i;   # OUTPUT: «73+42i»
say 73+Inf\i; # OUTPUT: «73+Inf\i»</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住，上面的语法只是一个附加表达式和优先级规则适用。它也不能用于禁止表达式的地方，例如常规参数中的字面量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Precedence of `*` is higher than that of `+`
say 2 * 73+10i; # OUTPUT: «146+10i»</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了避免这些问题，您可以选择使用<a href="https://docs.raku.org/type/Complex">复数</a>字面量语法，其中包括使用尖括号包围实部和虚部，<strong>而不包含任何空格</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 2 * &lt;73+10i&gt;; # OUTPUT: «146+20i»

multi how-is-it (&lt;2+4i&gt;) { say "that's my favorite number!" }
multi how-is-it (|)      { say "meh"                        }
how-is-it 2+4i;  # OUTPUT: «that's my favorite number!»
how-is-it 3+2i;  # OUTPUT: «meh»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_rational">52.4. <code>Rational</code></h3>
<div class="paragraph">
<p>执行 <a href="https://docs.raku.org/type/Rational">Rational</a> 角色的类型提供高精度和任意精度的十进制数。由于精度越高，性能损失越大，<a href="https://docs.raku.org/type/Rational">Rational</a> 类型有两种形式：<a href="https://docs.raku.org/type/Rat">Rat</a> 和 <a href="https://docs.raku.org/type/FatRat">FatRat</a>。<a href="https://docs.raku.org/type/Rat">Rat</a> 是最常用的变体, 其在大多数情况下降级成 <a href="https://docs.raku.org/type/Num">Num</a>，当它不再能容纳所有的要求精度时。<a href="https://docs.raku.org/type/FatRat">FatRat</a> 是保持增长提供所有所需的精度任意精度的变体。</p>
</div>
<div class="sect3">
<h4 id="_rat">52.4.1. <code>Rat</code></h4>
<div class="paragraph">
<p>最常见的 <a href="https://docs.raku.org/type/Rational">Rational</a> 类型。它支持有 64 位分母的有理数（在将分数换算到最小分母之后）。<code>Rat</code> 可以直接创建具有较大分母的对象，但是，当具有这样的分母的 <code>Rat</code> 是数学运算的结果时，它们会降级为 <a href="https://docs.raku.org/type/Num">Num</a> 对象。</p>
</div>
<div class="paragraph">
<p>在许多其他语言中 <a href="https://docs.raku.org/type/Rat">Rat</a> 字面量使用和 <a href="https://docs.raku.org/type/Num">Num</a> 字面量类似的语法，使用点来表示数字是十进制：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say .1 + .2 == .3; # OUTPUT: «True»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你在许多常用语言中执行与上述类似的语句, 由于浮点数学的精度，您将得到 <code>False</code> 作为答案。要在 Raku 中获得相同的结果，你必须使用 <a href="https://docs.raku.org/type/Num">Num</a> 字面量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say .1e0 + .2e0 == .3e0; # OUTPUT: «False»</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use <a href="https://docs.raku.org/routine/$SOLIDUS"><code>/</code> division operator</a> with <a href="https://docs.raku.org/type/Int">Int</a> or <a href="https://docs.raku.org/type/Rat">Rat</a> objects to produce a <a href="https://docs.raku.org/type/Rat">Rat</a>:</p>
</div>
<div class="paragraph">
<p>您还可以使用具有 <a href="https://docs.raku.org/type/Int">Int</a> 或 <a href="https://docs.raku.org/type/Rat">Rat</a> 对象的<a href="https://docs.raku.org/routine/$SOLIDUS">`/`除法运算符</a>来生成 <a href="https://docs.raku.org/type/Rat">Rat</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 3/4;     # OUTPUT: «0.75»
say 3/4.2;   # OUTPUT: «0.714286»
say 1.1/4.2; # OUTPUT: «0.261905»</code></pre>
</div>
</div>
<div class="paragraph">
<p>Keep in mind the above syntax is just a division expression and precedence rules apply. It also cannot be used in places that forbid expressions, such as literals in routine parameters.</p>
</div>
<div class="paragraph">
<p>请记住，上面的语法只是一个应用了优先级规则的除法表达式。它也不能用于禁止表达式的地方，例如例程参数中的字面量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Precedence of power operators is higher than division
say 3/2²; # OUTPUT: «0.75»</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了避免这些问题，您可以选择使用 <a href="https://docs.raku.org/type/Rational">Rational</a> 字面量语法，它用尖括号括起分子和分母，<strong>不带任何空格</strong>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &lt;3/2&gt;²; # OUTPUT: «2.25»

multi how-is-it (&lt;3/2&gt;) { say "that's my favorite number!" }
multi how-is-it (|)     { say "meh"                        }
how-is-it 3/2;  # OUTPUT: «that's my favorite number!»
how-is-it 1/3;  # OUTPUT: «meh»</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，任何具有 <code>No</code> 属性的表示小数的 Unicode 字符都可以用作<a href="https://docs.raku.org/type/Rat">Rat</a> 字面量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ½ + ⅓ + ⅝ + ⅙; # OUTPUT: «1.625»</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_分解为_num">分解为 <code>Num</code></h5>
<div class="paragraph">
<p>If a <strong>mathematical operation</strong> that produces a <a href="https://docs.raku.org/type/Rat">Rat</a> answer would produce a <a href="https://docs.raku.org/type/Rat">Rat</a> with denominator larger than 64 bits, that operation would instead return a <a href="https://docs.raku.org/type/Num">Num</a> object. When <strong>constructing</strong> a <a href="https://docs.raku.org/type/Rat">Rat</a> (i.e. when it is not a result of some mathematical expression), however, a larger denominator can be used:</p>
</div>
<div class="paragraph">
<p>如果产生 <a href="https://docs.raku.org/type/Rat">Rat</a> 答案的*数学运算*会产生分母大于64位的 <a href="https://docs.raku.org/type/Rat">Rat</a>，则该操作将返回 <a href="https://docs.raku.org/type/Num">Num</a> 对象。当*构建*一个<a href="https://docs.raku.org/type/Rat">Rat</a>（即，当它不是一些数学表达式的结果）时，但是，更大的分母可以使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 1 / (2⁶⁴ - 1);
say $a;                   # OUTPUT: «0.000000000000000000054»
say $a.^name;             # OUTPUT: «Rat»
say $a.nude;              # OUTPUT: «(1 18446744073709551615)»

my $b = 1 / 2⁶⁴;
say $b;                   # OUTPUT: «5.421010862427522e-20»
say $b.^name;             # OUTPUT: «Num»

my $c = Rat.new(1, 2⁶⁴);
say $c;                   # OUTPUT: «0.000000000000000000054»
say $c.^name;             # OUTPUT: «Rat»
say $c.nude;              # OUTPUT: «(1 18446744073709551616)»
say $c.Num;               # OUTPUT: «5.421010862427522e-20»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_fatrat">52.4.2. <code>FatRat</code></h4>
<div class="paragraph">
<p>最后一个 <a href="https://docs.raku.org/type/Rational">Rational</a> 类型 - <a href="https://docs.raku.org/type/FatRat">FatRat</a> - 保留你所要求的所有精度，将分子和分母存储为两个 <a href="https://docs.raku.org/type/Int">Int</a> 对象。<a href="https://docs.raku.org/type/FatRat">FatRat</a> 比 <a href="https://docs.raku.org/type/Rat">Rat</a> 更具传染性，有这么多的 <a href="https://docs.raku.org/type/FatRat">FatRat</a> 数学运算会产生另一个 <a href="https://docs.raku.org/type/FatRat">FatRat</a>，保留所有可用的精度。当 <a href="https://docs.raku.org/type/Rat">Rat</a> 退化为 <a href="https://docs.raku.org/type/Num">Num</a> 时，使用 <a href="https://docs.raku.org/type/FatRat">FatRat </a> 的数学运算会持续不断：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ((42 + Rat.new(1,2))/999999999999999999).^name;         # OUTPUT: «Rat»
say ((42 + Rat.new(1,2))/9999999999999999999).^name;        # OUTPUT: «Num»
say ((42 + FatRat.new(1,2))/999999999999999999).^name;      # OUTPUT: «FatRat»
say ((42 + FatRat.new(1,2))/99999999999999999999999).^name; # OUTPUT: «FatRat»</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有特殊的运算符或语法可用于构造 <a href="https://docs.raku.org/type/FatRat">FatRat</a> 对象。只需使用 <a href="https://docs.raku.org/type/FatRat#%28Rational%29_method_new"><code>FatRat.new</code></a> 方法，将分子作为第一个位置参数，将分母作为第二个位置参数。</p>
</div>
<div class="paragraph">
<p>如果您的程序需要大量的 <a href="https://docs.raku.org/type/FatRat">FatRat</a> 创建，您可以创建自己的自定义运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;🙼&gt; { FatRat.new: $^a, $^b }
say (1🙼3).perl; # OUTPUT: «FatRat.new(1, 3)»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_打印_rationals">52.4.3. 打印 rationals</h4>
<div class="paragraph">
<p>请记住，像 <a href="https://docs.raku.org/routine/say">say</a> 或 <a href="https://docs.raku.org/routine/put">put</a> 这样的输出例程不会力图区分<a href="https://docs.raku.org/type/Numeric">数字</a>类型如何输出，并且可能选择将 <a href="https://docs.raku.org/type/Num">Num</a> 显示为 <a href="https://docs.raku.org/type/Int">Int</a> 或 <a href="https://docs.raku.org/type/Rat">Rat</a> 数字。要获得更明确的输出字符串，请使用 <a href="https://docs.raku.org/routine/perl">perl</a> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1.0;        # OUTPUT: «1»
say ⅓;          # OUTPUT: «0.333333»
say 1.0.perl;   # OUTPUT: «1.0»
say ⅓.perl;     # OUTPUT: «&lt;1/3&gt;»</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多信息，您可以选择在 <a href="https://docs.raku.org/routine/nude">nude</a> 中查看 <a href="https://docs.raku.org/type/Rational">Rational</a> 对象，显示其分子和分母：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ⅓;          # OUTPUT: «0.333333»
say 4/2;        # OUTPUT: «2»
say ⅓.perl;     # OUTPUT: «&lt;1/3&gt;»
say &lt;4/2&gt;.nude; # OUTPUT: «(2 1)»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_除零">52.5. 除零</h3>
<div class="paragraph">
<p>在许多语言中，除以零立马会抛出一个异常。在 Raku 中，会发生什么取决于你要除的东西以及你如何使用结果。</p>
</div>
<div class="paragraph">
<p>Raku 遵循 <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754-2008浮点运算标准</a>，但由于历史原因，6.c 和 6.d 语言版本不完全符合。<a href="https://docs.raku.org/type/Num">Num</a>被零除产生 <a href="https://docs.raku.org/type/Failure">Failure</a>，而<a href="https://docs.raku.org/type/Complex">复数</a>被零除产生 <code>NaN</code> 部件, 无论分子是什么。</p>
</div>
<div class="paragraph">
<p>从 6.e 语言开始，<a href="https://docs.raku.org/type/Num">Num</a> 和 <a href="https://docs.raku.org/type/Complex">Complex</a> 除以零将产生<a href="https://docs.raku.org/type/Num#Inf">-Inf</a>，<code>+Inf</code> 或 <a href="https://docs.raku.org/type/Num#NaN">NaN</a>, 这取决于分子分别是负数，正数还是零（对于<a href="https://docs.raku.org/type/Complex">复数</a>，实部和虚部是 <a href="https://docs.raku.org/type/Num">Num</a> 并且被分别考虑）。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Int">Int</a> 数字的除法产生一个 <a href="https://docs.raku.org/type/Rat">Rat</a> 对象（或 <a href="https://docs.raku.org/type/Num">Num</a>，如果在换算之后分母大于64位，当你除以零时就不是这种情况）。这意味着这种除法永远不会产生<a href="https://docs.raku.org/type/Exception">异常</a>或<a href="https://docs.raku.org/type/Failure">失败</a>。结果是零分母有理数，这可能是爆炸性的。</p>
</div>
<div class="sect3">
<h4 id="_zero_denominator_rationals">52.5.1. Zero-denominator rationals</h4>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/FatRat">零分母</a> 有理数是一个扮演 <a href="https://docs.raku.org/type/Rational">Rational</a> 角色的数字，它在核心数字中将是 <a href="https://docs.raku.org/type/Rat">Rat</a> 和 <a href="https://docs.raku.org/type/FatRat">FatRat</a> 对象，其分母为零。这样根据原始分子是否为负，分别为零或正数, 有理数的分子被归一化到`-1`，<code>0`或`1</code>。</p>
</div>
<div class="paragraph">
<p>可以在不需要实际除法的情况下执行的操作是非爆炸性的。例如，您可以单独检查 <a href="https://docs.raku.org/routine/nude">nude</a> 中的<a href="https://docs.raku.org/routine/numerator">分子</a>和<a href="https://docs.raku.org/routine/denominator">分母</a>，或执行数学运算，而不会出现任何异常或失败。</p>
</div>
<div class="paragraph">
<p>转换零分母有理数到 <a href="https://docs.raku.org/type/Num">Num</a> 遵循 <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE</a> 公约，结果是`-Inf`，<code>Inf</code>，或 <code>NaN</code>，这取决于分子是否分别是负，正，或零。从另一个方面来看也是如此：转换`±Inf`/ `NaN`到其中一个 <a href="https://docs.raku.org/type/Rational">Rational</a> 类型将产生具有适当分子的零分母有理数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say  &lt;1/0&gt;.Num;   # OUTPUT: «Inf»
say &lt;-1/0&gt;.Num;   # OUTPUT: «-Inf»
say  &lt;0/0&gt;.Num;   # OUTPUT: «NaN»
say Inf.Rat.nude; # OUTPUT: «(1 0)»</code></pre>
</div>
</div>
<div class="paragraph">
<p>要求非 <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE</a> 除法的分子和分母的所有其他操作将导致抛出异常 <code>X::Numeric::DivideByZero</code>。最常见的此类操作可能是尝试打印或字符串化零分母有理数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 0/0;
# OUTPUT:
# Attempt to divide by zero using div
#  in block &lt;unit&gt; at -e line 1</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_同质异形">52.6. 同质异形</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/glossary#index-entry-Allomorph">Allomorphs</a> 是两种类型的子类，可以表现为它们中的任何一种。例如，同质异形 <a href="https://docs.raku.org/type/IntStr">IntStr</a> 是 <a href="https://docs.raku.org/type/Int">Int</a> 和 <a href="https://docs.raku.org/type/Str">Str</a> 类型的子类，并且将被需要 <a href="https://docs.raku.org/type/Int">Int</a> 或 <a href="https://docs.raku.org/type/Str">Str</a> 对象的任何类型约束所接受。</p>
</div>
<div class="paragraph">
<p>同质异形可以使用<a href="https://docs.raku.org/language/quoting#Word_quoting%3A_%3C_%3E">尖括号</a>创建，可以单独使用或作为散列键查找的一部分使用; 直接使用方法`.new`，也由一些结构提供，如 <a href="https://docs.raku.org/language/functions#sub_MAIN"><code>sub MAIN</code></a> 的参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &lt;42&gt;.^name;                 # OUTPUT: «IntStr»
say &lt;42e0&gt;.^name;               # OUTPUT: «NumStr»
say &lt; 42+42i&gt;.^name;            # OUTPUT: «ComplexStr»
say &lt; 1/2&gt;.^name;               # OUTPUT: «RatStr»
say &lt;0.5&gt;.^name;                # OUTPUT: «RatStr»

@*ARGS = "42";
sub MAIN($x) { say $x.^name }   # OUTPUT: «IntStr»

say IntStr.new(42, "42").^name; # OUTPUT: «IntStr»</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的几个结构在打开角括号之后有一个空格。那个空格不是故意的。通常使用运算符编写的数字，例如`1/2`（<a href="https://docs.raku.org/type/Rat">Rat</a>，除法运算符）和`1+2i`（<a href="https://docs.raku.org/type/Complex">复数</a>，加法）可以写成不涉及使用运算符的字面值：在尖括号和尖括号里面的字符之间*没有*任何空格。通过在尖括号中添加空格，我们告诉编译器我们不仅需要 <a href="https://docs.raku.org/type/Rat">Rat</a> 或 <a href="https://docs.raku.org/type/Complex">Complex</a> 字面量，而且我们还希望它是一个allomorph：在这种情况下是 <a href="https://docs.raku.org/type/RatStr">RatStr</a> 或 <a href="https://docs.raku.org/type/ComplexStr">ComplexStr</a>。</p>
</div>
<div class="paragraph">
<p>如果数字字面量不使用任何运算符，则将其写入尖括号内，即使不包含任何空格，也会产生同形异形体。（逻辑：如果你不想要同质异形，你就不会使用尖括号。对于使用运算符的数字也是如此，因为某些结构，例如签名字面量，不允许你使用运算符，所以你不能只为这些数字字面量省略尖括号）。</p>
</div>
<div class="sect3">
<h4 id="_可用的同质异形">52.6.1. 可用的同质异形</h4>
<div class="paragraph">
<p>核心语言提供以下同质异形：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Allomorph of</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Example</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IntStr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int and Str</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;42&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NumStr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Num and Str</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;42e0&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ComplexStr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Complex and Str</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt; 1+2i&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RatStr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rat and Str</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;1.5&gt;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>注意：没有`FatRatStr`类型。</p>
</div>
</div>
<div class="sect3">
<h4 id="_coercion_of_allomorphs">52.6.2. Coercion of allomorphs</h4>
<div class="paragraph">
<p>请记住，同质异形只是它们所代表的两种（或三种）类型的子类。正如变量或参数类型约束为`Foo`可以接受任何 <code>Foo</code> 子类一样，所以变量或参数类型约束为 <a href="https://docs.raku.org/type/Int">Int</a> 的将接受 <a href="https://docs.raku.org/type/IntStr">IntStr</a> 同质异形：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub foo(Int $x) { say $x.^name }
foo &lt;42&gt;;                          # OUTPUT: «IntStr»
my Num $y = &lt;42e0&gt;;
say $y.^name;                      # OUTPUT: «NumStr»</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，这也适用于参数<a href="https://docs.raku.org/type/Signature#Coercion_type">coercers</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub foo(Int(Cool) $x) { say $x.^name }
foo &lt;42&gt;;  # OUTPUT: «IntStr»</code></pre>
</div>
</div>
<div class="paragraph">
<p>给定的同质异形*已经*是 <a href="https://docs.raku.org/type/Int">Int</a> 类型的对象，因此在这种情况下它不会转换为“普通的”  <a href="https://docs.raku.org/type/Int">Int</a>。</p>
</div>
<div class="paragraph">
<p>当然，如果没有办法将它们“折叠”到其中一个组件，那么同质异形体的力量将会严重减弱。因此，如果你使用所要强制到的类型的名字显式调用方法，那么您将获得该组件。这同样适用于任何代理方法，例如调用方法<a href="https://docs.raku.org/routine/Numeric"><code>.Numeric</code></a>而不是<a href="https://docs.raku.org/routine/Int"><code>.Int</code></a>或使用<a href="https://docs.raku.org/routine/<sub>"><code>prefix:&lt;</sub>&gt; `</a>运算符而不是<a href="https://docs.raku.org/routine/Str"></code>.Str`</a>方法调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $al := IntStr.new: 42, "forty two";
say $al.Str;  # OUTPUT: «forty two»
say +$al;     # OUTPUT: «42»

say &lt;1/99999999999999999999&gt;.Rat.^name;    # OUTPUT: «Rat»
say &lt;1/99999999999999999999&gt;.FatRat.^name; # OUTPUT: «FatRat»</code></pre>
</div>
</div>
<div class="paragraph">
<p>强制整个同质异形体列表的一种方便方法是将 <a href="https://docs.raku.org/language/operators#Hyper_operators">hyper</a> 运算符应用于适当的前缀：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say map *.^name,   &lt;42 50e0 100&gt;;  # OUTPUT: «(IntStr NumStr IntStr)»
say map *.^name, +«&lt;42 50e0 100&gt;;  # OUTPUT: «(Int Num Int)»
say map *.^name, ~«&lt;42 50e0 100&gt;;  # OUTPUT: «(Str Str Str)»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_object_identity">52.6.3. Object identity</h4>
<div class="paragraph">
<p>当我们考虑对象一致性时，上面关于强制同形异形的讨论变得更加重要。一些构造利用它来确定两个对象是否“相同”。而对于人类而言，同质异形`42`和常规的`42`可能看起来“相同”，对于那些构造，它们是完全不同的对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># "42" shows up twice in the result: 42 and &lt;42&gt; are different objects:
say unique 1, 1, 1, 42, &lt;42&gt;; # OUTPUT: «(1 42 42)»
# Use a different operator to `unique` with:
say unique :with(&amp;[==]), 1, 1, 1, 42, &lt;42&gt;; # OUTPUT: «(1 42)»
# Or coerce the input instead (faster than using a different `unique` operator):
say unique :as(*.Int), 1, 1, 1, 42, &lt;42&gt;; # OUTPUT: «(1 42)»
say unique +«(1, 1, 1, 42, &lt;42&gt;);         # OUTPUT: «(1 42)»

# Parameterized Hash with `Any` keys does not stringify them; our key is of type `Int`:
my %h{Any} = 42 =&gt; "foo";
# But we use the allomorphic key of type `IntStr`, which is not in the Hash:
say %h&lt;42&gt;:exists;           # OUTPUT: «False»
# Must use curly braces to avoid the allomorph:
say %h{42}:exists;           # OUTPUT: «True»

# We are using a set operator to look up an `Int` object in a list of `IntStr` objects:
say 42 ∈ &lt;42 100 200&gt;; # OUTPUT: «False»
# Convert it to an allomorph:
say &lt;42&gt; ∈ &lt;42 100 200&gt;; # OUTPUT: «True»
# Or convert the items in the list to plain `Int` objects:
say 42 ∈ +«&lt;42 100 200&gt;; # OUTPUT: «True»</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意这些对象一致性的差异，并根据需要强制你的同形异形体。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_原生数字">52.7. 原生数字</h3>
<div class="paragraph">
<p>顾名思义，原生数字可以访问原生数字 - 即由硬件直接提供的数字。这反过来又提供两个功能：溢出/下溢和更好的性能。</p>
</div>
<div class="paragraph">
<p><strong>注意：</strong>在撰写本文时（2018.05），某些实现（例如 Rakudo）提供了有关原生类型的一些细节，例如  <code>int64</code> 是否可用且在32位计算机上具有64位大小，以及如何检测何时你的程序正在这样的硬件上运行。</p>
</div>
<div class="sect3">
<h4 id="_可用的原生数字">52.7.1. 可用的原生数字</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Native type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Base numeric</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Size</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">atomicint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sized to offer CPU-provided atomic operations. (typically 64 bits on 64-bit platforms and 32 bits on 32-bit ones)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64-bits</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16-bits</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32-bits</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64-bits</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8-bits</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">num</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">floating point</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64-bits</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">num32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">floating point</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32-bits</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">num64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">floating point</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64-bits</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unsigned integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64-bits</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unsigned integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16-bits</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unsigned integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32-bits</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unsigned integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64-bits</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unsigned integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8-bits</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_创建原生数字">52.7.2. 创建原生数字</h4>
<div class="paragraph">
<p>要创建原生类型的变量或参数，只需使用其中一个可用数字的名称作为类型约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my int32 $x = 42;
sub foo(num $y) {}
class { has int8 $.z }</code></pre>
</div>
</div>
<div class="paragraph">
<p>有时，您可能希望在不创建任何可用变量的情况下将某些值强制转换为原生类型。没有`.int`或类似的强制方法（方法调用是后期的，所以它们不适合这个目的）。相反，只需使用匿名变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">some-native-taking-sub (my int $ = $y), (my int32 $ = $z)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_溢出下溢">52.7.3. 溢出/下溢</h4>
<div class="paragraph">
<p>尝试<strong>分配</strong>不适合特定原生类型的值会产生异常。这包括尝试为原生参数提供过大的参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my int $x = 2¹⁰⁰;
# OUTPUT:
# Cannot unbox 101 bit wide bigint into native integer
#  in block &lt;unit&gt; at -e line 1

sub f(int $x) { $x }; say f 2⁶⁴
# OUTPUT:
# Cannot unbox 65 bit wide bigint into native integer
#   in sub f at -e line 1
#   in block &lt;unit&gt; at -e line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，以这样一种太大/太小的方式修改已存在的值会产生溢出/下溢行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my int $x = 2⁶³-1;
say $x;             # OUTPUT: «9223372036854775807»
say ++$x;           # OUTPUT: «-9223372036854775808»

my uint8 $x;
say $x;             # OUTPUT: «0»
say $x -= 100;      # OUTPUT: «156»</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建使用原生类型的对象不涉及程序员的直接分配; 这就是为什么这些构造提供溢出/下溢行为而不是抛出异常。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Buf.new(1000, 2000, 3000).List; # OUTPUT: «(232 208 184)»
say my uint8 @a = 1000, 2000, 3000; # OUTPUT: «232 208 184»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_auto_boxing">52.7.4. Auto-boxing</h4>
<div class="paragraph">
<p>虽然它们可以被称为“<strong>原生类型</strong> ”，但原生数字实际上并不是具有任何可用方法的类。但是，您*可以*调用这些数字的非原生版本上可用的任何方法。这是怎么回事？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my int8 $x = -42;
say $x.abs; # OUTPUT: «42»</code></pre>
</div>
</div>
<div class="paragraph">
<p>此行为称为“自动装箱”。编译器使用所有方法自动将原生类型“装箱”为功能齐全的高级类型。换句话说，`int8`上面的内容自动转换为<a href="https://docs.raku.org/type/Int">Int，</a>然后它是<a href="https://docs.raku.org/type/Int">Int</a>类，然后提供被调用的<a href="https://docs.raku.org/routine/abs">abs</a>方法。</p>
</div>
<div class="paragraph">
<p>当您使用原生类型获得性能提升时，此详细信息非常重要。如果您正在使用的代码导致执行大量自动装箱，那么使用原生类型的性能可能会比使用非原生类型时*更差*：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = -42;
my int $a-native = -42;
{ for ^1000_000 { $a.abs        }; say now - ENTER now } # OUTPUT: «0.38180862»
{ for ^1000_000 { $a-native.abs }; say now - ENTER now } # OUTPUT: «0.938720»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见，原生变体的速度慢了两倍多。原因是方法调用需要将原生类型装箱，而非原生变体不需要这样的东西，因此性能损失。</p>
</div>
<div class="paragraph">
<p>在这种特殊情况下，我们可以简单地切换到<a href="https://docs.raku.org/routine/abs">abs</a>的子程序形式，它可以使用原生类型而无需装箱。在其他情况下，您可能需要寻找其他解决方案以避免过多的自动装箱，包括切换到部分代码的非原生类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = -42;
my int $a-native = -42;
{ for ^1000_000 { abs $a        }; say now - ENTER now } # OUTPUT: «0.38229177»
{ for ^1000_000 { abs $a-native }; say now - ENTER now } # OUTPUT: «0.3088305»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_默认值">52.7.5. 默认值</h4>
<div class="paragraph">
<p>由于原生类型后面没有类，因此通常没有使用尚未初始化的变量获得的类型对象。因此，原生类型自动初始化为零。在6.c语言，原生的浮点类型（<code>num</code>，<code>num32</code>，和`num64`）被初始化为值 <code>NaN</code>; 在 6.d 语言中默认为 <code>0e0</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_原生分派">52.7.6. 原生分派</h4>
<div class="paragraph">
<p>例如，当大小可预测时，可以使原生候选者与非原生候选者一起提供具有原生候选者的更快算法，但是否则回退到较慢的非原生候选者。以下是涉及原生候选人的多重分派的规则。</p>
</div>
<div class="paragraph">
<p>首先，原生类型的大小在分派中不起作用，并且`int8`被认为与`int16`或`int` 例如，当大小可预测时，可以使本地候选者与非本地候选者一起提供具有本地候选者的更快算法，但是否则回退到较慢的非本地候选者。以下是涉及本地候选人的多次派遣的规则。</p>
</div>
<div class="paragraph">
<p>首先，原生类型的大小在调度中不起作用，并且`int8`被认为与`int16`或`int` 相同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi foo(int   $x) { say "int" }
multi foo(int32 $x) { say "int32" }
foo my int $x = 42;
# OUTPUT:
# Ambiguous call to 'foo(Int)'; these signatures all match:
# :(int $x)
# :(int32 $x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>其次，如果例程是一个 <code>only</code>-ie，它不是一个<a href="https://docs.raku.org/language/functions#Multi-dispatch"><code>multi</code></a>非原生类型，而是在调用期间给出一个原生类型，反之亦然，那么参数将被自动装箱或自动取消装箱以使可以被调用。如果给定的参数太大而无法放入native参数，则会抛出异常：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">-&gt; int {}( 42 );            # OK; auto-unboxing
-&gt; int {}( 2¹⁰⁰ );          # Too large; exception
-&gt; Int {}( 2¹⁰⁰ );          # OK; non-native parameter
-&gt; Int {}( my int $ = 42 ); # OK; auto-boxing</code></pre>
</div>
</div>
<div class="paragraph">
<p>当涉及到<a href="https://docs.raku.org/language/functions#Multi-dispatch"><code>multi</code></a>例程时，如果没有可用的原生候选者，则原生参数将始终自动装箱：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi foo (Int $x) { $x }
say foo my int $ = 42; # OUTPUT: «42»</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种方式是不能提供相同的 luxury。如果只有原生候选者可用，则非原生参数将*不会*被自动取消装箱，而是指示不会抛出匹配的候选者的异常（这种不对称的原因是原生类型总是可以装箱，但是非原生的可能太大而无法融入原生）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi f(int $x) { $x }
my $x = 2;
say f $x;
# OUTPUT:
# Cannot resolve caller f(Int); none of these signatures match:
#     (int $x)
#   in block &lt;unit&gt; at -e line 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果正在进行调用，其中一个参数是原生类型而另一个是<a href="https://docs.raku.org/language/syntax#Number_literals">数字字面量</a>，则放弃此规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi f(int, int) {}
f 42, my int $x; # Successful call</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样，您就不必不断将诸如 <code>$n +&gt; 2</code> 写为 <code>$n +&gt; (my int $ = 2)</code> 了。编译器知道字面量小到足以适合原生类型并将其转换为原生类型。</p>
</div>
</div>
<div class="sect3">
<h4 id="_原子操作">52.7.7. 原子操作</h4>
<div class="paragraph">
<p>该语言提供了一些保证以原子方式执行的<a href="https://docs.raku.org/type/atomicint">操作</a>，即安全地由多个线程执行而无需锁定而没有数据争用的风险。</p>
</div>
<div class="paragraph">
<p>对于此类操作，需要<a href="https://docs.raku.org/type/atomicint">atomicint</a>原生类型。此类型与普通原生<a href="https://docs.raku.org/type/int">int</a>类似，不同之处在于它的大小使得可以对其执行CPU提供的原子操作。在32位CPU上，它通常是32位大小，而在64位CPU上，它通常是64位大小。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># !!WRONG!! Might be non-atomic on some systems
my int $x;
await ^100 .map: { start $x⚛++ };
say $x; # OUTPUT: «98»

# RIGHT! The use of `atomicint` type guarantees operation is atomic
my atomicint $x;
await ^100 .map: { start $x⚛++ };
say $x; # OUTPUT: «100»</code></pre>
</div>
</div>
<div class="paragraph">
<p>相似性`int`也存在于多重分派中： <code>atomicint</code>，普通的 `int`和固定大小的`int`变量都是相同的，并且不能通过多重分派来区分。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_numeric_infectiousness">52.8. Numeric infectiousness</h3>
<div class="paragraph">
<p>当一些数学运算中涉及两个不同类型的数字时，数字“传递性”决定了结果类型。如果结果是该类型而不是其他操作数的类型，则认为类型比其他类型更具传递性。例如，<a href="https://docs.raku.org/type/Num">Num</a>类型比<a href="https://docs.raku.org/type/Int">Int</a>更具传递性，因此我们可以期望`42e0 + 42`产生<a href="https://docs.raku.org/type/Num">Num</a>作为结果。</p>
</div>
<div class="paragraph">
<p>传递性如下，首先列出最具传递性的类型</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Complex</p>
</li>
<li>
<p>Num</p>
</li>
<li>
<p>FatRat</p>
</li>
<li>
<p>Rat</p>
</li>
<li>
<p>Int</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (2 + 2e0).^name; # Int + Num =&gt; OUTPUT: «Num»
say (½ + ½).^name; # Rat + Rat =&gt; OUTPUT: «Rat»
say (FatRat.new(1,2) + ½).^name; # FatRat + Rat =&gt; OUTPUT: «FatRat»</code></pre>
</div>
</div>
<div class="paragraph">
<p>同质异形体具有与其数字成分相同的传递性。原生类型获得自动装箱，并具有与其盒装变体相同的传递性。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_raku_中的面向对象">53. Raku 中的面向对象</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 有很多预先定义好的类型，这些类型可以归为 2 类：<code>普通类型`和`原生类型</code>。原生类型用于`底层类型`（例如 uint 64）。原生类型没有和对象同样的功能，尽管你可以在它们身上调用方法， 它们还是被包装成普通的对象。所有你能存储到变量中的东西要么是一个原生的 value， 要么是一个对象。这包括字面值、类型（类型对象）、code 和容器。</p>
</div>
<div class="sect2">
<h3 id="_使用对象">53.1. 使用对象</h3>
<div class="paragraph">
<p>方法可以有参数， 但是方法名和参数列表之间不可以有空格：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "abc".uc;
#        ^^^ 不带参数的方法调用
my @words = $string.comb(/\w+/);
#                  ^^^^^^^^^^^^ 带一个参数的方法调用</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外一种方法调用的语法将方法名和参数列表用一个冒号分开(冒号紧跟方法名, 中间不能有空格):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @*INC.join: ':';</code></pre>
</div>
</div>
<div class="paragraph">
<p>方法能返回一个可变容器, 这种情况下 你可以赋值给方法调用的返回值.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$*IN.input-line-separator = "\r\n";</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类型对象">53.2. 类型对象</h3>
<div class="paragraph">
<p>Types本身就是对象 ，你可以使用类型的名字获取 type object :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $int-type-obj = Int;</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以通过调用 WHAT 方法查看任何对象的 type object(它实际上是一个方法形式的macro):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $int-type-obj = 1.WHAT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 === 操作符可以比较 类型对象的相等性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f(Int $x) {
    if $x.WHAT === Int {
        say 'you passed an Int';
    }
    else {
        say 'you passed a subtype of Int';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>子类型可以使用 smart-matching来检查：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $type ~~ Real {
    say '$type contains Real or a subtype thereof';
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类">53.3. 类</h3>
<div class="paragraph">
<p>使用 class 关键字进行类的定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Journey {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>声明一个词法作用域的类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my class Journey {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这在嵌套类中很有用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_属性">53.4. 属性</h3>
<div class="paragraph">
<p>属性存在于每个类的实例中。属性中存储着对象的状态。在 Raku 中, 一切属性都是`私有的`.  它们一般使用 <code>has</code> 关键字和 <code>!</code> twigil 进行声明.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Journey {
    has $!origin;
    has $!destination;
    has @!travellers;
    has $!notes;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而, 没有像这样的公共(甚至保护属性)属性, 不过有一种方式能`自动生成访问方法`: 使用 <code>. `代替 `!</code> twigil 。(那个 <code>.</code> 应该让你想起了<strong>方法调用</strong>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Journey {
    has $.origin;
    has $.destination;
    has @!travellers;
    has $.notes;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这默认提供了一种<strong>只读</strong>的取值方法, 为了允许更改属性, 要添加 <code>is rw</code> 特性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Journey {
    has $.origin;
    has $.destination;
    has @!travellers;
    has $.notes is rw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为类默认继承于构造器 <code>Mu</code>, 我们也要求类为我们生成一些<strong>存取方法</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># 创建一个新的类的实例.
my $vacation = Journey.new(
    origin      =&gt; 'Sweden',
    destination =&gt; 'Switzerland',
    notes       =&gt; 'Pack hiking gear!'
);
# 使用存取器; 这打印出 Sweden.
say $vacation.origin;
# 使用 rw 存取器来更改属性的值.
$vacation.notes = 'Pack hiking gear and sunglasses!';</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, 默认的构造器只会设置含有存取器方法的属性.</p>
</div>
</div>
<div class="sect2">
<h3 id="_方法_2">53.5. 方法</h3>
<div class="paragraph">
<p>使用 <code>method</code> 关键字定义类中的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Journey {
    has $.origin;
    has $.destination;
    has @!travellers;
    has $.notes is rw;

    method add_traveller($name) {
        if $name ne any(@!travellers) {
            push @!travellers, $name;
        }
        else {
            warn "$name is already going on the journey!";
        }
    }

    method describe() {
        "From $!origin to $!destination"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>方法可以有签名, 就像子例程一样。 方法中能访问对象的属性,  并且总是能使用 <code>!</code> twigil, 即使属性是用 <code>.</code> twigil 声明的. 这是因为, . twigil 是在那个位置上使用 ! twigil 声明了属性, 然后额外又添加了一个取值器方法.</p>
</div>
<div class="paragraph">
<p>即 <code>has $.attribute</code> 等价于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    has $!attribute
    method attribute() { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    has $.attr is rw;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>等价于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    has $!attr;
    method attr() is rw {
        $!attr;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 describe 方法中使用 $!origin 和 $.origin ,这之间有一个微小但很重要的差别.  $!origin 只是属性的简单查看. 它是廉价的, 并且你知道它是类中声明的属性. $.origin 真正的是一个方法调用, 因此能在子类中被覆写. 如果你真的显式地要覆写它才使用 $.origin 吧.</p>
</div>
</div>
<div class="sect2">
<h3 id="_self_2">53.6. self</h3>
<div class="paragraph">
<p>在方法内部, self 是可用的, 它被绑定到调用者, 例如方法调用的对象. self 能用于在调用者上调用深层的方法, 例如:</p>
</div>
<div class="sect3">
<h4 id="_私有方法_3">53.6.1. 私有方法</h4>
<div class="paragraph">
<p>在方法的名字前面引入一个感叹号, 这个方法就变为类的私有方法, 这个方法只在内的内部使用, 不能在其它任何地方调用.</p>
</div>
<div class="paragraph">
<p>私有方法的调用要使用感叹号而非点号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method !do-something-private($x) {
    ...
}
method public($x) {
    if self.precondition {
        self!do-something--private(2 * $x)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>私有方法不能被子类继承.</p>
</div>
</div>
<div class="sect3">
<h4 id="_子方法">53.6.2. 子方法</h4>
<div class="paragraph">
<p>submethod  是不会被子类继承的公开方法。从词干名来看它们在语义上与子例程类似。</p>
</div>
<div class="paragraph">
<p>Submethods 对于对象构建和解构任务很有用。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_继承_2">53.7. 继承</h3>
<div class="paragraph">
<p>类可以有父类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Child is Parent1 is Parent2 { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在子类中调用一个方法, 但是子类没有提供那个方法, 就会调用父类中同名的方法, 如果父类中存在那个方法的话. 父类被询问的顺序就叫做方法解析顺序(MRO). Raku 使用 C3 方法解析顺序. 你可以通过调用一个类型的元类型方法得知这个类型的 MRO.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Parcel.^mro;    # Parcel() Cool() Any() Mu()</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果一个类没有指定它的父类, 就假定默认为 <code>Any</code>. 所有的类都直接或间接的派生于 Mu-类型层级的根.</p>
</div>
</div>
<div class="sect2">
<h3 id="_对象构造">53.8. 对象构造</h3>
<div class="paragraph">
<p>对象通常通过方法调用创建, 或者通过类型对象或者通过同类型的其它对象创建. 类 Mu 提供了一个叫做 new 的构造器方法, 这个方法接收命名参数然后使用它们来初始化公共属性.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Point {
    has $.x;
    has $.y = 2 * $!x;
}
my $p = Point.new( x =&gt; 1, y =&gt; 2);
#             ^^^ 继承自类 Mu</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Mu.new</code> 在调用者身上调用 <code>bless</code> 方法, 传递所有的具名参数. bless 创建新的对象, 然后调用该对象的 <code>BUILDALL</code> 方法.  <strong>BUILDALL</strong> 以`相反的`方法解析顺序(继承层级树自上而下)遍历所有子类(例如, 从 Mu 到 派生类), 并且在每个类中检查名为 <code>BUILD</code> 的方法是否存在。 如果存在就调用它, 再把传递给 new 方法的所有具名参数传递给这个 <code>BUILD</code> 方法。 如果没有, 这个类的公开属性就会用`同名的`具名参数进行初始化.  这两种情况下, 如果 <strong>BULID</strong> 方法和 <strong>默认构造函数</strong> 都没有对属性进行初始化, 就会应用默认值 (上面例子中的 <code>2 * $!x</code>)。</p>
</div>
<div class="paragraph">
<p>这种构造模式对于自定义构造器有几处暗示. 首先, 自定义 BUILD 方法应该总是子方法(submethod), 否则它们会中断子类中的属性初始化. 第二, BUILD 子方法能用于在对象构造时执行自定义代码. 它们也能用于为属性初始化<strong>创建别名</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class EncodedBuffer {
    has $.enc;
    has $.data;

    submethod BUILD(:encoding(:$enc), :$data) {
        $!enc  := $enc;
        $!data := $data;
    }
}
my $b1 = EncodedBuffer.new( encoding =&gt; 'UTF-8', data =&gt; [64, 65] );
my $b2 = EncodedBuffer.new( enc      =&gt; 'UTF-8', data =&gt; [64, 65] );
#  现在 enc 和 encoding 都被允许</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为传递实参给子例程把实参绑定给了形参, 如果把属性用作形参,单独绑定那一步就不需要了. 所以上面的例子可以写为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">submethod BUILD(:encoding(:$!enc), :$!data) {
    # nothing to do here anymore, the signature binding
    # does all the work for us.
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>第三个暗示是如果你想要一个接收位置参数的构造函数, 你必须自己写 new 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Point {
    has $.x;
    has $.y;
    method new($x, $y) {
        self.bless(*, :$x, :$y);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而, 这不是最佳实践, 因为这让来自子类的对象的初始化正确更难了.</p>
</div>
</div>
<div class="sect2">
<h3 id="_roles">53.9. Roles</h3>
<div class="paragraph">
<p>Roles 在某种程度上和类相似, 它们都是属性和方法的集合. 不同之处在于,  roles 是用来描述对象行为的某<strong>一部分</strong>的, 和 roles 怎样应用于类中. 或怎样解析。 类用于管理对象实例, 而 roles 用于<strong>管理行为</strong>和<strong>代码复用</strong>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Serializable {
    method serialize() {
        self.perl; # 很粗超的序列化
    }
    method deserialization-code($buf) {
        EVAL $buf; #  反转 .perl 操作
    }
}

class Point does Serializable {
    has $.x;
    has $.y;
}
my $p = Point.new(:x(1), :y(2));
my $serialized = $p.serialize;      # 由 role 提供的方法
my $clone-of-p = Point.deserialization-code($serialized);
say $clone-of-p.x;      # 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>编译器一解析到 role 声明的闭合花括号, roles 就不可变了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_role_application">53.10. Role Application</h3>
<div class="paragraph">
<p>Role 应用和类继承有重大不同。 当 role 应用到类中时, 那个 role 的方法被复制到类中。如果多个 roles 被应用到同一个类中, 冲突( 例如同名的非 multi 方法(s) )会导致编译时错误, 这可以通过在类中提供一个同名的方法来解决冲突。
这比多重继承更安全, 在冲突从来不会被编译器检测到的地方, 但是代替的是借助于在 MRO 中出现更早的父类, 这可能是也可能不是程序员想要的。</p>
</div>
<div class="paragraph">
<p>当一个 role 被应用到第二个 role上, 实际的程序被延迟直到第二个 role 被应用到类, 这时两个 roles 才都被应用到那个类中。 因此：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role R1 {
    # methods here
}
role R2 does R1 {
    # methods here
}
class C does R2 { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>等价于：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-perl" data-lang="perl">role R1 {
    # methods here
}
role R2 {
    # methods here
}
class C does R2 does R1 { }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stubs">53.11. Stubs</h3>
<div class="paragraph">
<p>当 role 中包含了一个 stubbed 方法, 在这个 role 被应用到类中时, 必须提供一个同名的非 stubbed 版本的方法。这允许你创建如抽象接口那样的 roles。这有点像 Swift 中的 Protocol 协议。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role AbstractSerializable {
    method serialize() { ... }  # 字面的三个点 ... 把方法标记为 stub
}

#  下面是一个编译时错误, 例如
#        Method 'serialize' must be implemented by APoint because
#        it is required by a role
class APoint does AbstractSerializable {
    has $.x;
    has $.y;
}

# 这个有效:
class SPoint does AbstractSerializable {
    has $.x;
    has $.y;
    method serialize() { "p($.x, $.y)" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>那个 stubbed 方法的实现也可能由另外一个 role 提供。</p>
</div>
<div class="paragraph">
<p>TODO: 参数化的 roles</p>
</div>
</div>
<div class="sect2">
<h3 id="_元对象编程和自省">53.12. 元对象编程和自省</h3>
<div class="paragraph">
<p>Raku 有一个元对象系统, 这意味着对象,类,roles,grammars,enums 它们自身的行为都被其它对象控制; 那些对象叫做元对象(想想元操作符, 它操作的对象是普通操作符). 元对象, 像普通对象一样,  是类的实例, 这时我们称它们为元类.</p>
</div>
<div class="paragraph">
<p>对每个对象或类, 你能通过调用 `.HOW`方法获取元对象. 注意, 尽管这看起来像是一个方法调用, 然而它实际上是编译器中的特殊案列, 所以它更像一个 macro.</p>
</div>
<div class="paragraph">
<p>所以, 你能用元对象干些什么呢? 你可以通过比较元类的相等性来检查两个对象是否具有同样的元类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1.HOW ===   2.HOW;      # True
say 1.HOW === Int.HOW;      # True
say 1.HOW === Num.HOW;      # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 使用单词 <code>HOW</code>, Higher Order Workings, 来引用元对象系统. 因此, 在 Rakudo 中不必对此吃惊, 控制类行为的元类的类名叫做 <code>Raku::Metamodel::ClassHow</code>. 每个类都有一个 `Raku::Metamodel::ClassHOW`的实例.</p>
</div>
<div class="paragraph">
<p>但是,理所当然的, 元模型为你做了很多. 例如它允许你内省对象和类.  元对象方法调用的约定是, 在元对象上调用方法, 并且传递感兴趣的对象作为对象的第一参数. 所以, 要获取对象的类名, 你可以这样写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $object = 1;
my $metaobject = 1.HOW;
say $metaobject.name($object);      # Int
# or shorter:
say 1.HOW.name(1);                  # Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了避免使用同一个对象两次, 有一个便捷写法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1.^name;                        # Int
# same as
say 1.HOW.name(1);                  # Int</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_内省_2">53.13. 内省</h3>
<div class="paragraph">
<p>内省就是在运行时获取对象或类的信息的过程. 在 Raku 中,  所有的内省都会搜查原对象. 标准的基于类对象的 ClassHow 提供了这些工具:</p>
</div>
<div class="sect3">
<h4 id="_can">53.13.1. can</h4>
<div class="paragraph">
<p>给定一个方法名, 它返回一个Parcel, 这个 Parcel 里面是可用的方法名</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A      { method x($a) {} };
class B is A { method x()   {} };
say B.^can('x').elems;              # 2
for B.^can('x') {
    say .arity;                     # 1, 2
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中, 类 B 中有两个名为 x 的方法可能可用(尽管一个正常的方法调用仅仅会直接调用安置在 B 中那个方法). B 中的那个方法有一个参数(例如, 它期望一个参数, 一个调用者(self)), 而 A 中的 x 方法期望 2 个参数( self 和 $a).</p>
</div>
</div>
<div class="sect3">
<h4 id="_methods">53.13.2. methods</h4>
<div class="paragraph">
<p>返回类中可用公共方法的列表( 这包括父类和 roles 中的方法). 默认它会停在类 Cool, Any 或 Mu 那儿; 若真要获取所有的方法, 使用副词 <code>:all</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    method x() { };
}
say A.^methods();                   # x
say A.^methods(:all);               # x infinite defined ...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mro_2">53.13.3. mro</h4>
<div class="paragraph">
<p>按方法解析顺序返回类自身的列表和它们的父类.  当方法被调用时, 类和它的父类按那个顺序被访问.(仅仅是概念上; 实际上方法列表在类构建是就创建了).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1.^mro;                         # (Int) (Cool) (Any) (Mu)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_name">53.13.4. name</h4>
<div class="paragraph">
<p>返回类的名字:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'a string'.^name;               # Str</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_parents">53.13.5. parents</h4>
<div class="paragraph">
<p>返回一个父类的列表. 默认它会停在 Cool, Any 或者 Mu 那儿, 但你可以提供一个副词 <code>:all`来压制它. 使用副词 `:tree</code> 会返回一个嵌套列表.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class D             { };
class C1 is D       { };
class C2 is D       { };
class B is C1 is C2 { };
class A is B        { };
say A.^parents(:all).perl;          # (B, C1, C2, D, Any, Mu)
say A.^parents(:all, :tree).perl;
    # ([B, [C1, [D, [Any, [Mu]]]], [C2, [D, [Any, [Mu]]]]],)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_操作符_2">54. 操作符</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_操作符优先级">54.1. 操作符优先级</h3>
<div class="paragraph">
<p>在像 <code>1 + 2 * 3</code> 这样的表达式中， <code>2 * 3</code> 被首先计算， 因为中缀操作符  <code>*</code> 的优先级比 <code>+</code> 的优先级高。下面的表中总结了 Perl  6 中  的优先级级别， 从最牢固到最松散：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">A	Level	           Examples
N	Terms	           42 3.14 "eek" qq["foo"] $x :!verbose @$array
L	方法后缀	        .meth .+ .? .* .() .[] .{} .&lt;&gt; .«» .:: .= .^ .:
N	自增	              ++ --
R	求幂	              **
L	Symbolic unary	   ! + - ~ ? | || +^ ~^ ?^ ^
L	乘法	              * / % %% +&amp; +&lt; +&gt; ~&amp; ~&lt; ~&gt; ?&amp; div mod gcd lcm
L	加法	              + - +| +^ ~| ~^ ?| ?^
L	重复	              x xx
X	连结                ~
X	Junctive and	   &amp;
X	Junctive or	       | ^
L	Named unary	       temp let
N	Structural infix   but does &lt;=&gt; leg cmp .. ..^ ^.. ^..^
C	Chaining infix	   != == &lt; &lt;= &gt; &gt;= eq ne lt le gt ge ~~ === eqv !eqv
X	Tight and	       &amp;&amp;
X	Tight or	       || ^^ // min max
R	Conditional	       ?? !! ff fff
R	Item assignment	   = =&gt; += -= **= xx= .=
L	Loose unary	       so not
X	Comma operator	   , :
X	List infix	       Z minmax X X~ X* Xeqv ...
R	List prefix	       print push say die map substr ... [+] [*] any Z=
X	Loose and	       and andthen
X	Loose or	       or xor orelse
X	Sequencer	       &lt;==, ==&gt;, &lt;&lt;==, ==&gt;&gt;
N	Terminator	       ; {...}, unless, extra ), ], }</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面使用的两处 <code>!</code> 符号一般代表任何一对儿拥有相同优先级的操作符， 上表指定的二元操作符的结合性解释如下(其中 A 代表结合性， associativities )：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">A	Assoc	Meaning of $a ! $b ! $c
L	left	($a ! $b) ! $c
R	right	$a ! ($b ! $c)
N	non	    ILLEGAL
C	chain	($a ! $b) and ($b ! $c)
X	list	infix:&lt;!&gt;($a; $b; $)</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于一元操作符， 这解释为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">A	Assoc	Meaning of !$a!
L	left	(!$a)!
R	right	!($a!)
N	non	    ILLEGAL</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面描述的操作符， 默认假定为 left 结合性。</p>
</div>
</div>
<div class="sect2">
<h3 id="_操作符种类">54.2. 操作符种类</h3>
<div class="paragraph">
<p>操作符能出现在相对于 term 的几个位置处：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">+term	        prefix         (后缀)
term1 + term2	infix          (中缀)
term++	        postfix        (后缀)
(term)	        circumfix      (环缀)
term1[term2]	postcircumfix  (后环缀)</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个操作符也可以用作子例程。 这样的子例程的名字由操作符的种类， 然后后跟一个冒号，再加上一组引号结构， 引号结构中是组成操作符的符号(s):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">infix:&lt;+&gt;(1, 2)                           # same as 1 + 2
circumfix:«( )»('a', 'b', 'c')            # same as ('a', 'b', 'c'), 目前编译错误。
circumfix:&lt;[ ]&gt;('a', 'b', 'c').perl.say   # ["a", "b", "c"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为一种特殊情况， listop(列表操作符)既能作为 term 又能作为前缀。子例程调用是最常见的列表操作符。其它情况包括元运算中缀操作符 <code>[+]| 1, 2, 3</code> 和 <code>prefix</code> 等 stub 操作符。</p>
</div>
<div class="paragraph">
<p>定义自定义操作符在 <a href="http://doc.raku.org/language/functions#Defining_Operators"> /language/functions#Defining_Operators.</a>  中有涉及。</p>
</div>
</div>
<div class="sect2">
<h3 id="_term_优先级">54.3. Term 优先级</h3>
<div class="paragraph">
<p>Term 怎么翻译才合适？ 我觉得翻译成 <code>项</code> 更合适， 表明这是一个名词。</p>
</div>
<div class="sect3">
<h4 id="_环缀">54.3.1. 环缀 &lt; &gt;</h4>
<div class="paragraph">
<p>引起单词的结构。以空白隔开内容， 并返回一个单词的 <code>Parcel</code>。 如果单词看起来像数字字面量或 <code>Pair</code> 字面量， 那么它会被转为合适的数字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &lt;a b c&gt;[1]  # b</code></pre>
</div>
</div>
<div class="paragraph">
<p>(Rakudo 当前总是返回一块儿字符串)。</p>
</div>
</div>
<div class="sect3">
<h4 id="_环缀_2">54.3.2. 环缀 ( )</h4>
<div class="paragraph">
<p>分组操作符。</p>
</div>
<div class="paragraph">
<p>空的分组 <code>()</code> 创建一个空的 <code>Pracel</code>。 非空表达式周围的圆括号只是构建了表达式， 而没有额外的语义。</p>
</div>
<div class="paragraph">
<p>在参数列表中，在参数周围放上圆括号防止了参数被解释为具名参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub p(:$a!) { say 'named'      }
multi sub p($a)   { say 'positional' }
p a =&gt; 1;       # named
p (a =&gt; 1);     # positional</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_环缀_3">54.3.3. 环缀 { }</h4>
<div class="paragraph">
<p>Block 或 散列构造器。</p>
</div>
<div class="paragraph">
<p>如果`{}` 里面的内容看起来像一组 pairs 并且没有 <code>$_</code> 或其它占位符参数，就返回一个散列， 这个散列由逐项逐项的 pair 组成。</p>
</div>
<div class="paragraph">
<p>否则就返回一个 Block。</p>
</div>
<div class="paragraph">
<p>注意，这个结构没有重新解析内容； 而里面的内容总是被解析为一组句子（例如，像一个 block）， 并且如果后面的分析表明它需要被解析成一个散列， 那么 block 就会被执行并强转为散列。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_环缀_4">54.4. 环缀 [ ]</h3>
<div class="paragraph">
<p>数组构造器。在列表上下文中返回一个不会展平的 item 化的数组。</p>
</div>
</div>
<div class="sect2">
<h3 id="_方法后缀优先级">54.5. 方法后缀优先级</h3>
<div class="sect3">
<h4 id="_后环缀">54.5.1. 后环缀 [ ]</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub postcircumfix:&lt;[ ]&gt;(@container, **@index,
                        :$k, :$v, :$kv, :$p, :$exists, :$delete)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:$k</code> 会创建一个 pair， 它是散列中的一个条目。 键是 <code>k</code>， 键值为 <code>$kv</code>。 所以， <code>$k</code> 等价于 <code>k</code> &#8658; <code>$k</code></p>
</div>
<div class="paragraph">
<p>访问 <code>@container</code>  中的一个或多个元素，即数组索引操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @alphabet = 'a' .. 'z';
say @alphabet[0];                   #-&gt; a
say @alphabet[1];                   #-&gt; b
say @alphabet[*-1];                 #-&gt; z
say @alphabet[100]:exists;          #-&gt; False
say @alphabet[15, 4, 17, 11].join;  #-&gt; perl
say @alphabet[23 .. *].perl;        #-&gt; ("x", "y", "z")

@alphabet[1, 2] = "B", "C";
say @alphabet[0..3].perl            #-&gt; ("a", "B", "C", "d")</code></pre>
</div>
</div>
<div class="paragraph">
<p>查看 <a href="http://doc.raku.org/language/subscripts">Subscripts</a> 获取关于该操作符行为的更详细的解释， 还有怎么在自定义类型中实现对它的支持。</p>
</div>
</div>
<div class="sect3">
<h4 id="_后环缀_2">54.5.2. 后环缀 { }</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub postcircumfix:&lt;{ }&gt;(%container, **@key,
                        :$k, :$v, :$kv, :$p, :$exists, :$delete)</code></pre>
</div>
</div>
<div class="paragraph">
<p>访问 <code>%container</code> 的一个或多个元素， 即散列索引操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my  %color = kiwi =&gt; "green", banana =&gt; "yellow", cherry =&gt; "red";
say %color{"banana"};               #-&gt; yellow
say %color{"cherry", "kiwi"}.perl;  #-&gt; ("red", "green")
say %color{"strawberry"}:exists;    #-&gt; False

%color{"banana", "lime"} = "yellowish", "green";
%color{"cherry"}:delete;
say %color;  #-&gt; banana =&gt; yellowish, kiwi =&gt; green, lime =&gt; green</code></pre>
</div>
</div>
<div class="paragraph">
<p>查看 <code>后环缀 &lt; &gt;</code> 和 <code>后环缀 « »</code> 作为便捷形式， 查看 <code>Subscripts</code> 获取这个操作符行为的更详细解释， 还有怎么在自定义类型中实现对它的支持。</p>
</div>
</div>
<div class="sect3">
<h4 id="_后环缀_3">54.5.3. 后环缀 &lt; &gt;</h4>
<div class="paragraph">
<p><code>后环缀 { }</code> 的简写形式， 它会引起它的参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %color = kiwi =&gt; "green", banana =&gt; "yellow", cherry =&gt; "red";
say %color&lt;banana&gt;;             #-&gt; yellow
say %color&lt;cherry kiwi&gt;.perl;   #-&gt; ("red", "green")
say %color&lt;strawberry&gt;:exists;  #-&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p>这不是一个真正的操作符， 它仅仅是一个在编译时把 <code>&lt; &gt;</code> 变成 <code>{}</code> 后环缀操作符的语法糖。</p>
</div>
</div>
<div class="sect3">
<h4 id="_后环缀_4">54.5.4. 后环缀 « »</h4>
<div class="paragraph">
<p><code>后环缀 { }</code> 的简写形式。它会引起它的参数，并且 « » 中能进行变量插值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %color = kiwi =&gt; "green", banana =&gt; "yellow", cherry =&gt; "red";
my $fruit = "kiwi";
say %color«cherry $fruit».perl;   #-&gt; ("red", "green")</code></pre>
</div>
</div>
<div class="paragraph">
<p>这不是一个真正的操作符， 它仅仅是一个在编译时把 « » 变成 <code>{}</code> 后环缀操作符的语法糖。</p>
</div>
</div>
<div class="sect3">
<h4 id="_后环缀_5">54.5.5. 后环缀 ( )</h4>
<div class="paragraph">
<p>调用操作符。把调用者当作 <code>Callable</code> 并引用它，它使用圆括号之间的表达式作为参数。</p>
</div>
<div class="paragraph">
<p>注意，标识符后面直接跟着一对儿圆括号总是被解析为子例程调用。</p>
</div>
<div class="paragraph">
<p>如果你想要你的对象响应该调用操作符， 你需要实现 <code>CALL-ME</code> 方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_postfix">54.5.6. postfix .</h4>
<div class="paragraph">
<p>该操作符用于调用一个方法， <code>$invocant.method</code>。</p>
</div>
<div class="paragraph">
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_postfix_2">54.5.7. postfix .=</h4>
<div class="paragraph">
<p>可变的方法调用。 <code>$invocant.=method</code> ， 脱去语法糖后就是 <code>$invocant = $invocant.method</code> , 这与 <a href="http://doc.raku.org/routine/op%3D" class="bare">http://doc.raku.org/routine/op%3D</a> 类似。</p>
</div>
<div class="paragraph">
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_postfix_3">54.5.8. postfix .^</h4>
<div class="paragraph">
<p>元方法调用。 ` $invocant.^method` 在  <code>$invocant</code> 的元类身上调用方法。脱去语法糖后， 它就是 <code>$invocant.HOW.method($invocant, &#8230;&#8203;)</code> 。 查看 <a href="http://doc.raku.org/type/HOW">HOW</a> 获取更多信息。</p>
</div>
<div class="paragraph">
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_postfix_4">54.5.9. postfix .?</h4>
<div class="paragraph">
<p><code>有可能被调用`的方法调用。如果有名为 `method</code> 的方法，  <code>$invocant.?method</code> 就在 <code>$invocant</code> 上调用 <code>method</code> 方法。否则它就返回 <code>Nil</code>。</p>
</div>
<div class="paragraph">
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_postfix_5">54.5.10. postfix .+</h4>
<div class="paragraph">
<p><code>$invocant.+method ` 从 `$invocant</code> 身上调用所有叫做 	<code>method</code> 的方法， 并返回一个 Parcel 作为结果。 如果没有找到这个名字的方法， 就会死掉。</p>
</div>
<div class="paragraph">
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_postfix_6">54.5.11. postfix .*</h4>
<div class="paragraph">
<p><code>$invocant.*method</code> ` 从 <code>$invocant</code> 身上调用所有叫做 <code>method</code> 的方法， 并返回一个 Parcel 作为结果。 如果没有找到这个名字的方法，则返回一个空的 Parcel。</p>
</div>
<div class="paragraph">
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_postfix_postfix">54.5.12. postfix .postfix</h4>
<div class="paragraph">
<p>大多数情况下， 可以在后缀或后环缀前面放上一个点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@a[1, 2, 3];
@a.[1, 2, 3]; # Same</code></pre>
</div>
</div>
<div class="paragraph">
<p>这对于视觉清晰或简洁很有帮助。例如，如果对象的属性是一个函数，在属性名后面放置一对儿圆括号会变成方法调用的一部分。 所以要么使用两对儿圆括号， 要么在圆括号前面放上一个点来阻止方法调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Operation {
    has $.symbol;
    has &amp;.function;
}
my $addition = Operation.new(:symbol&lt;+&gt;, :function{ $^a + $^b });
say $addition.function()(1, 2); # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $addition.function.(1,2); # 3</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>然而，如果后缀是一个标识符， 那么它会被解释为一个普通的方法调用。</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1.i # No such method 'i' for invocant of type 'Int'</code></pre>
</div>
</div>
<div class="paragraph">
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_postfix_prefix">54.5.13. postfix .:&lt;prefix&gt;</h4>
<div class="paragraph">
<p>前缀能够像方法那样， 使用冒号对儿标记法来调用。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 1;
say ++$a;     # 2
say $a.:&lt;++&gt;; # 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_postfix_7">54.5.14. <code>postfix .::</code></h4>
<div class="paragraph">
<p>一个类限定的方法调用， 用于调用一个定义在父类或 role 中的方法， 甚至在子类中重新定义了之后。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Bar {
    method baz { 42 }
}

class Foo is Bar {
    method baz { "nope" }
}
say Foo.Bar::baz; # 42</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_自增优先级">54.6. 自增优先级</h3>
<div class="sect3">
<h4 id="_prefix">54.6.1. prefix ++</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub prefix:&lt;++&gt;($x is rw) is assoc&lt;none&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>把它的参数增加 1， 并返回增加后的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 3;
say ++$x;    # 4
say $x;      # 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>它的工作原理是在它的参数身上调用 <code>succ</code> 方法， 这可以让自定义类型自由地实现它们自己的增量语义。</p>
</div>
</div>
<div class="sect3">
<h4 id="_prefix_2">54.6.2. prefix&#8201;&#8212;&#8201;</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub prefix:&lt;--&gt;($x is rw) is assoc&lt;none&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>把它的参数减少 1， 并返回减少后的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 3;
say --$x;       # 2
say $x;         # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>它的工作原理是在它的参数身上调用 <code>pred</code> 方法， 这可以让自定义类型自由地实现它们自己的减量语义。</p>
</div>
</div>
<div class="sect3">
<h4 id="_postfix_8">54.6.3. postfix ++</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub postfix:&lt;++&gt;($x is rw) is assoc&lt;none&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>把它的参数增加 1， 并返回`unincremented`的那个值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 3;
say $x++;       # 3
say $x;         # 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>它的工作原理是在它的参数身上调用 <code>succ</code> 方法， 这可以让自定义类型自由地实现它们自己的增量语义。</p>
</div>
<div class="paragraph">
<p>注意这并不一定返回它的参数。 例如，对于未定义的值， 它返回 0:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;
say $x++;       # 0
say $x;         # 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_postfix_9">54.6.4. postfix&#8201;&#8212;&#8201;</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub postfix:&lt;--&gt;($x is rw) is assoc&lt;none&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>把它的参数减少 1， 并返回`undecremented`的那个值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 3;
say $x--;       # 3
say $x;         # 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>它的工作原理是在它的参数身上调用 <code>pred</code> 方法， 这可以让自定义类型自由地实现它们自己的减量语义。</p>
</div>
<div class="paragraph">
<p>注意这并不一定返回它的参数。 例如，对于未定义的值， 它返回 0:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;
say $x--;       # 0
say $x;         # -1</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_求幂优先级">54.7. 求幂优先级</h3>
<div class="sect3">
<h4 id="_infix">54.7.1. infix **</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;**&gt;(Any, Any) returns Numeric:D is assoc&lt;right&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>求幂操作符把它的两个参数都强制转为 <code>Numeric</code> , 然后计算，右侧为幂。</p>
</div>
<div class="paragraph">
<p>如果 <code>**</code> 右边是一个非负整数，并且左侧是任意精度类型(Int, FatRat)，那么计算不会损失精度。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_象形一元操作符的优先级">54.8. 象形一元操作符的优先级</h3>
<div class="sect3">
<h4 id="_prefix_3">54.8.1. prefix ?</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub prefix:&lt;?&gt;(Mu) returns Bool:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>布尔上下文操作符。</p>
</div>
<div class="paragraph">
<p>通过在参数身上调用 <code>Bool</code> 方法强制它的参数为 Bool。注意， 这会使 Junctions 失效。</p>
</div>
</div>
<div class="sect3">
<h4 id="_prefix_4">54.8.2. prefix !</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub prefix:&lt;!&gt;(Mu) returns Bool:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>否定的布尔上下文操作符。</p>
</div>
<div class="paragraph">
<p>通过在参数身上调用 <code>Bool</code> 方法强制它的参数为 Bool， 并返回结果的否定值。注意， 这会使 Junctions 失效。</p>
</div>
</div>
<div class="sect3">
<h4 id="_prefix_5">54.8.3. prefix<br></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub prefix:&lt;+&gt;(Any) returns Numeric:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>Numeric 上下文操作符。</p>
</div>
<div class="paragraph">
<p>通过在参数身上调用 Numeric 方法强制将参数转为 Numeric 类型。</p>
</div>
</div>
<div class="sect3">
<h4 id="_prefix_6">54.8.4. prefix -</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub prefix:&lt;-&gt;(Any) returns Numeric:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>否定的 Numeric 上下文操作符。</p>
</div>
<div class="paragraph">
<p>通过在参数身上调用 Numeric 方法强制将参数转为 Numeric 类型， 并返回结果的否定值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_prefix_7">54.8.5. prefix ~</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub prefix:&lt;-&gt;(Any) returns Str:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>字符串上下文操作符。</p>
</div>
<div class="paragraph">
<p>通过在参数身上调用 <code>Str</code> 方法强制把参数转为 <code>Str</code> 类型。</p>
</div>
</div>
<div class="sect3">
<h4 id="_prefix_8">54.8.6. prefix |</h4>
<div class="paragraph">
<p>将  Capture, Enum, Pair, List, Parcel, EnumMap 和 Hash 展平到参数列表中。</p>
</div>
<div class="paragraph">
<p>（在 Rakudo 中，这不是作为一个合适的操作符来实现的，而是编译器中的一种特殊情况， 这意味着它只对参数列表有效，而非在任意代码中都有效。）</p>
</div>
</div>
<div class="sect3">
<h4 id="_prefix_9">54.8.7. prefix +^</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub prefix:&lt;+^&gt;(Any) returns Int:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>Integer bitwise negation</p>
</div>
<div class="paragraph">
<p>整数按位取反。</p>
</div>
<div class="paragraph">
<p>将参数强转为 Int 类型并对结果按位取反， 假设两者互补。</p>
</div>
</div>
<div class="sect3">
<h4 id="_prefix_10">54.8.8. prefix ?^</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub prefix:&lt;?^&gt;(Mu) returns Bool:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>布尔按位取反。</p>
</div>
<div class="paragraph">
<p>将参数强转为 Bool， 然后按位反转，这使它和 prefix:&lt;!&gt;  一样。</p>
</div>
</div>
<div class="sect3">
<h4 id="_prefix_11">54.8.9. prefix ^</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub prefix:&lt;^&gt;(Any) returns Range:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>upto 操作符.</p>
</div>
<div class="paragraph">
<p>强制把它的参数转为 Numeric， 生成一个从 0 直到（但是排除） 参数为止的范围。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ^5;         # 0..^5
for ^5 { }      # 5 iterations</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_乘法优先级">54.9. 乘法优先级</h3>
<div class="sect3">
<h4 id="_infix_2">54.9.1. infix *</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;*&gt;(Any, Any) returns Numeric:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>把两边的参数都强转为 Numeric 并把它们相乘。 结果是一个更宽的类型。 查看 Numeric 获取更详细信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_3">54.9.2. infix /</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;/&gt;(Any, Any) returns Numeric:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>把两边的参数都强制为 Numeric， 并用左边除以右边的数。整数相除返回 Rat， 否则返回"更宽类型” 的结果。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_div">54.9.3. infix div</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;div&gt;(Int:D, Int:D) returns Int:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>整除。向下取整。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_4">54.9.4. infix %</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;%&gt;($x, $y) return Numeric:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>模操作符。首先强制为 Numeric。</p>
</div>
<div class="paragraph">
<p>通常，下面的等式是成立的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$x % $y == $x - floor($x / $y) * $y</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_infix_5">54.9.5. infix %%</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;%%&gt;($a, $b) returns Bool:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>整除操作符， 如果 ` $a % $b == 0` 则返回 True.</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_mod">54.9.6. infix mod</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;mod&gt;(Int:D $a, Int:D $b) returns Int:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>整数取模操作符。 返回整数取模操作的剩余部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_6">54.9.7. infix +&amp;</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;+&amp;&gt;($a, $b) returns Int:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>Numeric 按位 <code>AND</code>。 把两个参数都强转为 Int 并执行按位 AND 操作，假定两者是互补的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_7">54.9.8. infix +&lt;</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;&lt; +&lt; &gt;&gt;($a, $b) returns Int:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>向左移动整数个位。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_8">54.9.9. infix +&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;&lt; +&gt; &gt;&gt;($a, $b) returns Int:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>向右移动整数个位。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_gcd">54.9.10. infix gcd</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;gcd&gt;($a, $b) returns Int:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>强制两个参数都为 Int 并返回最大公分母（greatest common denominator）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_lcm">54.9.11. infix lcm</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;lcm&gt;($a, $b) returns Int:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>强制两个参数为 Int 并返回最小公倍数(least common multiple)</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_加法优先级">54.10. 加法优先级</h3>
<div class="sect3">
<h4 id="_infix_9">54.10.1. infix<br></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;+&gt;($a, $b) returns Numeric:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>强制两个参数为 Numeric 并把它们相加。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_10">54.10.2. infix -</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;-&gt;($a, $b) returns Numeric:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>强制两个参数为 Numeric 并用第一个参数减去第二个参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_11">54.10.3. infix +|</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;+|&gt;($a, $b) returns Int:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>强制两个参数为 Int 并执行按位 OR（包括 OR）</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_12">54.10.4. infix +^</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;+^&gt;($a, $b) returns Int:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>强制两个参数为 Int 并执行按位 XOR（不包括 OR）</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_13">54.10.5. infix ?|</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;?|&gt;($a, $b) returns Bool:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>强制两个参数为 Bool 并执行逻辑 OR（不包括 OR）</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_重复操作符优先级">54.11. 重复操作符优先级</h3>
<div class="sect3">
<h4 id="_infix_x">54.11.1. infix x</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:&lt;x&gt;(Any, Any) returns Str:D
multi sub infix:&lt;x&gt;(Any, Any)
multi sub infix:&lt;x&gt;(Str:D, Int:D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>把 <code>$a</code> 强转为 Str ， 把 <code>$b</code> 强转为 Int， 并重复字符串 <code>$b</code> 次。 如果 <code>$b &#8656; 0</code> 则返回空字符串。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'ab' x 3;       # ababab
say 42 x 3;         # 424242</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_infix_xx">54.11.2. infix xx</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;xx&gt;($a, $b) returns List:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回一组重复的 <code>$a</code> 并计算 <code>$b</code> 次（<code>$b</code> 被强转为 Int）。 如果 <code>$b &#8656; 0</code> ,则返回一个空列表。</p>
</div>
<div class="paragraph">
<p>每次重复都会计算左侧的值， 所以</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[1, 2] xx 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回 5 个不同的数组（但是每次都是相同的内容）并且</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rand xx 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回 3 个独立的伪随机数。右侧可以是 <code>*</code>, 这时会返回一个惰性的，无限的列表。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_连结">54.12. 连结</h3>
<div class="sect3">
<h4 id="_infix_14">54.12.1. infix ~</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:&lt;~&gt;(Any, Any) returns Str:D
multi sub infix:&lt;~&gt;(Any,   Any)
multi sub infix:&lt;~&gt;(Str:D, Str:D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>强制两个参数为 Str 并连结它们。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'ab' ~ 'c';     # abc</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_junctive_and_all_优先级">54.13. Junctive AND (all) 优先级</h3>
<div class="sect3">
<h4 id="_infix_15">54.13.1. infix &amp;</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;&amp;&gt;($a, $b) returns Junction:D is assoc&lt;list&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>用它的参数创建一个 <code>all</code> Junction。查看 Junctions 获取更多详情。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_junctive_or_any_precedence">54.14. Junctive OR (any) Precedence</h3>
<div class="sect3">
<h4 id="_infix_16">54.14.1. infix |</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;|&gt;($a, $b) returns Junction:D is assoc&lt;list&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>用它的参数创建一个 <code>any</code> Junction。查看 Junctions 获取更多详情。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_17">54.14.2. infix ^</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;^&gt;($a, $b) returns Junction:D is assoc&lt;list&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>用它的参数创建一个 <code>one</code> Junction。查看 Junctions 获取更多详情。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_named_unary_precedence">54.15. Named Unary Precedence</h3>
<div class="sect3">
<h4 id="_prefix_temp">54.15.1. prefix temp</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub prefix:&lt;temp&gt;(Mu $a is rw)</code></pre>
</div>
</div>
<div class="paragraph">
<p>temporizes 传入的变量作为参数， 这意味着退出作用域后它被重置为旧值。（这和 Perl 5 中的 local 操作符类似， 除了 temp 不重置值之外。）</p>
</div>
</div>
<div class="sect3">
<h4 id="_prefix_let">54.15.2. prefix let</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub prefix:&lt;let&gt;(Mu $a is rw)</code></pre>
</div>
</div>
<div class="paragraph">
<p>假定重置：如果通过异常或 fail()退出当前作用域, 旧值就会被恢复。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_nonchaining_binary_precedence">54.16. Nonchaining Binary Precedence</h3>
<div class="sect3">
<h4 id="_infix_does">54.16.1. infix does</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;does&gt;(Mu $obj, Mu $role) is assoc&lt;none&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在运行时把 <code>$role</code> 混合进 <code>$obj</code> 中。 要求 <code>$obj</code> 是可变的。</p>
</div>
<div class="paragraph">
<p>参数 <code>$role</code> 不一定要求是一个 role， 它可以表现的像是一个 role， 例如枚举值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_but">54.16.2. infix but</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;but&gt;(Mu $obj, Mu $role) is assoc&lt;none&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>把 <code>$role</code> 混合进 <code>$obj</code> 并创建一个 <code>$obj</code> 的副本。因为 <code>$obj</code> 是不能修改的，但是能使用 mixins 用于创建不可变值。</p>
</div>
<div class="paragraph">
<p>参数 <code>$role</code> 不一定要求是一个 role， 它可以表现的像是一个 role， 例如枚举值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_cmp">54.16.3. infix cmp</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:&lt;cmp&gt;(Any, Any) returns Order:D is assoc&lt;none&gt;
multi sub infix:&lt;cmp&gt;(Any,       Any)
multi sub infix:&lt;cmp&gt;(Real:D,    Real:D)
multi sub infix:&lt;cmp&gt;(Str:D,     Str:D)
multi sub infix:&lt;cmp&gt;(Enum:D,    Enum:D)
multi sub infix:&lt;cmp&gt;(Version:D, Version:D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>一般的， “智能的” 三路比较器。</p>
</div>
<div class="paragraph">
<p>比较字符串时使用字符串语义， 比较数字时使用数字语义， 比较 Pair 对象时， 先比较键， 再比较值，等等。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $a eqv $b, then $a cmp $b always returns Order::Same.
say (a =&gt; 3) cmp (a =&gt; 4);      # Less
say 4        cmp 4.0;           # Same
say 'b'      cmp 'a';           # More</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_infix_leg">54.16.4. infix leg</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:&lt;leg&gt;($a, $b) returns Order:D is assoc&lt;none&gt;
multi sub infix:&lt;leg&gt;(Any,   Any)
multi sub infix:&lt;leg&gt;(Str:D, Str:D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>字符串三路比较器。 leg 是  less, equal 还有 greater 的简写形式？</p>
</div>
<div class="paragraph">
<p>把两个参数都强转为 <code>Str</code> , 然后按照字母次序比较。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'a' leg 'b';        Less
say 'a' leg 'a';        Same
say 'b' leg 'a';        More</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_infix_18">54.16.5. infix &lt;&#8658;</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:«&lt;=&gt;»($a, $b) returns Order:D is assoc&lt;none&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Numeric 三路比较器。</p>
</div>
<div class="paragraph">
<p>把两个参数强转为 Real， 并执行数值比较。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_19">54.16.6. infix ..</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;..&gt;($a, $b) returns Range:D is assoc&lt;none&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>由参数创建一个  Range。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_20">54.16.7. infix ..^</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;..^&gt;($a, $b) returns Range:D is assoc&lt;none&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>由参数创建一个 Range， 不包含末端。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_21">54.16.8. infix ^..</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;^..&gt;($a, $b) returns Range:D is assoc&lt;none&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>由参数创建一个 Range， 不包含开始端点。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_22">54.16.9. infix <sup>..</sup></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;^..^&gt;($a, $b) returns Range:D is assoc&lt;none&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>由参数创建一个 Range， 不包含开端和末端。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_chaining_binary_precedence">54.17. Chaining Binary Precedence</h3>
<div class="sect3">
<h4 id="_infix_23">54.17.1. infix ==</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:&lt;==&gt;($, $) returns Bool:D is assoc:&lt;chain&gt;
multi sub infix:&lt;==&gt;(Any, Any)
multi sub infix:&lt;==&gt;(Int:D, Int:D)
multi sub infix:&lt;==&gt;(Num:D, Num:D)
multi sub infix:&lt;==&gt;(Rational:D, Rational:D)
multi sub infix:&lt;==&gt;(Real:D, Real:D)
multi sub infix:&lt;==&gt;(Complex:D, Complex:D)
multi sub infix:&lt;==&gt;(Numeric:D, Numeric:D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>强转两个参数为 Numeric（如果必要）， 并返回 True 如果它们相等。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_24">54.17.2. infix !=</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:&lt;!=&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>强转两个参数为 Numeric（如果必要）， 并返回 True 如果它们不相等。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_25">54.17.3. infix &lt;</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:«&lt;»(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:«&lt;»(Int:D, Int:D)
multi sub infix:«&lt;»(Num:D, Num:D)
multi sub infix:«&lt;»(Real:D, Real:D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>强转两个参数为 Real （如果必要）， 并返回 True 如果第一个参数小于第二个参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_26">54.17.4. infix &#8656;</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:«&lt;=»(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:«&lt;=»(Int:D, Int:D)
multi sub infix:«&lt;=»(Num:D, Num:D)
multi sub infix:«&lt;=»(Real:D, Real:D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>强转两个参数为 Real （如果必要）， 并返回 True 如果第一个参数小于第二个参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_27">54.17.5. infix &gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:«&gt;»(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:«&gt;»(Int:D, Int:D)
multi sub infix:«&gt;»(Num:D, Num:D)
multi sub infix:«&gt;»(Real:D, Real:D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>强转两个参数为 Real （如果必要）， 并返回 True 如果第一个参数大于第二个参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_28">54.17.6. infix &gt;=</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:«&gt;=»(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:«&gt;=»(Int:D, Int:D)
multi sub infix:«&gt;=»(Num:D, Num:D)
multi sub infix:«&gt;=»(Real:D, Real:D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>强转两个参数为 Real （如果必要）， 并返回 True 如果第一个参数大于或等于第二个参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_eq">54.17.7. infix eq</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:&lt;eq&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;eq&gt;(Any,   Any)
multi sub infix:&lt;eq&gt;(Str:D, Str:D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数等于第二个参数。</p>
</div>
<div class="paragraph">
<p>助记法: equal</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_ne">54.17.8. infix ne</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:&lt;ne&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;ne&gt;(Mu,    Mu)
multi sub infix:&lt;ne&gt;(Str:D, Str:D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>强转两个参数为 Str（如果必要）， 并返回 False 如果第一个参数等于第二个参数。</p>
</div>
<div class="paragraph">
<p>助记法: not equal</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_gt">54.17.9. infix gt</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:&lt;gt&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;gt&gt;(Mu,    Mu)
multi sub infix:&lt;gt&gt;(Str:D, Str:D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数大于第二个参数。</p>
</div>
<div class="paragraph">
<p>助记法: greater than</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_ge">54.17.10. infix ge</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:&lt;ge&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;ge&gt;(Mu,    Mu)
multi sub infix:&lt;ge&gt;(Str:D, Str:D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数大于第二个参数。</p>
</div>
<div class="paragraph">
<p>助记法: greater or equal</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_lt">54.17.11. infix lt</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:&lt;lt&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;lt&gt;(Mu,    Mu)
multi sub infix:&lt;lt&gt;(Str:D, Str:D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数小于第二个参数。</p>
</div>
<div class="paragraph">
<p>助记法: less than</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_le">54.17.12. infix le</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:&lt;le&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;le&gt;(Mu,    Mu)
multi sub infix:&lt;le&gt;(Str:D, Str:D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数小于或等于第二个参数。</p>
</div>
<div class="paragraph">
<p>助记法: less or equal</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_before">54.17.13. infix before</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:&lt;before&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;before&gt;(Any,       Any)
multi sub infix:&lt;before&gt;(Real:D,    Real:D)
multi sub infix:&lt;before&gt;(Str:D,     Str:D)
multi sub infix:&lt;before&gt;(Enum:D,    Enum:D)
multi sub infix:&lt;before&gt;(Version:D, Version:D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>一般的排序， 使用和 cmp 相同的语义。 如果第一个参数小于第二个参数则返回 True。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_after">54.17.14. infix after</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:&lt;after&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;after&gt;(Any,       Any)
multi sub infix:&lt;after&gt;(Real:D,    Real:D)
multi sub infix:&lt;after&gt;(Str:D,     Str:D)
multi sub infix:&lt;after&gt;(Enum:D,    Enum:D)
multi sub infix:&lt;after&gt;(Version:D, Version:D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>一般的排序， 使用和 cmp 相同的语义。 如果第一个参数大于第二个参数则返回 True。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_eqv">54.17.15. infix eqv</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:&lt;eqv&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;
proto sub infix:&lt;eqv&gt;(Any, Any)</code></pre>
</div>
</div>
<div class="paragraph">
<p>等值操作符。如果两个参数在结构上相同就返回 True。例如， 相同类型（并且递归）包含相同的值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [1, 2, 3] eqv [1, 2, 3];        # True
say Any eqv Any;                    # True
say 1 eqv 2;                        # False
say 1 eqv 1.0;                      # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于任意对象使用默认的 eqv 操作是不可能的。例如， eqv 不认为同一对象的两个实例在结构上是相等的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    has $.a;
}

say A.new(a =&gt; 5) eqv A.new(a =&gt; 5);  #=&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p>要得到这个类的对象相等（eqv）语义， 需要实现一个合适的中缀 eqv 操作符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    has $.a;
}

multi infix:&lt;eqv&gt;(A $l, A $r) { $l.a eqv $r.a }
say A.new(a =&gt; 5) eqv A.new(a =&gt; 5);  #=&gt; True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_infix_29">54.17.16. infix ===</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:&lt;===&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;
proto sub infix:&lt;===&gt;(Any, Any)</code></pre>
</div>
</div>
<div class="paragraph">
<p>值相等。如果两个参数都是同一个对象则返回 True。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A { };

my $a = A.new;
say $a === $a;              # True
say A.new === A.new;        # False
say A === A;                # True</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于值的类型，  <code>===</code> 表现的和 eqv 一样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'a' === 'a';            # True
say 'a' === 'b';            # False

# different types
say 1 === 1.0;              # False</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>===</code> 使用 <code>WHICH</code> 方法来获取对象相等， 所以所有的值类型必须重写方法 <code>WHICH</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_30">54.17.17. infix =:=</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub infix:&lt;=:=&gt;(Mu \a, Mu \b) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;=:=&gt;(Mu \a, Mu \b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>容器相等。返回 True 如果两个参数都绑定到同一个容器上。 如果它返回 True， 那通常意味着修改一个参数也会同时修改另外一个。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my ($a, $b) = (1, 3);
say $a =:= $b;      # False
$b = 2;
say $a;             # 1
$b := $a;
say $a =:= $b;      # True
$a = 5;
say $b;             # 5</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_infix_31">54.17.18. infix ~~</h4>
<div class="paragraph">
<p>智能匹配操作符。把左侧参数起别名为 <code>$<em></code> , 然后计算右侧的值， 并在它身上调用 <code>.ACCEPTS($</em>)</code> 。 匹配的语义由右侧操作数的类型决定。</p>
</div>
<div class="paragraph">
<p>这儿有一个内建智能匹配函数的摘要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">右侧      比较语义
Mu:U	  类型检查
Str	      字符串相等
Numeric	  数值相等
Regex	  正则匹配
Callable  调用的布尔结果
Any:D	  对象相等</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tight_and_precedence">54.18. Tight AND Precedence</h3>
<div class="sect3">
<h4 id="_infix_32">54.18.1. infix &amp;&amp;</h4>
<div class="paragraph">
<p>在布尔上下文中返回第一个求值为 False 的参数， 否则返回最后一个参数。</p>
</div>
<div class="paragraph">
<p>注意这是短路操作符，如果其中的一个参数计算为 false 值， 那么该参数右侧的值绝不会被计算。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub a { 1 }
sub b { 0 }
sub c { die "never called" };
say a() &amp;&amp; b() &amp;&amp; c();      # 0</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tight_or_precedence">54.19. Tight OR Precedence</h3>
<div class="sect3">
<h4 id="_infix_33">54.19.1. infix ||</h4>
<div class="paragraph">
<p>在布尔上下文中返回第一个求值为 True 的参数， 否则返回最后一个参数。</p>
</div>
<div class="paragraph">
<p>注意这是短路操作符，如果其中的一个参数计算为 true 值， 那么该参数右侧的值绝不会被计算。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub a { 0 }
sub b { 1 }
sub c { die "never called" };
say a() || b() || c();      # 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_infix_34">54.19.2. infix ^^</h4>
<div class="paragraph">
<p>返回第一个值为 true 的参数如果只有一个的话， 否则返回 Nil。只要找到两个值为 true 的参数就发生短路。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 0 ^^ 42;                # 42
say 0 ^^ 42 ^^ 1 ^^ die 8;  # (empty line)</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意， 这个操作符的语义可能不是你假想的那样： infix ^^ 翻到它找到的第一个 true 值， 找到第二个 true 值后永远地反转为 Nil 值， 不管还有多少 true 值。（换句话说，它的语义是”找到一个真值”， 而不是布尔起奇偶校验语义）</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_35">54.19.3. infix //</h4>
<div class="paragraph">
<p>Defined-or  操作符。返回第一个定义了的操作数， 否则返回最后一个操作数。短路操作符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Any // 0 // 42;         # 0</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_infix_min">54.19.4. infix min</h4>
<div class="paragraph">
<p>返回参数的最小值。语义由 cmp 语义决定。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$foo min= 0  # read as: $foo decreases to 0</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_infix_max">54.19.5. infix max</h4>
<div class="paragraph">
<p>返回参数的最大值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$foo max= 0  # read as: $foo increases to 0</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conditional_operator_precedence">54.20. Conditional Operator Precedence</h3>
<div class="sect3">
<h4 id="_infix_36">54.20.1. infix ?? !!</h4>
<div class="paragraph">
<p>三目操作符， 条件操作符。</p>
</div>
<div class="paragraph">
<p><code>$condition ?? $true !! $false</code> 计算并返回 <code>$true</code> 表达式，如果 <code>$condition</code> 为真的话。 否则计算并返回 <code>$false</code> 分支。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_ff">54.20.2. infix ff</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;ff&gt;(Mu $a, Mu $b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Flipflop operator. 触发器操作符。</p>
</div>
<div class="paragraph">
<p>把两个参数都跟 <code>$<em></code> 进行比较（即，<code>$</em> ~~ $a</code> 和 <code>$_ ~~ $b</code>）。求值为 False 直到左侧的智能匹配为真， 这时，它求值为真， 直到右侧的智能匹配为真。</p>
</div>
<div class="paragraph">
<p>实际上，左边的参数是"开始”条件， 右侧的参数是”停止” 条件。 这种结构一般用于收集只在特定区域的行。 例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $excerpt = q:to/END/;
Here's some unimportant text.
=begin code
    This code block is what we're after.
    We'll use 'ff' to get it.
=end code
More unimportant text.
END

my @codelines = gather for $excerpt.lines {
    take $_ if "=begin code" ff "=end code"
}

# this will print four lines,
# starting with "=begin code" and ending with "=end code"
say @codelines.join("\n");</code></pre>
</div>
</div>
<div class="paragraph">
<p>匹配开始条件之后，操作符会继续将停止条件与 <code>$_</code> 进行匹配， 如果成功就做相应地表现。在这个例子中， 只有第一个元素被打印了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;AB C D B E F&gt; {
    say $_ if /A/ ff /B/;  # prints only "AB"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想测试开始条件， 并且没有结束条件， <code>*</code> 能用作 “停止” 条件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;A B C D E&gt; {
    say $_ if /C/ ff *; # prints C, D, and E
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 sed-like 版本， 在开始条件匹配成功之后，它不会使用停止条件与 <code>$_</code> 进行匹配。</p>
</div>
<div class="paragraph">
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_ff_2">54.20.3. infix ^ff</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;^ff&gt;(Mu $a, Mu $b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>像 ff 那样工作，除了它不会在条目匹配开始条件时返回真。（包括匹配停止条件的条目）</p>
</div>
<div class="paragraph">
<p>一个比较:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @list = &lt;A B C&gt;;
say $_ if /A/ ff /C/ for @list;  # prints A, B, and C
say $_ if /A/ ^ff /C/ for @list; # prints B and C</code></pre>
</div>
</div>
<div class="paragraph">
<p>sed-like 版本 可以在 ^fff 中找到.</p>
</div>
<div class="paragraph">
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_ff_3">54.20.4. infix ff^</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;ff^&gt;(Mu $a, Mu $b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>像 ff 那样工作，除了它不会在条目匹配停止条件时返回真。（包括第一次匹配开始条件的条目）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @list = &lt;A B C&gt;;
say $_ if /A/ ff /C/ for @list;  # prints A, B, and C
say $_ if /A/ ff^ /C/ for @list; # prints A and B</code></pre>
</div>
</div>
<div class="paragraph">
<p>sed-like 版本 可以在 fff^ 中找到.</p>
</div>
<div class="paragraph">
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_ff_4">54.20.5. infix <sup>ff</sup></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;^ff^&gt;(Mu $a, Mu $b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>像 ff 那样工作，除了它不会在条目匹配停止条件时返回真, 也不会在条目匹配开始时返回真。（或者两者）</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @list = &lt;A B C&gt;;
say $_ if /A/ ff /C/ for @list;  # prints A, B, and C
say $_ if /A/ ^ff^ /C/ for @list; # prints B</code></pre>
</div>
</div>
<div class="paragraph">
<p>sed-like 版本 可以在 <sup>fff</sup> 中找到.</p>
</div>
<div class="paragraph">
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_fff">54.20.6. infix fff</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;fff&gt;(Mu $a, Mu $b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行 sed-like 那样的 flipflop 操作，在其中，它返回 False 直到左侧的参数与 <code>$<em></code> 智能匹配， 并且在那之后返回 True 直到右侧的参数和 <code>$</em></code>  智能匹配。</p>
</div>
<div class="paragraph">
<p>像 ff 那样工作， 除了它每次调用只尝试一个参数之外。即， 如果 <code>$<em></code> 和左侧的参数智能匹配， fff 随后不会尝试将同一个 <code>$</em></code> 和右侧的参数进行匹配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;AB C D B E F&gt; {
    say $_ if /A/ fff /B/;  # Prints "AB", "C", "D", and "B"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 non-sed-like 版本， 查看 <code>ff</code>.</p>
</div>
<div class="paragraph">
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_fff_2">54.20.7. infix ^fff</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;^fff&gt;(Mu $a, Mu $b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>像 fff那样， 除了它对于左侧的匹配不返回真之外。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @list = &lt;A B C&gt;;
say $_ if /A/ fff /C/ for @list;  # prints A, B, and C
say $_ if /A/ ^fff /C/ for @list; # prints B and C</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 non-sed 版本， 查看 <code>^ff</code>.</p>
</div>
<div class="paragraph">
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_fff_3">54.20.8. infix fff^</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;fff^&gt;(Mu $a, Mu $b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>像 fff 那样， 除了它对于右侧的匹配不返回真之外。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @list = &lt;A B C&gt;;
say $_ if /A/ fff /C/ for @list;  # prints A, B, and C
say $_ if /A/ fff^ /C/ for @list; # prints A and B</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 non-sed 版本， 查看 <code>ff^</code>.</p>
</div>
<div class="paragraph">
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_fff_4">54.20.9. infix <sup>fff</sup></h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;^fff^&gt;(Mu $a, Mu $b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>像 fff 那样， 除了它对于左侧和右侧的匹配都不返回真之外。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @list = &lt;A B C&gt;;
say $_ if /A/ fff /C/ for @list;  # prints A, B, and C
say $_ if /A/ ^fff^ /C/ for @list; # prints B</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 non-sed 版本， 查看 <code><sup>ff</sup></code>.</p>
</div>
<div class="paragraph">
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_item_assignment_precedence">54.21. Item Assignment Precedence</h3>
<div class="sect3">
<h4 id="_infix_37">54.21.1. infix =</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;=&gt;(Mu $a is rw, Mu $b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Item 赋值.</p>
</div>
<div class="paragraph">
<p>把 = 号右侧的值放入左侧的容器中。 它真正的语义是由左侧的容器类型决定的。</p>
</div>
<div class="paragraph">
<p>（注意 item 赋值和列表赋值的优先级级别不同， 并且等号左侧的语法决定了等号是被解析为 item 赋值还是列表赋值操作符）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_38">54.21.2. infix &#8658;</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:«=&gt;»($key, Mu $value) returns Pair:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pair 构造器.</p>
</div>
<div class="paragraph">
<p>使用左侧值作为键， 右侧值作为值，构造一个 Pair 对象。</p>
</div>
<div class="paragraph">
<p>注意 <code>&#8658;</code> 操作符是语法上的特例，在这个结构中， 它允许左侧是一个未被引起的标识符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $p = a =&gt; 1;
say $p.key;         # a
say $p.value;       # 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>在参数列表中，在 <code>&#8658;</code> 左侧使用未被引起的标识符构建的 Pair 会被解释为一个具名参数。</p>
</div>
<div class="paragraph">
<p>查看 Terms 语言文档了解更多创建 Pair 对象的方式。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_loose_unary_precedence">54.22. Loose Unary Precedence</h3>
<div class="sect3">
<h4 id="_prefix_not">54.22.1. prefix not</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub prefix:&lt;not&gt;(Mu $x) returns Bool:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>在布尔上下文中计算它的参数（因此使 Junctions 失效）， 并返回否定的结果。</p>
</div>
</div>
<div class="sect3">
<h4 id="_prefix_so">54.22.2. prefix so</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub prefix:&lt;so&gt;(Mu $x) returns Bool:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>在布尔上下文中计算它的参数（因此使 Junctions 失效）， 并返回结果。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_逗号操作符优先级">54.23. 逗号操作符优先级</h3>
<div class="sect3">
<h4 id="_infix_39">54.23.1. infix ,</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;,&gt;(*@a) is assoc&lt;list&gt; returns Parcel:D</code></pre>
</div>
</div>
<div class="paragraph">
<p>从它的参数宏构建一个 Parcel。也在语法构成上用作函数用的参数的分隔符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_40">54.23.2. infix :</h4>
<div class="paragraph">
<p>就像中缀操作符  <code>,</code> 那样， <code>:</code> 用作参数分隔符， 并把它左侧的参数标记为调用者。</p>
</div>
<div class="paragraph">
<p>那会把函数调用转为方法调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">substr('abc': 1);       # same as 'abc'.substr(1)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Infix :</code> 只允许出现在非方法调用的第一个参数后面。 在其它位置它会是语法错误。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_list_infix_precedence">54.24. List Infix Precedence</h3>
<div class="sect3">
<h4 id="_infix_z">54.24.1. infix Z</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;Z&gt;(**@lists) returns List:D is assoc&lt;chain&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Zip operator.</p>
</div>
<div class="paragraph">
<p>Z 像一个拉链那样把列表插入进来， 只要第一个输入列表耗尽就停止：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, 2 Z &lt;a b c&gt; Z &lt;+ -&gt;).perl;  # ((1, "a", "+"), (2, "b", "-")).list</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Z</code> 操作符也作为元操作符存在， 此时内部的 parcels 被应用了元操作符的列表替换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 100, 200 Z+ 42, 23;             # 142, 223
say 1..3 Z~ &lt;a b c&gt; Z~ 'x' xx 3;    # 1ax 2bx 3cx</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_infix_x_2">54.24.2. infix X</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub infix:&lt;X&gt;(**@lists) returns List:D is assoc&lt;chain&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>从所有列表创建一个外积。最右边的元素变化得最迅速。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1..3 X &lt;a b c&gt; X 9

# produces   (1, 'a', 9), (1, 'b', 9), (1, 'c', 9),
         (2, 'a', 9), (2, 'b', 9), (2, 'c', 9),
         (3, 'a', 9), (3, 'b', 9), (3, 'c', 9)</code></pre>
</div>
</div>
<div class="paragraph">
<p>X 操作符也可以作为元操作符， 此时内部的 parcels 被应用了元操作符的列表的值替换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1..3 X~ &lt;a b c&gt; X~ 9

# produces   '1a9', '1b9', '1c9',

         '2a9', '2b9', '2c9',
         '3a9', '3b9', '3c9'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_infix_41">54.24.3. infix &#8230;&#8203;</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;...&gt;(**@) is assoc&lt;list&gt;
multi sub infix:&lt;...^&gt;(**@) is assoc&lt;list&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>序列操作符是一个用于产生惰性列表的普通操作符。</p>
</div>
<div class="paragraph">
<p>它可以有一个初始元素和一个生成器在 <code>…</code> 的左侧， 在右侧是一个端点。</p>
</div>
<div class="paragraph">
<p>序列操作符会使用尽可能多的参数来调用生成器。参数会从初始元素和已生成元素中获取。</p>
</div>
<div class="paragraph">
<p>默认的生成器是 <code><strong>.succ</code> 或 <code></strong>.pred</code> ， 取决于末端怎么比较：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1 ... 4;        # 1 2 3 4
say 4 ... 1;        # 4 3 2 1
say 'a' ... 'e';    # a b c d e
say 'e' ... 'a';    # e d c b a</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><strong></code>  (Whatever) 末端生成一个无限序列，使用的是默认的生成器 <code></strong>.succ</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1 ... *)[^5];  # 1 2 3 4 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>自定义生成器是在 <code>…</code> 操作符之前的最后一个参数。下面这个自定义生成器接收两个参数， 生成了斐波纳契数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, 1, -&gt; $a, $b { $a + $b } ... *)[^8];    # 1 1 2 3 5 8 13 21
# same but shorter
say (1, 1, *+* ... *)[^8];                      # 1 1 2 3 5 8 13 21</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然自定义生成器也能只接收一个参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 5, { $_ * 2 } ... 40;                       # 5 10 20 40</code></pre>
</div>
</div>
<div class="paragraph">
<p>生成器的参数个数至少要和初始元素的个数一样多。</p>
</div>
<div class="paragraph">
<p>如果没有生成器，并且有不止一个初始元素，所有的初始元素都是数值，那么序列操作符会尝试推导出生成器。它知道数学和几何序列。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 2, 4, 6 ... 12;     # 2 4 6 8 10 12
say 1, 2, 4 ... 32;     # 1 2 4 8 16 32</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果末端不是 <code>*</code>， 它会和每个生成的元素进行智能匹配，当智能匹配成功的时候序列就被终止。对于 <code>&#8230;&#8203;</code>  操作符， 会包含最后一个元素， 对于 <code>&#8230;&#8203;^</code> 操作符，会排除最后的那个元素。</p>
</div>
<div class="paragraph">
<p>这允许你这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1, 1, *+* ...^ *&gt;= 100;</code></pre>
</div>
</div>
<div class="paragraph">
<p>来生成所有直到 100 但不包括 100 的斐波纳契数。</p>
</div>
<div class="paragraph">
<p><code>&#8230;&#8203;</code> 操作符还会把初始值看作”已生成的元素”，所以它们也会对末端进行检查：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $end = 4;
say 1, 2, 4, 8, 16 ... $end;
# outputs 1 2 4</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_list_prefix_precedence">54.25. List Prefix Precedence</h3>
<div class="sect3">
<h4 id="_infix_42">54.25.1. infix =</h4>
<div class="paragraph">
<p>列表赋值。  它真正的语义是由左侧的容器类型决定的。查看 Array 和 Hash 获取普通案例。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>item 赋值和列表赋值的优先级级别不同， 并且等号左侧的语法决定了等号是被解析为 item 赋值还是列表赋值操作符。</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_infix_43">54.25.2. infix :=</h4>
<div class="paragraph">
<p>绑定。 而 <code>$x = $y</code> 是把 <code>$y</code> 中的值放到 <code>$x</code> 里面， <code>$x := $y</code> 会让 <code>$x</code> 和 <code>$y</code> 引用同一个值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;
my $b = $a;
$b++;
say $a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会输出 42， 因为 $a 和 $b 都包含了数字 42， 但是容器是不同的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;
my $b := $a;
$b++;
say $a;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会打印 43， 因为 <code>$b</code> 和 <code>$a</code> 都代表着`同一个对象`。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_44">54.25.3. infix ::=</h4>
<div class="paragraph">
<p>只读绑定. 查看  infix :=.</p>
</div>
</div>
<div class="sect3">
<h4 id="_listop">54.25.4. listop &#8230;&#8203;</h4>
<div class="paragraph">
<p>这是yada, yada, yada 操作符 或 stub 操作符。如果它在子例程或类型中是唯一的语句，它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
</div>
<div class="paragraph">
<p>如果 <code>&#8230;&#8203;</code> 语句被执行了， 它会调用 <code>&amp;fail</code> , 伴随着默认的消息 stub 代码的执行。</p>
</div>
</div>
<div class="sect3">
<h4 id="_listop_2">54.25.5. listop !!!</h4>
<div class="paragraph">
<p>如果它在子例程或类型中是唯一的语句，它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
</div>
<div class="paragraph">
<p>如果 <code>!!!</code> 语句被执行了， 它会调用 <code>&amp;die</code> , 伴随着默认的消息 stub 代码的执行。</p>
</div>
</div>
<div class="sect3">
<h4 id="_listop_3">54.25.6. listop ???</h4>
<div class="paragraph">
<p>如果它在子例程或类型中是唯一的语句，它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
</div>
<div class="paragraph">
<p>如果 <code>???</code> 语句被执行了， 它会调用 <code>&amp;warn</code> , 伴随着默认的消息 stub 代码的执行。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_loose_and_precedence">54.26. Loose AND precedence</h3>
<div class="sect3">
<h4 id="_infix_and">54.26.1. infix and</h4>
<div class="paragraph">
<p>和中缀操作符 <code>&amp;&amp;</code> 一样，除了优先级更宽松。</p>
</div>
<div class="paragraph">
<p>在布尔上下文中返回第一个求值为 False 的操作数， 否则返回最后一个操作数。短路操作符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_andthen">54.26.2. infix andthen</h4>
<div class="paragraph">
<p>返回第一个未定义的参数，否则返回最后一个参数。短路操作符。左侧的结果被绑定到 <code>$_</code> 身上， 在右侧中使用， 或者作为参数被传递，如果右侧是一个 block 或 pointy block.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_loose_or_precedence">54.27. Loose OR Precedence</h3>
<div class="sect3">
<h4 id="_infix_or">54.27.1. infix or</h4>
<div class="paragraph">
<p>和中缀操作符 <code>||</code> 一样，除了优先级更宽松。</p>
</div>
<div class="paragraph">
<p>在布尔上下文中返回第一个求值为 True 的参数， 否则返回最后一个参数。短路操作符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_infix_orelse">54.27.2. infix orelse</h4>
<div class="paragraph">
<p>和中缀操作符 <code>//</code> 一样，除了优先级更宽松之外。</p>
</div>
<div class="paragraph">
<p>返回第一个定义过的参数， 否则返回最后一个参数。短路操作符。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_包">55. 包</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Packages - Organizing and referencing namespaced program elements</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>包是指定程序元素的嵌套命名空间。 模块，类，Grammar是包类型。 像目录中的文件一样，通常可以使用其短名称（如果它们是本地的）或使用较长的名称来消除歧义的引用具名元素。</p>
</div>
<div class="sect2">
<h3 id="_names">55.1. Names</h3>
<div class="paragraph">
<p>名称是作为变量名称的合法部分的任何东西（不包括sigil符号）。 这包括：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$foo                # 简单标识符
$Foo::Bar::baz      # 通过 :: 分割的组合标识符
$Foo::($bar)::baz   # 执行插值的组合标识符
$42                 # numeric names
$!                  # 某些标点符号变量</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>::</code> 用于分割嵌套的包名。</p>
</div>
<div class="sect3">
<h4 id="_包限定名">55.1.1. 包限定名</h4>
<div class="paragraph">
<p>普通的包限定名像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$Foo::Bar::baz  # 包 Foo::Bar 中的 $baz 变量</code></pre>
</div>
</div>
<div class="paragraph">
<p>有时保持sigil与变量名很清晰，所以来写这个的一个替代方式是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Foo::Bar::&lt;$baz&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这在编译时解决，因为变量名是一个常量。</p>
</div>
<div class="paragraph">
<p>如果 <code>::</code> 之前的名称部分为 null，则意味着包未指定并且必须搜索。 一般来说，这意味着跟在主sigil后面的初始 <code>::</code> 是对编译时已知的名字的无操作(no-op)，但 <code>::()</code> 也可以用来引入插值。 另外，在没有另一个sigil的情况下，<code>::</code> 可以作为它自己的sigil，表明有意使用一个尚未声明的包名。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_伪包">55.2. 伪包</h3>
<div class="paragraph">
<p>在名称前面保留以下伪包名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">MY          # 当前词法作用域中的符号 (aka $?SCOPE)
OUR         # 当前包中的符号 (aka $?PACKAGE)
CORE        # 最外层词法作用域, 定义标准 Perl
GLOBAL      # Interpreter-wide package symbols, really UNIT::GLOBAL
PROCESS     # 进程相关的全局变量 (superglobals)
COMPILING   # 正在编译的作用域中的词法符号</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下相对名称也保留，但可以在名称中的任何位置使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">CALLER      # Contextual symbols in the immediate caller's lexical scope
CALLERS     # Contextual symbols in any caller's lexical scope
DYNAMIC     # Contextual symbols in my or any caller's lexical scope
OUTER       # Symbols in the next outer lexical scope
OUTERS      # Symbols in any outer lexical scope
LEXICAL     # Contextual symbols in my or any outer's lexical scope
UNIT        # Symbols in the outermost lexical scope of compilation unit
SETTING     # Lexical symbols in the unit's DSL (usually CORE)
PARENT      # Symbols in this package's parent package (or lexical scope)
CLIENT      # The nearest CALLER that comes from a different package</code></pre>
</div>
</div>
<div class="paragraph">
<p>文件的作用域称为 <code>UNIT</code>，但在对应于语言设置的外面有一个或多个词法作用域（其他文化中通常称为序幕）。 因此，<code>SETTING</code> 作用域等价于 <code>UNIT::OUTERS</code>。 对于标准的Perl程序，<code>SETTING</code> 与 <code>CORE</code> 相同，但是各种启动选项（如 <code>-n</code> 或 <code>-p</code>）可以使您进入特定领域语言，在这种情况下，<code>CORE</code> 仍然是标准语言的作用域，而 <code>SETTING</code> 表示定义用作当前文件的设置的DSL的作用域。 当作为名称中间的搜索项使用时，SETTING包括其所有外部作用域，直到 <code>CORE</code>。 要仅获取设置的最外层作用域，请改用 <code>UNIT::OUTER</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_查找名字">55.3. 查找名字</h3>
<div class="sect3">
<h4 id="_插值到名字中">55.3.1. 插值到名字中</h4>
<div class="paragraph">
<p>您可以使用 <code>::($expr)</code> 将字符串插入到包或变量名中，<code>$expr</code> 表达式中通常放置包或变量名。 该字符串允许包含额外的 <code>::</code> 实例，这将被解释为包嵌套。 您只能内插整个名称，因为结构以 <code>::</code> 开头，并且立即结束或用括号之外的另一个 <code>::</code> 继续。 大多数符号引用使用这种记法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$foo = "Bar";
$foobar = "Foo::Bar";
$::($foo)           # lexically-scoped $Bar
$::("MY::$foo")     # lexically-scoped $Bar
$::("OUR::$foo")    # package-scoped $Bar
$::("GLOBAL::$foo") # global $Bar
$::("PROCESS::$foo")# process $Bar
$::("PARENT::$foo") # current package's parent's $Bar
$::($foobar)        # $Foo::Bar
$::($foobar)::baz   # $Foo::Bar::baz
$::($foo)::Bar::baz # $Bar::Bar::baz
$::($foobar)baz     # ILLEGAL at compile time (no operator baz)</code></pre>
</div>
</div>
<div class="paragraph">
<p>初始 <code>::</code> 不表明全局。 这里作为插值语法的一部分，它甚至不暗示包。 <code>::()</code> 组件插值之后，间接名称被查找，就像它在原始源代码中一样，优先级首先指定为前导伪包名称，然后指向词法作用域中的名称（搜索 向外扩展，以`CORE`结束）。 最后搜索当前包。</p>
</div>
<div class="paragraph">
<p>使用 <code>MY</code> 伪包将查找限制为当前词法作用域，<code>OUR</code> 将作用域限制为当前包作用域。</p>
</div>
</div>
<div class="sect3">
<h4 id="_直接查找">55.3.2. 直接查找</h4>
<div class="paragraph">
<p>要在包的符号表中直接查找而不进行扫描，请将包名视为哈希：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Foo::Bar::{'&amp;baz'}  # same as &amp;Foo::Bar::baz
PROCESS::&lt;$IN&gt;      # Same as $*IN
Foo::&lt;::Bar&gt;&lt;::Baz&gt; # same as Foo::Bar::Baz</code></pre>
</div>
</div>
<div class="paragraph">
<p>不像 <code>::()</code> 符号引用，这不解析`::`的参数，也不从该初始点启动命名空间扫描。 此外，对于常量下标，保证在编译时解析符号。</p>
</div>
<div class="paragraph">
<p>空伪包是与普通名称搜索有相同的搜索列表。 也就是说，以下各项在意义上是相同的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$foo
$::{'foo'}
::{'$foo'}
$::&lt;foo&gt;
::&lt;$foo&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>它们中的每一个都向外扫描词法作用域，然后扫描当前的包作用域（虽然当“strict”有效时包作用域被禁止，）。</p>
</div>
<div class="paragraph">
<p>作为这些规则的结果，您可以把变量名写的很随意：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$::{'!@#$#@'}
::{'$!@#$#@'}</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要名字中没有空格, 您也可以使用 <code>::&lt;&gt;</code> 形式。</p>
</div>
</div>
<div class="sect3">
<h4 id="_包查找">55.3.3. 包查找</h4>
<div class="paragraph">
<p>将包对象本身下标为哈希对象，其键是变量名，包括任何sigil。 包对象可以通过使用 <code>::</code> 后缀从类型名中派生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">MyType::&lt;$foo&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_全局">55.4. 全局</h3>
<div class="paragraph">
<p>解释器全局变量存在于 <code>GLOBAL</code> 包中。 用户程序在 <code>GLOBAL</code> 包中启动，因此默认情况下，主线代码中的“our”声明会进入该包。 进程范围的变量存在于 <code>PROCESS`包中。 大多数预定义的全局变量，例如 `$*UID</code> 和 <code>$*PID</code> 实际上是进程全局变量。</p>
</div>
</div>
<div class="sect2">
<h3 id="_版本">55.5. 版本</h3>
<div class="paragraph">
<p>任何包都可以有一个 <a href="https://docs.raku.org/type/Version">Version</a> 对象。 这个对象可以通过 <code>$PACKAGE.^ver</code> 或从包 <code>Fully::Qualified::Name.^ver</code> 外部访问。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/packages">Packages</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_性能">56. 性能</h2>
<div class="sectionbody">
<div class="paragraph">
<p>该页面是关于在 Raku 上下文中 <a href="https://en.wikipedia.org/wiki/Computer_performance">计算机性能</a> 的。</p>
</div>
<div class="sect2">
<h3 id="_首先剖析你的代码">56.1. 首先,剖析你的代码</h3>
<div class="paragraph">
<p><strong>确保你没有在错误的代码上浪费时间</strong>: 通过剖析你的代码的性能以从识别你的 <a href="https://en.wikiquote.org/wiki/Donald_Knuth">"临界 3%"</a> 开始。本文档的其余部分将向您展示如何执行此操作。</p>
</div>
<div class="sect3">
<h4 id="_time_with_now_init_now">56.1.1. Time with <code>now - INIT now</code></h4>
<div class="paragraph">
<p>对于 <code>now - INIT now</code> 形式的表达式, 其中 <code>INIT</code> 是一个 <a href="https://docs.raku.org/language/phasers">Raku 程序中运行的 phase</a>, 为计时代码片段提供了一个很好的习惯用法。</p>
</div>
<div class="paragraph">
<p>使用 <code>m: your code goes here</code> <a href="https://docs.raku.org/language/glossary#camelia">raku 频道 evalbot</a> 来写出这样的行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">m: say now - INIT now
rakudo-moar abc1234: OUTPUT«0.0018558␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>INIT</code> 左边的 <code>now</code> 比 <code>INIT</code> 右边的 <code>now</code> *晚*运行了 0.0018558 秒, 因为后者在<a href="https://docs.raku.org/language/phasers#INIT">INIT phase</a> 期间出现。</p>
</div>
</div>
<div class="sect3">
<h4 id="_本地剖析">56.1.2. 本地剖析</h4>
<div class="paragraph">
<p>当使用 <a href="https://moarvm.org/">MoarVM</a> 后端时, <a href="https://rakudo.org/">Rakudo</a> 编译器的 <code>--profile</code> 命令行选项将剖析数据写到一个 HTML 文件中。</p>
</div>
<div class="paragraph">
<p>此文件将打开“概述”部分，该部分提供有关程序如何运行的一些总体数据，例如总运行时间，执行垃圾回收所花费的时间。您将获得的一个重要信息是被解释的总调用帧（即，块）的百分比（最慢，红色），拼写（更快，橙色）和 jitted（最快，绿色）。</p>
</div>
<div class="paragraph">
<p>下一节“常规”可能是您花费最多时间的地方。它有一个可排序和可过滤的例程（或块）名称+文件+行的表，它运行的次数，包含时间（在该例程中花费的时间+从它调用的所有例程中花费的时间），独占时间（仅在该例程中花费的时间），以及它是否被解释，拼写或jitted（与“概述”页面相同的颜色代码）。按专属时间排序是了解从哪里开始优化的好方法。文件名从 <code>SETTING::src/core/</code> 或 <code>gen/moar/</code> 开始的例程来自编译器，从您自己的代码中看到的东西的一个好方法是将您描述的脚本的文件名放在“名称”中“ 搜索框。</p>
</div>
<div class="paragraph">
<p>“调用图”部分给出了与“例程”部分大致相同信息的火焰图表示。</p>
</div>
<div class="paragraph">
<p>“分配”部分为您提供有关分配的不同类型的数量以及分配的例程的信息。</p>
</div>
<div class="paragraph">
<p>“GC”部分为您提供有关所发生的所有垃圾收集的详细信息。</p>
</div>
<div class="paragraph">
<p>“OSR/Deopt”部分为您提供有关堆栈替换（OSR）的信息，这是在将例程从“已解释”升级为“拼写”或“jitted”时。当拼写或jitted代码必须被“降级”为被解释时，De是相反的。</p>
</div>
<div class="paragraph">
<p>如果配置文件数据太大，浏览器可能需要很长时间才能打开该文件。在这种情况下，使用 <code>--profile-filename</code> 选项输出到扩展名为 <code>.json</code> 的文件，然后使用 <a href="https://github.com/tadzik/p6profiler-qt">Qt</a> 查看器打开该文件。</p>
</div>
<div class="paragraph">
<p>要处理更大的配置文件，请输出到扩展名为 <code>.sql</code> 的文件。这将把配置文件数据写成一系列SQL语句，适合在 SQLite 中打开。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=== create a profile
raku --profile --profile-filename=demo.sql -e 'say (^20).combinations(3).elems'

=== create a SQLite database
sqlite3 demo.sqlite

=== load the profile data
sqlite&gt; .read demo.sql

=== the query below is equivalent to the default view of the "Routines" tab in the HTML profile
sqlite&gt; select
      case when r.name = "" then "&lt;anon&gt;" else r.name end as name,
      r.file,
      r.line,
      sum(entries) as entries,
      sum(case when rec_depth = 0 then inclusive_time else 0 end) as inclusive_time,
      sum(exclusive_time) as exclusive_time
    from
      calls c,
      routines r
    where
      c.id = r.id
    group by
      c.id
    order by
      inclusive_time desc
    limit 30;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要了解如何解释配置文件信息，请使用 evalbot（如上所述）并在 IRC 频道上提问。</p>
</div>
</div>
<div class="sect3">
<h4 id="_profile_编译">56.1.3. Profile 编译</h4>
<div class="paragraph">
<p>If you want to profile the time and memory it takes to compile your code, use Rakudo&#8217;s <code>--profile-compile</code> or <code>--profile-stage`options.
如果要分析编译代码所需的时间和内存，请使用 Rakudo 的 `--profile-compile</code> 或 <code>--profile-stage</code> 选项。</p>
</div>
</div>
<div class="sect3">
<h4 id="_创建或查看基准">56.1.4. 创建或查看基准</h4>
<div class="paragraph">
<p>使用 <a href="https://github.com/japhb/raku-bench">raku-bench</a>。</p>
</div>
<div class="paragraph">
<p>如果您为多个编译器（通常是 Perl 5，Raku 或 NQP 的版本）运行 raku-bench，则每个编译器的结果将在视觉上覆盖在相同的图形上，以便快速轻松地进行比较。</p>
</div>
</div>
<div class="sect3">
<h4 id="_share_problems">56.1.5. Share problems</h4>
<div class="paragraph">
<p>Once you&#8217;ve used the above techniques to identify the code to improve, you can then begin to address (and share) the problem with others:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于每个问题，将其提取到单行或 gist，并提供性能数字或使片段足够小，以便可以使用 <code>prof-m: your code or gist URL goes here</code> 进行分析。</p>
</li>
<li>
<p>考虑你需要/想要的最低速度增加（或减少或减少什么），并考虑与实现该目标相关的成本。在人们的时间和精力方面，改进的价值是什么？</p>
</li>
<li>
<p>让其他人知道您的 Raku 用例是在生产环境中还是仅仅是为了好玩。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_解决问题">56.2. 解决问题</h3>
<div class="paragraph">
<p>这需要重复：<strong>确保你没有浪费时间在错误的代码上</strong>。首先确定代码的“<a href="https://en.wikiquote.org/wiki/Donald_Knuth">关键3％</a>”。</p>
</div>
<div class="sect3">
<h4 id="_逐行">56.2.1. 逐行</h4>
<div class="paragraph">
<p>尝试逐行改进代码的快速，有趣和高效的方法是使用 raku <a href="https://docs.raku.org/language/glossary#IRC">evalbot</a> <a href="https://docs.raku.org/language/glossary#camelia">camelia</a> 与其他人协作。</p>
</div>
</div>
<div class="sect3">
<h4 id="_逐个例程">56.2.2. 逐个例程</h4>
<div class="paragraph">
<p>使用 multidispatch，您可以在现有的例程“旁边”添加新的例程变体：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=== existing code generically matches a two arg foo call:
multi sub foo(Any $a, Any $b) { ... }

=== new variant takes over for a foo("quux", 42) call:
multi sub foo("quux", Int $b) { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>拥有多个 <code>foo</code> 定义的调用开销通常是微不足道的（虽然请参见下面的讨论），因此如果您的新定义比以前存在的定义集更有效地处理其特定情况，那么您可能只是使您的代码更有效率对于那种情况。</p>
</div>
</div>
<div class="sect3">
<h4 id="_加速类型检测和调用解析">56.2.3. 加速类型检测和调用解析</h4>
<div class="paragraph">
<p>大多数 <a href="https://docs.raku.org/type/Signature#Type_constraints">where 子句</a>  - 以及大多数<a href="https://design.raku.org/S12.html#Types_and_Subtypes">子集</a>  - 强制动态（运行时）类型检查和调用解析它可能匹配的任何调用。这比编译时更慢，或者至少晚一些。</p>
</div>
<div class="paragraph">
<p>方法调用通常尽可能晚地解析（在运行时动态），而 sub 调用通常在编译时静态解析。</p>
</div>
</div>
<div class="sect3">
<h4 id="_选择更好的算法">56.2.4. 选择更好的算法</h4>
<div class="paragraph">
<p>无论语言或编译器如何，提高性能的最可靠技术之一是选择更合适的算法。</p>
</div>
<div class="paragraph">
<p>一个典型的例子是 <a href="https://en.wikipedia.org/wiki/Boyer–Moore_string_search_algorithm">Boyer-Moore</a>。要匹配大字符串中的小字符串，一个明显的方法是比较两个字符串的第一个字符然后，如果它们匹配，则比较第二个字符，或者，如果它们不匹配，则比较第一个字符大字符串中第二个字符的小字符串的字符，依此类推。相反，Boyer-Moore 算法首先将小字符串的 <strong>last</strong> 字符与大字符串中相应定位的字符进行比较。对于大多数字符串，Boyer-Moore 算法在算法上接近 N 倍，其中 N 是小字符串的长度。</p>
</div>
<div class="paragraph">
<p>接下来的几节讨论了算法改进的两大类，这些类别在 Raku 中特别容易实现。有关这个一般主题的更多信息，请阅读有关<a href="https://en.wikipedia.org/wiki/Algorithmic_efficiency">算法效率</a>的维基百科页面，尤其是接近结尾的“另请参阅”部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="_将顺序阻塞代码更改为并行非阻塞">56.2.5. 将顺序/阻塞代码更改为并行/非阻塞</h4>
<div class="paragraph">
<p>这是另一个非常重要的算法改进类。</p>
</div>
<div class="paragraph">
<p>查看幻灯片 <a href="https://jnthn.net/papers/2015-yapcasia-concurrency.pdf#page=17">Raku 中的并行、并发和异步</a> 和 <a href="https://www.youtube.com/watch?v=JpqnNCx7wVY&amp;list=PLRuESFRW2Fa77XObvk7-BYVFwobZHdXdK&amp;index=8">对应的视频</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用已有的高性能代码">56.2.6. 使用已有的高性能代码</h4>
<div class="paragraph">
<p>您可以在 Raku 中使用大量高性能 C 库，而 <a href="https://docs.raku.org/language/nativecall">NativeCall</a> 可以轻松地为它们创建包装器。还有对 C++ 库的实验性支持。</p>
</div>
<div class="paragraph">
<p>如果要<a href="https://stackoverflow.com/a/27206428/1077672">在 Raku 中使用 Perl 5 模块</a>，请混合使用 Raku 类型和<a href="https://docs.raku.org/language/mop">元对象协议</a>。</p>
</div>
<div class="paragraph">
<p>更一般地说，Raku 旨在与其他语言平滑地互操作，并且有许多模块<a href="https://modules.raku.org/#q=inline">旨在促进使用来自其他语言的库</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_让_rakudo_编译器生成更快的代码">56.2.7. 让 Rakudo 编译器生成更快的代码</h4>
<div class="paragraph">
<p>到目前为止，编译器的重点是正确性，而不是它生成代码的速度有多快，或者生成的代码运行速度有多快。但是预计会发生变化，最终&#8230;&#8203;&#8230;&#8203;你可以在 freenode IRC 频道#raku 和 #moarvm 上与编译器开发人员讨论预期的内容。更好的是，你可以自己贡献代码：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Rakudo 主要用 Raku 编写。因此，如果您可以编写 Raku，那么您可以破解编译器，包括优化任何影响代码速度的大量现有高级代码（以及其他所有代码）。</p>
</li>
<li>
<p>大多数编译器的其余部分都是用一种名为 <a href="https://github.com/raku/nqp">NQP</a> 的小语言编写的，它基本上是 Raku 的一个子集。如果你可以编写 Raku，你也可以很容易地学会使用和改进中级 NQP 代码，至少从一种纯粹的语言观点。要深入了解 NQP 和 Rakudo 的内涵，请从 <a href="https://edumentab.github.io/rakudo-and-nqp-internals-course/">NQP 和内部课程</a>开始。</p>
</li>
<li>
<p>如果低级别的 C 黑客是你的乐趣，请查看 <a href="https://moarvm.org/">MoarVM</a> 并访问 freenode IRC 频道 #moarvm（<a href="https://colabti.org/irclogger/irclogger_logs/moarvm">日志</a>）。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_仍然需要更多想法">56.2.8. 仍然需要更多想法?</h4>
<div class="paragraph">
<p>此页面中尚未涵盖的一些已知当前 Rakudo 性能缺陷包括使用 <code>gather/take</code>，<code>junctions</code>，正则表达式和字符串处理。</p>
</div>
<div class="paragraph">
<p>如果您认为某个主题需要在此页面上进行更多报道，请提交 PR 或告诉某人您的想法。谢谢。 :)</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_没有得到你需要想要的结果">56.3. 没有得到你需要/想要的结果?</h3>
<div class="paragraph">
<p>如果您已尝试此页面上的所有内容无效，请考虑使用 #raku 上的编译器开发人员进行讨论，以便我们可以从您的用例中了解到目前为止您已经发现的内容。</p>
</div>
<div class="paragraph">
<p>一旦开发人员知道您的困境，请留出足够的时间做出明智的回应（几天或几周，具体取决于问题的确切性质和潜在的解决方案）。</p>
</div>
<div class="paragraph">
<p>如果还没有成功，请考虑在继续之前提交有关您在我们的<a href="https://github.com/raku/user-experience/issues">用户体验</a>仓库中的体验的问题。</p>
</div>
<div class="paragraph">
<p>谢谢。 :)</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_raku_原生类型">57. Raku 原生类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 提供了一组原生类型，在内存中具有固定且已知的表示。此页面显示了存在哪些原生类型以及如何使用它们。有关它们的更多信息，请查看有关<a href="https://docs.raku.org/language/numerics#Native_numerics">原生数字</a> 的页面。</p>
</div>
<div class="sect2">
<h3 id="_types_with_native_representation">57.1. Types with native representation</h3>
<div class="paragraph">
<p>Raku 中的一些简单类型具有原生表示，表示它们将使用编译器，操作系统和原生提供的 C 语言表示。这些是可用的四种原生类型：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to Int (with limited range)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to Int (with limited range) with the unsigned trait</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">num</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to Num</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">str</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to Str</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>但是，这些类型不一定具有 <a href="https://docs.raku.org/language/nativecall">NativeCall</a> 接口所需的大小（例如，Raku 的 <code>int</code> 可以是 8 个字节，但 C 的 <code>int</code> 只有 4 个字节）; 必须使用以下类型而不是上面列出的 <code>int</code> 或 <code>num</code> 类型。</p>
</div>
<div class="paragraph">
<p>通常，这些变量的行为与常规标量变量的行为方式相同，称为<a href="https://docs.raku.org/language/numerics#Auto-boxing"><strong>自动装箱</strong></a>; 然而，存在一些差异，因为您实际宣称的是如何表示它们，而不是它们的实际类型。第一个是它们的类型实际上是它们的等效类型，而不是它们的原生类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my int $intillo = 3;
say $intillo.^name; # OUTPUT: «Int␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这显然意味着他们将智能匹配他们的等效（自动装箱）类型，而不是他们的原生类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my str $strillo = "tres";
say $strillo ~~ str; # OUTPUT: «False␤»
say $strillo ~~ Str; # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且与非原生对应物不同，他们将始终具有默认值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (my Str $); # OUTPUT: «(Str)␤»
say (my str $); # OUTPUT: «␤»
say (my num $); # OUTPUT: «0␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>注意</strong>: 在 v6.c 中，<code>num</code> 的默认值是 NaN。</p>
</div>
<div class="paragraph">
<p>这是因为 Natives 不知道他们的类型，因为他们只是值，没有任何元数据。在<a href="https://docs.raku.org/language/glossary#Multi-Dispatch">多重分派</a> 中，您可以拥有原生候选者，但无法区分相同原生类型的不同大小。也就是说，你可以有一个 <a href="https://docs.raku.org/type/Int">Int</a> 和 <a href="https://docs.raku.org/type/int">int</a> 候选者，但是 <a href="https://docs.raku.org/type/int">int</a>, <a href="https://docs.raku.org/type/atomicint">atomicint</a>, <a href="https://docs.raku.org/type/int64">int64</a> 等候选者之间会有歧义。</p>
</div>
<div class="paragraph">
<p>它们也不能被绑定。尝试做 <code>my num $numillo := 3.5</code> 会发出异常 <code>Cannot bind to natively typed variable '$variable-name'; use assignment instead</code>。</p>
</div>
<div class="paragraph">
<p>原生类型也可以是复合的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my int @intillos = ^10_000_000;
say [+] @intillos; # OUTPUT: «49999995000000␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，*native*ness 扩展到复合类型，它将是 <code>array</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my num @many-pi  = ^8 »*» π ; say @many-pi.^name;  # OUTPUT: «array[num]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>原生`数组`是 <a href="https://docs.raku.org/type/Iterable">Iterable</a>，但它们不是 List 的子类。但是，它们的行为类似于 <a href="https://docs.raku.org/type/Array">Array</a>; 例如，它们可以成形</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my str @letter-pairs[10] = 'a'..'j' Z~ 'A'..'J';
say @letter-pairs.perl;
# OUTPUT: «array[str].new(:shape(10,), ["aA", "bB", "cC", "dD", "eE", "fF", "gG", "hH", "iI", "jJ"])␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_types_with_native_representation_and_size">57.2. Types with native representation and size</h3>
<div class="paragraph">
<p>关于具有原生表示的类型的提及也适用于此;它们将自动装入 Raku 类型，并且不受限制。但是，下表中列出的这些类型具有可在<a href="https://docs.raku.org/language/nativecall#Passing_and_returning_values">NativeCall</a>函数中使用的特性：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(int8_t in C, also used for char)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(int16_t in C, also used for short)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(int32_t in C, also used for int)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(int64_t in C)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">byte, uint8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(uint8_t in C, also used for unsigned char)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(uint16_t in C, also used for unsigned short)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(uint32_t in C, also used for unsigned int)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uint64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(uint64_t in C)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">num32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(float in C)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">num64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(double in C)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>这些类型具有固定大小的表示，它独立于平台，因此可以安全地用于那些原生调用。如果我们愿意，没有什么能阻止我们在任何其他环境中使用它们。与上述类型相同，在为此类型的变量赋值时，必须考虑此大小：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my byte $intillo = 257;
say $intillo; # OUTPUT: «1␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <code>byte</code> 只能容纳 8 位，因此它将换行并分配模值为 256 的原始值的结果，这就是所示的内容。</p>
</div>
<div class="paragraph">
<p>声明原生大小的类型与没有声明原生大小的类型之间的主要区别是在声明中使用了 nativesize。例如，<code>int8</code> 以这种方式声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my native int8 is repr('P6int') is Int is nativesize( 8) { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>表示除了整数表示（<code>P6int</code>）之外，它还将使用仅 8 位的原生大小。但是，这个特性并不打算在您的程序中使用，因为它不是 Raku 规范的一部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="_void_类型">57.3. <code>void</code> 类型</h3>
<div class="paragraph">
<p>原生 <code>void</code> 类型对应于 C 的 <code>void</code> 类型。虽然是有效类型，但您可以在表达式中使用它</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;
my void $nothing;
say $nothing.perl; # OUTPUT: «NativeCall::Types::void␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>实际上，它是一个很难单独使用的 <code>Uninstantiable</code> 类型，实际上它在 link:(<a href="https://docs.raku.org/language/nativecall#Passing_and_returning_values"><code>return</code></a>) 类型中被明确禁止。但是，它通常在类型指针中找到，表示等效于 C 中的 <code>void *</code> 指针。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub malloc( int32 $size --&gt; Pointer[void] ) is native { * };
my Pointer[void] $for-malloc = malloc( 32 );
say $for-malloc.perl;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要在使用该类型的原生函数中使用它们，您还可以将 <a href="https://docs.raku.org/type/Blob">Blob</a> <a href="https://docs.raku.org/routine/nativecast">nativecast</a>  到此类指针上。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;
my Pointer[void] $native = nativecast(Pointer[void], Blob.new(0x22, 0x33));</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，除此之外，它提供的功能非常有限，因为指向 <code>void</code> 的指针无法解引用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;
my Pointer[void] $native = nativecast(Pointer[void], Buf.new(0x22, 0x33));
say $native.deref; # ERROR OUTPUT: «Internal error: unhandled target type␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_atomic_types">57.4. <strong>Atomic</strong> types</h3>
<div class="paragraph">
<p>在这种情况下，<strong>atomic</strong> 指的是线程下的安全操作。 Raku 提供了一个类型，<a href="https://docs.raku.org/type/atomicint"><code>atomicint</code></a> 和<a href="https://docs.raku.org/type/atomicint#Routines">一些操作</a>，它们共同保证了这一点。有关详细信息，请查看 link:(<a href="https://docs.raku.org/language/numerics#Atomic_operations">Numerics</a>) 页面上的原子操作部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="_rakudo_specific_native_types">57.5. Rakudo specific native types</h3>
<div class="paragraph">
<p>本节中描述的类型是特定于 Rakudo 的，因此不保证它们在其他实现中或在将来的版本中保持不变。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(long in C)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">longlong</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(longlong in C)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ulong</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(long and unsigned in C)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ulonglong</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(longlong and unsigned in C)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">size_t</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(size_t and unsigned in C)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ssize_t</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(size_t in C)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bool</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(bool in C)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>您可以像在本机 C 中使用它们一样使用它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use NativeCall;

my $just-an-array = CArray[int32].new( 1, 2, 3, 4, 5 );

loop ( my size_t $i = 0; $i &lt; $just-an-array.elems; $i++ ) {
    say $just-an-array[$i];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将打印数组的五个元素，因为它应该是你期望的。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_phasers_2">58. Phasers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>程序的生命周期（执行时间表）分为几个阶段。*phaser*是在特定执行阶段调用的代码块。</p>
</div>
<div class="sect2">
<h3 id="_phasers_3">58.1. Phasers</h3>
<div class="paragraph">
<p>phaser 块只是包含它的闭包的 trait，并在适当的时刻自动调用。这些自动调用的块称为 <strong>phasers</strong>，因为它们通常标记从计算的一个阶段到另一个阶段的转换。例如，在编译编译单元结束时调用 <code>CHECK</code> 块。也可以安装其他类型的 phasers; 它们会在适当的时候自动调用，其中一些 phasers 响应各种控制异常和退出值。例如，如果块的退出成功或失败，则可能会调用某些 phasers，在这种情况下*成功*退出, 则在这时返回定义的值或列表，而不带任何 <code>Failure</code> 或异常。</p>
</div>
<div class="paragraph">
<p>以下是摘要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">  BEGIN {...} #  * at compile time, as soon as possible, only ever runs once
  CHECK {...} #  * at compile time, as late as possible, only ever runs once
   INIT {...} #  * at runtime, as soon as possible, only ever runs once
    END {...} #  at runtime, as late as possible, only ever runs once
    DOC [BEGIN|CHECK|INIT] {...} # only in documentation mode

  ENTER {...} #  * at every block entry time, repeats on loop blocks.
  LEAVE {...} #  at every block exit time (even stack unwinds from exceptions)
   KEEP {...} #  at every successful block exit, part of LEAVE queue
   UNDO {...} #  at every unsuccessful block exit, part of LEAVE queue

  FIRST {...} #  at loop initialization time, before any ENTER
   NEXT {...} #  at loop continuation time, before any LEAVE
   LAST {...} #  at loop termination time, after any LEAVE

    PRE {...} #  assert precondition at every block entry, before ENTER
   POST {...} #  assert postcondition at every block exit, after LEAVE

  CATCH {...} #  catch exceptions, before LEAVE
CONTROL {...} #  catch control exceptions, before LEAVE

   LAST {...} #  supply tapped by whenever-block is done, runs very last
   QUIT {...} #  catch async exceptions within a whenever-block, runs very last

COMPOSE {...} #  when a role is composed into a class (Not yet implemented)
  CLOSE {...} #  appears in a supply block, called when the supply is closed</code></pre>
</div>
</div>
<div class="paragraph">
<p>标记为 <code>*</code> 号的 phaser 具有运行时值，并且如果早于周围表达式进行求值，则只需保存其结果，以便在以后计算表达式的其余部分时在表达式中使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $compiletime = BEGIN { now };
our $random = ENTER { rand };</code></pre>
</div>
</div>
<div class="paragraph">
<p>与其他语句前缀一样，这些产生值的构造可以放在块或语句的前面：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $compiletime = BEGIN now;
our $random = ENTER rand;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些 phaser 的大多数将接收块或函数引用。语句形式对于将词法作用域的声明暴露给周围的词法作用域而不在块中“捕获”它特别有用。</p>
</div>
<div class="paragraph">
<p>它们声明了与前面示例相同作用域的相同变量，但在指定时间把语句作为整体运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">BEGIN my $compiletime = now;
ENTER our $random = rand;</code></pre>
</div>
</div>
<div class="paragraph">
<p>（但请注意，在运行时克隆任何周围闭包时，在编译时计算的变量值可能不会持久存在。）</p>
</div>
<div class="paragraph">
<p>大多数非值生成 phasers 也可能如此使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">END say my $accumulator;</code></pre>
</div>
</div>
<div class="paragraph">
<p>但请注意：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">END say my $accumulator = 0;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>END</code> time 时将变量设置为 0 ，因为这是实际执行 “my” 声明的时间。只有无参数的 phasers 可以使用语句形式。这意味着 <code>CATCH</code> 和 <code>CONTROL</code> 始终需要一个块，因为它们接收一个设置 <code>$<em></code> 为当前主题的参数，以便内部行为能够表现为 switch 语句。（如果允许使用裸语句，那么 <code>$</em></code> 临时绑定会在 <code>CATCH`或者`CONTROL</code> 结束时泄漏出来，带来不可预测的，甚至可能是可怕的后果。异常处理程序应该减少不确定性，而不是增加它。）</p>
</div>
<div class="paragraph">
<p>其中一些 phasers 也具有可以在变量上设置的相应 trait; 他们使用 <code>will</code> 后面跟着小写的 phaser 名称。这些优点是将讨论中的变量作为主题传递给闭包：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">our $h will enter { .rememberit() } will undo { .forgetit() };</code></pre>
</div>
</div>
<div class="paragraph">
<p>只有在块内可以多次出现的 phaser 才有资格获得这种每个变量(per-variable)形式; 这不包括 <code>CATCH</code> 和其他例如 <code>CLOSE</code> 或 <code>QUIT</code> phaser 。</p>
</div>
<div class="paragraph">
<p>phaser 外部的块的主题作为 <code>OUTER::&lt;$_&gt;</code> 仍然可用。返回值是否可修改可能是所讨论的 phaser 的策略。特别地，不应在 <code>POST</code> phaser 内修改返回值，但 <code>LEAVE</code> phaser 可能更自由。</p>
</div>
<div class="paragraph">
<p>在方法的词法作用域中定义的任何 phaser 都是闭合 <code>self</code> 以及正常词汇。（或者等效地，实现可以简单地将所有这样的 phaser 转换为其引导的调用者是当前对象的子方法。）</p>
</div>
<div class="paragraph">
<p>当多个 phaser 被安排在同一时刻运行时，一般的打破平局的原则是初始化 phaser 按照声明的顺序执行，而最终 phaser 以相反的顺序执行，因为设置和拆除通常希望以相反的顺序相互发生。</p>
</div>
<div class="sect3">
<h4 id="_执行顺序">58.1.1. 执行顺序</h4>
<div class="paragraph">
<p>编译开始</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">      BEGIN {...} #  at compile time, As soon as possible, only ever runs once
      CHECK {...} #  at compile time, As late as possible, only ever runs once
    COMPOSE {...} #  when a role is composed into a class (Not yet implemented)</code></pre>
</div>
</div>
<div class="paragraph">
<p>执行开始</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">       INIT {...} #  at runtime, as soon as possible, only ever runs once</code></pre>
</div>
</div>
<div class="paragraph">
<p>在块执行开始之前</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">        PRE {...} #  assert precondition at every block entry, before ENTER</code></pre>
</div>
</div>
<div class="paragraph">
<p>循环执行开始</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">      FIRST {...} #  at loop initialization time, before any ENTER</code></pre>
</div>
</div>
<div class="paragraph">
<p>块执行开始</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">      ENTER {...} #  at every block entry time, repeats on loop blocks.</code></pre>
</div>
</div>
<div class="paragraph">
<p>可能会发生异常</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">      CATCH {...} #  catch exceptions, before LEAVE
    CONTROL {...} #  catch control exceptions, before LEAVE</code></pre>
</div>
</div>
<div class="paragraph">
<p>循环结束，继续或结束</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">       NEXT {...} #  at loop continuation time, before any LEAVE
       LAST {...} #  at loop termination time, after any LEAVE</code></pre>
</div>
</div>
<div class="paragraph">
<p>块结束</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">      LEAVE {...} #  at every block exit time (even stack unwinds from exceptions)
       KEEP {...} #  at every successful block exit, part of LEAVE queue
       UNDO {...} #  at every unsuccessful block exit, part of LEAVE queue</code></pre>
</div>
</div>
<div class="paragraph">
<p>块的后置条件</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">       POST {...} #  assert postcondition at every block exit, after LEAVE</code></pre>
</div>
</div>
<div class="paragraph">
<p>异步 whenever-block 结束</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">       LAST {...} #  if ended normally with done, runs once after block
       QUIT {...} #  catch async exceptions</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序终止</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">        END {...} #  at runtime, ALAP, only ever runs once</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_程序执行_phasers">58.2. 程序执行 phasers</h3>
<div class="sect3">
<h4 id="_begin">58.2.1. BEGIN</h4>
<div class="paragraph">
<p>编译时运行，一旦 phaser 中的代码编译完毕，就只运行一次。</p>
</div>
<div class="paragraph">
<p>返回值可在以后的 phaser 中使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "About to print 3 things";
for ^3 {
    say ^10 .pick ~ '-' ~ BEGIN { say  "Generating BEGIN value"; ^10 .pick }
}
# OUTPUT:
# Generating BEGIN value
# About to print 3 things
# 3-3
# 4-3
# 6-3</code></pre>
</div>
</div>
<div class="paragraph">
<p>phaser 中的 <code>^10 .pick</code> 只产生一次，并在运行时期间由循环重用。注意怎么 <code>BEGIN</code> 块中的 <a href="https://docs.raku.org/routine/say">say</a> 是在上述循环执行之前是怎么执行的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_check">58.2.2. CHECK</h4>
<div class="paragraph">
<p>在编译时运行，尽可能晚，只运行一次。</p>
</div>
<div class="paragraph">
<p>可以具有即使在后期 phases 提供的返回值。</p>
</div>
<div class="paragraph">
<p>在运行时生成的代码仍然可以启动 <code>CHECK</code> 和 <code>INIT</code> phasers，但当然这些 phaser 无法做出需要及时返回的事情。你需要一个虫洞。</p>
</div>
</div>
<div class="sect3">
<h4 id="_init">58.2.3. INIT</h4>
<div class="paragraph">
<p>在 main 执行期间编译后运行，尽快运行一次。它可以具有即使在后期 phases 也提供的返回值。</p>
</div>
<div class="paragraph">
<p>当 phaser 位于不同的模块中时， phaser <code>INIT</code> 和 <code>END</code> phaser 将被视为在使用模块中就像在 <code>use</code> 时声明一样。（如果模块被多次使用，则依赖于此顺序是错误的，因为仅在第一次注意到它们时才安装 phaser 。）</p>
</div>
<div class="paragraph">
<p>在运行时生成的代码仍然可以启动 <code>CHECK</code> 和 <code>INIT</code> phaser，但当然这些 phaser 无法做出需要及时返回的事情。你需要一个虫洞。</p>
</div>
<div class="paragraph">
<p>对 <code>INIT</code> 克隆闭包的所有副本只运行一次。</p>
</div>
</div>
<div class="sect3">
<h4 id="_end">58.2.4. END</h4>
<div class="paragraph">
<p>在 main 执行期间编译后运行，尽可能晚，只运行一次。</p>
</div>
<div class="paragraph">
<p>当 phaser 位于不同的模块中时， <code>INIT</code> 和 <code>END</code> phaser 将被视为在正使用的模块中就像在 <code>use</code> 时声明一样。（如果模块被多次使用，则依赖于此顺序是错误的，因为仅在第一次注意到它们时才安装 phaser 。）</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_block_phasers">58.3. Block phasers</h3>
<div class="paragraph">
<p>块的上下文中的执行具有其自己的 phases。</p>
</div>
<div class="paragraph">
<p>块离开 phaser 等待直到调用堆栈实际展开才能运行。只有在某个异常处理程序决定以这种方式处理异常之后才会展开。也就是说，仅仅因为异常被抛出堆栈帧并不意味着我们已经正式离开了块，因为异常可能是可恢复的。在任何情况下，异常处理程序都指定在失败代码的动态作用域内运行，无论异常是否可恢复。堆栈已展开，仅在未恢复异常时才调用 phaser 。</p>
</div>
<div class="paragraph">
<p>这些可以在块内多次出现。所以它们确实不是真正的 trait - 它们将自己添加到存储在实际 trait 中的列表中。如果你检查块的 <code>ENTER</code> trait，你会发现它实际上是一个 phaser 列表而不是一个 phaser 。</p>
</div>
<div class="paragraph">
<p>所有这些 phaser 块都可以看到任何先前声明的词法变量，即使在调用闭包时尚未详细说明这些变量（在这种情况下，变量会计算为未定义的值。）</p>
</div>
<div class="sect3">
<h4 id="_enter">58.3.1. ENTER</h4>
<div class="paragraph">
<p>在每个块进入时运行，在循环块上重复。</p>
</div>
<div class="paragraph">
<p>可以具有即使在后期 phases 提供的返回值。</p>
</div>
<div class="paragraph">
<p>从 <code>ENTER</code> phaser 抛出的异常将中止 <code>ENTER</code> 队列，但是从 <code>LEAVE</code> phaser 抛出的异常将不会。</p>
</div>
</div>
<div class="sect3">
<h4 id="_leave">58.3.2. LEAVE</h4>
<div class="paragraph">
<p>在每个块退出时运行（甚至堆栈从异常中展开），除非程序突然退出（例如 <a href="https://docs.raku.org/routine/exit"><code>exit</code></a>）。</p>
</div>
<div class="paragraph">
<p><code>LEAVE</code> 在任何 <code>CATCH</code> 和 <code>CONTROL</code> phaser 之后必须计算给定块的 phaser 。这包括 <code>LEAVE</code> 变体，<code>KEEP</code> 和 <code>UNDO</code>。<code>POST</code> 在其他一切之后对 phaser 进行计算，以保证偶数 <code>LEAVE</code> phaser 不会违反后置条件。</p>
</div>
<div class="paragraph">
<p>从 <code>ENTER</code> phaser 抛出的异常将中止 <code>ENTER</code> 队列，但是从 <code>LEAVE</code> phaser 抛出的异常将不会。</p>
</div>
<div class="paragraph">
<p>如果 <code>POST</code> 失败或任何类型的 <code>LEAVE</code> 块在堆栈展开时抛出异常，则展开继续并收集要处理的异常。展开完成后，将从该点抛出所有新异常。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub answer() {
    LEAVE say „I say after the return value.“;

    42 # this is the return value
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>注意:</strong> 铭记 <code>LEAVE</code> phaser 直接在程序的块，即使用错误的参数尝试调用该例程, 他们也将得到执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub foo (Int) {
    say "Hello!";
    LEAVE say "oh noes!"
}
try foo rand; # OUTPUT: «oh noes!»</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然子程序的主体没有得到执行，因为 sub 的<a href="https://docs.raku.org/type/Int">Int</a> 和 <a href="https://docs.raku.org/routine/rand"><code>rand</code></a> 期望返回一个 <a href="https://docs.raku.org/type/Num">Num</a>，其块进入和离开时（指令绑定失败），因此 <code>LEAVE</code> phaser *正*运行。</p>
</div>
</div>
<div class="sect3">
<h4 id="_keep">58.3.3. KEEP</h4>
<div class="paragraph">
<p>在每个成功的块出口处运行，作为 LEAVE 队列的一部分（共享相同的执行顺序）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_undo">58.3.4. UNDO</h4>
<div class="paragraph">
<p>在每个不成功的块出口处运行，作为 LEAVE 队列的一部分（共享相同的执行顺序）。</p>
</div>
</div>
<div class="sect3">
<h4 id="_pre">58.3.5. PRE</h4>
<div class="paragraph">
<p>断言每个块条目的前提条件。在 ENTER phase 之前运行。</p>
</div>
<div class="paragraph">
<p><code>PRE</code> phaser 在任何 <code>ENTER</code> 或 <code>FIRST</code> 之前启动。</p>
</div>
<div class="paragraph">
<p>失败的 <code>PRE</code> 和 <code>POST</code> phaser 抛出的异常不能被同一个块中的 <code>CATCH</code> 异常捕获，这意味着如果`PRE`phaser 失败，则 <code>POST</code> phaser 不会运行。</p>
</div>
</div>
<div class="sect3">
<h4 id="_post">58.3.6. POST</h4>
<div class="paragraph">
<p>在每个块条目处断言后置条件。在 LEAVE phase 后运行。</p>
</div>
<div class="paragraph">
<p>对于如 <code>KEEP</code> 和 <code>POST</code> 的 phaser，在正常情况下退出作用域时运行，返回值（如果有的话）从该作用域可作为 phaser 中的当前主题。</p>
</div>
<div class="paragraph">
<p><code>POST</code> 块可以以两种方式之一来定义。要么 <code>POST</code> 定义为单独的 phaser ，在这种情况下 <code>PRE</code> 和 <code>POST</code> 不共享词法作用域。或者，任何 <code>PRE</code> phaser 都可以将其对应的 <code>POST</code> 定义为嵌入式 phaser 块，该 phaser 块封闭在 <code>PRE</code> 的词法作用域内。</p>
</div>
<div class="paragraph">
<p>如果 <code>POST</code> 失败或任何类型的 <code>LEAVE</code> 块在堆栈展开时抛出异常，则展开继续并收集要处理的异常。展开完成后，将从该点抛出所有新异常。</p>
</div>
<div class="paragraph">
<p><code>PRE</code> 和 <code>POST</code> phaser 抛出的异常不能被同一个块中的  <code>CATCH</code> 异常捕获，这意味着如果 <code>PRE</code> phaser 失败，<code>POST</code> phaser 就不会运行。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_loop_phasers">58.4. Loop phasers</h3>
<div class="paragraph">
<p><code>FIRST</code>，<code>NEXT</code> 和 <code>LAST</code> 仅在循环的词法作用域内有意义，并且可能仅在这样的循环块的顶层发生。</p>
</div>
<div class="sect3">
<h4 id="_first">58.4.1. FIRST</h4>
<div class="paragraph">
<p>在 ENTER 之前运行循环初始化。</p>
</div>
</div>
<div class="sect3">
<h4 id="_next_2">58.4.2. NEXT</h4>
<div class="paragraph">
<p>循环继续（通过 <code>next</code> 或因为你到达循环的底部并循环回来）时运行，在LEAVE之前。</p>
</div>
<div class="paragraph">
<p>仅当正常到达循环块的末尾或 <code>next`显式 执行时，才执行 `NEXT</code>。 与 <code>LEAVE</code> phaser 不同，<code>NEXT</code> 如果通过除由 <code>next</code> 引发的控制异常之外的任何异常退出循环块，则不执行 <code>NEXT</code> phaser。特别地，<code>last</code> 绕过了 <code>NEXT</code> phaser 的计算。</p>
</div>
</div>
<div class="sect3">
<h4 id="_last_2">58.4.3. LAST</h4>
<div class="paragraph">
<p>在循环结束时运行，在 <code>LEAVE</code> 之后(或者当它使用 <code>last</code> 或 <code>return</code> 退出时; 或者因为你到了循环的底部) 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exception_handling_phasers">58.5. Exception handling phasers</h3>
<div class="sect3">
<h4 id="_catch">58.5.1. CATCH</h4>
<div class="paragraph">
<p>在 LEAVE phase 之前，当前块引发异常时运行。</p>
</div>
</div>
<div class="sect3">
<h4 id="_control">58.5.2. CONTROL</h4>
<div class="paragraph">
<p>在 LEAVE phase 之前，当前块引发控制异常时运行。它通过 <code>return</code>，<code>fail</code>，<code>redo</code>，<code>next</code>，<code>last</code>，<code>emit</code>，<code>take</code>，<code>warn</code>，<code>proceed</code> 和 <code>succeed</code> 发生。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say elems gather {
    CONTROL {
        when CX::Warn { say "WARNING!!! $_"; .resume }
        when CX::Take { say "Don't take my stuff"; .resume }
    }
    warn 'people take stuff here';
    take 'keys';
}
# OUTPUT:
# WARNING!!! people take stuff here
# Don't take my stuff
# 0</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_object_phasers">58.6. Object phasers</h3>
<div class="sect3">
<h4 id="_compose_not_yet_implemented">58.6.1. COMPOSE (Not yet implemented)</h4>
<div class="paragraph">
<p>将角色组合到一个类中时运行。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_asynchronous_phasers">58.7. Asynchronous phasers</h3>
<div class="sect3">
<h4 id="_last_3">58.7.1. LAST</h4>
<div class="paragraph">
<p>当<a href="https://docs.raku.org/type/Supply">Supply</a> 完成 <code>done</code> 调用或当一个 <code>supply</code> 块正常退出时运行。它在 <code>whenever</code> 块完成后完全运行。</p>
</div>
<div class="paragraph">
<p>此 phaser 重用该名称 <code>LAST</code>，但与 <code>LAST</code> 循环 phaser 的工作方式不同。此 phaser 类似于用 <code>tap</code> supply 设置例程 <code>done</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_quit">58.7.2. QUIT</h4>
<div class="paragraph">
<p>当 <a href="https://docs.raku.org/type/Supply">Supply</a> 以异常提前终止时运行。它在放置的  <code>whenever</code> 块完成后运行。</p>
</div>
<div class="paragraph">
<p>此 phaser 类似于 <code>quit</code> 在 <code>tap</code> supply 时设置例程 <code>quit</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_close">58.7.3. CLOSE</h4>
<div class="paragraph">
<p>出现在 supply 块中。supply 关闭时调用。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_doc_phasers">58.8. DOC phasers</h3>
<div class="sect3">
<h4 id="_doc">58.8.1. DOC</h4>
<div class="paragraph">
<p>phaser <code>BEGIN</code>，<code>CHECK</code> 和 <code>INIT</code> 仅在文档模式时，前面带有 <code>DOC</code> 关键字。当使用 <code>--doc</code> 运行时编译器在文档中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">DOC INIT { say 'init'  }  # prints 'init' at initialization time when in documentation mode.</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_编译指令_2">59. 编译指令</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 中，<strong>pragma</strong> 是用于识别要使用的 Raku 的特定版本或以某种方式修改编译器的正常行为的指令。<code>use</code> 关键字开启编译指示（类似于你怎么 <code>use</code> 一个模块）。要禁用 pragma，请使用 <code>no</code> 关键字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6.c;   # use 6.c language version
no worries; # don't issue compile time warnings</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下是一个编译指令列表，其中包含每个编译指令意图的简短描述或指向其使用的更多详细信息的链接。（注意：标记为“[NYI]”的编译指令尚未实现，标记为“[TBD]”的编号将在稍后定义。）</p>
</div>
<div class="sect2">
<h3 id="_v6_x">59.1. v6.x</h3>
<div class="paragraph">
<p>该编译指令 声明了将要使用的编译器的版本，如果它们是可选的，则开启它的功能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use v6;   # Load latest supported version (non-PREVIEW).
          # Also, useful for producing better errors when accidentally
          # executing the program with `perl` instead of `raku`
use v6.c;         # Use the "Christmas" version of Raku
use v6.d;         # Use the "Diwali" version of Raku
use v6.d.PREVIEW; # On 6.d-capable compilers, enables 6.d features,
                  # otherwise enables the available experimental
                  # preview features for 6.d language
                  # This will only work on releases previous to 6.d.</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于这些编译指令是在编译器版本上开启的，所以它们应该是文件中的第一个语句（前面的注释和 Pod 都没问题）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_monkey_guts">59.2. MONKEY-GUTS</h3>
<div class="paragraph">
<p>该编译指令目前不是任何 Raku 规范的一部分，但作为 <code>use nqp</code> 的同义词存在于 Rakudo 中（见下文）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_monkey_see_no_eval">59.3. MONKEY-SEE-NO-EVAL</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/routine/EVAL">EVAL</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_monkey_typing">59.4. MONKEY-TYPING</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/syntax/augment">augment</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_monkey">59.5. MONKEY</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use MONKEY;</code></pre>
</div>
</div>
<div class="paragraph">
<p>打开所有可用的 <code>MONKEY</code> 编译指令，目前有上面的三个; 因此，它等同于：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use MONKEY-TYPING;
use MONKEY-SEE-NO-EVAL;
use MONKEY-GUTS;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_experimental">59.6. experimental</h3>
<div class="paragraph">
<p>允许使用<a href="https://docs.raku.org/language/experimental">实验性功能</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_fatal">59.7. fatal</h3>
<div class="paragraph">
<p>一个词法编译指令，使得<a href="https://docs.raku.org/type/Failure">Failures</a>从例程致命错误中返回。例如，<a href="https://docs.raku.org/type/Str">Str</a>上的 <code>+</code> 前缀将其强制转换为<a href="https://docs.raku.org/type/Numeric">Numeric</a>，但如果字符串包含非数字字符，则返回<a href="https://docs.raku.org/type/Failure">Failure</a>。在变量中保存该<a href="https://docs.raku.org/type/Failure">Failure</a>可以防止它被下沉，因此下面的第一个代码块到达 <code>say $x.^name;</code> 行并在输出中打印 <code>Failure</code>。</p>
</div>
<div class="paragraph">
<p>在第二个块中，<code>use fatal</code> 编译指定开启了，因此 <code>say</code> 永远不会到达该行，因为从前缀 <code>+</code> 返回的 <a href="https://docs.raku.org/type/Failure">Failure</a> 中包含的 <a href="https://docs.raku.org/type/Exception">Exception</a> 被抛出并且 <code>CATCH</code> 块被运行，打印出 <code>Caught&#8230;&#8203;</code> 行。请注意，这两个块都是相同的程序，<code>use fatal</code> 只会影响它所使用的词法块：<code>Caught&#8230;&#8203;use fatal</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    my $x = +"a";
    say $x.^name;
    CATCH { default { say "Caught {.^name}" } }
} # OUTPUT: «Failure»

{
    use fatal;
    my $x = +"a";
    say $x.^name;
    CATCH { default { say "Caught {.^name}" } }
} # OUTPUT: «Caught X::Str::Numeric»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在<a href="https://docs.raku.org/language/exceptions#index-entry-try_blocks-try"><code>try</code></a> 块内部，默认开启 <code>fatal</code> 编译指令，您可以使用 <code>no fatal</code> *禁用*它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">try {
    my $x = +"a";
    say $x.^name;
    CATCH { default { say "Caught {.^name}" } }
} # OUTPUT: «Caught X::Str::Numeric»

try {
    no fatal;
    my $x = +"a";
    say $x.^name;
    CATCH { default { say "Caught {.^name}" } }
} # OUTPUT: «Failure»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_internals">59.8. internals</h3>

</div>
<div class="sect2">
<h3 id="_invocant_2">invocant</h3>

</div>
<div class="sect2">
<h3 id="_isms">isms</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[2018.09 and later]</code></pre>
</div>
</div>
<div class="paragraph">
<p>允许被认为是正常 Raku 编程中的警告和/或错误的陷阱的一些其他语言结构。目前，<code>Perl5</code> 和 <code>C++</code> 是被允许的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub abs() { say "foo" }
abs;
# Unsupported use of bare "abs"; in Raku please use .abs if you meant
# to call it as a method on $_, or use an explicit invocant or argument,
# or use &amp;abs to refer to the function as a noun</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，提供一个不带任何参数的 <code>abs</code> sub，并没有使编译错误消失。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use isms &lt;Perl5&gt;;
sub abs() { say "foo" }
abs;   # foo</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这个，编译器将允许违规的 Perl 5 构造，允许实际执行代码。</p>
</div>
<div class="paragraph">
<p>如果未指定任何语言，则允许使用所有已知语言结构。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use isms;   # allow for Perl5 and C++ isms</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lib_2">59.9. lib</h3>
<div class="paragraph">
<p>该编译指令将子目录添加到库搜索路径，以便解释器可以<a href="https://docs.raku.org/language/modules#Finding_modules">找到模块</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use lib &lt;lib /opt/lib /usr/local/lib&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将搜索列表中传递的目录。有关更多示例，请查看<a href="https://docs.raku.org/language/modules#use">模块文档</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_newline">59.10. newline</h3>
<div class="paragraph">
<p>在调用的作用域内设置<a href="https://docs.raku.org/language/variables#Compile-time_variables">$?NL</a>常量的值。可能的值有 <code>:lf</code>（默认值，表示换行），<code>:crlf</code>（表示回车，换行）和 <code>:cr</code>（表示回车）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_nqp">59.11. nqp</h3>
<div class="paragraph">
<p>使用风险由您自己承担。</p>
</div>
<div class="paragraph">
<p>这是一个 Rakudo 特有的编译指令。有了它，Rakudo 可以访问顶级命名空间中的<a href="https://github.com/raku/nqp/blob/master/docs/ops.markdown">nqp操作码</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use nqp;
nqp::say("hello world");</code></pre>
</div>
</div>
<div class="paragraph">
<p>这使用底层的 nqp <code>say</code> 操作码而不是 Raku 例程。这个编译指示可能会使您的代码依赖于特定版本的 nqp，并且由于该代码不是 Raku 规范的一部分，因此不能保证它是稳定的。您可能会在 Rakudo 核心中找到大量用法，这些用法用于尽可能快地实现核心功能。Rakudo 代码生成的未来优化可能会废弃这些用法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters">59.12. parameters</h3>

</div>
<div class="sect2">
<h3 id="_precompilation">precompilation</h3>
<div class="paragraph">
<p>默认允许预编译源代码，特别是在模块中使用时。如果由于某种原因您不希望预编译（模块的）代码，您可以使用 <code>no precompilation</code>。这将阻止整个编译单元（通常是文件）被预编译。</p>
</div>
</div>
<div class="sect2">
<h3 id="_soft">59.13. soft</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/functions#Re-dispatching">Re-dispatching</a>, <a href="https://docs.raku.org/language/functions#index-entry-use_soft_%28pragma%29">inlining</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_strict_2">59.14. strict</h3>
<div class="paragraph">
<p><code>strict</code> 是默认行为，并要求您在使用变量之前声明变量。你可以用 <code>no</code> 放松这个限制。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">no strict; $x = 42; # OK</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_trace">59.15. trace</h3>
<div class="paragraph">
<p>当 <code>use trace</code> 被激活时，执行的代码的任何行将被写入 stderr。您可以使用 <code>no trace</code> 关闭该功能，因此这仅适用于某些代码段。</p>
</div>
</div>
<div class="sect2">
<h3 id="_v6_2">59.16. v6</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/testing#Writing_tests">Writing Tests</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_variables_2">59.17. variables</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/variables#Default_defined_variables_pragma">Defined Variables Pragma</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_worries">59.18. worries</h3>
<div class="paragraph">
<p>词法地控制是否显示编译器生成的编译时警告。默认情况下启用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$ raku -e 'say :foo&lt;&gt;.Pair'
Potential difficulties:
  Pair with &lt;&gt; really means an empty list, not null string; use :foo('') to represent the null string,
    or :foo() to represent the empty list more accurately
  at -e:1
  ------&gt; say :foo&lt;&gt;⏏.Pair
foo =&gt; Nil

$ raku -e 'no worries; say :foo&lt;&gt;.Pair'
foo =&gt; Nil</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_引号结构">60. 引号结构</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_the_q_lang">60.1. The Q Lang</h3>
<div class="paragraph">
<p>在 Raku 中, 字符串通常使用一些引号结构来表示. 这些引号结构中,最简单的就是 <code>Q</code>, 通过便捷方式 <code>｢…｣</code> 或 <code>Q</code> 后跟着由任意一对儿分隔符包围着的文本. 大多数时候, 你需要的只是 <code>'…'</code> 或 <code>"…"</code>.</p>
</div>
<div class="sect3">
<h4 id="_literal_strings_q">60.1.1. Literal strings: Q</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Q[A literal string]
｢More plainly.｣
Q ^Almost any non-word character can be a delimiter!^
Q ｢｢Delimiters can be repeated/nested if they are adjacent.｣｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>分隔符能够嵌套, 但是在普通的 Q 形式中, 反斜线转义是不允许的. 换种说法就是, Q 字符串尽可能被作为字面量.</p>
</div>
<div class="paragraph">
<p>在 <code>Q</code>、<code>q</code> 或 <code>qq</code> 之后不允许立即使用一些分隔符。<a href="https://docs.raku.org/language/syntax#Identifiers">标识符</a>中允许的任何字符都不允许使用，因为在这种情况下，引号结构和这些字符一起被解释为标识符。此外，<code>( )</code> 是不允许的，因为它被解释为函数调用。如果你仍然希望使用这些字符作为分隔符，请用空格将它们与 <code>Q</code>、<code>q</code> 或 <code>qq</code> 分隔开。请注意，一些自然语言在字符串的右侧使用左分隔引号。<code>Q</code> 不支持这些，因为它依赖unicode 属性来区分左分隔符和右分隔符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Q'this will not work!'
Q(this won't work either!)</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面对例子会产生错误。然而，下面这个能起作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Q (this is fine, because of space after Q)
Q 'and so is this'
Q&lt;Make sure you &lt;match&gt; opening and closing delimiters&gt;
Q{This is still a closing curly brace → \}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些例子产生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">this is fine, because of space after Q
and so is this
Make sure you &lt;match&gt; opening and closing delimiters
This is still a closing curly brace → \</code></pre>
</div>
</div>
<div class="paragraph">
<p>引号结构的行为可以用副词修改，后面的章节会详细解释。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Short</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Meaning</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:exec</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Execute as command and return results</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:words</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Split result on words (no quote protection)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:ww</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:quotewords</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Split result on words (with quote protection)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:q</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:single</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolate \\, \qq[&#8230;&#8203;] and escaping the delimiter with \</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:qq</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:double</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolate with :s, :a, :h, :f, :c, :b</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:scalar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolate $ vars</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolate @ vars</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:h</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:hash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolate % vars</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:f</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:function</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolate &amp; calls</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:c</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:closure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpolate {&#8230;&#8203;} expressions</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:backslash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enable backslash escapes (\n, \qq, \$foo, etc)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:to</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:heredoc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parse result as heredoc terminator</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:v</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">:val</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convert to allomorph if possible</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_escaping_q">60.1.2. Escaping: q</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'Very plain';
q[This back\slash stays];
q[This back\\slash stays]; # Identical output
q{This is not a closing curly brace → \}, but this is → };
Q :q $There are no backslashes here, only lots of \$\$\$&gt;!$;
'(Just kidding. There\'s no money in that string)';
'No $interpolation {here}!';
Q:q!Just a literal "\n" here!;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>q</code> 形式的引号结构允许使用反斜线转义可能会结束字符串的字符. 反斜线自身也能被转义, 就像上面的第三个例子那样. 通常的形式是 <code>'&#8230;&#8203;'</code> 或 <code>q</code> 后跟着分隔符, 但是它也能作为 Q 上的副词使用, 就像上面的第五个和最后一个例子那样.</p>
</div>
<div class="paragraph">
<p>这些例子产生:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Very plain
This back\slash stays
This back\slash stays
This is not a closing brace → } but this is →
There are no backslashes here, only lots of $$$!
(Just kidding. There's no money in that string)
No $interpolation {here}!
Just a literal "\n" here</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>\qq<a href="https://docs.raku.org/language/quoting#Interpolation%3A_qq">&#8230;&#8203;</a></code> 转义序列允许 [qq 插值] 的一部分字符串。当字符串中有 HTML 标记时，使用这个转义序列非常方便，可以避免将尖括号解释为散列键:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $var = 'foo';
say '&lt;code&gt;$var&lt;/code&gt; is &lt;var&gt;\qq[$var.uc()]&lt;/var&gt;';
# OUTPUT: «&lt;code&gt;$var&lt;/code&gt; is &lt;var&gt;FOO&lt;/var&gt;␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_interpolation_qq">60.1.3. Interpolation: qq</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $color = 'blue';
say "My favorite color is $color!" # My favorite color is blue!</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>qq</code> 形式&#8201;&#8212;&#8201;通常使用双引号写成&#8201;&#8212;&#8201;允许变量的插值, 例如字符串中能写入变量, 以使变量的内容能插入到字符串中. 在 <code>qq</code> 引起字符串中, 也能转义变量.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "The \$color variable contains the value '$color'";
# The $color variable contatins the value 'blue'</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>qq</code> 的另外一种功能是使用花括号在字符串中插值 Raku 代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my ($x, $y, $z) = 4, 3.5, 3;
say "This room is $x m by $y m by $z m."
say "Therefore its volume should be { $x * $y * $z } m³!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">This room is 4 m by 3.5 m by 3 m.
Therefore its volume should be 42 m³!</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下, 只有带有 <code>$</code> 符号的变量才能正常插值. 这时, <code>"<a href="mailto:documentation@raku.org">documentation@raku.org</a>"</code> 不会插值  <code>@raku</code> 变量. 如果你确实想那么做, 在变量名后面添加一个 <code>[]</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @neighbors = "Felix", "Danielle", "Lucinda";
say "@neighbors[] and I try our best to coexist peacefully."</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Felix Danielle Lucinda and I try our best to coexist peacefully.</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常使用一个方法调用会更合适. 只有在 <code>qq</code> 引号中, 方法调用后面有圆括号, 就能进行插值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "@neighbors.join(', ') and I try our best to coexist peacefully."</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Felix, Danielle, Lucinda and I try our best to coexist peacefully.</code></pre>
</div>
</div>
<div class="paragraph">
<p>而 <code>"@example.com"</code> 产生 <code>@example.com</code>.</p>
</div>
<div class="paragraph">
<p>要调用子例程请使用 <code>&amp;</code> 符号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "abc&amp;uc("def")ghi";
# OUTPUT: «abcDEFghi␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>后环缀操作符和 <a href="https://docs.raku.org/language/subscripts">subscripts</a> 也会被插值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %h = :1st; say "abc%h&lt;st&gt;ghi";
# OUTPUT: «abc1ghi␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>要输入 unicode 序列，请使用 <code>\x</code> 或 <code>\x[]</code> 加上字符的十六进制编码或字符列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = "I \x2665 Raku!";
say $s;
# OUTPUT: «I ♥ Raku!␤»

$s = "I really \x[2661,2665,2764,1f495] Raku!";
say $s;
# OUTPUT: «I really ♡♥❤💕 Raku!␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以在 <a href="https://docs.raku.org/language/unicode#Entering_unicode_codepoints_and_codepoint_sequences">\c[</a>] 中使用 <a href="https://docs.raku.org/language/unicode#Entering_unicode_codepoints_and_codepoint_sequences">unicode 名称</a>、<a href="https://docs.raku.org/language/unicode#Named_sequences">命名序列</a>和<a href="https://docs.raku.org/language/unicode#Name_aliases">名称别名</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $s = "Camelia \c[BROKEN HEART] my \c[HEAVY BLACK HEART]!";
say $s;
# OUTPUT: «Camelia 💔 my ❤!␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>对未定义值进行插值将引发控件异常，该异常可以在当前控件块中使用 <a href="https://docs.raku.org/language/phasers#CONTROL">CONTROL</a> 捕获。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub niler {Nil};
my Str $a = niler;
say("$a.html", "sometext");
say "alive"; # this line is dead code
CONTROL { .die };</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_word_quoting_qw">60.1.4. Word quoting: qw</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">qw|! @ # $ % ^ &amp; * \| &lt; &gt; | eqv '! @ # $ % ^ &amp; * | &lt; &gt;'.words.list
q:w { [ ] \{ \} } eqv ('[', ']', '{', '}')
Q:w | [ ] { } | eqv ('[', ']', '{', '}')</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:w</code> 通常写作 <code>qw</code>, 把字符串分割为 "words" (单词). 在这种情景下, 单词被定义为由空格分割的一串非空白字符. <code>q:w</code> 和 <code>qw</code> 继承了 <code>q</code> 的插值和转义语法, 还有单引号字符串分割符, 而 <code>Qw</code> 和 <code>Q:w</code> 继承了 <code>Q</code> 的非转义语法.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @directions = 'left', 'right,', 'up', 'down';</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样读和写都更容易:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @directions = qw|left right up down|;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_word_quoting">60.1.5. Word quoting: &lt;&gt;</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &lt;a b c&gt; eqv ('a', 'b', 'c');   # OUTPUT: «True␤»
say &lt;a b 42&gt; eqv ('a', 'b', '42'); # OUTPUT: «False␤», the 42 became an IntStr allomorph
say &lt; 42 &gt; ~~ Int; # OUTPUT: «True␤»
say &lt; 42 &gt; ~~ Str; # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>尖括号的引号类似于 <code>qw</code>，但有一个额外的特性，可以让你构造特定数字的<a href="https://docs.raku.org/language/glossary#index-entry-Allomorph">同质异形体</a>或字面量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &lt;42 4/2 1e6 1+1i abc&gt;.perl;
# OUTPUT: «(IntStr.new(42, "42"), RatStr.new(2.0, "4/2"), NumStr.new(1000000e0, "1e6"), ComplexStr.new(&lt;1+1i&gt;, "1+1i"), "abc")␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>要构造 <a href="https://docs.raku.org/type/Rat">Rat</a> 或 <a href="https://docs.raku.org/type/Complex">Complex</a> 字面量，请在数字周围使用尖括号，不带任何额外的空格:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &lt;42/10&gt;.^name;   # OUTPUT: «Rat␤»
say &lt;1+42i&gt;.^name;   # OUTPUT: «Complex␤»
say &lt; 42/10 &gt;.^name; # OUTPUT: «RatStr␤»
say &lt; 1+42i &gt;.^name; # OUTPUT: «ComplexStr␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>与 <code>42/10</code> 和 <code>1+42i</code> 相比，不涉及除法(或加法)运算。这对于例程签名中的字面量很有用，例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub close-enough-π (&lt;355/113&gt;) {
    say "Your π is close enough!"
}
close-enough-π 710/226; # OUTPUT: «Your π is close enough!␤»

# WRONG: can't do this, since it's a division operation

sub compilation-failure (355/113) {}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_word_quoting_with_quote_protection_qww">60.1.6. Word quoting with quote protection: qww</h4>
<div class="paragraph">
<p>单词引用的 <code>qw</code> 格式将按字面意思处理引用字符，将它们保留在结果单词中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say qw{"a b" c}.perl; # OUTPUT: «("\"a", "b\"", "c")␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，如果您希望在结果单词中保留引用的子字符串作为单个项，则需要使用 <code>qww</code> 变体:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say qww{"a b" c}.perl; # OUTPUT: «("a b", "c")␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_word_quoting_with_interpolation_qqw">60.1.7. Word quoting with interpolation: qqw</h4>
<div class="paragraph">
<p><code>qw</code> 形式的 word quoting 不会进行变量插值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42; say qw{$a b c};  # $a b c</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此, 如果你想在引号字符串中进行变量插值, 你需要使用 <code>qqw</code> 变体:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42;
my @list = qqw{$a b c};
say @list;                # 42 b c</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，变量插值发生在单词分割之前:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = "a b";
my @list = qqw{$a c};
.say for @list; # OUTPUT: «a␤b␤c␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_word_quoting_with_interpolation_and_quote_protection_qqww">60.1.8. Word quoting with interpolation and quote protection: qqww</h4>
<div class="paragraph">
<p><code>qqw</code> 形式的单词引用会把引起的字符当作字面量，将引起的字符留在结果单词中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42; say qqw{"$a b" c}.perl;  # OUTPUT: «("\"42", "b\"", "c")␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，如果希望在结果单词中保留引起的子字符串为单个项，则需要使用 <code>qqww</code> 变体:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 42; say qqww{"$a b" c}.perl; # OUTPUT: «("42 b", "c")␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>引号保护发生在插值之前，插值发生在分词之前，所以来自插值变量内部的引号只是字面引号字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = "1 2";
say qqww{"$a" $a}.perl; # OUTPUT: «("1 2", "1", "2")␤»
my $b = "1 \"2 3\"";
say qqww{"$b" $b}.perl; # OUTPUT: «("1 \"2 3\"", "1", "\"2", "3\"")␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_word_quoting_with_interpolation_and_quote_protection">60.1.9. Word quoting with interpolation and quote protection: « »</h4>
<div class="paragraph">
<p>这种引用方式类似于 <code>qqww</code>，但它具有构造 <a href="https://docs.raku.org/language/glossary#index-entry-Allomorph">allomorphs</a> 的额外好处(使其功能相当于 <a href="https://docs.raku.org/language/quoting#index-entry-%3Aval_%28quoting_adverb%29">qq:ww:v</a>)。与 <code>«»</code> 等价的 ASCII 是双尖括号 <code>&lt;&lt; &gt;&gt;</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Allomorph Construction
my $a = 42; say «  $a b c    ».perl;  # OUTPUT: «(IntStr.new(42, "42"), "b", "c")␤»
my $a = 42; say &lt;&lt; $a b c   &gt;&gt;.perl;  # OUTPUT: «(IntStr.new(42, "42"), "b", "c")␤»

# Quote Protection
my $a = 42; say «  "$a b" c  ».perl;  # OUTPUT: «("42 b", "c")␤»
my $a = 42; say &lt;&lt; "$a b" c &gt;&gt;.perl;  # OUTPUT: «("42 b", "c")␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_shell_quoting_qx">60.1.10. Shell quoting: qx</h4>
<div class="paragraph">
<p>要将字符串作为外部程序运行，不仅可以将字符串传递给 <code>shell</code> 或 <code>run</code> 函数，还可以执行 shell 引用。然而，有一些微妙之处需要考虑。<code>qx</code> 引号不插入变量。因此</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $world = "there";
say qx{echo "hello $world"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>仅仅打印 <code>hello</code>. 然而, 如果你在调用 <code>raku</code> 之前声明了一个环境变量, 这在 <code>qx</code> 里是可用的, 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">WORLD="there" raku
&gt; say qx{echo "hello $WORLD"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在会打印 <code>hello there</code>.</p>
</div>
<div class="paragraph">
<p>调用 <code>qx</code> 会返回结果, 所以这个结果能被赋值给一个变量以便后来使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $output = qx{echo "hello!"};
say $output;    # hello!</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_shell_quoting_with_interpolation_qqx">60.1.11. Shell quoting with interpolation: qqx</h4>
<div class="paragraph">
<p>如果希望在外部命令中使用 Raku 变量的内容，那么应该使用 <code>qqx</code> shell 引用结构:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $world = "there";
say qqx{echo "hello $world"};  # hello there</code></pre>
</div>
</div>
<div class="paragraph">
<p>再一次, 外部命令的输出结果可以保存在一个变量中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $word = "cool";
my $option = "-i";
my $file = "/usr/share/dict/words";
my $output = qqx{grep $option $word $file};
# runs the command: grep -i cool /usr/share/dict/words
say $output;      # Cooley␤Cooley's␤Coolidge␤Coolidge's␤cool␤ ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关执行外部命令的更好方法，请参见 <a href="https://docs.raku.org/routine/run">run</a> 和 <a href="https://docs.raku.org/type/Proc::Async">Proc::Async</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_heredocs_to">60.1.12. Heredocs: :to</h4>
<div class="paragraph">
<p>一种方便的写多行字符串字面量的方式是 <strong>heredocs</strong>，它让你选择自己的分隔符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say q:to/END/;
Here is
some multi-line
string
END</code></pre>
</div>
</div>
<div class="paragraph">
<p>heredoc 的内容总是从下一行开始，所以你可以(也应该)完成这一行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $escaped = my-escaping-function(q:to/TERMINATOR/, language =&gt; 'html');
Here are the contents of the heredoc.
Potentially multiple lines.
TERMINATOR</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果终止分隔符缩进了, 同等数量的缩进会从字符串字面量上移除. 因此下面这个 heredoc</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say q:to/END/;
    Here is
    some multi line
        string
    END</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Here is
some multi line
    string</code></pre>
</div>
</div>
<div class="paragraph">
<p>heredoc 包含了终止符之前的换行符。</p>
</div>
<div class="paragraph">
<p>要允许对变量进行插值，可以使用 <code>qq</code> 形式，但如果不是已定义变量的标识符，则必须转义元字符 <code>{\</code> 和 <code>$</code>。例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $f = 'db.7.3.8';
my $s = qq:to/END/;
option \{
    file "$f";
};
END
say $s;</code></pre>
</div>
</div>
<div class="paragraph">
<p>会产生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">option {
    file "db.7.3.8";
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在同一行开始多个 heredoc。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my ($first, $second) = qq:to/END1/, qq:to/END2/;
  FIRST
  MULTILINE
  STRING
  END1
   SECOND
   MULTILINE
   STRING
   END2</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_unquoting">60.1.13. Unquoting</h4>
<div class="paragraph">
<p>字面量字符串允许使用转义序列插入内嵌的引用结构，例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $animal="quaggas";
say 'These animals look like \qq[$animal]'; # OUTPUT: «These animals look like quaggas␤»
say 'These animals are \qqw[$animal or zebras]'; # OUTPUT: «These animals are quaggas or zebras␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在本例中，<code>\qq</code> 将做双引号内插，<code>\qqw</code> 文字内插。如上所述，转义任何其他引用结构都将以相同的方式进行，从而允许在字面量字符串中进行插值。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_regexes">60.2. Regexes</h3>
<div class="paragraph">
<p>有关在 regexes 中应用的引用的信息，请参阅<a href="https://docs.raku.org/language/regexes">正则表达式文档</a>。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_正则表达式">61. 正则表达式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>正则表达式, 简称 regexes, 是描述文本模式的字符序列。模式匹配就是将这些模式和实际的文本进行匹配的过程。</p>
</div>
<div class="sect2">
<h3 id="_词法约定">61.1. 词法约定</h3>
<div class="paragraph">
<p>Raku 正则表达式有特殊的写法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">m/abc/;         # a regex that is immediately matched against $_
rx/abc/;        # a Regex object
/abc/;          # a Regex object</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于前两个例子,  分隔符还能用除了斜线之外的其它字符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">m{abc};
rx{abc};</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, 冒号和圆括号都不能用作分隔符; 禁止使用冒号作为正则表达式分割符是因为它和副词冲突, 例如 <code>rx:i/abc/</code>(忽略大小写的正则表达式), 而圆括号表明函数调用。</p>
</div>
<div class="paragraph">
<p>空白符在正则表达式中通常被忽略(带有 <code>:s</code> 或 <code>:sigspace</code> 副词的正则表达式除外)。</p>
</div>
<div class="paragraph">
<p>通常, 对于 Raku 来说, 正则表达式中的注释以 <code>#</code> 号开头, 直至行尾。</p>
</div>
</div>
<div class="sect2">
<h3 id="_字面值">61.2. 字面值</h3>
<div class="paragraph">
<p>正则表达式最简单的情况是匹配字符串字面值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 'properly' ~~ m/ perl / {
    say "'properly' contains 'perl'";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>字母数字和下划线 <code>_</code> 按字面值匹配。所有其它字符要么使用反斜线转义(例如, <code>\:</code> 匹配一个冒号), 要么用引号引起来:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ 'two words' /;     # matches 'two words' including the blank
/ "a:b"       /;     # matches 'a:b' including the colon
/ '#' /;             # matches a hash character</code></pre>
</div>
</div>
<div class="paragraph">
<p>字符串是从左往右搜索的, 所以如果只有部分字符串匹配正则表达式也足够:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 'abcdef' ~~ / de / {
    say ~$/;            # OUTPUT: «de␤»
    say $/.prematch;    # OUTPUT: «abc␤»
    say $/.postmatch;   # OUTPUT: «f␤»
    say $/.from;        # OUTPUT: «3␤»
    say $/.to;          # OUTPUT: «5␤»
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>匹配结果存储在 <code>$/</code> 变量中并且也从匹配中返回。如果匹配成功, 那么结果就是 <a href="https://docs.raku.org/type/Match">Match</a> 类型, 否则它就是 <a href="https://docs.raku.org/type/Nil">Nil</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_通配符和字符类">61.3. 通配符和字符类</h3>
<div class="sect3">
<h4 id="_点号匹配任意字符">61.3.1. 点号匹配任意字符: .</h4>
<div class="paragraph">
<p>在正则表达式中一个未转义的点 <code>.</code>  匹配任意单个字符。</p>
</div>
<div class="paragraph">
<p>所以,  这些都匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'perl' ~~ /per./;       # matches the whole string
'perl' ~~ / per . /;    # the same; whitespace is ignored
'perl' ~~ / pe.l /;     # the . matches the r
'speller' ~~ / pe.l/;   # the . matches the first l</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面这个不匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'perl' ~~ /. per /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为在目标字符串中 <code>per</code> 前面没有要匹配的字符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_反斜杠_预定义字符类">61.3.2. 反斜杠, 预定义字符类</h4>

</div>
<div class="sect3">
<h4 id="_unicode_properties">61.3.3. Unicode properties</h4>
<div class="paragraph">
<p>Raku 有 <code>\w</code> 形式的预定义字符类。大写形式是它的反面, <code>\W</code>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\d 和 \D</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>\d</code> 匹配单个数字(Unicode 属性 N) 而 <code>\D</code> 匹配单个不是数字的字符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'ab42' ~~ /\d/ and say ~$/;     # OUTPUT: «4␤»
'ab42' ~~ /\D/ and say ~$/;     # OUTPUT: «a␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, 不仅仅只有阿拉伯数字(通常用于拉丁字母表中)匹配 <code>\d</code>, 还有来自其它下标的数字也匹配 \d。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">U+0035 5 DIGIT FIVE
U+07C2 ߂ NKO DIGIT TWO
U+0E53 ๓ THAI DIGIT THREE
U+1B56 ᭖ BALINESE DIGIT SIX</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>\h 和 \H</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>\h</code> 匹配单个水平空白符。 <code>\H</code> 匹配单个不是水平空白符的字符。</p>
</div>
<div class="paragraph">
<p>水平空白符的例子有:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">U+0020 SPACE
U+00A0 NO-BREAK SPACE
U+0009 CHARACTER TABULATION
U+2001 EM QUAD</code></pre>
</div>
</div>
<div class="paragraph">
<p>像换行符那样的垂直空白被显式地排除了; 那些可以用 <code>\v</code> 来匹配, 而 <code>\s</code> 匹配任何类型的空白:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\n 和 \N</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>\n</code> 匹配单个逻辑换行符。<code>\n</code> 也支持匹配 Windows 的 CR LF 代码点对儿;　尽管还不清楚魔法是发生在读取数据时还是在正则表达式匹配时。 <code>\N</code> 匹配单个非逻辑换行符。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\s 和 \S</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>\s</code> 匹配单个空白符。 <code>\S</code> 匹配单个非空白符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 'contains a word starting with "w"' ~~ / w \S+ / {
    say ~$/;        # OUTPUT: «word␤»
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>\t 和 \T</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>\t</code> 匹配单个 tab/制表符, <code>U+0009</code>。(注意这儿不包含诸如 <code>U+000B VERTICAL TABULATION</code> 这样奇异的制表符)。<code>\T</code> 匹配单个非制表符。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\v 和 \V</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>\v</code> 匹配单个垂直空白符。 <code>\V</code> 匹配单个非垂直空白符。</p>
</div>
<div class="paragraph">
<p>垂直空白符的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">U+000A LINE FEED
U+000B VERTICAL TABULATION
U+000C FORM FEED
U+000D CARRIAGE RETURN
U+0085 NEXT LINE
U+2028 LINE SEPARATOR
U+2029 PARAGRAPH SEPARATOR</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>\s</code> 去匹配任意空白, 而不仅仅匹配垂直空白。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\w 和 \W</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>\w</code> 匹配单个单词字符; 例如: 一个字母(Unicode 类别 L), 一个数字或一个下划线。<code>\W</code> 匹配单个非单词字符。</p>
</div>
<div class="paragraph">
<p>单词字符的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">0041 A LATIN CAPITAL LETTER A
0031 1 DIGIT ONE
03B4 δ GREEK SMALL LETTER DELTA
03F3 ϳ GREEK LETTER YOT
0409 Љ CYRILLIC CAPITAL LETTER LJE</code></pre>
</div>
</div>
<div class="paragraph">
<p>预定义的 subrules:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;alnum&gt;   \w       'alpha' plus 'digit'
&lt;alpha&gt;   &lt;:L&gt;     Alphabetic characters
&lt;blank&gt;   \h       Horizontal whitespace
&lt;cntrl&gt;            Control characters
&lt;digit&gt;   \d       Decimal digits
&lt;graph&gt;            'alnum' plus 'punct'
&lt;lower&gt;   &lt;:Ll&gt;    Lowercase characters
&lt;print&gt;            'graph' plus 'space', but no 'cntrl'
&lt;punct&gt;            Punctuation and Symbols (only Punct beyond ASCII)
&lt;space&gt;   \s       Whitespace
&lt;upper&gt;   &lt;:Lu&gt;    Uppercase characters
&lt;|wb&gt;               Word Boundary (zero-width assertion)
&lt;ww&gt;               Within Word (zero-width assertion)
&lt;xdigit&gt;           Hexadecimal digit [0-9A-Fa-f]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_unicode_属性">61.3.4. Unicode 属性</h4>
<div class="paragraph">
<p>目前提到的字符类大多是为了方便; 另一种方法是使用 Unicode 字符属性。这些以 <code>&lt;:property&gt;</code> 的形式出现, 其中 <strong>property</strong> 可以是短的或长的 Unicode 一般类别名。它们使用 pair 语法。</p>
</div>
<div class="paragraph">
<p>要匹配一个 Unicode 属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">"a".uniprop('Script');                 # OUTPUT: «Latin␤»
"a" ~~ / &lt;:Script&lt;Latin&gt;&gt; /;
"a".uniprop('Block');                  # OUTPUT: «Basic Latin␤»
"a" ~~ / &lt;:Block('Basic Latin')&gt; /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的 Unicode 通用类别表是从 Perl 5 的 <a href="http://perldoc.perl.org/perlunicode.html">perlunicode</a> 文档偷来的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Short	Long
L	Letter
LC	Cased_Letter
Lu	Uppercase_Letter
Ll	Lowercase_Letter
Lt	Titlecase_Letter
Lm	Modifier_Letter
Lo	Other_Letter
M	Mark
Mn	Nonspacing_Mark
Mc	Spacing_Mark
Me	Enclosing_Mark
N	Number
Nd	Decimal_Number (also Digit)
Nl	Letter_Number
No	Other_Number
P	Punctuation (also punct)
Pc	Connector_Punctuation
Pd	Dash_Punctuation
Ps	Open_Punctuation
Pe	Close_Punctuation
Pi	Initial_Punctuation
        (may behave like Ps or Pe depending on usage)
Pf	Final_Punctuation
        (may behave like Ps or Pe depending on usage)
Po	Other_Punctuation
S	Symbol
Sm	Math_Symbol
Sc	Currency_Symbol
Sk	Modifier_Symbol
So	Other_Symbol
Z	Separator
Zs	Space_Separator
Zl	Line_Separator
Zp	Paragraph_Separator
C	Other
Cc	Control (also cntrl)
Cf	Format
Cs	Surrogate
Co	Private_Use
Cn	Unassigned</code></pre>
</div>
</div>
<div class="paragraph">
<p>举个例子: <code>&lt;:Lu&gt;</code> 匹配单个大写字母。</p>
</div>
<div class="paragraph">
<p>它的反面是这个: <code>&lt;:!property&gt;</code>。所以, <code>&lt;:!Lu&gt;</code> 匹配单个非大写字母的字符。</p>
</div>
<div class="paragraph">
<p>类别可以使用中缀操作符组合在一起:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Operator	Meaning
+	        set union
|	        set union
&amp;	        set intersection
-	        set difference (first minus second)
^	        symmetric set intersection / XOR</code></pre>
</div>
</div>
<div class="paragraph">
<p>要匹配要么一个小写字母,要么一个数字, 可以写 <code>&lt;:Ll+:N&gt;</code> 或 <code>&lt;:Ll+:Number&gt;</code> 或 <code>&lt;+ :Lowercase_Letter + :Number&gt;</code>。</p>
</div>
<div class="paragraph">
<p>使用圆括号将类别和一组类别分组也是可以的; 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'raku' ~~ m{\w+(&lt;:Ll+:N&gt;)}  # OUTPUT: «0 =&gt; ｢6｣␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_可枚举的字符类和区间">61.3.5. 可枚举的字符类和区间</h4>
<div class="paragraph">
<p>有时候, 预先存在的通配符和字符类不够用。幸运的是, 定义你自己的字符类相当简单。在 <code>&lt;[]&gt;</code> 中, 你可以放入任何数量的单个字符和字符区间(两个端点之间有两个点号), 带有或不带有空白。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">"abacabadabacaba" ~~ / &lt;[ a .. c 1 2 3 ]&gt; /;
# Unicode hex codepoint range
"ÀÁÂÃÄÅÆ" ~~ / &lt;[ \x[00C0] .. \x[00C6] ]&gt; /;
# Unicode named codepoint range
"ÀÁÂÃÄÅÆ" ~~ / &lt;[ \c[LATIN CAPITAL LETTER A WITH GRAVE] .. \c[LATIN CAPITAL LETTER AE] ]&gt; /;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>&lt;&gt;</code> 中你可以使用 <code>+</code> 或 <code>-</code> 来添加或移除多个区间定义, 甚至混合某些上面的 unicode 属性。你还可以在 <code>[]</code> 之间写上反斜线形式的字符类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;[\d] - [13579]&gt; /;
# starts with \d and removes odd ASCII digits, but not quite the same as
/ &lt;[02468]&gt; /;
# because the first one also contains "weird" unicodey digits</code></pre>
</div>
</div>
<div class="paragraph">
<p>解析引号分割的字符串的一个常见模式涉及到对字符类取反:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say '"in quotes"' ~~ / '"' &lt;-[ " ]&gt; * '"'/;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这先匹配一个引号, 然后匹配任何不是引号的字符, 再然后还是一个引号。 上面例子中的 <code>*</code> 和 <code>+</code> 会在<a href="https://docs.raku.org/language/regexes#Quantifiers">量词</a>一节中解释。</p>
</div>
<div class="paragraph">
<p>就像你可以使用 <code>-</code> 用于集合差集和取反单个值, 你也可以在前面显式地放上一个 <code>+</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ &lt;+[123]&gt; /  # same as &lt;[123]&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_量词">61.4. 量词</h3>
<div class="paragraph">
<p>量词使前面的原子匹配可变次数。例如, <code>a+</code> 匹配一个或多个字符 <strong>a</strong>。</p>
</div>
<div class="paragraph">
<p>量词比连结绑定的更紧, 所以 <code>ab+</code> 匹配一个 <strong>a</strong>, 然后跟着一个或多个 <strong>b</strong>。对于引号来说, 有点不同, 所以 <code>'ab'+</code> 匹配字符串 <strong>ab</strong>, <strong>abab</strong>, <strong>ababab</strong> 等等。</p>
</div>
<div class="sect3">
<h4 id="_一次_或多次">61.4.1. 一次 或多次 :<br></h4>
<div class="paragraph">
<p><code>+</code> 量词使它前面的原子匹配一次或多次, 没有次数上限。</p>
</div>
<div class="paragraph">
<p>例如, 要匹配 <code>form=value</code> 形式的字符串, 你可以这样写正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ \w+ '=' \w+ /</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_零次_或_多次">61.4.2. 零次 或 多次: *</h4>
<div class="paragraph">
<p><code>*</code> 量词使它前面的原子匹配一次或多次, 没有次数上限。</p>
</div>
<div class="paragraph">
<p>例如, 要允许 <strong>a</strong> 和 <strong>b</strong> 之间出现可选的空白,  你可以这样写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ a \s* b /</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_零次_或_一次匹配">61.4.3. 零次 或 一次匹配: ?</h4>
<div class="paragraph">
<p><code>?</code> 量词使它前面的原子匹配零次或一次。</p>
</div>
</div>
<div class="sect3">
<h4 id="_常规量词_min_max">61.4.4. 常规量词: ** min..max</h4>
<div class="paragraph">
<p>要限定原子匹配任意次数,　你可以写出像 <code>a <strong>* 2..5</code> 那样的表达式来匹配字符 *a</strong> 至少 2 次, 至多 5 次。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so 'a' ~~ /a ** 2..5/;        # OUTPUT: «False␤»
say so  'aaa' ~~ /a ** 2..5/;     # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果最小匹配次数和最大匹配次数相同, 那么使用单个整数: <code>a ** 5</code> 精确地匹配 5 次。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so 'aaaaa' ~~ /a ** 5/;       # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以使用 <code>^</code> 脱字符来排除区间的端点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so 'a'    ~~ /a ** 1^..^6/;   # OUTPUT: «False␤» -- there are 2 to 5 'a's in a row
say so 'aaaa' ~~ /a ** 1^..^6/;   # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面这个包含从 0 开始的数值区间:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so 'aaa' ~~ /a ** ^6/;        # OUTPUT: «True␤» -- there are 0 to 5 'a's in a row</code></pre>
</div>
</div>
<div class="paragraph">
<p>或使用一个 Whatever Star <code>*</code> 操作符来表示无限区间:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so 'aaaa' ~~ /a ** 1^..*/;    # OUTPUT: «True␤» -- there are 2 or more 'a's in a row</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_modified_quantifier">61.4.5. Modified quantifier: %</h4>
<div class="paragraph">
<p>为了更容易地匹配逗号分割那样的值, 你可以在以上任何一个量词后面加上一个 <code>%</code> 修饰符以指定某个修饰符必须出现在每一次匹配之间。例如, <code>a+ % ','</code> 会匹配 <strong>a</strong>, 或 <strong>a,a</strong> 或 <strong>a,a,a</strong> 等等, 但是不会匹配 <strong>a,</strong> 或 <strong>a,a,</strong> 等。要连这些也要匹配, 那么使用 <code>%%</code> 代替 <code>%</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_贪婪量词_vs_非贪婪量词">61.4.6. 贪婪量词 Vs. 非贪婪量词: ?</h4>
<div class="paragraph">
<p>默认地, 量词要求进行贪婪匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'abababa' ~~ /a .* a/ &amp;&amp; say ~$/;   # OUTPUT: «abababa␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以给量词附加一个 <code>?</code> 修饰符来开启非贪婪匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'abababa' ~~ /a .*? a/ &amp;&amp; say ~$/;   # OUTPUT: «aba␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以使用 <code>!</code> 修饰符显式地要求贪婪匹配。</p>
</div>
</div>
<div class="sect3">
<h4 id="_阻止回溯">61.4.7. 阻止回溯: :</h4>
<div class="paragraph">
<p>你可以在正则表达式中通过为量词附加一个 <code>:</code> 修饰符来阻止回溯:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so 'abababa' ~~ /a .* aba/;    # OUTPUT: «True␤»
say so 'abababa' ~~ /a .*: aba/;   # OUTPUT: «False␤»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_alternation">61.5. Alternation: ||</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/regexes#Alternation:_||">||</a> 在正则表达式中表示备选分支, 在匹配由 <code>||</code> 分割的几个可能的备选分支之一时, <strong>第一个</strong>匹配的备选分支胜出。例如, <strong>ini</strong> 文件有如下形式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[section]
key = value</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此, 如果你解析单行 <strong>ini</strong> 文件, 那么它要么是一个 section, 要么是一个键值对儿。所以正则表达式可以是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ '[' \w+ ']' || \S+ \s* '=' \s* \S* /</code></pre>
</div>
</div>
<div class="paragraph">
<p>即, 它要么是一个由方括号包围起来的单词, 要么是一个键值对。</p>
</div>
</div>
<div class="sect2">
<h3 id="_longest_alternation">61.6. Longest Alternation: |</h3>
<div class="paragraph">
<p>如果正则表达式由 <code>|</code> 分割, 则最长的那个匹配胜出。独立于正则表达式中的词法顺序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ('abc' ~~ / a | .b /).Str;    # OUTPUT: «ab␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_anchors">61.7. Anchors</h3>
<div class="paragraph">
<p>正则表达式引擎尝试在字符串中从左至右地搜索来查找匹配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so 'properly' ~~ / perl/;   # OUTPUT: «True␤»
#          ^^^^</code></pre>
</div>
</div>
<div class="paragraph">
<p>有时候这不是你想要的。相反, 你可能只想匹配整个字符串, 或一整行, 或精确地一个或几个完整的单词。锚或断言能帮助我们。</p>
</div>
<div class="paragraph">
<p>为了整个正则表达式能够匹配, 断言需要被成功地匹配但是断言在匹配时不消耗字符。</p>
</div>
<div class="sect3">
<h4 id="_start_of_string_and_end_of_string">61.7.1. ^ , Start of String and $ , End of String</h4>
<div class="paragraph">
<p><code>^</code> 断言只匹配字符串的开头:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so 'properly' ~~ /  perl/;    # OUTPUT: «True␤»
say so 'properly' ~~ /^ perl/;    # OUTPUT: «False␤»
say so 'perly'    ~~ /^ perl/;    # OUTPUT: «True␤»
say so 'perl'     ~~ /^ perl/;    # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$</code> 断言只匹配字符串的结尾:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so 'use perl' ~~ /  perl  /;   # OUTPUT: «True␤»
say so 'use perl' ~~ /  perl $/;   # OUTPUT: «True␤»
say so 'perly'    ~~ /  perl $/;   # OUTPUT: «False␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以把这两个断言组合起来:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so 'use perl' ~~ /^ perl $/;   # OUTPUT: «False␤»
say so 'perl'     ~~ /^ perl $/;   # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>记住, <code>^</code> 匹配<strong>字符串</strong>的开头, 而非<strong>行</strong>的开头。同样地, <code>$</code> 匹配<strong>字符串</strong>的结尾, 而非<strong>行</strong>的结尾。</p>
</div>
<div class="paragraph">
<p>下面的是多行字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = q:to/EOS/;
   Keep it secret
   and keep it safe
   EOS

say so $str ~~ /safe   $/;   # OUTPUT: «True␤»  -- 'safe' is at the end of the string
say so $str ~~ /secret $/;   # OUTPUT: «False␤» -- 'secret' is at the end of a line -- not the string
say so $str ~~ /^Keep   /;   # OUTPUT: «True␤»  -- 'Keep' is at the start of the string
say so $str ~~ /^and    /;   # OUTPUT: «False␤» -- 'and' is at the start of a line -- not the string</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_start_of_line_and_end_of_line">61.7.2. ^^ , Start of Line and $$ , End of Line</h4>
<div class="paragraph">
<p><code>^^</code> 断言匹配逻辑行的开头。即, 要么在字符串的开头, 要么在换行符之后。然而, 它不匹配字符串的结尾, 即使它以一个换行符结尾。</p>
</div>
<div class="paragraph">
<p><code>$$</code> 只匹配逻辑换行符的结尾, 即, 在换行符之前, 或在字符串的结尾, 当最后一个字符不是换行符时。</p>
</div>
<div class="paragraph">
<p>(为了理解下面的示例, 最好先了解 <code>q:to/EOS/&#8230;&#8203;EOS</code> 的 "heredoc" 语法移除了前置的缩进, 使之与 <code>EOS</code> 标记同级, 以至于第一行, 第二行和最后一行没有前置空格而第三行和第四行各有两个前置空格。)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = q:to/EOS/;
    There was a young man of Japan
    Whose limericks never would scan.
      When asked why this was,
      He replied "It's because
    I always try to fit as many syllables into the last line as ever I possibly can."
    EOS

say so $str ~~ /^^ There/;        # OUTPUT: «True␤»  -- start of string
say so $str ~~ /^^ limericks/;    # OUTPUT: «False␤» -- not at the start of a line
say so $str ~~ /^^ I/;            # OUTPUT: «True␤»  -- start of the last line
say so $str ~~ /^^ When/;         # OUTPUT: «False␤» -- there are blanks between
                                  #                       start of line and the "When"

say so $str ~~ / Japan $$/;       # OUTPUT: «True␤»  -- end of first line
say so $str ~~ / scan $$/;        # OUTPUT: «False␤» -- there's a . between "scan"
                                  #                      and the end of line
say so $str ~~ / '."' $$/;        # OUTPUT: «True␤»  -- at the last line</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_w_and_w_word_boundary">61.7.3. &lt;|w&gt; and &lt;!|w&gt;, word boundary</h4>
<div class="paragraph">
<p>要匹配单词边界, 使用 <code>&lt;|w&gt;</code>。这与其它语言的 <code>\b</code> 类似，要匹配一个非单词边界, 使用 <code>&lt;!|w&gt;</code>, 类似其它语言的 <code>\B</code>。这些都是零宽断言。</p>
</div>
</div>
<div class="sect3">
<h4 id="_and_left_and_right_word_boundary">61.7.4. &lt;&lt; and &gt;&gt; , left and right word boundary</h4>
<div class="paragraph">
<p><code>&lt;&lt;</code> 匹配左单词边界。它匹配左侧(或者字符串的开头)是非单词字符而右侧是一个单词字符的位置。</p>
</div>
<div class="paragraph">
<p><code>&gt;&gt;</code> 匹配右单词边界。它匹配左侧有一个单词字符而右侧(或者字符串的结尾)是一个非单词字符的位置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = 'The quick brown fox';
say so $str ~~ /br/;              # OUTPUT: «True␤»
say so $str ~~ /&lt;&lt; br/;           # OUTPUT: «True␤»
say so $str ~~ /br &gt;&gt;/;           # OUTPUT: «False␤»
say so $str ~~ /own/;             # OUTPUT: «True␤»
say so $str ~~ /&lt;&lt; own/;          # OUTPUT: «False␤»
say so $str ~~ /own &gt;&gt;/;          # OUTPUT: «True␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用变体 <strong>«</strong> 和 <strong>»</strong> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = 'The quick brown fox';
say so $str ~~ /« own/;          # OUTPUT: «False␤»
say so $str ~~ /own »/;          # OUTPUT: «True␤»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_分组和捕获">61.8. 分组和捕获</h3>
<div class="paragraph">
<p>在普通的(非正则表达式)Raku 代码中, 你可以使用圆括号把东西组织到一块, 通常用于覆盖操作符优先级:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 1+4*2;   # 9, parsed as 1 + (4*2)
say (1+4)*2; # 输出: 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>在正则表达式中也可以使用同样的分组工具:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ a || b c/;   # 匹配 'a' 或 'bc'
/ (a || b) c/; # 匹配 'ac' 或 'bc'</code></pre>
</div>
</div>
<div class="paragraph">
<p>分组可以应用在量词上:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ a b+ /;      # 匹配一个 'a', 后面再跟着一个或多个 'b'
/ (a b)+/;     # 匹配一个或多个 'ab' 序列
/ (a || b)+ /; # 匹配一个 'a' 序列或者 'b' 序列, 至少一次</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个非量词化的捕获产生一个 <a href="https://docs.raku.org/type/Match">Match</a>对象。当捕获被量化(除了使用 ? 量词)之后, 该捕获就变成 <a href="https://docs.raku.org/type/Match">Match</a>对象的列表。</p>
</div>
<div class="sect3">
<h4 id="_捕获_2">61.8.1. 捕获</h4>
<div class="paragraph">
<p>圆括号不仅仅能够分组, 它们也*捕获*; 也就是说, 它们使分组中匹配到的字符串用作变量，并且还作为生成的 <a href="https://docs.raku.org/type/Match">Match</a> 对象的元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $str = 'number 42';
if $str ~~ /'number' (\d+) / {
    say "The number is $0";    # The number is 42
    # or
    say "The number is $/[0]"; # The number is 42
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>圆括号对儿是从左到右编号的, 编号从零开始。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 'abc' ~~ /(a) b (c)/ {
    say "0:$0; 1:$1"; # 输出: 0:a; 1:c
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$0</code> 和 <code>$1</code> 等语法是简写的。这些捕获可以从用作列表的匹配对象 <code>$/</code> 中规范地获取到, 所以, <code>$0</code> 实际上是 <code>$/[0]</code> 的语法糖。</p>
</div>
<div class="paragraph">
<p>将匹配对象强制转换为列表可以方便地以编程方式访问所有元素:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 'abc' ~~ /(a) b (c)/ {
    say $/.list.join: ','; # 输出 a,c
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_非捕获分组">61.8.2. 非捕获分组</h4>
<div class="paragraph">
<p>正则表达式中的圆括号扮演了双重角色: 它们将内部的正则表达式元素分组, 并通过内部的子正则表达式捕获所匹配到的内容。</p>
</div>
<div class="paragraph">
<p>要仅仅获得分组行为, 可以使用方括号 <code>[&#8230;&#8203;]</code> 代替圆括号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 'abc' ~~ / [a||b] (c) / {
    say ~$0;                # OUTPUT: «c␤»
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您不需要捕获, 则使用非捕获分组可提供三个好处: 它们更干净地传达正则表达式; 它们使您更容易对您关心的捕获组计数; 并且它匹配比较快。</p>
</div>
</div>
<div class="sect3">
<h4 id="_捕获编号">61.8.3. 捕获编号</h4>
<div class="paragraph">
<p>上面已经说明，捕获从左到右编号。 原则上是真的，这也是过于简单的。</p>
</div>
<div class="paragraph">
<p>为了完整起见，列出了以下规则。 当您发现自己经常使用它们时，考虑命名捕获（可能是 subrules）是值得的。</p>
</div>
<div class="paragraph">
<p>备选分支会重置捕获计数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ (x) (y)  || (a) (.) (.) /
# $0  $1      $0  $1  $2</code></pre>
</div>
</div>
<div class="paragraph">
<p>例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 'abc' ~~ /(x)(y) || (a)(.)(.)/ {
    say ~$1;            # b
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果两个（或多个）备选分支具有不同的捕获编号，则捕获编号最多的决定了下一个捕获的索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = 'abcd';

if / a [ b (.) || (x) (y) ] (.) / {
    #      $0     $0  $1    $2
    say ~$2;           # d
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>捕获可以嵌套，在这种情况下，它们的每一级都会编号:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 'abc' ~~ / ( a (.) (.) ) / {
    say "Outer: $0";                # Outer: abc
    say "Inner: $0[0] and $0[1]";   # Inner: b and c
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_命名捕获_2">61.8.4. 命名捕获</h4>
<div class="paragraph">
<p>除了给捕获编号，你也可以给他们起名字。 命名捕获的通用和略微冗长的方式是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 'abc' ~~ / $&lt;myname&gt; = [ \w+ ] / {
    say ~$&lt;myname&gt;      # OUTPUT: «abc␤»
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对命名捕获 <strong>$&lt;myname&gt;</strong> 的访问是将匹配对象作为哈希索引的简写，换句话说：<code>$/{'myname'}</code> 或 <code>$/&lt;myname&gt;</code>。</p>
</div>
<div class="paragraph">
<p>命名捕获也可以使用常规捕获分组语法进行嵌套:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 'abc-abc-abc' ~~ / $&lt;string&gt;=( [ $&lt;part&gt;=[abc] ]* % '-' ) / {
    say ~$&lt;string&gt;;         # OUTPUT: «abc-abc-abc␤»
    say ~$&lt;string&gt;&lt;part&gt;;   # OUTPUT: «[abc, abc, abc]␤»
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>将匹配对象强制为散列可让您轻松地以编程方式访问所有命名捕获:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if 'count=23' ~~ / $&lt;variable&gt;=\w+ '=' $&lt;value&gt;=\w+ / {
    my %h = $/.hash;
    say %h.keys.sort.join: ', ';        # OUTPUT: «value, variable␤»
    say %h.values.sort.join: ', ';      # OUTPUT: «23, count␤»

    for %h.kv -&gt; $k, $v {
        say "Found value '$v' with key '$k'";
        # outputs two lines:
        #   Found value 'count' with key 'variable'
        #   Found value '23' with key 'value'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Subrules 部分会讨论获取命名捕获的更方便的方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_capture_markers">61.8.5. Capture markers: &lt;( )&gt;</h4>
<div class="paragraph">
<p><code>&lt;(</code> token 表示匹配的整体捕捉的开始，而相应的 <code>)&gt;</code> token 表示其末端。 <code>&lt;(</code> 类似于其他语言的 <code>\K</code> 丢弃 <code>\K</code> 之前找到的任何匹配项。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_替换">61.9. 替换</h3>
<div class="paragraph">
<p>正则表达式也可以用来替换另一个文本。 您可以使用它来解决拼写错误(例如, 用 "Pearl Jam" 替换 "Perl Jam"), 从 <code>yyyy-mm-ddThh:mm:ssZ</code> 到 <code>mm-dd-yy h:m {AM,PM}</code> 重新格式化 ISO8601 日期及其它。</p>
</div>
<div class="paragraph">
<p>就像搜索替换编辑器的对话框一样，<code>s///</code> 操作符有两面，左侧和右侧。 左侧是匹配表达式的位置，右侧是您要替换的表达式。</p>
</div>
<div class="sect3">
<h4 id="_词汇约定">61.9.1. 词汇约定</h4>
<div class="paragraph">
<p>替换和匹配的写法类似，但替换运算符既有正则表达式匹配的区域，也有替换的文本区域：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">s/replace/with/;           # a substitution that is applied to $_
$str ~~ s/replace/with/;   # a substitution applied to a scalar</code></pre>
</div>
</div>
<div class="paragraph">
<p>替换操作法允许除了斜线之外的分隔符:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">s|replace|with|;
s!replace!with!;
s,replace,with,;</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意, 冒号和诸如 <code>{}</code> 或 <code>()</code> 的分隔符不能作为替换分割符。带有副词的冒号斜线诸如 <code>s:i/Foo/Bar</code> 和其它分割符有其它用途。</p>
</div>
<div class="paragraph">
<p>就像 <code>m//</code> 操作符一样, 通常会忽略空白。在 Raku 中, 注释以 <strong>#</strong> 号开头直到当前行的结尾。</p>
</div>
</div>
<div class="sect3">
<h4 id="_替换字符串字面值">61.9.2. 替换字符串字面值</h4>
<div class="paragraph">
<p>要替换的最简单的东西就是字符串字面量。你要替换的字符串在替换运算符的左侧, 而替换它的字符串在替换操作符的右侧; 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = 'The Replacements';
s/Replace/Entrap/;
.say;                    # OUTPUT: «The Entrapments␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>字母数字字符和下划线是文字匹配，就像其表哥 <code>m//</code> 操作符一样。 所有其他字符都必须使用反斜杠`\`转义，或包含在引号中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = 'Space: 1999';
s/Space\:/Party like it's/;
.say                        # OUTPUT: «Party like it's 1999␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，匹配约束仅适用于替换表达式的左侧。</p>
</div>
<div class="paragraph">
<p>默认情况下，替换仅在第一匹配中完成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = 'There can be twly two';
s/tw/on/;                     # replace 'tw' with 'on' once
.say;                         # OUTPUT: «there can be only two␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_通配符和字符类_2">61.9.3. 通配符和字符类</h4>
<div class="paragraph">
<p>任何可以进入 <code>m//</code> 操作符的内容都可以进入替换操作符的左侧，包括通配符和字符类。 当您匹配的文本不是静态的时，这很方便，例如尝试匹配字符串中间的数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = "Blake's 9";
s/\d+/7/;         # replace any sequence of digits with '7'
.say;             # OUTPUT: «Blake's 7␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，你可以使用任何`+<code>，</code>*<code>和</code>?` 修饰符，它们的行为就像在 <code>m//</code> 操作符的上下文中一样。</p>
</div>
</div>
<div class="sect3">
<h4 id="_捕获组">61.9.4. 捕获组</h4>
<div class="paragraph">
<p>就像在匹配运算符中一样，捕获组在左侧被允许，匹配的内容填充 <code>$0..$n</code> 变量和 <code>$/</code> 对象：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = '2016-01-23 18:09:00';
s/ (\d+)\-(\d+)\-(\d+) /today/;   # replace YYYY-MM-DD with 'today'
.say;                             # OUTPUT: «today 18:09:00␤»
"$1-$2-$0".say;                   # OUTPUT: «01-23-2016␤»
"$/[1]-$/[2]-$/[0]".say;          # OUTPUT: «01-23-2016␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>任何这些变量 <code>$0</code>，<code>$1</code>，<code>$/</code> 也可以在运算符的右侧使用，所以你可以操纵你刚刚匹配的内容。 这样，您可以将日期的YYYY，MM和DD部分分开，并将其重新格式化为 <code>MM-DD-YYYY</code> 顺序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = '2016-01-23 18:09:00';
s/ (\d+)\-(\d+)\-(\d+) /$1-$2-$0/;    # transform YYYY-MM-DD to MM-DD-YYYY
.say;                                 # OUTPUT: «01-23-2016 18:09:00␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于右侧实际上是一个常规的 Raku 内插字符串，因此可以将时间从 <code>HH:MM</code> 重新格式化为 `h:MM {AM,PM} 格式, 如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$_ = '18:38';
s/(\d+)\:(\d+)/{$0 % 12}\:$1 {$0 &lt; 12 ?? 'AM' !! 'PM'}/;
.say;                                                    # OUTPUT: «6:38 PM␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用上面的模数 <code>%</code> 运算符将样本代码保留在80个字符以下，否则就是 <code>$0 &lt;12 ?? $0 !! $0 - 12</code>。 结合解析器表达式语法的强大功能，真正使您在这里看到的内容成为可能，您可以使用“正则表达式”来解析任何文本。</p>
</div>
</div>
<div class="sect3">
<h4 id="_common_adverbs">61.9.5. Common adverbs</h4>

</div>
</div>
<div class="sect2">
<h3 id="_tilde_for_nesting_structures">61.10. Tilde for nesting structures</h3>
<div class="paragraph">
<p><code>~</code> 运算符是一个帮助器，用于匹配具有特定终结符的嵌套子规则作为目标。 它被设计为放置在开口和闭合括号之间，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ '(' ~ ')' &lt;expression&gt; /</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而, 它主要忽略左侧的参数, 并且在接下来的两个原子（可以被量化）上操作。 它对下两个原子的操作是“旋转”它们，使得它们实际上以相反的顺序匹配。 因此，上面的表达式，起初是腮红，只不过是下面的简写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ '(' &lt;expression&gt; ')' /</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是除此之外，当它重写原子时，它还会插入将设置内部表达式以识别终止符的设备，并且如果内部表达式不在所需的闭合原子上终止，则产生适当的错误消息。 所以它确实也注意了左边的括号，它实际上把我们的例子改写成更像:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$&lt;OPEN&gt; = '(' &lt;SETGOAL: ')'&gt; &lt;expression&gt; [ $GOAL || &lt;FAILGOAL&gt; ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>FAILGOAL 是一种可以由用户定义的特殊方法，它将在解析失败时被调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar A { token TOP { '[' ~ ']' \w+  };
            method FAILGOAL($goal) {
                die "Cannot find $goal near position {self.pos}"
            }
}

A.parse: '[good]';  # OUTPUT: «｢[good]｣␤»
A.parse: '[bad';    # will throw FAILGOAL exception
CATCH { default { put .^name, ': ', .Str } };
# OUTPUT: «X::AdHoc: Cannot find ']'  near position 5␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，即使没有开头括号，也可以使用此构造来设置闭合结构的期望值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">"3)"  ~~ / &lt;?&gt; ~ ')' \d+ /;  # RESULT: «｢3)｣»
"(3)" ~~ / &lt;?&gt; ~ ')' \d+ /;  # RESULT: «｢3)｣»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里 <code>&lt;?&gt;</code> 在第一个空字符串中返回true。</p>
</div>
<div class="paragraph">
<p>正则表达式捕获的顺序是原始的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">"abc" ~~ /a ~ (c) (b)/;
say $0; # OUTPUT: «｢c｣␤»
say $1; # OUTPUT: «｢b｣␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_subrules">61.11. Subrules</h3>
<div class="paragraph">
<p>就像你可以把代码片段放进子例程中一样, 你同样可以把正则表达式片段放进命名规则中(named rules)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex line { \N*\n }
if "abc\ndef" ~~ /&lt;line&gt; def/ {
    say "First line:", $&lt;line&gt;.chomp; # OUTPUT:«First line: abc␤»
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>命名正则可以使用 <code>my regex_name { body here }</code> 来声明, 并使用 <code>&lt;regex_name&gt;</code> 来调用。与此同时, 调用命名正则的时候会安装一个同名的命名捕获。</p>
</div>
<div class="paragraph">
<p>要给捕获起一个和 regex 不同的名字, 那么使用 <code>&lt;capture_name=regex_name&gt;</code> 语法。如果不想捕获, 那么使用一个前置的点号来抑制捕获: <code>&lt;.regex_name&gt;</code>。</p>
</div>
<div class="paragraph">
<p>下面是一个更完善的解析 ini 文件的例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex header { \s* '[' (\w+) ']' \h* \n+ }
my regex identifier  { \w+ }
my regex kvpair { \s* &lt;key=identifier&gt; '=' &lt;value=identifier&gt; \n+ }
my regex section {
    &lt;header&gt;
    &lt;kvpair&gt;*
}

my $contents = q:to/EOI/;
    [passwords]
        jack=password1
        joy=muchmoresecure123
    [quotas]
        jack=123
        joy=42
EOI

my %config;
if $contents ~~ /&lt;section&gt;*/ {
    for $&lt;section&gt;.list -&gt; $section {
        my %section;
        for $section&lt;kvpair&gt;.list -&gt; $p {
            say $p&lt;value&gt;;
            %section{ $p&lt;key&gt; } = ~$p&lt;value&gt;;
        }
        %config{ $section&lt;header&gt;[0] } = %section;
    }
}
say %config.perl;
# OUTPUT: «("passwords" =&gt; {"jack" =&gt; "password1", "joy" =&gt; "muchmoresecure123"},␤
#          "quotas" =&gt; {"jack" =&gt; "123", "joy" =&gt; "42"}).hash»</code></pre>
</div>
</div>
<div class="paragraph">
<p>命名正则可以规整到 <a href="https://docs.raku.org/language/grammars">gramamrs</a> 中。<a href="https://design.raku.org/S05.html#Predefined_Subrules">S05</a>中有一组预定义的 subrules。</p>
</div>
</div>
<div class="sect2">
<h3 id="_副词_2">61.12. 副词</h3>
<div class="paragraph">
<p>副词修改正则表达式的工作方式, 并为某些类型的循环任务提供方便的快捷方式。</p>
</div>
<div class="paragraph">
<p>有两种副词: 正则表达式副词适用于定义正则表达式时, 匹配副词适用于正则表达式与字符串匹配时。</p>
</div>
<div class="paragraph">
<p>这种区别往往是模糊的, 因为匹配和声明通常是文本上关闭的, 但使用方法形式的匹配使得区分清晰一点。</p>
</div>
<div class="paragraph">
<p><code>'abc' ~~ /../</code> 大致相当于 <code>'abc'.match(/../)</code>, 甚至可以更清楚地单独写成一行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $regex = /../;           # definition
if 'abc'.match($regex) {    # matching
    say "'abc' has at least two characters";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>正则表达式副词像 <code>:i</code> 会进入定义行而匹配副词像 <code>:overlap</code> 会附加到匹配调用上:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $regex = /:i . a/;
for 'baA'.match($regex, :overlap) -&gt; $m {
    say ~$m;
}
# OUTPUT: «ba␤aA␤»</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_regex_adverbs">61.12.1. Regex Adverbs</h4>
<div class="paragraph">
<p>在正则表达式声明时出现的副词是实际正则表达式的一部分, 并影响 Raku 编译器如何将正则表达式转换为二进制代码。</p>
</div>
<div class="paragraph">
<p>例如: <code>:ignorecase (:i)</code> 副词告诉编译器忽略大写, 小写和标题大小写字母之间的区别。</p>
</div>
<div class="paragraph">
<p>所以 <code>'a'~~ /A/</code> 是假的, 但 &#8217;a' ~~ /:i A /是一个成功的匹配。</p>
</div>
<div class="paragraph">
<p>正则表达式副词可以在正则表达式声明之前或之内, 并且仅在词法上影响其后的正则表达式部分。 请注意, 在正则表达式之前出现的正则表达式副词必须出现在将正则表达式引入解析器之后, 如 'rx' 或 'm' 或裸的 '/'。 但是这样是无效的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $rx1 = :i/a/;      # adverb is before the regex is recognized =&gt; exception</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面这些是等价的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $rx1 = rx:i/a/;      # before
my $rx2 = rx/:i a/;     # inside</code></pre>
</div>
</div>
<div class="paragraph">
<p>而下面这两种是不等价的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $rx3 = rx/a :i b/;   # matches only the b case insensitively
my $rx4 = rx/:i a b/;   # matches completely case insensitively</code></pre>
</div>
</div>
<div class="paragraph">
<p>方括号和圆括号约束副词的作用域:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/ (:i a b) c /;         # matches 'ABc' but not 'ABC'
/ [:i a b] c /;         # matches 'ABc' but not 'ABC'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ratchet">61.12.2. Ratchet</h4>
<div class="paragraph">
<p><code>:ratchet</code> 或 <code>:r</code> 副词会导致正则表达式引擎不回溯。</p>
</div>
<div class="paragraph">
<p>假如没有这个副词, 那么正则表达式的一部分将尝试不同的路径来匹配字符串, 以使正则表达式的其他部分可以匹配。 例如, 在 <code>'abc' ~~ / \w+ ./</code> 中, <code>\w+</code> 首先吃光整个字符串 abc, 然后 <code>.</code> 就失败了。 因此 <code>\w+</code> 放弃一个字符, 只匹配 ab 而 <code>.</code> 可以成功匹配字符串 c。 放弃字符的过程(或在轮试的情况下, 尝试不同的分支)被称为回溯。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so 'abc' ~~ / \w+ . /;        # OUTPUT: «True␤»
say so 'abc' ~~ / :r \w+ . /;     # OUTPUT: «False␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ratcheting 是一种优化, 因为回溯是昂贵的。 但更重要的是, 它与人类解析文本的方式密切相关。 如果你有一个正则表达式 <code>my regex identifier { \w+ } ` 和 `my regex keyword { if | else | endif }</code>, 你直观地期望 <code>identifier</code> 吞噬整个单词，而不是放弃结束下一个规则，如果下一个 rule 失败时。</p>
</div>
<div class="paragraph">
<p>例如，你不想让单词 <code>motif</code> 被解析为标识符 mot 后面跟着关键字 if。 相反, 你想将 <code>motif</code> 解析为标识符; 并且如果解析器期望之后有一个 <code>if</code>, 那么最好让它失败, 而不是以你不期望的方式解析输入。</p>
</div>
<div class="paragraph">
<p>由于 ratcheting 行为在解析器中通常是需要的, 所以有一个快捷方式来声明一个 ratcheting 正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my token thing { .... }
# short for
my regex thing { :r ... }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sigspace">61.12.3. Sigspace</h4>
<div class="paragraph">
<p><code>:sigspace</code> 或 <code>:s</code> 副词使空白在正则表达式中有意义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say so "I used Photoshop®"   ~~ m:i/   photo shop /;      # OUTPUT: «True␤»
say so "I used a photo shop" ~~ m:i:s/ photo shop /;   # OUTPUT: «True␤»
say so "I used Photoshop®"   ~~ m:i:s/ photo shop /;   # OUTPUT: «False␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>m:s/ photo shop /</code> 的作用和 <code>m/ photo &lt;.ws&gt; shop &lt;.ws&gt; /</code> 一样。默认地, <code>&lt;.ws&gt;</code> 确保单词是分开的, 所以 <code>a b</code> 和 <code>^$</code> 会匹配中间的 <code>&lt;.ws&gt;</code>, 但是 <code>ab</code> 不会。</p>
</div>
<div class="paragraph">
<p>正则表达式中哪里的空白会被转换为 <code>&lt;.ws&gt;</code> 取决于空白前面是什么。在上面的例子中, 正则表达式开头的空白不会被转换为 <code>&lt;.ws&gt;</code>, 但是字符后面的空白会被转换为 <code>&lt;.ws&gt;</code>。通常, 规则就是, 如果某一项可能匹配某个东西, 那么它后面的空白会被转换为 <code>&lt;.ws&gt;</code>。</p>
</div>
<div class="paragraph">
<p>此外, 如果空白跟在某个 term 之后, 量词(,* 或 ?)之前, 那么 `&lt;.ws&gt;` 会在每次 term 匹配后匹配。 所以, `foo +` 变为 `[foo &lt;.ws&gt;]<code>。另一方面, 量词后面的空白和普通的空白作用一样; 例如: "foo+" 变为 `foo+&lt;.ws&gt;</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_matching_adverbs">61.12.4. Matching adverbs</h4>
<div class="paragraph">
<p>和正则表达式副词对比, 其与正则表达式声明有关, 匹配副词只有在将字符串与正则表达式匹配时才有意义。</p>
</div>
<div class="paragraph">
<p>它们永远不会出现在正则表达式内部, 只能在外部 - 作为 <code>m/&#8230;&#8203;/</code> 匹配的一部分或作为匹配方法的参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="_continue_2">61.12.5. Continue</h4>
<div class="paragraph">
<p><code>:continue</code> 或短的 <code>:c</code> 副词接收一个参数。 这个参数是正则表达式开始搜索的位置。 默认情况下, 它从字符串的开头搜索, 但是 <code>:c</code> 覆盖该位置。 如果没有为 <code>:c</code> 指定位置, 它将默认为 0, 除非设置了 <code>$/</code>, 在这种情况下, 它默认为 <code>$/.to</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given 'a1xa2' {
    say ~m/a./;         # OUTPUT: «a1␤»
    say ~m:c(2)/a./;    # OUTPUT: «a2␤»
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意: 不同于 <code>:pos</code>, 使用 <code>:continue()</code> 的匹配将尝试在字符串中进一步匹配, 而不是马上失败:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "abcdefg" ~~ m:c(3)/e.+/; # OUTPUT: «｢efg｣␤»
say "abcdefg" ~~ m:p(3)/e.+/; # OUTPUT: «False␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exhaustive">61.12.6. Exhaustive</h4>
<div class="paragraph">
<p>要找到正则表达式的所有可能的匹配 - 包括重叠的 - 和几个从同一位置开始的匹配, 请使用 <code>:exhaustive</code>(short: <code>ex</code>) 副词。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given 'abracadabra' {
    for m:exhaustive/ a .* a / -&gt; $match {
        say ' ' x $match.from, ~$match;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码产生这样的输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">abracadabra
abracada
abraca
abra
   acadabra
   acada
   aca
     adabra
     ada
       abra</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_global">61.12.7. Global</h4>
<div class="paragraph">
<p>不是搜索一个匹配并返回一个 <a href="https://docs.raku.org/type/Match">Match 对象</a>, Global 搜索每个不重叠的匹配, 并将其返回到<a href="https://docs.raku.org/type/List">列表</a>中。 为此, 请使用 <code>:global</code> 副词:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given 'several words here' {
    my @matches = m:global/\w+/;
    say @matches.elems;         # OUTPUT: «3␤»
    say ~@matches[2];           # OUTPUT: «here␤»
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:g</code> 是 <code>:global</code> 的简写。</p>
</div>
</div>
<div class="sect3">
<h4 id="_pos">61.12.8. Pos</h4>
<div class="paragraph">
<p>在字符串的特定位置锚定匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given 'abcdef' {
    my $match = m:pos(2)/.*/;
    say $match.from;        # OUTPUT: «2␤»
    say ~$match;            # OUTPUT: «cdef␤»
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:p</code> 是 <code>:pos</code> 的简写。</p>
</div>
<div class="paragraph">
<p>注意: 不同于 <code>:continue</code>, 使用 <code>:pos()</code> 锚定的匹配在不匹配时将立即失败, 而不是尝试进一步匹配字符串:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "abcdefg" ~~ m:c(3)/e.+/; # OUTPUT: «｢efg｣␤»
say "abcdefg" ~~ m:p(3)/e.+/; # OUTPUT: «False␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_overlap">61.12.9. Overlap</h4>
<div class="paragraph">
<p>要获得多个匹配, 包括重叠的匹配, 但每个起始位置只有一个(最长的)匹配, 请指定 <code>:overlap</code> (short <code>:ov</code>) 副词:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">given 'abracadabra' {
    for m:overlap/ a .* a / -&gt; $match {
        say ' ' x $match.from, ~$match;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>产生:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">abracadabra
   acadabra
     adabra
       abra</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_look_around_assertions">61.13. Look-around assertions</h3>
<div class="sect3">
<h4 id="_lookahead_assertions">61.13.1. Lookahead assertions</h4>
<div class="paragraph">
<p>要检查一个模式是否出现在另一个模式之前，请通过 <code>before</code> 断言使用 lookahead 断言。形式如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;?before pattern&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，要搜索字符串 foo 后面紧跟着字符串 bar, 请使用以下 regexp:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rx{ foo &lt;?before bar&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "foobar" ~~ rx{ foo &lt;?before bar&gt; };   # OUTPUT: «foo␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果要搜索一个不紧随某个模式的模式, 那么您需要使用反向向前查看断言, 其形式如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;!before pattern&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，所有出现的不在 bar 之前的 foo 都会匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rx{ foo &lt;!before bar&gt; }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_lookbehind_assertions">61.13.2. Lookbehind assertions</h4>
<div class="paragraph">
<p>要检查一个模式是否出现在另一个模式之后，请通过 <code>after</code> 断言使用 <code>lookbehind</code> 断言。 其形式如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;?after pattern&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此, 要搜索字符串 foo 立即跟着的 bar 字符串, 使用如下正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rx{ &lt;?after foo&gt; bar } # read as after foo is bar</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "foobar" ~~ rx{ &lt;?after foo&gt; bar }; #  OUTPUT: «bar␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是, 如果要搜索的模式不是紧随其后的模式, 那么您需要使用反向的 lookbehind 断言, 其形式如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;!after pattern&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此, bar 前面不是 foo 的所有 bar 将被匹配:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">rx{ &lt;!after foo&gt; bar }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_best_practices_and_gotchas">61.14. Best practices and gotchas</h3>
<div class="paragraph">
<p>为了帮助强大的正则表达式和 Grammar, 以下是代码布局和可读性的最佳实践，实际匹配的内容，并避免常见的陷阱。</p>
</div>
<div class="sect3">
<h4 id="_code_layout">61.14.1. Code layout</h4>
<div class="paragraph">
<p>没有 <code>:sigspace</code> 副词, 空白在 Raku 正则表达式中就是没有意义的。 在能增加可读性的地方插入空格。 此外, 必要时插入注释。</p>
</div>
<div class="paragraph">
<p>比较下面这个比较紧凑的正则表达式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex float { &lt;[+-]&gt;?\d*'.'\d+[e&lt;[+-]&gt;?\d+]? }</code></pre>
</div>
</div>
<div class="paragraph">
<p>和可读性更好的版本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex float {
     &lt;[+-]&gt;?        # optional sign
     \d*            # leading digits, optional
     '.'
     \d+
     [              # optional exponent
        e &lt;[+-]&gt;?  \d+
     ]?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据经验，在原子周围和分组内部使用空格; 将量词直接置于原子之后; 并垂直对齐开口和闭合方括号和圆括号。</p>
</div>
<div class="paragraph">
<p>当你在方括号或圆括号中使用一组备选分支时, 请对齐垂直条:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex example {
    &lt;preamble&gt;
    [
    || &lt;choice_1&gt;
    || &lt;choice_2&gt;
    || &lt;choice_3&gt;
    ]+
    &lt;postamble&gt;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_keep_it_small">61.14.2. Keep it small</h4>
<div class="paragraph">
<p>正则表达式通常比常规代码更紧凑。 因为他们短小精悍, 保持正则表达式很短。</p>
</div>
<div class="paragraph">
<p>当你可以命名正则表达式的一部分时, 通常最好将其放入单独的命名正则表达式中。</p>
</div>
<div class="paragraph">
<p>例如, 您可以从前面获取 float 正则表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex float {
     &lt;[+-]&gt;?        # optional sign
     \d*            # leading digits, optional
     '.'
     \d+
     [              # optional exponent
        e &lt;[+-]&gt;?  \d+
     ]?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并把它分解成几部分:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my token sign { &lt;[+-]&gt; }
my token decimal { \d+ }
my token exponent { 'e' &lt;sign&gt;? &lt;decimal&gt; }
my regex float {
    &lt;sign&gt;?
    &lt;decimal&gt;?
    '.'
    &lt;decimal&gt;
    &lt;exponent&gt;?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这很有用, 特别是当正则表达式变得更加复杂时。 例如, 你可能希望在存在指数的情况下使小数点可选。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex float {
    &lt;sign&gt;?
    [
    || &lt;decimal&gt;?  '.' &lt;decimal&gt; &lt;exponent&gt;?
    || &lt;decimal&gt; &lt;exponent&gt;
    ]
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_what_to_match">61.14.3. What to match</h4>
<div class="paragraph">
<p>通常，输入数据格式没有明确的规范，或规范对编程人员来说是未知的。 那么，在你期望的时候是自由的，只要没有可能的含糊不清就行了。</p>
</div>
<div class="paragraph">
<p>例如，在 ini 文件中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[section]
key=value</code></pre>
</div>
</div>
<div class="paragraph">
<p>什么可以在 section 标题内? 只允许一个单词可能太限制了。 有人会写 <code>[two words]</code>, 或用破折号等等。 而不是询问内部允许的内容, 可能这样问比较好: 什么是不允许的？</p>
</div>
<div class="paragraph">
<p>显然, 不允许使用括号，因为 <code>[a] b]</code> 是不明确的。 同样的论据, 应禁止开口方括号。 这让我们有了</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token header { '[' &lt;-[ \[\] ]&gt;+ ']' }</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你只处理一行就行了。 但是，如果你正在处理整个文件，突然间正则表达式解析到一句</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[with a
newline in between]</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可能不是一个好方法。折中的方式是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token header { '[' &lt;-[ \[\] \n ]&gt;+ ']' }</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后在扫尾处理中, 从 section 标题中移除前导和尾部空格和制表符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_matching_whitespace">61.14.4. Matching Whitespace</h4>
<div class="paragraph">
<p><code>:sigspace</code> 副词(或使用 <code>rule</code> 声明符, 而不是 <code>token</code> 或 <code>regex</code>) 非常适用于隐式解析许多地方可能出现的空格。</p>
</div>
<div class="paragraph">
<p>回到解析 ini 文件的例子, 我们有</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex kvpair { \s* &lt;key=identifier&gt; '=' &lt;value=identifier&gt; \n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可能不像我们想要的那样自由, 因为用户可能会在等号周围放置空格。 那么我们可以试试这个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my regex kvpair { \s* &lt;key=identifier&gt; \s* '=' \s* &lt;value=identifier&gt; \n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>但这看起来很笨重, 所以我们尝试其他方式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my rule kvpair { &lt;key=identifier&gt; '=' &lt;value=identifier&gt; \n+ }</code></pre>
</div>
</div>
<div class="paragraph">
<p>可是等等! <code>value</code> 之后，隐含的空白匹配用光了所有的空白, 包括换行符, 所以 <code>\n+</code> 没有什么可以匹配的(rule 也禁止回溯, 所以运气不佳)。</p>
</div>
<div class="paragraph">
<p>因此, 重要的是将隐式空白的定义重新定义为输入格式无意义的空白。</p>
</div>
<div class="paragraph">
<p>这通过重新定义 token <code>ws</code>; 但是，它只适用于 <a href="https://docs.raku.org/language/grammars">Grammars</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar IniFormat {
    token ws { &lt;!ww&gt; \h* }
    rule header { \s* '[' (\w+) ']' \n+ }
    token identifier  { \w+ }
    rule kvpair { \s* &lt;key=identifier&gt; '=' &lt;value=identifier&gt; \n+ }
    token section {
        &lt;header&gt;
        &lt;kvpair&gt;*
    }

    token TOP {
        &lt;section&gt;*
    }
}

my $contents = q:to/EOI/;
    [passwords]
        jack = password1
        joy = muchmoresecure123
    [quotas]
        jack = 123
        joy = 42
EOI
say so IniFormat.parse($contents);</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了把所有的正则表达式都放在一个 Grammar 中并把它们变成了 tokens(因为他们不需要回溯) 之外, 有趣的新花样是:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">token ws { &lt;!ww&gt; \h* }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这被称为隐式空白解析。 当它不在两个字符之间 (<code>&lt;ww&gt;</code>, 反向的"within word" 断言)时匹配, 以及零个或多个水平空格字符。 对水平空白的限制很重要, 因为换行符(它们是垂直空白)定界记录, 不应该被隐式地匹配。</p>
</div>
<div class="paragraph">
<p>还有一些与空白有关的麻烦潜伏着。 正则表达式 <code>\n+</code> 将不会匹配 <code>\n \n</code> 这样的字符串, 因为两个换行符之间有空白。 要允许这样的输入字符串, 用 <code>\n\s*</code> 代替 <code>\n+</code>。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_控制例程">62. 控制例程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>关于怎样定义例程和使用例程, 请参阅 <a href="https://docs.raku.org/type/Sub">Sub</a> 。</p>
</div>
<div class="paragraph">
<p>控制例程是能改变程序流的例程, 它可能会返回一个值。</p>
</div>
<div class="sect2">
<h3 id="_sub_exit">62.1. sub exit</h3>
<div class="paragraph">
<p>定义为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub exit(Int() $status = 0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用返回码 <code>$status</code> 退出当前进程，如果未指定值，则返回码为 0。退出值 (<code>$status</code>)，当不同于零时，必须从捕获它的进程（例如，shell）进行适当的计算; 它是从<a href="https://docs.raku.org/routine/MAIN">Main</a> 返回不同于零的退出代码的唯一方法。</p>
</div>
<div class="paragraph">
<p><code>exit</code> 防止 <a href="https://docs.raku.org/language/phasers#LEAVE">LEAVE</a> phaser 被执行, 但是它会在 <a href="https://docs.raku.org/language/variables#index-entry-%2524%2AEXIT"><code>&amp;*EXIT</code></a> 变量中运行。</p>
</div>
<div class="paragraph">
<p><code>exit</code> 应该作为最后的手段用于向父进程发出关于退出代码不等于零的信号，而不是异常地终止方法或 sub, 使用 <a href="https://docs.raku.org/language/exceptions">exceptions</a> 代替。</p>
</div>
</div>
<div class="sect2">
<h3 id="_done">62.2. done</h3>
<div class="paragraph">
<p>定义为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub done(--&gt; Nil)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果用在任何 supply 或 react 块儿之外, 则抛出异常: <code>done without supply or react</code>。在 <a href="https://docs.raku.org/type/Supply">Supply</a> 块儿里面, 它会指示该 supply 不会再发出任何东西. 还请参阅 <a href="https://docs.raku.org/routine/done">documentation on method <code>done</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = supply {
    for 1 .. 3 {
        emit($_);
    }
    done;
}
$supply.tap( -&gt; $v { say "Second : $v" }, done =&gt; { say "No more" });
# OUTPUT: OUTPUT: «Second : 1␤Second : 2␤Second : 3␤No More␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>传递给 <code>done</code> 命名参数的块将在 <code>supply</code> 块中调用结束 (<code>done</code>) 时运行。</p>
</div>
</div>
<div class="sect2">
<h3 id="_emit">62.3. emit</h3>
<div class="paragraph">
<p>定义为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub emit(\value --&gt; Nil)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在任何 supply 或 react 块儿外面使用 <code>emit</code>, 则抛出异常 <code>emit without supply or react</code>. 在 <a href="https://docs.raku.org/type/Supply">Supply</a> 块儿里面, 它会添加一条消息给 stream 流。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $supply = supply {
  for 1 .. 10 {
      emit($_);
  }
}
$supply.tap( -&gt; $v { say "First : $v" });</code></pre>
</div>
</div>
<div class="paragraph">
<p>还请参阅 <a href="https://docs.raku.org/routine/emit">the page for <code>emit</code> methods</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_undefine">62.4. undefine</h3>
<div class="paragraph">
<p>定义为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub undefine(Mu    \x)
multi sub undefine(Array \x)
multi sub undefine(Hash  \x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 6.d 中被<strong>废弃</strong>, 将在 6.e 中移除。 对于 <a href="https://docs.raku.org/type/Array">Array</a> 和 <a href="https://docs.raku.org/type/Hash">Hash</a>, 它会变得和赋值为 <a href="https://docs.raku.org/type/Slip#index-entry-Empty-Empty">Empty</a> 相等; 对于其它任何东西, 它会和赋值为 <a href="https://docs.raku.org/type/Nil">Nil</a> 相等, 建议使用它。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_setsbags_和_mixes">63. Sets、Bags 和 Mixes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>简而言之，这些类通常包含无序的对象集合。Set 仅考虑这些对象是否存在，bags 可以容纳多个相同类型的对象，mixes 也允许分数（和负）权重。常规版本是不可变的，<strong>Hash</strong> 版本是可变的。</p>
</div>
<div class="paragraph">
<p>让我们详细说明一下。如果要收集容器中的对象但不关心这些对象的顺序，Raku 提供*无序*集合类型 <a href="https://docs.raku.org/type/Set">Set</a>, <a href="https://docs.raku.org/type/SetHash">SetHash</a>, <a href="https://docs.raku.org/type/Bag">Bag</a>, <a href="https://docs.raku.org/type/BagHash">BagHash</a>, <a href="https://docs.raku.org/type/Mix">Mix</a>, 和 <a href="https://docs.raku.org/type/MixHash">MixHash</a>. 由于无序，这些容器可以比 <a href="https://docs.raku.org/type/List">Lists</a> 更有效地查找元素或处理重复的项目。</p>
</div>
<div class="paragraph">
<p>另一方面，如果你想获得包含的对象（元素）<strong>而没有重复</strong>并且你只关心元素*是否*在集合中，你可以使用  <a href="https://docs.raku.org/type/Set">Set</a> 或 <a href="https://docs.raku.org/type/SetHash">SetHash</a>。如果你想消除重复但仍保留顺序，请查看 <a href="https://docs.raku.org/type/List">List</a> 的  <a href="https://docs.raku.org/routine/unique">unique</a> 例程。</p>
</div>
<div class="paragraph">
<p>如果你想跟踪<strong>每个对象出现的次数</strong>，你可以使用 <a href="https://docs.raku.org/type/Bag">Bag</a> 或 <a href="https://docs.raku.org/type/BagHash">BagHash</a>。在这些Baggy 容器中，每个元素都有一个权重（无符号整数），表示同一个对象已包含在集合中的次数。</p>
</div>
<div class="paragraph">
<p>类型 <a href="https://docs.raku.org/type/Mix">Mix</a> 和  <a href="https://docs.raku.org/type/MixHash">MixHash</a> 类似于 <a href="https://docs.raku.org/type/Bag">Bag</a> 和 <a href="https://docs.raku.org/type/BagHash">BagHash</a>，但它们也允许<strong>分数和负权重</strong>。</p>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Set">Set</a>，<a href="https://docs.raku.org/type/Bag">Bag</a> 和 <a href="https://docs.raku.org/type/Mix">Mix</a>  是 <strong>immutable</strong> 类型。如果要在构造容器后添加或删除元素，请使用可变变体 <a href="https://docs.raku.org/type/SetHash">SetHash</a>, <a href="https://docs.raku.org/type/BagHash">BagHash</a>, 和 <a href="https://docs.raku.org/type/MixHash">MixHash</a> 。</p>
</div>
<div class="paragraph">
<p>六个集合类 <code>Set</code>，<code>SetHash</code>，<code>Bag</code>，<code>BagHash</code>，<code>Mix</code>，<code>MixHash</code>，都有相似的语义。</p>
</div>
<div class="paragraph">
<p>首先，就它们而言，相同的对象引用相同的元素 - 其中使用 <a href="https://docs.raku.org/routine/WHICH">WHICH</a> 方法确定身份（即以相同的方式<a href="https://docs.raku.org/routine/===">===</a> 运算符检查身份）。对于像 <code>Str</code> 这样的值类型，这意味着具有相同的值; 对于像“Array”这样的引用类型，它意味着引用相同的对象实例。</p>
</div>
<div class="paragraph">
<p>其次，它们提供了类似 Hash 的接口，其中集合的实际元素（可以是任何类型的对象）是“键”，关联的权重是“值”：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">type of $a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">value of $a{$b} if $b is an element</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">value of $a{$b} if $b is not an element</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set / SetHash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">True</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">False</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bag / BagHash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a positive integer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mix / MixHash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a non-zero real number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_setbag_operators">63.1. Set/Bag operators</h3>
<div class="paragraph">
<p>有几个中缀运算符致力于在 <a href="https://docs.raku.org/type/Set">Set</a> 上执行常见操作，例如并集和差集。其他操作包括布尔检查，例如对象是否是 <code>Set</code> 中的元素，或者一个 <code>Set</code> 是否是另一个 <code>Set</code> 的子集。</p>
</div>
<div class="paragraph">
<p>这些中缀可以使用代表函数的 UTF-8 字符编写（如 <a href="https://docs.raku.org/routine/%E2%88%88">∈</a> 或 <a href="https://docs.raku.org/routine/%E2%88%AA">∪</a>），或与 <a href="https://docs.raku.org/routine/(elem">(elem)</a>) 或 <a href="https://docs.raku.org/routine/%E2%8A%96">(^)</a>。</p>
</div>
<div class="paragraph">
<p>大多数情况下，显式地使用带有这些中缀的 <code>Set</code> 对象是不必要的。所有中缀运算符都将处理 <a href="https://docs.raku.org/type/Any">Any</a> 类型的任何对象的参数（例如， <a href="https://docs.raku.org/type/List">List</a>），<a href="https://docs.raku.org/type/Array">Array</a>，<a href="https://docs.raku.org/type/Mix">Mix</a> 等）并强制他们到在需要的地方设置。</p>
</div>
<div class="paragraph">
<p>在某些情况下，如果参数的类型是 <a href="https://docs.raku.org/type/Bag">Bag</a>，则中缀运算符将以与其行为方式不同但类似的方式运行 <code>Set</code> 参数。</p>
</div>
<div class="sect3">
<h4 id="_operators_that_return_bool">63.1.1. Operators that return <code>Bool</code></h4>
<div class="paragraph">
<p>下面的运算符都是 “Chaining infix” 的优先级。</p>
</div>
<div class="sect4">
<h5 id="_infix_elem">infix (elem)</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;(elem)&gt;($a, Any $b --&gt; Bool)
multi sub infix:&lt;(elem)&gt;($a, Set $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>成员运算符。</p>
</div>
<div class="paragraph">
<p>返回i <code>True</code> 如果 <code>$a</code> 是 <code>$b</code> 中的一个<strong>元素</strong>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 2 (elem) (1, 2, 3).Set;              # OUTPUT: «True␤»
say 4 (elem) (1, 2, 3).Set;              # OUTPUT: «False␤»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_infix_45">infix ∈</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;∈&gt;($a, $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个成员运算符。</p>
</div>
<div class="paragraph">
<p>等价于 <a href="https://docs.raku.org/routine/(elem">(elem)</a>), 在代码点 U+2208 (ELEMENT OF).</p>
</div>
</div>
<div class="sect4">
<h5 id="_infix_46">infix ∉</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;∉&gt;($a, $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>非成员运算符。</p>
</div>
<div class="paragraph">
<p>等价于 <code>!(elem)</code>, 例如, 返回 <code>True</code> 如果 <code>$a</code> 不是 <code>$b</code> 中的元素, 在代码点 U+2209 (NOT AN ELEMENT OF).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 2 !(elem) (1, 2, 3).Set;             # OUTPUT: «False␤»
say 4 !(elem) (1, 2, 3).Set;             # OUTPUT: «True␤»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_infix_cont">infix (cont)</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;(cont)&gt;(Any $a, $b --&gt; Bool)
multi sub infix:&lt;(cont)&gt;(Set $a, $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>包含运算符。</p>
</div>
<div class="paragraph">
<p>返回 <code>True</code> 如果 <code>$a</code> <strong>contains</strong> <code>$b</code> 作为一个元素。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, 2, 3).Set (cont) 2;              # OUTPUT: «True␤»
say (1, 2, 3).Set (cont) 4;              # OUTPUT: «False␤»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_infix_47">infix ∋</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;∋&gt;($a, $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个包含运算符。</p>
</div>
<div class="paragraph">
<p>等价于 <a href="https://docs.raku.org/routine/(cont">(cont)</a>), 在代码点 U+220B (CONTAINS AS MEMBER).</p>
</div>
</div>
<div class="sect4">
<h5 id="_infix_48">infix ∌</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;∌&gt;($a, $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>不包含运算符。</p>
</div>
<div class="paragraph">
<p>等价于 <code>!(cont)</code>, 例如, 返回 <code>True</code> 如果 <code>$a</code> 不包含 <code>$b</code>, 在代码点 U+220C (DOES NOT CONTAIN AS MEMBER).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, 2, 3).Set !(cont) 2;             # OUTPUT: «False␤»
say (1, 2, 3).Set !(cont) 4;             # OUTPUT: «True␤»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_infix_49">infix (&#8656;)</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;&lt;(&lt;=)&gt;&gt;(Any $a, Any $b --&gt; Bool)
multi sub infix:&lt;&lt;(&lt;=)&gt;&gt;(Setty $a, Setty $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>子集或相等运算符。</p>
</div>
<div class="paragraph">
<p>返回 <code>True</code> 如果 <code>$a</code> 是  <code>$b</code>  的一个<strong>子集</strong>(subset) 或  <code>$a</code> 和 <code>$b</code> 相等, 例如, 如果 <code>$a</code> 中所有的元素都是 <code>$b</code> 中的元素, 且 <code>$a</code> 的大小小于或等于 <code>$b</code> 的大小。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, 2, 3).Set (&lt;=) (3, 2, 1).Set;    # OUTPUT: «True␤»
say (1, 3).Set (&lt;=) (2, 1).Set;          # OUTPUT: «False␤»
say ∅ (&lt;=) (3, 2, 1).Set;                # OUTPUT: «True␤»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_infix_50">infix ⊆</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;⊆&gt;($a, $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个子集或相等运算符。</p>
</div>
<div class="paragraph">
<p>等价于 <a href="https://docs.raku.org/routine/(%3C=">(&#8656;)</a>), 在代码点 U+2286 (SUBSET OF OR EQUAL TO).</p>
</div>
</div>
<div class="sect4">
<h5 id="_infix_51">infix ⊈</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;⊈&gt;($a, $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>既不是子集运算符也不是相等运算符。</p>
</div>
<div class="paragraph">
<p>等价于 <code>!(&#8656;)</code>, 在代码点 U+2288 (NEITHER A SUBSET OF NOR EQUAL TO).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, 2, 3).Set !(&lt;=) (3, 2, 1).Set;   # OUTPUT: «False␤»
say (1, 3).Set ⊈ (2, 1).Set;             # OUTPUT: «True␤»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_infix_52">infix (&lt;)</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;&lt;(&lt;)&gt;&gt;(Any $a, Any $b --&gt; Bool)
multi sub infix:&lt;&lt;(&lt;)&gt;&gt;(Setty $a, Setty $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>子集运算符。</p>
</div>
<div class="paragraph">
<p>返回 <code>True</code> 如果 <code>$a</code> 是 <code>$b</code> 的一个<strong>真子集</strong>(strict subset), 例如, <code>$a</code> 中的所有元素都是 <code>$b</code> 中的元素, 但是 <code>$a</code> 的大小比 <code>$b</code> 的大小要小。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, 2, 3).Set (&lt;) (3, 2, 1).Set;     # OUTPUT: «False␤»
say (1, 3).Set (&lt;) (3, 2, 1).Set;        # OUTPUT: «True␤»
say ∅ (&lt;) (3, 2, 1).Set;                 # OUTPUT: «True␤»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_infix_53">infix ⊂</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;⊂&gt;($a, $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个子集运算符。</p>
</div>
<div class="paragraph">
<p>等价于 <a href="https://docs.raku.org/routine/(%3C">(&lt;)</a>), 在代码点 U+2282 (SUBSET OF).</p>
</div>
</div>
<div class="sect4">
<h5 id="_infix_54">infix ⊄</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;⊄&gt;($a, $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>非子集运算符。</p>
</div>
<div class="paragraph">
<p>等价于 <code>!(&lt;)</code>, 在代码点 U+2284 (NOT A SUBSET OF).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, 2, 3).Set !(&lt;) (3, 2, 1).Set;    # OUTPUT: «True␤»
say (1, 3).Set ⊄ (3, 2, 1).Set;          # OUTPUT: «False␤»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_infix_55">infix (&gt;=)</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;&lt;(&gt;=)&gt;&gt;(Any $a, Any $b --&gt; Bool)
multi sub infix:&lt;&lt;(&gt;=)&gt;&gt;(Setty $a, Setty $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>超集或相等运算符。</p>
</div>
<div class="paragraph">
<p>像 <a href="https://docs.raku.org/routine/(%3C=">(&#8656;)</a>) 但是翻转参数。 返回 <code>True</code> 如果 <code>$a</code> 是 <code>$b</code> 的<strong>超集</strong>(superset) 或与 <code>$b</code> 相等。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, 2, 3).Set (&gt;=) (3, 2, 1).Set;    # OUTPUT: «True␤»
say (1, 3).Set (&gt;=) (3, 2, 1).Set;       # OUTPUT: «False␤»
say ∅ (&gt;=) (3, 2, 1).Set;                # OUTPUT: «False␤»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_infix_56">infix ⊇</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;⊇&gt;($a, $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个超集或集合相等运算符。</p>
</div>
<div class="paragraph">
<p>等价于 <a href="https://docs.raku.org/routine/(%3E=">(&gt;=)</a>), 在代码点 U+2287 (SUPERSET OF OR EQUAL TO).</p>
</div>
</div>
<div class="sect4">
<h5 id="_infix_57">infix ⊉</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;⊉&gt;($a, $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>既不是超集运算符, 也非集合相等运算符。</p>
</div>
<div class="paragraph">
<p>等价于 <code>!(&gt;=)</code>, 在代码点 U+2289 (NEITHER A SUPERSET OF NOR EQUAL TO).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, 2, 3).Set !(&gt;=) (3, 2, 1).Set;   # OUTPUT: «False␤»
say (1, 3).Set ⊉ (3, 2, 1).Set;          # OUTPUT: «True␤»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_infix_58">infix (&gt;)</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;&lt;(&gt;)&gt;&gt;(Any $a, Any $b --&gt; Bool)
multi sub infix:&lt;&lt;(&gt;)&gt;&gt;(Setty $a, Setty $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>超集运算符。</p>
</div>
<div class="paragraph">
<p>像 <a href="https://docs.raku.org/routine/(%3C">(&lt;)</a>) 但是反转参数。返回 <code>True</code> 如果 <code>$a</code> 是 <code>$b</code> 的一个<strong>严格超集</strong>(strict superset)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, 2, 3, 4).Set (&gt;) (3, 2, 1).Set;  # OUTPUT: «True␤»
say (1, 3).Set (&gt;) (3, 2, 1).Set;        # OUTPUT: «False␤»
say ∅ (&gt;) (3, 2, 1).Set;                 # OUTPUT: «False␤»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_infix_59">infix ⊃</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;⊃&gt;($a, $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个超集运算符。</p>
</div>
<div class="paragraph">
<p>等价于 <a href="https://docs.raku.org/routine/(%3E">(&gt;)</a>), 在代码点 U+2283 (SUPERSET OF).</p>
</div>
</div>
<div class="sect4">
<h5 id="_infix_60">infix ⊅</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;⊅&gt;($a, $b --&gt; Bool)</code></pre>
</div>
</div>
<div class="paragraph">
<p>非超集运算符。</p>
</div>
<div class="paragraph">
<p>等价于`!(&gt;)`, 在代码点 U+2285 (NOT A SUPERSET OF).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (1, 2, 3, 4).Set !(&gt;) (3, 2, 1).Set; # OUTPUT: «False␤»
say (1, 3).Set ⊅ (3, 2, 1).Set;          # OUTPUT: «True␤»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_operators_that_return_set_or_bag">63.1.2. Operators that return <code>Set</code> or <code>Bag</code></h4>
<div class="sect4">
<h5 id="_infix_61">infix (|)</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;(|)&gt;(**@p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>并集运算符。 它的优先级是 "Junctive Or".</p>
</div>
<div class="paragraph">
<p>返回它所有参数的<strong>并集</strong>。通常, 这创建一个新的包含参数的所有元素的集合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;a a b c d&gt; (|) &lt;h g f e d c&gt; (|) &lt;i j&gt; === set &lt;a b c d e f g h i j&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果它的任何参数是 “Baggy”，它会创建一个新的 “Bag”，其中包含参数的所有元素，每个元素都按照该元素出现的最高权重进行加权。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">bag(&lt;a a b c a&gt;) (|) bag(&lt;a a b c c&gt;) === bag(&lt;a a a b c c&gt;)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_infix_62">infix ∪</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;∪&gt;(|p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个并集运算符。它的优先级是 "Junctive or".</p>
</div>
<div class="paragraph">
<p>等价于 <a href="https://docs.raku.org/routine/(|">(|)</a>), 在代码点 U+222A (UNION).</p>
</div>
</div>
<div class="sect4">
<h5 id="_infix_63">infix (&amp;)</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;(&amp;)&gt;(**@p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>交集运算符。它的优先级是 "Junctive and".</p>
</div>
<div class="paragraph">
<p>返回它所有参数的<strong>交集</strong>。通常, 这创建一个包含所有参数都共有的元素的新的集合。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;a b c&gt; (&amp;) &lt;b c d&gt; === set &lt;b c&gt;
&lt;a b c d&gt; (&amp;) &lt;b c d e&gt; (&amp;) &lt;c d e f&gt; === set &lt;c d&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果任何参数是 “Baggy”，则结果是一个包含公共元素的新 “Bag”，每个元素都由最大*共同*权重（这是所有参数中该元素的权重的最小值）加权。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">bag(&lt;a a b c a&gt;) (&amp;) bag(&lt;a a b c c&gt;) === bag(&lt;a a b c&gt;)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_infix_64">infix ∩</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;∩&gt;(|p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个交集运算符。它的优先级是 "Junctive and".</p>
</div>
<div class="paragraph">
<p>等价于 <a href="https://docs.raku.org/routine/(&amp;">(&amp;)</a>), 在代码点 U+2229 (INTERSECTION).</p>
</div>
</div>
<div class="sect4">
<h5 id="_infix_65">infix (-)</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;(-)&gt;(**@p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>差集运算符。它优先于“Junctive or”。</p>
</div>
<div class="paragraph">
<p>返回其所有参数的<strong>差集</strong>。通常，这将返回由第一个参数具有的所有元素组成的 “Set”，但不包括其余元素，即第一个参数的所有元素，减去其他参数中的元素。</p>
</div>
<div class="paragraph">
<p>如果第一个参数是 “Baggy”，则返回一个 “Bag”，其中包含第一个参数的每个元素，其权重减去每个其他参数中该元素的权重。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">bag(&lt;a a b c a d&gt;) (-) bag(&lt;a a b c c&gt;) === bag(&lt;a d&gt;)
bag(&lt;a a a a c d d d&gt;) (-) bag(&lt;a b d a&gt;) (-) bag(&lt;d c&gt;) === bag(&lt;a a d&gt;)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_infix_66">infix ∖</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;&lt;"\x2216"&gt;&gt;(|p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个差集运算符. 它的优先级是 "Junctive or".</p>
</div>
<div class="paragraph">
<p>等价于 <a href="https://docs.raku.org/routine/(-">(-)</a>).</p>
</div>
</div>
<div class="sect4">
<h5 id="_infix_67">infix (^)</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub infix:&lt;(^)&gt;(Any $a, Any $b --&gt; Setty)
multi sub infix:&lt;(^)&gt;(Set $a, Set $b --&gt; Setty)</code></pre>
</div>
</div>
<div class="paragraph">
<p>对称差集运算符。 它的优先级是 “Junctive or“。</p>
</div>
<div class="paragraph">
<p>返回所有参数的<strong>对称差集</strong>，即 <code>Set</code> 由 <code>$a</code> 所有的元素组成，但 <code>$b</code> 没有，所有元素 <code>$b</code> 都有但是 <code>$a</code> 没有。 相当于  <code>($a ∖ $b) ∪ ($b ∖ $a)</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_infix_68">infix ⊖</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;⊖&gt;($a, $b --&gt; Setty)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个对称差集运算符。它的优先级是 "Junctive or".</p>
</div>
<div class="paragraph">
<p>等价于 <a href="https://docs.raku.org/routine/($CIRCUMFLEX_ACCENT">(^)</a>), 在代码点 U+2296 (CIRCLED MINUS).</p>
</div>
</div>
<div class="sect4">
<h5 id="_infix_69">infix (.)</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;(.)&gt;(**@p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Baggy 乘法运算符。它的优先级是 “Junctive and”。</p>
</div>
<div class="paragraph">
<p>返回其参数的 Baggy <strong>倍数</strong>，即 <code>Bag</code> 包含参数的每个元素，其中参数的元素权重相乘以获得新的权重。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">&lt;a b c&gt; (.) &lt;a b c d&gt; === bag &lt;a b c&gt; # Since 1 * 0 == 0, in the case of 'd'
bag(&lt;a a b c a d&gt;) (.) bag(&lt;a a b c c&gt;) === ("a"=&gt;6,"c"=&gt;2,"b"=&gt;1).Bag</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_infix_70">infix ⊍</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;⊍&gt;(|p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个 baggy 乘法运算符。 它的优先级是 "Junctive and".</p>
</div>
<div class="paragraph">
<p>等价于<a href="https://docs.raku.org/routine/(.">infix (.)</a>), 在代码点 U+228D (MULTISET MULTIPLICATION).</p>
</div>
</div>
<div class="sect4">
<h5 id="_infix_71">infix (+)</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;(+)&gt;(**@p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Baggy 加法运算符。它的优先级是 “Junctive or”。</p>
</div>
<div class="paragraph">
<p>返回其参数的 Baggy <strong>加法</strong>，即包含参数的每个元素，其中参数的权重加在一起以获得新的权重。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">bag(&lt;a a b c a d&gt;) (+) bag(&lt;a a b c c&gt;) === ("a"=&gt;5,"c"=&gt;3,"b"=&gt;2,"d"=&gt;1).Bag</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_infix_72">infix ⊎</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">only sub infix:&lt;⊎&gt;(|p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个 baggy 加法 operator。 它的优先级是 "Junctive or".</p>
</div>
<div class="paragraph">
<p>等价于 link:https://docs.raku.org/routine/([()]), 在代码点 U+228E (MULTISET UNION).</p>
</div>
</div>
<div class="sect4">
<h5 id="_term_2">term ∅</h5>
<div class="paragraph">
<p>等价于 set(), 即空集, 在代码点 U+2205 (EMPTY SET).</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_下标">64. 下标</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_subscripts">64.1. Subscripts</h3>
<div class="paragraph">
<p>通过索引或键访问数据结构中的元素。</p>
</div>
<div class="paragraph">
<p>通常，人们需要引用集合或数据结构中的一个特定的元素（或特定的元素切片）。从数学标记法中偷学到的，向量 <code>v</code> 的组成部分用 <strong>v₁, v₂, v₃</strong> 来引用，在 Raku 中这个概念叫做 “下标” （或“索引”）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_basics">64.2. Basics</h3>
<div class="paragraph">
<p>Raku 提供了两个通用的下标接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">	   elements are identified by     interface name    supported by
[ ]	 zero-based indices	              Positional        Array, List, Buf, Match, ...
{ }	 string or object keys            Associative       Hash, Bag, Mix, Match, ...</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Positional</strong> 下标 (通过 <a href="http://doc.raku.org/language/operators#postcircumfix_">_</a>[postcircumfix [ ]] 通过元素在有序集合中的位置来寻址元素。)索引 0 引用第一个元素， 索引 1 引用第二个元素， 以此类推：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">  my @chores = "buy groceries", "feed dog", "wash car";
  say @chores[0];  #-&gt; buy groceries
  say @chores[1];  #-&gt; feed dog
  say @chores[2];  #-&gt; wash car</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Associative</strong> 下标 (通过 <a href="http://doc.raku.org/language/operators#postcircumfix_{_}">postcircumfix { }</a>), 不要求集合以任何特定的顺序保存元素 - 相反，它使用一个唯一的键来寻址每个值。键的种类取决于使用的集合： 举个例子， 一个标准的<a href="http://doc.raku.org/type/Hash">散列</a> 使用字符串作为键， 而一个 <a href="http://doc.raku.org/type/Mix">Mix</a> 能使用任意的对象作为键， 等等:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">  my %grade = Zoe =&gt; "C", Ben =&gt; "B+";
  say %grade{"Zoe"};  #-&gt; C
  say %grade{"Ben"};  #-&gt; B+

  my $stats = ( Date.today =&gt; 4.18, Date.new(2015,  4,  5) =&gt; 17.253 ).Mix;
  say $stats{ Date.new(2015, 4, 5) };  #-&gt; 17.253</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>相对于传递单个-单词字符串键给 `{ }` , 你也可以使用link:http://doc.raku.org/language/quoting#Word_quoting:_qw[以尖括号引起单词的结构] ，就像它们是后缀操作符一样：</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">  say %grade&lt;Zoe&gt;;    #-&gt; C
  say %grade&lt;Ben&gt;;    #-&gt; B+</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>这实际上仅仅是在编译时被转换为对应 `{ }` 形式的语法糖：</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">  %hash&lt;foo bar&gt;;     # same as %hash{ &lt;foo bar&gt; }
  %hash«foo $var»;    # same as %hash{ «foo $var» }
  %hash&lt;&lt;foo $var&gt;&gt;;  # same as %hash{ &lt;&lt;foo $var&gt;&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>下标能应用到能返回可下标化对象的任何表达式上， 而不仅仅应用到变量上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "__Hello__".match(/__(.*)__/)[0];   #-&gt; ｢Hello｣
say "__Hello__".match(/__(.*)__/).[0];  # same, in method notation</code></pre>
</div>
</div>
<div class="paragraph">
<p>Positional 和 associative  下标并不互相排斥 - 举个例子， <code>Match</code> 对象两个都支持（每个访问不同的数据集）。还有， 为了让列表处理更方便， 类 <code>Any</code> 为`位置下标`提供了备用的实现，这会把调用者看作含有`一个`元素的列表。(但是对于关系下标，没有这样的备用实现， 所以会抛出一个异常，当下标被应用到没有实现支持的对象上时。)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 42[0];    #-&gt; 42
say 42&lt;foo&gt;;  # ERROR: postcircumfix { } not defined for type Int</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_nonexistent_elements">64.3. Nonexistent elements</h3>
<div class="paragraph">
<p>当通过下标寻址一个不存在的元素所发生的事情取决于正在使用的集合类型。标准的 Array 和 Hash 集合返回它们的<a href="http://doc.raku.org/routine/of">value type constraint</a>  的类型对象（这默认是 <code>Any</code>）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array1;     say @array1[10];  #-&gt; (Any)
my Int @array2; say @array2[10];  #-&gt; (Int)

my %hash1;      say %hash1&lt;foo&gt;;  #-&gt; (Any)
my Int %hash2;  say %hash2&lt;foo&gt;;  #-&gt; (Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而， 其它类型的集合可能在寻址不存在的元素的下标时反应也不用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say (0, 10, 20)[3];       #-&gt; Nil
say bag(&lt;a a b b b&gt;)&lt;c&gt;;  #-&gt; 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了在下标操作中默默地跳过不存在的元素， 查看 <a href="http://doc.raku.org/language/subscripts#Truncating_slices"><mark>Truncating slices</a>  和 <a href="http://doc.raku.org/language/subscripts</mark>%3Av"><code>#:v</code></a> 副词。</p>
</div>
</div>
<div class="sect2">
<h3 id="_from_the_end">64.4. From the end</h3>
<div class="paragraph">
<p>Positional  索引是从集合的开头计数的， 但是也有一种标记法用于，通过相对于末尾的位置来寻址元素：<code><strong>-1</code> 引用最后一个元素， <code></strong>-2</code> 引用倒数第二个元素， 以此类推。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @alphabet = 'A' .. 'Z';
say @alphabet[*-1];  #-&gt; Z
say @alphabet[*-2];  #-&gt; Y
say @alphabet[*-3];  #-&gt; X</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意：星号很重要。在 Raku中，如果像在很多其它编程语言中那样传递一个裸的负整数（例如 <code>@alphabet[-1]</code>）， 会抛出错误。</p>
</div>
<div class="paragraph">
<p>这里实际发生的是， <code><strong>-1</code> 那样的表达式通过 <a href="http://doc.raku.org/type/Whatever">Whatever</a> 柯里化声明了一个代码对象 - <code>[ ]`会把代码对象作为索引， 通过集合的长度作为参数来调用它并使用结果值作为实际的索引。 换句话说，</code>@alphabet[</strong>-1]` 变成了 <code>@alphabet[@alphabet.elems - 1]</code>。</p>
</div>
<div class="paragraph">
<p>这意味着你可以使用任何依赖于集合尺寸的表达式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @array[* div 2];  # 选择最中间的那个元素
say @array[$i % *];   # wrap around a given index ("模运算")
say @array[ -&gt; $size { $i % $size } ];  # same as previous</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_slices">64.5. Slices</h3>
<div class="paragraph">
<p>当需要访问集合中的多个元素时，有一个快捷方式用于处理多个单独的下标操作：仅仅在下标中指定一个`索引/键`的列表，来取回一个元素的列表 - 也被叫做”切片” - 以相同的顺序。</p>
</div>
<div class="paragraph">
<p>对于 positional  切片， 你可以混合普通切片和  <a href="http://doc.raku.org/language/subscripts#From_the_end">from-the-end</a> 切片：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @alphabet = 'a' .. 'z';
dd @alphabet[15, 4, *-9, 11];  #-&gt; ("p", "e", "r", "l")</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 associative  切片，尖括号形式的切片通常会很方便：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %color = kiwi =&gt; "green", banana =&gt; "yellow", cherry =&gt; "red";
dd %color{"cherry", "kiwi"};  #-&gt; ("red", "green")
dd %color&lt;cherry kiwi&gt;;       #-&gt; ("red", "green")
dd %color{*};                 #-&gt; ("green", "red", "yellow")</code></pre>
</div>
</div>
<div class="paragraph">
<p>要知道切片是由传入 (<a href="http://doc.raku.org/language/subscripts#Multiple_dimensions">one dimension of</a>)下标的类型控制的，而非它的长度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subscript	                               result
any Positional object not covered below	   normal slice
a Range or infinite sequence	           truncating slice (only for positional subscripts)
* (Whatever-star)	                       full slice (as if all keys/indices were specified)
any other object	                       single-element access rather than a slice
empty	                                   Zen slice</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以，即使一个单个元素的列表也会返回一个切片， 而一个裸的标量值不会：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">dd @alphabet[2,];  #-&gt; ("c",)
dd @alphabet[2];   #-&gt; "c"</code></pre>
</div>
</div>
<div class="paragraph">
<p>(尖括号形式的 associative 下标也没有问题，因为 <a href="http://doc.raku.org/language/quoting#Word_quoting:_qw">word quoting</a>  在单个单词的情况下很方便的返回一个 Str, 但是在多个单词的情况下返回一个 <a href="http://doc.raku.org/type/Parcel">Parcel</a>)。</p>
</div>
<div class="paragraph">
<p>对于普通的切片，下标的内容 (<a href="http://doc.raku.org/language/subscripts#Multiple_dimensions">the current dimension of</a>) 在它的元素被解释为 <code>索引/键</code> 之前会被展平(flattened)：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">dd @alphabet[0, (1..2, (3,)))];  #-&gt; ("a", "b", "c", "d")</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_truncating_slices">64.5.1. Truncating slices</h4>
<div class="paragraph">
<p>通常, 在切片下标中引用不存在的元素会让输出列表包含未定义的值。然而， 如果传递给位置下标的对象是一个 Range 或使用序列操作符构建的无限序列， 它会被自动截断到集合的实际尺寸：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @letters = &lt;a b c d e f&gt;;
dd @letters[3, 4, 5, 6, 7];  #-&gt; ("d", "e", "f", Any, Any)
dd @letters[3 .. 7];         #-&gt; ("d", "e", "f")</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://doc.raku.org/language/subscripts#From_the_end">From-the-end</a>  索引被允许作为范围的端点，代表无限的范围和序列：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @array[*-3 .. *];       # select the last three elements
say @array[0, 2, 4 ... *];  # select all elements with even indices</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你不想把你的切片指定为 <code>range/sequence</code> 但仍旧想默默地跳过不存在的元素， 你可以使用 <a href="http://doc.raku.org/language/subscripts#%3Av">#:v</a> 副词。</p>
</div>
</div>
<div class="sect3">
<h4 id="_zen_slices">64.5.2. Zen slices</h4>
<div class="paragraph">
<p>如果你写的下标没有指定任何 <code>索引/键</code> ，那它就会返回被脚注的对象自身。因为它是空的但是返回了全部东西， 这就是所谓的 "Zen slice"。</p>
</div>
<div class="paragraph">
<p>这和传递一个  Whatever-star （这，像普通的切片， 总是返回一个元素的 Parcel，不管原对象的类型）还有传递一个空的列表都不同（它返回一个空的切片）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %bag := ("orange" =&gt; 1, "apple" =&gt; 3).Bag;
dd %bag&lt;&gt;;    #-&gt; ("orange"=&gt;1,"apple"=&gt;3).Bag
dd %bag{};    #-&gt; ("orange"=&gt;1,"apple"=&gt;3).Bag
dd %bag{*};   #-&gt; (1, 3)
dd %bag{()};  #-&gt; ()</code></pre>
</div>
</div>
<div class="paragraph">
<p>这通常被用于把整个 <code>数组/散列</code> 插值到字符串中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @words = "cruel", "world";
say "Hello, @words[]!"  #-&gt; Hello, cruel world!</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_dimensions">64.6. Multiple dimensions</h3>
<div class="paragraph">
<p>尚未实现！等到 9 月份？</p>
</div>
</div>
<div class="sect2">
<h3 id="_modifying_elements">64.7. Modifying elements</h3>

</div>
<div class="sect2">
<h3 id="_autovivification">64.8. Autovivification</h3>
<div class="paragraph">
<p>下标参与 "autovivification”（自动复活），i.e. 这是一种数组和散列在需要时会自动存在的处理， 以至于你没有必要在每一层级预声明集合的类型来构建嵌套的数据结构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $beatles;
$beatles{"White Album"}[0] = "Back in the U.S.S.R.";  # autovivification!
say $beatles.perl;  #-&gt; {"White Album" =&gt; ["Back in the U.S.S.R."]}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$beatles</code>  从未定义开始， 但是它变成了一个 Hash 对象， 因为它在赋值时用 <code>{ }</code> 标注了。 类似地，  <code>$beatles{"White Album”}</code> 变成一个 Array 对象， 因为它在赋值时用 <code>[ ]</code> 标注了。</p>
</div>
<div class="paragraph">
<p>注意下标本身不会引起 autovivification（自动复活）：它只发生在下标链的结果被赋值时（或变化时）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_binding_2">64.9. Binding</h3>
<div class="paragraph">
<p>下标表达式也可以用在绑定语句的左侧。如果被标注的集合的类型支持， 这会使用指定的容器替换集合里的插槽的值：（给跪了！）</p>
</div>
<div class="paragraph">
<p>内置的 Array 和 Hash 类型支持这种绑定， 为了允许构建复杂的联动的数据结构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 10, 11, 12, 13;
my $x = 1;

@a[2] := $x;  # binding! (@a[2] and $x refer to the same container now.)

$x++; @a[2]++;

dd @a;  #-&gt; [10, 11, 3, 13]&lt;&gt;
dd $x;  #-&gt; 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>查看 <a href="http://doc.raku.org/language/subscripts#method_BIND-POS">#method BIND-POS</a> 和 <a href="http://doc.raku.org/language/subscripts#method_BIND-KEY">#method BIND-KEY</a> 了解底层机制.</p>
</div>
</div>
<div class="sect2">
<h3 id="_adverbs">64.10. Adverbs</h3>
<div class="paragraph">
<p>下标操作的返回值和可能存在的副作用能够使用副词来控制。</p>
</div>
<div class="paragraph">
<p>要知道副词操作符的优先级相对宽松，这可能需要你在合成表达式中添加括号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $foo || %hash&lt;key&gt;:exists { ... }    # WRONG, tries to adverb the || op
if $foo || (%hash&lt;key&gt;:exists) { ... }  # correct</code></pre>
</div>
</div>
<div class="paragraph">
<p>支持的副词有:</p>
</div>
<div class="sect3">
<h4 id="_exists_2">64.10.1. :exists</h4>
<div class="paragraph">
<p>返回请求的元素是否存在，而不是返回元素实际的值。这能够用于区别未定义值的元素和一点儿也不属于集合部分的元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @foo = Any, 10;
dd @foo[0].defined;    #-&gt; False
dd @foo[0]:exists;     #-&gt; True
dd @foo[2]:exists;     #-&gt; False
dd @foo[0, 2]:exists;  #-&gt; (True, False)

my %fruit = apple =&gt; Any, orange =&gt; 10;
dd %fruit&lt;apple&gt;.defined;       #-&gt; False
dd %fruit&lt;apple&gt;:exists;        #-&gt; True
dd %fruit&lt;banana&gt;:exists;       #-&gt; False
dd %fruit&lt;apple banana&gt;:exists; #-&gt; (True, False)</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以对副词取反来测试不存在：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">dd %fruit&lt;apple banana&gt;:!exists; #-&gt; (False, True)</code></pre>
</div>
</div>
<div class="paragraph">
<p>要检查切片的所有元素是否存在， 使用 <a href="http://doc.raku.org/routine/all">all</a> junction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if all %fruit&lt;apple orange banana&gt;:exists { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:exists</code>  可以和  <a href="http://doc.raku.org/language/subscripts#%3Adelete">:delete</a> 还有 <code>:p/:kv</code> 副词组合 - 这时表达式的行为就由那些副词决定，除了使用表明元素存在的对应 Bool 值替换返回的元素值之外。</p>
</div>
<div class="paragraph">
<p>查看 <a href="http://doc.raku.org/language/subscripts#method_EXISTS-POS">method EXISTS-POS</a>  和 <a href="http://doc.raku.org/language/subscripts#method_EXISTS-KEY">method EXISTS-KEY</a> 了解底层机制.</p>
</div>
</div>
<div class="sect3">
<h4 id="_delete_2">64.10.2. :delete</h4>
<div class="paragraph">
<p>从集合中删除元素， 除了返回它们的值以外。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @tens = 0, 10, 20, 30;
dd @tens[3]:delete;     #-&gt; 30
dd @tens;               #-&gt; [0, 10, 20]&lt;&gt;

my %fruit = apple =&gt; 5, orange =&gt; 10, banana =&gt; 4, peach =&gt; 17;
dd %fruit&lt;apple&gt;:delete;         #-&gt; 5
dd %fruit&lt;peach orange&gt;:delete;  #-&gt; (17, 10)
dd %fruit;                       #-&gt; {banana =&gt; 4}&lt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用否定形式的副词，元素实际上不会被删除。这意味着你可以传递一个标记，让它变成有条件的删除：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">dd %fruit&lt;apple&gt; :delete($flag);  # deletes the element only if $flag is
                                  # true, but always returns the value.</code></pre>
</div>
</div>
<div class="paragraph">
<p>能和 <code>:exists</code> 还有 <code>:p/:kv/:k/:v</code> 副词组合 - 这时返回值由那些副词决定， 但是同时元素也会被删除。</p>
</div>
<div class="paragraph">
<p>查看 <a href="http://doc.raku.org/language/subscripts#method_DELETE-POS">method DELETE-POS</a> and <a href="http://doc.raku.org/language/subscripts#method_DELETE-KEY">method DELETE-KEY</a> 了解底层机制.</p>
</div>
</div>
<div class="sect3">
<h4 id="_p">64.10.3. :p</h4>
<div class="paragraph">
<p>以 Pair 的形式，返回元素的`索引/键` 和元素值， 并默默跳过不存在的元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @tens = 0, 10, 20, 30;
dd @tens[1]:p;        #-&gt; 1 =&gt; 10
dd @tens[0, 4, 2]:p;  #-&gt; (0 =&gt; 0, 2 =&gt; 20)

my %month = Jan =&gt; 1, Feb =&gt; 2, Mar =&gt; 3;
dd %month&lt;Feb&gt;:p;          #-&gt; "Feb" =&gt; 2
dd %month&lt;Jan Foo Mar&gt;:p;  #-&gt; ("Jan" =&gt; 1, "Mar" =&gt; 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你不想跳过不存在的元素， 使用否定形式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">dd %month&lt;Jan Foo Mar&gt;:!p;  #-&gt; ("Jan" =&gt; 1, "Foo" =&gt; Any, "Mar" =&gt; 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>能和 <code>:exists</code> 还有 <code>:delete</code> 组合。</p>
</div>
<div class="paragraph">
<p>也可以查看  <a href="http://doc.raku.org/routine/pairs">pairs</a> 子例程.</p>
</div>
</div>
<div class="sect3">
<h4 id="_kv">64.10.4. :kv</h4>
<div class="paragraph">
<p>以列表的形式返回元素的`索引/键`和`值` , 并默默地跳过不存在的元素。 当作用在切片上时，返回值是一个展平的键和值交叉着的单个列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @tens = 0, 10, 20, 30;
dd @tens[1]:kv;        #-&gt; (1, 10)
dd @tens[0, 4, 2]:kv;  #-&gt; (0, 0, 2, 20)

my %month = Jan =&gt; 1, Feb =&gt; 2, Mar =&gt; 3;
dd %month&lt;Feb&gt;:kv;          #-&gt; ("Feb", 2)
dd %month&lt;Jan Foo Mar&gt;:kv;  #-&gt; ("Jan", 1, "Mar", 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你不想跳过不存在的元素， 使用否定形式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">dd %month&lt;Jan Foo Mar&gt;:!kv;  #-&gt; ("Jan", 1, "Foo", Any, "Mar", 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个副词一般用于遍历切片：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for %month&lt;Feb Mar&gt;:kv -&gt; $month, $i {
    say "$month had {Date.new(2015, $i, 1).days-in-month} days in 2015"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>能和 <code>:exists</code> 还有 <code>:delete</code> 组合。</p>
</div>
<div class="paragraph">
<p>也可以查看  <a href="http://doc.raku.org/routine/kv">kv</a> 子例程.</p>
</div>
</div>
<div class="sect3">
<h4 id="_k">64.10.5. :k</h4>
<div class="paragraph">
<p>只返回元素的`索引/键` , 而不是它们的值, 并默默地跳过不存在的元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @tens = 0, 10, 20, 30;
dd @tens[1]:k;        #-&gt; 1
dd @tens[0, 4, 2]:k;  #-&gt; (0, 2)

my %month = Jan =&gt; 1, Feb =&gt; 2, Mar =&gt; 3;
dd %month&lt;Feb&gt;:k;          #-&gt; "Feb"
dd %month&lt;Jan Foo Mar&gt;:k;  #-&gt; ("Jan", "Mar")</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你不想跳过不存在的元素， 使用否定形式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">dd %month&lt;Jan Foo Mar&gt;:!k;  #-&gt; ("Jan", "Foo", "Mar")</code></pre>
</div>
</div>
<div class="paragraph">
<p>还可以查看  <a href="http://doc.raku.org/routine/keys">keys</a> 子例程.</p>
</div>
</div>
<div class="sect3">
<h4 id="_v">64.10.6. :v</h4>
<div class="paragraph">
<p>返回元素的裸值（不是有可能返回一个可变值容器），并默默跳过不存在的元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @tens = 0, 10, 20, 30;
dd @tens[1]:v;        #-&gt; 10
dd @tens[0, 4, 2]:v;  #-&gt; (0, 20)
@tens[3] = 31;        # OK
@tens[3]:v = 31;      # ERROR, cannot assign to immutable integer value

my %month = Jan =&gt; 1, Feb =&gt; 2, Mar =&gt; 3;
dd %month&lt;Feb&gt;:v;          #-&gt; 2
dd %month&lt;Jan Foo Mar&gt;:v;  #-&gt; (1, 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你不想跳过不存在的元素， 使用否定形式:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">dd %month&lt;Jan Foo Mar&gt;:!v;  #-&gt; (1, Any, 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>还可以查看  <a href="http://doc.raku.org/routine/values">values</a> 子例程.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_custom_types">64.11. Custom types</h3>
<div class="paragraph">
<p>这页描述的下标接口并不意味着和 Raku 的内置集合类型相排斥 - 你可以（并且应该）为任何想通过索引或键提供数据访问的自定义类型重用它们。</p>
</div>
<div class="paragraph">
<p>你不必手动重载  <a href="http://doc.raku.org/routine/">%20</a>#postcircumfix_[_][postcircumfix [ ]] 和  <a href="http://doc.raku.org/">postcircumfix { }</a>  操作符并重新实现它们所有的戏法， 为了实现它， 相反，你可以依赖这个事实， 在幕后，它们的标准实现分派给了一个定义良好的底层方法集。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">当你这样写:	         这会在幕后调用如下底层方法:
%foo&lt;aa&gt;	        %foo.AT-KEY("aa")
%foo&lt;aa&gt;:delete	    %foo.DELETE-KEY("aa")
@foo[3,4,5]	        @foo.AT-POS(3), @foo.AT-POS(4), @foo.AT-POS(5)
@foo[*-1]	        @foo.AT-POS(@foo.elems - 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以， 为了让你的下标工作， 你只需要为你的自定义类型实现或委托那些底层方法（<a href="http://doc.raku.org/language/subscripts#Methods_to_implement_for_positional_subscripting">下面描述详情</a>）。</p>
</div>
<div class="paragraph">
<p>如果你这样做了， 你还应该让你的类型各自遵守 <a href="http://doc.raku.org/type/Positional">Positional</a> 或 <a href="http://doc.raku.org/type/Associative">Associative</a> role</p>
</div>
<div class="sect3">
<h4 id="_custom_type_example">64.11.1. Custom type example</h4>
<div class="paragraph">
<p>设想一下 HTTP::Header 类型，尽管它作为一个有特定行为的自定义类，却能像散列那样索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $request = HTTP::Request.new(GET =&gt; "raku.org");
say $request.header.WHAT;  #-&gt; (HTTP::Header)

$request.header&lt;Accept&gt; = "text/plain";
$request.header{'Accept-' X~ &lt;Charset Encoding Language&gt;} = &lt;utf-8 gzip en&gt;;
$request.header.push('Accept-Language' =&gt; "fr");  # like .push on a Hash

say $request.header&lt;Accept-Language&gt;.perl;  #-&gt; ["en", "fr"]

my $rawheader = $request.header.Str;  # stringify according to HTTP spec</code></pre>
</div>
</div>
<div class="paragraph">
<p>实现这个类的最简单的方法是，给它一个 Hash 类型的属性，并把所有的下标和迭代相关功能性委托给那个属性。（使用一个自定义类型约束来确保使用者不会在里面插入任何不合法的值）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class HTTP::Header does Associative is Iterable {
    subset StrOrArrayOfStr where Str | ( Array &amp; {.all ~~ Str} );

    has %!fields of StrOrArrayOfStr
                 handles &lt;AT-KEY EXISTS-KEY DELETE-KEY push
                          iterator list kv keys values&gt;;

    method Str { #`[not shown, for brevity] }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而， HTTP header 字段名被认为是大小写无关的（更偏好驼峰法）。我们可以通过把 <code>*-key</code> 和 <code>push</code> 方法拿到 <code>handles</code> 列表的外面来容纳它， 并像这样各自实现它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method AT-KEY     ($key) is rw { %!fields{normalize-key $key}        }
method EXISTS-KEY ($key)       { %!fields{normalize-key $key}:exists }
method DELETE-KEY ($key)       { %!fields{normalize-key $key}:delete }
method push (*@_) { #`[not shown, for brevity] }

sub normalize-key ($key) { $key.subst(/\w+/, *.tc, :g) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意下标  <code>%!fields</code> 返回一个适当的 rw 容器， 而我们的 <code>AT-KEY</code> 能够简单地传递。</p>
</div>
<div class="paragraph">
<p>然而， 我们可能倾向于少一点对用户输入的限制， 相反我们自己关心字段值的消毒。那种情况下，我们可以移除 <code>%!fields</code> 上的 <code>StrOrArrayOfStr</code>  类型约束， 并在赋值时使用返回自定义的关心消毒值的 Proxy 容器来替换我们的 <code>AT-KEY</code> 实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method AT-KEY (::?CLASS:D: $key) is rw {
    my $element := %!fields{normalize-key $key};

    Proxy.new(
        FETCH =&gt; method () { $element },

        STORE =&gt; method ($value) {
            $element = do given $value».split(/',' \s+/).flat {
                when 1  { .[0] }    # a single value is stored as a string
                default { .Array }  # multiple values are stored as an array
            }
        }
    );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意把方法声明为 <code>multi</code> 并把它限制为 <code>:D</code> (defined invocants) 确保未定义情况被传递给由 Any（这在自动复活中被调用） 提供的默认实现。（我去，翻译不来哦！）</p>
</div>
</div>
<div class="sect3">
<h4 id="_methods_to_implement_for_positional_subscripting">64.11.2. Methods to implement for positional subscripting</h4>
<div class="paragraph">
<p>为了通过  <a href="http://doc.raku.org/routine/">%20</a>#postcircumfix_[_][postcircumfix [ ]]  让基于索引的下标在你的自定义类型中工作，你应该至少实现下面的  <code>elems</code>, <code>AT-POS</code> 和 <code>EXISTS-POS-</code> 还有其它可选项。</p>
</div>
<div class="sect4">
<h5 id="_elems_方法">elems 方法</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method elems (::?CLASS:D:)</code></pre>
</div>
</div>
<div class="paragraph">
<p>预期返回一个数字，用于表明对象中有多少个可标注的元素。 可能被用户直接调用， 并且当从末尾索引元素的时候， 还会被  <code>postcircumfix [ ]</code> 调用， 就像 <code>@foo[*-1]</code> 中那样。</p>
</div>
<div class="paragraph">
<p>如果没有实现这个方法， 你的类型会从 Any 继承默认的实现， 对定义过的调用者这总是返回 1 - 这最不可能是你想要的。 所以， 如果不能从你的位置类型知晓元素的个数， 那就添加一个 fails 或 dies 实现， 以避免沉默地做了错事。</p>
</div>
</div>
<div class="sect4">
<h5 id="_at_pos_方法">AT-POS 方法</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method AT-POS (::?CLASS:D: $index)</code></pre>
</div>
</div>
<div class="paragraph">
<p>期望返回 <code>$index</code> 位置处的元素。这就是 <code>postcircumfix [ ]</code> 通常调用的方法。
如果你想让元素可变(像它们用于 Array 类型那样), 你就必须确保以 item 容器的形式返回它, 并在被赋值时更新它。(记得使用 <code>return-rw</code> 或 <code>rw</code> 子例程 trait 以使它工作; 查看例子。)</p>
</div>
</div>
<div class="sect4">
<h5 id="_exists_pos_方法">EXISTS-POS 方法</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method EXISTS-POS (::?CLASS:D: $index)</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回一个布尔值以表明在 <code>$index</code> 位置处是否有元素。这就是引用 <code>@foo[42]:exists</code> 时, <code>postcircumfix [ ]</code> 所调用的方法。</p>
</div>
<div class="paragraph">
<p>元素"存在"意味着什么, 取决于你的类型。</p>
</div>
<div class="paragraph">
<p>如果你没有实现它, 你的类型会从 <code>Any</code> 那儿继承默认的实现, 对于索引 0 它会返回 True, 对于 其它索引它会返回 <code>false</code>&#8201;&#8212;&#8201;这可能不是你想要的。所以如果你的类型不能做元素存在检测, 那就添加一个 fails 或 die 实现, 以避免静默地做错事情。</p>
</div>
</div>
<div class="sect4">
<h5 id="_delete_pos_方法">DELETE-POS 方法</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method DELETE-POS (::?CLASS:D: $index)</code></pre>
</div>
</div>
<div class="paragraph">
<p>删除 <code>$index</code> 处的元素, 并返回它所删除的这个元素。这就是引用 <code>@foo[42]:delete</code> 时, <code>postcircumfix [ ]</code> 所调用的方法。</p>
</div>
<div class="paragraph">
<p>"删除"元素的意思是什么, 取决于你的类型。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>实现这个方法是可选的; 如果你没有实现它, 那么用户尝试从这种类型的对象中删除元素会得到一个合适的错误信息。</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_assign_pos_方法">ASSIGN-POS 方法</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method ASSIGN-POS (::?CLASS:D: $index, $new)</code></pre>
</div>
</div>
<div class="paragraph">
<p>把 <code>$index</code> 位置处的元素设置为 <code>$new</code> 值。实现这个方法完全是可选的; 如果你没有实现这个方法, 那么会使用 <code>self.AT-POS($index) = $new</code>  代替, 如果你确实实现了该方法, 那么确保它拥有相同的效果。</p>
</div>
<div class="paragraph">
<p>这意味着 opt-in 性能优化, 以至于简单的诸如 <code>@numbers[5] = "five"</code> 的赋值能在不调用 <code>AT-POS</code>(这必须创建并返回一个潜在的昂贵的容器对象) 方法时操作。</p>
</div>
<div class="paragraph">
<p>注意, 实现 <code>ASSIGN-POS</code> 不能解除让 <code>AT-POS</code> 变成一个 <code>rw</code> 方法, 因为诸如 <code>@numbers[5]++</code> 的不太重要的赋值/修改 仍旧会使用 <code>AT-POS</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_bind_pos_方法">BIND-POS 方法</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method BIND-POS (::?CLASS:D: $index, \new)</code></pre>
</div>
</div>
<div class="paragraph">
<p>把值或容器 <code>new</code> 绑定给位置 <code>$index</code> 处的插槽上, 替换那儿能找到的任何容器。这是当你这样写的时候所调用的东西:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 10;
@numbers[5] := $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>一般的数组类支持这以允许创建复杂的链接数据结构,  但是对于更特定领域类型它可能没有意义, 所以不强求去实现它。如果你没有实现该方法, 用户会获得一个合适的错误信息, 当它们尝试绑定到这种类型的对象的一个位置插槽上时。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_methods_to_implement_for_associative_subscripting">64.11.3. Methods to implement for associative subscripting</h4>
<div class="paragraph">
<p>为了通过 <code>postcircumfix { }</code> 让基于键的下标能够工作于你的自定义类型中, 你应该至少实现 <code>AT-KEY</code> 和 <code>EXISTS-KEY</code>&#8201;&#8212;&#8201;还有可选地实现下面的方法。</p>
</div>
<div class="sect4">
<h5 id="_at_key_方法">AT-KEY 方法</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method AT-KEY (::?CLASS:D: $key)</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回和 <code>$key</code> 相关联的元素。这正是 <code>postcircumfix { }</code> 通常所调用的方法。</p>
</div>
<div class="paragraph">
<p>如果你想让元素可变(就像它们是为了内置的 Hash 类型), 你必须确保以 item 容器的形式返回它, 并在被赋值时更新它。(记得使用 <code>return-rw</code> 或 <code>is rw</code> 子例程 trait 以使其有效; 查看例子。)</p>
</div>
<div class="paragraph">
<p>另一方面, 如果你想让你的集合只读, 请直接返回非容器值。</p>
</div>
</div>
<div class="sect4">
<h5 id="_exists_key_方法">EXISTS-KEY 方法</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method EXISTS-KEY (::?CLASS:D: $key)</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回一个布尔值以表明和 <code>$key</code> 相关联的元素是否存在。这就是引用 <code>%foo&lt;aa&gt;:exists</code> 时, <code>postcircumfix { }</code> 所调用的方法。</p>
</div>
<div class="paragraph">
<p>元素"存在"意味着什么, 取决于你的类型。</p>
</div>
<div class="paragraph">
<p>如果你没有实现它, 你的类型会从 <code>Any</code> 那儿继承默认的实现, 这通常返回 False&#8201;&#8212;&#8201;这可能不是你想要的。所以如果你的类型不能做元素存在检测, 那就添加一个 fails 或 die 实现, 以避免静默地做错事情</p>
</div>
</div>
<div class="sect4">
<h5 id="_delete_key_方法">DELETE-KEY 方法</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method DELETE-KEY (::?CLASS:D: $key)</code></pre>
</div>
</div>
<div class="paragraph">
<p>删除和 <code>$key</code> 相关联的元素, 并返回它所删除的这个元素。这就是引用 <code>%foo&lt;aa&gt;:delete</code> 时, <code>postcircumfix { }</code> 所调用的方法。</p>
</div>
<div class="paragraph">
<p>"删除"元素的意思是什么, 取决于你的类型&#8201;&#8212;&#8201;尽管它通常让 <code>EXISTS-KEY</code> 因为那个键变为 <code>False</code>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>实现这个方法是可选的; 如果你没有实现它, 那么用户尝试从这种类型的对象中删除元素会得到一个合适的错误信息。</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_assign_key_方法">ASSIGN-KEY 方法</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method ASSIGN-KEY (::?CLASS:D: $key, $new)</code></pre>
</div>
</div>
<div class="paragraph">
<p>把和 <code>$key</code>  相关联的元素设置为 <code>$new</code> 值。实现这个方法完全是可选的; 如果你没有实现这个方法, 那么会使用 <code>self.AT-KEY($key) = $new</code> 代替, 如果你确实实现了该方法, 那么确保它拥有相同的效果。</p>
</div>
<div class="paragraph">
<p>这意味着 opt-in 性能优化, 以至于简单的诸如 <code>%age&lt;Claire&gt; = 29</code> 的赋值能在不调用 <code>AT-KEY</code>(这必须创建并返回一个潜在的昂贵的容器对象) 方法时操作。</p>
</div>
<div class="paragraph">
<p>注意, 实现 <code>ASSIGN-KEY</code> 不能解除让 <code>AT-KEY</code> 变成一个 <code>rw</code> 方法, 因为诸如 <code>%age&lt;Claire&gt;++</code> 的不太重要的赋值/修改 仍旧会使用 <code>AT-KEY</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_bind_key_方法">BIND-KEY 方法</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method BIND-KEY (::?CLASS:D: $key, \new)</code></pre>
</div>
</div>
<div class="paragraph">
<p>把值或容器 <code>new</code> 绑定给跟 <code>$key</code> 相关联的插槽上, 替换那儿能找到的任何容器。这是当你这样写的时候所调用的东西:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = 10;
%age&lt;Claire&gt; := $x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>一般的散列类支持这以允许创建复杂的链接数据结构,  但是对于更特定领域类型它可能没有意义, 所以不强求去实现它。如果你没有实现该方法, 用户会获得一个合适的错误信息, 当它们尝试绑定到这种类型的对象的一个位置插槽上时。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_语法_2">65. 语法</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 借用了人类语言中的许多概念。考虑到它是由语言学家设计的，这并不奇怪。</p>
</div>
<div class="paragraph">
<p>它重用不同语境中的共同元素，具有名词（术语）和动词（运算符）的概念，是上下文敏感的（在日常意义上，不一定在计算机科学解释中），因此符号可以具有不同的含义取决于名词或动词是否是预期的。</p>
</div>
<div class="paragraph">
<p>它也是自同步的，因此解析器可以检测大多数常见错误并提供良好的错误消息。</p>
</div>
<div class="sect2">
<h3 id="_词法约定_2">65.1. 词法约定</h3>
<div class="paragraph">
<p>Raku 代码是 Unicode 文本。当前的实现支持 UTF-8 作为输入编码。</p>
</div>
<div class="paragraph">
<p>也参阅 <a href="https://docs.raku.org/language/unicode_ascii">Unicode versus ASCII symbols</a>.</p>
</div>
<div class="sect3">
<h4 id="_自由形式_2">65.1.1. 自由形式</h4>
<div class="paragraph">
<p>Raku 代码也是自由格式的，从某种意义上说，你可以自由选择你使用的空格量，尽管在某些情况下，空格的存在与否具有意义。</p>
</div>
<div class="paragraph">
<p>所以你可以写</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if True {
    say "Hello";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    if True {
say "Hello"; # Bad indentation intended
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>或</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if True { say "Hello" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者甚至</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if True {say "Hello"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然你不能省略任何剩余的空白。</p>
</div>
</div>
<div class="sect3">
<h4 id="_unspace">65.1.2. Unspace</h4>
<div class="paragraph">
<p>在编译器不允许空格的许多地方，只要用反斜杠引用，就可以使用任意数量的空格。不支持 token 中的空格。当编译器生成行号时，未空格的换行仍然计算。用于非空格的用例是后缀运算符和例程参数列表的分离。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub alignment(+@l) { +@l };
sub long-name-alignment(+@l) { +@l };
alignment\         (1,2,3,4).say;
long-name-alignment(3,5)\   .say;
say Inf+Inf\i;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，我们的目的是让 <code>.</code> 两个语句以及括号都对齐，所以我们在用于填充的空格之前加上 <code>\</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_用分号分割语句">65.1.3. 用分号分割语句</h4>
<div class="paragraph">
<p>Raku 程序是一组由分号 <code>;</code> 分割的语句。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "Hello";
say "world";</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一个语句之后（或在块内的最终语句之后）的分号是可选的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "Hello";
say "world"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if True {
    say "Hello"
}
say "world"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_隐式分隔符规则对于以块结尾的语句">65.1.4. 隐式分隔符规则（对于以块结尾的语句）</h4>
<div class="paragraph">
<p>以裸块结尾的完整语句可以省略尾随分号，如果同一行上没有其他语句跟随块的结束大括号 <code>}</code>。 这称为“隐式分隔符规则”。例如，您不需要在 <code>if</code> 语句块之后写一个分号，如上所示，以及下面所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if True { say "Hello" }
say "world";</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，需要使用分号将块与同一行中的尾随语句分开。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if True { say "Hello" }; say "world";
#                     ^^^ this ; is required</code></pre>
</div>
</div>
<div class="paragraph">
<p>此隐式语句分隔符规则除了控制语句之外还以其他方式应用，可能以裸块结束。例如，结合冒号：方法调用的语法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @names = &lt;Foo Bar Baz&gt;;
my @upper-case-names = @names.map: { .uc }    # OUTPUT: [FOO BAR BAZ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于属于同一 <code>if/elsif/else</code>（或类似）构造的一系列块，隐式分隔符规则仅适用于该系列的最后一个块的末尾。这三个是等价的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if True { say "Hello" } else { say "Goodbye" }; say "world";
#                                            ^^^ this ; is required</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if True { say "Hello" } else { say "Goodbye" } # &lt;- implied statement separator
say "world";</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if True { say "Hello" }   # still in the middle of an if/else statement
else    { say "Goodbye" } # &lt;- no semicolon required because it ends in a block
                          #    without trailing statements in the same line
say "world";</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_注释_4">65.1.5. 注释</h4>
<div class="paragraph">
<p>注释是程序文本的一部分，仅供人类读者阅读; Raku 编译器不会将它们当作程序文本。</p>
</div>
<div class="paragraph">
<p>在缺少或存在空白消除可能的解析的地方，注释计为空格。</p>
</div>
<div class="sect4">
<h5 id="_单行注释">单行注释</h5>
<div class="paragraph">
<p>Raku 中最常见的注释形式以单个哈希字符 <code>#</code> 开头，直到该行的结尾。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if $age &gt; 250 {     # catch obvious outliers
    # this is another comment!
    die "That doesn't look right"
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_多行_嵌套注释">多行 / 嵌套注释</h5>
<div class="paragraph">
<p>多行和嵌入式注释以井号字符开头，然后是反引号，然后是一些开口括号字符，并以匹配的闭合括号字符结束。内容不仅可以跨越多行，还可以嵌入内联。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">if #`( why would I ever write an inline comment here? ) True {
    say "something stupid";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些注释可以扩展到多行</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">#`[
And this is how a multi would work.
That says why we do what we do below.
]
say "No more";</code></pre>
</div>
</div>
<div class="paragraph">
<p>注释中的大括号可以嵌套，因此在  #<code>{ a { b } c }, 中，注释一直持续到字符串的最后。 您也可以使用多个花括号，例如 #</code>{{ double-curly-brace }}，这可能有助于消除嵌套分隔符的歧义。 您可以在表达式中嵌入这些注释，只要不将它们插入关键字或标识符的中间即可。</p>
</div>
</div>
<div class="sect4">
<h5 id="_pod_注释_2">Pod 注释</h5>
<div class="paragraph">
<p>Pod 语法可用于多行注释</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "this is code";

=begin comment

Here are several
lines
of comment

=end comment

say 'code again';</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_标识符_2">65.1.6. 标识符</h4>
<div class="paragraph">
<p>标识符是语法构建块，可用于为实体/对象赋予名称，例如常量，变量（例如标量）和例程（例如，Subs 和方法）。在变量名中，任何sigil（和twigil）都在标识符之前，并且不形成其一部分。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant c = 299792458;     # identifier "c" names an Int
my $a = 123;                # identifier "a" in the name "$a" of a Scalar
sub hello { say "Hello!" }; # identifier "hello" names a Sub</code></pre>
</div>
</div>
<div class="paragraph">
<p>标识符有不同的形式：普通标识符，扩展标识符和复合标识符。</p>
</div>
<div class="sect4">
<h5 id="_普通标识符">普通标识符</h5>
<div class="paragraph">
<p>普通标识符由前导字母字符组成，后面可以跟着一个或多个字母数字字符。它也可能包含单独的，嵌入的撇号 <code>'</code> 和/或连字符 <code>-</code>,  前提是下一个字符每次都是字母。</p>
</div>
<div class="paragraph">
<p>“字母”和“字母数字”的定义包括适当的 Unicode 字符。哪些字符“合适”取决于实现。在 Rakudo/MoarVM Raku 实现中，字母字符包括具有 Unicode 通用类别值 Letter(L) 和下划线 <code>_</code> 的字符。字母数字字符还包括具有 Unicode 通用类别值编号，十进制数字(Nd) 的字符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># valid ordinary identifiers:
x
_snake_oil
something-longer
with-numbers1234
don't-do-that
piece_of_π
駱駝道              # "Rakuda-dō", Japanese for "Way of the camel"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># invalid ordinary identifiers:
42                 # identifier does not start with alphabetic character
with-numbers1234-5 # embedded hyphen not followed by alphabetic character
is-prime?          # question mark is not alphanumeric
x²                 # superscript 2 is not alphanumeric (explained above)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_扩展标识符">扩展标识符</h5>
<div class="paragraph">
<p>使名称包含普通标识符中不允许的字符通常很方便。用例包括一组实体共享一个共同的“短”名称但仍需要单独识别其每个元素的情况。例如，您可以使用短名称为 <code>Dog</code> 的模块，而其长名称包括其命名所有权和版本号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Dog:auth&lt;Somebody&gt;:ver&lt;1.0&gt;  # long module names including author and version
Dog:auth&lt;Somebody&gt;:ver&lt;2.0&gt;

use Dog:auth&lt;Somebody&gt;:ver&lt;2.0&gt;;
# Selection of second module causes its full name to be aliased to the
# short name for the rest of # the lexical scope, allowing a declaration
# like this.
my Dog $spot .= new("woof");</code></pre>
</div>
</div>
<div class="paragraph">
<p>类似地，运算符集在各种语法类别中一起工作，其名称如 prefix，infix 和 postfix。这些运算符的官方名称通常包含从普通标识符中排除的字符。长名称是扩展标识符的构成，包括这个句法类别;短名称将包含在定义中的引号中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">infix:&lt;+&gt;                 # the official name of the operator in $a + $b
infix:&lt;*&gt;                 # the official name of the operator in $a * $b
infix:«&lt;=»                # the official name of the operator in $a &lt;= $b</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于所有此类用途，您可以将一个或多个冒号分隔的字符串附加到普通标识符，以创建所谓的扩展标识符。 附加到标识符（即后缀位置）时，此冒号分隔的字符串会生成该标识符的唯一变体。</p>
</div>
<div class="paragraph">
<p>这些字符串的格式为 <code>:key&lt;value&gt;</code>，其中 key 或 value 是可选的; 也就是说，在将它与常规标识符分开的冒号之后，将存在一个键和/或引用包围结构，例如 &lt;&gt;，«» 或 [' ']，它引用一个或多个任意字符值。[1]</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># exemplary valid extended identifiers:
postfix:&lt;²&gt;               # the official long name of the operator in $x²
WOW:That'sAwesome
WOW:That's&lt;&lt;🆒&gt;&gt;
party:sweet<i class="conum" data-value="16"></i><b>(16)</b>

# exemplary invalid extended identifiers:
party:16&lt;sweet&gt;           # 16 is not an ordinary identifier
party:16sweet
party:!a                  # ...and neither is !a
party:$a                  # ...nor $a</code></pre>
</div>
</div>
<div class="paragraph">
<p>在扩展标识符中，后缀字符串被视为名称的组成部分，因此 <code>infix:&lt;+&gt;</code> 和 <code>infix:&lt;&#8594;</code> 是两个不同的运算符。但是，使用的包围字符不算作其中的一部分;只有引用的数据很重要。所以这些都是同一个名字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">infix:&lt;+&gt;
infix:&lt;&lt;+&gt;&gt;
infix:«+»
infix:['+']
infix:('+')</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，所有这些都有效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $foo:bar&lt;baz&gt; = 'quux';
say $foo:bar«baz»;                               # OUTPUT: «quux␤»
my $take-me:&lt;home&gt; = 'Where the glory has no end';
say $take-me:['home'];                           # OUTPUT: «Where [...]␤»
my $foo:bar&lt;2&gt; = 5;
say $foo:bar(1+1);                               # OUTPUT: «5␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果扩展标识符包含两个或更多个冒号对，则它们的顺序通常很重要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a:b&lt;c&gt;:d&lt;e&gt; = 100;
my $a:d&lt;e&gt;:b&lt;c&gt; = 200;
say $a:b&lt;c&gt;:d&lt;e&gt;;               # OUTPUT: «100␤», NOT: «200␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>此规则的一个例外是模块版本控制;所以这些标识符有效地命名相同的模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use ThatModule:auth&lt;Somebody&gt;:ver&lt;2.7.18.28.18&gt;
use ThatModule:ver&lt;2.7.18.28.18&gt;:auth&lt;Somebody&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，扩展标识符支持编译时插值;这需要使用常量作为插值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant $c = 42;  # Constant binds to Int; $-sigil enables interpolation
my $a:foo&lt;42&gt; = "answer";
say $a:foo«$c»;    # OUTPUT: «answer␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然引用包围结构在标识符的上下文中通常是可互换的，但它们并不相同。特别是，尖括号 <code>&lt;&gt;</code>（模仿单引号插值特征）不能用于常量名称的插值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant $what = 'are';
my @we:&lt;are&gt;= &lt;the champions&gt;;
say @we:«$what»;     # OUTPUT: «[the champions]␤»
say @we:&lt;$what&gt;;
# Compilation error: Variable '@we:&lt;$what&gt;' is not declared</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_组合标识符">组合标识符</h5>
<div class="paragraph">
<p>复合标识符是由两个或多个普通和/或扩展标识符组成的标识符，这些标识符通过双冒号 <code>::</code> 彼此分开。</p>
</div>
<div class="paragraph">
<p>双冒号 <code>::</code> 被称为命名空间分隔符或包分隔符，它在名称中阐明了它的语义功能：强制将名称的前一部分视为包名/命名空间，名称的后续部分通过该包/命名空间位于：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">module MyModule {               # declare a module package
    our $var = "Hello";         # declare package-scoped variable
}
say $MyModule::var              # OUTPUT: «Hello␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中，<code>MyModule::var</code> 是一个复合标识符，由包名称标识符 <code>MyModule</code> 和变量名称 <code>var</code> 的标识符部分组成。加在一块, <code>$MyModule::var</code> 通常被称为包限定名。</p>
</div>
<div class="paragraph">
<p>使用双冒号分隔标识符会导致最右边的名称插入到现有包（参见上面的示例）或自动创建的包中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $foo::bar = 1;
say OUR::.keys;           # OUTPUT: «(foo)␤»
say OUR::foo.HOW          # OUTPUT: «Raku::Metamodel::PackageHOW.new␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后几行显示了如何自动创建 <code>foo</code> 包，作为该命名空间中变量的存放。</p>
</div>
<div class="paragraph">
<p>双冒号语法允许使用 <code>::($expr)</code> 将字符串运行时插入到包或变量名中，您通常会在其中放置包或变量名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $buz = "quux";
my $bur::quux = 7;
say $bur::($buz);               # OUTPUT: «7␤»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_项_term">65.1.7. 项 term:&lt;&gt;</h4>
<div class="paragraph">
<p>您可以使用 <code>term:&lt;&gt;</code> 来引入新的项，这对于引入违反常规标识符规则的常量非常方便：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use Test; plan 1; constant &amp;term:&lt;👍&gt; = &amp;ok.assuming(True);
👍
# OUTPUT: «1..1␤ok 1 - ␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是项不必是常量：您也可以将它们用于不带任何参数的函数，并强制解析器在它们之后期望运算符。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub term:&lt;dice&gt; { (1..6).pick };
say dice + dice;</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以打印 2 到 12 之间的任何数字。</p>
</div>
<div class="paragraph">
<p>相反，我们已经声明 dice 为常规子例程</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub dice() {(1...6).pick }</code></pre>
</div>
</div>
<div class="paragraph">
<p>表达式 <code>dice + dice</code> 将被解析为 <code>dice(+(dice()))</code>，导致错误，因为子 <code>dice</code> 需要零个参数。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_语句和表达式">65.2. 语句和表达式</h3>
<div class="paragraph">
<p>Raku 程序由一组组成。语句的一个特例是表达式，它返回一个值。例如，` if True { say 42 }` 在语法上是一个语句，而不是一个表达式，而 <code>1 + 2</code> 是一个表达式（因此也是一个语句）。</p>
</div>
<div class="paragraph">
<p><code>do</code> 前缀将语句转换为表达式。所以虽然</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = if True { 42 };     # Syntax error!</code></pre>
</div>
</div>
<div class="paragraph">
<p>是一个错误,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x = do if True { 42 };</code></pre>
</div>
</div>
<div class="paragraph">
<p>将 <code>if</code> 语句（此处为 42）的返回值赋给变量 <code>$x</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_项_2">65.3. 项</h3>
<div class="paragraph">
<p>项是基本名词，可选地与运算符一起形成表达式。项的示例是变量（<code>$x</code>），诸如类型名称（Int），字面量（42），声明（<code>sub f() { }</code>）和调用（<code>f()</code>）之类的裸字。</p>
</div>
<div class="paragraph">
<p>例如，在表达式 <code>2 * $salary</code> 中，<code>2</code> 和 <code>$salary</code> 是两个项（整数字面量和变量）。</p>
</div>
<div class="sect3">
<h4 id="_变量_4">65.3.1. 变量</h4>
<div class="paragraph">
<p>变量通常以称为 sigil 的特殊字符开头，后跟一个标识符。必须先声明变量才能使用它们。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># declaration:
my $number = 21;
# usage:
say $number * 2;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅变量文档。</p>
</div>
</div>
<div class="sect3">
<h4 id="_裸字_常量类型名">65.3.2. 裸字 (常量,类型名)</h4>
<div class="paragraph">
<p>预先声明的标识符可以是它们自己的术语。这些通常是类型名称或常量，但也是术语 <code>self</code>，它指的是调用方法的对象（请参阅对象）和无符号变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Int;                # OUTPUT: «(Int)␤»
#   ^^^ type name (built in)

constant answer = 42;
say answer;
#   ^^^^^^ constant

class Foo {
    method type-name {
        self.^name;
      # ^^^^ built-in term 'self'
    }
}
say Foo.type-name;     # OUTPUT: «Foo␤»
#   ^^^ type name</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_包和限定名">65.3.3. 包和限定名</h4>
<div class="paragraph">
<p>命名实体（如变量，常量，类，模块或子）是命名空间的一部分。名称的嵌套部分使用 <code>::</code> 来分隔层次结构。一些例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$foo                # simple identifiers
$Foo::Bar::baz      # compound identifiers separated by ::
$Foo::($bar)::baz   # compound identifiers that perform interpolations
Foo::Bar::bob(23)   # function invocation given qualified name</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅包中的文档。</p>
</div>
</div>
<div class="sect3">
<h4 id="_字面量">65.3.4. 字面量</h4>
<div class="paragraph">
<p>字面量是源代码中常量值的表示。 Raku 具有几种内置类型的字面量，如字符串，几种数字类型，pair 对儿等等。</p>
</div>
<div class="sect4">
<h5 id="_字符串字面量_2">字符串字面量</h5>
<div class="paragraph">
<p>字符串字面量用引号括起来：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say 'a string literal';
say "a string literal\nthat interprets escape sequences";</code></pre>
</div>
</div>
<div class="paragraph">
<p>请参阅引用以获取更多选项，包括转义引用 <code>q</code>。 Raku 在字面量中使用标准转义字符 \a \b \t \n \f \r \e, 与设计文档中指定的 ASCII 转义码具有相同的含义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "🔔\a";  # OUTPUT: «🔔␇␤»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_数字字面量">数字字面量</h5>
<div class="paragraph">
<p>数字字面量通常用十进制表示（除非前缀为 <code>0x</code>（十六进制，基数为16），<code>0o</code>（八进制，基数为8）或 <code>0b</code>（二进制，基数为2），否则可以通过前缀0d逐字地使用（如果需要，可以使用前缀 <code>0d</code>）。 ）或状语符号中的显式基数，如 <code>:16&lt;A0&gt;</code> 另有说明。与其他编程语言不同，前导零不表示基数 8;而是发出编译时警告。</p>
</div>
<div class="paragraph">
<p>在所有字面量格式中，你可以使用下划线来分组数字;他们没有任何语义信息;以下字面量都计算为相同的数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1000000
1_000_000
10_00000
100_00_00</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_int_字面量">Int 字面量</h5>
<div class="paragraph">
<p>整数默认为有符号十进制的，但您可以使用其他基数。有关详细信息，请参阅 Int。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># actually not a literal, but unary - operator applied to numeric literal 2
-2
12345
0xBEEF      # base 16
0o755       # base 8
:3&lt;1201&gt;    # arbitrary base, here base 3</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_rat_字面量">Rat 字面量</h5>
<div class="paragraph">
<p>Rat 字面量（有理数）非常常见，取代许多其他语言中的小数或浮点数。整除也会产生 Rat。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1.0
3.14159
-2.5        # Not actually a literal, but still a Rat
:3&lt;21.0012&gt; # Base 3 rational
⅔
2/3         # Not actually a literal, but still a Rat</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_num_字面量">Num 字面量</h5>
<div class="paragraph">
<p>在 <code>e</code> 产生浮点数后，使用整数指数到十进制的科学记数法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1e0
6.022e23
1e-9
-2e48
2e2.5       # error</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_complex_字面量">Complex 字面量</h5>
<div class="paragraph">
<p>复数可以写为虚数（只是附加后缀 <code>i</code> 的有理数），也可以是实数和虚数之和：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1+2i
6.123e5i    # note that this is 6.123e5 * i, not 6.123 * 10 ** (5i)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_pair_字面量">Pair 字面量</h5>
<div class="paragraph">
<p>对由键和值组成，构造它们有两种基本形式：<code>key &#8658; 'value'</code> 和 <code>:key('value')</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_arrow_pairs">Arrow pairs</h5>
<div class="paragraph">
<p>箭头对可以有一个表达式，一个字符串字面量或一个“裸标识符”，这是一个普通标识符语法的字符串，左侧不需要引号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">like-an-identifier-ain't-it =&gt; 42
"key" =&gt; 42
('a' ~ 'b') =&gt; 1</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_副词对儿_colon_pairs">副词对儿 (colon pairs)</h5>
<div class="paragraph">
<p>没有显式值的简短形式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $thing = 42;
:$thing                 # same as  thing =&gt; $thing
:thing                  # same as  thing =&gt; True
:!thing                 # same as  thing =&gt; False</code></pre>
</div>
</div>
<div class="paragraph">
<p>变量形式也适用于其他符号，例如：<code>:&amp;callback</code> 或 <code>:@elements</code>。如果值是数字字面量，它也可以用这种简短形式表示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">:42thing            # same as  thing =&gt; 42
:٤٢thing            # same as  thing =&gt; 42</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用其他字母，则此顺序将被反转：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">:٤٢ث              # same as   ث =&gt; ٤٢</code></pre>
</div>
</div>
<div class="paragraph">
<p>thaa 字母在数字之前。</p>
</div>
<div class="paragraph">
<p>具有显式值的长形式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">:thing($value)              # same as  thing =&gt; $value
:thing&lt;quoted list&gt;         # same as  thing =&gt; &lt;quoted list&gt;
:thing['some', 'values']    # same as  thing =&gt; ['some', 'values']
:thing{a =&gt; 'b'}            # same as  thing =&gt; { a =&gt; 'b' }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_boolean_字面量">Boolean 字面量</h5>
<div class="paragraph">
<p>True 和 False 是 Boolean 字面量; 他们始终是首字母大写的。</p>
</div>
</div>
<div class="sect4">
<h5 id="_array_字面量">Array 字面量</h5>
<div class="paragraph">
<p>一对方括号可以围绕表达式以形成逐项数组字面量; 通常在里面有一个以逗号分隔的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ['a', 'b', 42].join(' ');   # OUTPUT: «a b 42␤»
#   ^^^^^^^^^^^^^^ Array constructor</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果构造函数被赋予单个 Iterable，它将克隆并展平它。如果你想要一个只有 1 个 Iterable 元素的数组，请确保在它之后使用逗号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 2;
say [@a].perl;  # OUTPUT: «[1, 2]␤»
say [@a,].perl; # OUTPUT: «[[1, 2],]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>Array 构造函数不会展平其他类型的内容。使用 Slip 前缀运算符(<code>|</code>)展平所需项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = 1, 2;
say [@a, 3, 4].perl;  # OUTPUT: «[[1, 2], 3, 4]␤»
say [|@a, 3, 4].perl; # OUTPUT: «[1, 2, 3, 4]␤»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_hash_字面量">Hash 字面量</h5>
<div class="paragraph">
<p>一个前导的关联符号和一对括号 <code>%( )</code> 可以包围一对列表以形成一个哈希字面量; 通常在里面有一个以逗号分隔的 Pairs 列表。如果使用非 pair 对，则假定它是一个键，下一个元素是值。大多数情况下，它与简单的箭头对一起使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %( a =&gt; 3, b =&gt; 23, :foo, :dog&lt;cat&gt;, "french", "fries" );
# OUTPUT: «a =&gt; 3, b =&gt; 23, dog =&gt; cat, foo =&gt; True, french =&gt; fries␤»

say %(a =&gt; 73, foo =&gt; "fish").keys.join(" ");   # OUTPUT: «a foo␤»
#   ^^^^^^^^^^^^^^^^^^^^^^^^^ Hash constructor</code></pre>
</div>
</div>
<div class="paragraph">
<p>当赋值给左侧的 <code>%</code> sigiled 变量时，右侧 Pairs 周围的符号和括号是可选的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %ages = fred =&gt; 23, jean =&gt; 87, ann =&gt; 4;</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下, <code>%( )</code> 中的键被强制为字符串。要使用非字符串键组合散列，请使用带有冒号前缀的花括号分隔符 <code>:{}</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $when = :{ (now) =&gt; "Instant", (DateTime.now) =&gt; "DateTime" };</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，将对象作为键，您不能将非字符串键作为字符串访问：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say :{ -1 =&gt; 41, 0 =&gt; 42, 1 =&gt; 43 }&lt;0&gt;;  # OUTPUT: «(Any)␤»
say :{ -1 =&gt; 41, 0 =&gt; 42, 1 =&gt; 43 }{0};  # OUTPUT: «42␤»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_regex_字面量">Regex 字面量</h5>
<div class="paragraph">
<p>使用 <code>/foo/</code> 等斜杠声明正则表达式。请注意，此 <code>//</code> 语法是完整的 <code>rx//</code> 语法的简写。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">/foo/          # Short version
rx/foo/        # Longer version
Q :regex /foo/ # Even longer version

my $r = /foo/; # Regexes can be assigned to variables</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_签名字面量">签名字面量</h5>
<div class="paragraph">
<p>除了 sub 和块声明中的典型用法之外，签名可以单独用于模式匹配。从冒号开始声明独立签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "match!" if 5, "fish" ~~ :(Int, Str); # OUTPUT: «match!␤»

my $sig = :(Int $a, Str);
say "match!" if (5, "fish") ~~ $sig; # OUTPUT: «match!␤»

given "foo", 42 {
  when :(Str, Str) { "This won't match" }
  when :(Str, Int $n where $n &gt; 20) { "This will!" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关签名的更多信息，请参阅签名文档。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_声明_2">65.3.5. 声明</h4>
<div class="sect4">
<h5 id="_变量声明">变量声明</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $x;                          # simple lexical variable
my $x = 7;                      # initialize the variable
my Int $x = 7;                  # declare the type
my Int:D $x = 7;                # specify that the value must be defined (not undef)
my Int $x where { $_ &gt; 3 } = 7; # constrain the value based on a function
my Int $x where * &gt; 3 = 7;      # same constraint, but using Whatever shorthand</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关其他作用域的更多详细信息，请参阅变量声明符和作用域（<code>our</code>，<code>has</code>）。</p>
</div>
</div>
<div class="sect4">
<h5 id="_子例程声明">子例程声明</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># The signature is optional
sub foo { say "Hello!" }

sub say-hello($to-whom) { say "Hello $to-whom!" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以将子例程赋值给变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;f = sub { say "Hello!" } # Un-named sub
my &amp;f = -&gt; { say "Hello!" }  # Lambda style syntax. The &amp; sigil indicates the variable holds a function
my $f = -&gt; { say "Hello!" }  # Functions can also be put into scalars</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_包_模块_类_角色_和_grammar_声明">包, 模块, 类, 角色 和 Grammar 声明</h5>
<div class="paragraph">
<p>有几种类型的包，每种类型都使用关键字，名称，一些可选特征以及子例程，方法或规则体声明。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">package P { }

module M { }

class C { }

role R { }

grammar G { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在单个文件中声明多个包。但是，您可以在文件的开头声明一个单元包（仅在注释或 <code>use</code> 语句之前），并且该文件的其余部分将被视为包的主体。在这种情况下，不需要花括号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">unit module M;
# ... stuff goes here instead of in {}'s</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_多重分派的声明">多重分派的声明</h5>
<div class="paragraph">
<p>另请参见多重分派。</p>
</div>
<div class="paragraph">
<p>可以使用多个签名声明同名子例程。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub foo() { say "Hello!" }
multi sub foo($name) { say "Hello $name!" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>在类里面, 你还可以声明多重分派方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi method greet { }
multi method greet(Str $name) { }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_子例程调用">65.3.6. 子例程调用</h4>
<div class="paragraph">
<p>子程序使用关键字 <code>sub</code> 创建，后跟可选名称，可选签名和代码块。子例程是词法作用域的，因此如果在声明时指定了名称，则可以在词法作用域中使用相同的名称来调用子例程。子例程是 <code>Sub</code> 类型的实例，可以赋值给任何容器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">foo;   # Invoke the function foo with no arguments
foo(); # Invoke the function foo with no arguments
&amp;f();  # Invoke &amp;f, which contains a function
&amp;f.(); # Same as above, needed to make the following work
my @functions = ({say 1}, {say 2}, {say 3});
@functions&gt;&gt;.(); # hyper method call operator</code></pre>
</div>
</div>
<div class="paragraph">
<p>当在类中声明时，子例程被命名为“方法”：方法是针对对象（即，类实例）调用的子例程。在方法中，特殊变量 <code>self</code> 包含对象实例（请参阅方法）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># Method invocation. Object (instance) is $person, method is set-name-age
$person.set-name-age('jane', 98);   # Most common way
$person.set-name-age: 'jane', 98;   # Precedence drop
set-name-age($person: 'jane', 98);  # Invocant marker
set-name-age $person: 'jane', 98;   # Indirect invocation</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多信息，请参阅函数。</p>
</div>
<div class="sect4">
<h5 id="_优先级下降">优先级下降</h5>
<div class="paragraph">
<p>在方法调用的情况下（即，在针对类实例调用子例程时），可以应用由冒号标识的优先级下降：在方法名称之后和参数列表之前。参数列表优先于方法调用，另一方面“降低”其优先级。为了更好地理解，请考虑以下简单示例（仅添加额外空格以对齐方法调用）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $band = 'Foo Fighters';
say $band.substr( 0, 3 ) .substr( 0, 1 ); # F
say $band.substr: 0, 3   .substr( 0, 1 ); # Foo</code></pre>
</div>
</div>
<div class="paragraph">
<p>在第二种方法调用中，最右边的 <code>substr</code> 应用于“3”，而不是最左边的 substr 的结果，另一方面，它产生优先级最右边的 substr。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_运算符_3">65.3.7. 运算符</h4>
<div class="paragraph">
<p>有关详细信息，请参阅运算符。</p>
</div>
<div class="paragraph">
<p>运算符是具有更多符号重和可组合语法的函数。与其他函数一样，运算符可以进行多重分派以允许特定于上下文的使用。</p>
</div>
<div class="paragraph">
<p>运算符有五种类型（排列），每种类型都有一个或两个参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">++$x           # prefix, operator comes before single input
5 + 3          # infix, operator is between two inputs
$x++           # postfix, operator is after single input
&lt;the blue sky&gt; # circumfix, operator surrounds single input
%foo&lt;bar&gt;      # postcircumfix, operator comes after first input and surrounds second</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_元运算符">元运算符</h5>
<div class="paragraph">
<p>运算符可以组合。一个常见的例子是将中缀（二元）运算符与赋值相结合。您可以将赋值与任何二元运算符组合。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$x += 5     # Adds 5 to $x, same as $x = $x + 5
$x min= 3   # Sets $x to the smaller of $x and 3, same as $x = $x min 3
$x .= child # Equivalent to $x = $x.child</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>[ ]</code> 中包装中缀运算符以创建一个新的化简运算符，该运算符在单个输入列表上工作，从而产生单个值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say [+] &lt;1 2 3 4 5&gt;;    # OUTPUT: «15␤»
(((1 + 2) + 3) + 4) + 5 # equivalent expanded version</code></pre>
</div>
</div>
<div class="paragraph">
<p>用 <code>« »</code>（或等效的 ASCII）包装一个中缀运算符，以创建一个在两个列表上成对工作的新超运算符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &lt;1 2 3&gt; «+» &lt;4 5 6&gt; # OUTPUT: «(5 7 9)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>箭头的方向表示当列表的大小不同时该怎么做。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">@a «+« @b # Result is the size of @b, elements from @a will be re-used
@a »+» @b # Result is the size of @a, elements from @b will be re-used
@a «+» @b # Result is the size of the biggest input, the smaller one is re-used
@a »+« @b # Exception if @a and @b are different sizes</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用超运算符包装一元运算符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say -« &lt;1 2 3&gt; # OUTPUT: «(-1 -2 -3)␤»</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_系统交互">66. 系统交互</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_通过命令行获取参数">66.1. 通过命令行获取参数</h3>
<div class="paragraph">
<p>最简单的方法是使用 <a href="https://docs.raku.org/language/variables#%2524%252AARGS"><code>@*ARGS</code></a> 变量从命令行获取参数;此数组将包含程序名称后面的字符串。 <a href="https://docs.raku.org/language/variables#Runtime_environment"><code>%*ENV</code></a> 将包含环境变量，因此如果您使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">export API_KEY=1967196417966160761fabc1511067
./consume_api.p6</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过以下方式在程序中使用它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $api-key = %*ENV&lt;API_KEY&gt; // die "Need the API key";</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果先前未定义环境变量 <code>API_KEY</code>，则此操作将失败。</p>
</div>
<div class="paragraph">
<p>Raku 有一个更好的方法来处理命令行参数，如果它们代表文件名：那么使用 <a href="https://docs.raku.org/language/variables#%2524%252AARGFILES"><code>$*ARGFILES</code></a> 动态变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for $*ARGFILES.lines -&gt; $l {
    say "Long lines in {$*ARGFILES.path}"
        if $l.chars &gt; 72 ;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如，你可以用 <code>argf​​iles.p6 *.p6</code> 的方式运行这个程序，每次找到一个超过72个字符的行时，它就会打印一个文件名。 <code>$*ARGFILES</code> 包含命令行中描述的所有文件的文件句柄 -  <code>.lines</code> 将依次读取每行文件的一行，每次处理新句柄时都会更改 <code>$*ARGFILES.path</code> 的值。通常，它为处理文件集的脚本提供了非常方便的 API。</p>
</div>
</div>
<div class="sect2">
<h3 id="_以交互方式获取参数">66.2. 以交互方式获取参数</h3>
<div class="paragraph">
<p>使用 <code>prompt</code> 让一个正在运行的程序向用户查询数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my UInt $num-iters = prompt "How many iterations to run: ";</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_同步和异步运行程序">66.3. 同步和异步运行程序</h3>
<div class="paragraph">
<p>运行外部程序有两个例程：<a href="https://docs.raku.org/routine/run"><code>run</code></a> 和 <a href="https://docs.raku.org/routine/shell"><code>shell</code></a>。两者都存在于 <a href="https://docs.raku.org/type/IO"><code>IO</code></a> 角色中，因此包含在混合该角色的所有类中，如 <a href="https://docs.raku.org/type/IO::Path">IO::Path</a>。两者都返回一个 <a href="https://docs.raku.org/type/Proc">Proc</a> 对象，但主要区别在于 <code>run</code> 会尽可能避免系统 shell，而 <code>shell</code> 会通过默认系统 shell 运行命令。</p>
</div>
<div class="paragraph">
<p>运行所有外部程序的关键类是 <a href="https://docs.raku.org/type/Proc::Async">Proc::Async</a>，它以异步方式运行进程，并允许与正在运行的进程进行<a href="https://docs.raku.org/language/concurrency#Proc%3A%3AAsync">并发</a>交互。通常，通过这些高级抽象接口与系统进行交互是一种很好的做法。但是，Raku 提供了通过低级接口与系统交互的其他方式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_通过原生_api_进行操作系统调用">66.4. 通过原生 API 进行操作系统调用</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/language/nativecall"><code>NativeCall</code></a> 可用于与系统库以及任何其他可访问库进行交互。这个link:(<a href="https://docs.raku.org/language/nativecall#Short_tutorial_on_calling_a_C_function">简短的教程</a>)解释了，例如，如何使用该接口调用系统函数，如 <code>getaddrinfo</code>;通过使用 NativeCall 接口的声明，也可以通过这种方式访问​​其他一些函数，例如 <a href="https://docs.raku.org/language/5to6-perlfunc#kill"><code>kill</code></a>。</p>
</div>
<div class="paragraph">
<p>幸运的是，您不必为所有原生功能执行此操作。作为将 Perl 5 作为生态系统的一部分移植到 Raku 的蝴蝶项目的一部分，<a href="https://github.com/lizmat">Elizabeth Mattijsen</a> 正在将许多系统功能移植到 <a href="https://github.com/lizmat/P5getprotobyname"><code>P5getprotobyname</code></a> 等模块中，这些功能包括 <code>endprotoent</code>，<code>getprotoent</code>，<code>getprotobyname</code> 等功能。 <code>getprotobynumber</code> 和 <code>setprotoent</code>。如果要使用p6y形式的那些功能，请搜索并安装<a href="https://modules.raku.org/search/?q=p5">P5模块</a>。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_traits_2">67. Traits</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 中，*traits*是附加到对象和类的编译器钩子，它们修改了类和对象的默认行为，功能或表示。作为这样的编译器钩子，它们是在编译时定义的，尽管它们可以用于运行时。</p>
</div>
<div class="paragraph">
<p>通过使用 <code>trait_mod</code> 关键字，已经将几个 traits 定义为语言或 Rakudo 编译器的一部分。接下来列出并解释它们。</p>
</div>
<div class="sect2">
<h3 id="_is_trait">67.1. is trait</h3>
<div class="paragraph">
<p>定义为</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub trait_mod:&lt;is&gt;(Mu $, |) {*}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>is</code> 适用于任何类型的标量对象，并且可以接收任意数量的命名参数或位置参数。它是最常用的 trait，取决于第一个参数的类型，采用以下形式。</p>
</div>
<div class="sect3">
<h4 id="_is_应用于类">67.1.1. <code>is</code> 应用于类</h4>
<div class="paragraph">
<p>最常见的形式涉及两个类，一个正在定义，另一个现有，定义为 <a href="https://docs.raku.org/syntax/is">defines parenthood</a>。  <code>A is B</code>, 如果两个都是类，则将 A 定义为 B 的子类。</p>
</div>
<div class="paragraph">
<p><code>is DEPRECATED</code> 可以应用于类，属性或例程，将它们标记为已弃用并发出警告消息（如果提供了的话）。</p>
</div>
<div class="paragraph">
<p><code>is</code> 的几个实例被直接转换为它们引用的类的属性：<code>rw</code>，<code>nativesize</code>，<code>ctype</code>，<code>unsigned</code>，<code>hidden</code>，<code>array_type</code>。</p>
</div>
<div class="paragraph">
<p>不可实例化的表示 trait 与表示没有多大关系，与特定类可以做什么有关; 它有效地防止以任何可能的方式创建类的实例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant @IMM = &lt;Innie Minnie Moe&gt;;

class don't-instantiate is repr('Uninstantiable') {
    my $.counter;

    method imm () {
        return @IMM[ $.counter++ mod @IMM.elems ];
    }
}
say don't-instantiate.imm for ^10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不能实例化的类仍然可以通过它们的类变量和方法使用, 如上所示。尝试这样: <code>my $do-instantiate = don&#8217;t-instantiate.new;</code> 来实例化它们会产生错误。</p>
</div>
</div>
<div class="sect3">
<h4 id="_is_repr_和原生表示">67.1.2. <code>is repr</code> 和原生表示</h4>
<div class="paragraph">
<p>由于 <code>is</code> trait 通常指的是它们所应用的类或对象的性质，因此它们在link:(<a href="https://docs.raku.org/language/nativecall">原生调用</a>)中被广泛使用，以指定将由原生函数通过 <code>is repr</code> 后缀处理的数据结构的<a href="https://docs.raku.org/language/nativecall#Specifying_the_native_representation">表示</a>。同时，<code>is native</code> 用于通过原生函数实际实现的例程。这些是可以使用的表示：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>CStruct 对应于 C 语言中的 <code>struct</code>。它是一种复合数据结构，包括不同的异构和低级数据结构;请参阅<a href="https://docs.raku.org/language/nativecall#Structs">此示例</a>和进一步说明。</p>
</li>
<li>
<p>类似地，CPPStruct 对应于 C++ 中的 <code>struct</code>。但是，这是暂时是 Rakudo 特定的。</p>
</li>
<li>
<p>CPointer 是任何这些语言的指针。它是一个动态数据结构，必须在使用之前进行实例化，可<a href="https://docs.raku.org/language/nativecall#Basic_use_of_pointers">用于</a>其方法也是原生的类。</p>
</li>
<li>
<p>CUnion 将使用与 C 中的 <code>union</code> 相同的表示形式; 看一下<a href="https://docs.raku.org/language/nativecall#CUnions">这个例子</a>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另一方面，P6opaque 是用于 Raku 中所有对象的默认表示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Thar {};
say Thar.REPR;    #OUTPUT: «P6opaque␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>除非另有说明，否则<a href="https://docs.raku.org/language/mop">元对象协议</a>默认对每个对象和类使用它;因此，除非您有效地使用该接口，否则通常没有必要。</p>
</div>
</div>
<div class="sect3">
<h4 id="_is_作用于例程">67.1.3. <code>is</code> 作用于例程</h4>
<div class="paragraph">
<p><code>is</code> trait 可用于定义方法和例程以建立<a href="https://docs.raku.org/language/functions#Precedence">优先级</a>和<a href="https://docs.raku.org/language/functions#Associativity">关联性</a>。它们充当使用 <a href="https://docs.raku.org/type/Sub#Traits">trait_mod</a> 定义的子元素，该元素将要添加的 trait 的类型和名称作为参数。在子例程的情况下，trait 将是添加跨越类和角色层次结构的功能的一种方式，或者甚至可以用于向独立定义的例程添加行为。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_类型系统">68. 类型系统</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_raku类型的定义">68.1. Raku类型的定义</h3>
<div class="paragraph">
<p>类型通过创建类型对象来定义新对象，该类型对象提供用于创建对象实例或检查值的接口。任何类型对象都是 <a href="https://docs.raku.org/type/Any">Any</a> 或 <a href="https://docs.raku.org/type/Mu">Mu</a> 的子类。通过从这些基类和内省后缀 <a href="https://docs.raku.org/language/operators#postfix_.%5E" target="_blank" rel="noopener">.</a> 继承来提供内省方法。在编译时由以下类型声明符之一或在运行时使用<a href="https://docs.raku.org/language/mop">元对象协议</a>将新类型引入当前作用域。所有类型名称的作用域必须是唯一的。</p>
</div>
<div class="sect3">
<h4 id="_默认类型">68.1.1. 默认类型</h4>
<div class="paragraph">
<p>如果用户没有提供类型，则 Raku 假定类型为 <code>Any</code>。这包括<a href="https://docs.raku.org/language/containers">容器</a>，基类，<a href="https://docs.raku.org/type/Signature#Type_constraints">参数</a>和返回类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = 1;
$a = Nil;
say $a.^name;
# OUTPUT: «Any»

class C {};
say C.^parents(:all);
# OUTPUT: «((Any) (Mu))»</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于容器，默认类型为 <code>Any</code>，但默认类型约束为 <code>Mu</code>。请注意，绑定会替换容器，而不仅仅是值。在这种情况下，类型约束可能会变。</p>
</div>
</div>
<div class="sect3">
<h4 id="_类型对象_2">68.1.2. 类型对象</h4>
<div class="paragraph">
<p>要测试对象是否为类型对象，请对使用类型为 <a href="https://docs.raku.org/type/Signature#Constraining_defined_and_undefined_values">smiley</a> 或 <a href="https://docs.raku.org/language/mop#index-entry-syntax_DEFINITE-DEFINITE"><code>.DEFINITE</code></a> 方法约束的类型使用 <a href="https://docs.raku.org/language/operators#index-entry-smartmatch_operator">smartmatch</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $a = Int;
say $a ~~ Mu:U;
# OUTPUT: «True»
say not $a.DEFINITE;
# OUTPUT: «True»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果调用者是实例，则 <code>.DEFINITE</code> 将返回 <code>True</code>。如果它返回 <code>False</code>，则调用者是一个类型对象。</p>
</div>
<div class="sect4">
<h5 id="_undefinedness">Undefinedness</h5>
<div class="paragraph">
<p>未定义的对象在 Raku 中维护类型信息。类型对象用于表示未定义值和未定义值的类型。要提供一般的未定义值，请使用 <a href="https://docs.raku.org/type/Any">Any</a>。如果要区分容器和参数的默认类型 <code>Any</code>，则需要使用 <code>Mu</code>。</p>
</div>
<div class="paragraph">
<p>由 <a href="https://docs.raku.org/type/Mu#method_CREATE">.CREATE</a> 创建的对象实例是按惯例定义的。方法 <a href="https://docs.raku.org/type/Mu#routine_defined">.defined</a> 将返回 <code>Bool::True</code> 以指示定义。该规则的例外是 <a href="https://docs.raku.org/type/Nil">Nil</a> 和 <a href="https://docs.raku.org/type/Failure">Failure</a>。请注意，任何对象都可以重载 <code>.defined</code>，因此可以携带其他信息。此外，Raku 明确区分了定义和真假。很多值是有定义的, 即使它们具有错误或空值的含义。这些值为 <code>0</code>，<a href="https://docs.raku.org/type/Bool">Bool::False</a>, <a href="https://docs.raku.org/language/operators#term_%28_%29">()</a> (空列表) 和 <a href="https://docs.raku.org/type/Num#NaN">NaN</a>。</p>
</div>
<div class="paragraph">
<p>值可以在运行时通过 <a href="https://docs.raku.org/language/operators#infix_but">mixin</a> 变为未定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int $i = 1 but role::{ method defined { False } };
say $i // "undefined";
# OUTPUT: «undefined»</code></pre>
</div>
</div>
<div class="paragraph">
<p>要测试定义需调用 <code>.defined</code>，请使用 <a href="https://docs.raku.org/language/operators#infix_%2F%2F">//</a>，<a href="https://docs.raku.org/language/control#with%2C_orwith%2C_without">with/without</a> 和 <a href="https://docs.raku.org/type/Signature#Constraining_defined_and_undefined_values">signatures</a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_强制转换">强制转换</h5>
<div class="paragraph">
<p>将一种类型转换为另一种类型是使用与目标类型同名的强制方法完成的。<a href="https://docs.raku.org/type/Signature#Coercion_type">Signatures</a> 强制要求此约定。源类型必须知道如何将自身转换为目标类型。要允许内置类型将自己转换为用户定义的类型，请使用 <a href="https://docs.raku.org/language/variables#The_augment_declarator">augment</a> 或者 <a href="https://docs.raku.org/language/mop">MOP</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class C {
    has $.int;
    method this-is-c { put 'oi' x $!int ~ '‽' }
}

use MONKEY-TYPING;
augment class Int {
    method C { C.new(:int(self))}
}

my $i = 10;
$i.=C;
$i.this-is-c();
# OUTPUT: «oioioioioioioioioioi‽»</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 提供了在 <a href="https://docs.raku.org/type/Cool">Cool</a> 中定义的方法，以便在应用进一步操作之前转换为目标类型。大多数内置类型都来自 <code>Cool</code>，因此可能会提供可能不需要的隐式强制。用户有责任关心这些方法的无陷阱使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $whatever = "123.6";
say $whatever.round;
# OUTPUT: «124»
say &lt;a b c d&gt;.starts-with("ab");
# OUTPUT: «False»</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类型声明符">68.2. 类型声明符</h3>
<div class="paragraph">
<p>类型声明符将新类型引入给定作用域。嵌套作用域可以用 <code>::</code> 分隔。如果不存在此类作用域，则会自动创建新 <a href="https://docs.raku.org/language/packages">packages</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Foo::Bar::C {};
put Foo::Bar::.keys;
# OUTPUT: «C»</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用仅包含 <code>&#8230;&#8203;</code> 的块来提供前置声明。如果定义了类型，编译器将在当前作用域的末尾检查。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class C {...}
# many lines later
class C { has $.attr }</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_class">68.2.1. class</h4>
<div class="paragraph">
<p><code>class</code> 声明符创建一个编译为类型对象的编译时构造。后者是一个简单的 Raku 对象，它提供了通过执行初始化程序和子方法来构造实例的方法，以填充在类中声明的所有属性，以及任何具有值的父类。初始化程序可以提供属性声明或构造函数。 <a href="https://docs.raku.org/type/Metamodel::ClassHOW">Metamodel::ClassHOW</a> 负责知道如何运行它们。这是在 Raku 中构建对象的唯一神奇部分。默认父类型是 <code>Any</code>，它继承自 <code>Mu</code>。后者提供了默认的按照惯例命名的构造函数 <code>.new</code>。除此之外，<code>.new</code> 不具有任何特殊含义，也不以任何特殊方式对待。</p>
</div>
<div class="paragraph">
<p>有关如何使用类的更多信息，请参阅<a href="https://docs.raku.org/language/classtut">类和对象</a>教程。</p>
</div>
<div class="sect4">
<h5 id="_mixins">Mixins</h5>
<div class="paragraph">
<p><code>class</code> 引入的类型可以在运行时使用 <a href="https://docs.raku.org/language/operators#infix_but">infix:</a> 进行扩展。原始类型不会被修改，而是返回一个新的类型对象，并且可以存储在一个容器中，该容器对原始类型或混合的角色进行成功类型检查。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {}
role R { method m { say 'oi‽' } }
my R $A = A but R;
my $a1 = $A.new;
$a1.m;
say [$A ~~ R, $a1 ~~ R];
# OUTPUT: «oi‽[True True]»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_自省_2">自省</h5>
<div class="sect5">
<h6 id="_元类">元类</h6>
<div class="paragraph">
<p>要测试给定类型对象是否为类，请针对 <a href="https://docs.raku.org/type/Metamodel::ClassHOW">Metamodel::ClassHOW</a> 测试元对象方法 <code>.HOW</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class C {};
say C.HOW ~~ Metamodel::ClassHOW;
# OUTPUT: «True»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_私有属性">私有属性</h5>
<div class="paragraph">
<p>私有<a href="https://docs.raku.org/type/Attribute">属性</a>用任何一个 <code>$!</code>，<code>@!</code> 和 <code>%!</code> twigils 来处理。它们没有自动生成的公共访问器方法。因此，它们不能从它们所定义的类的外面进行更改。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class C {
    has $!priv;
    submethod BUILD { $!priv = 42 }
};

say (.name, .package, .has_accessor) for C.new.^attributes;
# OUTPUT: «($!priv (C) False)»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_方法_3">方法</h5>
<div class="paragraph">
<p><code>method</code> 声明符定义 <a href="https://docs.raku.org/type/Method">Method</a> 类型的对象，并将其绑定到类的作用域中提供的名称上。默认情况下，类中的方法具有 <code>has</code> 作用域。<code>our</code> 作用域的那些方法默认不会添加到方法缓存中，因此不能使用访问器符号 <code>$.</code> 来调用。使用完全限定名称和调用者作为第一个参数来调用它们。</p>
</div>
<div class="sect5">
<h6 id="_继承和_multis">继承和 multis</h6>
<div class="paragraph">
<p>子类中的普通方法不与父类中的 multis 竞争。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    multi method m(Int $i){ say 'Int' }
    multi method m(int $i){ say 'int' }
}

class B is A {
    method m(Int $i){ say 'B::Int' }
}

my int $i;
B.new.m($i);
# OUTPUT: «B::Int»</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_only_方法">Only 方法</h6>
<div class="paragraph">
<p>要明确声明方法不是 multi 方法，请使用 <code>only</code> 方法声明符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class C {
    only method m {};
    multi method m {};
};
# OUTPUT: «X::Comp::AdHoc: Cannot have a multi candidate for 'm' when an only method is also in the package 'C'»</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_submethod_build">Submethod BUILD</h6>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Submethod">submethod</a> <code>BUILD</code> 是（间接地）由被称为 <a href="https://docs.raku.org/type/Mu#method_bless">.bless</a> 的方法调用的。它旨在设置类的私有和公共属性，并接收传入 <code>.bless</code> 的所有名称属性。定义在 <code>Mu</code> 中的默认构造函数 <a href="https://docs.raku.org/type/Mu#method_new">.new</a> 是调用它的方法。鉴于公共访问器方法在 <code>BUILD</code> 中不可用，您必须使用私有属性表示法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class C {
    has $.attr;
    submethod BUILD (:$attr = 42) {
        $!attr = $attr
    };
    multi method new($positional) {
        self.bless(:attr($positional), |%_)
   }
};

C.new.say; C.new('answer').say;
# OUTPUT: «C.new(attr =&gt; 42)
#          C.new(attr =&gt; "answer")»</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_fallback_方法">Fallback 方法</h6>
<div class="paragraph">
<p>当其他解析名称的方法不产生结果时，将调用具有特殊名称的 <code>FALLBACK</code> 方法。第一个参数保存名称，所有后续参数都从原始调用转发。支持 multi 方法和<a href="https://docs.raku.org/type/Signature#Destructuring_arguments">子签名</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Magic {
    method FALLBACK ($name, |c(Int, Str)) {
    put "$name called with parameters {c.perl}"  }
};
Magic.new.simsalabim(42, "answer");

# OUTPUT: «simsalabim called with parameters ⌈\(42, "answer")⌋»</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_保留方法名">保留方法名</h6>
<div class="paragraph">
<p>一些内置的内省方法实际上是由编译器提供的特殊语法, 即 <code>WHAT</code>，<code>WHO</code>，<code>HOW</code> 和 <code>VAR</code>。使用这些名称声明的方法将无声地失败。动态调用将起作用，允许从外部对象调用方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    method WHAT { "ain't gonna happen" }
};

say A.new.WHAT;    # OUTPUT: «(A)»
say A.new."WHAT"() # OUTPUT: «ain't gonna happen»</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_包作用域中的方法">包作用域中的方法</h6>
<div class="paragraph">
<p>任何 <code>our</code> 作用域方法都将在类的包作用域内可见。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class C {
    our method packaged {};
    method loose {}
};
say C::.keys
# OUTPUT: «(&amp;packaged)»</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_使用同名变量和方法设置属性">使用同名变量和方法设置属性</h6>
<div class="paragraph">
<p>如果您用和属性属性同名的名字设置属性的变量（或方法调用），则可以节省一些输入，例如 <code>attr &#8658; $attr ` 或 `:attr($attr)</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A { has $.i = 42 };
class B {
    has $.i = "answer";
    method m() { A.new(:$.i) }
    #                  ^^^^  Instead of i =&gt; $.i or :i($.i)
};
my $a = B.new.m;
say $a.i; # OUTPUT: «answer»</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <code>$.i</code> 方法调用名字叫 <code>i</code> 且属性也叫 <code>i</code>，因此 Raku 允许我们使用快捷方式。这同样适用于 <code>:$var</code>，<code>:$!private-attribute</code>，<code>:&amp;attr-with-code-in-it</code>，等等。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_trait_is_nodal">trait <code>is nodal</code></h5>
<div class="paragraph">
<p>标记一个<a href="https://docs.raku.org/type/List">List</a>方法，指示 hyperoperator 不要进入内部 <a href="https://docs.raku.org/type/Iterable">Iterables</a> 以调用此方法。这个特性通常不是终端用户会使用的东西，除非他们子类化或扩展核心 <a href="https://docs.raku.org/type/List">List</a> 类型。</p>
</div>
<div class="paragraph">
<p>为了证明差异，请考虑以下示例，第一个使用 <code>is nodal</code> 方法（<code>elems</code>），第二个使用方法 <code>Int</code> , 它不是节点方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say ((1.0, "2", 3e0), [^4], '5')».elems; # OUTPUT: «(3, 4, 1)»
say ((1.0, "2", 3e0), [^4], '5')».Int    # OUTPUT: «((1 2 3) [0 1 2 3] 5)»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_trait_handles">trait <code>handles</code></h5>
<div class="paragraph">
<p>定义为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub trait_mod:&lt;handles&gt;(Attribute:D $target, $thunk)</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Sub#Traits">trait</a> <code>handles</code> 应用于类的属性，会将对提供的方法名称的所有调用代理给和属性同名名的方法。必须初始化属性引用的对象。可以提供代理调用的对象的类型约束。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A      { method m(){ 'A::m has been called.' } }
class B is A { method m(){ 'B::m has been called.' } }
class C {
    has A $.delegate handles 'm';
    method new($delegate){ self.bless(delegate =&gt; $delegate) }
};
say C.new(B.new).m(); # OUTPUT: «B::m has been called.»</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以提供一个 <code>Pair</code>（或用于重命名）或一个 <code>Pair</code>，<code>Regex</code> 或 <code>Whatever</code> 的列表而不是一个方法名。在后一种情况下，在类本身及其继承链中的现有方法将优先。如果 <code>FALLBACK</code> 要搜索本地，请使用 <code>HyperWhatever</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    method m1(){}
    method m2(){}
}

class C {
    has $.delegate handles &lt;m1 m2&gt; = A.new()
}
C.new.m2;

class D {
    has $.delegate handles /m\d/ = A.new()
}
D.new.m1;

class E {
    has $.delegate handles (em1 =&gt; 'm1') = A.new()
}
E.new.em1;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_trait_is">trait <code>is</code></h5>
<div class="paragraph">
<p>定义为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub trait_mod:&lt;is&gt;(Mu:U $child, Mu:U $parent)</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://docs.raku.org/type/Sub#Traits">trait</a> <code>is</code> 接受一个类型对象，该类型对象在其定义中被添加为类的父类。为了允许多重继承，可以多次应用 <code>is</code> trait。将父类添加到类中会将其方法导入目标类。如果在多个父类中出现同名方法，则第一个添加的父类将胜出。</p>
</div>
<div class="paragraph">
<p>如果没有提供 <code>is</code> trait，则默认值 <a href="https://docs.raku.org/type/Any"><code>Any</code></a> 将用作父类。这迫使所有 Raku 对象具有相同的基本方法集，以提供内省和强制到基本类型的接口。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    multi method from-a(){ 'A::from-a' }
}
say A.new.^parents(:all).perl;
# OUTPUT: «(Any, Mu)»

class B {
    method from-b(){ 'B::from-b ' }
    multi method from-a(){ 'B::from-A' }
}

class C is A is B {}
say C.new.from-a();
# OUTPUT: «A::from-a»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_trait_is_rw">trait <code>is rw</code></h5>
<div class="paragraph">
<p>定义为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub trait_mod:&lt;is&gt;(Mu:U $type, :$rw!)</code></pre>
</div>
</div>
<div class="paragraph">
<p>类的<a href="https://docs.raku.org/type/Sub#Traits">trait</a> <code>is rw</code> 在该类的所有公共属性上创建可写的访问器方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class C is rw {
    has $.a;
};
my $c = C.new.a = 42;
say $c; # OUTPUT: «42»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_trait_is_required">trait <code>is required</code></h5>
<div class="paragraph">
<p>定义为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">multi sub trait_mod:&lt;is&gt;(Attribute $attr, :$required!)
multi sub trait_mod:&lt;is&gt;(Parameter:D $param, :$required!)</code></pre>
</div>
</div>
<div class="paragraph">
<p>将类或角色属性标记为必要的。如果在对象构造时未初始化该属性，则抛出 <a href="https://docs.raku.org/type/X::Attribute::Required">X::Attribute::Required</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Correct {
    has $.attr is required;
    submethod BUILD (:$attr) { $!attr = $attr }
}
say Correct.new(attr =&gt; 42);
# OUTPUT: «Correct.new(attr =&gt; 42)»

class C {
    has $.attr is required;
}
C.new;
CATCH { default { say .^name =&gt; .Str } }
# OUTPUT: «X::Attribute::Required =&gt; The attribute '$!attr' is required, but you did not provide a value for it.»</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以为 <code>is required</code> 提供一个理由作为参数，说明它为什么是必须的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class Correct {
    has $.attr is required("it's so cool")
};
say Correct.new();
# OUTPUT: «The attribute '$!attr' is required because it's so cool,but you did not provide a value for it.»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_trait_hides">trait <code>hides</code></h5>
<div class="paragraph">
<p>trait <code>hides</code> 提供继承而不需要<a href="https://docs.raku.org/language/functions#Re-dispatching">重新分派</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {
    method m { say 'i am hidden' }
}
class B hides A {
    method m { nextsame }
    method n { self.A::m }
};

B.new.m;
B.new.n;
# OUTPUT: «i am hidden»</code></pre>
</div>
</div>
<div class="paragraph">
<p>trait <code>is hidden</code> 允许类从 <a href="https://docs.raku.org/language/functions#Re-dispatching">重新分派</a> 中隐藏自己。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A is hidden {
    method m { say 'i am hidden' }
}
class B is A {
    method m { nextsame }
    method n { self.A::m }
}

B.new.m;
B.new.n;
# OUTPUT: «i am hidden»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_trait_trusts">trait <code>trusts</code></h5>
<div class="paragraph">
<p>要允许一个类访问另一个类的私有方法，请使用该 trait <code>trusts</code>。可能需要可信类的前置声明。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class B {...};
class A {
    trusts B;
    has $!foo;
    method !foo { return-rw $!foo }
    method perl { "A.new(foo =&gt; $!foo)" }
};
class B {
    has A $.a .= new;
    method change { $!a!A::foo = 42; self }
};
say B.new.change;
# OUTPUT: «B.new(a =&gt; A.new(foo =&gt; 42))»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_扩展类">扩展类</h5>
<div class="paragraph">
<p>要在编译时向类添加方法和属性，请在类定义片段前面使用 <code>augment</code>。编译器将要求编译指令 <code>use MONKEY-TYPING</code> 或 <code>use MONKEY</code> 早一点出现在同一作用域中。请注意，可能会对性能产生影响，因此可能会出现问题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use MONKEY; augment class Str {
    method mark(Any :$set){
        state $mark //= $set; $mark
    }
};
my $s = "42";
$s.mark(set =&gt; "answer");
say $s.mark
# OUTPUT: «answer»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在类片段内可以做什么的限制很少。其中之一是将方法或子方法重新声明为 <code>multi</code> 方法。使用添加的属性尚未被实现。请注意，添加仅在其命名参数方面不同的多候选项将在已定义的候选项后面添加该候选项，因此调度程序不会选择该候选项。</p>
</div>
</div>
<div class="sect4">
<h5 id="_版本和作者">版本和作者</h5>
<div class="paragraph">
<p>版权和作者身份可以通过副词 <code>:ver&lt;&gt;</code> 和 <code>:auth&lt;&gt;</code> 应用。两者都以字符串作为参数，对于 <code>:ver</code>, 字符串被转换为 <a href="https://docs.raku.org/type/Version">Version</a> 对象。查询类版本和作者请使用 <code>.^ver</code> 和 <code>^.auth</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class C:ver&lt;4.2.3&gt;:auth&lt;me@here.local&gt; {}
say [C.^ver, C.^auth];
# OUTPUT: «[v4.2.3 me@here.local]»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_role">68.2.2. <code>role</code></h4>
<div class="paragraph">
<p>角色是类片段，它允许定义类共享的接口。<code>role</code> 声明符还引入了可用于类型检查的类型对象。角色可以在运行时和编译时混合到类和对象中。<code>role</code> 声明符返回创建的类型对象因而允许匿名角色和就地混入定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Serialize {
    method to-string { self.Str }
    method to-number { self.Num }
}

class A does Serialize {}
class B does Serialize {}

my Serialize @list;
@list.push: A.new;
@list.push: B.new;

say @list».to-string;
# OUTPUT: «[A&lt;57192848&gt; B&lt;57192880&gt;]»</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>&#8230;&#8203;</code> 作为方法体的唯一元素声明一个要抽象的方法。任何混合使用这种方法的类都必须重载它。如果在编译单元结束之前该方法没有被重载，则抛出 <code>X::Comp::AdHoc</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">EVAL 'role R { method overload-this(){...} }; class A does R {}; ';
CATCH { default { say .^name, ' ', .Str } }
# OUTPUT: «X::Comp::AdHoc Method 'overload-this' must be implemented by A because it is required by roles: R.»</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_自动双关">自动双关</h5>
<div class="paragraph">
<p>可以使用角色而不是类来创建对象。由于角色在运行时不能存在，因此会创建一个同名的类，该类将对角色类型检查成功。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role R { method m { say 'oi‽' } };
R.new.^mro.say;
# OUTPUT: «((R) (Any) (Mu))»
say R.new.^mro[0].HOW.^name;
# OUTPUT: «Raku::Metamodel::ClassHOW»
say R.new ~~ R;
# OUTPUT: «True»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_trait_does">trait <code>does</code></h5>
<div class="paragraph">
<p>trait <code>does</code> 可以应用于提供编译时混合的角色和类。要引用尚未定义的角色，请使用前置声明。混合角色的类的类型名称不反射 mixin，类型检查反射。如果在多个混合角色中提供方法，则首先定义的方法优先。可以提供以逗号分隔的角色列表。在这种情况下，将在编译时报告冲突。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role R2 {...};
role R1 does R2 {};
role R2 {};
class C does R1 {};

say [C ~~ R1, C ~~ R2];
# OUTPUT: «[True True]»</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于运行时混入请参阅<a href="https://docs.raku.org/language/operators#infix_but">but</a> 和 <a href="https://docs.raku.org/language/operators#infix_does">does</a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_参数化">参数化</h5>
<div class="paragraph">
<p>可以在角色名称后面的 <code><a href="https://docs.raku.org/type/Signature#Type_captures" class="bare">https://docs.raku.org/type/Signature#Type_captures</a></code> 之间提供角色的参数。支持[类型捕获]。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role R[$d] { has $.a = $d };
class C does R["default"] { };

my $c = C.new;
say $c;
# OUTPUT: «C.new(a =&gt; "default")»</code></pre>
</div>
</div>
<div class="paragraph">
<p>参数可以有类型约束，类型不支持 <code>where</code> 子句，但可以通过 <code>subset</code> 实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class A {};
class B {};
subset A-or-B where * ~~ A|B;
role R[A-or-B ::T] {};
R[A.new].new;</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以提供默认参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role R[$p = fail("Please provide a parameter to role R")] {};
my $i = 1 does R;
CATCH { default { say .^name, ': ', .Str} }
# OUTPUT: «X::AdHoc: Could not instantiate role 'R':Please provide a parameter to role R»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_as_类型约束">As 类型约束</h5>
<div class="paragraph">
<p>在期望类型的任何地方，角色都可以用作类型约束。如果使用 <code>does</code> 或 <code>but</code> 混合角色，则其 type-object 将添加到相关对象的 type-object 列表中。如果使用角色而不是类（使用自动生成），则自动生成的类与角色同名的类型对象将添加到继承链中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">role Unitish[$unit = fail('Please provide a SI unit quantifier as a parameter to the role Unitish')] {
    has $.SI-unit-symbol = $unit;
    method gist {
        given self {
            # ...
            when * &lt; 1 { return self * 1000 ~ 'm' ~ $.SI-unit-symbol }
            when * &lt; 1000 { return self ~ $.SI-unit-symbol }
            when * &lt; 1_000_000 { return self / 1_000 ~ 'k' ~ $.SI-unit-symbol }
            # ...
        }
    }
}

role SI-second   does Unitish[&lt;s&gt;] {}
role SI-meter    does Unitish[&lt;m&gt;] {}
role SI-kilogram does Unitish[&lt;g&gt;] {}

sub postfix:&lt;s&gt;(Numeric $num) { ($num) does SI-second }
sub postfix:&lt;m&gt;(Numeric $num) { ($num) does SI-meter }
sub postfix:&lt;g&gt;(Numeric $num) { ($num) does SI-kilogram }
sub postfix:&lt;kg&gt;(Numeric $num){ ($num * 1000) does SI-kilogram }

constant g = 9.806_65;

role SI-Newton does Unitish[&lt;N&gt;] {}

multi sub N(SI-kilogram $kg, SI-meter $m, SI-second $s --&gt; SI-Newton ){ ($kg * ($m / $s²)) does SI-Newton }
multi sub N(SI-kilogram $kg --&gt; SI-Newton)                            { ($kg * g) does SI-Newton }

say [75kg, N(75kg)];
# OUTPUT: «[75kg 735.49875kN]»
say [(75kg).^name, N(75kg).^name];
# OUTPUT: «[Int+{SI-kilogram} Rat+{SI-Newton}]»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_enum">68.2.3. <code>enum</code></h4>
<div class="paragraph">
<p>枚举提供具有关联类型的常量键-值对。任何键都属于该类型，并作为符号注入当前作用域。如果使用该符号，则将其视为常量表达式，并将该符号替换为枚举对的值。任何枚举都从角色 <a href="https://docs.raku.org/type/Enumeration"><code>Enumeration</code></a> 继承方法。不支持用于生成键值对的复杂表达式。通常，<code>enum</code> 是一个 <a href="https://docs.raku.org/type/Map">Map</a> 其元素具有混合的`Enumeration` 角色; 对于每个元素，此角色包括在 map 上创建顺序的索引。</p>
</div>
<div class="paragraph">
<p>符号的字符串化，在字符串上下文中自动完成，并且与其名称完全相同，这也是枚举对的键。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Names ( name1 =&gt; 1, name2 =&gt; 2 );
say name1, ' ', name2; # OUTPUT: «name1 name2»
say name1.value, ' ', name2.value; # OUTPUT: «1 2»</code></pre>
</div>
</div>
<div class="paragraph">
<p>比较符号将使用类型信息和枚举对的值。支持 <code>Num</code> 类型和 <code>Str</code> 类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Names ( name1 =&gt; 1, name2 =&gt; 2 );
sub same(Names $a, Names $b){
   $a eqv $b
}

say same(name1, name1); # OUTPUT: «True»
say same(name1, name2); # OUTPUT: «False»
my $a = name1;
say $a ~~ Names; # OUTPUT: «True»
say $a.^name;    # OUTPUT: «Names»</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有键必须属于同一类型。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Mass ( mg =&gt; 1/1000, g =&gt; 1/1, kg =&gt; 1000/1 );

say Mass.enums;
# OUTPUT: «Map.new((g =&gt; 1, kg =&gt; 1000, mg =&gt; 0.001))»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有给出值，则 <code>Int</code> 将假定为值类型，并且每个键从零开始递增 1。作为枚举键类型 <code>Int</code>，<code>Num</code>，<code>Rat</code> 和 <code>Str</code> 都被支持。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Numbers &lt;one two three four&gt;;

say Numbers.enums;
# OUTPUT: «Map.new((four =&gt; 3, one =&gt; 0, three =&gt; 2, two =&gt; 1))»</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以提供不同的起始值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Numbers «:one(1) two three four»;

say Numbers.enums;
# OUTPUT: «Map.new((four =&gt; 4, one =&gt; 1, three =&gt; 3, two =&gt; 2))»</code></pre>
</div>
</div>
<div class="paragraph">
<p>枚举也可以是匿名的，和具名 <code>enum</code> 的唯一的区别在于您不能在签名中使用它或用它声明变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $e = enum &lt;one two three&gt;;
say two;       # OUTPUT: «two»
say one.^name; # OUTPUT: «»
say $e.^name;  # OUTPUT: «Map»</code></pre>
</div>
</div>
<div class="paragraph">
<p>有多种方法可以访问已定义的符号的键和值。所有这些都将值转换为 <code>Str</code>，这可能是不可取的。通过将枚举视为包，我们可以获得键的类型列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum E(&lt;one two&gt;);
my @keys = E::.values;
say @keys.map: *.enums;
# OUTPUT: «(Map.new((one =&gt; 0, two =&gt; 1)) Map.new((one =&gt; 0, two =&gt; 1)))»</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_元类_2">元类</h5>
<div class="paragraph">
<p>要测试给定类型对象是否为 <code>enum</code>，请 <code>.HOW</code> 针对 <a href="https://docs.raku.org/type/Metamodel::EnumHOW">Metamodel::EnumHOW</a> 测试元对象方法，或者仅针对该 <code>Enumeration</code> 角色进行测试。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum E(&lt;a b c&gt;);
say E.HOW ~~ Metamodel::EnumHOW; # OUTPUT: «True»
say E ~~ Enumeration;            # OUTPUT: «True»</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_methods_2">Methods</h5>
<div class="sect5">
<h6 id="_method_enums">method enums</h6>
<div class="paragraph">
<p>定义为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method enums()</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回枚举对列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">enum Mass ( mg =&gt; 1/1000, g =&gt; 1/1, kg =&gt; 1000/1 );
say Mass.enums; # OUTPUT: «{g =&gt; 1, kg =&gt; 1000, mg =&gt; 0.001}»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_coercion">Coercion</h5>
<div class="paragraph">
<p>如果要将枚举元素的值强制转换为其合适的枚举对象，请使用带有枚举名称的 coercer：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my enum A (sun =&gt; 42, mon =&gt; 72);
A(72).pair.say;   # OUTPUT: «mon =&gt; 72»
A(1000).say; # OUTPUT: «(A)»</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一个示例显示了如果没有枚举对包含它作为值会发生什么。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_module">68.2.4. <code>module</code></h4>
<div class="paragraph">
<p>模块通常是一个或多个公开 Raku 结构的源文件，例如类，角色，grammars，子例程和变量。模块通常用于将 Raku 代码分发为可在另一个 Raku 程序中使用的库。</p>
</div>
<div class="paragraph">
<p>有关完整说明，请参阅<a href="https://docs.raku.org/language/modules">模块</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_package">68.2.5. <code>package</code></h4>
<div class="paragraph">
<p>Packages are nested namespaces of named program elements. Modules, classes and grammars are all types of package.</p>
</div>
<div class="paragraph">
<p>For a full explanation see <a href="https://docs.raku.org/language/packages">Packages</a>.</p>
</div>
<div class="paragraph">
<p>包是命名程序元素的嵌套命名空间。模块，类和语法都是所有类型的包。</p>
</div>
<div class="paragraph">
<p>有关完整说明，请参阅<a href="https://docs.raku.org/language/packages">包</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_grammar">68.2.6. <code>grammar</code></h4>
<div class="paragraph">
<p>Grammar 是用于解析文本的特定类型。Grammars 由 rule，token 和 regex 组成，它们实际上是方法，因为 grammars 是类。</p>
</div>
<div class="paragraph">
<p>有关完整说明，请参阅<a href="https://docs.raku.org/language/grammars">Grammars</a>。</p>
</div>
<div class="sect4">
<h5 id="_版本和作者_2">版本和作者</h5>
<div class="paragraph">
<p>版权和作者身份可以通过副词 <code>:ver&lt;&gt;</code> 和 <code>:auth&lt;&gt;</code> 应用。两者都以字符串作为参数，对于 <code>:ver</code>, 字符串被转换为 <a href="https://docs.raku.org/type/Version">Version</a>对象。查询语法版本和作者使用 <code>.^ver</code> 和 <code>^.auth</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">grammar G:ver&lt;4.2.3&gt;:auth&lt;me@here.local&gt; {}
say [G.^ver, G.^auth];
# OUTPUT: «[v4.2.3 me@here.local]»</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_subset">68.2.7. <code>subset</code></h4>
<div class="paragraph">
<p><code>subset</code> 声明一个会重新分配到其基类型的新类型。如果提供了 <a href="https://docs.raku.org/type/Signature#where"><code>where</code></a> 子句，则将针对给定的代码对象检查任何赋值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset Positive of Int where * &gt; -1;
my Positive $i = 1;
$i = -42;
CATCH { default { put .^name,': ', .Str } }
# OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $i; expected Positive but got Int (-42)»</code></pre>
</div>
</div>
<div class="paragraph">
<p>Subsets 可用于签名，例如通过键入下面的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">subset Foo of List where (Int,Str);
sub a($a, $b, --&gt; Foo) { $a, $b }
# Only a List with the first element being an Int and the second a Str will pass the type check.
a(1, "foo");  # passes
a("foo", 1);  # fails</code></pre>
</div>
</div>
<div class="paragraph">
<p>Subsets 可以是匿名的，允许在需要 subset 的情况下进行内联放置，但名字既不需要也不值得。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my enum E1 &lt;A B&gt;;
my enum E2 &lt;C D&gt;;
sub g(@a where { .all ~~ subset::where E1|E2 } ) {
    say @a
}
g([A, C]);
# OUTPUT: «[A C]»</code></pre>
</div>
</div>
<div class="paragraph">
<p>Subsets 可用于动态检查类型，这可以与 <a href="https://docs.raku.org/language/modules#require">require</a> 结合使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">require ::('YourModule');
subset C where ::('YourModule::C');</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_unicode_2">69. Unicode</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raku 对 Unicode 有很高的支持。本文档旨在概述和描述不属于例程和方法文档的 Unicode 功能。</p>
</div>
<div class="paragraph">
<p>有关 MoarVM 内部字符串表示的概述，请参阅 <a href="https://github.com/MoarVM/MoarVM/blob/master/docs/strings.asciidoc">MoarVM 字符串文档</a>。</p>
</div>
<div class="sect2">
<h3 id="_文件句柄和输入输出">69.1. 文件句柄和输入输出</h3>
<div class="sect3">
<h4 id="_标准化">69.1.1. 标准化</h4>
<div class="paragraph">
<p>默认情况下，Raku 对所有输入和输出应用标准化，但存储为 link:(<a href="https://docs.raku.org/language/unicode#UTF8-C8">UTF8-C8</a>) 的文件名除外;字形是用户可见的字符形式，将使用标准化表示。这是什么意思？例如，字形数字 <code>á</code> 可以用两种方式表示，或者使用一个代码点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">á (U+E1 "LATIN SMALL LETTER A WITH ACUTE")</code></pre>
</div>
</div>
<div class="paragraph">
<p>或两个代码点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">a +  ́ (U+61 "LATIN SMALL LETTER A" + U+301 "COMBINING ACUTE ACCENT")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Raku 将这两个输入转换为一个代码点，如规范化形式 C（NFC）所指定的那样。在大多数情况下，这很有用，意味着两个相同的输入都被视为相同。 Unicode 具有规范等价的概念，它允许我们确定字符串的规范形式，允许我们正确地比较字符串并操纵它们，而不必担心文本丢失这些属性。默认情况下，您处理或从 Raku 输出的任何文本都将采用此“规范”形式，即使在对字符串进行修改或连接时也是如此（请参阅下文，了解如何避免这种情况）。有关规范化表单C和规范等效性的更多详细信息，请参阅Unicode Foundation 的<a href="https://unicode.org/reports/tr15/#Canon_Compat_Equivalence">规范化和规范等效性</a>页面。</p>
</div>
<div class="paragraph">
<p>我们不默认的一种情况是文件名。这是因为必须完全访问文件的名称，就像在磁盘上写入字节一样。</p>
</div>
<div class="paragraph">
<p>为避免规范化，您可以使用名为 <a href="https://docs.raku.org/language/unicode#UTF8-C8">UTF8-C8</a> 的特殊编码格式。将此编码与任何文件句柄一起使用将允许您读取磁盘上的确切字节，而不进行规范化。如果使用 UTF8 句柄打印出来，打印出来时看起来会很滑稽。如果将其打印到输出编码为 <a href="https://docs.raku.org/language/unicode#UTF8-C8">UTF8-C8</a> 的句柄，则它将按照您通常的预期进行渲染，并且是字节精确复制的字节。有关 MoarVM 上 UTF8-C8 的更多技术细节, 请参见下文。</p>
</div>
</div>
<div class="sect3">
<h4 id="_utf8_c8">69.1.2. UTF8-C8</h4>
<div class="paragraph">
<p>UTF-8 Clean-8 是一种编码器/解码器，主要用作 UTF-8。但是，遇到一个不能解码为有效 UTF-8 的字节序列，或者由于规范化而不会往返的字节序列时，它将使用 link:(<a href="https://docs.raku.org/language/glossary#NFG">NFG</a>) 合成来跟踪所涉及的原始字节。这意味着编码回 UTF-8 Clean-8 将能够重新创建它们最初存在的字节。合成物包含4个代码点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>代码点 0x10FFFD (这是一个私用的代码点)</p>
</li>
<li>
<p>代码点 'x'</p>
</li>
<li>
<p>高4位作为十六进制字符的不可解码字节 (0..9A..F)</p>
</li>
<li>
<p>低4位作为十进制字符的不可解码字节 (0..9A..F)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在正常的 UTF-8 编码下，这意味着不可代表的字符会像 <code>?xFF</code> 那样出现。</p>
</div>
<div class="paragraph">
<p>UTF-8 Clean-8 用于 MoarVM 从环境，命令行参数和文件系统查询接收字符串的地方，例如解码缓冲区时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say Buf.new(ord('A'), 0xFE, ord('Z')).decode('utf8-c8');
#  OUTPUT: «A􏿽xFEZ␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以看到 UTF8-C8 使用的两个初始代码点如何显示在此处，就在“FE”之前。您可以使用此类编码来读取具有未知编码的文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $test-file = "/tmp/test";
given open($test-file, :w, :bin) {
  .write: Buf.new(ord('A'), 0xFA, ord('B'), 0xFB, 0xFC, ord('C'), 0xFD);
  .close;
}

say slurp($test-file, enc =&gt; 'utf8-c8'); # OUTPUT: «(65 250 66 251 252 67 253)»</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用这种类型的编码进行读取并将它们编码回 UTF8-C8 将返回原始字节;使用默认的 UTF8-C8 是不可能的。</p>
</div>
<div class="paragraph">
<p>请注意，到目前为止，这种编码在 Rakudo 的 JVM 实现中不受支持。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_输入_unicode_代码点和代码点序列">69.2. 输入 unicode 代码点和代码点序列</h3>
<div class="paragraph">
<p>您可以按编号（十进制和十六进制）输入 Unicode 代码点。例如，名为“带有macron的拉丁大写字母ae”的字符具有十进制代码点482和十六进制代码点0x1E2：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "\c[482]"; # OUTPUT: «Ǣ␤»
say "\x1E2";   # OUTPUT: «Ǣ␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以按名称访问 Unicode 代码点：Rakudo 支持所有 Unicode 9.0 名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "\c[PENGUIN]"; # OUTPUT: «🐧␤»
say "\c[BELL]";    # OUTPUT: «🔔␤» (U+1F514 BELL)</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有 Unicode 代码点名称/命名seq /emoji 序列现在都不区分大小写：[从2017.02开始]</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "\c[latin capital letter ae with macron]"; # OUTPUT: «Ǣ␤»
say "\c[latin capital letter E]";              # OUTPUT: «E␤» (U+0045)</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用带有 <code>\c[]</code> 的逗号分隔列表来指定多个字符。 您也可以组合数字和命名样式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "\c[482,PENGUIN]"; # OUTPUT: «Ǣ🐧␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了在内插字符串中使用 <code>\c<a href="https://docs.raku.org/routine/uniparse" class="bare">https://docs.raku.org/routine/uniparse</a></code> 之外，您还可以使用 [uniparse]:：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "DIGIT ONE".uniparse;  # OUTPUT: «1␤»
say uniparse("DIGIT ONE"); # OUTPUT: «1␤»</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_名称别名">69.2.1. 名称别名</h4>
<div class="paragraph">
<p>按名称别名。名称别名主要用于没有正式名称的代码点，缩写或更正（Unicode 名称永远不会更改）。有关它们的完整列表，请参见<a href="https://www.unicode.org/Public/UCD/latest/ucd/NameAliases.txt">此处</a>。</p>
</div>
<div class="paragraph">
<p>没有任何官方名称的控制代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "\c[ALERT]";     # Not visible (U+0007 control code (also accessible as \a))
say "\c[LINE FEED]"; # Not visible (U+000A same as "\n")</code></pre>
</div>
</div>
<div class="paragraph">
<p>更正:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "\c[LATIN CAPITAL LETTER GHA]"; # OUTPUT: «Ƣ␤»
say "Ƣ".uniname; # OUTPUT: «LATIN CAPITAL LETTER OI␤»
# This one is a spelling mistake that was corrected in a Name Alias:
say "\c[PRESENTATION FORM FOR VERTICAL RIGHT WHITE LENTICULAR BRACKET]".uniname;
# OUTPUT: «PRESENTATION FORM FOR VERTICAL RIGHT WHITE LENTICULAR BRAKCET␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>缩写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "\c[ZWJ]".uniname;  # OUTPUT: «ZERO WIDTH JOINER␤»
say "\c[NBSP]".uniname; # OUTPUT: «NO-BREAK SPACE␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_命名序列">69.2.2. 命名序列</h4>
<div class="paragraph">
<p>您也可以使用任何<a href="https://www.unicode.org/Public/UCD/latest/ucd/NamedSequences.txt">命名序列</a>，这些不是单个代码点，而是它们的序列。 [从2017.02开始]</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "\c[LATIN CAPITAL LETTER E WITH VERTICAL LINE BELOW AND ACUTE]";      # OUTPUT: «É̩␤»
say "\c[LATIN CAPITAL LETTER E WITH VERTICAL LINE BELOW AND ACUTE]".ords; # OUTPUT: «(201 809)␤»</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_emoji_序列">Emoji 序列</h5>
<div class="paragraph">
<p>Rakudo 支持表情符号 4.0（最新的非草稿版本）序列。 对于他们所有人看到：link:(<a href="https://www.unicode.org/Public/emoji/4.0/emoji-zwj-sequences.txt">表情符号 ZWJ 序列</a>)和<a href="https://www.unicode.org/Public/emoji/4.0/emoji-sequences.txt">表情符号序列</a>。 请注意，任何带逗号的名称都应删除逗号，因为 Raku 使用逗号分隔同一 <code>\c</code> 序列中的不同代码点/序列。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "\c[woman gesturing OK]";         # OUTPUT: «🙆‍♀️␤»
say "\c[family: man woman girl boy]"; # OUTPUT: «👨‍👩‍👧‍👦␤»</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_unicode_和_ascii_符号">70. Unicode 和 ASCII 符号</h2>
<div class="sectionbody">
<div class="paragraph">
<p>可以在 Raku 中使用以下 Unicode 符号，而无需加载任何其他模块。其中一些具有可以使用 ASCII 独有字符键入的等效物。这些变体通常由比 Unicode 版本更多的字符组成，因此它们看起来更大。</p>
</div>
<div class="paragraph">
<p>下面参考 unicode 码点的各种属性。最终列表可以在这里找到：<a href="https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt" class="bare">https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt</a>.</p>
</div>
<div class="sect2">
<h3 id="_字母字符">70.1. 字母字符</h3>
<div class="paragraph">
<p>任何具有 <code>Ll</code>（字母，小写），<code>Lu</code>（字母，大写），<code>Lt</code>（字母，标题），<code>Lm</code>（字母，修饰符）或 <code>Lo</code>（字母，其他）属性的代码点都可以像任何其他字母一样使用 ASCII 范围内的字符。</p>
</div>
</div>
<div class="sect2">
<h3 id="_数字字符">70.2. 数字字符</h3>
<div class="paragraph">
<p>任何具有 <code>Nd</code>（数字，十进制数字）属性的代码点都可以用作任何数字的数字。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $var = １９; # U+FF11 U+FF19
say $var + 2;  # OUTPUT: «21␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_数字值">70.3. 数字值</h3>
<div class="paragraph">
<p>任何具有 <code>No</code>（Number，other）或 <code>Nl</code>（Number，letter）属性的代码点都可以单独用作数值，例如 ½ 和 ⅓。 （这些不是十进制数字，因此不能组合。）例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $var = ⅒ + 2 + Ⅻ; # here ⅒ is No and Rat and Ⅻ is Nl and Int
say $var;            # OUTPUT: «14.1␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_空白字符">70.4. 空白字符</h3>
<div class="paragraph">
<p>除了空格和制表符，您还可以使用具有 <code>Zs</code>（分隔符，空格），<code>Zl</code>（分隔符，行）或 <code>Zp</code>（分隔符，段落）属性的任何其他 unicode 空白字符。</p>
</div>
</div>
<div class="sect2">
<h3 id="_其它可接受的单代码点">70.5. 其它可接受的单代码点</h3>
<div class="paragraph">
<p>此列表包含 Raku 中具有特殊含义的单个代码点及其 ASCII 等价物。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Symbol</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Codepoint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ASCII</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remarks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">«</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+00AB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;&lt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为 «» 或 .« 的一部分, 或正则表达式左单词边界</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">¯</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+00AF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(必须使用显式的数字) 作为幂的一部分 (长音符号是减号的另一种写法)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">²</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+00B2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">**2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以与 ⁰..⁹ 结合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">³</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+00B3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">**3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以与 ⁰..⁹ 结合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">¹</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+00B9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">**1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以与 ⁰..⁹ 结合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">»</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+00BB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&gt;&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为 «» 或 .« 的一部分, 或正则表达式右单词边界</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">×</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+00D7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">÷</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+00F7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">π</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+03C0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">pi</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.14159_26535_89793_238e0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">τ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+03C4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tau</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6.28318_53071_79586_476e0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">‘</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2018</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为 ‘’ 或 ’‘ 的一部分</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">’</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2019</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为 ‘’ 或 ‚’ 或 ’‘ 的一部分</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">‚</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+201A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为 ‚‘ 或 ‚’ 的一部分</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">“</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+201C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为 “” 或 ”“ 的一部分</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">”</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+201D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为 “” 或 ”“ 或 ”” 的一部分</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">„</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+201E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为 „“ 或 „” 的一部分</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">…</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2026</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⁰</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2070</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">**0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以与 ⁰..⁹ 结合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⁴</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2074</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">**4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以与 ⁰..⁹ 结合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⁵</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2075</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">**5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以与 ⁰..⁹ 结合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⁶</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2076</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">**6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以与 ⁰..⁹ 结合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⁷</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2077</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">**7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以与 ⁰..⁹ 结合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⁸</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2078</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">**8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以与 ⁰..⁹ 结合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⁹</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2079</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">**9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以与 ⁰..⁹ 结合</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⁺</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+207A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(必须使用显式的数字) 作为幂的一部分</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⁻</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+207B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(必须使用显式的数字) 作为幂的一部分</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">∅</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2205</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">set()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(empty set)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">∈</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2208</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(elem)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">∉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2209</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!(elem)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">∋</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+220B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(cont)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">∌</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+220C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!(cont)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">−</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2212</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">∖</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2216</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(-)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">∘</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2218</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">o</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">∞</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+221E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inf</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">∩</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2229</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(&amp;)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">∪</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+222A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(|)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">≅</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2245</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">=~=</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">≠</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2260</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!=</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">≤</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2264</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8656;</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">≥</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2265</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&gt;=</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊂</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2282</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(&lt;)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊃</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2283</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(&gt;)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊄</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2284</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!(&lt;)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊅</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2285</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!(&gt;)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊆</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2286</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(&#8656;)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊇</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2287</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(&gt;=)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊈</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2288</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!(&#8656;)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2289</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!(&gt;=)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊍</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+228D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(.)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊎</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+228E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(+)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊖</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+2296</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(^)</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">𝑒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+1D452</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">e</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.71828_18284_59045_235e0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">｢</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+FF62</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Q//</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为 ｢｣ 的一部分 (注意: Q// 变体不能裸用在正则表达式中)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">｣</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+FF63</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Q//</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为 ｢｣ 的一部分 (注意: Q// 变体不能裸用在正则表达式中)</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_原子运算符">70.5.1. 原子运算符</h4>
<div class="paragraph">
<p>原子运算符将 <code>U+269B</code> ⚛ ATOM SYMBOL 合并到其中。它们的 ASCII 等价物是普通的子程序，而不是运算符：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my atomicint $x = 42;
$x⚛++;                # Unicode version
atomic-fetch-inc($x); # ASCII version</code></pre>
</div>
</div>
<div class="paragraph">
<p>ASCII 替代方案如下：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Symbol</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ASCII</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remarks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⚛=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">atomic-assign</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⚛</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">atomic-fetch</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">this is the prefix:&lt;⚛&gt; operator</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⚛+=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">atomic-add-fetch</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⚛-=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">atomic-sub-fetch</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⚛−=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">atomic-sub-fetch</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">this operator uses U+2212 minus sign</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">++⚛</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">atomic-inc-fetch</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⚛++</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">atomic-fetch-inc</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">--⚛</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">atomic-dec-fetch</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⚛--</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">atomic-fetch-dec</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_多代码点">70.6. 多代码点</h3>
<div class="paragraph">
<p>此列表包含多个代码点运算符，这些运算符需要对其 ASCII 等价物项进行特殊组合。请注意，代码点以空格分隔显示，但在使用时应作为相邻代码点输入。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Symbol</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Codepoints</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ASCII</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Since</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remarks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">»=»</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+00BB = U+00BB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&gt;&gt;[=]&gt;&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v6.c</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uses ASCII '='</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">«=«</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+00AB = U+00AB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;&lt;[=]&lt;&lt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v6.c</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uses ASCII '='</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">«=»</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+00AB = U+00BB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;&lt;[=]&gt;&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v6.c</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uses ASCII '='</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">»=«</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+00BB = U+00AB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&gt;&gt;[=]&lt;&lt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">v6.c</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">uses ASCII '='</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_变量_5">71. 变量</h2>
<div class="sectionbody">
<div class="paragraph">
<p>变量名以一个叫做魔符 sigil 的特殊字符开头, 后面跟着一个可选的第二个叫做 <code>twigil</code> 的特殊字符, 然后是一个标识符.</p>
</div>
<div class="sect2">
<h3 id="_sigils">71.1. Sigils</h3>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">符号</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类型约束</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Flattens</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Assignment</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mu (no type constraint)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">item</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&amp;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Callable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Callable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">item</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Positional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">list</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Associative</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">list</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $square = 9 ** 2;
my @array  = 1, 2, 3;   # Array variable with three elements
my %hash   = London =&gt; 'UK', Berlin =&gt; 'Germany';</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认类型可以使用 <code>is</code> 关键字设置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">class FailHash is Hash {
    has Bool $!final = False;
    multi method AT-KEY ( ::?CLASS:D: Str:D \key ){
        fail X::OutOfRange.new(:what("Hash key"), :got(key), :range(self.keys)) if $!final &amp;&amp; !self.EXISTS-KEY(key);
        callsame
    }

    method finalize() {
        $!final = True
    }
}

my %h is FailHash = oranges =&gt; "round", bananas =&gt; "bendy";
say %h&lt;oranges&gt;;
# OUTPUT «round␤»
%h.finalize;
say %h&lt;cherry&gt;;
CATCH { default { put .^name, ': ', .Str } }
# OUTPUT «X::OutOfRange: Hash key out of range. Is: cherry, should be in (oranges bananas)»</code></pre>
</div>
</div>
<div class="paragraph">
<p>不带符号的变量也是可行的, 查看 <a href="http://doc.raku.org/language/variables#Sigilless_variables">无符号变量</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_项和列表赋值">71.2. 项和列表赋值</h3>
<div class="paragraph">
<p>有两种类型的赋值, item 赋值和 list 赋值. 两者都使用 = 号操作符. 根据 = 号左边的语法来区别 = 是 item 赋值还是 list 赋值.</p>
</div>
<div class="paragraph">
<p>Item 赋值把等号右侧的值放到左侧的变量(容器)中.</p>
</div>
<div class="paragraph">
<p>例如, <a href="https://docs.raku.org/type/Array">数组</a>变量(@符号)在列表赋值时清空数组自身, 然后把等号右侧的值都放进数组自身中. 跟 Item 赋值相比, 这意味着等号左侧的变量类型始终是 Array, 不管右侧是什么类型.</p>
</div>
<div class="paragraph">
<p>赋值类型(item 或 list)取决于当前表达式或声明符看到的第一个上下文:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $foo = 5;            # item assignment
say $foo.perl;          # 5

my @bar = 7, 9;         # list assignment
say @bar.WHAT;          # Array
say @bar.perl;          # [7, 9]

(my $baz) = 11, 13;     # list assignment
say $baz.WHAT;          # Parcel
say $baz.perl;          # (11, 13)</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此, 包含在列表赋值中的赋值行为依赖于表达式或包含表达式的声明符。
例如, 如果内部赋值是一个声明符(例如 my), 就使用 item 赋值, 它比逗号和列表赋值的优先级更高:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array;
@array = my $num = 42, "str";   # item assignment: uses declarator
say @array.perl;                # [42, "str"] (an Array)
say $num.perl;                  # 42 (a Num)</code></pre>
</div>
</div>
<div class="paragraph">
<p>类似地, 如果内部赋值是一个用于声明符初始化的表达式, 则内部表达式的上下文决定赋值的类型:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $num;
my @array = $num = 42, "str";    # item assignment: uses expression
say @array.perl;                 # [42, "str"] (an Array)
say $num.perl;                   # 42 (a Num)

my ( @foo, $bar );
@foo = ($bar) = 42, "str";       # list assignment: uses parens
say @foo.perl;                   # [42, "str"] (an Array)
say $bar.perl;                   # $(42, "str")  (a Parcel)</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而, 如果内部赋值既不是声明符又不是表达式, 而是更大的表达式的一部分, 更大的表达式的上下文决定赋值的类型:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my ( @array, $num );
@array = $num = 42, "str";    # list assignment
say @array.perl;              # [42, "str"] (an Array)
say $num.perl;                # [42, "str"] (an Array)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是因为整个表达式是 <code>@array = $num = 42, "str"</code>, 而 <code>$num = 42</code> 不是单独的表达式.</p>
</div>
<div class="paragraph">
<p>查看<a href="https://docs.raku.org/language/operators">操作符</a>获取关于优先级的更多详情。</p>
</div>
</div>
<div class="sect2">
<h3 id="_无符号变量">71.3. 无符号变量</h3>
<div class="paragraph">
<p>在 Raku 中创建不带符号的变量也是可能的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my \degrees = pi / 180;
my \θ       = 15 * degrees;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而, 这些无符号变量并不创建<a href="https://docs.raku.org/language/containers">容器</a>. 那意味着上面的 <code>degrees</code> 和 <code>θ</code> 实际上直接代表 <code>Nums</code>. 为了说明, 我们定义一个无符号变量后再赋值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">θ = 3; # Dies with the error "Cannot modify an immutable Num"</code></pre>
</div>
</div>
<div class="paragraph">
<p>无符号变量不强制上下文, 所以它们可被用于原样地传递某些东西:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub logged(&amp;f, |args) {
    say('Calling ' ~ &amp;f.name ~ ' with arguments ' ~ args.perl);
    my \result = f(|args);
    #  ^^^^^^^ not enforcing any context here
    say(&amp;f.name ~ ' returned ' ~ result.perl);
    return |result;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_twigils_2">71.4. Twigils</h3>
<div class="paragraph">
<p><code>Twigils</code> 影响变量的`作用域`。请记住 twigils 对基本的魔符插值没有影响，那就是，如果  <code>$a</code> 内插， <code>$^a</code>, <code>$*a</code>, <code>$=a</code>, <code>$?a</code>, <code>$.a</code>, 等等也会内插. 它仅仅取决于 <code>$</code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Twigil</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scope</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">动态的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">!</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">属性(类成员)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">编译时变量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">方法(并非真正的变量)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配对象索引(并非真正的变量)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">^</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自我声明的形式位置参数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自我声明的形式命名参数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pod 变量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">~</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">子语言</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_twigil">71.5. * Twigil</h3>
<div class="paragraph">
<p>动态变量通过 caller 查找, 不是通过外部作用域。例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    my $lexical   = 1;
    my $*dynamic1 = 10;
    my $*dynamic2 = 100;

    sub say-all() {
        say "$lexical, $*dynamic1, $*dynamic2";
    }

    # prints 1, 10, 100
    say-all();

    {
        my $lexical   = 2;
        my $*dynamic1 = 11;
        $*dynamic2    = 101; # 注意,这儿没有使用 my 来声明

        # prints 1, 11, 101
        say-all();
    }

    # prints 1, 10, 101
    say-all();</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一次调用 <code>&amp;say-all</code> 时, 就像你期望的一样, 它打印 "1, 10, 100"。可是第二次它打印 "1, 11, 101"。 这是因为 <code>$lexical</code> 不是在调用者的作用域内被查找, 而是在 <code>&amp;say-all</code> 被定义的作用域里被查找的。这两个动态作用域变量在调用者的作用域内被查找, 所以值为 <code>11</code> 和 <code>101</code>。第三次调用 <code>&amp;say-all</code> 后,  <code>$*dynamic1</code> 不再是 11 了. 但是 <code>$*dynamic2</code> 仍然是 101。这源于我们在块中声明了一个新的动态变量 <code>$*dynamic1</code> 的事实并且没有像我们对待 <code>$*dynamic2</code> 那样把值赋值给旧的变量。</p>
</div>
<div class="paragraph">
<p>动态变量与其他变量类型在引用一个未声明的动态变量上不同的是前者不是一个编译时错误，而是运行时 <a href="https://docs.raku.org/type/Failure">failure</a>，这样一个动态变量可以在未定义时使用只要在把它用作任何其它东西的时候检查它是否定义过:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub foo() {
    $*FOO // 'foo';
}

say foo; # -&gt; 'foo'

my $*FOO = 'bar';

say foo; # -&gt; 'bar'</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_twigil_2">71.6. ! Twigil</h3>
<div class="paragraph">
<p>属性是变量, 存在于每个类的实例中. 通过 <code>!</code> 符号它们可以从类的里面直接被访问到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    class Point {
        has $.x;
        has $.y;

        method Str() {
            "($!x, $!y)"
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意属性是怎样被声明为 <code>$.x</code> 和 <code>$.y</code> 的, 但是仍然能够通过 <code>$!x</code> 和 <code>$!y</code> 访问到属性. 这是因为 在 Raku 中, 所有的属性都是`私有的`, 并且在类中能使用 <code>$!attribute-name</code> 直接访问这些属性. Raku 能自动为你生成访问方法. 关于对象、类和它们的属性和方法的详情, 请查看<a href="https://docs.raku.org/language/objects">面向对象</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_twigil_3">71.7. ? Twigil</h3>
<div class="paragraph">
<p>编译时"常量", 可通过 <code>?</code> twigil 访问. 编译器对它们很熟悉, 并且编译后不能被修改. 常用的一个例子如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "$?FILE: $?LINE"; # prints "hello.pl: 23" if this is the 23 line of a
                      # file named "hello.pl".</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于这些特殊变量的列表请查看<a href="https://docs.raku.org/language/variables#Compile-time_variables">编译时变量</a>。</p>
</div>
<div class="paragraph">
<p>尽管不能在运行时改变它们, 用户可以(重新)定义这种常量.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">constant $?TABSTOP = 4; # this causes leading tabs in a heredoc or in a POD
                        # block's virtual margin to be counted as 4 spaces.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_twigil_4">71.8. . Twigil</h3>
<div class="paragraph">
<p><code>.</code> twigil 真的不是用于变量的. 实际上, 看下面的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    class Point {
        has $.x;
        has $.y;

        method Str() {
            "($.x, $.y)" # 注意我们这次使用 . 而不是 !
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>对 <code>self</code>(自身)调用了方法 <code>x</code> 和方法 <code>y</code>, 这是自动为你生成的, 因为在你声明你的属性的时候, 你使用的是 <code>.</code> twigil 。 注意,  子类可能会覆盖那些方法. 如果你不想这个发生, 请使用 <code>$!x</code> 和 <code>$!y</code> 代替。</p>
</div>
<div class="paragraph">
<p><code>.</code> twigil 只是调用了一个方法也表明下面是可能的</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">    class SaySomething {
        method a() { say "a"; }
        method b() { $.a; }
    }

    SaySomething.b; # prints "a"</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于对象、类和它们的属性和方法的详情, 请查看<a href="https://docs.raku.org/language/objects">面向对象</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_twigil_5">71.9. &lt; Twigil</h3>
<div class="literalblock">
<div class="content">
<pre>`&lt;` twigil 是 `$/&lt;...&gt;` 的别名, 其中,  `$/` 是匹配变量. 关于匹配变量的更多详情请查看 link:https://docs.raku.org/language/variables#The_%24%2F_Variable[$/变量]和link:https://docs.raku.org/type/Match[类型匹配]</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_twigil_6">71.10. ^ Twigil</h3>
<div class="paragraph">
<p><code>^</code> twigil 为 block 块 或 子例程 声明了一个形式位置参数.  形如 <code>$^variable</code> 的变量是一种占位变量. 它们可用在裸代码块中来声明代码块的形式参数. 看下面代码中的块:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for ^4 {
    say "$^seconds follows $^first";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它打印出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">1 follows 0
3 follows 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>有两个形式参数，就是 <code>$first</code> 和 <code>$second</code>.  注意, 尽管 <code>$^second</code> 在代码中出现的比 <code>$^first</code> 早,  <code>$^first</code> 依然是代码块中的第一个形式参数. 这是因为占位符变量是以 Unicode 顺序排序的.</p>
</div>
<div class="paragraph">
<p>子例程也能使用占位符变量, 但是只有在子例程没有显式的参数列表时才行. 这对普通的块也适用</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub say-it    { say $^a; } # valid
sub say-it()  { say $^a; } # invalid
              { say $^a; } # valid
-&gt; $x, $y, $x { say $^a; } # 非法, 已经有参数列表 $x,$y,$x 了</code></pre>
</div>
</div>
<div class="paragraph">
<p>占位符变量语法上不能有类型限制. 也注意, 也不能使用单个大写字母的占位符变量, 如 <code>$^A</code></p>
</div>
</div>
<div class="sect2">
<h3 id="_twigil_7">71.11. : Twigil</h3>
<div class="paragraph">
<p><code>:</code> twigil 为块或子例程声明了一个形式<strong>命名参数</strong>。使用这种形式声明的变量也是占位符变量的一种类型。因此适用于使用 <code>^</code> twigil 声明的变量的东西在这儿也适用(除了它们不是位置的以外, 因此没有使用 Unicode 顺序排序)。所以这个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say { $:add ?? $^a + $^b !! $^a - $^b }( 4, 5 ) :!add
# OUTPUT:
# -1</code></pre>
</div>
</div>
<div class="paragraph">
<p>查看 <a href="https://docs.raku.org/routine/%5E" class="bare" target="_blank" rel="noopener">https://docs.raku.org/routine/%5E</a>获取关于占位符变量的更多细节。</p>
</div>
</div>
<div class="sect2">
<h3 id="_twigil_8">71.12. = Twigil</h3>
<div class="paragraph">
<p><code>=</code> twigil 用于访问 Pod 变量。当前文件中的每个 Pod 块都能通过一个 Pod 对象访问到, 例如 <code>$=data</code>, <code>$=SYNOPSIS</code> 或 <code>=UserBlock</code>, 即：一个和想要的块同名的变量加上一个 <code>=</code> twigil。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">=begin Foo
...
=end Foo

#after that, $=Foo gives you all Foo-Pod-blocks</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以通过 `$=pod`访问 Pod 树，它包含所有作为分级数据结构的Pod结构。</p>
</div>
<div class="paragraph">
<p>请注意，所有这些 <code>$=someBlockName</code> 都支持位置和关联角色。</p>
</div>
</div>
<div class="sect2">
<h3 id="_twigil_9">71.13. ~ Twigil</h3>
<div class="paragraph">
<p>注意: Slangs（俚语）在 Rakudo 中还没有被实现。 NYI = Not Yet Implemented.</p>
</div>
<div class="paragraph">
<p><code>~</code> twigil 是指子语言（称为俚语）。下面是有用的：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">变量名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">说 明</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$~MAIN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the current main language (e.g. Perl statements)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$~Quote</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the current root of quoting language</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$~Quasi</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the current root of quasiquoting language</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$~Regex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the current root of regex language</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$~Trans</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the current root of transliteration language</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$~P5Regex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the current root of the Perl 5 regex language</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>你在你当前的词法作用域中扩充这些语言。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use MONKEY-TYPING;
augment slang Regex {  # derive from $~Regex and then modify $~Regex
    token backslash:std&lt;\Y&gt; { YY };
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_变量声明符和作用域">71.14. 变量声明符和作用域</h3>
<div class="paragraph">
<p>通常, 使用 <code>my</code> 关键字创建一个新的变量就足够了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $amazing-variable = "World";
say "Hello $amazing-variable!"; # Hello World!</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而, 有很多声明符能在 <a href="https://docs.raku.org/language/variables#Twigils">Twigils</a> 的能力之外改变作用域的细节。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明符</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">my</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为词法作用域名字的开头</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">our</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为包作用域名字的开头</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">has</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为属性名的开头</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">anon</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为私有名字的开头</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">state</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作为词法作用域但是持久名字的开头</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">augment</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">给已存在的名字添加定义</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">supersede</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">替换已存在名字的定义</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>还有两个类似于声明符的前缀, 但是作用于预定义变量:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">前缀</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作用</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">temp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在作用域的最后恢复变量的值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">let</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果 block 成功退出就恢复变量的值</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_my_声明符">71.14.1. my 声明符</h4>
<div class="paragraph">
<p>使用 <code>my</code> 声明一个变量给变量一个词法作用域. 这意味着变量只在当前块中存在.例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">{
    my $foo = "bar";
    say $foo; # -&gt; "bar"
}
say $foo; # !!! "Variable '$foo' is not declared"</code></pre>
</div>
</div>
<div class="paragraph">
<p>它抛出异常,因为只要我们在同一个作用域内 <code>$foo</code> 才被定义. 此外, 词法作用域意味着变量能在新的作用域内被临时地重新定义:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $location = "outside";

sub outer-location {
    # Not redefined:
    say $location;
}

outer-location; # -&gt; "outside"

sub in-building {
    my $location = "inside";
    say $location;
}

in-building;    # -&gt; "inside"
outer-location; # -&gt; "outside"</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果变量被重新定义了, 任何引用外部变量的代码会继续引用外部变量.
所以, 在这儿, <code>&amp;outer-location</code> 仍然打印外部的 <code>$location</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub new-location {
    my $location = "nowhere"
    outer-location;
}

new-location; # -&gt; "outside"</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了让 <code>new-location()</code> 能打印 <code>nowwhere</code>, 需要使用 <code>*</code> <a href="https://docs.raku.org/language/variables#The_%2A_Twigil">twigil</a> 让 <code>$location</code> 变为动态变量.
对于子例程来说, <code>my</code> 是默认作用域, 所以 <code>my sub x( ) { }</code> 和 <code>sub x( ) { }</code> 是一样的.</p>
</div>
</div>
<div class="sect3">
<h4 id="_our_声明符">71.14.2. our 声明符</h4>
<div class="paragraph">
<p>our 跟 <code>my</code> 的作用类似, 除了把别名引入到符号表之外:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">module M {
    our $Var;
    # $Var available here
}

# Available as $M::Var here.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_声明一组变量">71.14.3. 声明一组变量</h4>
<div class="paragraph">
<p>声明符 <code>my</code> 和 <code>our</code> 接收一组扩在圆括号中的变量作为参数来一次性声明多个变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my (@a, $s, %h);</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可以和解构赋值结合使用。任何对这样一个列表的赋值会取得左侧列表中提供的元素数量并且从右侧列表中把对应的值赋值给它们。没有得到赋值的元素会根据变量的类型得到一个未定义值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my (Str $a, Str $b, Int $c) = &lt;a b&gt;;
say [$a, $b, $c].perl;
# OUTPUT«["a", "b", Int]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>要把列表解构到一个单个的值中, 通过使用 <code>($var,)</code> 创建一个带有一个值的列表字面值。当使用了一个变量声明符时只在单个变量周围提供一个圆括号就足够了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub f { 1,2,3 };
my ($a) = f;
say $a.perl;
# OUTPUT«1␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>要跳过列表中的元素, 使用匿名状态变量 <code>$</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my ($,$a,$,%h) = ('a', 'b', [1,2,3], {:1th});
say [$a, %h].perl;
# OUTPUT«["b", {:th(1)}]␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_has_声明符">71.14.4. has 声明符</h4>
<div class="paragraph">
<p><code>has</code> 作用在类的实例或 role 的属性上, 还有类或 roles 的方法上. has 隐式作用于方法上, 所以 <code>has method x() {}</code> 和 <code>method x() {}</code> 做得是相同的事情。</p>
</div>
<div class="paragraph">
<p>查看<a href="https://docs.raku.org/language/objects">面向对象</a>获取更多文档和例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">has method x( ) { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>等价于:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">method x( ) { }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_anon_声明符">71.14.5. anon 声明符</h4>
<div class="paragraph">
<p><code>anon</code> 声明符阻止符号本安装在词法作用域内, 还有方法表中, 和其它任何地方.
例如, 你可以使用 <code>anon</code> 声明一个知道自己名字的子例程, 但是仍然不会被安装到作用域内:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my %operations =
    half   =&gt; anon sub half($x)   { $x / 2  },
    square =&gt; anon sub square($x) { $x * $x },
    ;
say %operations&lt;square&gt;.name;       # square
say %operations&lt;square&gt;(8);         # 64</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_state_声明符">71.14.6. state 声明符</h4>
<div class="paragraph">
<p><code>state</code> 声明词法作用域变量, 就像 my 那样。然而, <strong>初始化只发生一次</strong>, 就在正常执行流中第一次遇见初始化的时候。因此, state 变量会在闭合块或 程序的多次执行<strong>之间</strong>保留它们的值。</p>
</div>
<div class="paragraph">
<p>因此, 下面这个子例程:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub a {
    state @x;
    state $l = 'A';
    @x.push($l++);
};

say a for 1..6;</code></pre>
</div>
</div>
<div class="paragraph">
<p>会持续增加 <code>$l</code> 并在每次被调用时把它追加到 @x 中, 所以它会打印出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">[A]
[A B]
[A B C]
[A B C D]
[A B C D E]
[A B C D E F]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This works per "clone" of the containing code object, as in this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">({ state $i = 1; $i++.say; } xx 3).map: {$_(), $_()}; # says 1 then 2 thrice</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，这不是一个线程安全的解构, 当同一个 block 的同一个克隆运行在多个线程中时。要知道方法只有每个类一个克隆，而不是每个对象。</p>
</div>
<div class="paragraph">
<p>至于 <code>my</code>，声明多个状态变量必须放置在圆括号中, 而声明一个单一变量，圆括号可以省略。</p>
</div>
<div class="paragraph">
<p>请注意，许多操作符都伴随着隐式绑定，什么会导致超距作用。使用 <code>.clone</code> 或强迫创建一个可以绑定的新容器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a;
sub f() {
    state $i;
    $i++;
    @a.push: "k$i" =&gt; $i # &lt;-- .clone goes here
};
f for 1..3;
dd @a; # «Array $var = $[:k1(3), :k2(3), :k3(3)]»</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有的状态变量都是线程间共享的。这个结果可能是你不希望得到的或危险的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub code(){ state $i = 0; say ++$i; $i };
await
    start { loop { last if code() &gt;= 5 } },
    start { loop { last if code() &gt;= 5 } };

# OUTPUT«1␤2␤3␤4␤4␤3␤5␤»
# OUTPUT«2␤1␤3␤4␤5␤»
# many other more or less odd variations can be produced</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_变量_6">71.14.7. $ 变量</h4>
<div class="paragraph">
<p>和显式地声明命名状态变量一样, <code>$</code> 能够用作不带显式状态声明的匿名状态变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "1-a 2-b 3-c".subst(:g, /\d/, {&lt;one two three&gt;[$++]});
# OUTPUT«one-a two-b three-c␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>更进一步, 状态变量不需要存在于子例程中。你可以, 举个例子, 在单行程序中使用 <code>$</code> 在文件中编号行号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku -ne 'say ++$ ~ " $_"' example.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>实际上词法范围内每个对 <code>$</code> 的引用都是是一个<strong>单独的</strong>变量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">raku -e '{ say ++$; say $++  } for ^5'
# OUTPUT«1␤0␤2␤1␤3␤2␤4␤3␤5␤4␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在作用域内你需要多次引用 <code>$</code> 的值, 那么它应该被拷贝到一个新的变量中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub foo() {
    given ++$ {
        when 1 {
            say "one";
        }
        when 2 {
            say "two";
        }
        when 3 {
            say "three";
        }
        default {
            say "many";
        }
    }
}

foo() for ^3;
# OUTPUT«one␤two␤three␤»</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_变量_7">71.14.8. @ 变量</h4>
<div class="paragraph">
<p>和 <code>$</code> 变量类似, 也有一个位置匿名状态变量 <code>@</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub foo($x) {
    say (@).push($x);
}

foo($_) for ^3;

# OUTPUT:
# [0]
# [0 1]
# [0 1 2]</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的 <code>@</code> 是用圆括号括起来了以和名为 <code>@.push</code> 的类成员变量消除歧义。索引访问并不需要这种歧义，但你需要拷贝这个值，以便用它做任何有用的事情。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub foo($x) {
    my $v = @;
    $v[$x] = $x;
    say $v;
}

foo($_) for ^3;

# OUTPUT:
# [0]
# [0 1]
# [0 1 2]</code></pre>
</div>
</div>
<div class="paragraph">
<p>就和 <code>$</code> 一样, 作用域中的每次提及 <code>@</code> 就引入了一个新的匿名数组。</p>
</div>
</div>
<div class="sect3">
<h4 id="_变量_8">71.14.9. % 变量</h4>
<div class="paragraph">
<p>最后, 还有一个关联匿名状态变量 <code>%</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub foo($x) {
    say (%).push($x =&gt; $x);
}

foo($_) for ^3;

# OUTPUT:
# 0 =&gt; 0
# 0 =&gt; 0, 1 =&gt; 1
# 0 =&gt; 0, 1 =&gt; 1, 2 =&gt; 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于歧义的同样警告适用。正如你可能期望，索引访问也有可能（使用复制以使之有用）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub foo($x) {
    my $v = %;
    $v{$x} = $x;
    say $v;
}

foo($_) for ^3;

# OUTPUT:
# 0 =&gt; 0
# 0 =&gt; 0, 1 =&gt; 1
# 0 =&gt; 0, 1 =&gt; 1, 2 =&gt; 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>就像其它的匿名状态变量一样, 在给定作用域中每次提及 <code>%</code> 最终都会引入一个单独的变量。</p>
</div>
</div>
<div class="sect3">
<h4 id="_augment_声明符">71.14.10. augment 声明符</h4>
<div class="paragraph">
<p>使用 <code>augment</code>, 你可以给已经存在的类或 grammars 增加属性和方法.</p>
</div>
<div class="paragraph">
<p>因为类通常使用 our 作用域, 因此是全局的, 这意味着修改全局状态, 这是强烈不鼓励的, 对于大部分情况, 有更好的方法.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># don't do this
use MONKEY-TYPING;
augment class Int {
    method is-answer { self == 42 }
}
say 42.is-answer;       # True</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_temp_前缀">71.14.11. temp 前缀</h4>
<div class="paragraph">
<p>像 my 一样, temp 在作用域的末尾恢复旧的变量值. 然而, temp 不创建新的变量.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $in = 0; # temp will "entangle" the global variable with the call stack
            # that keeps the calls at the bottom in order.
sub f(*@c) {
    (temp $in)++;
     "&lt;f&gt;\n"
     ~ @c&gt;&gt;.indent($in).join("\n")
     ~ (+@c ?? "\n" !! "")
     ~ '&lt;/f&gt;'
};
sub g(*@c) {
    (temp $in)++;
    "&lt;g&gt;\n"
    ~ @c&gt;&gt;.indent($in).join("\n")
    ~ (+@c ?? "\n" !! "")
    ~ "&lt;/g&gt;"
};
print g(g(f(g()), g(), f()));

# OUTPUT:
# &lt;g&gt;
#  &lt;g&gt;
#   &lt;f&gt;
#    &lt;g&gt;
#    &lt;/g&gt;
#   &lt;/f&gt;
#   &lt;g&gt;
#   &lt;/g&gt;
#   &lt;f&gt;
#   &lt;/f&gt;
#  &lt;/g&gt;
# &lt;/g&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_let_前缀">71.14.12. let 前缀</h4>
<div class="paragraph">
<p>跟 temp 类似, 如果 block 没有成功退出则恢复之前的值。成功的退出意味着该 block 返回了一个定义过的值或一个列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $answer = 42;

{
    let $answer = 84;
    die if not Bool.pick;
    CATCH {
        default { say "it's been reset :(" }
    }
    say "we made it 84 sticks!";
}

say $answer;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的例子中, 如果 <code>Bool.pick</code> 返回 true, 那么答案会保持为 84, 因为那个 block 返回了一个定义了的值(say 返回 true)。
否则那个 <code>die</code> 语句会让那个 block 不成功地退出, 把答案重新设置为 42。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_类型约束和初始化">71.15. 类型约束和初始化</h3>
<div class="paragraph">
<p>变量可以有类型约束, 约束在声明符和变量名之间:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int $x = 42;
$x = 'a string'; # throws an X::TypeCheck::Assignment error
CATCH { default { put .^name, ': ', .Str } }
# OUTPUT: X::TypeCheck::Assignment: Type check failed in assignment to $x; expected Int but got Str ("a string")</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果一个标量有类型约束但是没有初始值, 它会使用类型约束的类型对象来初始化.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Int $x;
say $x.^name;    # Int
say $x.defined;  # False</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有显式类型约束的标量的类型为 Mu, 但是默认会是 Any 类型的对象.</p>
</div>
<div class="paragraph">
<p>带有 @ 符号的变量会被初始化为空的数组; 带有 % 符号的变量会被初始化为空的散列.</p>
</div>
<div class="paragraph">
<p>变量的默认值可以使用 <code>is default</code> 特性设置, 通过把 Nil 赋值给变量来重新应用默认值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Real $product is default(1);
say $product;                       # 1
$produce *= 5;
say $product;                       # 5
$product = Nil;
say $product;                       # 1</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_默认的有定义的变量指令">71.16. 默认的有定义的变量指令</h3>
<div class="paragraph">
<p>为了强制所有的变量拥有一个有定义的约束, 使用 <code>use variables :D</code> 指令。这个指令是词法作用域的并且可以使用 <code>use variables :_</code> 指令进行切换。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use variables :D;
my Int $i;
# OUTPUT«===SORRY!=== Error while compiling &lt;tmp&gt;␤Variable definition of type Int:D (implicit :D by pragma) requires an initializer ...
my Int $i = 1; # that works
{ use variables :_; my Int $i; } # 在这个 block 中关掉它</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意, 赋值 Nil 会把这个变量恢复为它的默认值。一个有定义的约束类型的默认值是类型名加上 <code>:D</code>(例如 <code>Int:D</code>)。That means a definedness contraint is no guarantee of definedness. 这只适用于变量初始化, 不适用于签名。</p>
</div>
</div>
<div class="sect2">
<h3 id="_特殊变量_3">71.17. 特殊变量</h3>
<div class="paragraph">
<p><strong>Pre-defined lexical variables</strong></p>
</div>
<div class="paragraph">
<p>每个代码块中都有3个特别的变量:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">变量</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">意义</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$_</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">特殊变量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">正则匹配</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$!</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">异常</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="">71.17.1. $_</h4>
<div class="paragraph">
<p><code>$<em></code> 是特殊变量，在没有显式标识的代码块中，它是默认参数。所以诸如 <code>for @array { &#8230;&#8203; }</code> 和 <code>given $var { &#8230;&#8203; }</code> 之类的结构会将变量绑定给 <code>$</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for &lt;a b c&gt; { say $_ }  # sets $_ to 'a', 'b' and 'c' in turn
say $_ for &lt;a b c&gt;;     # same, even though it's not a block
given 'a'   { say $_ }  # sets $_ to 'a'
say $_ given 'a';       # same, 尽管这不是一个块</code></pre>
</div>
</div>
<div class="paragraph">
<p>CATCH 块将 <code>$<em></code> 设置为捕获到的异常。 <code>~~</code> 智能匹配操作符。
对 <code>$</em></code> 调用一个方法可以省略特殊变量 <code>$_</code> 的名字，从而写的更短：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">.say;                   # 与 $_.say 相同</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>m/regex/</code> 和 <code>/regex/</code> 正则匹配 和 <code>s/regex/subst/</code> 替换是作用于 <code>$_</code> 上的.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say "Looking for strings with non-alphabetic characters...";
for &lt;ab:c d$e fgh ij*&gt; {
    .say if m/&lt;!alpha&gt;/;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">Looking for strings with non-alphabetic characters...
ab:c
d$e
ij*</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_2">71.17.2. $/</h4>
<div class="paragraph">
<p><code>$/</code> 是匹配变量。它存储着最近一次<a href="https://docs.raku.org/language/regexes">正则</a>匹配的结果，通常包含 <a href="https://docs.raku.org/type/Match">Match</a> 类型的对象。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'abc 12' ~~ /\w+/;  # 设置 $/ 为一个Match 对象
say $/.Str;         # abc</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Grammar.parse</code> 方法会把调用者的 <code>$/</code> 设置为 <code>Match object</code> 的结果。看下面的代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use XML::Grammar; # panda install XML
XML.Grammar.parse("&lt;p&gt;some text&lt;/p&gt;");
say $/;

# OUTPUT:
# ｢&lt;p&gt;some text&lt;/p&gt;｣
#  root =&gt; ｢&lt;p&gt;some text&lt;/p&gt;｣
#   name =&gt; ｢p｣
#   child =&gt; ｢some text｣
#    text =&gt; ｢some text｣
#    textnode =&gt; ｢some text｣
#  element =&gt; ｢&lt;p&gt;some text&lt;/p&gt;｣
#   name =&gt; ｢p｣
#   child =&gt; ｢some text｣
#    text =&gt; ｢some text｣
#    textnode =&gt; ｢some text｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>其他匹配变量是 <code>$/</code> 元素的别名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">$0          # same as $/[0]
$1          # same as $/[1]
$&lt;named&gt;    # same as $/&lt;named&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_位置属性">71.17.3. 位置属性</h4>
<div class="paragraph">
<p>如果正则中有捕获分组, <code>$/</code> 中会有位置属性. 它们由圆括号组成.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'abbbbbcdddddeffg' ~~ / a (b+) c (d+ef+) g /;
say $/[0]; # ｢bbbbb｣
say $/[1]; # ｢dddddeff｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些捕获分组也能使用 <code>$0</code>,<code>$1</code>,<code>$2</code> 等便捷形式取得:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $0; # ｢bbbbb｣
say $1; # ｢dddddeff｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>要获取所有的位置属性, 使用 <code>$/.list</code>, <code>@$/</code>,<code>@( )</code> 中的任意一个都可以:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say @().join; # bbbbbdddddeff</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_命名属性">71.17.4. 命名属性</h4>
<div class="paragraph">
<p>如果正则中有命名捕获分组, <code>$/</code> 可以有命名属性, 或者正则调用了另一个正则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">'I.... see?' ~~ / \w+ $&lt;punctuation&gt;=[ &lt;-[\w\s]&gt;+ ] \s* $&lt;final-word&gt; = [ \w+ . ] /;
say $/&lt;punctuation&gt;; # ｢....｣
say $/&lt;final-word&gt;;  # ｢see?｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些命名捕获分组也能使用便捷形式的 <code>$&lt;named&gt;</code> 获取:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say $&lt;punctuation&gt;; # ｢....｣
say $&lt;final-word&gt;;  # ｢see?｣</code></pre>
</div>
</div>
<div class="paragraph">
<p>要获取所有的命名属性, 使用 <code>$/.hash</code>,  <code>%$/</code>, `%()`中的任何一个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say %().join;  # "punctuation     ....final-word  see?"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_变量_9">71.17.5. $! 变量</h4>
<div class="paragraph">
<p><code>$!</code> 是错误变量. 如果 <code>try</code> block 或语句前缀捕获到异常, 那个异常就会被存储在 <code>$!</code> 中。如果没有捕获到异常, 那么 <code>$!</code> 会被设置为 Any 类型对象。
注意, <code>CATCH</code> 块不设置 <code>$!</code>。CATCH 在 block 中把 <code>$_</code> 设置为捕获到的异常。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_编译时变量">71.18. 编译时变量</h3>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Compile-time Variables</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">说明</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$?FILE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所在文件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$?LINE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所在行</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">::?CLASS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所在类</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&amp;?ROUTINE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所在子例程</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&amp;?BLOCK</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所在块</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%?LANG</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">What is the current set of interwoven languages?</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%?RESOURCES</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The files associated with the "Distribution" of the current compilation unit.</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">for '.' {
    .Str.say when !.IO.d;
    .IO.dir()&gt;&gt;.&amp;?BLOCK when .IO.d # lets recurse a little!
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其它编译时变量：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Compile-time Variables</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">说明</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$?PACKAGE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所在包</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$?MODULE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所在模块</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$?CLASS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所在类(as variable)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$?ROLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所在角色(as variable)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$?GRAMMAR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所在 grammar</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$?TABSTOP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在 heredoc 或 虚拟边距中 tab 有多少空格</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$?USAGE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从 MAIN 程序的签名中生成的使用信息</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$?ENC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Str.encode/Buf.decode/various IO 方法的默认编码.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_动态变量">71.19. 动态变量</h3>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dynamic Variable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">说明</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*ARGFILES</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">神奇的命令行输入句柄</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@*ARGS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">来自命令行的参数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*IN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标准输入文件句柄, AKA stdin</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*OUT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标准输出文件句柄, AKA stdout</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*ERR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标准错误文件句柄, AKA stderr</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">%*ENV</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">环境变量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*REPO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存储安装过的/加载了的模块信息的变量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*TZ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">系统的本地时区.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*CWD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前工作目录.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*KERNEL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在哪个内核下运行</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*DISTRO</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在哪个操作系统分发下运行</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*VM</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在哪个虚拟机下运行</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*PERL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在哪个 Perl 下运行</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*PID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前进程的进程 ID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*PROGRAM-NAME</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前可执行程序的路径就像它通过命令行键入一样, 或 -e 如果 perl 引用了 -e 标记</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*PROGRAM</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">正被执行的 Perl 程序的位置( 以 IO::Path 对象的形式)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*EXECUTABLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前运行的可执行 perl 的绝对路径</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*EXECUTABLE-NAME</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前运行的可执行 perl 程序的名字。(e.g. raku-p, raku-m, Niecza.exe)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*USER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">正在运行该程序的用户. 它是一个被求值为 "username (uid)" 的对象. 它只有在被当作字符串时才被求值为用户名, 如果被当作数字则被求值为数值化的用户 id。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*GROUP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">运行程序的用户的主要组. 它是被计算为  "groupname (gid)" 的对象.它只有在被当作字符串时才被求值为组名, 如果被当作数字则被求值为数值化的组 id。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*HOME</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">代表当前运行程序的用户家目录的 IO::Path 对象。如果家目录不确定则为 Nil。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*SPEC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">程序运行的平台的合适的 IO::Spec 子类, 对于特定操作系统代码,使用智能匹配: say "We are on Windows!" if $*SPEC ~~ IO::Spec::Win32</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*TMPDIR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">代表着 "系统临时目录" 的 IO::Path 对象</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*TOLERANCE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由 &#8656;~&#8658; 操作符使用并且任何依赖它的操作, 来决定两个值是否近似地相等, 默认为 1e-15。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*THREAD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">代表当前执行线程的 Thread 对象。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">$*SCHEDULER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">代表当前默认调度程序的 ThreadPoolScheduler 对象。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>注意 <code>$*SCHEDULER</code> 的用法:</p>
</div>
<div class="paragraph">
<p>对于当前的 Rakudo, 这个默认在方法 <code>.hyper</code> 和 <code>.race</code> 上采用最大 16 个线程。要更改线程的最大数量, 要么在运行 perl 之前设置环境变量  RAKUDO_MAX_THREADS 的值, 要么在使用 .hyper 或 .race 之前创建一个默认改变了的作用域的拷贝:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $*SCHEDULER = ThreadPoolScheduler.new( max_threads =&gt; 64 );</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种行为在 spec 测试中没有被测试并且还会变化。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_实验特性">72. 实验特性</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Raku 开发期间，通常可以在设计完成之前为用户提供新功能。最终，这些功能可能成为 Raku 规范的一部分。要使用这些功能，可以在程序源代码中使用  <code>experimental</code> 指令，例如，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use experimental :macros;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些功能暂时是实验性的。</p>
</div>
<div class="sect2">
<h3 id="_pack">72.1. <strong>pack</strong></h3>
<div class="paragraph">
<p>Pack 是一种允许二进制序列化一般数据结构的功能，并且继承自 Perl 的<a href="http://perldoc.perl.org/functions/pack.html">pack</a>。<code>pack</code> 命令通过以包装字符串给出的特定方式打包数据结构来创建Buf，其中包含 <a href="https://docs.raku.org/type/Blob#method_unpack"><code>unpack</code></a> 描述中显示的选项。你可以通过在程序开头插入这个指令来打开它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use experimental :pack;</code></pre>
</div>
</div>
<div class="paragraph">
<p>例如，我们可以打包数字，将它们解释为十六进制（<code>H</code>），重复模式，直到没有更多的元素（<code>*</code>）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use experimental :pack;
say pack("H*", "414243").contents;#  OUTPUT: «(65 66 67)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>有一个相应的 <code>unpack</code> 例程正好相反。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use experimental :pack;
my $buf=Buf.new(65,66,67);
say $buf.unpack("H*"); # OUTPUT: «414243␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>并非所有上述符号都可以保证实现，并且路线图不包含退出该阶段的固定日期。</p>
</div>
<div class="paragraph">
<p>请参阅 <code>Blob</code> 页面中的 <a href="https://docs.raku.org/type/Blob#sub_pack"><code>pack</code></a> 和 <a href="https://docs.raku.org/type/Blob#method_unpack"><code>unpack</code></a> 文档。</p>
</div>
</div>
<div class="sect2">
<h3 id="_宏">72.2. <strong>宏</strong></h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Macro_(computer_science">宏</a>) 是代码生成例程，它们在程序执行之前在编译时生成代码。在 Raku 中，它的使用仍然是实验性的，它需要通过编译指示打开</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use experimental :macros;</code></pre>
</div>
</div>
<div class="paragraph">
<p>宏处理在解析时发生。宏生成抽象语法树，将其移植到程序语法树中。 <code>quasi</code> 是执行此任务的例程。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">macro does-nothing() {
    quasi {}
};
does-nothing; # OUTPUT: «»</code></pre>
</div>
</div>
<div class="paragraph">
<p>宏是一种例程，因此它们可以以完全相同的方式接受参数，并且也以几乎相同的方式起作用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">macro is-mighty( $who ) {
    quasi { "$who is mighty!"}
};
say is-mighty "Freija"; # OUTPUT: « "Freija" is mighty!␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>“几乎”说明了参数作为文字插入的事实，包括引号。请注意，我们也可以按照与例程相同的规则消除宏调用的括号。你可以使用unquoting构造  <code>{{{}}}</code>  来摆脱这种事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">macro is-mighty( $who ) {
    quasi { {{{$who}}} ~ " is mighty!"}
};
say is-mighty "Freija";  # OUTPUT: «Freija is mighty!␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于宏扩展是在解析时发生的，因此在使用外部变量时必须小心：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use experimental :macros;
my $called;
macro called() {
    $called++;
    quasi { "Called" }
};
say called() ~ " $called times";
say called() ~ " $called times"; # OUTPUT: «Called 2 times␤Called 2 times␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于宏在分析时被扩展，因此 <code>$called</code> 将是运行时启动时的结果，已打印为 <code>2</code>。 但是，使用 0 初始化 <code>$called</code> 将使此打印调用 0 次，因为在扩展宏的解析阶段之后运行初始化。</p>
</div>
<div class="paragraph">
<p>当需要进行复杂的计算初始化时，宏非常有用。 然而，他们仍然处于试验中，这是有充分理由的。 虽然上面显示的功能不太可能发生变化，但任何事情，甚至它们的存在，都可能在任何时候都有所改变，这取决于必需品，因此最好让它们远离生产代码。 与此同时，看看 Masak 和 <a href="https://github.com/masak/007">007</a> 的<a href="https://rakuadvent.wordpress.com/2012/12/23/day-23-macros/">这篇文章</a>，这是一种新的宏观语言，可能会显示未来的形状。</p>
</div>
</div>
<div class="sect2">
<h3 id="_cached">72.3. <strong>cached</strong></h3>
<div class="paragraph">
<p>以下指令:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use experimental :cached;</code></pre>
</div>
</div>
<div class="paragraph">
<p>打开 <code>is cached</code> trait，它存储例程调用的结果，如果使用相同的参数调用，则返回相同的值。</p>
</div>
<div class="paragraph">
<p>它可以在涉及大量计算时使用，如本示例中使用的<a href="https://rakuadvent.wordpress.com/2018/12/25/calling-numbers-names/#more-7528">友好数字</a>，取自 2018 年 Advent 日历：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">use experimental :cached;

sub aliquot-parts( $number ) is cached {
    (^$number).grep: $number %% *;
}

sub infix:&lt;amic&gt;( $m, $n ) {
    $m == aliquot-parts($n).sum &amp;&amp;
    $n == aliquot-parts($m).sum;
}

# Taken from https://en.wikipedia.org/wiki/Amicable_numbers
my @numbers = [2620, 2924, 5020, 5564, 6232, 6368, 66928, 66992];

say "Aliquot parts of $_ are ", aliquot-parts $_ for @numbers;

for @numbers X @numbers -&gt; @pair {
    say "@pair[0] and @pair[1] are ",
        @pair[0] amic @pair[1]??" "!!"not ", "amicable";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码缓存了等分部分的计算，因此当调用 <code>amic</code> 运算符时，它只计算一次;事实上，打印这些等分部件的第一个循环将是唯一一个实际执行计算的循环。</p>
</div>
<div class="paragraph">
<p>有关其他信息和示例，另请参见<a href="https://docs.raku.org/routine/is%20cached">特征描述</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opener_graphemes">73. Opener graphemes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>下表显示了在 Pod6 声明符块之类的结构中可用作开头配对定界符的所有有效字素。 请注意，它们显示在管道符号之间，因此可以看到任何宽度字符的额外边界空间。</p>
</div>
<div class="paragraph">
<p>该表的来源是 <strong>Rakudo grammar</strong> 中的角色 STD 中定义的 <strong>token opener</strong>。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Opener Graphemes</caption>
<colgroup>
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 12.5%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Char</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Char</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Char</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Char</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hex</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">｢</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFF62</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">«</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x00AB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">༺</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x0F3A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">༼</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x0F3C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">᚛</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x169B</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">‘</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2018</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">‚</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x201A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">‛</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x201B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">“</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x201C</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">„</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x201E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">‟</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x201F</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">‹</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2039</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⁅</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2045</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⁽</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x207D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">₍</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x208D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∈</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2208</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2209</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">∊</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x220A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∕</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2215</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∼</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x223C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">≃</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2243</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">≒</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2252</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">≔</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2254</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">≤</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2264</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">≦</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2266</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">≨</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2268</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">≪</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x226A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">≮</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x226E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">≰</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2270</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">≲</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2272</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">≴</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2274</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">≶</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2276</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">≸</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2278</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">≺</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x227A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">≼</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x227C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">≾</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x227E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊀</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2280</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊂</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2282</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊄</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2284</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊆</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2286</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊈</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2288</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊊</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x228A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊏</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x228F</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊑</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2291</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊘</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2298</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊢</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22A2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊦</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22A6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊨</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22A8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊩</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22A9</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊫</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22AB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊰</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22B0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊲</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22B2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊴</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22B4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⊶</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22B6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22C9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋋</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22CB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋐</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22D0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋖</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22D6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋘</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22D8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋚</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22DA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋜</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22DC</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋞</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22DE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋠</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22E0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋢</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22E2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋤</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22E4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋦</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22E6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋨</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22E8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋪</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22EA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋬</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22EC</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋰</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22F0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋲</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22F2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋳</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22F3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋴</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22F4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋶</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22F6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⋷</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x22F7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⌈</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2308</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⌊</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x230A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">〈</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2329</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⎴</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x23B4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">❨</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2768</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">❪</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x276A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">❬</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x276C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">❮</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x276E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">❰</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2770</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">❲</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2772</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">❴</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2774</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⟃</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x27C3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⟅</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x27C5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⟕</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x27D5</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⟝</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x27DD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⟢</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x27E2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⟤</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x27E4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⟦</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x27E6</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⟨</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x27E8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⟪</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x27EA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⦃</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2983</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⦅</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2985</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⦇</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2987</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⦉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2989</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⦋</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x298B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⦍</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x298D</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⦏</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x298F</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⦑</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2991</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⦓</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2993</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⦕</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2995</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⦗</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2997</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⧀</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x29C0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⧄</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x29C4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⧏</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x29CF</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⧑</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x29D1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⧔</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x29D4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⧘</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x29D8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⧚</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x29DA</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⧸</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x29F8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⧼</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x29FC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⨫</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2A2B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⨭</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2A2D</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⨴</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2A34</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⨼</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2A3C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⩤</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2A64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⩹</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2A79</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⩽</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2A7D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⩿</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2A7F</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪁</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2A81</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪃</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2A83</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪋</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2A8B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪑</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2A91</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪓</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2A93</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪕</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2A95</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪗</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2A97</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪙</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2A99</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪛</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2A9B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪡</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2AA1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪦</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2AA6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪨</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2AA8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪪</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2AAA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪬</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2AAC</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪯</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2AAF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪳</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2AB3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪻</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2ABB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪽</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2ABD</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⪿</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2ABF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⫁</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2AC1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⫃</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2AC3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⫅</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2AC5</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⫍</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2ACD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⫏</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2ACF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⫑</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2AD1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⫓</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2AD3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⫕</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2AD5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⫬</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2AEC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⫷</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2AF7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⫹</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2AF9</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⸂</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2E02</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⸄</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2E04</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⸉</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2E09</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⸌</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2E0C</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">⸜</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2E1C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⸠</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2E20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">⸨</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x2E28</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">〈</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x3008</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">《</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x300A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">「</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x300C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">『</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x300E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">【</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x3010</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">〔</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x3014</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">〖</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x3016</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">〘</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x3018</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">〚</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x301A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">〝</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0x301D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">﴾</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFD3E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">︗</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFE17</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">︵</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFE35</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">︷</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFE37</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">︹</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFE39</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">︻</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFE3B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">︽</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFE3D</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">︿</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFE3F</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">﹁</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFE41</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">﹃</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFE43</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">﹇</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFE47</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">﹙</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFE59</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">﹛</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFE5B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">﹝</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFE5D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFF08</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">＜</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFF1C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">［</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFF3B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">｛</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFF5B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">｟</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xFF5F</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_语句前缀">74. 语句前缀</h2>
<div class="sectionbody">
<div class="paragraph">
<p>语句前缀写在语句之前, 改变语句的意思, 语句的输出或语句运行的时刻。因为他们拥有特定的行为, 他们有时候也对某些语句或语句组有特定作用。</p>
</div>
<div class="sect2">
<h3 id="_lazy">74.1. lazy</h3>
<div class="paragraph">
<p>作为语句前缀，<code>lazy</code> 会在任何语句（包括 <code>for</code> 循环）之前起作用，从而在实际需要将其赋值给变量时保存执行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $incremented = 0;
my $var = lazy for &lt;1 2 3 4&gt; -&gt; $d {
    $incremented++
};
say $incremented; # OUTPUT: «0␤»
say eager $var;   # OUTPUT: «(0 1 2 3)␤»
say $incremented; # OUTPUT: «4␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>$incremented</code> 变量仅递增，也就是说，仅当我们热切计算包含惰性循环变量 <code>$var</code> 时，才运行循环的内部部分。 渴望可以通过其他方式应用于变量，例如在其上调用 <code>.eager</code> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @array = lazy { (^3).map( *² )  };
say @array;       # OUTPUT: «[...]»
say @array.eager; # OUTPUT: «[0 1 4]␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个前缀也可以在 <a href="https://docs.raku.org/language/control#gather/take">gather</a> 前面使用，以使内部语句表现得懒惰。 通常，使用此方法会使返回值的任何语句集变得懒惰。</p>
</div>
</div>
<div class="sect2">
<h3 id="_eager">74.2. eager</h3>
<div class="paragraph">
<p><code>eager</code> 语句前缀将热切地返回后面的语句的结果，从而消除惰性并返回结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $result := eager gather { for 1..3 { say "Hey"; take $_² } };
say $result[0]; # OUTPUT: «Hey␤Hey␤Hey␤1␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>当与标量绑定时，<code>gather</code> <a href="https://docs.raku.org/syntax/gather%20take">隐式地是惰性的</a>。 但是，使用 <code>eager</code> 作为语句前缀，即使我们只是连续请求第一个，它也会在循环中运行所有三个迭代，如打印的 "Hey" 所示。</p>
</div>
</div>
<div class="sect2">
<h3 id="_hyper_race">74.3. hyper, race</h3>
<div class="paragraph">
<p><code>hyper</code> 和 <code>race</code> 使用（可能是同时）线程在循环中运行不同的迭代：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my @a = hyper for ^100_000 { .is-prime }</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码比裸代码快3倍左右。 但是这里有一些警告：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>循环内的操作应花费足够的时间使线程有意义。</p>
</li>
<li>
<p>循环内不应有对同一数据结构的读取或写入访问。 让循环产生一个结果，并分配它。</p>
</li>
<li>
<p>如果循环中存在I / O操作，则可能存在争用，因此请避免使用。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>hyper</code> 和 <code>race</code> 之间的主要区别是结果的顺序。 如果您需要按顺序生成循环结果，请使用 <code>hyper</code>；如果您不关心，请使用 <code>race</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_quietly_2">74.4. quietly</h3>
<div class="paragraph">
<p>作为语句前缀，<code>quietly</code> 抑制其前面的语句产生的所有警告。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">sub marine() {};
quietly say ~&amp;marine; # OUTPUT: «marine␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在代码上调用 <code>.Str</code> <a href="https://docs.raku.org/type/Code#method_Str">会产生警告</a>。 在该语句前面加一个 <code>quietly</code> 只会产生输出，即例程的名称。</p>
</div>
</div>
<div class="sect2">
<h3 id="_try">74.5. try</h3>
<div class="paragraph">
<p>如果在语句前使用 <code>try</code>，它将包含其中产生的异常并将其存储在 <code>$!</code> 中。 变量，<a href="https://docs.raku.org/language/language/exceptions#try_blocks">就像在块前使用它一样</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">try [].pop;
say $!; # OUTPUT: «Cannot pop from an empty Array␤..»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_do_3">74.6. do</h3>
<div class="paragraph">
<p><code>do</code> 可以用作语句前缀，以消除它们之前的语句的歧义； 例如，如果要分配 <code>for</code> 语句的结果，则需要使用此命令。 裸 <code>for</code> 将失败，但这将起作用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $counter = 0;
my $result = do for ^5 { $counter++ };
say $counter; # OUTPUT: «5␤»
say $result;  # OUTPUT: «(0 1 2 3 4)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在其他情况下，<code>do</code> 等效于用括号将语句括起来。 它可以用作（可能更多）简单语法的替代方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="_sink">74.7. sink</h3>
<div class="paragraph">
<p><a href="https://docs.raku.org/routine/sink">与例程一样</a>，<code>sink</code> 将运行该语句以丢弃结果。 如果您想对其产生的副作用运行某些语句，请使用它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $counter = 0;
my $result = sink for ^5 { $counter++ };
say $counter; #  OUTPUT: «5␤»
say $result;  #  OUTPUT: «(Any)␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_once_2">74.8. once</h3>
<div class="paragraph">
<p>在循环内, 仅运行带前缀的语句一次。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my $counter;
my $result = do for ^5 { once $counter = 0; $counter++ };
say $result; # OUTPUT: «(0 1 2 3 4)␤»</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gather">74.9. gather</h3>
<div class="paragraph">
<p>可以在语句前面使用 <code>gather</code>，在该语句的任何位置接收并收集从一次 <code>take</code> 运行发出的所有数据结构的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub fact( Int ) {*}
multi sub fact( 1 --&gt; 1 ) {}
multi sub fact( $x ) { take $x * fact( $x-1 ) }

my @factors = gather say fact(13); # OUTPUT: «6227020800»
say @factors;
# OUTPUT: «[2 6 24 120 720 5040 40320 362880 3628800 ...]»</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，<code>gather</code> 在 <code>say</code> 之前，它打印阶乘的第一个结果； 同时，它从每次对事实的调用中都收集了结果，该结果发送到 <code>@factor</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_start_2">74.10. start</h3>
<div class="paragraph">
<p>作为语句前缀，<code>start</code> 的行为与<a href="https://docs.raku.org/language/control#flow%29_start">在块前面</a>的行为相同，即，它以异步方式运行该语句，并返回 promise。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto sub fact( Int ) {*}
multi sub fact( 1 --&gt; 1 ) {}
multi sub fact( $x ) {  $x * fact( $x-1 ) }

my @promises = gather {
    for &lt;3 4&gt; {
        take start fact( 10 ** $_ );
    }
}

say await @promises;</code></pre>
</div>
</div>
<div class="paragraph">
<p>由 <code>start</code> 创建的 <a href="https://docs.raku.org/type/Promise">Promises</a> 收集在一个数组中，一旦实现了 Promise，它就会返回操作的结果。</p>
</div>
</div>
<div class="sect2">
<h3 id="_react">74.11. react</h3>
<div class="paragraph">
<p><code>react</code> 可以在并发程序中用于创建代码块，这些代码块在某些事件发生时运行。 它<a href="https://docs.raku.org/syntax/react">适用于块</a>，也可用作语句前缀。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my Channel $KXGA .= new;
for ^100 {
    $KXGA.send( (100000..200000).pick );
}

my @sums = ( start react whenever $KXGA -&gt; $number {
    say "In thread ", $*THREAD.id;
    say "→ ", (^$number).sum;
} ) for ^10;

start { sleep 10; $KXGA.close(); }

await @sums;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，<code>react</code> 前置于 <code>whenever</code>，这会使从通道中读取的每个数字都变得很长。</p>
</div>
</div>
<div class="sect2">
<h3 id="_supply">74.12. supply</h3>
<div class="paragraph">
<p>关键字 <code>supply</code> 可创建您可以点击的<a href="https://docs.raku.org/language/concurrency#index-entry-supply_(on-demand)">按需供应</a>。 它与 <code>emit</code> 配对，可以在 <code>supply</code> 前缀语句中的任何位置使用它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">my &amp;cards = -&gt;  {
    my @cards = 1..10 X~ &lt;♠ ♥ ♦ ♣&gt;;
    emit($_) for @cards.pick(@cards.elems);
}
my $supply = supply cards;

$supply.tap( -&gt; $v { say "Drawing: $v" });
$supply.tap( -&gt; $v { say "Drawing: $v" }, done =&gt; { say "No more cards" });
# OUTPUT:
# [...]
# Drawing: 1♥
# Drawing: 7♥
# Drawing: 9♥
# No more cards</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_声明符原型">75. 声明符原型</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>proto</code> 是一种正式声明多个(<code>multi</code>)候选者之间的共性的方法。 它充当可以验证但不能修改参数的包装器。 考虑以下基本示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto congratulate(Str $reason, Str $name, |) {*}
multi congratulate($reason, $name) {
   say "Hooray for your $reason, $name";
}
multi congratulate($reason, $name, Int $rank) {
   say "Hooray for your $reason, $name -- got rank $rank!";
}

congratulate('being a cool number', 'Fred');     # OK
congratulate('being a cool number', 'Fred', 42); # OK</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">congratulate('being a cool number', 42);         # Proto match error</code></pre>
</div>
</div>
<div class="paragraph">
<p>原型坚持认为，所有 <code>multi congratulate</code> 都符合两个字符串，并可选地后面跟随其他参数的基本签名。 <code>|</code> 是一个未命名的 <code>Capture</code> 参数，并且允许 <code>multi</code> 接收其他参数。 前两个调用成功，但第三个调用失败（在编译时），因为 <code>42</code> 与 <code>Str</code> 不匹配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">say &amp;congratulate.signature # OUTPUT: «(Str $reason, Str $name, | is raw)␤»</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以为 <code>proto</code> 提供一个函数主体，然后将 <code>{*}</code> 放在您希望完成分派的位置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku"># attempts to notify someone -- False if unsuccessful
proto notify(Str $user, Str $msg) {
   my \hour = DateTime.now.hour;
   if hour &gt; 8 or hour &lt; 22 {
      return {*};
   } else {
      # we can't notify someone when they might be sleeping
      return False;
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>{*}</code> 始终使用其调用的参数来分派给候选者。 参数默认值和类型强制将起作用，但不会传递。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">proto mistake-proto(Str() $str, Int $number = 42) {*}
multi mistake-proto($str, $number) { say $str.^name }
mistake-proto(7, 42);  # OUTPUT: «Int␤» -- not passed on</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-raku" data-lang="raku">mistake-proto('test'); # fails -- not passed on</code></pre>
</div>
</div>
</div>
</div>

</article>


    

  </main><section class="site__search">
    <label class="site__form">
        <p class="form__label">Search around the site</p> 
        <input class="site__search-bar form__input" type="text">
    </label>
    <div class="site__search-bar-results"></div>
</section>
  
  <footer class="site__footer">
    
    
    <p class="footer__sign">© 2020 ohmyraku</p></footer>
    

    
    <script>
        window.addEventListener("load", function () {
            const script = document.createElement("script");
            script.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
            script.async = true

            document.head.appendChild(script);
        })
    </script>





<script defer type="text/javascript" src="https://ohmyraku.github.io/js/script.14164ab553b19613ce98aadb54b1ed9a89ae5b056c72b99a4c672e37954f33d67bebe1452b0279025ba889964b51bdf8ec69683933cf427ae67c08ac2cdda7b1.js" integrity="sha512-FBZKtVOxlhPOmKrbVLHtmomuWwVscrmaTGcuN5VPM9Z76&#43;FFKwJ5AluoiZZLUb347GloOTPPQnrmfAisLN2nsQ=="></script>



</body>
</html>